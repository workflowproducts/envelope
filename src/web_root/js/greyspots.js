//jslint white:true
/**
    
    ######## BEFORE UPDATING DATA-HANDLING CODE OR USING THE COALESCE OPERATOR: ######## ~michael
    don't use the pipe-pipe "||" coalesce operator when handling data because if a zero comes to the coalesce (and it is a number 0 and not a string "0") it will be evaluated as false and thus coalesce to the next operand. Whenever you use this operator: be careful of what will be evaluated.
    
    To see this in action run this in your console:
    
    console.log( true      || 'test' );  // logs:  true  (expected)
    console.log( false     || 'test' );  // logs: 'test' (expected)

    console.log( null      || 'test' );  // logs: 'test' (expected)
    console.log( undefined || 'test' );  // logs: 'test' (expected)

    console.log( '1'       || 'test' );  // logs: '1'    (expected)
    console.log(  1        || 'test' );  // logs:  1     (expected)
    console.log( '0'       || 'test' );  // logs: '0'    (expected)
    console.log(  0        || 'test' );  // logs: 'test' (OH NO!!)
    
    here is another demonstration:
    
    console.log( Boolean(true)      );
    console.log( Boolean(false)     );
    console.log( Boolean(null)      );
    console.log( Boolean(undefined) );
    console.log( Boolean('1')       );
    console.log( Boolean( 1)        );
    console.log( Boolean('0')       );
    console.log( Boolean( 0)        ); // zero evaluates to false
    
    
    ######## BEFORE UPDATING FASTCLICK: ######## ~michael
    fastclick (around line 254) has some code added (by michael) to add a feature to fastclick, bring this code to any new version
    
    it also has (around line 123) some code added to an if statement added by joseph:
        if (deviceIsAndroid || deviceIsIOS) {
    as opposed to:
        if (deviceIsAndroid) {
    
    
    ######## BEFORE UPDATING X-TAGS: ######## ~michael and nunzio
    nunzio: you have to delete '"function"==typeof define&&define.amd?define(X):"undefined"!=typeof module&&module.exports?module.exports=X:' from xtags for electron
    nunzio: the below warning now seems to be outdated
    make sure you include the polyfills and make sure that there isn't still a duplicated block of code in the source, if there is remove it, here is how to find out:
    
    do a find in textedit for: "scope.upgradeDocumentTree = nop;" (excluding the quotes of course)
    AND var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE
    
    remove the whole block of code surrounding the second match (it might be the first match but I think it is the second match)
    
    
    ######## ELEMENT REGISTRATION: ######## ~michael
    When registering a custom element:
        1) register it after the "DOMContentLoaded" event has fired. Doing this prevents an issue that we ran into where in some cases (I believe when greyspots.js is cached and you are on yosemite is one case) some elements would be cut off and would disappear.
        2) Use the "methods" for public functions only, private functions should be kept in the "DOMContentLoaded" function. By keeping the functions in there it makes it so that the code for that element is the only code that can run those functions and it prevents these functions for cluttering public namespaces.
        3) Use "'use strict';" from the beginning. If you don't start out with it you might introduce strict mode errors that you don't even know about. Then one day you might decide to put "'use strict';" in there and errors you didn't know about will appear. Some errors might appear when you first move it over and some errors might be disvovered by your users because you didn't test every little feature of the element.
    
    An example:
    
    document.addEventListener('DOMContentLoaded', function () {
        'use strict';
        
        // ### private functions go here ###
        function foobar() {
            // do stuff to "element" here (gs-new-element is the only element that can run this function)
        }
        
        xtag.register('gs-new-element', {
            lifecycle: {
                'created': function () {
                    
                }
            },
            events: {},
            accessors: {},
            methods: {
                // ### public functions go here ###
            }
        });
    });
    
    
    ######## PSEUDO ELEMENT WARNING: ######## ~michael
    In firefox I ran into an issue where the undo history of controls in a gs-form (with the attribute "save-while-typing") was being erased. Turns out the issue was caused by a CSS pseudo-element. I was using a pseudo-element for a little box attached to the form to tell the user if the form was waiting to save or saving. By changing the pseudo-element to a real element that I add and remove with Javascript the issue was fixed.
    
    If you want to use a pseudo-element: make sure it doesn't affect the undo history of elements that are children of the element that the pseudo-element is attached to. This issue could have been fixed by now.
    
    
    ######## TEMPLATE SHIM: ######## ~michael
    The template polyfill has been changed, DO NOT UPDATE. It is for old browsers, and old browsers don't change so there is should be no need for the polyfill to change.
    
    
    ######## HALLMARKS OF GOOD ELEMENT DESIGN: ######## ~michael
    
    
    
    
*//**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

// minimal template polyfill
if (typeof HTMLTemplateElement === 'undefined') {
  (function() {

    var TEMPLATE_TAG = 'template';

    var contentDoc = document.implementation.createHTMLDocument('template');

    /**
      Provides a minimal shim for the <template> element.
    */
    HTMLTemplateElement = function() {};
    HTMLTemplateElement.prototype = Object.create(HTMLElement.prototype);

    /**
      The `decorate` method moves element children to the template's `content`.
      NOTE: there is no support for dynamically adding elements to templates.
    */
    HTMLTemplateElement.decorate = function(template) {
        if (!template.content) {
            template.content = template.ownerDocument.createDocumentFragment();
        }
        var child;
        while (child = template.firstChild) {
            template.content.appendChild(child);
        }
        
        if (!template.content.children) {
            Object.defineProperty(template.content, 'children', {
                get: function() {
                    'use strict';
                    var arrChildren = [], i, len, childNodes = this.childNodes;
                    
                    for (i = 0, len = childNodes.length; i < len; i += 1) {
                        if (childNodes[i].nodeType !== 3) {
                            arrChildren.push(childNodes[i]);
                        }
                    }
                    
                    return arrChildren;
                },
                configurable: true
            });
        }
        
        //HTMLTemplateElement.bootstrap(template.content);
        
        //console.log(template.content);
        
        // add innerHTML to template
        Object.defineProperty(template, 'innerHTML', {
            get: function() {
                var o = '', fragment = this.content.cloneNode(true);//,
                    //templates = xtag.toArray(fragment.querySelectorAll(TEMPLATE_TAG)), i, l;
                
                //for (i = 0, l = templates.length; i < l; i += 1) {
                //    templates[i].outerHTML = templates[i].outerHTML;
                //    //console.log(templates[i].outerHTML);
                //}
                
                for (var e = fragment.firstChild; e; e = e.nextSibling) {
                    o += e.outerHTML || escapeData(e.data);
                }
                
                //console.log(o);
                
                return o;
            },
            set: function(text) {
                contentDoc.body.innerHTML = text;
                
                while (this.content.firstChild) {
                    this.content.removeChild(this.content.firstChild);
                }
                while (contentDoc.body.firstChild) {
                    this.content.appendChild(contentDoc.body.firstChild);
                }
                //HTMLTemplateElement.bootstrap(this.content);
            },
            configurable: true
            //writable: true
        });
      
        // add outerHTML to template
        Object.defineProperty(template, 'outerHTML', {
            get: function () {
                var openTagText, arrAttr, i, len, innerHTML = this.innerHTML;
                
                arrAttr = this.attributes;
                
                for (i = 0, len = arrAttr.length, openTagText = '<template'; i < len; i += 1) { // >
                    openTagText += ' ' + arrAttr[i].nodeName + '="' + encodeHTML(arrAttr[i].value) + '"';
                }
                
                return openTagText + '>' + innerHTML + '</template>';
            },
            configurable: true
            //writable: true
        });
    };

    /**
      The `bootstrap` method is called automatically and "fixes" all
      <template> elements in the document referenced by the `doc` argument.
    */
    HTMLTemplateElement.bootstrap = function(doc) {
        var templates = doc.querySelectorAll(TEMPLATE_TAG), i, l, t;
        
        for (i = 0, l = templates.length, t; (i < l) && (t = templates[i]); i += 1) {
            if (!GS.findParentTag(t, 'template') && GS.findParentTag(t, 'html')) {
                HTMLTemplateElement.decorate(t);
            }
        }
    };

    // auto-bootstrapping for main document
    window.addEventListener('DOMContentLoaded', function() {
      HTMLTemplateElement.bootstrap(document);
    });

    // Patch document.createElement to ensure newly created templates have content
    var createElement = document.createElement;
    document.createElement = function() {
      'use strict';
      var el = createElement.apply(document, arguments);
      if (el.localName == 'template') {
        HTMLTemplateElement.decorate(el);
      }
      return el;
    };

    var escapeDataRegExp = /[&\u00A0<>]/g;

    function escapeReplace(c) {
      switch (c) {
        case '&':
          return '&amp;';
        case '<':
          return '&lt;';
        case '>':
          return '&gt;';
        case '\u00A0':
          return '&nbsp;';
      }
    }

    function escapeData(s) {
      return s.replace(escapeDataRegExp, escapeReplace);
    }
  })();
}if (!window.hasOwnProperty('customElements')) {
    (function(){function e(e){if(this._element=e,e.className!=this._classCache){if(this._classCache=e.className,!this._classCache)return;var t,n=this._classCache.replace(/^\s+|\s+$/g,"").split(/\s+/);for(t=0;n.length>t;t++)a.call(this,n[t])}}function t(e,t){e.className=t.join(" ")}function n(e,t,n){Object.defineProperty?Object.defineProperty(e,t,{get:n}):e.__defineGetter__(t,n)}if(!(window.Element===void 0||"classList"in document.documentElement)){var r=Array.prototype,o=r.indexOf,i=r.slice,a=r.push,s=r.splice,c=r.join;e.prototype={add:function(e){this.contains(e)||(a.call(this,e),t(this._element,i.call(this,0)))},contains:function(e){return-1!==o.call(this,e)},item:function(e){return this[e]||null},remove:function(e){var n=o.call(this,e);-1!==n&&(s.call(this,n,1),t(this._element,i.call(this,0)))},toString:function(){return c.call(this," ")},toggle:function(e){-1===o.call(this,e)?this.add(e):this.remove(e)}},window.DOMTokenList=e,n(Element.prototype,"classList",function(){return new e(this)})}})(),function(){window.WebComponents=window.WebComponents||{flags:{}};var e="webcomponents-lite.js",t=document.querySelector('script[src*="'+e+'"]'),n={};if(!n.noOpts){if(location.search.slice(1).split("&").forEach(function(e){var t,r=e.split("=");r[0]&&(t=r[0].match(/wc-(.+)/))&&(n[t[1]]=r[1]||!0)}),t)for(var r,o=0;r=t.attributes[o];o++)"src"!==r.name&&(n[r.name]=r.value||!0);if(n.log&&n.log.split){var i=n.log.split(",");n.log={},i.forEach(function(e){n.log[e]=!0})}else n.log={}}n.register&&(window.CustomElements=window.CustomElements||{flags:{}},window.CustomElements.flags.register=n.register),WebComponents.flags=n}(),function(e){"use strict";function t(e){return void 0!==h[e]}function n(){s.call(this),this._isInvalid=!0}function r(e){return""==e&&n.call(this),e.toLowerCase()}function o(e){var t=e.charCodeAt(0);return t>32&&127>t&&-1==[34,35,60,62,63,96].indexOf(t)?e:encodeURIComponent(e)}function i(e){var t=e.charCodeAt(0);return t>32&&127>t&&-1==[34,35,60,62,96].indexOf(t)?e:encodeURIComponent(e)}function a(e,a,s){function c(e){y.push(e)}var u=a||"scheme start",l=0,d="",b=!1,g=!1,y=[];e:for(;(e[l-1]!=f||0==l)&&!this._isInvalid;){var w=e[l];switch(u){case"scheme start":if(!w||!m.test(w)){if(a){c("Invalid scheme.");break e}d="",u="no scheme";continue}d+=w.toLowerCase(),u="scheme";break;case"scheme":if(w&&v.test(w))d+=w.toLowerCase();else{if(":"!=w){if(a){if(f==w)break e;c("Code point not allowed in scheme: "+w);break e}d="",l=0,u="no scheme";continue}if(this._scheme=d,d="",a)break e;t(this._scheme)&&(this._isRelative=!0),u="file"==this._scheme?"relative":this._isRelative&&s&&s._scheme==this._scheme?"relative or authority":this._isRelative?"authority first slash":"scheme data"}break;case"scheme data":"?"==w?(this._query="?",u="query"):"#"==w?(this._fragment="#",u="fragment"):f!=w&&"	"!=w&&"\n"!=w&&"\r"!=w&&(this._schemeData+=o(w));break;case"no scheme":if(s&&t(s._scheme)){u="relative";continue}c("Missing scheme."),n.call(this);break;case"relative or authority":if("/"!=w||"/"!=e[l+1]){c("Expected /, got: "+w),u="relative";continue}u="authority ignore slashes";break;case"relative":if(this._isRelative=!0,"file"!=this._scheme&&(this._scheme=s._scheme),f==w){this._host=s._host,this._port=s._port,this._path=s._path.slice(),this._query=s._query,this._username=s._username,this._password=s._password;break e}if("/"==w||"\\"==w)"\\"==w&&c("\\ is an invalid code point."),u="relative slash";else if("?"==w)this._host=s._host,this._port=s._port,this._path=s._path.slice(),this._query="?",this._username=s._username,this._password=s._password,u="query";else{if("#"!=w){var _=e[l+1],E=e[l+2];("file"!=this._scheme||!m.test(w)||":"!=_&&"|"!=_||f!=E&&"/"!=E&&"\\"!=E&&"?"!=E&&"#"!=E)&&(this._host=s._host,this._port=s._port,this._username=s._username,this._password=s._password,this._path=s._path.slice(),this._path.pop()),u="relative path";continue}this._host=s._host,this._port=s._port,this._path=s._path.slice(),this._query=s._query,this._fragment="#",this._username=s._username,this._password=s._password,u="fragment"}break;case"relative slash":if("/"!=w&&"\\"!=w){"file"!=this._scheme&&(this._host=s._host,this._port=s._port,this._username=s._username,this._password=s._password),u="relative path";continue}"\\"==w&&c("\\ is an invalid code point."),u="file"==this._scheme?"file host":"authority ignore slashes";break;case"authority first slash":if("/"!=w){c("Expected '/', got: "+w),u="authority ignore slashes";continue}u="authority second slash";break;case"authority second slash":if(u="authority ignore slashes","/"!=w){c("Expected '/', got: "+w);continue}break;case"authority ignore slashes":if("/"!=w&&"\\"!=w){u="authority";continue}c("Expected authority, got: "+w);break;case"authority":if("@"==w){b&&(c("@ already seen."),d+="%40"),b=!0;for(var T=0;d.length>T;T++){var C=d[T];if("	"!=C&&"\n"!=C&&"\r"!=C)if(":"!=C||null!==this._password){var M=o(C);null!==this._password?this._password+=M:this._username+=M}else this._password="";else c("Invalid whitespace in authority.")}d=""}else{if(f==w||"/"==w||"\\"==w||"?"==w||"#"==w){l-=d.length,d="",u="host";continue}d+=w}break;case"file host":if(f==w||"/"==w||"\\"==w||"?"==w||"#"==w){2!=d.length||!m.test(d[0])||":"!=d[1]&&"|"!=d[1]?0==d.length?u="relative path start":(this._host=r.call(this,d),d="",u="relative path start"):u="relative path";continue}"	"==w||"\n"==w||"\r"==w?c("Invalid whitespace in file host."):d+=w;break;case"host":case"hostname":if(":"!=w||g){if(f==w||"/"==w||"\\"==w||"?"==w||"#"==w){if(this._host=r.call(this,d),d="",u="relative path start",a)break e;continue}"	"!=w&&"\n"!=w&&"\r"!=w?("["==w?g=!0:"]"==w&&(g=!1),d+=w):c("Invalid code point in host/hostname: "+w)}else if(this._host=r.call(this,d),d="",u="port","hostname"==a)break e;break;case"port":if(/[0-9]/.test(w))d+=w;else{if(f==w||"/"==w||"\\"==w||"?"==w||"#"==w||a){if(""!=d){var L=parseInt(d,10);L!=h[this._scheme]&&(this._port=L+""),d=""}if(a)break e;u="relative path start";continue}"	"==w||"\n"==w||"\r"==w?c("Invalid code point in port: "+w):n.call(this)}break;case"relative path start":if("\\"==w&&c("'\\' not allowed in path."),u="relative path","/"!=w&&"\\"!=w)continue;break;case"relative path":if(f!=w&&"/"!=w&&"\\"!=w&&(a||"?"!=w&&"#"!=w))"	"!=w&&"\n"!=w&&"\r"!=w&&(d+=o(w));else{"\\"==w&&c("\\ not allowed in relative path.");var O;(O=p[d.toLowerCase()])&&(d=O),".."==d?(this._path.pop(),"/"!=w&&"\\"!=w&&this._path.push("")):"."==d&&"/"!=w&&"\\"!=w?this._path.push(""):"."!=d&&("file"==this._scheme&&0==this._path.length&&2==d.length&&m.test(d[0])&&"|"==d[1]&&(d=d[0]+":"),this._path.push(d)),d="","?"==w?(this._query="?",u="query"):"#"==w&&(this._fragment="#",u="fragment")}break;case"query":a||"#"!=w?f!=w&&"	"!=w&&"\n"!=w&&"\r"!=w&&(this._query+=i(w)):(this._fragment="#",u="fragment");break;case"fragment":f!=w&&"	"!=w&&"\n"!=w&&"\r"!=w&&(this._fragment+=w)}l++}}function s(){this._scheme="",this._schemeData="",this._username="",this._password=null,this._host="",this._port="",this._path=[],this._query="",this._fragment="",this._isInvalid=!1,this._isRelative=!1}function c(e,t){void 0===t||t instanceof c||(t=new c(t+"")),this._url=e,s.call(this);var n=e.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g,"");a.call(this,n,null,t)}var u=!1;if(!e.forceJURL)try{var l=new URL("b","http://a");l.pathname="c%20d",u="http://a/c%20d"===l.href}catch(d){}if(!u){var h=Object.create(null);h.ftp=21,h.file=0,h.gopher=70,h.http=80,h.https=443,h.ws=80,h.wss=443;var p=Object.create(null);p["%2e"]=".",p[".%2e"]="..",p["%2e."]="..",p["%2e%2e"]="..";var f=void 0,m=/[a-zA-Z]/,v=/[a-zA-Z0-9\+\-\.]/;c.prototype={toString:function(){return this.href},get href(){if(this._isInvalid)return this._url;var e="";return(""!=this._username||null!=this._password)&&(e=this._username+(null!=this._password?":"+this._password:"")+"@"),this.protocol+(this._isRelative?"//"+e+this.host:"")+this.pathname+this._query+this._fragment},set href(e){s.call(this),a.call(this,e)},get protocol(){return this._scheme+":"},set protocol(e){this._isInvalid||a.call(this,e+":","scheme start")},get host(){return this._isInvalid?"":this._port?this._host+":"+this._port:this._host},set host(e){!this._isInvalid&&this._isRelative&&a.call(this,e,"host")},get hostname(){return this._host},set hostname(e){!this._isInvalid&&this._isRelative&&a.call(this,e,"hostname")},get port(){return this._port},set port(e){!this._isInvalid&&this._isRelative&&a.call(this,e,"port")},get pathname(){return this._isInvalid?"":this._isRelative?"/"+this._path.join("/"):this._schemeData},set pathname(e){!this._isInvalid&&this._isRelative&&(this._path=[],a.call(this,e,"relative path start"))},get search(){return this._isInvalid||!this._query||"?"==this._query?"":this._query},set search(e){!this._isInvalid&&this._isRelative&&(this._query="?","?"==e[0]&&(e=e.slice(1)),a.call(this,e,"query"))},get hash(){return this._isInvalid||!this._fragment||"#"==this._fragment?"":this._fragment},set hash(e){this._isInvalid||(this._fragment="#","#"==e[0]&&(e=e.slice(1)),a.call(this,e,"fragment"))},get origin(){var e;if(this._isInvalid||!this._scheme)return"";switch(this._scheme){case"data":case"file":case"javascript":case"mailto":return"null"}return e=this.host,e?this._scheme+"://"+e:""}};var b=e.URL;b&&(c.createObjectURL=function(){return b.createObjectURL.apply(b,arguments)},c.revokeObjectURL=function(e){b.revokeObjectURL(e)}),e.URL=c}}(self),"undefined"==typeof WeakMap&&function(){var e=Object.defineProperty,t=Date.now()%1e9,n=function(){this.name="__st"+(1e9*Math.random()>>>0)+(t++ +"__")};n.prototype={set:function(t,n){var r=t[this.name];return r&&r[0]===t?r[1]=n:e(t,this.name,{value:[t,n],writable:!0}),this},get:function(e){var t;return(t=e[this.name])&&t[0]===e?t[1]:void 0},"delete":function(e){var t=e[this.name];return t&&t[0]===e?(t[0]=t[1]=void 0,!0):!1},has:function(e){var t=e[this.name];return t?t[0]===e:!1}},window.WeakMap=n}(),function(e){function t(e){w.push(e),y||(y=!0,m(r))}function n(e){return window.ShadowDOMPolyfill&&window.ShadowDOMPolyfill.wrapIfNeeded(e)||e}function r(){y=!1;var e=w;w=[],e.sort(function(e,t){return e.uid_-t.uid_});var t=!1;e.forEach(function(e){var n=e.takeRecords();o(e),n.length&&(e.callback_(n,e),t=!0)}),t&&r()}function o(e){e.nodes_.forEach(function(t){var n=v.get(t);n&&n.forEach(function(t){t.observer===e&&t.removeTransientObservers()})})}function i(e,t){for(var n=e;n;n=n.parentNode){var r=v.get(n);if(r)for(var o=0;r.length>o;o++){var i=r[o],a=i.options;if(n===e||a.subtree){var s=t(a);s&&i.enqueue(s)}}}}function a(e){this.callback_=e,this.nodes_=[],this.records_=[],this.uid_=++_}function s(e,t){this.type=e,this.target=t,this.addedNodes=[],this.removedNodes=[],this.previousSibling=null,this.nextSibling=null,this.attributeName=null,this.attributeNamespace=null,this.oldValue=null}function c(e){var t=new s(e.type,e.target);return t.addedNodes=e.addedNodes.slice(),t.removedNodes=e.removedNodes.slice(),t.previousSibling=e.previousSibling,t.nextSibling=e.nextSibling,t.attributeName=e.attributeName,t.attributeNamespace=e.attributeNamespace,t.oldValue=e.oldValue,t}function u(e,t){return E=new s(e,t)}function l(e){return T?T:(T=c(E),T.oldValue=e,T)}function d(){E=T=void 0}function h(e){return e===T||e===E}function p(e,t){return e===t?e:T&&h(e)?T:null}function f(e,t,n){this.observer=e,this.target=t,this.options=n,this.transientObservedNodes=[]}if(!e.JsMutationObserver){var m,v=new WeakMap;if(/Trident|Edge/.test(navigator.userAgent))m=setTimeout;else if(window.setImmediate)m=window.setImmediate;else{var b=[],g=Math.random()+"";window.addEventListener("message",function(e){if(e.data===g){var t=b;b=[],t.forEach(function(e){e()})}}),m=function(e){b.push(e),window.postMessage(g,"*")}}var y=!1,w=[],_=0;a.prototype={observe:function(e,t){if(e=n(e),!t.childList&&!t.attributes&&!t.characterData||t.attributeOldValue&&!t.attributes||t.attributeFilter&&t.attributeFilter.length&&!t.attributes||t.characterDataOldValue&&!t.characterData)throw new SyntaxError;var r=v.get(e);r||v.set(e,r=[]);for(var o,i=0;r.length>i;i++)if(r[i].observer===this){o=r[i],o.removeListeners(),o.options=t;break}o||(o=new f(this,e,t),r.push(o),this.nodes_.push(e)),o.addListeners()},disconnect:function(){this.nodes_.forEach(function(e){for(var t=v.get(e),n=0;t.length>n;n++){var r=t[n];if(r.observer===this){r.removeListeners(),t.splice(n,1);break}}},this),this.records_=[]},takeRecords:function(){var e=this.records_;return this.records_=[],e}};var E,T;f.prototype={enqueue:function(e){var n=this.observer.records_,r=n.length;if(n.length>0){var o=n[r-1],i=p(o,e);if(i)return n[r-1]=i,void 0}else t(this.observer);n[r]=e},addListeners:function(){this.addListeners_(this.target)},addListeners_:function(e){var t=this.options;t.attributes&&e.addEventListener("DOMAttrModified",this,!0),t.characterData&&e.addEventListener("DOMCharacterDataModified",this,!0),t.childList&&e.addEventListener("DOMNodeInserted",this,!0),(t.childList||t.subtree)&&e.addEventListener("DOMNodeRemoved",this,!0)},removeListeners:function(){this.removeListeners_(this.target)},removeListeners_:function(e){var t=this.options;t.attributes&&e.removeEventListener("DOMAttrModified",this,!0),t.characterData&&e.removeEventListener("DOMCharacterDataModified",this,!0),t.childList&&e.removeEventListener("DOMNodeInserted",this,!0),(t.childList||t.subtree)&&e.removeEventListener("DOMNodeRemoved",this,!0)},addTransientObserver:function(e){if(e!==this.target){this.addListeners_(e),this.transientObservedNodes.push(e);var t=v.get(e);t||v.set(e,t=[]),t.push(this)}},removeTransientObservers:function(){var e=this.transientObservedNodes;this.transientObservedNodes=[],e.forEach(function(e){this.removeListeners_(e);for(var t=v.get(e),n=0;t.length>n;n++)if(t[n]===this){t.splice(n,1);break}},this)},handleEvent:function(e){switch(e.stopImmediatePropagation(),e.type){case"DOMAttrModified":var t=e.attrName,n=e.relatedNode.namespaceURI,r=e.target,o=new u("attributes",r);o.attributeName=t,o.attributeNamespace=n;var a=e.attrChange===MutationEvent.ADDITION?null:e.prevValue;i(r,function(e){return!e.attributes||e.attributeFilter&&e.attributeFilter.length&&-1===e.attributeFilter.indexOf(t)&&-1===e.attributeFilter.indexOf(n)?void 0:e.attributeOldValue?l(a):o});break;case"DOMCharacterDataModified":var r=e.target,o=u("characterData",r),a=e.prevValue;i(r,function(e){return e.characterData?e.characterDataOldValue?l(a):o:void 0});break;case"DOMNodeRemoved":this.addTransientObserver(e.target);case"DOMNodeInserted":var s,c,h=e.target;"DOMNodeInserted"===e.type?(s=[h],c=[]):(s=[],c=[h]);var p=h.previousSibling,f=h.nextSibling,o=u("childList",e.target.parentNode);o.addedNodes=s,o.removedNodes=c,o.previousSibling=p,o.nextSibling=f,i(e.relatedNode,function(e){return e.childList?o:void 0})}d()}},e.JsMutationObserver=a,e.MutationObserver||(e.MutationObserver=a,a._isPolyfilled=!0)}}(self),"undefined"==typeof HTMLTemplateElement&&function(){function e(e){switch(e){case"&":return"&amp;";case"<":return"&lt;";case">":return"&gt;";case"Â ":return"&nbsp;"}}function t(t){return t.replace(a,e)}var n="template",r=document.implementation.createHTMLDocument("template"),o=!0;HTMLTemplateElement=function(){},HTMLTemplateElement.prototype=Object.create(HTMLElement.prototype),HTMLTemplateElement.decorate=function(e){if(!e.content){e.content=r.createDocumentFragment();for(var n;n=e.firstChild;)e.content.appendChild(n);if(o)try{Object.defineProperty(e,"innerHTML",{get:function(){for(var e="",n=this.content.firstChild;n;n=n.nextSibling)e+=n.outerHTML||t(n.data);return e},set:function(e){for(r.body.innerHTML=e,HTMLTemplateElement.bootstrap(r);this.content.firstChild;)this.content.removeChild(this.content.firstChild);for(;r.body.firstChild;)this.content.appendChild(r.body.firstChild)},configurable:!0})}catch(i){o=!1}HTMLTemplateElement.bootstrap(e.content)}},HTMLTemplateElement.bootstrap=function(e){for(var t,r=e.querySelectorAll(n),o=0,i=r.length;i>o&&(t=r[o]);o++)HTMLTemplateElement.decorate(t)},document.addEventListener("DOMContentLoaded",function(){HTMLTemplateElement.bootstrap(document)});var i=document.createElement;document.createElement=function(){"use strict";var e=i.apply(document,arguments);return"template"==e.localName&&HTMLTemplateElement.decorate(e),e};var a=/[&\u00A0<>]/g}(),function(){"use strict";if(!window.performance){var e=Date.now();window.performance={now:function(){return Date.now()-e}}}window.requestAnimationFrame||(window.requestAnimationFrame=function(){var e=window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame;return e?function(t){return e(function(){t(performance.now())})}:function(e){return window.setTimeout(e,1e3/60)}}()),window.cancelAnimationFrame||(window.cancelAnimationFrame=function(){return window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||function(e){clearTimeout(e)}}());var t=function(){var e=document.createEvent("Event");return e.initEvent("foo",!0,!0),e.preventDefault(),e.defaultPrevented}();if(!t){var n=Event.prototype.preventDefault;Event.prototype.preventDefault=function(){this.cancelable&&(n.call(this),Object.defineProperty(this,"defaultPrevented",{get:function(){return!0},configurable:!0}))}}var r=/Trident/.test(navigator.userAgent);if((!window.CustomEvent||r&&"function"!=typeof window.CustomEvent)&&(window.CustomEvent=function(e,t){t=t||{};var n=document.createEvent("CustomEvent");return n.initCustomEvent(e,Boolean(t.bubbles),Boolean(t.cancelable),t.detail),n},window.CustomEvent.prototype=window.Event.prototype),!window.Event||r&&"function"!=typeof window.Event){var o=window.Event;window.Event=function(e,t){t=t||{};var n=document.createEvent("Event");return n.initEvent(e,Boolean(t.bubbles),Boolean(t.cancelable)),n},window.Event.prototype=o.prototype}}(window.WebComponents),window.HTMLImports=window.HTMLImports||{flags:{}},function(e){function t(e,t){t=t||f,r(function(){i(e,t)},t)}function n(e){return"complete"===e.readyState||e.readyState===b}function r(e,t){if(n(t))e&&e();else{var o=function(){("complete"===t.readyState||t.readyState===b)&&(t.removeEventListener(g,o),r(e,t))};t.addEventListener(g,o)}}function o(e){e.target.__loaded=!0}function i(e,t){function n(){c==u&&e&&e({allImports:s,loadedImports:l,errorImports:d})}function r(e){o(e),l.push(this),c++,n()}function i(){d.push(this),c++,n()}var s=t.querySelectorAll("link[rel=import]"),c=0,u=s.length,l=[],d=[];if(u)for(var h,p=0;u>p&&(h=s[p]);p++)a(h)?(l.push(this),c++,n()):(h.addEventListener("load",r),h.addEventListener("error",i));else n()}function a(e){return d?e.__loaded||e.import&&"loading"!==e.import.readyState:e.__importParsed}function s(e){for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)c(t)&&u(t)}function c(e){return"link"===e.localName&&"import"===e.rel}function u(e){var t=e.import;t?o({target:e}):(e.addEventListener("load",o),e.addEventListener("error",o))}var l="import",d=Boolean(l in document.createElement("link")),h=Boolean(window.ShadowDOMPolyfill),p=function(e){return h?window.ShadowDOMPolyfill.wrapIfNeeded(e):e},f=p(document),m={get:function(){var e=window.HTMLImports.currentScript||document.currentScript||("complete"!==document.readyState?document.scripts[document.scripts.length-1]:null);return p(e)},configurable:!0};Object.defineProperty(document,"_currentScript",m),Object.defineProperty(f,"_currentScript",m);var v=/Trident/.test(navigator.userAgent),b=v?"complete":"interactive",g="readystatechange";d&&(new MutationObserver(function(e){for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)t.addedNodes&&s(t.addedNodes)}).observe(document.head,{childList:!0}),function(){if("loading"===document.readyState)for(var e,t=document.querySelectorAll("link[rel=import]"),n=0,r=t.length;r>n&&(e=t[n]);n++)u(e)}()),t(function(e){window.HTMLImports.ready=!0,window.HTMLImports.readyTime=(new Date).getTime();var t=f.createEvent("CustomEvent");t.initCustomEvent("HTMLImportsLoaded",!0,!0,e),f.dispatchEvent(t)}),e.IMPORT_LINK_TYPE=l,e.useNative=d,e.rootDocument=f,e.whenReady=t,e.isIE=v}(window.HTMLImports),function(e){var t=[],n=function(e){t.push(e)},r=function(){t.forEach(function(t){t(e)})};e.addModule=n,e.initializeModules=r}(window.HTMLImports),window.HTMLImports.addModule(function(e){var t=/(url\()([^)]*)(\))/g,n=/(@import[\s]+(?!url\())([^;]*)(;)/g,r={resolveUrlsInStyle:function(e,t){var n=e.ownerDocument,r=n.createElement("a");return e.textContent=this.resolveUrlsInCssText(e.textContent,t,r),e},resolveUrlsInCssText:function(e,r,o){var i=this.replaceUrls(e,o,r,t);return i=this.replaceUrls(i,o,r,n)},replaceUrls:function(e,t,n,r){return e.replace(r,function(e,r,o,i){var a=o.replace(/["']/g,"");return n&&(a=new URL(a,n).href),t.href=a,a=t.href,r+"'"+a+"'"+i})}};e.path=r}),window.HTMLImports.addModule(function(e){var t={async:!0,ok:function(e){return e.status>=200&&300>e.status||304===e.status||0===e.status},load:function(n,r,o){var i=new XMLHttpRequest;return(e.flags.debug||e.flags.bust)&&(n+="?"+Math.random()),i.open("GET",n,t.async),i.addEventListener("readystatechange",function(e){if(4===i.readyState){var n=null;try{var a=i.getResponseHeader("Location");a&&(n="/"===a.substr(0,1)?location.origin+a:a)}catch(e){console.error(e.message)}r.call(o,!t.ok(i)&&i,i.response||i.responseText,n)}}),i.send(),i},loadDocument:function(e,t,n){this.load(e,t,n).responseType="document"}};e.xhr=t}),window.HTMLImports.addModule(function(e){var t=e.xhr,n=e.flags,r=function(e,t){this.cache={},this.onload=e,this.oncomplete=t,this.inflight=0,this.pending={}};r.prototype={addNodes:function(e){this.inflight+=e.length;for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)this.require(t);this.checkDone()},addNode:function(e){this.inflight++,this.require(e),this.checkDone()},require:function(e){var t=e.src||e.href;e.__nodeUrl=t,this.dedupe(t,e)||this.fetch(t,e)},dedupe:function(e,t){return this.pending[e]?(this.pending[e].push(t),!0):this.cache[e]?(this.onload(e,t,this.cache[e]),this.tail(),!0):(this.pending[e]=[t],!1)},fetch:function(e,r){if(n.load&&console.log("fetch",e,r),e)if(e.match(/^data:/)){var o=e.split(","),i=o[0],a=o[1];a=i.indexOf(";base64")>-1?atob(a):decodeURIComponent(a),setTimeout(function(){this.receive(e,r,null,a)}.bind(this),0)}else{var s=function(t,n,o){this.receive(e,r,t,n,o)}.bind(this);t.load(e,s)}else setTimeout(function(){this.receive(e,r,{error:"href must be specified"},null)}.bind(this),0)},receive:function(e,t,n,r,o){this.cache[e]=r;for(var i,a=this.pending[e],s=0,c=a.length;c>s&&(i=a[s]);s++)this.onload(e,i,r,n,o),this.tail();this.pending[e]=null},tail:function(){--this.inflight,this.checkDone()},checkDone:function(){this.inflight||this.oncomplete()}},e.Loader=r}),window.HTMLImports.addModule(function(e){var t=function(e){this.addCallback=e,this.mo=new MutationObserver(this.handler.bind(this))};t.prototype={handler:function(e){for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)"childList"===t.type&&t.addedNodes.length&&this.addedNodes(t.addedNodes)},addedNodes:function(e){this.addCallback&&this.addCallback(e);for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)t.children&&t.children.length&&this.addedNodes(t.children)},observe:function(e){this.mo.observe(e,{childList:!0,subtree:!0})}},e.Observer=t}),window.HTMLImports.addModule(function(e){function t(e){return"link"===e.localName&&e.rel===l}function n(e){var t=r(e);return"data:text/javascript;charset=utf-8,"+encodeURIComponent(t)}function r(e){return e.textContent+o(e)}function o(e){var t=e.ownerDocument;t.__importedScripts=t.__importedScripts||0;var n=e.ownerDocument.baseURI,r=t.__importedScripts?"-"+t.__importedScripts:"";return t.__importedScripts++,"\n//# sourceURL="+n+r+".js\n"}function i(e){var t=e.ownerDocument.createElement("style");return t.textContent=e.textContent,a.resolveUrlsInStyle(t),t}var a=e.path,s=e.rootDocument,c=e.flags,u=e.isIE,l=e.IMPORT_LINK_TYPE,d="link[rel="+l+"]",h={documentSelectors:d,importsSelectors:[d,"link[rel=stylesheet]:not([type])","style:not([type])","script:not([type])",'script[type="application/javascript"]','script[type="text/javascript"]'].join(","),map:{link:"parseLink",script:"parseScript",style:"parseStyle"},dynamicElements:[],parseNext:function(){var e=this.nextToParse();e&&this.parse(e)},parse:function(e){if(this.isParsed(e))return c.parse&&console.log("[%s] is already parsed",e.localName),void 0;var t=this[this.map[e.localName]];t&&(this.markParsing(e),t.call(this,e))},parseDynamic:function(e,t){this.dynamicElements.push(e),t||this.parseNext()},markParsing:function(e){c.parse&&console.log("parsing",e),this.parsingElement=e},markParsingComplete:function(e){e.__importParsed=!0,this.markDynamicParsingComplete(e),e.__importElement&&(e.__importElement.__importParsed=!0,this.markDynamicParsingComplete(e.__importElement)),this.parsingElement=null,c.parse&&console.log("completed",e)},markDynamicParsingComplete:function(e){var t=this.dynamicElements.indexOf(e);t>=0&&this.dynamicElements.splice(t,1)},parseImport:function(e){if(e.import=e.__doc,window.HTMLImports.__importsParsingHook&&window.HTMLImports.__importsParsingHook(e),e.import&&(e.import.__importParsed=!0),this.markParsingComplete(e),e.__resource&&!e.__error?e.dispatchEvent(new CustomEvent("load",{bubbles:!1})):e.dispatchEvent(new CustomEvent("error",{bubbles:!1})),e.__pending)for(var t;e.__pending.length;)t=e.__pending.shift(),t&&t({target:e});this.parseNext()},parseLink:function(e){t(e)?this.parseImport(e):(e.href=e.href,this.parseGeneric(e))},parseStyle:function(e){var t=e;e=i(e),t.__appliedElement=e,e.__importElement=t,this.parseGeneric(e)},parseGeneric:function(e){this.trackElement(e),this.addElementToDocument(e)},rootImportForElement:function(e){for(var t=e;t.ownerDocument.__importLink;)t=t.ownerDocument.__importLink;return t},addElementToDocument:function(e){var t=this.rootImportForElement(e.__importElement||e);t.parentNode.insertBefore(e,t)},trackElement:function(e,t){var n=this,r=function(o){e.removeEventListener("load",r),e.removeEventListener("error",r),t&&t(o),n.markParsingComplete(e),n.parseNext()};if(e.addEventListener("load",r),e.addEventListener("error",r),u&&"style"===e.localName){var o=!1;if(-1==e.textContent.indexOf("@import"))o=!0;else if(e.sheet){o=!0;for(var i,a=e.sheet.cssRules,s=a?a.length:0,c=0;s>c&&(i=a[c]);c++)i.type===CSSRule.IMPORT_RULE&&(o=o&&Boolean(i.styleSheet))}o&&setTimeout(function(){e.dispatchEvent(new CustomEvent("load",{bubbles:!1}))})}},parseScript:function(t){var r=document.createElement("script");r.__importElement=t,r.src=t.src?t.src:n(t),e.currentScript=t,this.trackElement(r,function(){r.parentNode&&r.parentNode.removeChild(r),e.currentScript=null}),this.addElementToDocument(r)},nextToParse:function(){return this._mayParse=[],!this.parsingElement&&(this.nextToParseInDoc(s)||this.nextToParseDynamic())},nextToParseInDoc:function(e,n){if(e&&0>this._mayParse.indexOf(e)){this._mayParse.push(e);for(var r,o=e.querySelectorAll(this.parseSelectorsForNode(e)),i=0,a=o.length;a>i&&(r=o[i]);i++)if(!this.isParsed(r))return this.hasResource(r)?t(r)?this.nextToParseInDoc(r.__doc,r):r:void 0}return n},nextToParseDynamic:function(){return this.dynamicElements[0]},parseSelectorsForNode:function(e){var t=e.ownerDocument||e;return t===s?this.documentSelectors:this.importsSelectors},isParsed:function(e){return e.__importParsed},needsDynamicParsing:function(e){return this.dynamicElements.indexOf(e)>=0},hasResource:function(e){return t(e)&&void 0===e.__doc?!1:!0}};e.parser=h,e.IMPORT_SELECTOR=d}),window.HTMLImports.addModule(function(e){function t(e){return n(e,a)}function n(e,t){return"link"===e.localName&&e.getAttribute("rel")===t}function r(e){return!!Object.getOwnPropertyDescriptor(e,"baseURI")}function o(e,t){var n=document.implementation.createHTMLDocument(a);n._URL=t;var o=n.createElement("base");o.setAttribute("href",t),n.baseURI||r(n)||Object.defineProperty(n,"baseURI",{value:t});var i=n.createElement("meta");return i.setAttribute("charset","utf-8"),n.head.appendChild(i),n.head.appendChild(o),n.body.innerHTML=e,window.HTMLTemplateElement&&HTMLTemplateElement.bootstrap&&HTMLTemplateElement.bootstrap(n),n}var i=e.flags,a=e.IMPORT_LINK_TYPE,s=e.IMPORT_SELECTOR,c=e.rootDocument,u=e.Loader,l=e.Observer,d=e.parser,h={documents:{},documentPreloadSelectors:s,importsPreloadSelectors:[s].join(","),loadNode:function(e){p.addNode(e)},loadSubtree:function(e){var t=this.marshalNodes(e);p.addNodes(t)},marshalNodes:function(e){return e.querySelectorAll(this.loadSelectorsForNode(e))},loadSelectorsForNode:function(e){var t=e.ownerDocument||e;return t===c?this.documentPreloadSelectors:this.importsPreloadSelectors},loaded:function(e,n,r,a,s){if(i.load&&console.log("loaded",e,n),n.__resource=r,n.__error=a,t(n)){var c=this.documents[e];void 0===c&&(c=a?null:o(r,s||e),c&&(c.__importLink=n,this.bootDocument(c)),this.documents[e]=c),n.__doc=c}d.parseNext()},bootDocument:function(e){this.loadSubtree(e),this.observer.observe(e),d.parseNext()},loadedAll:function(){d.parseNext()}},p=new u(h.loaded.bind(h),h.loadedAll.bind(h));if(h.observer=new l,!document.baseURI){var f={get:function(){var e=document.querySelector("base");return e?e.href:window.location.href},configurable:!0};Object.defineProperty(document,"baseURI",f),Object.defineProperty(c,"baseURI",f)}e.importer=h,e.importLoader=p}),window.HTMLImports.addModule(function(e){var t=e.parser,n=e.importer,r={added:function(e){for(var r,o,i,a,s=0,c=e.length;c>s&&(a=e[s]);s++)r||(r=a.ownerDocument,o=t.isParsed(r)),i=this.shouldLoadNode(a),i&&n.loadNode(a),this.shouldParseNode(a)&&o&&t.parseDynamic(a,i)},shouldLoadNode:function(e){return 1===e.nodeType&&o.call(e,n.loadSelectorsForNode(e))},shouldParseNode:function(e){return 1===e.nodeType&&o.call(e,t.parseSelectorsForNode(e))}};n.observer.addCallback=r.added.bind(r);var o=HTMLElement.prototype.matches||HTMLElement.prototype.matchesSelector||HTMLElement.prototype.webkitMatchesSelector||HTMLElement.prototype.mozMatchesSelector||HTMLElement.prototype.msMatchesSelector}),function(e){function t(){window.HTMLImports.importer.bootDocument(r)}var n=e.initializeModules;if(e.isIE,!e.useNative){n();var r=e.rootDocument;"complete"===document.readyState||"interactive"===document.readyState&&!window.attachEvent?t():document.addEventListener("DOMContentLoaded",t)}}(window.HTMLImports),window.CustomElements=window.CustomElements||{flags:{}},function(e){var t=e.flags,n=[],r=function(e){n.push(e)},o=function(){n.forEach(function(t){t(e)})};e.addModule=r,e.initializeModules=o,e.hasNative=Boolean(document.registerElement),e.isIE=/Trident/.test(navigator.userAgent),e.useNative=!t.register&&e.hasNative&&!window.ShadowDOMPolyfill&&(!window.HTMLImports||window.HTMLImports.useNative)}(window.CustomElements),window.CustomElements.addModule(function(e){function t(e,t){n(e,function(e){return t(e)?!0:(r(e,t),void 0)}),r(e,t)}function n(e,t,r){var o=e.firstElementChild;if(!o)for(o=e.firstChild;o&&o.nodeType!==Node.ELEMENT_NODE;)o=o.nextSibling;for(;o;)t(o,r)!==!0&&n(o,t,r),o=o.nextElementSibling;return null}function r(e,n){for(var r=e.shadowRoot;r;)t(r,n),r=r.olderShadowRoot}function o(e,t){i(e,t,[])}function i(e,t,n){if(e=window.wrap(e),!(n.indexOf(e)>=0)){n.push(e);for(var r,o=e.querySelectorAll("link[rel="+a+"]"),s=0,c=o.length;c>s&&(r=o[s]);s++)r.import&&i(r.import,t,n);t(e)}}var a=window.HTMLImports?window.HTMLImports.IMPORT_LINK_TYPE:"none";e.forDocumentTree=o,e.forSubtree=t}),window.CustomElements.addModule(function(e){function t(e,t){return n(e,t)||r(e,t)}function n(t,n){return e.upgrade(t,n)?!0:(n&&a(t),void 0)}function r(e,t){y(e,function(e){return n(e,t)?!0:void 0})}function o(e){T.push(e),E||(E=!0,setTimeout(i))}function i(){E=!1;for(var e,t=T,n=0,r=t.length;r>n&&(e=t[n]);n++)e();T=[]}function a(e){_?o(function(){s(e)}):s(e)}function s(e){e.__upgraded__&&!e.__attached&&(e.__attached=!0,e.attachedCallback&&e.attachedCallback())}function c(e){u(e),y(e,function(e){u(e)})}function u(e){_?o(function(){l(e)}):l(e)}function l(e){e.__upgraded__&&e.__attached&&(e.__attached=!1,e.detachedCallback&&e.detachedCallback())}function d(e){for(var t=e,n=window.wrap(document);t;){if(t==n)return!0;t=t.parentNode||t.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&t.host}}function h(e){if(e.shadowRoot&&!e.shadowRoot.__watched){g.dom&&console.log("watching shadow-root for: ",e.localName);
    for(var t=e.shadowRoot;t;)m(t),t=t.olderShadowRoot}}function p(e,n){if(g.dom){var r=n[0];if(r&&"childList"===r.type&&r.addedNodes&&r.addedNodes){for(var o=r.addedNodes[0];o&&o!==document&&!o.host;)o=o.parentNode;var i=o&&(o.URL||o._URL||o.host&&o.host.localName)||"";i=i.split("/?").shift().split("/").pop()}console.group("mutations (%d) [%s]",n.length,i||"")}var a=d(e);n.forEach(function(e){"childList"===e.type&&(C(e.addedNodes,function(e){e.localName&&t(e,a)}),C(e.removedNodes,function(e){e.localName&&c(e)}))}),g.dom&&console.groupEnd()}function f(e){for(e=window.wrap(e),e||(e=window.wrap(document));e.parentNode;)e=e.parentNode;var t=e.__observer;t&&(p(e,t.takeRecords()),i())}function m(e){if(!e.__observer){var t=new MutationObserver(p.bind(this,e));t.observe(e,{childList:!0,subtree:!0}),e.__observer=t}}function v(e){e=window.wrap(e),g.dom&&console.group("upgradeDocument: ",e.baseURI.split("/").pop());var n=e===window.wrap(document);t(e,n),m(e),g.dom&&console.groupEnd()}function b(e){w(e,v)}var g=e.flags,y=e.forSubtree,w=e.forDocumentTree,_=window.MutationObserver._isPolyfilled&&g["throttle-attached"];e.hasPolyfillMutations=_,e.hasThrottledAttached=_;var E=!1,T=[],C=Array.prototype.forEach.call.bind(Array.prototype.forEach),M=Element.prototype.createShadowRoot;M&&(Element.prototype.createShadowRoot=function(){var e=M.call(this);return window.CustomElements.watchShadow(this),e}),e.watchShadow=h,e.upgradeDocumentTree=b,e.upgradeDocument=v,e.upgradeSubtree=r,e.upgradeAll=t,e.attached=a,e.takeRecords=f}),window.CustomElements.addModule(function(e){function t(t,r){if("template"===t.localName&&window.HTMLTemplateElement&&HTMLTemplateElement.decorate&&HTMLTemplateElement.decorate(t),!t.__upgraded__&&t.nodeType===Node.ELEMENT_NODE){var o=t.getAttribute("is"),i=e.getRegisteredDefinition(t.localName)||e.getRegisteredDefinition(o);if(i&&(o&&i.tag==t.localName||!o&&!i.extends))return n(t,i,r)}}function n(t,n,o){return a.upgrade&&console.group("upgrade:",t.localName),n.is&&t.setAttribute("is",n.is),r(t,n),t.__upgraded__=!0,i(t),o&&e.attached(t),e.upgradeSubtree(t,o),a.upgrade&&console.groupEnd(),t}function r(e,t){Object.__proto__?e.__proto__=t.prototype:(o(e,t.prototype,t.native),e.__proto__=t.prototype)}function o(e,t,n){for(var r={},o=t;o!==n&&o!==HTMLElement.prototype;){for(var i,a=Object.getOwnPropertyNames(o),s=0;i=a[s];s++)r[i]||(Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(o,i)),r[i]=1);o=Object.getPrototypeOf(o)}}function i(e){e.createdCallback&&e.createdCallback()}var a=e.flags;e.upgrade=t,e.upgradeWithDefinition=n,e.implementPrototype=r}),window.CustomElements.addModule(function(e){function t(t,r){var c=r||{};if(!t)throw Error("document.registerElement: first argument `name` must not be empty");if(0>t.indexOf("-"))throw Error("document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '"+(t+"")+"'.");if(o(t))throw Error("Failed to execute 'registerElement' on 'Document': Registration failed for type '"+(t+"")+"'. The type name is invalid.");if(u(t))throw Error("DuplicateDefinitionError: a type with name '"+(t+"")+"' is already registered");return c.prototype||(c.prototype=Object.create(HTMLElement.prototype)),c.__name=t.toLowerCase(),c.lifecycle=c.lifecycle||{},c.ancestry=i(c.extends),a(c),s(c),n(c.prototype),l(c.__name,c),c.ctor=d(c),c.ctor.prototype=c.prototype,c.prototype.constructor=c.ctor,e.ready&&b(document),c.ctor}function n(e){if(!e.setAttribute._polyfilled){var t=e.setAttribute;e.setAttribute=function(e,n){r.call(this,e,n,t)};var n=e.removeAttribute;e.removeAttribute=function(e){r.call(this,e,null,n)},e.setAttribute._polyfilled=!0}}function r(e,t,n){e=e.toLowerCase();var r=this.getAttribute(e);n.apply(this,arguments);var o=this.getAttribute(e);this.attributeChangedCallback&&o!==r&&this.attributeChangedCallback(e,r,o)}function o(e){for(var t=0;E.length>t;t++)if(e===E[t])return!0}function i(e){var t=u(e);return t?i(t.extends).concat([t]):[]}function a(e){for(var t,n=e.extends,r=0;t=e.ancestry[r];r++)n=t.is&&t.tag;e.tag=n||e.__name,n&&(e.is=e.__name)}function s(e){if(!Object.__proto__){var t=HTMLElement.prototype;if(e.is){var n=document.createElement(e.tag);t=Object.getPrototypeOf(n)}for(var r,o=e.prototype,i=!1;o;)o==t&&(i=!0),r=Object.getPrototypeOf(o),r&&(o.__proto__=r),o=r;i||console.warn(e.tag+" prototype not found in prototype chain for "+e.is),e.native=t}}function c(e){return y(M(e.tag),e)}function u(e){return e?T[e.toLowerCase()]:void 0}function l(e,t){T[e]=t}function d(e){return function(){return c(e)}}function h(e,t,n){return e===C?p(t,n):L(e,t)}function p(e,t){e&&(e=e.toLowerCase()),t&&(t=t.toLowerCase());var n=u(t||e);if(n){if(e==n.tag&&t==n.is)return new n.ctor;if(!t&&!n.is)return new n.ctor}var r;return t?(r=p(e),r.setAttribute("is",t),r):(r=M(e),e.indexOf("-")>=0&&w(r,HTMLElement),r)}function f(e,t){var n=e[t];e[t]=function(){var e=n.apply(this,arguments);return g(e),e}}var m,v=e.isIE,b=e.upgradeDocumentTree,g=e.upgradeAll,y=e.upgradeWithDefinition,w=e.implementPrototype,_=e.useNative,E=["annotation-xml","color-profile","font-face","font-face-src","font-face-uri","font-face-format","font-face-name","missing-glyph"],T={},C="http://www.w3.org/1999/xhtml",M=document.createElement.bind(document),L=document.createElementNS.bind(document);m=Object.__proto__||_?function(e,t){return e instanceof t}:function(e,t){if(e instanceof t)return!0;for(var n=e;n;){if(n===t.prototype)return!0;n=n.__proto__}return!1},f(Node.prototype,"cloneNode"),f(document,"importNode"),v&&function(){var e=document.importNode;document.importNode=function(){var t=e.apply(document,arguments);if(t.nodeType==t.DOCUMENT_FRAGMENT_NODE){var n=document.createDocumentFragment();return n.appendChild(t),n}return t}}(),document.registerElement=t,document.createElement=p,document.createElementNS=h,e.registry=T,e.instanceof=m,e.reservedTagList=E,e.getRegisteredDefinition=u,document.register=document.registerElement}),function(e){function t(){i(window.wrap(document)),window.CustomElements.ready=!0;var e=window.requestAnimationFrame||function(e){setTimeout(e,16)};e(function(){setTimeout(function(){window.CustomElements.readyTime=Date.now(),window.HTMLImports&&(window.CustomElements.elapsed=window.CustomElements.readyTime-window.HTMLImports.readyTime),document.dispatchEvent(new CustomEvent("WebComponentsReady",{bubbles:!0}))})})}var n=e.useNative,r=e.initializeModules;if(e.isIE,n){var o=function(){};e.watchShadow=o,e.upgrade=o,e.upgradeAll=o,e.upgradeDocumentTree=o,e.upgradeSubtree=o,e.takeRecords=o,e.instanceof=function(e,t){return e instanceof t}}else r();var i=e.upgradeDocumentTree,a=e.upgradeDocument;if(window.wrap||(window.ShadowDOMPolyfill?(window.wrap=window.ShadowDOMPolyfill.wrapIfNeeded,window.unwrap=window.ShadowDOMPolyfill.unwrapIfNeeded):window.wrap=window.unwrap=function(e){return e}),window.HTMLImports&&(window.HTMLImports.__importsParsingHook=function(e){e.import&&a(wrap(e.import))}),"complete"===document.readyState||e.flags.eager)t();else if("interactive"!==document.readyState||window.attachEvent||window.HTMLImports&&!window.HTMLImports.ready){var s=window.HTMLImports&&!window.HTMLImports.ready?"HTMLImportsLoaded":"DOMContentLoaded";window.addEventListener(s,t)}else t()}(window.CustomElements),function(){var e=document.createElement("style");e.textContent="body {transition: opacity ease-in 0.2s; } \nbody[unresolved] {opacity: 0; display: block; overflow: hidden; position: relative; } \n";var t=document.querySelector("head");t.insertBefore(e,t.firstChild)}(window.WebComponents),function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.PointerEventsPolyfill=t()}(this,function(){"use strict";function e(e,t){t=t||Object.create(null);var n=document.createEvent("Event");n.initEvent(e,t.bubbles||!1,t.cancelable||!1);for(var r,o=2;l.length>o;o++)r=l[o],n[r]=t[r]||d[o];n.buttons=t.buttons||0;var i=0;return i=t.pressure?t.pressure:n.buttons?.5:0,n.x=n.clientX,n.y=n.clientY,n.pointerId=t.pointerId||0,n.width=t.width||0,n.height=t.height||0,n.pressure=i,n.tiltX=t.tiltX||0,n.tiltY=t.tiltY||0,n.pointerType=t.pointerType||"",n.hwTimestamp=t.hwTimestamp||0,n.isPrimary=t.isPrimary||!1,n}function t(){this.array=[],this.size=0}function n(e,t,n,r){this.addCallback=e.bind(r),this.removeCallback=t.bind(r),this.changedCallback=n.bind(r),O&&(this.observer=new O(this.mutationWatcher.bind(this)))}function r(e){return"body /shadow-deep/ "+o(e)}function o(e){return'[touch-action="'+e+'"]'}function i(e){return"{ -ms-touch-action: "+e+"; touch-action: "+e+"; touch-action-delay: none; }"}function a(){if(A){I.forEach(function(e){e+""===e?(k+=o(e)+i(e)+"\n",x&&(k+=r(e)+i(e)+"\n")):(k+=e.selectors.map(o)+i(e.rule)+"\n",x&&(k+=e.selectors.map(r)+i(e.rule)+"\n"))});var e=document.createElement("style");e.textContent=k,document.head.appendChild(e)}}function s(){if(!window.PointerEvent){if(window.PointerEvent=h,window.navigator.msPointerEnabled){var e=window.navigator.msMaxTouchPoints;Object.defineProperty(window.navigator,"maxTouchPoints",{value:e,enumerable:!0}),_.registerSource("ms",ot)}else _.registerSource("mouse",U),void 0!==window.ontouchstart&&_.registerSource("touch",et);_.register(document)}}function c(e){if(!_.pointermap.has(e))throw Error("InvalidPointerId")}function u(){window.Element&&!Element.prototype.setPointerCapture&&Object.defineProperties(Element.prototype,{setPointerCapture:{value:J},releasePointerCapture:{value:Q}})}var l=["bubbles","cancelable","view","detail","screenX","screenY","clientX","clientY","ctrlKey","altKey","shiftKey","metaKey","button","relatedTarget","pageX","pageY"],d=[!1,!1,null,null,0,0,0,0,!1,!1,!1,!1,0,null,0,0],h=e,p=window.Map&&window.Map.prototype.forEach,f=p?Map:t;t.prototype={set:function(e,t){return void 0===t?this.delete(e):(this.has(e)||this.size++,this.array[e]=t,void 0)},has:function(e){return void 0!==this.array[e]},"delete":function(e){this.has(e)&&(delete this.array[e],this.size--)},get:function(e){return this.array[e]},clear:function(){this.array.length=0,this.size=0},forEach:function(e,t){return this.array.forEach(function(n,r){e.call(t,n,r,this)},this)}};var m=f,v=["bubbles","cancelable","view","detail","screenX","screenY","clientX","clientY","ctrlKey","altKey","shiftKey","metaKey","button","relatedTarget","buttons","pointerId","width","height","pressure","tiltX","tiltY","pointerType","hwTimestamp","isPrimary","type","target","currentTarget","which","pageX","pageY","timeStamp"],b=[!1,!1,null,null,0,0,0,0,!1,!1,!1,!1,0,null,0,0,0,0,0,0,0,"",0,!1,"",null,null,0,0,0,0],g={pointerover:1,pointerout:1,pointerenter:1,pointerleave:1},y="undefined"!=typeof SVGElementInstance,w={pointermap:new m,eventMap:Object.create(null),captureInfo:Object.create(null),eventSources:Object.create(null),eventSourceList:[],registerSource:function(e,t){var n=t,r=n.events;r&&(r.forEach(function(e){n[e]&&(this.eventMap[e]=n[e].bind(n))},this),this.eventSources[e]=n,this.eventSourceList.push(n))},register:function(e){for(var t,n=this.eventSourceList.length,r=0;n>r&&(t=this.eventSourceList[r]);r++)t.register.call(t,e)},unregister:function(e){for(var t,n=this.eventSourceList.length,r=0;n>r&&(t=this.eventSourceList[r]);r++)t.unregister.call(t,e)},contains:function(e,t){try{return e.contains(t)}catch(n){return!1}},down:function(e){e.bubbles=!0,this.fireEvent("pointerdown",e)},move:function(e){e.bubbles=!0,this.fireEvent("pointermove",e)},up:function(e){e.bubbles=!0,this.fireEvent("pointerup",e)},enter:function(e){e.bubbles=!1,this.fireEvent("pointerenter",e)},leave:function(e){e.bubbles=!1,this.fireEvent("pointerleave",e)},over:function(e){e.bubbles=!0,this.fireEvent("pointerover",e)},out:function(e){e.bubbles=!0,this.fireEvent("pointerout",e)},cancel:function(e){e.bubbles=!0,this.fireEvent("pointercancel",e)},leaveOut:function(e){this.out(e),this.contains(e.target,e.relatedTarget)||this.leave(e)},enterOver:function(e){this.over(e),this.contains(e.target,e.relatedTarget)||this.enter(e)},eventHandler:function(e){if(!e._handledByPE){var t=e.type,n=this.eventMap&&this.eventMap[t];n&&n(e),e._handledByPE=!0}},listen:function(e,t){t.forEach(function(t){this.addEvent(e,t)},this)},unlisten:function(e,t){t.forEach(function(t){this.removeEvent(e,t)},this)},addEvent:function(e,t){e.addEventListener(t,this.boundHandler)},removeEvent:function(e,t){e.removeEventListener(t,this.boundHandler)},makeEvent:function(e,t){this.captureInfo[t.pointerId]&&(t.relatedTarget=null);var n=new h(e,t);return t.preventDefault&&(n.preventDefault=t.preventDefault),n._target=n._target||t.target,n},fireEvent:function(e,t){var n=this.makeEvent(e,t);return this.dispatchEvent(n)},cloneEvent:function(e){for(var t,n=Object.create(null),r=0;v.length>r;r++)t=v[r],n[t]=e[t]||b[r],!y||"target"!==t&&"relatedTarget"!==t||n[t]instanceof SVGElementInstance&&(n[t]=n[t].correspondingUseElement);return e.preventDefault&&(n.preventDefault=function(){e.preventDefault()}),n},getTarget:function(e){var t=this.captureInfo[e.pointerId];return t?e._target!==t&&e.type in g?void 0:t:e._target},setCapture:function(e,t){this.captureInfo[e]&&this.releaseCapture(e),this.captureInfo[e]=t;var n=document.createEvent("Event");n.initEvent("gotpointercapture",!0,!1),n.pointerId=e,this.implicitRelease=this.releaseCapture.bind(this,e),document.addEventListener("pointerup",this.implicitRelease),document.addEventListener("pointercancel",this.implicitRelease),n._target=t,this.asyncDispatchEvent(n)},releaseCapture:function(e){var t=this.captureInfo[e];if(t){var n=document.createEvent("Event");n.initEvent("lostpointercapture",!0,!1),n.pointerId=e,this.captureInfo[e]=void 0,document.removeEventListener("pointerup",this.implicitRelease),document.removeEventListener("pointercancel",this.implicitRelease),n._target=t,this.asyncDispatchEvent(n)}},dispatchEvent:function(e){var t=this.getTarget(e);return t?t.dispatchEvent(e):void 0},asyncDispatchEvent:function(e){requestAnimationFrame(this.dispatchEvent.bind(this,e))}};w.boundHandler=w.eventHandler.bind(w);var _=w,E={shadow:function(e){return e?e.shadowRoot||e.webkitShadowRoot:void 0},canTarget:function(e){return e&&Boolean(e.elementFromPoint)},targetingShadow:function(e){var t=this.shadow(e);return this.canTarget(t)?t:void 0},olderShadow:function(e){var t=e.olderShadowRoot;if(!t){var n=e.querySelector("shadow");n&&(t=n.olderShadowRoot)}return t},allShadows:function(e){for(var t=[],n=this.shadow(e);n;)t.push(n),n=this.olderShadow(n);return t},searchRoot:function(e,t,n){if(e){var r,o,i=e.elementFromPoint(t,n);for(o=this.targetingShadow(i);o;){if(r=o.elementFromPoint(t,n)){var a=this.targetingShadow(r);return this.searchRoot(a,t,n)||r}o=this.olderShadow(o)}return i}},owner:function(e){for(var t=e;t.parentNode;)t=t.parentNode;return t.nodeType!==Node.DOCUMENT_NODE&&t.nodeType!==Node.DOCUMENT_FRAGMENT_NODE&&(t=document),t},findTarget:function(e){var t=e.clientX,n=e.clientY,r=this.owner(e.target);return r.elementFromPoint(t,n)||(r=document),this.searchRoot(r,t,n)}},T=Array.prototype.forEach.call.bind(Array.prototype.forEach),C=Array.prototype.map.call.bind(Array.prototype.map),M=Array.prototype.slice.call.bind(Array.prototype.slice),L=Array.prototype.filter.call.bind(Array.prototype.filter),O=window.MutationObserver||window.WebKitMutationObserver,S="[touch-action]",N={subtree:!0,childList:!0,attributes:!0,attributeOldValue:!0,attributeFilter:["touch-action"]};n.prototype={watchSubtree:function(e){this.observer&&E.canTarget(e)&&this.observer.observe(e,N)},enableOnSubtree:function(e){this.watchSubtree(e),e===document&&"complete"!==document.readyState?this.installOnLoad():this.installNewSubtree(e)},installNewSubtree:function(e){T(this.findElements(e),this.addElement,this)},findElements:function(e){return e.querySelectorAll?e.querySelectorAll(S):[]},removeElement:function(e){this.removeCallback(e)},addElement:function(e){this.addCallback(e)},elementChanged:function(e,t){this.changedCallback(e,t)},concatLists:function(e,t){return e.concat(M(t))},installOnLoad:function(){document.addEventListener("readystatechange",function(){"complete"===document.readyState&&this.installNewSubtree(document)}.bind(this))},isElement:function(e){return e.nodeType===Node.ELEMENT_NODE},flattenMutationTree:function(e){var t=C(e,this.findElements,this);return t.push(L(e,this.isElement)),t.reduce(this.concatLists,[])},mutationWatcher:function(e){e.forEach(this.mutationHandler,this)},mutationHandler:function(e){if("childList"===e.type){var t=this.flattenMutationTree(e.addedNodes);t.forEach(this.addElement,this);var n=this.flattenMutationTree(e.removedNodes);n.forEach(this.removeElement,this)}else"attributes"===e.type&&this.elementChanged(e.target,e.oldValue)}};var P=n,I=["none","auto","pan-x","pan-y",{rule:"pan-x pan-y",selectors:["pan-x pan-y","pan-y pan-x"]}],k="",A=window.PointerEvent||window.MSPointerEvent,x=!window.ShadowDOMPolyfill&&document.head.createShadowRoot,D=_.pointermap,R=25,H=[1,4,2,8,16],j=!1;try{j=1===new MouseEvent("test",{buttons:1}).buttons}catch(F){}var q,Y={POINTER_ID:1,POINTER_TYPE:"mouse",events:["mousedown","mousemove","mouseup","mouseover","mouseout"],register:function(e){_.listen(e,this.events)},unregister:function(e){_.unlisten(e,this.events)},lastTouches:[],isEventSimulatedFromTouch:function(e){for(var t,n=this.lastTouches,r=e.clientX,o=e.clientY,i=0,a=n.length;a>i&&(t=n[i]);i++){var s=Math.abs(r-t.x),c=Math.abs(o-t.y);if(R>=s&&R>=c)return!0}},prepareEvent:function(e){var t=_.cloneEvent(e),n=t.preventDefault;return t.preventDefault=function(){e.preventDefault(),n()},t.pointerId=this.POINTER_ID,t.isPrimary=!0,t.pointerType=this.POINTER_TYPE,t},prepareButtonsForMove:function(e,t){var n=D.get(this.POINTER_ID);e.buttons=n?n.buttons:0,t.buttons=e.buttons},mousedown:function(e){if(!this.isEventSimulatedFromTouch(e)){var t=D.get(this.POINTER_ID),n=this.prepareEvent(e);j||(n.buttons=H[n.button],t&&(n.buttons|=t.buttons),e.buttons=n.buttons),D.set(this.POINTER_ID,e),t?_.move(n):_.down(n)}},mousemove:function(e){if(!this.isEventSimulatedFromTouch(e)){var t=this.prepareEvent(e);j||this.prepareButtonsForMove(t,e),_.move(t)}},mouseup:function(e){if(!this.isEventSimulatedFromTouch(e)){var t=D.get(this.POINTER_ID),n=this.prepareEvent(e);if(!j){var r=H[n.button];n.buttons=t?t.buttons&~r:0,e.buttons=n.buttons}D.set(this.POINTER_ID,e),0===n.buttons||n.buttons===H[n.button]?(this.cleanupMouse(),_.up(n)):_.move(n)}},mouseover:function(e){if(!this.isEventSimulatedFromTouch(e)){var t=this.prepareEvent(e);j||this.prepareButtonsForMove(t,e),_.enterOver(t)}},mouseout:function(e){if(!this.isEventSimulatedFromTouch(e)){var t=this.prepareEvent(e);j||this.prepareButtonsForMove(t,e),_.leaveOut(t)}},cancel:function(e){var t=this.prepareEvent(e);_.cancel(t),this.cleanupMouse()},cleanupMouse:function(){D.delete(this.POINTER_ID)}},U=Y,X=_.captureInfo,B=E.findTarget.bind(E),z=E.allShadows.bind(E),W=_.pointermap,V=2500,K=200,G="touch-action",$=!1,Z={events:["touchstart","touchmove","touchend","touchcancel"],register:function(e){$?_.listen(e,this.events):q.enableOnSubtree(e)},unregister:function(e){$&&_.unlisten(e,this.events)},elementAdded:function(e){var t=e.getAttribute(G),n=this.touchActionToScrollType(t);n&&(e._scrollType=n,_.listen(e,this.events),z(e).forEach(function(e){e._scrollType=n,_.listen(e,this.events)},this))},elementRemoved:function(e){e._scrollType=void 0,_.unlisten(e,this.events),z(e).forEach(function(e){e._scrollType=void 0,_.unlisten(e,this.events)},this)},elementChanged:function(e,t){var n=e.getAttribute(G),r=this.touchActionToScrollType(n),o=this.touchActionToScrollType(t);r&&o?(e._scrollType=r,z(e).forEach(function(e){e._scrollType=r},this)):o?this.elementRemoved(e):r&&this.elementAdded(e)},scrollTypes:{EMITTER:"none",XSCROLLER:"pan-x",YSCROLLER:"pan-y",SCROLLER:/^(?:pan-x pan-y)|(?:pan-y pan-x)|auto$/},touchActionToScrollType:function(e){var t=e,n=this.scrollTypes;return"none"===t?"none":t===n.XSCROLLER?"X":t===n.YSCROLLER?"Y":n.SCROLLER.exec(t)?"XY":void 0},POINTER_TYPE:"touch",firstTouch:null,isPrimaryTouch:function(e){return this.firstTouch===e.identifier},setPrimaryTouch:function(e){(0===W.size||1===W.size&&W.has(1))&&(this.firstTouch=e.identifier,this.firstXY={X:e.clientX,Y:e.clientY},this.scrolling=!1,this.cancelResetClickCount())},removePrimaryPointer:function(e){e.isPrimary&&(this.firstTouch=null,this.firstXY=null,this.resetClickCount())},clickCount:0,resetId:null,resetClickCount:function(){var e=function(){this.clickCount=0,this.resetId=null}.bind(this);this.resetId=setTimeout(e,K)},cancelResetClickCount:function(){this.resetId&&clearTimeout(this.resetId)},typeToButtons:function(e){var t=0;return("touchstart"===e||"touchmove"===e)&&(t=1),t},touchToPointer:function(e){var t=this.currentTouchEvent,n=_.cloneEvent(e),r=n.pointerId=e.identifier+2;n.target=X[r]||B(n),n.bubbles=!0,n.cancelable=!0,n.detail=this.clickCount,n.button=0,n.buttons=this.typeToButtons(t.type),n.width=e.radiusX||e.webkitRadiusX||0,n.height=e.radiusY||e.webkitRadiusY||0,n.pressure=e.force||e.webkitForce||.5,n.isPrimary=this.isPrimaryTouch(e),n.pointerType=this.POINTER_TYPE;var o=this;return n.preventDefault=function(){o.scrolling=!1,o.firstXY=null,t.preventDefault()},n},processTouches:function(e,t){var n=e.changedTouches;this.currentTouchEvent=e;for(var r,o=0;n.length>o;o++)r=n[o],t.call(this,this.touchToPointer(r))},shouldScroll:function(e){if(this.firstXY){var t,n=e.currentTarget._scrollType;if("none"===n)t=!1;else if("XY"===n)t=!0;else{var r=e.changedTouches[0],o=n,i="Y"===n?"X":"Y",a=Math.abs(r["client"+o]-this.firstXY[o]),s=Math.abs(r["client"+i]-this.firstXY[i]);t=a>=s}return this.firstXY=null,t}},findTouch:function(e,t){for(var n,r=0,o=e.length;o>r&&(n=e[r]);r++)if(n.identifier===t)return!0},vacuumTouches:function(e){var t=e.touches;if(W.size>=t.length){var n=[];W.forEach(function(e,r){if(1!==r&&!this.findTouch(t,r-2)){var o=e.out;n.push(o)}},this),n.forEach(this.cancelOut,this)}},touchstart:function(e){this.vacuumTouches(e),this.setPrimaryTouch(e.changedTouches[0]),this.dedupSynthMouse(e),this.scrolling||(this.clickCount++,this.processTouches(e,this.overDown))},overDown:function(e){W.set(e.pointerId,{target:e.target,out:e,outTarget:e.target}),_.over(e),_.enter(e),_.down(e)},touchmove:function(e){this.scrolling||(this.shouldScroll(e)?(this.scrolling=!0,this.touchcancel(e)):(e.preventDefault(),this.processTouches(e,this.moveOverOut)))},moveOverOut:function(e){var t=e,n=W.get(t.pointerId);if(n){var r=n.out,o=n.outTarget;_.move(t),r&&o!==t.target&&(r.relatedTarget=t.target,t.relatedTarget=o,r.target=o,t.target?(_.leaveOut(r),_.enterOver(t)):(t.target=o,t.relatedTarget=null,this.cancelOut(t))),n.out=t,n.outTarget=t.target}},touchend:function(e){this.dedupSynthMouse(e),this.processTouches(e,this.upOut)},upOut:function(e){this.scrolling||(_.up(e),_.out(e),_.leave(e)),this.cleanUpPointer(e)},touchcancel:function(e){this.processTouches(e,this.cancelOut)},cancelOut:function(e){_.cancel(e),_.out(e),_.leave(e),this.cleanUpPointer(e)},cleanUpPointer:function(e){W.delete(e.pointerId),this.removePrimaryPointer(e)},dedupSynthMouse:function(e){var t=U.lastTouches,n=e.changedTouches[0];if(this.isPrimaryTouch(n)){var r={x:n.clientX,y:n.clientY};t.push(r);var o=function(e,t){var n=e.indexOf(t);n>-1&&e.splice(n,1)}.bind(null,t,r);setTimeout(o,V)}}};$||(q=new P(Z.elementAdded,Z.elementRemoved,Z.elementChanged,Z));var J,Q,et=Z,tt=_.pointermap,nt=window.MSPointerEvent&&"number"==typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE,rt={events:["MSPointerDown","MSPointerMove","MSPointerUp","MSPointerOut","MSPointerOver","MSPointerCancel","MSGotPointerCapture","MSLostPointerCapture"],register:function(e){_.listen(e,this.events)},unregister:function(e){_.unlisten(e,this.events)},POINTER_TYPES:["","unavailable","touch","pen","mouse"],prepareEvent:function(e){var t=e;return nt&&(t=_.cloneEvent(e),t.pointerType=this.POINTER_TYPES[e.pointerType]),t},cleanup:function(e){tt.delete(e)},MSPointerDown:function(e){tt.set(e.pointerId,e);var t=this.prepareEvent(e);_.down(t)},MSPointerMove:function(e){var t=this.prepareEvent(e);_.move(t)},MSPointerUp:function(e){var t=this.prepareEvent(e);_.up(t),this.cleanup(e.pointerId)},MSPointerOut:function(e){var t=this.prepareEvent(e);_.leaveOut(t)},MSPointerOver:function(e){var t=this.prepareEvent(e);_.enterOver(t)},MSPointerCancel:function(e){var t=this.prepareEvent(e);_.cancel(t),this.cleanup(e.pointerId)},MSLostPointerCapture:function(e){var t=_.makeEvent("lostpointercapture",e);_.dispatchEvent(t)},MSGotPointerCapture:function(e){var t=_.makeEvent("gotpointercapture",e);_.dispatchEvent(t)}},ot=rt,it=window.navigator;it.msPointerEnabled?(J=function(e){c(e),this.msSetPointerCapture(e)},Q=function(e){c(e),this.msReleasePointerCapture(e)}):(J=function(e){c(e),_.setCapture(e,this)},Q=function(e){c(e),_.releaseCapture(e,this)}),a(),s(),u();var at={dispatcher:_,Installer:P,PointerEvent:h,PointerMap:m,targetFinding:E};return at}),function(){function e(e){var t=D.call(e);return x[t]||(x[t]=t.match(R)[1].toLowerCase())}function t(n,r){var o=t[r||e(n)];return o?o(n):n}function n(t){return H[e(t)]?[t]:Array.prototype.slice.call(t,0)}function r(e,t){return(t||j).length?n(e.querySelectorAll(t)):[]}function o(e){e()}function i(n,r,o){var i=e(o);return"object"==i&&"object"==e(n[r])?X.merge(n[r],o):n[r]=t(o,i),n}function a(e,t,n){var r,o={};for(var i in t)o[i.split(":")[0]]=i;for(i in n)r=o[i.split(":")[0]],"function"==typeof t[r]?(r.match(":mixins")||(t[r+":mixins"]=t[r],delete t[r],r+=":mixins"),t[r].__mixin__=X.applyPseudos(i+(i.match(":mixins")?"":":mixins"),n[i],e.pseudos,t[r].__mixin__)):(t[i]=n[i],delete t[r])}function s(e,t,n){for(var r in n)t[r+":__mixin__("+F++ +")"]=X.applyPseudos(r,n[r],e.pseudos)}function c(e,t){for(var n=e.length;n--;)t.unshift(e[n]),X.mixins[e[n]].mixins&&c(X.mixins[e[n]].mixins,t);return t}function u(e){return c(e.mixins,[]).forEach(function(t){var n=X.mixins[t];for(var r in n){var o=n[r],i=e[r];if(i)switch(r){case"mixins":break;case"events":s(e,i,o);break;case"accessors":case"prototype":for(var c in o)i[c]?a(e,i[c],o[c],t):i[c]=o[c];break;default:a(e,i,o,t)}else e[r]=o}}),e}function l(e,t){for(var n,r=t.target,o=t.currentTarget;!n&&r&&r!=o;)r.tagName&&A.call(r,e.value)&&(n=r),r=r.parentNode;return!n&&o.tagName&&A.call(o,e.value)&&(n=o),n?e.listener=e.listener.bind(n):null}function d(e){return 0===e.button}function h(e,t,n,r){r?t[e]=n[e]:Object.defineProperty(t,e,{writable:!0,enumerable:!0,value:n[e]})}function p(e,t){var n=Object.getOwnPropertyDescriptor(e,"target");for(var r in t)q[r]||h(r,e,t,n);e.baseEvent=t}function f(e,t,n,r,o){_[o].call(e,n,t&&t.boolean?"":r)}function m(e,t,n,r,o){if(t&&(t.property||t.selector))for(var i=t.property?[e.xtag[t.property]]:t.selector?X.query(e,t.selector):[],a=i.length;a--;)i[a][o](n,r)}function v(e,t,n,r,o,i){var a=n.split(":"),s=a[0];"get"==s?(a[0]=t,e.prototype[t].get=X.applyPseudos(a.join(":"),r[n],e.pseudos,r[n])):"set"==s?(a[0]=t,e.prototype[t].set=X.applyPseudos(a.join(":"),o?function(e){var t,a="setAttribute";o.boolean?(e=!!e,t=this.hasAttribute(i),e||(a="removeAttribute")):(e=o.validate?o.validate.call(this,e):e,t=this.getAttribute(i)),f(this,o,i,e,a),r[n].call(this,e,t),m(this,o,i,e,a)}:r[n]?function(e){r[n].call(this,e)}:null,e.pseudos,r[n]),o&&(o.setter=r[n])):e.prototype[t][n]=r[n]}function b(e,t){e.prototype[t]={};var n,r=e.accessors[t],o=r.attribute;o&&(n=o.name=(o?o.name||t.replace(O,"$1-$2"):t).toLowerCase(),o.key=t,e.attributes[n]=o);for(var i in r)v(e,t,i,r,o,n);if(o){if(!e.prototype[t].get){var a=(o.boolean?"has":"get")+"Attribute";e.prototype[t].get=function(){return this[a](n)}}e.prototype[t].set||(e.prototype[t].set=function(e){e=o.boolean?!!e:o.validate?o.validate.call(this,e):e;var t=o.boolean?e?"setAttribute":"removeAttribute":"setAttribute";f(this,o,n,e,t),m(this,o,n,e,t)})}}function g(e){return"function"==typeof e?U.exec(""+e)[1]:e}var y=window,w=document,_={setAttribute:Element.prototype.setAttribute,removeAttribute:Element.prototype.removeAttribute},E=Element.prototype.createShadowRoot,T=w.createElement("div"),C=function(){},M=function(){return!0},L=/,/g,O=/([a-z])([A-Z])/g,S=/\(|\)/g,N=/:(\w+)\u276A(.+?(?=\u276B))|:(\w+)/g,P=/(\d+)/g,I={action:function(e,t){return e.value.match(P).indexOf(t.keyCode+"")>-1==("keypass"==e.name)||null}},k=function(){var e=Object.keys(window).join(),t=(e.match(/,(ms)/)||e.match(/,(moz)/)||e.match(/,(O)/)||[null,"webkit"])[1].toLowerCase();return{dom:"ms"==t?"MS":t,lowercase:t,css:"-"+t+"-",js:"ms"==t?t:t.charAt(0).toUpperCase()+t.substring(1)}}(),A=Element.prototype.matches||Element.prototype.matchesSelector||Element.prototype[k.lowercase+"MatchesSelector"],x={},D=x.toString,R=/\s([a-zA-Z]+)/;t.object=function(e){var n={};for(var r in e)n[r]=t(e[r]);return n},t.array=function(e){for(var n=e.length,r=Array(n);n--;)r[n]=t(e[n]);return r};var H={undefined:1,"null":1,number:1,"boolean":1,string:1,"function":1},j="",F=0,q={};for(var Y in w.createEvent("CustomEvent"))q[Y]=1;var U=/\/\*!?(?:\@preserve)?[ \t]*(?:\r\n|\n)([\s\S]*?)(?:\r\n|\n)\s*\*\//,X={tags:{},defaultOptions:{pseudos:[],mixins:[],events:{},methods:{},accessors:{},lifecycle:{},attributes:{},prototype:{xtag:{get:function(){return this.__xtag__?this.__xtag__:this.__xtag__={data:{}}}}}},register:function(e,t){var r;if("string"!=typeof e)throw"First argument must be a Custom Element string name";r=e.toLowerCase(),X.tags[r]=t||{};var o=t.prototype;delete t.prototype;var i=X.tags[r].compiled=u(X.merge({},X.defaultOptions,t)),a=i.prototype,s=i.lifecycle;for(var c in i.events)i.events[c]=X.parseEvent(c,i.events[c]);for(c in s)s[c.split(":")[0]]=X.applyPseudos(c,s[c],i.pseudos,s[c]);for(c in i.methods)a[c.split(":")[0]]={value:X.applyPseudos(c,i.methods[c],i.pseudos,i.methods[c]),enumerable:!0};for(c in i.accessors)b(i,c);i.shadow&&(i.shadow=i.shadow.nodeName?i.shadow:X.createFragment(i.shadow)),i.content&&(i.content=i.content.nodeName?i.content.innerHTML:g(i.content));var l=s.created,d=s.finalized;a.createdCallback={enumerable:!0,value:function(){var e=this;i.shadow&&E&&this.createShadowRoot().appendChild(i.shadow.cloneNode(!0)),i.content&&(this.appendChild(document.createElement("div")).outerHTML=i.content);var t=l?l.apply(this,arguments):null;X.addEvents(this,i.events);for(var n in i.attributes){var r=i.attributes[n],o=this.hasAttribute(n),a=void 0!==r.def;(o||r.boolean||a)&&(this[r.key]=r.boolean?o:!o&&a?r.def:this.getAttribute(n))}return i.pseudos.forEach(function(t){t.onAdd.call(e,t)}),this.xtagComponentReady=!0,d&&d.apply(this,arguments),t}};var h=s.inserted,p=s.removed;(h||p)&&(a.attachedCallback={value:function(){return p&&(this.xtag.__parentNode__=this.parentNode),h?h.apply(this,arguments):void 0},enumerable:!0}),p&&(a.detachedCallback={value:function(){var e=n(arguments);e.unshift(this.xtag.__parentNode__);var t=p.apply(this,e);return delete this.xtag.__parentNode__,t},enumerable:!0}),s.attributeChanged&&(a.attributeChangedCallback={value:s.attributeChanged,enumerable:!0}),a.setAttribute={writable:!0,enumerable:!0,value:function(e,t){var n,r=e.toLowerCase(),o=i.attributes[r];o&&(n=this.getAttribute(r),t=o.boolean?"":o.validate?o.validate.call(this,t):t),f(this,o,r,t,"setAttribute"),o&&(o.setter&&o.setter.call(this,o.boolean?!0:t,n),m(this,o,r,t,"setAttribute"))}},a.removeAttribute={writable:!0,enumerable:!0,value:function(e){var t=e.toLowerCase(),n=i.attributes[t],r=this.hasAttribute(t);f(this,n,t,"","removeAttribute"),n&&(n.setter&&n.setter.call(this,n.boolean?!1:void 0,r),m(this,n,t,"","removeAttribute"))}};var v={},_=o instanceof y.HTMLElement,T=i["extends"]&&(v["extends"]=i["extends"]);return o&&Object.getOwnPropertyNames(o).forEach(function(e){var t=a[e],n=_?Object.getOwnPropertyDescriptor(o,e):o[e];if(t)for(var r in n)t[r]="function"==typeof n[r]&&t[r]?X.wrap(n[r],t[r]):n[r];a[e]=t||n}),v.prototype=Object.create(T?Object.create(w.createElement(T).constructor).prototype:y.HTMLElement.prototype,a),w.registerElement(r,v)},mixins:{},prefix:k,captureEvents:{focus:1,blur:1,scroll:1,DOMMouseScroll:1},customEvents:{animationstart:{attach:[k.dom+"AnimationStart"]},animationend:{attach:[k.dom+"AnimationEnd"]},transitionend:{attach:[k.dom+"TransitionEnd"]},move:{attach:["pointermove"]},enter:{attach:["pointerenter"]},leave:{attach:["pointerleave"]},scrollwheel:{attach:["DOMMouseScroll","mousewheel"],condition:function(e){return e.delta=e.wheelDelta?e.wheelDelta/40:Math.round(-1*(e.detail/3.5)),!0
    }},tap:{attach:["pointerdown","pointerup"],condition:function(e,t){if("pointerdown"==e.type)t.startX=e.clientX,t.startY=e.clientY;else if(0===e.button&&10>Math.abs(t.startX-e.clientX)&&10>Math.abs(t.startY-e.clientY))return!0}},tapstart:{attach:["pointerdown"],condition:d},tapend:{attach:["pointerup"],condition:d},tapmove:{attach:["pointerdown"],condition:function(e,t){if("pointerdown"==e.type){var n=t.listener.bind(this);t.tapmoveListeners||(t.tapmoveListeners=X.addEvents(document,{pointermove:n,pointerup:n,pointercancel:n}))}else("pointerup"==e.type||"pointercancel"==e.type)&&(X.removeEvents(document,t.tapmoveListeners),t.tapmoveListeners=null);return!0}},taphold:{attach:["pointerdown","pointerup"],condition:function(e,t){if("pointerdown"==e.type)(t.pointers=t.pointers||{})[e.pointerId]=setTimeout(X.fireEvent.bind(null,this,"taphold"),t.duration||1e3);else{if("pointerup"!=e.type)return!0;t.pointers&&(clearTimeout(t.pointers[e.pointerId]),delete t.pointers[e.pointerId])}}}},pseudos:{__mixin__:{},mixins:{onCompiled:function(e,t){var n=t.source&&t.source.__mixin__||t.source;if(!n)return e;switch(t.value){case null:case"":case"before":return function(){return n.apply(this,arguments),e.apply(this,arguments)};case"after":return function(){var t=e.apply(this,arguments);return n.apply(this,arguments),t};case"none":return e}}},keypass:I,keyfail:I,delegate:{action:l},preventable:{action:function(e,t){return!t.defaultPrevented}},duration:{onAdd:function(e){e.source.duration=Number(e.value)}},capture:{onCompiled:function(e,t){t.source&&(t.source.capture=!0)}}},clone:t,typeOf:e,toArray:n,wrap:function(e,t){return function(){var n=e.apply(this,arguments);return t.apply(this,arguments),n}},merge:function(t,n,r){if("string"==e(n))return i(t,n,r);for(var o=1,a=arguments.length;a>o;o++){var s=arguments[o];for(var c in s)i(t,c,s[c])}return t},uid:function(){return Math.random().toString(36).substr(2,10)},query:r,skipTransition:function(e,t,n){var r=k.js+"TransitionProperty";e.style[r]=e.style.transitionProperty="none";var o=t?t.call(n||e):null;return X.skipFrame(function(){e.style[r]=e.style.transitionProperty="",o&&o.call(n||e)})},requestFrame:function(){var e=y.requestAnimationFrame||y[k.lowercase+"RequestAnimationFrame"]||function(e){return y.setTimeout(e,20)};return function(t){return e(t)}}(),cancelFrame:function(){var e=y.cancelAnimationFrame||y[k.lowercase+"CancelAnimationFrame"]||y.clearTimeout;return function(t){return e(t)}}(),skipFrame:function(e){var t=X.requestFrame(function(){t=X.requestFrame(e)});return t},matchSelector:function(e,t){return A.call(e,t)},set:function(e,t,n){e[t]=n,window.CustomElements&&CustomElements.upgradeAll(e)},innerHTML:function(e,t){X.set(e,"innerHTML",t)},hasClass:function(e,t){return e.className.split(" ").indexOf(t.trim())>-1},addClass:function(e,t){var n=e.className.trim().split(" ");return t.trim().split(" ").forEach(function(e){~n.indexOf(e)||n.push(e)}),e.className=n.join(" ").trim(),e},removeClass:function(e,t){var n=t.trim().split(" ");return e.className=e.className.trim().split(" ").filter(function(e){return e&&!~n.indexOf(e)}).join(" "),e},toggleClass:function(e,t){return X[X.hasClass(e,t)?"removeClass":"addClass"].call(null,e,t)},queryChildren:function(e,t){var r=e.id,o="#"+(e.id=r||"x_"+X.uid())+" > ",i=e.parentNode||!T.appendChild(e);t=o+(t+"").replace(L,","+o);var a=e.parentNode.querySelectorAll(t);return r||e.removeAttribute("id"),i||T.removeChild(e),n(a)},createFragment:function(e){var t=document.createElement("template");return e&&(e.nodeName?n(arguments).forEach(function(e){t.content.appendChild(e)}):t.innerHTML=g(e)),document.importNode(t.content,!0)},manipulate:function(e,t){var n=e.nextSibling,r=e.parentNode,o=t.call(e)||e;n?r.insertBefore(o,n):r.appendChild(o)},applyPseudos:function(e,t,r,i){var a=t,s={};if(e.match(":")){var c=[],u=0;e.replace(S,function(e){return"("==e?1==++u?"âª":"(":--u?")":"â«"}).replace(N,function(e,t,n,r){c.push([t||r,n])});for(var l=c.length;l--;)o(function(){var o=c[l][0],u=c[l][1];if(!X.pseudos[o])throw"pseudo not found: "+o+" "+u;u=""===u||u===void 0?null:u;var d=s[l]=Object.create(X.pseudos[o]);d.key=e,d.name=o,d.value=u,d.arguments=(u||"").split(","),d.action=d.action||M,d.source=i,d.onAdd=d.onAdd||C,d.onRemove=d.onRemove||C;var h=d.listener=a;a=function(){var e=d.action.apply(this,[d].concat(n(arguments)));return null===e||e===!1?e:(e=d.listener.apply(this,arguments),d.listener=h,e)},r?r.push(d):d.onAdd.call(t,d)})}for(var d in s)s[d].onCompiled&&(a=s[d].onCompiled(a,s[d])||a);return a},removePseudos:function(e,t){t.forEach(function(t){t.onRemove.call(e,t)})},parseEvent:function(e,t){var r=e.split(":"),o=r.shift(),i=X.customEvents[o],a=X.merge({type:o,stack:C,condition:M,capture:X.captureEvents[o],attach:[],_attach:[],pseudos:"",_pseudos:[],onAdd:C,onRemove:C},i||{});a.attach=n(a.base||a.attach),a.chain=o+(a.pseudos.length?":"+a.pseudos:"")+(r.length?":"+r.join(":"):"");var s=X.applyPseudos(a.chain,t,a._pseudos,a);return a.stack=function(e){e.currentTarget=e.currentTarget||this;var t=e.detail||{};return t.__stack__?t.__stack__==s?(e.stopPropagation(),e.cancelBubble=!0,s.apply(this,arguments)):void 0:s.apply(this,arguments)},a.listener=function(e){var t=n(arguments),r=a.condition.apply(this,t.concat([a]));return r?e.type!=o&&e.baseEvent&&e.type!=e.baseEvent.type?(X.fireEvent(e.target,o,{baseEvent:e,detail:r!==!0&&(r.__stack__=s)?r:{__stack__:s}}),void 0):a.stack.apply(this,t):r},a.attach.forEach(function(e){a._attach.push(X.parseEvent(e,a.listener))}),a},addEvent:function(e,t,n,r){var o="function"==typeof n?X.parseEvent(t,n):n;return o._pseudos.forEach(function(t){t.onAdd.call(e,t)}),o._attach.forEach(function(t){X.addEvent(e,t.type,t)}),o.onAdd.call(e,o,o.listener),e.addEventListener(o.type,o.stack,r||o.capture),o},addEvents:function(e,t){var n={};for(var r in t)n[r]=X.addEvent(e,r,t[r]);return n},removeEvent:function(e,t,n){n=n||t,n.onRemove.call(e,n,n.listener),X.removePseudos(e,n._pseudos),n._attach.forEach(function(t){X.removeEvent(e,t)}),e.removeEventListener(n.type,n.stack)},removeEvents:function(e,t){for(var n in t)X.removeEvent(e,t[n])},fireEvent:function(e,t,n){var r=w.createEvent("CustomEvent");n=n||{},r.initCustomEvent(t,n.bubbles!==!1,n.cancelable!==!1,n.detail),n.baseEvent&&p(r,n.baseEvent),e.dispatchEvent(r)}};y.xtag=X,w.addEventListener("WebComponentsReady",function(){X.fireEvent(w.body,"DOMComponentsLoaded")})}();
} else {
    (function(){"use strict";var t=new function(){},e=new Set("annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" "));function n(t){var n=e.has(t);return t=/^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(t),!n&&t}function o(t){var e=t.isConnected;if(void 0!==e)return e;for(;t&&!(t.__CE_isImportDocument||t instanceof Document);)t=t.parentNode||(window.ShadowRoot&&t instanceof ShadowRoot?t.host:void 0);return!(!t||!(t.__CE_isImportDocument||t instanceof Document))}function i(t,e){for(;e&&e!==t&&!e.nextSibling;)e=e.parentNode;return e&&e!==t?e.nextSibling:null}function r(t,e,n){n=n||new Set;for(var o=t;o;){if(o.nodeType===Node.ELEMENT_NODE){var a=o;e(a);var l=a.localName;if("link"===l&&"import"===a.getAttribute("rel")){if((o=a.import)instanceof Node&&!n.has(o))for(n.add(o),o=o.firstChild;o;o=o.nextSibling)r(o,e,n);o=i(t,a);continue}if("template"===l){o=i(t,a);continue}if(a=a.__CE_shadowRoot)for(a=a.firstChild;a;a=a.nextSibling)r(a,e,n)}o=o.firstChild?o.firstChild:i(t,o)}}function a(t,e,n){t[e]=n}function l(){this.a=new Map,this.m=new Map,this.f=[],this.b=!1}function c(t,e){t.b=!0,t.f.push(e)}function s(t,e){t.b&&r(e,function(e){return f(t,e)})}function f(t,e){if(t.b&&!e.__CE_patched){e.__CE_patched=!0;for(var n=0;n<t.f.length;n++)t.f[n](e)}}function h(t,e){var n=[];for(r(e,function(t){return n.push(t)}),e=0;e<n.length;e++){var o=n[e];1===o.__CE_state?t.connectedCallback(o):d(t,o)}}function u(t,e){var n=[];for(r(e,function(t){return n.push(t)}),e=0;e<n.length;e++){var o=n[e];1===o.__CE_state&&t.disconnectedCallback(o)}}function p(t,e,n){var o=(n=n||{}).w||new Set,i=n.s||function(e){return d(t,e)},a=[];if(r(e,function(e){if("link"===e.localName&&"import"===e.getAttribute("rel")){var n=e.import;n instanceof Node&&"complete"===n.readyState?(n.__CE_isImportDocument=!0,n.__CE_hasRegistry=!0):e.addEventListener("load",function(){var n=e.import;n.__CE_documentLoadHandled||(n.__CE_documentLoadHandled=!0,n.__CE_isImportDocument=!0,n.__CE_hasRegistry=!0,o.delete(n),p(t,n,{w:o,s:i}))})}else a.push(e)},o),t.b)for(e=0;e<a.length;e++)f(t,a[e]);for(e=0;e<a.length;e++)i(a[e])}function d(t,e){if(void 0===e.__CE_state){var n=t.a.get(e.localName);if(n){n.constructionStack.push(e);var i=n.constructor;try{try{if(new i!==e)throw Error("The custom element constructor did not produce the element being upgraded.")}finally{n.constructionStack.pop()}}catch(t){throw e.__CE_state=2,t}if(e.__CE_state=1,e.__CE_definition=n,n.attributeChangedCallback)for(n=n.observedAttributes,i=0;i<n.length;i++){var r=n[i],a=e.getAttribute(r);null!==a&&t.attributeChangedCallback(e,r,null,a,null)}o(e)&&t.connectedCallback(e)}}}function m(t,e){this.c=t,this.a=e,this.b=void 0,p(this.c,this.a),"loading"===this.a.readyState&&(this.b=new MutationObserver(this.f.bind(this)),this.b.observe(this.a,{childList:!0,subtree:!0}))}function w(t){t.b&&t.b.disconnect()}function y(t){if(t.a)throw Error("Already resolved.");t.a=void 0,t.b&&t.b(void 0)}function g(t){this.h=!1,this.c=t,this.l=new Map,this.i=function(t){return t()},this.g=!1,this.j=[],this.u=new m(t,document)}l.prototype.connectedCallback=function(t){var e=t.__CE_definition;e.connectedCallback&&e.connectedCallback.call(t)},l.prototype.disconnectedCallback=function(t){var e=t.__CE_definition;e.disconnectedCallback&&e.disconnectedCallback.call(t)},l.prototype.attributeChangedCallback=function(t,e,n,o,i){var r=t.__CE_definition;r.attributeChangedCallback&&-1<r.observedAttributes.indexOf(e)&&r.attributeChangedCallback.call(t,e,n,o,i)},m.prototype.f=function(t){var e=this.a.readyState;for("interactive"!==e&&"complete"!==e||w(this),e=0;e<t.length;e++)for(var n=t[e].addedNodes,o=0;o<n.length;o++)p(this.c,n[o])},g.prototype.define=function(t,e){var o,i,r,a,l,c=this;if(!(e instanceof Function))throw new TypeError("Custom element constructors must be functions.");if(!n(t))throw new SyntaxError("The element name '"+t+"' is not valid.");if(this.c.a.get(t))throw Error("A custom element with name '"+t+"' has already been defined.");if(this.h)throw Error("A custom element is already being defined.");this.h=!0;try{var s=function(t){var e=f[t];if(void 0!==e&&!(e instanceof Function))throw Error("The '"+t+"' callback must be a function.");return e},f=e.prototype;if(!(f instanceof Object))throw new TypeError("The custom element constructor's prototype is not an object.");o=s("connectedCallback"),i=s("disconnectedCallback"),r=s("adoptedCallback"),a=s("attributeChangedCallback"),l=e.observedAttributes||[]}catch(t){return}finally{this.h=!1}e={localName:t,constructor:e,connectedCallback:o,disconnectedCallback:i,adoptedCallback:r,attributeChangedCallback:a,observedAttributes:l,constructionStack:[]},function(t,e,n){t.a.set(e,n),t.m.set(n.constructor,n)}(this.c,t,e),this.j.push(e),this.g||(this.g=!0,this.i(function(){return function(t){if(!1!==t.g){t.g=!1;for(var e=t.j,n=[],o=new Map,i=0;i<e.length;i++)o.set(e[i].localName,[]);for(p(t.c,document,{s:function(e){if(void 0===e.__CE_state){var i=e.localName,r=o.get(i);r?r.push(e):t.c.a.get(i)&&n.push(e)}}}),i=0;i<n.length;i++)d(t.c,n[i]);for(;0<e.length;){for(var r=e.shift(),i=r.localName,r=o.get(r.localName),a=0;a<r.length;a++)d(t.c,r[a]);(i=t.l.get(i))&&y(i)}}}(c)}))},g.prototype.get=function(t){if(t=this.c.a.get(t))return t.constructor},g.prototype.whenDefined=function(t){if(!n(t))return Promise.reject(new SyntaxError("'"+t+"' is not a valid custom element name."));var e=this.l.get(t);return e?e.f:(e=new function(){var t=this;this.b=this.a=void 0,this.f=new Promise(function(e){t.b=e,t.a&&e(t.a)})},this.l.set(t,e),this.c.a.get(t)&&!this.j.some(function(e){return e.localName===t})&&y(e),e.f)},g.prototype.v=function(t){w(this.u);var e=this.i;this.i=function(n){return t(function(){return e(n)})}},window.CustomElementRegistry=g,g.prototype.define=g.prototype.define,g.prototype.get=g.prototype.get,g.prototype.whenDefined=g.prototype.whenDefined,g.prototype.polyfillWrapFlushCallback=g.prototype.v;var b=window.Document.prototype.createElement,v=window.Document.prototype.createElementNS,_=window.Document.prototype.importNode,E=window.Document.prototype.prepend,C=window.Document.prototype.append,N=window.Node.prototype.cloneNode,k=window.Node.prototype.appendChild,A=window.Node.prototype.insertBefore,D=window.Node.prototype.removeChild,S=window.Node.prototype.replaceChild,T=Object.getOwnPropertyDescriptor(window.Node.prototype,"textContent"),j=window.Element.prototype.attachShadow,M=Object.getOwnPropertyDescriptor(window.Element.prototype,"innerHTML"),O=window.Element.prototype.getAttribute,L=window.Element.prototype.setAttribute,H=window.Element.prototype.removeAttribute,x=window.Element.prototype.getAttributeNS,R=window.Element.prototype.setAttributeNS,P=window.Element.prototype.removeAttributeNS,F=window.Element.prototype.insertAdjacentElement,I=window.Element.prototype.prepend,z=window.Element.prototype.append,W=window.Element.prototype.before,B=window.Element.prototype.after,X=window.Element.prototype.replaceWith,$=window.Element.prototype.remove,q=window.HTMLElement,G=Object.getOwnPropertyDescriptor(window.HTMLElement.prototype,"innerHTML"),J=window.HTMLElement.prototype.insertAdjacentElement;function K(t,e,n){e.prepend=function(e){for(var i=[],r=0;r<arguments.length;++r)i[r-0]=arguments[r];r=i.filter(function(t){return t instanceof Node&&o(t)}),n.o.apply(this,i);for(var a=0;a<r.length;a++)u(t,r[a]);if(o(this))for(r=0;r<i.length;r++)(a=i[r])instanceof Element&&h(t,a)},e.append=function(e){for(var i=[],r=0;r<arguments.length;++r)i[r-0]=arguments[r];r=i.filter(function(t){return t instanceof Node&&o(t)}),n.append.apply(this,i);for(var a=0;a<r.length;a++)u(t,r[a]);if(o(this))for(r=0;r<i.length;r++)(a=i[r])instanceof Element&&h(t,a)}}var Q,U=window.customElements;if(!U||U.forcePolyfill||"function"!=typeof U.define||"function"!=typeof U.get){var V=new l;Q=V,window.HTMLElement=function(){function e(){var e=this.constructor;if(!(o=Q.m.get(e)))throw Error("The custom element being constructed was not registered with `customElements`.");var n=o.constructionStack;if(!n.length)return n=b.call(document,o.localName),Object.setPrototypeOf(n,e.prototype),n.__CE_state=1,n.__CE_definition=o,f(Q,n),n;var o,i=n[o=n.length-1];if(i===t)throw Error("The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.");return n[o]=t,Object.setPrototypeOf(i,e.prototype),f(Q,i),i}return e.prototype=q.prototype,e}(),function(){var t=V;a(Document.prototype,"createElement",function(e){if(this.__CE_hasRegistry){var n=t.a.get(e);if(n)return new n.constructor}return e=b.call(this,e),f(t,e),e}),a(Document.prototype,"importNode",function(e,n){return e=_.call(this,e,n),this.__CE_hasRegistry?p(t,e):s(t,e),e}),a(Document.prototype,"createElementNS",function(e,n){if(this.__CE_hasRegistry&&(null===e||"http://www.w3.org/1999/xhtml"===e)){var o=t.a.get(n);if(o)return new o.constructor}return e=v.call(this,e,n),f(t,e),e}),K(t,Document.prototype,{o:E,append:C})}(),function(){var t=V;function e(e,n){Object.defineProperty(e,"textContent",{enumerable:n.enumerable,configurable:!0,get:n.get,set:function(e){if(this.nodeType===Node.TEXT_NODE)n.set.call(this,e);else{var i=void 0;if(this.firstChild){var r=this.childNodes,a=r.length;if(0<a&&o(this)){i=Array(a);for(var l=0;l<a;l++)i[l]=r[l]}}if(n.set.call(this,e),i)for(e=0;e<i.length;e++)u(t,i[e])}}})}a(Node.prototype,"insertBefore",function(e,n){if(e instanceof DocumentFragment){var i=Array.prototype.slice.apply(e.childNodes);if(e=A.call(this,e,n),o(this))for(n=0;n<i.length;n++)h(t,i[n]);return e}return i=o(e),n=A.call(this,e,n),i&&u(t,e),o(this)&&h(t,e),n}),a(Node.prototype,"appendChild",function(e){if(e instanceof DocumentFragment){var n=Array.prototype.slice.apply(e.childNodes);if(e=k.call(this,e),o(this))for(var i=0;i<n.length;i++)h(t,n[i]);return e}return n=o(e),i=k.call(this,e),n&&u(t,e),o(this)&&h(t,e),i}),a(Node.prototype,"cloneNode",function(e){return e=N.call(this,e),this.ownerDocument.__CE_hasRegistry?p(t,e):s(t,e),e}),a(Node.prototype,"removeChild",function(e){var n=o(e),i=D.call(this,e);return n&&u(t,e),i}),a(Node.prototype,"replaceChild",function(e,n){if(e instanceof DocumentFragment){var i=Array.prototype.slice.apply(e.childNodes);if(e=S.call(this,e,n),o(this))for(u(t,n),n=0;n<i.length;n++)h(t,i[n]);return e}i=o(e);var r=S.call(this,e,n),a=o(this);return a&&u(t,n),i&&u(t,e),a&&h(t,e),r}),T&&T.get?e(Node.prototype,T):c(t,function(t){e(t,{enumerable:!0,configurable:!0,get:function(){for(var t=[],e=0;e<this.childNodes.length;e++)t.push(this.childNodes[e].textContent);return t.join("")},set:function(t){for(;this.firstChild;)D.call(this,this.firstChild);k.call(this,document.createTextNode(t))}})})}(),function(){var t=V;function e(e,n){Object.defineProperty(e,"innerHTML",{enumerable:n.enumerable,configurable:!0,get:n.get,set:function(e){var i=this,a=void 0;if(o(this)&&(a=[],r(this,function(t){t!==i&&a.push(t)})),n.set.call(this,e),a)for(var l=0;l<a.length;l++){var c=a[l];1===c.__CE_state&&t.disconnectedCallback(c)}return this.ownerDocument.__CE_hasRegistry?p(t,this):s(t,this),e}})}function n(e,n){a(e,"insertAdjacentElement",function(e,i){var r=o(i);return e=n.call(this,e,i),r&&u(t,i),o(e)&&h(t,i),e})}if(j?a(Element.prototype,"attachShadow",function(t){return this.__CE_shadowRoot=j.call(this,t)}):console.warn("Custom Elements: `Element#attachShadow` was not patched."),M&&M.get)e(Element.prototype,M);else if(G&&G.get)e(HTMLElement.prototype,G);else{var i=b.call(document,"div");c(t,function(t){e(t,{enumerable:!0,configurable:!0,get:function(){return N.call(this,!0).innerHTML},set:function(t){var e="template"===this.localName?this.content:this;for(i.innerHTML=t;0<e.childNodes.length;)D.call(e,e.childNodes[0]);for(;0<i.childNodes.length;)k.call(e,i.childNodes[0])}})})}a(Element.prototype,"setAttribute",function(e,n){if(1!==this.__CE_state)return L.call(this,e,n);var o=O.call(this,e);L.call(this,e,n),n=O.call(this,e),t.attributeChangedCallback(this,e,o,n,null)}),a(Element.prototype,"setAttributeNS",function(e,n,o){if(1!==this.__CE_state)return R.call(this,e,n,o);var i=x.call(this,e,n);R.call(this,e,n,o),o=x.call(this,e,n),t.attributeChangedCallback(this,n,i,o,e)}),a(Element.prototype,"removeAttribute",function(e){if(1!==this.__CE_state)return H.call(this,e);var n=O.call(this,e);H.call(this,e),null!==n&&t.attributeChangedCallback(this,e,n,null,null)}),a(Element.prototype,"removeAttributeNS",function(e,n){if(1!==this.__CE_state)return P.call(this,e,n);var o=x.call(this,e,n);P.call(this,e,n);var i=x.call(this,e,n);o!==i&&t.attributeChangedCallback(this,n,o,i,e)}),J?n(HTMLElement.prototype,J):F?n(Element.prototype,F):console.warn("Custom Elements: `Element#insertAdjacentElement` was not patched."),K(t,Element.prototype,{o:I,append:z}),function(t){var e=Element.prototype;e.before=function(e){for(var n=[],i=0;i<arguments.length;++i)n[i-0]=arguments[i];i=n.filter(function(t){return t instanceof Node&&o(t)}),W.apply(this,n);for(var r=0;r<i.length;r++)u(t,i[r]);if(o(this))for(i=0;i<n.length;i++)(r=n[i])instanceof Element&&h(t,r)},e.after=function(e){for(var n=[],i=0;i<arguments.length;++i)n[i-0]=arguments[i];i=n.filter(function(t){return t instanceof Node&&o(t)}),B.apply(this,n);for(var r=0;r<i.length;r++)u(t,i[r]);if(o(this))for(i=0;i<n.length;i++)(r=n[i])instanceof Element&&h(t,r)},e.replaceWith=function(e){for(var n=[],i=0;i<arguments.length;++i)n[i-0]=arguments[i];i=n.filter(function(t){return t instanceof Node&&o(t)});var r=o(this);X.apply(this,n);for(var a=0;a<i.length;a++)u(t,i[a]);if(r)for(u(t,this),i=0;i<n.length;i++)(r=n[i])instanceof Element&&h(t,r)},e.remove=function(){var e=o(this);$.call(this),e&&u(t,this)}}(t)}(),document.__CE_hasRegistry=!0;var Y=new g(V);Object.defineProperty(window,"customElements",{configurable:!0,enumerable:!0,value:Y})}}).call(self);
    !function(){var e=document.documentElement;Element.prototype.matches||(Element.prototype.matches=e.webkitMatchesSelector||e.msMatchesSelector||e.oMatchesSelector);var t=/([\w\-]+)|(::|:)(\w+)(?:\((.+?(?=\)))\))?/g,n=/,\s*/,r=/[A-Z]/g,s=e=>"-"+e.toLowerCase();var o={events:{},pseudos:{delegate:{onInvoke:function(e,t,n){for(var r,s=n.target,o=n.currentTarget;!r&&s&&s!=o;)s.tagName&&s.matches(t.args)&&(r=s),s=s.parentNode;if(!r&&o.tagName&&o.matches(t.args)&&(r=o),!r)return null;t.fn=t.fn.bind(r)}}},extensions:{rxn:{onParse:(e,t,n,r,s)=>(delete e.prototype[s],!1),onConstruct(e,t,n,r){e.rxn(t,r.value,!!n[1])}},attr:{mixin:e=>(class extends e{attributeChangedCallback(e,t,n){var r=this.constructor.getOptions("attributes")[e];r&&r.set&&!r._skip&&(r.set.call(this,n),r._skip=null)}}),types:{boolean:{set:function(e,t){t||""===t?this.setAttribute(e,""):this.removeAttribute(e)},get:function(e){return this.hasAttribute(e)}}},onParse(e,t,n,o,i){if(o.value)throw'Attribute accessor "'+t+'" was declared as a value, but must be declared as get or set';var a=t.replace(r,s);e.getOptions("attributes")[a]=o;var l=this.types[n[0]]||{};let c=o.set,u=l.set||HTMLElement.prototype.setAttribute;o.set=function(e){var t;o._skip||(o._skip=!0,c&&(t=c.call(this,e)),u.call(this,a,void 0===t?e:t),o._skip=null)};let d=o.get,p=l.get||HTMLElement.prototype.getAttribute;o.get=function(){var e,t=p.call(this,a);return d&&(e=d.call(this,t)),void 0===e?t:e},delete e.prototype[i]},onCompiled(e){e.observedAttributes=Object.keys(e.getOptions("attributes")).concat(e.observedAttributes||[])}},event:{onParse:(e,t,n,r,s)=>(delete e.prototype[s],!1),onConstruct(e,t,n,r){o.addEvent(e,t,r.value)}},template:{throttle:{frame:function(e,t,n){n.cancel=cancelAnimationFrame.bind(window,requestAnimationFrame(()=>{e._render(t,n)}))},debounce:function(e,t,n,r){n.cancel=clearTimeout.bind(window,setTimeout(()=>{node_.render(t,n)},r.throttle))}},mixin:e=>(class extends e{set"template::attr"(e){this.render(e)}get templates(){return this.constructor.getOptions("templates")}_render(e,t){this.innerHTML=e.call(this),this._XTagRender=null,t.resolve&&t.resolve(this)}render(e,t={}){var n=e||"default",r=this.templates[n];if(!r)throw new ReferenceError('Template "'+n+'" undefined for '+this.nodeName);var s=this._XTagRender;if(s){if(s.name===n)return s.promise;s.cancel&&s.cancel()}this.getAttribute("template")!=n&&this.setAttribute("template",n),s=this._XTagRender={name:n};var i=o.extensions.template.throttle,a=!!t.throttle&&(i[t.throttle]||i.debounce);return a?s.promise=new Promise(e=>{s.resolve=e,a(this,r,s,t)}):(this._render(r,s),Promise.resolve(this))}}),onParse:(e,t,n,r)=>(e.getOptions("templates")[t||"default"]=r.value,!1),onReady(e,t,n,r){r[0]&&("ready"===r[0]?e.render(n):e.rxn("firstpaint",()=>e.render(n))),t()}}},create(e,t){var n=t||e;return n.options=Object.assign({},n.options),c(n),t&&e&&customElements.define(e,n),n},register(e,t){customElements.define(e,t)},addEvents(e,t){let n={};for(let r in t)n[r]=o.addEvent(e,r,t[r]);return n},addEvent(e,r,s,i){var a,c=s,u=i||{};u.data={},r.replace(t,(t,r,s,i,d)=>{if(r)a=r;else if(":"==s){i=o.pseudos[i];var p=d?d.split(n):[];c=l(i,p,c,u),i.onParse&&i.onParse(e,a,p,c,u)}}),e.addEventListener(a,c,u),u.type=a,u.listener=c;var d=o.events[a];if(d){var p=function(e){new Promise(t=>{d.onFilter?d.onFilter(this,e,u,t):t()}).then(()=>{let t="_"+a+"EventFired";e[t]||(e[t]=!0,o.fireEvent(e.target||this,a))})};u.attached=d.attach.map(t=>o.addEvent(e,t,p,{capture:!0})),d.onAdd&&d.onAdd(e,u)}return u},removeEvents(e,t){for(let n in t)o.removeEvent(e,t[n])},removeEvent(e,t){e.removeEventListener(t.type,t.listener,t.capture);var n=o.events[t.type];n&&n.onRemove&&n.onRemove(e,t),t.attached&&t.attached.forEach(n=>{o.removeEvent(e,t)})},fireEvent(e,t,n={}){let r=Object.assign({bubbles:!0,cancelable:!0},n);e.dispatchEvent(new CustomEvent(t,r))}},i=0;function a(e,t){var n=e.rxns[t],r=n.queue;for(let t in r)r[t].fn.call(e),!n.singleton&&r[t].recurring||delete r[t];n.fired=!0}function l(e,t,n,r){return function(){var s={fn:n,args:t,detail:r},o=e.onInvoke(this,s,...arguments);return null===o||!1===o?o:s.fn.apply(this,o instanceof Array?o:arguments)}}function c(e){var r={},s=function(e){var t={},n=e.prototype;return Object.getOwnPropertyNames(n).forEach(e=>{t[e]=Object.getOwnPropertyDescriptor(n,e)}),t}(e),i=e.getOptions("extensions"),a=e._processedExtensions=new Map;for(let c in s){let u,d,p,f=[],m=[],h=s[c],v=e._pseudos||o.pseudos;if(c.replace(t,function(){f.unshift(arguments)}),f.forEach(t=>(function(t,r,s,c,p){if(u=r||u,p)var f=p.split(n);if("::"==s)m=f||[],d=i[c]||o.extensions[c],a.get(d)||a.set(d,[]);else if(!r){let t=v[c];if(t)for(let n in h){let r=h[n];"function"==typeof r&&t.onInvoke&&(r=h[n]=l(t,f,r),t.onParse&&t.onParse(e,u,f,r))}}}).apply(null,t)),d&&(a.get(d).push([u,m,h]),d.onParse&&(p=d.onParse(e,u,m,h,c))),u){if(!1!==p){let e=r[u]||(r[u]={});for(let t in h)e[t]=h[t]}}else delete e.prototype[c]}for(let t of a.keys())t.onCompiled&&t.onCompiled(e,r);Object.defineProperties(e.prototype,r)}XTagElement=function e(t={}){var n;return(n=class extends(t.native?Object.getPrototypeOf(document.createElement(t.native)).constructor:HTMLElement){constructor(){super(),this.rxns||(this.rxns={ready:{queue:{},singleton:!0},firstpaint:{queue:{},singleton:!0},render:{queue:{}}}),function(e){var t=e.constructor._processedExtensions;for(let[n,r]of t)n.onConstruct&&r.forEach(t=>n.onConstruct(e,...t))}(this),new Promise(e=>(function(e,t){var n=e.constructor._processedExtensions;for(let[r,s]of n)r.onReady&&Promise.all(s.map(t=>new Promise(n=>r.onReady(e,n,...t)))).then(t)})(this,e)).then(()=>{a(this,"ready"),this.readyCallback&&this.readyCallback()})}connectedCallback(){!function(e){var t=e.constructor._processedExtensions;for(let[n,r]of t)n.onConnect&&r.forEach(t=>n.onConnect(e,...t))}(this),this.rxns.firstpaint.frame||(this.rxns.firstpaint.frame=requestAnimationFrame(()=>a(this,"firstpaint")))}rxn(e,t,n){var r=this.rxns[e];if(!r.singleton||!r.fired)return r.queue[i++]={fn:t,recurring:n},i;t.call(this)}cancelRxn(e,t){delete this.rxns[e].queue[t]}}).options={extensions:{},pseudos:{}},n.getOptions=function(e){return this.options[e]||(this.options[e]=Object.assign({},Object.getPrototypeOf(this).options?Object.getPrototypeOf(this).options[e]:{}))},n.extensions=function(...e){var t=this.getOptions("extensions");return e.reduce((e,n)=>{var r,s=e;return t[n.name]||("string"==typeof n?r=o.extensions[n].mixin:(r=n.mixin,t[n.name]=n),r&&c(s=r(e))),s},this)},n.as=function(t){return e({native:t})},n.extensions("attr","event","template")}(),(window.xtag=o,window.XTagElement=XTagElement)}();
    
    
    
    // Polyfill so that we don't have to update each element's code
    
    var oldRegister = xtag.register;
    
    xtag.tags = {};
    
    xtag.register = function (name, options) {
        'use strict';
        function ElementConstructor() {
            // inherit from HTMLElement part 1 of 2
            var _ = Reflect.construct(HTMLElement, [], new.target);
            
            // lifecycle part 1 of 2
            if (options.lifecycle) {
                if (options.lifecycle.created) {
                    //console.log(_ instanceof HTMLDivElement);
                    //console.log('hasAttribute:', _.hasAttribute);
                    options.lifecycle.created.apply(_, arguments);
                }
            }
    
            // accessors
            if (options.accessors) {
                //console.log(options.accessors);
                var arrAccessor = Object.keys(options.accessors);
                var i = 0;
                var len = arrAccessor.length;
                while (i < len) {
                    Object.defineProperty(_, arrAccessor[i], options.accessors[arrAccessor[i]]);
                    //console.log(_, arrAccessor[i], options.accessors[arrAccessor[i]]);
                    i += 1;
                }
            }
    
            // events
            if (options.events) {
                var arrEvent = Object.keys(options.events);
                var i = 0;
                var len = arrEvent.length;
                while (i < len) {
                    _.addEventListener(arrEvent[i], options.events[arrEvent[i]]);
                    i += 1;
                }
            }
    
            return _;
        };
        // inherit from HTMLElement part 2 of 2
        ElementConstructor.prototype = Object.create(HTMLElement.prototype);
        
        // lifecycle part 2 of 2
        //console.log(name, ElementConstructor.prototype, Object.create(HTMLElement.prototype));
        // ElementConstructor.prototype = ElementConstructor.prototype || {};
        if (options.lifecycle) {
            if (options.lifecycle.inserted) {
                ElementConstructor.prototype.connectedCallback = function () {
                    this.xtagInserted = true;
                    options.lifecycle.inserted.apply(this, arguments);
                };
            }
            if (options.lifecycle.removed) {
                ElementConstructor.prototype.disconnectedCallback = options.lifecycle.removed;
            }
            //console.log(name, 'options.lifecycle.attributeChanged', options.lifecycle.attributeChanged);
            if (options.lifecycle.attributeChanged) {
                ElementConstructor.prototype.attributeChangedCallback = function () {
                    // only run the changed callback if we are inserted
                    if (this.xtagInserted) {
                        options.lifecycle.attributeChanged.apply(this, arguments);
                    }
                };
                Object.defineProperty(ElementConstructor, 'observedAttributes', { get: function () { return ['disabled','for','format','href','media','min-width','no-focus','no-huddelete','no-hudlimit','no-hudorderby','no-hudrefresh','no-picker','path','placeholder','qs','name', 'maxlength', 'autofocus', 'readonly', 'title','reflow','reflow-at','src','suspend-created','suspend-inserted','tabindex','template','value','widths'].concat(options.observedAttributes); } });
            }
        }
    
        // methods
        var arrMethod = Object.keys(options.methods || {});
        var i = 0;
        var len = arrMethod.length;
        while (i < len) {
            ElementConstructor.prototype[arrMethod[i]] = options.methods[arrMethod[i]];
            i += 1;
        }
    
        // register
        //console.log('registering', name, ElementConstructor, ElementConstructor.prototype, options);
        oldRegister.call(xtag, name, ElementConstructor, { extends: options.extends || 'div' });
        xtag.tags[name] = options;
    };
    
    xtag.matchSelector = function (e, s) {
        // console.log(e);
        if (e.mozMatchesSelector) {
            return e.mozMatchesSelector(s);
        } else if (e.webkitMatchesSelector) {
            return e.webkitMatchesSelector(s);
        } else if (e.matches) {
            return e.matches(s);
        } else {
            return false;
        }
    };
    
    xtag.toArray = function (nodeList) {
        return Array.prototype.slice.call(nodeList, 0);
    };
    
    xtag.query = function (element, selector) {
        return !element ? null : xtag.toArray(element.querySelectorAll(selector));
    };
    
    // :scope polyfill for queryChildren
    (function(doc, proto) {
      try { // check if browser supports :scope natively
        doc.querySelector(':scope body');
      } catch (err) { // polyfill native methods if it doesn't
        ['querySelector', 'querySelectorAll'].forEach(function(method) {
          var nativ = proto[method];
          proto[method] = function(selectors) {
            if (/(^|,)\s*:scope/.test(selectors)) { // only if selectors contains :scope
              var id = this.id; // remember current element id
              this.id = 'ID_' + Date.now(); // assign new unique id
              selectors = selectors.replace(/((^|,)\s*):scope/g, '$1#' + this.id); // replace :scope with #ID
              var result = doc[method](selectors);
              this.id = id; // restore previous id
              return result;
            } else {
              return nativ.call(this, selectors); // use native code for other selectors
            }
          }
        });
      }
    })(window.document, Element.prototype);
    
    xtag.queryChildren = function (element, selector) {
        return !element ? null : xtag.toArray(element.querySelectorAll(':scope > ' + selector));
    };
}



;(function () {
	'use strict';

	/**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */

	/*jslint browser:true, node:true*/
	/*global define, Event, Node*/


	/**
	 * Instantiate fast-clicking listeners on the specified layer.
	 *
	 * @constructor
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	function FastClick(layer, options) {
		var oldOnClick;

		options = options || {};

		/**
		 * Whether a click is currently being tracked.
		 *
		 * @type boolean
		 */
		this.trackingClick = false;


		/**
		 * Timestamp for when click tracking started.
		 *
		 * @type number
		 */
		this.trackingClickStart = 0;


		/**
		 * The element being tracked for a click.
		 *
		 * @type EventTarget
		 */
		this.targetElement = null;


		/**
		 * X-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartX = 0;


		/**
		 * Y-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartY = 0;


		/**
		 * ID of the last touch, retrieved from Touch.identifier.
		 *
		 * @type number
		 */
		this.lastTouchIdentifier = 0;


		/**
		 * Touchmove boundary, beyond which a click will be cancelled.
		 *
		 * @type number
		 */
		this.touchBoundary = options.touchBoundary || 10;


		/**
		 * The FastClick layer.
		 *
		 * @type Element
		 */
		this.layer = layer;

		/**
		 * The minimum time between tap(touchstart and touchend) events
		 *
		 * @type number
		 */
		this.tapDelay = options.tapDelay || 200;

		/**
		 * The maximum time for a tap
		 *
		 * @type number
		 */
		this.tapTimeout = options.tapTimeout || 700;

		if (FastClick.notNeeded(layer)) {
			return;
		}

		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function() { return method.apply(context, arguments); };
		}


		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}

		// Set up event handlers as required
		//deviceIsIOS was added by Mojo
		if (deviceIsAndroid || deviceIsIOS) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}

		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);

		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function(type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};

			layer.addEventListener = function(type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}

		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {

			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function(event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}

	/**
	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
	*
	* @type boolean
	*/
	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

	/**
	 * Android requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


	/**
	 * iOS requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


	/**
	 * iOS 4 requires an exception for select elements.
	 *
	 * @type boolean
	 */
	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


	/**
	 * iOS 6.0-7.* requires the target element to be manually derived
	 *
	 * @type boolean
	 */
	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

	/**
	 * BlackBerry requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

	/**
	 * Determine whether a given element requires a native click.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element needs a native click
	 */
	FastClick.prototype.needsClick = function(target) {
		switch (target.nodeName.toLowerCase()) {

		// Don't send a synthetic click to disabled inputs (issue #62)
		case 'button':
		case 'select':
		case 'textarea':
			if (target.disabled) {
				return true;
			}

			break;
		case 'input':

			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
				return true;
			}

			break;
		case 'label':
		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
		case 'video':
			return true;
		}
        
        // CODE ADDED BY MICHAEL (added for case when we need to have click for html that we have no control over
        //                          (our example is the contents of an ACE editor need regular clicks but we cant add a "needsclick" to every element in an ACE editor)
        //                       )
        var currentElement = target.parentNode;
        
        // loop through parents and if any of the parents has the "childrenneedsclick" class than return true
        while (currentElement && currentElement.parentNode && currentElement.parentNode.nodeName !== 'HTML') {
            if (currentElement.classList.contains('childrenneedsclick')) {//alert('test');
                return true;
            }
            
            currentElement = currentElement.parentNode;
        }
        
		return (/\bneedsclick\b/).test(target.className);
	};


	/**
	 * Determine whether a given element requires a call to focus to simulate click into element.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
	 */
	FastClick.prototype.needsFocus = function(target) {
		switch (target.nodeName.toLowerCase()) {
		case 'textarea':
			return true;
		case 'select':
			return !deviceIsAndroid;
		case 'input':
			switch (target.type) {
			case 'button':
			case 'checkbox':
			case 'file':
			case 'image':
			case 'radio':
			case 'submit':
				return false;
			}

			// No point in attempting to focus disabled inputs
			return !target.disabled && !target.readOnly;
		default:
			return (/\bneedsfocus\b/).test(target.className);
		}
	};


	/**
	 * Send a click event to the specified element.
	 *
	 * @param {EventTarget|Element} targetElement
	 * @param {Event} event
	 */
	FastClick.prototype.sendClick = function(targetElement, event) {
		var clickEvent, touch;

		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}

		touch = event.changedTouches[0];
		//console.log('test click');

		// Synthesise a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};

	FastClick.prototype.determineEventType = function(targetElement) {

		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}

		return 'click';
	};


	/**
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.focus = function(targetElement) {
		var length;

		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};


	/**
	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
	 *
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.updateScrollParent = function(targetElement) {
		var scrollParent, parentElement;

		scrollParent = targetElement.fastClickScrollParent;

		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}

				parentElement = parentElement.parentElement;
			} while (parentElement);
		}

		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};


	/**
	 * @param {EventTarget} targetElement
	 * @returns {Element|EventTarget}
	 */
	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}

		return eventTarget;
	};


	/**
	 * On touch start, record the position and scroll offset.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchStart = function(event) {
		var targetElement, touch, selection;

		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}

		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];

		if (deviceIsIOS) {

			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}

			if (!deviceIsIOS4) {

				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}

				this.lastTouchIdentifier = touch.identifier;

				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}

		this.trackingClick = true;
		this.trackingClickStart = event.timeStamp;
		this.targetElement = targetElement;

		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			event.preventDefault();
		}

		return true;
	};


	/**
	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.touchHasMoved = function(event) {
		var touch = event.changedTouches[0], boundary = this.touchBoundary;

		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}

		return false;
	};


	/**
	 * Update the last position.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchMove = function(event) {
		if (!this.trackingClick) {
			return true;
		}

		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}

		return true;
	};


	/**
	 * Attempt to find the labelled control for the given label element.
	 *
	 * @param {EventTarget|HTMLLabelElement} labelElement
	 * @returns {Element|null}
	 */
	FastClick.prototype.findControl = function(labelElement) {

		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}

		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}

		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};


	/**
	 * On touch end, determine whether to send a click event at once.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchEnd = function(event) {
		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

		if (!this.trackingClick) {
			return true;
		}

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			this.cancelNextClick = true;
			return true;
		}

		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
			return true;
		}

		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;

		this.lastClickTime = event.timeStamp;

		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;

		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];

			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}

		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}

				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {

			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
				this.targetElement = null;
				return false;
			}

			this.focus(targetElement);
			this.sendClick(targetElement, event);

			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}

			return false;
		}

		if (deviceIsIOS && !deviceIsIOS4) {

			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}

		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}

		return false;
	};


	/**
	 * On touch cancel, stop tracking the click.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.onTouchCancel = function() {
		this.trackingClick = false;
		this.targetElement = null;
	};


	/**
	 * Determine mouse events which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onMouse = function(event) {

		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}

		if (event.forwardedTouchEvent) {
			return true;
		}

		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}

		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {

				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}

			// Cancel the event
			event.stopPropagation();
			event.preventDefault();

			return false;
		}

		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};


	/**
	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
	 * an actual click which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onClick = function(event) {
		var permitted;

		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}

		// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}

		permitted = this.onMouse(event);

		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}

		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};


	/**
	 * Remove all FastClick's event listeners.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.destroy = function() {
		var layer = this.layer;

		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}

		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};


	/**
	 * Check whether FastClick is needed.
	 *
	 * @param {Element} layer The layer to listen on
	 */
	FastClick.notNeeded = function(layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;

		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}

		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (chromeVersion) {

			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}

			// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}

		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}

		// IE10 with -ms-touch-action: none, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none') {
			return true;
		}

		// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
		if (layer.style.touchAction === 'none') {
			return true;
		}

		return false;
	};


	/**
	 * Factory method for creating a FastClick object
	 *
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	FastClick.attach = function(layer, options) {
		return new FastClick(layer, options);
	};


	if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {

		// AMD. Register as an anonymous module.
		define(function() {
			return FastClick;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = FastClick.attach;
		module.exports.FastClick = FastClick;
	}// else {
	
	window.FastClick = FastClick;
	//}
}());



//(function () {
//	'use strict';
//
//	/**
//	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
//	 *
//	 * @codingstandard ftlabs-jsv2
//	 * @copyright The Financial Times Limited [All Rights Reserved]
//	 * @license MIT License (see LICENSE.txt)
//	 */
//
//	/*jslint browser:true, node:true*/
//	/*global define, Event, Node*/
//
//
//	/**
//	 * Instantiate fast-clicking listeners on the specified layer.
//	 *
//	 * @constructor
//	 * @param {Element} layer The layer to listen on
//	 * @param {Object} [options={}] The options to override the defaults
//	 */
//	function FastClick(layer, options) {
//		var oldOnClick;
//
//		options = options || {};
//
//		/**
//		 * Whether a click is currently being tracked.
//		 *
//		 * @type boolean
//		 */
//		this.trackingClick = false;
//
//
//		/**
//		 * Timestamp for when click tracking started.
//		 *
//		 * @type number
//		 */
//		this.trackingClickStart = 0;
//
//
//		/**
//		 * The element being tracked for a click.
//		 *
//		 * @type EventTarget
//		 */
//		this.targetElement = null;
//
//
//		/**
//		 * X-coordinate of touch start event.
//		 *
//		 * @type number
//		 */
//		this.touchStartX = 0;
//
//
//		/**
//		 * Y-coordinate of touch start event.
//		 *
//		 * @type number
//		 */
//		this.touchStartY = 0;
//
//
//		/**
//		 * ID of the last touch, retrieved from Touch.identifier.
//		 *
//		 * @type number
//		 */
//		this.lastTouchIdentifier = 0;
//
//
//		/**
//		 * Touchmove boundary, beyond which a click will be cancelled.
//		 *
//		 * @type number
//		 */
//		this.touchBoundary = options.touchBoundary || 10;
//
//
//		/**
//		 * The FastClick layer.
//		 *
//		 * @type Element
//		 */
//		this.layer = layer;
//
//		/**
//		 * The minimum time between tap(touchstart and touchend) events
//		 *
//		 * @type number
//		 */
//		this.tapDelay = options.tapDelay || 200;
//
//		/**
//		 * The maximum time for a tap
//		 *
//		 * @type number
//		 */
//		this.tapTimeout = options.tapTimeout || 700;
//
//		if (FastClick.notNeeded(layer)) {
//			return;
//		}
//
//		// Some old versions of Android don't have Function.prototype.bind
//		function bind(method, context) {
//			return function() { return method.apply(context, arguments); };
//		}
//
//
//		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
//		var context = this;
//		for (var i = 0, l = methods.length; i < l; i++) {
//			context[methods[i]] = bind(context[methods[i]], context);
//		}
//
//		// Set up event handlers as required
//		if (deviceIsAndroid) {
//			layer.addEventListener('mouseover', this.onMouse, true);
//			layer.addEventListener('mousedown', this.onMouse, true);
//			layer.addEventListener('mouseup', this.onMouse, true);
//		}
//
//		layer.addEventListener('click', this.onClick, true);
//		layer.addEventListener('touchstart', this.onTouchStart, false);
//		layer.addEventListener('touchmove', this.onTouchMove, false);
//		layer.addEventListener('touchend', this.onTouchEnd, false);
//		layer.addEventListener('touchcancel', this.onTouchCancel, false);
//
//		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
//		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
//		// layer when they are cancelled.
//		if (!Event.prototype.stopImmediatePropagation) {
//			layer.removeEventListener = function(type, callback, capture) {
//				var rmv = Node.prototype.removeEventListener;
//				if (type === 'click') {
//					rmv.call(layer, type, callback.hijacked || callback, capture);
//				} else {
//					rmv.call(layer, type, callback, capture);
//				}
//			};
//
//			layer.addEventListener = function(type, callback, capture) {
//				var adv = Node.prototype.addEventListener;
//				if (type === 'click') {
//					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
//						if (!event.propagationStopped) {
//							callback(event);
//						}
//					}), capture);
//				} else {
//					adv.call(layer, type, callback, capture);
//				}
//			};
//		}
//
//		// If a handler is already declared in the element's onclick attribute, it will be fired before
//		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
//		// adding it as listener.
//		if (typeof layer.onclick === 'function') {
//
//			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
//			// - the old one won't work if passed to addEventListener directly.
//			oldOnClick = layer.onclick;
//			layer.addEventListener('click', function(event) {
//				oldOnClick(event);
//			}, false);
//			layer.onclick = null;
//		}
//	}
//
//	/**
//	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
//	*
//	* @type boolean
//	*/
//	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;
//
//	/**
//	 * Android requires exceptions.
//	 *
//	 * @type boolean
//	 */
//	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;
//
//
//	/**
//	 * iOS requires exceptions.
//	 *
//	 * @type boolean
//	 */
//	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;
//
//
//	/**
//	 * iOS 4 requires an exception for select elements.
//	 *
//	 * @type boolean
//	 */
//	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);
//
//
//	/**
//	 * iOS 6.0-7.* requires the target element to be manually derived
//	 *
//	 * @type boolean
//	 */
//	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);
//
//	/**
//	 * BlackBerry requires exceptions.
//	 *
//	 * @type boolean
//	 */
//	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;
//
//	/**
//	 * Determine whether a given element requires a native click.
//	 *
//	 * @param {EventTarget|Element} target Target DOM element
//	 * @returns {boolean} Returns true if the element needs a native click
//	 */
//	FastClick.prototype.needsClick = function(target) {
//		switch (target.nodeName.toLowerCase()) {
//
//		// Don't send a synthetic click to disabled inputs (issue #62)
//		case 'button':
//		case 'select':
//		case 'textarea':
//			if (target.disabled) {
//				return true;
//			}
//
//			break;
//		case 'input':
//
//			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
//			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
//				return true;
//			}
//
//			break;
//		case 'label':
//		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
//		case 'video':
//			return true;
//		}
//
//		return (/\bneedsclick\b/).test(target.className);
//	};
//
//
//	/**
//	 * Determine whether a given element requires a call to focus to simulate click into element.
//	 *
//	 * @param {EventTarget|Element} target Target DOM element
//	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
//	 */
//	FastClick.prototype.needsFocus = function(target) {
//		switch (target.nodeName.toLowerCase()) {
//		case 'textarea':
//			return true;
//		case 'select':
//			return !deviceIsAndroid;
//		case 'input':
//			switch (target.type) {
//			case 'button':
//			case 'checkbox':
//			case 'file':
//			case 'image':
//			case 'radio':
//			case 'submit':
//				return false;
//			}
//
//			// No point in attempting to focus disabled inputs
//			return !target.disabled && !target.readOnly;
//		default:
//			return (/\bneedsfocus\b/).test(target.className);
//		}
//	};
//
//
//	/**
//	 * Send a click event to the specified element.
//	 *
//	 * @param {EventTarget|Element} targetElement
//	 * @param {Event} event
//	 */
//	FastClick.prototype.sendClick = function(targetElement, event) {
//		var clickEvent, touch;
//        
//		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
//		if (document.activeElement && document.activeElement !== targetElement) {
//			document.activeElement.blur();
//		}
//
//		touch = event.changedTouches[0];
//
//		// Synthesise a click event, with an extra attribute so it can be tracked
//		clickEvent = document.createEvent('MouseEvents');
//		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
//		clickEvent.forwardedTouchEvent = true;
//		targetElement.dispatchEvent(clickEvent);
//	};
//
//	FastClick.prototype.determineEventType = function(targetElement) {
//
//		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
//		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
//			return 'mousedown';
//		}
//
//		return 'click';
//	};
//
//
//	/**
//	 * @param {EventTarget|Element} targetElement
//	 */
//	FastClick.prototype.focus = function(targetElement) {
//		var length;
//
//		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
//		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && //targetElement.type !== 'month') {
//			length = targetElement.value.length;
//			targetElement.setSelectionRange(length, length);
//		} else {
//			targetElement.focus();
//		}
//	};
//
//
//	/**
//	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
//	 *
//	 * @param {EventTarget|Element} targetElement
//	 */
//	FastClick.prototype.updateScrollParent = function(targetElement) {
//		var scrollParent, parentElement;
//
//		scrollParent = targetElement.fastClickScrollParent;
//
//		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
//		// target element was moved to another parent.
//		if (!scrollParent || !scrollParent.contains(targetElement)) {
//			parentElement = targetElement;
//			do {
//				if (parentElement.scrollHeight > parentElement.offsetHeight) {
//					scrollParent = parentElement;
//					targetElement.fastClickScrollParent = parentElement;
//					break;
//				}
//
//				parentElement = parentElement.parentElement;
//			} while (parentElement);
//		}
//
//		// Always update the scroll top tracker if possible.
//		if (scrollParent) {
//			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
//		}
//	};
//
//
//	/**
//	 * @param {EventTarget} targetElement
//	 * @returns {Element|EventTarget}
//	 */
//	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
//
//		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
//		if (eventTarget.nodeType === Node.TEXT_NODE) {
//			return eventTarget.parentNode;
//		}
//
//		return eventTarget;
//	};
//
//
//	/**
//	 * On touch start, record the position and scroll offset.
//	 *
//	 * @param {Event} event
//	 * @returns {boolean}
//	 */
//	FastClick.prototype.onTouchStart = function(event) {
//		var targetElement, touch, selection;
//
//		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
//		if (event.targetTouches.length > 1) {
//			return true;
//		}
//
//		targetElement = this.getTargetElementFromEventTarget(event.target);
//		touch = event.targetTouches[0];
//
//		if (deviceIsIOS) {
//
//			// Only trusted events will deselect text on iOS (issue #49)
//			selection = window.getSelection();
//			if (selection.rangeCount && !selection.isCollapsed) {
//				return true;
//			}
//
//			if (!deviceIsIOS4) {
//
//				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
//				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
//				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
//				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
//				// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
//				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
//				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
//				// random integers, it's safe to to continue if the identifier is 0 here.
//				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
//					event.preventDefault();
//					return false;
//				}
//
//				this.lastTouchIdentifier = touch.identifier;
//
//				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
//				// 1) the user does a fling scroll on the scrollable layer
//				// 2) the user stops the fling scroll with another tap
//				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
//				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
//				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
//				this.updateScrollParent(targetElement);
//			}
//		}
//
//		this.trackingClick = true;
//		this.trackingClickStart = event.timeStamp;
//		this.targetElement = targetElement;
//
//		this.touchStartX = touch.pageX;
//		this.touchStartY = touch.pageY;
//
//		// Prevent phantom clicks on fast double-tap (issue #36)
//		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
//			event.preventDefault();
//		}
//
//		return true;
//	};
//
//
//	/**
//	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
//	 *
//	 * @param {Event} event
//	 * @returns {boolean}
//	 */
//	FastClick.prototype.touchHasMoved = function(event) {
//		var touch = event.changedTouches[0], boundary = this.touchBoundary;
//
//		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
//			return true;
//		}
//
//		return false;
//	};
//
//
//	/**
//	 * Update the last position.
//	 *
//	 * @param {Event} event
//	 * @returns {boolean}
//	 */
//	FastClick.prototype.onTouchMove = function(event) {
//		if (!this.trackingClick) {
//			return true;
//		}
//
//		// If the touch has moved, cancel the click tracking
//		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
//			this.trackingClick = false;
//			this.targetElement = null;
//		}
//
//		return true;
//	};
//
//
//	/**
//	 * Attempt to find the labelled control for the given label element.
//	 *
//	 * @param {EventTarget|HTMLLabelElement} labelElement
//	 * @returns {Element|null}
//	 */
//	FastClick.prototype.findControl = function(labelElement) {
//
//		// Fast path for newer browsers supporting the HTML5 control attribute
//		if (labelElement.control !== undefined) {
//			return labelElement.control;
//		}
//
//		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
//		if (labelElement.htmlFor) {
//			return document.getElementById(labelElement.htmlFor);
//		}
//
//		// If no for attribute exists, attempt to retrieve the first labellable descendant element
//		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
//		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
//	};
//
//
//	/**
//	 * On touch end, determine whether to send a click event at once.
//	 *
//	 * @param {Event} event
//	 * @returns {boolean}
//	 */
//	FastClick.prototype.onTouchEnd = function(event) {
//		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;
//        
//        //console.trace('TRACE');
//        
//		if (!this.trackingClick) {
//			return true;
//		}
//
//		// Prevent phantom clicks on fast double-tap (issue #36)
//		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
//			this.cancelNextClick = true;
//			return true;
//		}
//
//		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
//			return true;
//		}
//
//		// Reset to prevent wrong click cancel on input (issue #156).
//		this.cancelNextClick = false;
//
//		this.lastClickTime = event.timeStamp;
//
//		trackingClickStart = this.trackingClickStart;
//		this.trackingClick = false;
//		this.trackingClickStart = 0;
//
//		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
//		// is performing a transition or scroll, and has to be re-detected manually. Note that
//		// for this to function correctly, it must be called *after* the event target is checked!
//		// See issue #57; also filed as rdar://13048589 .
//		if (deviceIsIOSWithBadTarget) {
//			touch = event.changedTouches[0];
//
//			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
//			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
//			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
//		}
//
//		targetTagName = targetElement.tagName.toLowerCase();
//		if (targetTagName === 'label') {
//			forElement = this.findControl(targetElement);
//			if (forElement) {
//				this.focus(targetElement);
//				if (deviceIsAndroid) {
//					return false;
//				}
//
//				targetElement = forElement;
//			}
//		} else if (this.needsFocus(targetElement)) {
//
//			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
//			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
//			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
//				this.targetElement = null;
//				return false;
//			}
//
//			this.focus(targetElement);
//			this.sendClick(targetElement, event);
//
//			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
//			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
//			if (!deviceIsIOS || targetTagName !== 'select') {
//				this.targetElement = null;
//				event.preventDefault();
//			}
//
//			return false;
//		}
//
//		if (deviceIsIOS && !deviceIsIOS4) {
//
//			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
//			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
//			scrollParent = targetElement.fastClickScrollParent;
//			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
//				return true;
//			}
//		}
//
//		// Prevent the actual click from going though - unless the target node is marked as requiring
//		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
//		if (!this.needsClick(targetElement)) {
//			event.preventDefault();
//			this.sendClick(targetElement, event);
//		}
//
//		return false;
//	};
//
//
//	/**
//	 * On touch cancel, stop tracking the click.
//	 *
//	 * @returns {void}
//	 */
//	FastClick.prototype.onTouchCancel = function() {
//		this.trackingClick = false;
//		this.targetElement = null;
//	};
//
//
//	/**
//	 * Determine mouse events which should be permitted.
//	 *
//	 * @param {Event} event
//	 * @returns {boolean}
//	 */
//	FastClick.prototype.onMouse = function(event) {
//
//		// If a target element was never set (because a touch event was never fired) allow the event
//		if (!this.targetElement) {
//			return true;
//		}
//
//		if (event.forwardedTouchEvent) {
//			return true;
//		}
//
//		// Programmatically generated events targeting a specific element should be permitted
//		if (!event.cancelable) {
//			return true;
//		}
//
//		// Derive and check the target element to see whether the mouse event needs to be permitted;
//		// unless explicitly enabled, prevent non-touch click events from triggering actions,
//		// to prevent ghost/doubleclicks.
//		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {
//
//			// Prevent any user-added listeners declared on FastClick element from being fired.
//			if (event.stopImmediatePropagation) {
//				event.stopImmediatePropagation();
//			} else {
//
//				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
//				event.propagationStopped = true;
//			}
//
//			// Cancel the event
//			event.stopPropagation();
//			event.preventDefault();
//
//			return false;
//		}
//
//		// If the mouse event is permitted, return true for the action to go through.
//		return true;
//	};
//
//
//	/**
//	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
//	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
//	 * an actual click which should be permitted.
//	 *
//	 * @param {Event} event
//	 * @returns {boolean}
//	 */
//	FastClick.prototype.onClick = function(event) {
//		var permitted;
//        
//		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
//		if (this.trackingClick) {
//			this.targetElement = null;
//			this.trackingClick = false;
//			return true;
//		}
//        
//		// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
//		if (event.target.type === 'submit' && event.detail === 0) {
//			return true;
//		}
//        
//		permitted = this.onMouse(event);
//        
//		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the //browser's click doesn't go through.
//		if (!permitted) {
//			this.targetElement = null;
//		}
//        
//		// If clicks are permitted, return true for the action to go through.
//		return permitted;
//	};
//
//
//	/**
//	 * Remove all FastClick's event listeners.
//	 *
//	 * @returns {void}
//	 */
//	FastClick.prototype.destroy = function() {
//		var layer = this.layer;
//
//		if (deviceIsAndroid) {
//			layer.removeEventListener('mouseover', this.onMouse, true);
//			layer.removeEventListener('mousedown', this.onMouse, true);
//			layer.removeEventListener('mouseup', this.onMouse, true);
//		}
//
//		layer.removeEventListener('click', this.onClick, true);
//		layer.removeEventListener('touchstart', this.onTouchStart, false);
//		layer.removeEventListener('touchmove', this.onTouchMove, false);
//		layer.removeEventListener('touchend', this.onTouchEnd, false);
//		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
//	};
//
//
//	/**
//	 * Check whether FastClick is needed.
//	 *
//	 * @param {Element} layer The layer to listen on
//	 */
//	FastClick.notNeeded = function(layer) {
//		var metaViewport;
//		var chromeVersion;
//		var blackberryVersion;
//		var firefoxVersion;
//
//		// Devices that don't support touch don't need FastClick
//		if (typeof window.ontouchstart === 'undefined') {
//			return true;
//		}
//
//		// Chrome version - zero for other browsers
//		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];
//
//		if (chromeVersion) {
//
//			if (deviceIsAndroid) {
//				metaViewport = document.querySelector('meta[name=viewport]');
//
//				if (metaViewport) {
//					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
//					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
//						return true;
//					}
//					// Chrome 32 and above with width=device-width or less don't need FastClick
//					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
//						return true;
//					}
//				}
//
//			// Chrome desktop doesn't need FastClick (issue #15)
//			} else {
//				return true;
//			}
//		}
//
//		if (deviceIsBlackBerry10) {
//			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);
//
//			// BlackBerry 10.3+ does not require Fastclick library.
//			// https://github.com/ftlabs/fastclick/issues/251
//			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
//				metaViewport = document.querySelector('meta[name=viewport]');
//
//				if (metaViewport) {
//					// user-scalable=no eliminates click delay.
//					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
//						return true;
//					}
//					// width=device-width (or less than device-width) eliminates click delay.
//					if (document.documentElement.scrollWidth <= window.outerWidth) {
//						return true;
//					}
//				}
//			}
//		}
//
//		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
//		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
//			return true;
//		}
//
//		// Firefox version - zero for other browsers
//		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];
//
//		if (firefoxVersion >= 27) {
//			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896
//
//			metaViewport = document.querySelector('meta[name=viewport]');
//			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
//				return true;
//			}
//		}
//
//		// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
//		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
//		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
//			return true;
//		}
//
//		return false;
//	};
//
//
//	/**
//	 * Factory method for creating a FastClick object
//	 *
//	 * @param {Element} layer The layer to listen on
//	 * @param {Object} [options={}] The options to override the defaults
//	 */
//	FastClick.attach = function(layer, options) {
//		return new FastClick(layer, options);
//	};
//
//
//	if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
//
//		// AMD. Register as an anonymous module.
//		define(function() {
//			return FastClick;
//		});
//	} else if (typeof module !== 'undefined' && module.exports) {
//		module.exports = FastClick.attach;
//		module.exports.FastClick = FastClick;
//	} else {
//		window.FastClick = FastClick;
//	}
//}());




/*
    json_parse.js
    2012-06-20

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    This file creates a json_parse function.

        json_parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = json_parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

    This is a reference implementation. You are free to copy, modify, or
    redistribute.

    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.
*/

/*members "", "\"", "\/", "\\", at, b, call, charAt, f, fromCharCode,
    hasOwnProperty, message, n, name, prototype, push, r, t, text
*/


window.JSON = window.JSON || {};

window.JSON.parse = (function () {
    "use strict";

// This is a function that can parse a JSON text, producing a JavaScript
// data structure. It is a simple, recursive descent parser. It does not use
// eval or regular expressions, so it can be used as a model for implementing
// a JSON parser in other languages.

// We are defining the function inside of another function to avoid creating
// global variables.

    var at,     // The index of the current character
        ch,     // The current character
        escapee = {
            '"':  '"',
            '\\': '\\',
            '/':  '/',
            b:    '\b',
            f:    '\f',
            n:    '\n',
            r:    '\r',
            t:    '\t'
        },
        text,

        error = function (m) {

// Call error when something is wrong.

            throw {
                name:    'SyntaxError',
                message: m,
                at:      at,
                text:    text
            };
        },

        next = function (c) {

// If a c parameter is provided, verify that it matches the current character.

            if (c && c !== ch) {
                error("Expected '" + c + "' instead of '" + ch + "'");
            }

// Get the next character. When there are no more characters,
// return the empty string.

            ch = text.charAt(at);
            at += 1;
            return ch;
        },

        number = function () {

// Parse a number value.

            var number,
                string = '';

            if (ch === '-') {
                string = '-';
                next('-');
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
            if (ch === '.') {
                string += '.';
                while (next() && ch >= '0' && ch <= '9') {
                    string += ch;
                }
            }
            if (ch === 'e' || ch === 'E') {
                string += ch;
                next();
                if (ch === '-' || ch === '+') {
                    string += ch;
                    next();
                }
                while (ch >= '0' && ch <= '9') {
                    string += ch;
                    next();
                }
            }
            number = +string;
            if (!isFinite(number)) {
                error("Bad number");
            } else {
                return number;
            }
        },

        string = function () {

// Parse a string value.

            var hex,
                i,
                string = '',
                uffff;

// When parsing for string values, we must look for " and \ characters.

            if (ch === '"') {
                while (next()) {
                    if (ch === '"') {
                        next();
                        return string;
                    }
                    if (ch === '\\') {
                        next();
                        if (ch === 'u') {
                            uffff = 0;
                            for (i = 0; i < 4; i += 1) {
                                hex = parseInt(next(), 16);
                                if (!isFinite(hex)) {
                                    break;
                                }
                                uffff = uffff * 16 + hex;
                            }
                            string += String.fromCharCode(uffff);
                        } else if (typeof escapee[ch] === 'string') {
                            string += escapee[ch];
                        } else {
                            break;
                        }
                    } else {
                        string += ch;
                    }
                }
            }
            error("Bad string");
        },

        white = function () {

// Skip whitespace.

            while (ch && ch <= ' ') {
                next();
            }
        },

        word = function () {

// true, false, or null.

            switch (ch) {
            case 't':
                next('t');
                next('r');
                next('u');
                next('e');
                return true;
            case 'f':
                next('f');
                next('a');
                next('l');
                next('s');
                next('e');
                return false;
            case 'n':
                next('n');
                next('u');
                next('l');
                next('l');
                return null;
            }
            error("Unexpected '" + ch + "'");
        },

        value,  // Place holder for the value function.

        array = function () {

// Parse an array value.

            var array = [];

            if (ch === '[') {
                next('[');
                white();
                if (ch === ']') {
                    next(']');
                    return array;   // empty array
                }
                while (ch) {
                    array.push(value());
                    white();
                    if (ch === ']') {
                        next(']');
                        return array;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad array");
        },

        object = function () {

// Parse an object value.

            var key,
                object = {};

            if (ch === '{') {
                next('{');
                white();
                if (ch === '}') {
                    next('}');
                    return object;   // empty object
                }
                while (ch) {
                    key = string();
                    white();
                    next(':');
                    if (Object.hasOwnProperty.call(object, key)) {
                        error('Duplicate key "' + key + '"');
                    }
                    object[key] = value();
                    white();
                    if (ch === '}') {
                        next('}');
                        return object;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad object");
        };

    value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

        white();
        switch (ch) {
        case '{':
            return object();
        case '[':
            return array();
        case '"':
            return string();
        case '-':
            return number();
        default:
            return ch >= '0' && ch <= '9' ? number() : word();
        }
    };

// Return the json_parse function. It will have access to all of the above
// functions and variables.

    return function (source, reviver) {
        var result;

        text = source;
        at = 0;
        ch = ' ';
        result = value();
        white();
        if (ch) {
            error("Syntax error");
        }

// If there is a reviver function, we recursively walk the new structure,
// passing each name/value pair to the reviver function for possible
// transformation, starting with a temporary root object that holds the result
// in an empty key. If there is not a reviver function, we simply return the
// result.

        return typeof reviver === 'function'
            ? (function walk(holder, key) {
                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }({'': result}, ''))
            : result;
    };
}());// ##############################################################
// ################ doT.js AND RELATED FUNCTIONS ################
// ##############################################################

// Laura Doktorova https://github.com/olado/doT
// version: 1.0.3
(function(){function p(b,a,d){return("string"===typeof a?a:a.toString()).replace(b.define||h,function(a,c,e,g){0===c.indexOf("def.")&&(c=c.substring(4));c in d||(":"===e?(b.defineParams&&g.replace(b.defineParams,function(a,b,l){d[c]={arg:b,text:l}}),c in d||(d[c]=g)):(new Function("def","def['"+c+"']="+g))(d));return""}).replace(b.use||h,function(a,c){b.useParams&&(c=c.replace(b.useParams,function(a,b,c,l){if(d[c]&&d[c].arg&&l)return a=(c+":"+l).replace(/'|\\/g,"_"),d.__exp=d.__exp||{},d.__exp[a]=
d[c].text.replace(new RegExp("(^|[^\\w$])"+d[c].arg+"([^\\w$])","g"),"$1"+l+"$2"),b+"def.__exp['"+a+"']"}));var e=(new Function("def","return "+c))(d);return e?p(b,e,d):e})}function k(b){return b.replace(/\\('|\\)/g,"$1").replace(/[\r\t\n]/g," ")}var f={version:"1.0.3",templateSettings:{evaluate:/\{\{([\s\S]+?(\}?)+)\}\}/g,interpolate:/\{\{=([\s\S]+?)\}\}/g,encode:/\{\{!([\s\S]+?)\}\}/g,use:/\{\{#([\s\S]+?)\}\}/g,useParams:/(^|[^\w$])def(?:\.|\[[\'\"])([\w$\.]+)(?:[\'\"]\])?\s*\:\s*([\w$\.]+|\"[^\"]+\"|\'[^\']+\'|\{[^\}]+\})/g,
define:/\{\{##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\}\}/g,defineParams:/^\s*([\w$]+):([\s\S]+)/,conditional:/\{\{\?(\?)?\s*([\s\S]*?)\s*\}\}/g,iterate:/\{\{~\s*(?:\}\}|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\}\})/g,varname:"it",strip:!0,append:!0,selfcontained:!1,doNotSkipEncoded:!1},template:void 0,compile:void 0},m;



// f.encodeHTMLSource = function(b) {
//         var a = {
//                 "&": "&#38;",
//                 "<": "&#60;",
//                 ">": "&#62;",
//                 '"': "&#34;",
//                 "'": "&#39;",
//                 "/": "&#47;"
//             },
//             d = b ? /[&<>"'\/]/g : /&(?!#?\w+;)|<|>|"|'|\//g;
//         return function(b) {
//                 return b ?

f.encodeHTMLSource=function(b){var a={"&":"&#38;","<":"&#60;",">":"&#62;",'"':"&#34;","'":"&#39;","/":"&#47;"},d=b?/[&<>"'\/]/g:/&(?!#?\w+;)|<|>|"|'|\//g;return function(b){return b?
b.toString().replace(d,function(b){return a[b]||b}):b}}; // replaced :"" with :b so that if you put a zero in encodehtml you get a zero out of encodehtml


m=function(){return this||(0,eval)("this")}();

"undefined"!==typeof module&&module.exports?module.exports=f:"function"===typeof define&&define.amd?define(function(){return f}):m.doT=f;



var r={start:"'+(",end:")+'",startencode:"'+encodeHTML("},s={start:"';out+=(",end:");out+='",startencode:"';out+=encodeHTML("},h=/$^/;f.template=function(b,a,d){a=a||f.templateSettings;var n=a.append?r:s,c,e=0,g;b=a.use||a.define?p(a,b,d||{}):b;b=("var out='"+(a.strip?
b.replace(/(^|\r|\n)\t* +| +\t*(\r|\n|$)/g," ").replace(/\r|\n|\t|\/\*[\s\S]*?\*\//g,""):b).replace(/'|\\/g,"\\$&").replace(a.interpolate||h,function(b,a){return n.start+k(a)+n.end}).replace(a.encode||h,function(b,a){c=!0;return n.startencode+k(a)+n.end}).replace(a.conditional||h,function(b,a,c){return a?c?"';}else if("+k(c)+"){out+='":"';}else{out+='":c?"';if("+k(c)+"){out+='":"';}out+='"}).replace(a.iterate||h,function(b,a,c,d){if(!a)return"';} } out+='";e+=1;g=d||"i"+e;a=k(a);return"';var arr"+
e+"="+a+";if(arr"+e+"){var "+c+","+g+"=-1,l"+e+"=arr"+e+".length-1;while("+g+"<l"+e+"){"+c+"=arr"+e+"["+g+"+=1];out+='"}).replace(a.evaluate||h,function(a,b){return"';"+k(b)+"out+='"})+"';return out;").replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/\r/g,"\\r").replace(/(\s|;|\}|^|\{)out\+='';/g,"$1").replace(/\+''/g,"");c&&(a.selfcontained||!m||m._encodeHTML||(m._encodeHTML=f.encodeHTMLSource(a.doNotSkipEncoded)),b="var encodeHTML = typeof _encodeHTML !== 'undefined' ? _encodeHTML : ("+f.encodeHTMLSource.toString()+
"("+(a.doNotSkipEncoded||"")+"));"+b);try{return new Function(a.varname,b)}catch(q){throw"undefined"!==typeof console&&console.log("Could not create a template function: "+b),q;}};f.compile=function(b,a){return f.template(b,null,a)}


    // we use doT.js in the global space, but sometimes module may be
    //      defined (electron defines module automatically) so we need to copy dot to
    //      the global namespace
    if (!window.doT) { // && window.module
        window.doT = f;
        
        //window.doT.encodeHTMLSource = module.exports.encodeHTMLSource;
        //window.doT.compile = module.exports.compile;
        //window.doT.templateSettings = module.exports.templateSettings;
        //window.doT.template = module.exports.template;
    }
})();


doT.templateSettings = {
    evaluate:    /\{\{([\s\S]+?)\}\}/g,
    interpolate: /\{\{=([\s\S]+?)\}\}/g,
    encode:      /\{\{!([\s\S]+?)\}\}/g,
    use:         /\{\{#([\s\S]+?)\}\}/g,
    define:      /\{\{##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\}\}/g,
    conditional: /\{\{\?(\?)?\s*([\s\S]*?)\s*\}\}/g,
    iterate:     /\{\{~\s*(?:}}|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\}\})/g,
    varname: 'jo',
    strip: false,
    append: true,
    selfcontained: false
};

// html encoding function used by doT.js
function encodeHTML(text) {
    'use strict';
    var encode = {
        "&": "&#38;",
        "<": "&#60;",
        ">": "&#62;",
        '"': "&#34;",
        "'": "&#39;",
        "/": "&#47;"
    };
    return text ? text.toString().replace(/&|<|>|"|'|\//g, function (letter) {
        return encode[letter] || letter;
    }) : text;
}

// html decoding function
function decodeHTML(text) {
    'use strict';
    var decode = {
        "&#38;": "&",
        "&amp;": "&",
        
        "&#60;": "<",
        "&#62;": ">",
        
        "&lt;":  "<", // The rose by another name
        "&gt;":  ">", // The rose by another name
        
        "&#34;": '"',
        "&#39;": "'",
        "&#47;": "/"
    };
    return text ? text.toString().replace(/&#38;|&amp;|&#60;|&#62;|&lt;|&gt;|&#34;|&#39;|&#47;/g, function (letter) {
        return decode[letter] || letter;
    }) : text;
}

// multiline strings in javascript
//
// ml(function () {/*
//     multiline string
//     hey
// */console.log});
function ml(func) {
    'use strict';
    
    func = func.toString();
    
    return func.substring(func.indexOf('/*') + 2, func.indexOf('*/'));
}
//global window
//jslint white:true multivar:true

// ##############################################################
// ################# WARNING FOR NON-DEVELOPERS #################
// ##############################################################
console.log('%cOnly developers should be in this area', 'color: red; font-size: x-large');

// #############################################################
// ################### CROSS PLATFORM EVENTS ###################
// #############################################################

if (window.evt === undefined) {
    window.evt = {};
}

// function for testing if the device has touch capibilities
function touchDeviceTest() {
    'use strict';
    //return 'ontouchstart' in window ||    // works on most browsers
    //       'onmsgesturechange' in window; // works on ie10
    return (('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) || false;
}

// display type based on size
function getDeviceType() {
    'use strict';
    // if we are not on a touch device than we must be a desktop
    if (evt.touchDevice === false) {
        return 'desktop';
    }
    // if touch device and screen is bigger than normal phone
    if (evt.touchDevice === true && screen.width > 500) {
        return 'tablet';
    }
    // if the screen is small and we are a touch device we are a phone
    return 'phone';
}

/*DOC
Name:
    evt.*

Description:
    This is a collection of global variables that are used for browser-type detection and for using different events for different devices.
    The reason for this is because even though the 'mousedown' event works on a phone it is substantially slower than if you had used 'touchstart',
    But if you used 'touchstart' it wouldn't work on the computer so we wrap both under the name evt.mousedown and only give mobile browsers
    'touchstart' and desktop browsers 'mousedown' so that you dont have to differentiate.
    
List of variables:
    evt.touchDevice  equals true|false depending on whether or not we are on a touch-enabled devide
    evt.deviceType   equals 'desktop'|'tablet'|'phone' depending on what type of device you are on
    
    evt.mousedown    if we are on a touch device: 'touchstart'  else  'mousedown'
    evt.mouseover    if we are on a touch device: 'touchenter'  else  'mouseover'
    evt.mousemove    if we are on a touch device: 'touchmove'   else  'mousemove'
    evt.mouseout     if we are on a touch device: 'touchleave'  else  'mouseout'
    evt.mouseup      if we are on a touch device: 'touchend'    else  'mouseup'
    evt.click        if we are on a touch device: 'touchend'    else  'click'

*/

// this is for detecting whether or not we are in an touch device
evt.touchDevice = touchDeviceTest();

// set global variable for display type
evt.deviceType = getDeviceType();

evt.mousedown = evt.touchDevice ? 'touchstart': 'mousedown';
evt.mouseover = evt.touchDevice ? 'touchenter': 'mouseover';
evt.mousemove = evt.touchDevice ? 'touchmove' : 'mousemove';
evt.mouseout  = evt.touchDevice ? 'touchleave': 'mouseout';
evt.mouseup   = evt.touchDevice ? 'touchend'  : 'mouseup';
evt.click     = 'click';

// ##############################################################
// ########### PINK BACKGROUND WHEN NOT IN PRODUCTION ###########
// ##############################################################
if (window.location.hostname.toString().match(/test[^.]*\..*/i)) {
    window.addEventListener('load', function () {
        var styleElement, helperElement, helperFunction;
        
        styleElement = document.createElement('style');
        styleElement.innerHTML = 'body, body gs-panel, body gs-panel gs-header, body gs-panel gs-body, ' +
                                 'body gs-page, body gs-page gs-header, body gs-page gs-body {\n' +
                                 '    background-color: #FFBBBB;\n' +
                                 '}';
        
        document.head.appendChild(styleElement);
    });
}

// #############################################################
// #################### DEFINE GS NAMESPACE ####################
// #############################################################

if (window.GS === undefined) {
    window.GS = {};
    
    GS.version = function () {
        'use strict';
        return '1.1.1';
    };
    
    window.addEventListener('design-register-element', function () {
        'use strict';
        
        registerDesignSnippet('GS.version', 'GS.version', 'GS.version();');
    });
}

// ##############################################################
// ################## DEFINE support NAMESPACE ##################
// ##############################################################

if (window.shimmed === undefined) {
    window.shimmed = {};
}

// ##############################################################
// ############### DEFINE functionality NAMESPACE ###############
// ##############################################################

if (window.functionality === undefined) {
    window.functionality = {"errors": {}};
}

// ##############################################################
// ####################### NO CONSOLE FIX #######################
// ##############################################################

// in IE8 when the dev tools are not open "console.log" is not defined so if there was a log the page would error
//      this defines the console object if it is empty so that if there is a log it will not error in IE8
if (typeof console === 'undefined' || !console.log) {
    window.console = {
        log:   function () { 'use strict'; },
        info:  function () { 'use strict'; },
        debug: function () { 'use strict'; },
        warn:  function () { 'use strict'; },
        trace: function () { 'use strict'; },
        error: function () { 'use strict'; }
    };
}


// ##############################################################
// ######## PREVENT WINDOW OVERSCROLLING ON TOUCH DEVICE ########
// ##############################################################
/*
if (evt.touchDevice) {
    (function () {
        var startTime, startTouchTop, endTime, endTouchTop, lastTouchTop, currentTouchTop,
            bolCurrentlyMonitoring = false, bolTouchScrollPrevented = false, currentScrollingElement, scrollingLooper;
        
        window.ontouchstart = function(event){
            lastTouchTop = GS.mousePosition(event).top;
        };
        
        //window.addEventListener('scroll', function (event) {
        //    //console.log(event);
        //}, true);
        
        window.ontouchmove = function (event) {
            var currentTouchTop = GS.mousePosition(event).top, currentElement = GS.scrollParent(event.target), bolFoundScrollable = Boolean(currentElement);
            
            //console.log(currentElement,
            //            event.target,
            //            bolFoundScrollable,
            //            currentElement.scrollTop,
            //            currentElement.clientHeight,
            //            currentElement.scrollHeight,
            //            currentTouchTop,
            //            lastTouchTop);
            //console.log(currentElement.scrollTop <= 0,
            //            currentTouchTop > lastTouchTop,
            //            currentElement.scrollTop + currentElement.clientHeight >= currentElement.scrollHeight,
            //            currentTouchTop < lastTouchTop);
            
            if (bolFoundScrollable === false ||
                (currentElement.scrollTop <= 0 && currentTouchTop > lastTouchTop) ||
                (currentElement.scrollTop + currentElement.clientHeight >= currentElement.scrollHeight && currentTouchTop < lastTouchTop)) {
                
                //console.log('prevent default');
                
                bolTouchScrollPrevented = true;
                event.preventDefault();
                //event.stopPropagation();
                
            } else if (bolFoundScrollable === true && bolTouchScrollPrevented === true) {
                currentElement.scrollTop += (lastTouchTop - currentTouchTop);
            }
            
            currentScrollingElement = currentElement;
            lastTouchTop = currentTouchTop;
        };
        
        window.ontouchend = function () {
            bolTouchScrollPrevented = false;
        };
    })();
}*/


// ##############################################################
// ################### DATABASE NORMALIZATION ###################
// ##############################################################

GS.database = {"engine": "", "type": {}};
GS.database.engine = "postgres";


// if db is SQL Server: utf16 else utf8
(function () {
    "use strict";
    
    // get a cookie from the browser
    function getCookie(c_name) {
        var c_value = document.cookie, c_end,
            c_start = c_value.indexOf(" " + c_name + "=");

        if (c_start === -1) {
            c_start = c_value.indexOf(c_name + "=");
        }
        if (c_start === -1) {
            c_value = null;
        } else {
            c_start = c_value.indexOf("=", c_start) + 1;
            c_end = c_value.indexOf(";", c_start);
            if (c_end === -1) {
                c_end = c_value.length;
            }
            c_value = decodeURIComponent(c_value.substring(c_start, c_end));
        }
        return c_value;
    };

    if ((getCookie('DB') || 'PG').toUpperCase() === 'PG') {
        GS.database.engine = 'postgres';
    } else { //ss
        GS.database.engine = 'mssqlserver'
    }
    
    if (GS.database.engine === "postgres") {
        GS.database.type.text = "text";
        GS.database.type.timestamp = "timestamptz";
        
    } else if (GS.database.engine === "mssqlserver") {
        GS.database.type.text = "nvarchar(MAX)";
        GS.database.type.timestamp = "datetime";
    }
}());





// ##############################################################
// ########### LABEL CLICK: FOCUS USING FOR ATTRIBUTE ###########
// ##############################################################

window.addEventListener('click', function (event) {
    'use strict';
    var labelElement, targetElement;
    
    //console.log(event.target, GS.findParentTag(event.target, 'LABEL'));
    
    if (event.target.nodeName === 'LABEL') {
        labelElement = event.target;
    } else if (GS.findParentTag(event.target, 'LABEL')) {
        labelElement = GS.findParentTag(event.target, 'LABEL');
    }
    
    //console.log(labelElement, labelElement.getAttribute('for'));
    
    if (labelElement && labelElement.hasAttribute('for')) {
        targetElement = document.getElementById(labelElement.getAttribute('for'));
        
        //console.log(targetElement);
        //console.log(targetElement.focus, !targetElement.hasAttribute('disabled'));
        
        if (targetElement && targetElement.focus && !targetElement.hasAttribute('disabled')) {
            targetElement.focus();
        }
    }
});


// #############################################################
// ######################### PAGE CURL #########################
// #############################################################
(function () {
    function aboutDialog() {
        'use strict';
        var templateElement = document.createElement('template');
        
        templateElement.innerHTML = ml(function () {/*
            <gs-page>
                <gs-header><center><h3>About Envelope</h3></center></gs-header>
                <gs-body padded>
                    <gs-grid widths="1,1" reflow-at="767px">
                        <gs-block>
                            <center><h3><a target="_blank" href="http://x-tag.github.io/">X-Tag</a></h3></center>
                        </gs-block>
                        <gs-block>
                            <center><h4>Version Unknown</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center><h3><a target="_blank" href="http://olado.github.io/doT/">doT.js</a></h3></center>
                        </gs-block>
                        <gs-block>
                            <center><h4>{{DOT}}</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center><h3><a target="_blank" href="http://ace.c9.io/">Ace Editor</a></h3></center>
                        </gs-block>
                        <gs-block>
                            <center><h4>1.2.3</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center><h3><a target="_blank" href="http://jsbeautifier.org/">JSBeautifier</a></h3></center>
                        </gs-block>
                        <gs-block>
                            <center><h4>Version Unknown</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center>
                                <h3><a target="_blank" href="https://github.com/douglascrockford/JSON-js">
                                    json_parse.js (modified)
                                </a></h3>
                            </center>
                        </gs-block>
                        <gs-block>
                            <center><h4>Version Unknown</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center>
                                <h3><a target="_blank" href="https://www.polymer-project.org/1.0/">
                                    HTML Template Polyfill (modified)
                                </a></h3>
                            </center>
                        </gs-block>
                        <gs-block>
                            <center><h4>Version Unknown</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center>
                                <h3><a target="_blank" href="https://github.com/ftlabs/fastclick">FastClick</a></h3>
                            </center>
                        </gs-block>
                        <gs-block>
                            <center><h4>Version Unknown</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center>
                                <h3><a target="_blank" href="https://code.google.com/archive/p/crypto-js/">CryptoJS (MD5 Portion)</a></h3>
                            </center>
                        </gs-block>
                        <gs-block>
                            <center><h4>3.1.2</h4></center>
                        </gs-block>
                        
                    </gs-grid>
                    
                    <div>
                        All other source code and documentation copyright Workflow Products, LLC. All Rights Reserved.
                        <br /><br />
                        The Envelope platform is available for many platforms and most embedded devices. If you'd like your application built using Envelope technology please contact us.
                        <br /><br />
                        Commercial license terms for the Envelope platform are available for a small fee. Contact us for details.
                        <br /><br />
                        <center><b>Workflow Products, L.L.C.</b></center>
                        <center>609 W Harwood Road</center>
                        <center>Hurst, Texas 76054</center>
                        <center>(817) 503-9545</center>
                    </div>
                    <br />
                    <center><small><i>Copyright &copy; 2016-present by Workflow Products, L.L.C. (817) 503-9545</i></small></center>
                </gs-body>
                <gs-footer>
                    <gs-button dialogclose>Done</gs-button>
                </gs-footer>
            </gs-page>
        */}).replace(/\{\{DOT\}\}/gi, doT.version);
        
        GS.openDialog(templateElement);
    }
    
    
    window.addEventListener('load', function () {
        'use strict';
        var bolOpen, intMaxHeight, curlElement, menuElement, strPostageUName, strHTML, toggleCurl;
        
        if (window.bolCurl !== false) {
            bolOpen = false;
            intMaxHeight = 0;
            curlElement = document.createElement('div');
            menuElement = document.createElement('div');
            strPostageUName = GS.getCookie('postage_uname');
            strHTML = '';
            
            curlElement.setAttribute('id', 'gs-document-curl-container');
            curlElement.innerHTML = '<div id="gs-document-curl-part-1"></div>' +
                                    '<div id="gs-document-curl-part-2"></div>' +
                                    '<div id="gs-document-curl-part-3"></div>' +
                                    '<div id="gs-document-curl-part-4"></div>';
            
            document.body.appendChild(curlElement);
            
            if (evt.deviceType === 'phone') {
                curlElement.setAttribute('style', 'font-size: 1.3em;');
            } else {
                curlElement.setAttribute('style', 'font-size: 0.7em;');
            }
            
            menuElement.setAttribute('id', 'gs-document-menu-container');
            menuElement.setAttribute('style', 'height: 0px;');
            
            // this is for envelope
            if (location.pathname.indexOf('/env/') === 0) {
                strHTML += '<center><gs-button target="_self" href="/env/app/all/index.html" inline>Back To Main Menu</gs-button></center>';
                strHTML += '<center>' +
                                '<gs-button target="_self" href="/env/auth/?action=logout" inline>Log out</gs-button><br />' +
                                '<gs-button onclick="GS.userChangePassword()" inline>Change Password</gs-button>' +
                            '</center>';
                intMaxHeight += 4.8;
                
            // and this is for postage
            } else {
                strHTML += '<center>' +
                                '<gs-button target="_self" href="/postage/auth?action=logout" inline>Log out</gs-button><br />' +
                                '<gs-button onclick="GS.userChangePassword()" inline>Change Password</gs-button>' +
                            '</center>';
                intMaxHeight += 3.4;
            }
            
            strHTML += '<center><gs-button onclick="GS.showShimmed()" inline>Browser Support</gs-button></center>';
            intMaxHeight += 1.9;
            
            strHTML += '<center><gs-button onclick="window.location.reload(true);" inline>Update Software</gs-button></center>';
            intMaxHeight += 1.9;
            
            if (location.pathname.indexOf('/env/') === 0) {
                strHTML += '<center><gs-button id="gs-button-about" inline>About</gs-button></center>';
                intMaxHeight += 1.9;
            }
            
            intMaxHeight += 1;
            
            menuElement.innerHTML = '<div id="gs-document-menu-link-container" style="height: ' + intMaxHeight + 'em;">' + strHTML + '</div>';
            document.body.appendChild(menuElement);
            // var testEMPXElement = document.createElement('div');
            // testEMPXElement.setAttribute('hidden', '');
            // testEMPXElement.setAttribute('id', 'testEMPXElement')
            // document.body.appendChild(testEMPXElement);
            
            if (location.pathname.indexOf('/env/') === 0) {
                document.getElementById('gs-button-about').addEventListener('click', aboutDialog);
            }
            
            // define function for toggling the page curl
            toggleCurl = function () {
                var intFontSize = GS.pxToEm(document.body, window.innerWidth) / 4,
                    intBottomLine = window.innerHeight - (GS.emToPx(document.body, intFontSize)),
                    closedSize = (evt.deviceType === 'phone' ? '1.3em' : '0.7em'); // replace evt.touchDevice with true to test on a desktop
                
                // maximum bottom line
                if (GS.pxToEm(document.body, intBottomLine) > intMaxHeight) {
                    intBottomLine = GS.emToPx(document.body, intMaxHeight);
                }
                
                //curlElement.classList.add('animating');
                //menuElement.classList.add('animating');
                
                if (bolOpen === false) {
                    document.body.insertBefore(GS.stringToElement('<div id="gs-document-curl-modal-background"></div>'), curlElement);
                    document.getElementById('gs-document-curl-modal-background').addEventListener('click', toggleCurl);
                    
                    curlElement.style.fontSize = intFontSize + 'em';
                    curlElement.style.bottom = intBottomLine + 'px';
                    menuElement.style.height = intBottomLine + 'px';
                    
                    //GS.animateStyle(curlElement, 'font-size', closedSize, intFontSize + 'em', function () {
                    //    curlElement.classList.remove('animating');
                    //}, 185, 14);
                    //
                    //GS.animateStyle(curlElement, 'bottom', '0px', intBottomLine + 'px', function () {
                    //    curlElement.classList.remove('animating');
                    //}, 185, 14);
                    //
                    //GS.animateStyle(menuElement, 'height', '0px', intBottomLine + 'px', function () {
                    //    menuElement.classList.remove('animating');
                    //}, 185, 14);
                    
                    bolOpen = true;
                } else {
                    document.body.removeChild(document.getElementById('gs-document-curl-modal-background'));
                    
                    curlElement.style.fontSize = closedSize;
                    curlElement.style.bottom = '0px';
                    menuElement.style.height = '0px';
                    
                    //GS.animateStyle(curlElement, 'font-size', intFontSize + 'em', closedSize, function () {
                    //    curlElement.classList.remove('animating');
                    //}, 185, 14);
                    //
                    //GS.animateStyle(curlElement, 'bottom', intBottomLine + 'px', '0px', function () {
                    //    curlElement.classList.remove('animating');
                    //}, 185, 14);
                    //
                    //GS.animateStyle(menuElement, 'height', intBottomLine + 'px', '0px', function () {
                    //    menuElement.classList.remove('animating');
                    //}, 185, 14);
                    
                    bolOpen = false;
                }
            };
            
            curlElement.addEventListener('click', toggleCurl);
        }
    });
})();

// ################################################################
// ###################### FASTCLICK POLYFILL ######################
// ################################################################

// double clicks will not work while using fastclick
// click events will not have a delay while using fastclick
// we chose fastclick :)

// if you need to turn fastclick off for an element use the "needsclick" class
// if you need to turn fastclick off for an elements children (but not the element itself) use the "childrenneedsclick" class
// if you need to turn fastclick off for an elements children and the element itself use the "childrenneedsclick" class and the "needsclick" class
if ('addEventListener' in document) {
    document.addEventListener('DOMContentLoaded', function() {
        'use strict';
        FastClick.attach(document.body);
    }, false);
}



// ##################################################################
// ##################### TEMPLATE GET INERT DOM #####################
// ##################################################################
/*
HTMLTemplateElement.prototype.contentTemplate = function () {
    'use strict';
    
    if (this.content) {
        
    } else {
        
    }
};
*/

// #################################################################
// ###################### POLYFILL/SHIM CHECK ######################
// #################################################################

window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('GS.showShimmed', 'GS.showShimmed', 'GS.showShimmed();');
});

window.addEventListener('load', function () {
    'use strict';
    function cleanFunctionForTest(fn) {
        fn = fn.toString().toLowerCase();   // convert function string and turn all text lowercase
        fn = fn.substring(fn.indexOf('{')); // remove everything up until the first open curly brace
        fn = fn.replace(/ /gim, '');        // remove all spaces
        
        return fn;
    }
    
    function nativeTest(fn) {
        // if there is not function: not native: return false
        if (!fn) {
            return false;
        }
        
        // clean function for native testing
        fn = cleanFunctionForTest(fn);
        
        return fn.indexOf('[nativecode]') > -1 ||                   // if '[nativecode]' is found in the cleaned text: native
               fn === cleanFunctionForTest(document.createElement); // else if the cleaned text matches a native function: native
    }
    
    shimmed.matchesSelector     = !nativeTest(Element.prototype.matchesSelector) &&
                                  !nativeTest(Element.prototype.webkitMatchesSelector) &&
                                  !nativeTest(Element.prototype.mozMatchesSelector) &&
                                  !nativeTest(Element.prototype.msMatchesSelector) &&
                                  !nativeTest(Element.prototype.MSMatchesSelector);
    
    shimmed.MutationObserver    = !nativeTest(window.MutationObserver);
    shimmed.WeakMap             = !nativeTest(window.WeakMap);
    shimmed.customElements      = !nativeTest(customElements.define);
    shimmed.registerElement     = !nativeTest(document.registerElement);
    shimmed.DOMTokenList        = !nativeTest(window.DOMTokenList);
    shimmed.HTMLTemplateElement = Boolean(HTMLTemplateElement.bootstrap);
    
    // automated functionality testing
    
    functionality.matchesSelector = false;
    try {
        var bodyElement = document.body
          , matchesSelector = (Element.prototype.matchesSelector
                                || Element.prototype.webkitMatchesSelector
                                || Element.prototype.mozMatchesSelector
                                || Element.prototype.msMatchesSelector
                                || Element.prototype.MSMatchesSelector);
        
        functionality.matchesSelector = matchesSelector.apply(bodyElement, ['body']);
        
    } catch (e) {
        functionality.matchesSelector = false;
        functionality.errors.matchesSelector = e;
    }
    
    functionality.MutationObserver = false;
    try {
        var testElement = document.createElement('div'), observer;
        
        observer = new MutationObserver(function(mutations) {
            functionality.MutationObserver = (mutations.length > 0);
        });
        
        observer.observe(testElement, {'childList': true});
        testElement.appendChild(document.createElement('div'));
    } catch (e) {
        functionality.MutationObserver = false;
        functionality.errors.MutationObserver = e;
    }
    
    functionality.WeakMap = false;
    try {
        var testMap = new WeakMap(), testObject = function(){};
        
        testMap.set(testObject, 'asdfasdf');
        
        functionality.WeakMap = (testMap.get(testObject) === 'asdfasdf');
        functionality.WeakMap = (functionality.WeakMap && testMap.has(testObject) === true);
        
        testMap.delete(testObject);
        
        functionality.WeakMap = (functionality.WeakMap && testMap.has(testObject) === false);
        
    } catch (e) {
        functionality.WeakMap = false;
        functionality.errors.WeakMap = e;
    }
    
    functionality.customElements = false;
    try {
        function AsdfElement() { return Reflect.construct(HTMLElement, [], new.target); }
        AsdfElement.prototype = Object.create(HTMLElement.prototype);
        AsdfElement.prototype.testmethod = function () {
            return true;
        };
        customElements.define('asdf-test', AsdfElement);
        
        var testElement;
        testElement = document.createElement('asdf-test');
        
        functionality.customElements = testElement.testmethod();
        
    } catch (e) {
        functionality.customElements = false;
        functionality.errors.customElements = e;
    }
    
    functionality.registerElement = false;
    try {
        var prototype = Object.create(HTMLElement.prototype);
        prototype.testmethod = function () { return true; };
        document.registerElement('asdf-test', {'prototype': prototype});
        
        var testElement;
        testElement = document.createElement('asdf-test');
        
        functionality.registerElement = testElement.testmethod();
        
    } catch (e) {
        functionality.registerElement = false;
        functionality.errors.registerElement = e;
    }
    
    functionality.DOMTokenList = false;
    try {
        functionality.DOMTokenList = Boolean(document.body.classList);
    } catch (e) {
        functionality.DOMTokenList = false;
        functionality.errors.DOMTokenList = e;
    }
    
    functionality.HTMLTemplateElement = false;
    try {
        var testElement = document.createElement('template');
        
        xtag.register('asdf-test-two', {
            'lifecycle': {
                'created': function () {
                    var divElement = document.createElement('div');
                    divElement.classList.add('find-me');
                    this.appendChild(divElement);
                }
            }
        });
        testElement.innerHTML = '<div></div><p></p><asdf-test-two></asdf-test-two>';
        
        functionality.HTMLTemplateElement = (xtag.query(testElement, '.find-me').length === 0);
        
    } catch (e) {
        functionality.HTMLTemplateElement = false;
        functionality.errors.HTMLTemplateElement = e;
    }
    
    // function to show shim and functionality results
    GS.showShimmed = function () {
        var strHTML = '', key, templateElement;
        
        strHTML += '<br />\n' +
                   '<center>This dialog is for developers so that they can determine what technologies this browser supports and what technologies are being implemented manually.</center>\n' +
                   '<br />\n' +
                   '<hr />\n';
        
        for (key in shimmed) {
            strHTML += '<gs-grid reflow-at="450px">\n' +
                       '    <gs-block><center>' + encodeHTML(key) + '</center></gs-block>\n' +
                       '    <gs-block>\n' +
                       '        <center><b>' + (shimmed[key] ? 'SHIMMED' : 'NATIVE') + '</center></b>\n' +
                       '    </gs-block>\n' +
                       '    <gs-block>\n' +
                       '        <center>' + (functionality[key] ? '<b style="color: #3F9A3F;">FUNCTION PASS' : '<b style="color: #F00;">FUNCTION FAIL') + '</center></b>\n' +
                       '    </gs-block>\n' +
                       '</gs-grid>\n' +
                       '<hr />\n';
        }
        
        strHTML += '<br />';
        
        
        templateElement = document.createElement('template');
        
        templateElement.innerHTML = ml(function () {/*
            <gs-page>
                <gs-header><center><h3>Native Detection</h3></center></gs-header>
                <gs-body padded>
                    {{HTML}}
                </gs-body>
                <gs-footer><gs-button dialogclose>Done</gs-button></gs-footer>
            </gs-page>
        */}).replace('{{HTML}}', strHTML);
        
        GS.openDialog(templateElement);
    };
});

// ##################################################################
// ################ MULTIPLE ONBEFOREUNLOAD HANDLERS ################
// ##################################################################


window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('GS.addBeforeUnloadEvent', 'GS.addBeforeUnloadEvent', 'GS.addBeforeUnloadEvent(function () {' +
                                                                    '    $0' +
                                                                    '});');
});

(function () {
    'use strict';
    var arrFunctions = [],
        unloadFunction = function () {
            var i, len, ret, current;
            
            for (i = 0, len = arrFunctions.length; i < len; i += 1) {
                current = arrFunctions[i]();
                
                if (current && !ret) {
                    ret = current;
                }
            }
            
            if (ret) {
                return ret;
            }
        };
    
    window.addEventListener('load', function () {
        if (window.onbeforeunload && window.onbeforeunload !== unloadFunction) {
            console.error('Please use the GS.addUnloadEvent function to run code onbeforeunload.');
        }
    });
    
    GS.addBeforeUnloadEvent = function (functionToCall) {
        if (typeof functionToCall !== 'function') {
            throw new TypeError('GS.addUnloadEvent takes one argument, and it must be a function.');
        }
        
        if (!window.onbeforeunload) {
            window.onbeforeunload = unloadFunction;
            
        } else if (window.onbeforeunload !== unloadFunction) {
            console.error('Please use just the GS.addBeforeUnloadEvent function to run code onbeforeunload.');
            window.onbeforeunload = unloadFunction;
        }
        
        arrFunctions.push(functionToCall);
    };
})();





/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(h,r){var k={},l=k.lib={},n=function(){},f=l.Base={extend:function(a){n.prototype=this;var b=new n;a&&b.mixIn(a);b.hasOwnProperty("init")||(b.init=function(){b.$super.init.apply(this,arguments)});b.init.prototype=b;b.$super=this;return b},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var b in a)a.hasOwnProperty(b)&&(this[b]=a[b]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
j=l.WordArray=f.extend({init:function(a,b){a=this.words=a||[];this.sigBytes=b!=r?b:4*a.length},toString:function(a){return(a||s).stringify(this)},concat:function(a){var b=this.words,d=a.words,c=this.sigBytes;a=a.sigBytes;this.clamp();if(c%4)for(var e=0;e<a;e++)b[c+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((c+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)b[c+e>>>2]=d[e>>>2];else b.push.apply(b,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,b=this.sigBytes;a[b>>>2]&=4294967295<<
32-8*(b%4);a.length=h.ceil(b/4)},clone:function(){var a=f.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var b=[],d=0;d<a;d+=4)b.push(4294967296*h.random()|0);return new j.init(b,a)}}),m=k.enc={},s=m.Hex={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++){var e=b[c>>>2]>>>24-8*(c%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join("")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c+=2)d[c>>>3]|=parseInt(a.substr(c,
2),16)<<24-4*(c%8);return new j.init(d,b/2)}},p=m.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++)d.push(String.fromCharCode(b[c>>>2]>>>24-8*(c%4)&255));return d.join("")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c++)d[c>>>2]|=(a.charCodeAt(c)&255)<<24-8*(c%4);return new j.init(d,b)}},t=m.Utf8={stringify:function(a){try{return decodeURIComponent(escape(p.stringify(a)))}catch(b){throw Error("Malformed UTF-8 data");}},parse:function(a){return p.parse(unescape(encodeURIComponent(a)))}},
q=l.BufferedBlockAlgorithm=f.extend({reset:function(){this._data=new j.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=t.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var b=this._data,d=b.words,c=b.sigBytes,e=this.blockSize,f=c/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;c=h.min(4*a,c);if(a){for(var g=0;g<a;g+=e)this._doProcessBlock(d,g);g=d.splice(0,a);b.sigBytes-=c}return new j.init(g,c)},clone:function(){var a=f.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});l.Hasher=q.extend({cfg:f.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){q.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,d){return(new a.init(d)).finalize(b)}},_createHmacHelper:function(a){return function(b,d){return(new u.HMAC.init(a,
d)).finalize(b)}}});var u=k.algo={};return k}(Math);
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(E){function h(a,f,g,j,p,h,k){a=a+(f&g|~f&j)+p+k;return(a<<h|a>>>32-h)+f}function k(a,f,g,j,p,h,k){a=a+(f&j|g&~j)+p+k;return(a<<h|a>>>32-h)+f}function l(a,f,g,j,h,k,l){a=a+(f^g^j)+h+l;return(a<<k|a>>>32-k)+f}function n(a,f,g,j,h,k,l){a=a+(g^(f|~j))+h+l;return(a<<k|a>>>32-k)+f}for(var r=CryptoJS,q=r.lib,F=q.WordArray,s=q.Hasher,q=r.algo,a=[],t=0;64>t;t++)a[t]=4294967296*E.abs(E.sin(t+1))|0;q=q.MD5=s.extend({_doReset:function(){this._hash=new F.init([1732584193,4023233417,2562383102,271733878])},
_doProcessBlock:function(m,f){for(var g=0;16>g;g++){var j=f+g,p=m[j];m[j]=(p<<8|p>>>24)&16711935|(p<<24|p>>>8)&4278255360}var g=this._hash.words,j=m[f+0],p=m[f+1],q=m[f+2],r=m[f+3],s=m[f+4],t=m[f+5],u=m[f+6],v=m[f+7],w=m[f+8],x=m[f+9],y=m[f+10],z=m[f+11],A=m[f+12],B=m[f+13],C=m[f+14],D=m[f+15],b=g[0],c=g[1],d=g[2],e=g[3],b=h(b,c,d,e,j,7,a[0]),e=h(e,b,c,d,p,12,a[1]),d=h(d,e,b,c,q,17,a[2]),c=h(c,d,e,b,r,22,a[3]),b=h(b,c,d,e,s,7,a[4]),e=h(e,b,c,d,t,12,a[5]),d=h(d,e,b,c,u,17,a[6]),c=h(c,d,e,b,v,22,a[7]),
b=h(b,c,d,e,w,7,a[8]),e=h(e,b,c,d,x,12,a[9]),d=h(d,e,b,c,y,17,a[10]),c=h(c,d,e,b,z,22,a[11]),b=h(b,c,d,e,A,7,a[12]),e=h(e,b,c,d,B,12,a[13]),d=h(d,e,b,c,C,17,a[14]),c=h(c,d,e,b,D,22,a[15]),b=k(b,c,d,e,p,5,a[16]),e=k(e,b,c,d,u,9,a[17]),d=k(d,e,b,c,z,14,a[18]),c=k(c,d,e,b,j,20,a[19]),b=k(b,c,d,e,t,5,a[20]),e=k(e,b,c,d,y,9,a[21]),d=k(d,e,b,c,D,14,a[22]),c=k(c,d,e,b,s,20,a[23]),b=k(b,c,d,e,x,5,a[24]),e=k(e,b,c,d,C,9,a[25]),d=k(d,e,b,c,r,14,a[26]),c=k(c,d,e,b,w,20,a[27]),b=k(b,c,d,e,B,5,a[28]),e=k(e,b,
c,d,q,9,a[29]),d=k(d,e,b,c,v,14,a[30]),c=k(c,d,e,b,A,20,a[31]),b=l(b,c,d,e,t,4,a[32]),e=l(e,b,c,d,w,11,a[33]),d=l(d,e,b,c,z,16,a[34]),c=l(c,d,e,b,C,23,a[35]),b=l(b,c,d,e,p,4,a[36]),e=l(e,b,c,d,s,11,a[37]),d=l(d,e,b,c,v,16,a[38]),c=l(c,d,e,b,y,23,a[39]),b=l(b,c,d,e,B,4,a[40]),e=l(e,b,c,d,j,11,a[41]),d=l(d,e,b,c,r,16,a[42]),c=l(c,d,e,b,u,23,a[43]),b=l(b,c,d,e,x,4,a[44]),e=l(e,b,c,d,A,11,a[45]),d=l(d,e,b,c,D,16,a[46]),c=l(c,d,e,b,q,23,a[47]),b=n(b,c,d,e,j,6,a[48]),e=n(e,b,c,d,v,10,a[49]),d=n(d,e,b,c,
C,15,a[50]),c=n(c,d,e,b,t,21,a[51]),b=n(b,c,d,e,A,6,a[52]),e=n(e,b,c,d,r,10,a[53]),d=n(d,e,b,c,y,15,a[54]),c=n(c,d,e,b,p,21,a[55]),b=n(b,c,d,e,w,6,a[56]),e=n(e,b,c,d,D,10,a[57]),d=n(d,e,b,c,u,15,a[58]),c=n(c,d,e,b,B,21,a[59]),b=n(b,c,d,e,s,6,a[60]),e=n(e,b,c,d,z,10,a[61]),d=n(d,e,b,c,q,15,a[62]),c=n(c,d,e,b,x,21,a[63]);g[0]=g[0]+b|0;g[1]=g[1]+c|0;g[2]=g[2]+d|0;g[3]=g[3]+e|0},_doFinalize:function(){var a=this._data,f=a.words,g=8*this._nDataBytes,j=8*a.sigBytes;f[j>>>5]|=128<<24-j%32;var h=E.floor(g/
4294967296);f[(j+64>>>9<<4)+15]=(h<<8|h>>>24)&16711935|(h<<24|h>>>8)&4278255360;f[(j+64>>>9<<4)+14]=(g<<8|g>>>24)&16711935|(g<<24|g>>>8)&4278255360;a.sigBytes=4*(f.length+1);this._process();a=this._hash;f=a.words;for(g=0;4>g;g++)j=f[g],f[g]=(j<<8|j>>>24)&16711935|(j<<24|j>>>8)&4278255360;return a},clone:function(){var a=s.clone.call(this);a._hash=this._hash.clone();return a}});r.MD5=s._createHelper(q);r.HmacMD5=s._createHmacHelper(q)})(Math);
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){if("function"==typeof ArrayBuffer){var b=CryptoJS.lib.WordArray,e=b.init;(b.init=function(a){a instanceof ArrayBuffer&&(a=new Uint8Array(a));if(a instanceof Int8Array||a instanceof Uint8ClampedArray||a instanceof Int16Array||a instanceof Uint16Array||a instanceof Int32Array||a instanceof Uint32Array||a instanceof Float32Array||a instanceof Float64Array)a=new Uint8Array(a.buffer,a.byteOffset,a.byteLength);if(a instanceof Uint8Array){for(var b=a.byteLength,d=[],c=0;c<b;c++)d[c>>>2]|=a[c]<<
24-8*(c%4);e.call(this,d,b)}else e.apply(this,arguments)}).prototype=b}})();

// if db is SQL Server: utf16 else utf8
(function () {
    "use strict";
    
    // get a cookie from the browser
    function getCookie(c_name) {
        var c_value = document.cookie, c_end,
            c_start = c_value.indexOf(" " + c_name + "=");

        if (c_start === -1) {
            c_start = c_value.indexOf(c_name + "=");
        }
        if (c_start === -1) {
            c_value = null;
        } else {
            c_start = c_value.indexOf("=", c_start) + 1;
            c_end = c_value.indexOf(";", c_start);
            if (c_end === -1) {
                c_end = c_value.length;
            }
            c_value = decodeURIComponent(c_value.substring(c_start, c_end));
        }
        return c_value;
    };

    if ((getCookie('DB') || 'PG').toUpperCase() === 'PG') {
        GS.utfSafeMD5 = CryptoJS.MD5;
    } else { //ss
        GS.utfSafeMD5 = function (str) {
            "use strict";
            var buf = new ArrayBuffer(str.length * 2);
            var bufView = new Uint16Array(buf);
            var i;
            var strLen;

            for (i = 0, strLen = str.length; i < strLen; i += 1) {
                bufView[i] = str.charCodeAt(i);
            }

            return CryptoJS.MD5(CryptoJS.lib.WordArray.create(bufView));
        }
    }
}());
//global registerDesignSnippet

// snippets are in the textmate format more info:
//      http://blog.macromates.com/2005/the-power-of-snippets/

window.addEventListener('design-register-element', function () {
    // uncategorized snippets
    registerDesignSnippet('Lorem Ipsum', 'Lorem Ipsum', 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.');

    registerDesignSnippet('Document Start', 'Document Start',
            '<!DOCTYPE html>\n' +
            '<html lang="en">\n' +
            '    <head>\n' +
            '        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />\n' +
            '        <meta name="apple-mobile-web-app-capable" content="yes" />\n' +
            '        <meta name="apple-mobile-web-app-status-bar-style" content="black" />\n' +
            '        <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1.0, minimal-ui" />\n' +
            '        <!-- Make this page use standard caching procedure when used as an iframe -->\n' +
            '        <meta http-equiv="Cache-control" content="no-store, must-revalidate" />\n' +
            '        \n' +
            '        <title>${1:New Page}</title>\n' +
            '        \n' +
            '        <script src="/js/greyspots.js" type="text/javascript"></script>\n' +
            '        <link href="/css/greyspots.css" type="text/css" rel="stylesheet" />\n' +
            '        \n' +
            '        <script>\n' +
            '//global GS, ml, evt, document, window\n' +
            '//jslint browser:true\n' +
            '\n' +
            '\n' +
            '        </script>\n' +
            '        \n' +
            '        <style>\n' +
            '\n' +
            '        </style>\n' +
            '    </head>\n' +
            '    <body>\n' +
            '        $0\n' +
            '    </body>\n' +
            '</html>');

    registerDesignSnippet('Centered H1', 'Centered H1', '<center><h1>$0</h1></center>');
    registerDesignSnippet('Centered H2', 'Centered H2', '<center><h2>$0</h2></center>');
    registerDesignSnippet('Centered H3', 'Centered H3', '<center><h3>$0</h3></center>');
    registerDesignSnippet('Centered H4', 'Centered H4', '<center><h4>$0</h4></center>');
    registerDesignSnippet('Centered H5', 'Centered H5', '<center><h5>$0</h5></center>');
    registerDesignSnippet('Centered H6', 'Centered H6', '<center><h6>$0</h6></center>');
    registerDesignSnippet('thead', 'thead',
            'thead>\n' +
            '    <tr>\n' +
            '        <th>\n' +
            '            $1\n' +
            '        </th>\n' +
            '    </tr>\n' +
            '</thead>\n');
    registerDesignSnippet('tbody', 'tbody',
            'tbody>\n' +
            '    <tr>\n' +
            '        <td>\n' +
            '            $1\n' +
            '        </td>\n' +
            '    </tr>\n' +
            '</tbody>\n');

    registerDesignSnippet('Table Template', 'Table Template',
            'template>\n' +
            '    <thead>\n' +
            '        <tr>\n' +
            '            <th>\n' +
            '                $1\n' +
            '            </th>\n' +
            '        </tr>\n' +
            '    </thead>\n' +
            '    <tbody>\n' +
            '        <tr>\n' +
            '            <td>\n' +
            '                $2\n' +
            '            </td>\n' +
            '        </tr>\n' +
            '    </tbody>\n' +
            '</template>\n');



    registerDesignSnippet('Format JSON', 'JSON.stringify', 'JSON.stringify(${1:value}, ${2:replacer}, ${3:space});');


    registerDesignSnippet('setInterval', 'setInterval',
            'var ${1:intervalId} = setInterval(function(){\n' +
            '    ${3}\n' +
            '}, ${2:milliseconds});\n');


    registerDesignSnippet('clearInterval', 'clearInterval', 'clearInterval(${1:intervalId});');



    registerDesignSnippet('setTimeout', 'setTimeout',
            'var ${1:intervalId} = setTimeout(function(){\n' +
            '    ${3}\n' +
            '}, ${2:milliseconds});\n');


    registerDesignSnippet('clearTimeout', 'clearTimeout', 'clearTimeout(${1:intervalId});');

    // javascript snippets
    registerDesignSnippet('Xtag Register', 'xtag.register',
            'window.addEventListener(\'design-register-element\', function () {\n' +
            'window.designElementProperty_GS${1:element} = function (selectedElement) {\n' +
            '        // Sample properties:\n' +
            '        // Checkbox:\n' +
            '        // addProp(\'Property\', true, \'<gs-checkbox class="target" value="\' + (selectedElement.hasAttribute(\'property\') || \'\') + \'" mini></gs-checkbox>\', function () {\n' +
            '        //     return setOrRemoveBooleanAttribute(selectedElement, \'property\', this.value === \'true\', true);\n' +
            '        // });\n' +
            '        // Text:\n' +
            '        // addProp(\'Property\', true, \'<gs-text class="target" value="\' + encodeHTML(selectedElement.getAttribute(\'property\') || \'\') + \'" mini></gs-text>\', function () {\n' +
            '        //     return setOrRemoveTextAttribute(selectedElement, \'property\', this.value, false);\n' +
            '        // });\n' +
            '    };\n' +
            '});\n' +
            '\n' +
            '//global xtag\n' +
            '//jslint browser:true\n' +
            'document.addEventListener("DOMContentLoaded", function () {\n' +
            '    "use strict";\n' +
            '    // dont do anything that modifies the element here\n' +
            '    function elementCreated(element) {\n' +
            '        // if "created" hasn\'t been suspended: run created code\n' +
            '        if (!element.hasAttribute(\'suspend-created\')) {\n' +
            '            ${2:Created Code}\n' +
            '        }\n' +
            '    }\n' +
            '\n' +
            '    function elementInserted(element) {\n' +
            '        // if "created" hasn\'t been suspended and "inserted" hasn\'t been suspended: run inserted code\n' +
            '        if (!element.hasAttribute("suspend-created") && !element.hasAttribute("suspend-inserted")) {\n' +
            '            // if this is the first time inserted has been run: continue\n' +
            '            if (!element.inserted) {\n' +
            '                element.inserted = true;\n' +
            '                ${3:Inserted Code}\n' +
            '            }\n' +
            '        }\n' +
            '    }\n' +
            '\n' +
            '    xtag.register("${1:element}", {\n' +
            '        lifecycle: {\n' +
            '            created function () {\n' +
            '                elementCreated(this);\n' +
            '            },\n' +
            '            inserted: function () {\n' +
            '                elementInserted(this);\n' +
            '            },\n' +
            '            attributeChanged: function (strAttrName, oldValue, newValue) {\n' +
            '                var element = this;\n' +
            '\n' +
            '                // if "suspend-created" has been removed: run created and inserted code\n' +
            '                if (strAttrName === "suspend-created" && newValue === null) {\n' +
            '                    elementInserted(element);\n' +
            '\n' +
            '                // if "suspend-inserted" has been removed: run inserted code\n' +
            '                } else if (strAttrName === "suspend-inserted" && newValue === null) {\n' +
            '                    elementInserted(element);\n' +
            '                }\n' +
            '            }\n' +
            '        },\n' +
            '        events: {},\n' +
            '        accessors: {\n' +
            '            // Sample accessor:\n' +
            '            // \'value\': {\n' +
            '            //     get: function () {\n' +
            '            //         var element = this;\n' +
            '            //     },\n' +
            '            //     set: function (strNewValue) {\n' +
            '            //         var element = this;\n' +
            '            //     }\n' +
            '            // }\n' +
            '        },\n' +
            '        methods: {\n' +
            '            // Sample method:\n' +
            '            // \'method\': function () {\n' +
            '            //     var element = this;\n' +
            '            // }\n' +
            '        }\n' +
            '    });\n' +
            '});');
    
    registerDesignSnippet('While Loop', 'While Loop', 'var i = ${0:0);\n'
        + 'var len = ${1:10);\n'
        + 'while (i < len) {\n'
        + '    $3\n'
        + '    i++;\n'
        + '}\n');
    
    registerDesignSnippet('Window Load', 'window.addEventListener',
            'window.addEventListener(\'load\', function () {\n' +
            '    $0\n' +
            '});');

    registerDesignSnippet('Multiline String', 'Multiline String',
            'ml(function () {/*\n' +
            '    ${0}\n' +
            '})');
            
    registerDesignSnippet('document.getElementById', 'document.getElementById',
            'document.getElementById(\'${1:id}\')');
            
    registerDesignSnippet('document.getElementsByClassName', 'document.getElementsByClassName',
            'document.getElementsByClassName(\'${1:class}\')');
            
    registerDesignSnippet('document.getElementsByName', 'document.getElementsByName',
            'document.getElementsByName(\'${1:name}\')');
            
    registerDesignSnippet('document.getElementsByTagName', 'document.getElementsByTagName',
            'document.getElementsByTagName(\'${1:tagname}\')');





    registerDesignSnippet('.getElementById', '.getElementById',
            '.getElementById(\'${1:id}\')');
            
    registerDesignSnippet('.getElementsByClassName', '.getElementsByClassName',
            '.getElementsByClassName(\'${1:class}\')');
            
    registerDesignSnippet('.getElementsByName', '.getElementsByName',
            '.getElementsByName(\'${1:name}\')');
            
    registerDesignSnippet('.getElementsByTagName', '.getElementsByTagName',
            '.getElementsByTagName(\'${1:tagname}\')');



    registerDesignSnippet('For loop', 'For loop',
            ' (var ${1:i} = 0, ${2:len} = ${3:Things}.length; $1 < $2; $1++) {\n' +
		    '    ${4:$3[$1]}$0\n' +
	        '}');





    registerDesignSnippet('Xtag Query', 'xtag.query',
            'xtag.query(${1:element}, \'${2:selector}\');');
    registerDesignSnippet('Xtag Query Children', 'xtag.queryChildren',
            'xtag.queryChildren(${1:element}, \'${2:selector}\');');
    registerDesignSnippet('Xtag Match Selector', 'xtag.matchSelector',
            'xtag.matchSelector(${1:element}, \'${2:selector}\');');

    registerDesignSnippet('ml()', 'ml()',
            'ml(function () {/*\n' +
            '    ${0}\n' +
            '*/})');

    // HTML snippets
    registerDesignSnippet('<style>', '<style>', 'style>\n' +
                                                '    $0\n' +
                                                '</style>');
    registerDesignSnippet('<script>', '<script>', 'script>\n' +
                                                  '    $0\n' +
                                                  '</script>');
    registerDesignSnippet('<link>', '<link>', 'link href="${1}" type="text/css" rel="stylesheet" />');
    
    
    // CSS snippets
    registerDesignSnippet('Curved Borders', 'Curved Borders', '-webkit-border-radius: ${1:50%};\n' +
                                                             '-moz-border-radius: ${1:50%};\n' +
                                                             '-ms-border-radius: ${1:50%};\n' +
                                                             '-o-border-radius: ${1:50%};\n' +
                                                             'border-radius: ${1:50%};');
    registerDesignSnippet('border-radius', 'border-radius', '-webkit-border-radius: ${1:50%};\n' +
                                                             '-moz-border-radius: ${1:50%};\n' +
                                                             '-ms-border-radius: ${1:50%};\n' +
                                                             '-o-border-radius: ${1:50%};\n' +
                                                             'border-radius: ${1:50%};');
    registerDesignSnippet('box-sizing', 'box-sizing', '-webkit-box-sizing: ${1:border-box};\n' +
                                                      '-moz-box-sizing: ${1:border-box};\n' +
                                                      '-ms-box-sizing: ${1:border-box};\n' +
                                                      '-o-box-sizing: ${1:border-box};\n' +
                                                      'box-sizing: ${1:border-box};');
    registerDesignSnippet('transform', 'transform', '-webkit-transform: ${1:rotate(42deg)};\n' +
                                                    '-moz-transform: ${1:rotate(42deg)};\n' +
                                                    '-ms-transform: ${1:rotate(42deg)};\n' +
                                                    '-o-transform: ${1:rotate(42deg)};\n' +
                                                    'transform: ${1:rotate(42deg)};');
    
    registerDesignSnippet('Desktop Media Query', 'Desktop Media Query', '@media only screen and (max-width: 5000px) {\n' +
                                                                        '    $0\n' +
                                                                        '}');
    registerDesignSnippet('Tablet Media Query', 'Tablet Media Query', '@media only screen and (max-width: 768px) {\n' +
                                                                      '    $0\n' +
                                                                      '}');
    registerDesignSnippet('Phone Media Query', 'Phone Media Query', '@media only screen and (max-width: 321px) {\n' +
                                                                    '    $0\n' +
                                                                    '}');
});//global registerDesignSnippet, window, GS, ml, encodeHTML
//jslint white:true multivar:true

window.addEventListener('design-register-element', function () {
    var strNormalCallbackContent = '    if (!error) {\n' +
                                   '        $0\n' +
                                   '    } else {\n' +
                                   '        GS.ajaxErrorDialog(data);\n' +
                                   '    }\n';
    
    registerDesignSnippet('JSON Ajax', 'JSON Ajax', 'GS.ajaxJSON(\'/env/${1:test.action_ship}\', \'${2:action=ship&id=}\', function (data, error) {\n' +
                                                        strNormalCallbackContent +
                                                    '});');
    registerDesignSnippet('GS.ajaxJSON', 'GS.ajaxJSON', 'GS.ajaxJSON(\'/env/${1:test.action_ship}\', \'${2:action=ship&id=}\', function (data, error) {\n' +
                                                            strNormalCallbackContent +
                                                        '});');
    
    
    registerDesignSnippet('TEXT Ajax', 'TEXT Ajax', 'GS.ajaxText(\'/env/${1:test.action_description}\', \'${2:action=get&id=}\', function (data, error) {\n' +
                                                        strNormalCallbackContent +
                                                    '});');
    registerDesignSnippet('GS.ajaxText', 'GS.ajaxText', 'GS.ajaxText(\'/env/${1:test.action_description}\', \'${2:action=get&id=}\', function (data, error) {\n' +
                                                            strNormalCallbackContent +
                                                        '});');
    
    registerDesignSnippet('PG FUNCTION AJAX', 'PG FUNCTION AJAX', 'GS.ajaxJSON(\'/env/${1:test.action_ship}\', \'${2:action=ship&id=}\', function (data, error) {\n' +
                                                  strNormalCallbackContent +
                                              '});');
    
    registerDesignSnippet('GS.ajaxErrorDialog', 'GS.ajaxErrorDialog', 'GS.ajaxErrorDialog(data,\n' +
              '                   function () {\n' +
              '                       // Try Again Button Callback\n' +
              '                       // delete this function if you dont want a try again button\n' +
              '                   },\n' +
              '                   function () {\n' +
              '                       // Cance Button Callback\n' +
              '                       // if you dont need to do anything when the cancel button is clicked: delete this function\n' +
              '                   });');
    
    registerDesignSnippet('GS.dataFetch', 'GS.dataFetch', 
            'function getData(bolClearPrevious) {\n' +
            '    var data, strLink, dataResultHandler, dataEventFunction;\n' +
            '    \n' +
            '    // create function that will use the data\n' +
            '    dataResultHandler = function (data, error) {\n' +
            '        \n' +
            '    };\n' +
            '    \n' +
            '    // save data from request or\n' +
            '    //     start ajax if it hasn\'t already gotten the data yet or\n' +
            '    //     start new ajax if bolClearPrevious is true\n' +
            '    data = GS.dataFetch(strLink, bolClearPrevious);\n' +
            '    \n' +
            '    // if this request already has been completed\n' +
            '    if (data) {\n' +
            '        // handle result\n' +
            '        dataResultHandler(data.response, data.error);\n' +
            '    } else {\n' +
            '        dataEventFunction = function (event) {\n' +
            '            // unbind data event function\n' +
            '            document.removeEventListener(\'dataready_\' + encodeURIComponent(strLink), dataEventFunction);\n' +
            '            \n' +
            '            // handle result\n' +
            '            dataResultHandler(event.detail.response, event.detail.error);\n' +
            '        };\n' +
            '        \n' +
            '        // bind data event function\n' +
            '        document.addEventListener(\'dataready_\' + encodeURIComponent(strLink), dataEventFunction);\n' +
            '    }\n' +
            '}');
    
});

(function () {
    'use strict';
    function ajaxCheckJSONResponseForError(request) {
        if (request.responseJSON) {
            if (request.responseJSON.stat === false) {
                return true;
            }
        } else {
            return true;
        }
        
        return false;
    }
    
    function ajaxNormalizeError (request) {
        var response = request.response, jsnTemp, jsnRet = {
            'error_title': '',
            'error_hint': '',
            'error_text': '',
            'error_file': '',
            'error_context': '',
            'original_response': response
        };
        
        // get error title and error hint
        if (request.bolFrontEndTimeout === true) {
            jsnRet.error_text = 'Front-end Timeout Reached';
            jsnRet.error_title = 'Front-end Timeout Reached';
            jsnRet.error_hint = 'This request took too long. Please report this to a system administrator.';
            
        } else if (response.status === 403) {
            jsnRet.error_title = '403 Link Is Forbidden';
            jsnRet.error_hint = 'You have no permission to use this link. If you need this link contact a system administrator and request permission for this link.';
            
        } else if (response.status === 404) {
            jsnRet.error_title = '404 Link Could Not Be Found';
            jsnRet.error_hint = 'This link does not exist. Please report this to a system administrator.';
            
        } else if (response.status === 408) {
            jsnRet.error_title = '408 Request Took Too Long';
            jsnRet.error_hint = 'This link is broken. Please report this to a system administrator.';
            
        } else if (response.status === 500) {
            jsnRet.error_title = '500 Internal Server Error';
            jsnRet.error_hint = 'This call to the server failed. Please report this to a system administrator.';
            
        } else if (response.status === 502) {
            jsnRet.error_title = '502 Bad Gateway';
            jsnRet.error_hint = 'This link is broken. Please report this to a system administrator.';
            
        } else if (response.status === 504) {
            jsnRet.error_title = '504 Gateway Timeout';
            jsnRet.error_hint = 'This link is broken. Please report this to a system administrator.';
        }
        
        // get error text
        try {
            jsnTemp = JSON.parse(response.responseText || response).dat;
            
            jsnRet.error_text = jsnTemp.error;
            jsnRet.error_file = jsnTemp.filename;
            jsnRet.error_context = jsnTemp.context;
            
            if (!jsnRet.error_text) {
                jsnRet.error_text = JSON.parse(response.responseText || response).dat;
            }
        } catch (err) {
            if (response) {
                jsnRet.error_text = response.responseText || JSON.stringify(response);
            } else {
                jsnRet.error_text = jsnRet.error_text || response;
            }
        }
        
        jsnRet.error_file = jsnRet.error_file || '';
        
        return jsnRet;
    }
    
    GS.ajaxJSON = function (strLink, strParams, callback, intTimeout) {
        var request = new XMLHttpRequest();
        
        callback = callback || function () {};
        
        request.onreadystatechange = function() {
            var normalizedError;
            
            // if expired cookie: go to login page
            if (request.readyState === 4) {
                if (request.status === 440) {
                    window.location = '/index.html?error=Connection%20timed%20out&redirect=' + encodeURIComponent(window.location.pathname);
                } else {
                    try {
                        request.responseJSON = JSON.parse(request.responseText || request.response);
                    } catch (e) {
                        //throw e;
                    }
                    
                    if (!ajaxCheckJSONResponseForError(request)) {
                        callback(request.responseJSON);
                        
                    } else {
                        normalizedError = ajaxNormalizeError(request);
                        
                        // if session error: have the user log back in and refresh
                        if ((normalizedError.error_text.indexOf('Session expired') === 0 ||
                            normalizedError.error_text.indexOf('No Cookie') !== -1 ||
                            normalizedError.error_text.indexOf('requires you to login') !== -1) &&
                            strLink.indexOf('action_info') === -1) {
                            GS.normalUserLogin(function () {
                                window.location.reload();
                            }, '', request.responseJSON.dat.default_subdomain);
                            
                        // else: callback with normalized error
                        } else {
                            callback(normalizedError, 'error');
                        }
                    }
                }
            }
        };
        
        request.open('POST', strLink + '?anticache=' + ((new Date()).getMilliseconds() + Math.floor(Math.random() * 1e9)), true);
        request.setRequestHeader('Content-type','application/x-www-form-urlencoded; charset=UTF-8');
        request.send(strParams);
        
        // if intTimeout has been set: start a timer to abort
        if (typeof intTimeout === 'number') {
            if (request && request.readyState !== 4) {
                setTimeout(function() {
                    request.bolFrontEndTimeout = true;
                    request.abort();
                }, intTimeout);
            }
        }
        
        return request;
    };
    
    GS.ajaxJSONNoRedirect = function (strLink, strParams, callback, intTimeout) {
        var request = new XMLHttpRequest();
        
        callback = callback || function () {};
        
        request.onreadystatechange = function() {
            var normalizedError;
            
            // if expired cookie: go to login page
            if (request.readyState === 4) {
                try {
                    request.responseJSON = JSON.parse(request.responseText || request.response);
                } catch (e) {
                    //throw e;
                }
                
                if (!ajaxCheckJSONResponseForError(request)) {
                    callback(request.responseJSON);
                    
                } else {
                    normalizedError = ajaxNormalizeError(request);
                    callback(normalizedError, 'error');
                }
            }
        };
        
        request.open('POST', strLink + '?anticache=' + ((new Date()).getMilliseconds() + Math.floor(Math.random() * 1e9)), true);
        request.setRequestHeader('Content-type','application/x-www-form-urlencoded; charset=UTF-8');
        request.send(strParams);
        
        // if intTimeout has been set: start a timer to abort
        if (typeof intTimeout === 'number') {
            if (request && request.readyState !== 4) {
                setTimeout(function() {
                    request.bolFrontEndTimeout = true;
                    request.abort();
                }, intTimeout);
            }
        }
        
        return request;
    };
    
    GS.ajaxText = function (strLink, strParams, callback, intTimeout) {
        var request = new XMLHttpRequest();
        
        callback = callback || function () {};
        
        request.onreadystatechange = function() {
            var normalizedError;
            
            if (request.readyState === 4) {
                if (request.status === 200) {
                    callback(request.responseText);
                    
                } else if (request.status === 440) {
                    window.location = '/index.html?error=Connection%20timed%20out&redirect=' + encodeURIComponent(window.location.pathname);
                    
                } else {
                    normalizedError = ajaxNormalizeError(request);
                    
                    // if session error: have the user log back in and refresh
                    if ((normalizedError.error_text.indexOf('Session expired') === 0 ||
                        normalizedError.error_text.indexOf('No Cookie') !== -1 ||
                        normalizedError.error_text.indexOf('requires you to login') !== -1) &&
                        strLink.indexOf('action_info') === -1) {
                        GS.normalUserLogin(function () {
                            window.location.reload();
                        }); //, '', JSON.parse(request.responseText || request.response).dat.default_subdomain
                        
                    // else: callback with normalized error
                    } else {
                        callback(normalizedError, 'error');
                    }
                }
            }
        };
        
        request.open('POST', strLink + '?anticache=' + ((new Date()).getMilliseconds() + Math.floor(Math.random() * 1e9)), true);
        request.setRequestHeader('Content-type','application/x-www-form-urlencoded; charset=UTF-8');
        request.send(strParams);
        
        // if intTimeout has been set: start a timer to abort
        if (typeof intTimeout === 'number') {
            if (request && request.readyState !== 4) {
                setTimeout(function() {
                    request.bolFrontEndTimeout = true;
                    request.abort();
                }, intTimeout);
            }
        }
        
        return request;
    };
}());

(function () {
    "use strict";
    
    function cleanErrorValue(strValue) {
        strValue = strValue || '';
        
        if (strValue.indexOf('DB_exec failed:') !== -1) {
            strValue = strValue.replace(/[.\s\S]*DB_exec\ failed:/mi, '');
        }
        
        if (strValue.indexOf('Query failed:') !== -1) {
            strValue = strValue.replace(/[.\s\S]*Query\ failed:/mi, '');
        }
        
        if (strValue.indexOf('FATAL') !== -1) {
            strValue = strValue.replace(/[.\s\S]*FATAL/mi, '');
        }
        
        strValue = strValue
                        .replace(/\\?\\n/gi, '\n')
                        .replace(/\\?\\t/gi, '\t')
                        .replace(/\[.*\]/gi, '')
                        .replace(/\([0-9]*\)/gi, '');
        
        return GS.trim(strValue.trim(), '"');
    }
    
    function errorJSONToHTML(errorJSON) {
        var errorHTML = '<pre style="word-break: break-all; white-space: pre-wrap;">' +
                    'There was an error:' +
                    (errorJSON.error_text //TODO: maybe make this red -Joseph 09/14/16
                        ? '<br /><br />' + encodeHTML(GS.decodeFromTabDelimited(errorJSON.error_text))
                        : '') +
                    (errorJSON.error_file
                        ? '<br /><br />The error was on file: ' + encodeHTML(GS.decodeFromTabDelimited(errorJSON.error_file))
                        : '') +
                    (errorJSON.error_hint
                        ? '<br /><br />' + encodeHTML(GS.decodeFromTabDelimited(errorJSON.error_hint))
                        : '') +
                    (errorJSON.error_context
                        ? '<br /><br />' + encodeHTML(errorJSON.error_context)                     
                        : '') +
                    (errorJSON.error_addin
                        ? '<br /><br />' + encodeHTML(errorJSON.error_addin)                       
                        : '') +
                '</pre>';
        return errorHTML;
    }
    
    GS.ajaxErrorDialog = function (jsnError, tryAgainCallback, cancelCallback) {
        'use strict';
        var templateElement = document.createElement('template'), strHTML;
        
        var jsnErrorCopy = {};
        jsnErrorCopy.error_text    = cleanErrorValue(jsnError.error_text);
        jsnErrorCopy.error_file    = cleanErrorValue(jsnError.error_file);
        jsnErrorCopy.error_hint    = cleanErrorValue(jsnError.error_hint);
        jsnErrorCopy.error_context = cleanErrorValue(jsnError.error_context);
        jsnErrorCopy.error_addin   = cleanErrorValue(jsnError.error_addin);
        
        templateElement.setAttribute('data-theme', 'error');
        strHTML = ml(function () {/*
            <gs-page>
                <gs-header><center><h3>There was an error!</h3></center></gs-header>
                <gs-body padded>
                    {{HTML}}
                    <gs-button class="error-button-show-full-text">Show Full Error Text</gs-button>
                </gs-body>
                <gs-footer>{{BUTTONS}}</gs-footer>
            </gs-page>
        */}).replace('{{HTML}}', errorJSONToHTML(jsnErrorCopy));
        
        
        var openFunction = function () {
            xtag.query(this, '.error-button-show-full-text')[0].addEventListener('click', function () {
                var templateElement = document.createElement('template');
                
                templateElement.innerHTML = ml(function () {/*
                    <gs-page>
                        <gs-header><center><h3>Full Error Text</h3></center></gs-header>
                        <gs-body padded>
                            {{HTML}}
                        </gs-body>
                        <gs-footer><gs-button dialogclose>Done</gs-button></gs-footer>
                    </gs-page>
                */}).replace('{{HTML}}', errorJSONToHTML(jsnError));
                
                GS.openDialog(templateElement);
            });
        };
        
        
        if (typeof tryAgainCallback === 'function') {
            templateElement.innerHTML = strHTML.replace('{{BUTTONS}}',
                        '<gs-grid>' +
                        '   <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>' +
                        '   <gs-block><gs-button dialogclose listen-for-return>Try Again</gs-button></gs-block>' +
                        '</gs-grid>');
            GS.openDialog(templateElement, openFunction, function (event, strAnswer) {
                if (strAnswer === 'Try Again') {
                    tryAgainCallback(strAnswer);
                } else {
                    if (typeof cancelCallback === 'function') {
                        cancelCallback(strAnswer);
                    }
                }
            });
        } else {
            templateElement.innerHTML = strHTML.replace('{{BUTTONS}}', '<gs-button dialogclose listen-for-return>Ok</gs-button>');
            GS.openDialog(templateElement, openFunction);
        }
    };
    
}());

/*

var strLink = '/env/action_select?view=wtkv2.ttime&where=user_name%20%3D%20\'michael%40tocci.org\'&offset=0&limit=25&order_by=id%20DESC&header=true';

document.addEventListener('dataready_' + encodeURIComponent(strLink), function (event) {
    //console.log(event);
});f

dataFetch(strLink, false);

*/

if (GS.dataLedger === undefined) {
    GS.dataLedger = {};
}

GS.dataFetch = function (strLink, bolClearPrevious) {
    'use strict';
    var arrLinkParts = strLink.split('?'), strId = encodeURIComponent(strLink);
    
    // if something wants to fetch data where the id does not already exist then do an ajax call 
    if (GS.dataLedger[strId] === undefined || bolClearPrevious === true) {
        
        GS.dataLedger[strId] = {'status': 'waiting', 'response': ''};
        
        GS.ajaxJSON(arrLinkParts[0], arrLinkParts[1] || '', function (data, error) {
            var event; // The custom event that will be created
            
            if (document.createEvent) {
                event = document.createEvent('HTMLEvents');
                event.initEvent('dataready_' + strId, true, true);
                event.eventName = 'dataready_' + strId;
            } else {
                event = document.createEventObject();
                event.eventType = 'dataready_' + strId;
                event.eventName = 'dataready_' + strId;
            }
            
            if (!error) {
                GS.dataLedger[strId].response = (data.dat !== undefined ? data.dat : data);
                GS.dataLedger[strId].status = 'finished';
                
                event.detail = {'response': GS.dataLedger[strId].response};
                
            } else {
                GS.dataLedger[strId].data = data;
                GS.dataLedger[strId].status = 'error';
                GS.dataLedger[strId].error = 'error';
                
                event.detail = {'response': data, 'error': 'error'};
            }
            
            if (document.createEvent) {
                document.dispatchEvent(event);
            } else {
                document.fireEvent('on' + event.eventType, event);
            }
        });
        
        return '';
    }
    
    if (GS.dataLedger[strId].status === 'finished' || GS.dataLedger[strId].status === 'error') {
        return GS.dataLedger[strId];
    }
    
    return '';
};
window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('GS.findParentTag', 'GS.findParentTag', 'GS.findParentTag(${1:element}, \'${0:tag-to-find}\');');
    
    registerDesignSnippet('GS.findParentElement', 'GS.findParentElement',
                                                    'GS.findParentElement(${1:element}, ${0:\'selector, element or function\'});');
    
    registerDesignSnippet('GS.insertElementAfter', 'GS.insertElementAfter',
                                                    'GS.insertElementAfter(${1:elementToInsert}, \'${0:elementToInsertAfter}\');');
    
    registerDesignSnippet('GS.getElementOffset', 'GS.getElementOffset', 'GS.getElementOffset(${0:element});');
    
    registerDesignSnippet('GS.animateStyle', 'GS.animateStyle',
                                            'GS.animateStyle(${1:elementToAnimate}, ' +
                                                            '${2:CSSPropertyToAnimate}, ' +
                                                            '${3:startValue}, ' +
                                                            '${4:endValue}, ' +
                                                            '${5:callbackAfterAnimation}, ' +
                                                            '${6:durationInMilliseconds}, ' +
                                                            '${0:numberOfFrames});');
    
    registerDesignSnippet('GS.stringToElement', 'GS.stringToElement', 'GS.stringToElement(\'${0:<div>your HTML here</div>}\');');
    
    registerDesignSnippet('GS.cloneElement', 'GS.cloneElement', 'GS.cloneElement(${0:element});');
    
    registerDesignSnippet('GS.isElementFocusable', 'GS.isElementFocusable', 'GS.isElementFocusable(${0:element});');
    
    registerDesignSnippet('GS.scrollParent', 'GS.scrollParent', 'GS.scrollParent(${0:element});');
    
    registerDesignSnippet('GS.scrollIntoView', 'GS.scrollIntoView', 'GS.scrollIntoView(${0:element});');
    
    registerDesignSnippet('GS.getInputSelection', 'GS.getInputSelection', 'GS.getInputSelection(${0:inputOrTextareaElement});');
    
    registerDesignSnippet('GS.setInputSelection', 'GS.setInputSelection',
                                    'GS.setInputSelection(${1:inputOrTextareaElement}, ${2:startAtNumber}, ${0:endAtNumber});');
    
    registerDesignSnippet('GS.getElementPositionData', 'GS.getElementPositionData', 'GS.getElementPositionData(${0:element});');
});

// #################################################################
// #################### DOM TRAVERSAL FUNCTIONS ####################
// #################################################################

// loop through parents until tag is found
GS.findParentTag = function (element, strTagName) {
    'use strict';
    var currentElement = element.parentNode;
    
    strTagName = strTagName.toUpperCase();
    
    while (currentElement && currentElement.nodeName !== strTagName && currentElement.nodeName !== 'HTML') {
        currentElement = currentElement.parentNode;
    }
    
    if (!currentElement || currentElement.nodeName !== strTagName) {
        return undefined;
    }
    
    return currentElement;
};

// loop through parents until checkParameter is satisfied or we run into HTML
GS.findParentElement = function (element, checkParameter) {
    'use strict';
    var currentElement = element;
    if (currentElement === window || currentElement === document) {
        return document.documentElement;
    }
    // if checkParameter is a function: use it to check the element
    if (typeof checkParameter === 'function') {
        while (currentElement && !checkParameter(currentElement) && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }
        
    // else if checkParameter is a string: use checkParameter as a selector string and use xtag.matchSelector
    } else if (typeof checkParameter === 'string') {
        while (currentElement && !xtag.matchSelector(currentElement, checkParameter) && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }
        
    // else: assume checkParameter is an element and use ===
    } else {
        while (currentElement && currentElement !== checkParameter && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }
    }
    
    if (!currentElement) {
        return undefined;
    }
    
    return currentElement;
};


// ################################################################
// #################### HTML ELEMENT FUNCTIONS ####################
// ################################################################

// insert element after another element
GS.insertElementAfter = function (elementToInsert, target) {
    if (target.nextElementSibling) {
        target.parentNode.insertBefore(elementToInsert, target.nextElementSibling);
    } else {
        target.parentNode.appendChild(elementToInsert);
    }
};

// get element's position on the screen
GS.getElementOffset = function (element) {
    'use strict';
    var intX = 0, intY = 0, ret;
    
    if (element.getBoundingClientRect) {
        ret = element.getBoundingClientRect();
        
    } else {
        while (element && element.nodeName !== 'HTML') {
            intX += element.offsetLeft - element.scrollLeft;// + element.clientLeft;
            intY += element.offsetTop - element.scrollTop;// + element.clientTop;
            
            //console.log(element.offsetTop, element.scrollTop, element);
            
            element = element.parentNode; //element.offsetParent
        }
        
        ret = {
            left: intX,
            top: intY
        };
    }
    
    return ret;
};

//
GS.animateStyle = function (element, strStyleProperty, strStart, strEnd, callback, intDuration, intFrames) {
    var intStart         = parseInt(strStart, 10),
        intEnd           = parseInt(strEnd, 10),
        strStartUnit     = strStart.replace(/[0-9\.-]/gi, '').toLowerCase(),
        //strEndUnit       = strEnd.replace(/[0-9\.-]/gi, '').toLowerCase(),
        intFrameDuration = intDuration / intFrames,
        i, timeoutFunction, intCurrent, intJump;
    
    //if (strStartUnit !== 'em' && strStartUnit !== 'px' && strStartUnit !== '') {
    //    throw 'animateStyle error: strStart has an invalid unit, use px or em or nothing';
    //    
    //} else if (strEndUnit !== 'em' && strEndUnit !== 'px' && strEndUnit !== '') {
    //    throw 'animateStyle error: strEnd has an invalid unit, use px or em or nothing';
    //    
    //} else {
    intCurrent = intStart;
    intJump = (intEnd - intStart) / intFrames;
    i = 1;
    
    element.style[strStyleProperty] = strStart;
    
    timeoutFunction = function () {
        setTimeout(function () {
            intCurrent += intJump;
            //element.style[strStyleProperty] = intCurrent + strStartUnit;
            //console.log(intCurrent, i, intFrames, element, element.style[strStyleProperty], intStart, intCurrent, strStartUnit);
            
            if (i < intFrames) {
                element.style[strStyleProperty] = intCurrent + strStartUnit;
                i += 1;
                timeoutFunction();
            } else {
                element.style[strStyleProperty] = strEnd;
                callback();
            }
        }, intFrameDuration);
    };
    
    timeoutFunction();
    //}
};

//
GS.stringToElement = function (strHTML, optionalTargetDocument) {
    var strFirstTagName, parentElement, indexInElement, parsedElement, targetDocument;
    
    if (optionalTargetDocument) {
        targetDocument = optionalTargetDocument;
    } else {
        targetDocument = document;
    }
    
    //console.log(strFirstTagName);
    
    strFirstTagName = strHTML.substring(strHTML.indexOf('<') + 1, strHTML.indexOf('>'));
    
    //console.log(strFirstTagName);
    
    if (strFirstTagName.indexOf(' ') > -1) {
        strFirstTagName = strFirstTagName.substring(0, strFirstTagName.indexOf(' '));
    }
    
    //console.log(strFirstTagName);
    
    if (strFirstTagName === 'body') {
        parentElement = targetDocument.createElement('html');
        indexInElement = 1;
        
    } else if (strFirstTagName === 'thead' || strFirstTagName === 'tbody') {
        parentElement = targetDocument.createElement('table');
        indexInElement = 0;
        
    } else if (strFirstTagName === 'tr') {
        parentElement = targetDocument.createElement('tbody');
        indexInElement = 0;
        
    } else if (strFirstTagName === 'td' || strFirstTagName === 'th') {
        parentElement = targetDocument.createElement('tr');
        indexInElement = 0;
        
    } else if (strFirstTagName === 'li') {
        parentElement = targetDocument.createElement('ul');
        indexInElement = 0;
    } else {
        parentElement = targetDocument.createElement('div');
        indexInElement = 0;
    }
    
    parentElement.innerHTML = strHTML;
    parsedElement = parentElement.children[indexInElement];
    
    //console.log(strFirstTagName, parsedElement);
    
    return parsedElement;
};

//
GS.cloneElement = function (element, optionalTargetDocument) {
    // if there is a template element in the element: copy the element without cloneNode because for some reason cloneNode breaks templates on IOS
    if (xtag.query(element, 'template').length > 0 || optionalTargetDocument) {
        return GS.stringToElement(element.outerHTML, optionalTargetDocument);
    }
    
    // else: just use cloneNode
    return element.cloneNode(true);
};

/*
// change the tag of an element
GS.changeElementTag = function (element, strNewTag, alterCallback) {
    var strHTML = element.outerHTML.trim(), newElement;
    
    strHTML = '<' + strNewTag + strHTML.substring(strHTML.indexOf(' '), strHTML.lastIndexOf('</')) + '</' + strNewTag + '>';
    
    //console.log(strHTML);
    
    newElement = GS.stringToElement(strHTML);
    
    if (typeof alterCallback === 'function') {
        alterCallback.apply(newElement);
    }
    
    return newElement;
};*/

// check to see if an element is focusable
GS.isElementFocusable = function (element) {
    return  (
                element.nodeName === 'INPUT' ||
                element.nodeName === 'TEXTAREA' ||
                element.nodeName === 'SELECT' ||
                element.nodeName === 'BUTTON' ||
                element.nodeName === 'IFRAME' ||
                GS.findParentTag(element, 'gs-text') ||
                GS.findParentTag(element, 'gs-combo') ||
                GS.findParentTag(element, 'gs-number') ||
                GS.findParentTag(element, 'gs-dt') ||
                (element.hasAttribute('tabindex') && element.getAttribute('tabindex') !== '-1') ||
                (element.focus &&
                    element.focus.toString().indexOf('[native code]') === -1 &&
                    element.focus.toString() !== document.createElement('div').focus.toString()) ||
                (
                    element.nodeName === 'A' &&
                    element.hasAttribute('href')
                ) ||
                (
                    element.nodeName === 'AREA' &&
                    element.hasAttribute('href')
                )
            ) &&
            !element.hasAttribute('disabled');
};

// see function in 006-utl.js
//// search for a parent with a scrollbar
//GS.scrollParent = function (element) {
//    var i = 0, currentElement = element, bolFoundScrollable = false, strOverflow;
//    
//    if (currentElement) {
//        while (currentElement && currentElement.nodeName !== 'HTML' && bolFoundScrollable === false && i < 75) {
//            strOverflow = GS.getStyle(currentElement, 'overflow');
//            
//            if (strOverflow === 'scroll' || (strOverflow === 'auto' && currentElement.clientHeight < currentElement.scrollHeight)) {
//                bolFoundScrollable = true;
//            } else {
//                currentElement = currentElement.parentNode;
//                i += 1;
//            }
//        }
//        return bolFoundScrollable ? currentElement : undefined;
//    }
//    return undefined;
//};
// see function in 006-utl.js
// scroll an element to the middle of its scrollparent
// GS.scrollIntoView = function (element) {
//     var scrollingContainer = GS.scrollParent(element), arrSiblings, i, len, intScrollTop;
//     //console.log(scrollingContainer);
//     if (scrollingContainer) {
//         //console.log(scrollingContainer);
        
//         arrSiblings = element.parentNode.children;
        
//         for (i = 0, intScrollTop = 0, len = arrSiblings.length; i < len; i += 1) {
//             if (arrSiblings[i] === element) {
//                 intScrollTop += arrSiblings[i].offsetHeight / 2;
                
//                 break;
//             } else {
//                 intScrollTop += arrSiblings[i].offsetHeight;
//             }
//         }
        
//         intScrollTop = intScrollTop - (scrollingContainer.offsetHeight / 2);
        
//         //console.log(intScrollTop);
        
//         scrollingContainer.scrollTop = intScrollTop;
//     }
// };


// GS.scrollIntoView = function (element, strDirection) {
//     var strDirectionText;
//     if (strDirection) {
//         strDirectionText = strDirection;
//     } else {
//         strDirectionText = 'vertical';
//     }
//     var scrollingContainer = GS.scrollParent(element, strDirectionText), arrSiblings, i, len, intScrollTop;
    
    
//     if (scrollingContainer) {
        
//         arrSiblings = element.parentNode.children;
        
//         for (i = 0, intScrollTop = 0, len = arrSiblings.length; i < len; i += 1) {
//             if (arrSiblings[i] === element) {
//                 intScrollTop += arrSiblings[i].offsetHeight / 2;
                
//                 break;
//             } else {
//                 intScrollTop += arrSiblings[i].offsetHeight;
//             }
//         }
        
//         intScrollTop = intScrollTop - (scrollingContainer.offsetHeight / 2);
        
//         //console.log(intScrollTop);
        
//         scrollingContainer.scrollTop = intScrollTop;
//     }
// };






// #################################################################
// ################### INPUT SELECTION FUNCTIONS ###################
// #################################################################

GS.getInputSelection = function (input) {
    'use strict';
    var start = 0, end = 0, normalizedValue, range, textInputRange, len, endRange;
    
    if (typeof input.selectionStart === "number" && typeof input.selectionEnd === "number") {
        start = input.selectionStart;
        end = input.selectionEnd;
    } else {
        range = (document.createRange() || document.selection.createRange());
        
        if (range && range.parentElement && range.parentElement() == input) {
            len = input.value.length;
            normalizedValue = input.value.replace(/\r\n/g, "\n");
            
            // Create a working TextRange that lives only in the input
            textInputRange = input.createTextRange();
            textInputRange.moveToBookmark(range.getBookmark());
            
            // Check if the start and end of the selection are at the very end
            // of the input, since moveStart/moveEnd doesn't return what we want
            // in those cases
            endRange = input.createTextRange();
            endRange.collapse(false);
            
            if (textInputRange.compareEndPoints("StartToEnd", endRange) > -1) {
                start = end = len;
            } else {
                start = -textInputRange.moveStart("character", -len);
                start += normalizedValue.slice(0, start).split("\n").length - 1;
                
                if (textInputRange.compareEndPoints("EndToEnd", endRange) > -1) {
                    end = len;
                } else {
                    end = -textInputRange.moveEnd("character", -len);
                    end += normalizedValue.slice(0, end).split("\n").length - 1;
                }
            }
        }
    }
    
    return {
        start: start,
        end: end
    };
};

GS.setInputSelection = function (input, intStart, intEnd) {
    'use strict';
    //console.trace('setInputSelection');
    var range;
    
    if (intStart === undefined || intStart === '' || isNaN(intStart) || intStart === null) {
        intStart = input.value.length;
    }
    
    if (intEnd === undefined || intEnd === '' || isNaN(intEnd) || intEnd === null) {
        intEnd = intStart;
    }
    
    if (input.setSelectionRange) {
        input.focus();
        input.setSelectionRange(intStart, intEnd);
    } else if (input.createTextRange) {
        range = input.createTextRange();
        range.collapse();
        range.moveStart('character', intStart);
        range.collapse();
        range.moveEnd('character', intEnd - intStart);
        range.select();
    }
};


// #################################################################
// ################### ELEMENT POSITION FUNCTION ###################
// #################################################################

// return a whole bunch of position data variables for an element
GS.getElementPositionData = function (element) {
    var objElementOffset  = GS.getElementOffset(element),
        intElementWidth   = element.offsetWidth,
        intElementHeight  = element.offsetHeight,
        intElementTop     = objElementOffset.top,
        intElementLeft    = objElementOffset.left,
        intElementBottom  = window.innerHeight - (intElementTop    + intElementHeight),
        intElementRight   = window.innerWidth  - (intElementLeft   + intElementWidth),
        intRoomAbove      = window.innerHeight - (intElementBottom + intElementHeight),
        intRoomBelow      = intElementBottom,
        intRoomLeft       = window.innerWidth  - (intElementRight  + intElementWidth),
        intRoomRight      = intElementRight;
    
    /*console.log(element, '\n' +
                'intElementWidth:   ' + intElementWidth + '\n' +
                'intElementHeight:  ' + intElementHeight + '\n' +
                'intElementTop:     ' + intElementTop + '\n' +
                'intElementBottom:  ' + intElementBottom + '\n' +
                'intElementLeft:    ' + intElementLeft + '\n' +
                'intElementRight:   ' + intElementRight + '\n' +
                'intRoomAbove:      ' + intRoomAbove + '\n' +
                'intRoomBelow:      ' + intRoomBelow + '\n' +
                'intRoomLeft:       ' + intRoomLeft + '\n' +
                'intRoomRight:      ' + intRoomRight);*/
    
    return {
        'element':           element,
        'objElementOffset':  objElementOffset,
        'intElementWidth':   intElementWidth,
        'intElementHeight':  intElementHeight,
        'intElementTop':     intElementTop,
        'intElementLeft':    intElementLeft,
        'intElementBottom':  intElementBottom,
        'intElementRight':   intElementRight,
        'intRoomAbove':      intRoomAbove,
        'intRoomBelow':      intRoomBelow,
        'intRoomLeft':       intRoomLeft,
        'intRoomRight':      intRoomRight
    };
};

// #################################################################
// ####################### DOCUMENT FRAGMENT #######################
// #################################################################
/*                                       ,--- the problem with this code is the DOM we get back is not 100% reliably inert. 
                                         V          To make it reliable I believe I have to change how my elements work.
GS.createDocumentFragment = function (strHTML) {
    'use strict';
    var element = document.createElement('div'),
        fragment = document.createDocumentFragment(),
        arrChildren = element.childNodes;
    
    // fill element with HTML
    element.innerHTML = strHTML;
    
    // append the element to the body (NECCESSARY FOR THE HTML TO BE INERT, I DON'T KNOW WHY -michael)
    document.body.appendChild(element);
    
    // transfer children from element to fragment
    while (arrChildren[0]) {
        fragment.appendChild(arrChildren[0]);
    }
    
    // remove element from the body
    document.body.removeChild(element);
    
    // return inert fragment
    return fragment;
};

GS.getDocumentFragmentHTML = function (fragment) {
    'use strict';
    var strHTML, i, len, arrChildren = fragment.children;
    
    for (strHTML = '', i = 0, len = arrChildren.length; i < len; i += 1) {
        strHTML += arrChildren[i].outerHTML;
    }
    
    return strHTML;
};
*/

// #################################################################
// ########################### INERT DOM ###########################
// #################################################################
/*tell papa if you uncomment
GS.createInertDOM = function (strHTML) {
    'use strict';
    var templateElement = document.createElement('template'), iframeElement;
    
    // if the content property is on a template element: no iframe neccessary
    if ('content' in templateElement) {
        templateElement.innerHTML = strHTML;
        
        return templateElement.content;
        
    // else: use iframe to create inert HTML
    } else {
        if (!document.getElementById('gs-inert-dom-generator')) {
            iframeElement = document.createElement('iframe');
            
            iframeElement.setAttribute('id', 'gs-inert-dom-generator');
            iframeElement.setAttribute('hidden', '');
            
            document.body.appendChild(iframeElement);
            
        } else {
            iframeElement = document.getElementById('gs-inert-dom-generator');
        }
        
        iframeElement.contentWindow.inertDOM = iframeElement.contentWindow.document.createElement('div');
        iframeElement.contentWindow.inertDOM.innerHTML = strHTML;
        
        return iframeElement.contentWindow.inertDOM;
    }
};

GS.getInertDOMHTML = function (inertDOM) {
    'use strict';
    var strHTML, i, len, arrChildren = inertDOM.children;
    
    for (strHTML = '', i = 0, len = arrChildren.length; i < len; i += 1) {
        strHTML += arrChildren[i].outerHTML;
    }
    
    return strHTML;
};
*/

// ##################################################################
// ###################### TABLE COPY/SELECTION ######################
// ##################################################################
(function () {
    'use strict';
    function getCellFromTarget(element) {
        var currentElement = element;
        
        while (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH' && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }
        
        if (currentElement && currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH') {
            return undefined;
        }
        
        return currentElement;
    }
    
    function selectHandler(tableElement, dragOrigin, dragCurrentCell, dragMode) {
        var bolThead, bolFirstTh, arrRecords, arrCells, arrRecordsToAffect = [], arrCellsToAffect = [],
            arrNewSelection = [], arrCellsToRemoveFromSelection = [], i, len, intFrom, intTo;
        
        arrRecords = xtag.query(tableElement, 'tr');
        arrCells = xtag.query(tableElement, 'td, th');
        
        if (arrRecords.length > 0) {
            bolThead = Boolean(xtag.queryChildren(tableElement, 'thead')[0]);
            
            if ((bolThead && arrRecords.length > 1) || (!bolThead && arrRecords > 0)) {
                if (bolThead) {
                    bolFirstTh = arrRecords[1].children[0].nodeName === 'TH';
                } else {
                    bolFirstTh = arrRecords[0].children[0].nodeName === 'TH';
                }
            }
            
            // if origin & currentCell are both the top-left cell and the cell is a heading: select all cells
            if (bolThead && bolFirstTh &&
                dragOrigin.parentNode.rowIndex === 0 && dragCurrentCell.parentNode.rowIndex === 0 &&
                dragOrigin.cellIndex === 0 && dragCurrentCell.cellIndex === 0) {
                arrCellsToAffect = arrCells;
                
            // else if origin & currentCell are both first ths: select the records from origin to currentCell
            } else if (bolFirstTh && dragOrigin.cellIndex === 0 && dragCurrentCell.cellIndex === 0) {
                arrRecordsToAffect =
                    arrRecords.slice(Math.min(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex),
                                     Math.max(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex) + 1);
                
                for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
                    Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children));
                }
                
            // else if origin & currentCell are both headings: select the columns from origin to currentCell
            } else if (bolThead && dragOrigin.parentNode.rowIndex === 0 && dragCurrentCell.parentNode.rowIndex === 0) {
                intFrom = Math.min(dragOrigin.cellIndex, dragCurrentCell.cellIndex);
                intTo   = Math.max(dragOrigin.cellIndex, dragCurrentCell.cellIndex) + 1;
                
                for (i = 0, len = arrRecords.length; i < len; i += 1) {
                    Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecords[i].children).slice(intFrom, intTo));
                }
                
            //// else if origin & currentCell are the same cell: select the record
            //} else if (dragOrigin === dragCurrentCell) {
            //    arrRecordsToAffect = arrRecords.slice(dragOrigin.parentNode.rowIndex, dragOrigin.parentNode.rowIndex + 1);
            //    
            //    for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
            //        Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children));
            //    }
            //    
            // else select cells from origin to currentCell
            } else {
                arrRecordsToAffect =
                    arrRecords.slice(Math.min(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex),
                                     Math.max(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex) + 1);
                
                intFrom = Math.min(dragOrigin.cellIndex, dragCurrentCell.cellIndex);
                intTo   = Math.max(dragOrigin.cellIndex, dragCurrentCell.cellIndex) + 1;
                
                for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
                    Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children).slice(intFrom, intTo));
                }
            }
            
            if (dragMode === 'select') {
                // add new cells to tableElement.selectionSelectedCells
                for (i = 0, len = tableElement.selectionSelectedCells.length; i < len; i += 1) {
                    if (arrCellsToAffect.indexOf(tableElement.selectionSelectedCells[i]) === -1) {
                        arrCellsToRemoveFromSelection.push(tableElement.selectionSelectedCells[i]);
                    }
                }
                tableElement.selectionSelectedCells = arrCellsToAffect;
                
                // add new cells to tableElement.selectedCells
                arrNewSelection = tableElement.selectedCells;
                for (i = 0, len = arrCellsToAffect.length; i < len; i += 1) {
                    GS.listAdd(arrNewSelection, arrCellsToAffect[i]);
                }
                for (i = 0, len = arrCellsToRemoveFromSelection.length; i < len; i += 1) {
                    arrNewSelection.splice(arrNewSelection.indexOf(arrCellsToRemoveFromSelection[i]), 1);
                }
                tableElement.selectedCells = arrNewSelection;
                
            } else { // implied if: dragMode === 'deselect'
                // deselect cells from arrCellsToAffect
                arrNewSelection = tableElement.selectedCells;
                
                for (i = 0, len = arrCellsToAffect.length; i < len; i += 1) {
                    if (arrNewSelection.indexOf(arrCellsToAffect[i]) > -1) {
                        arrNewSelection.splice(arrNewSelection.indexOf(arrCellsToAffect[i]), 1);
                    }
                }
                tableElement.selectedCells = arrNewSelection;
            }
        }
    }
    
    
    
    
    
    
    function getSelectedCopyHTML(element) {
        var strHTMLCopyString, intFromRecord, intToRecord, intFromCell = 9999999, intToCell = 0
          , i, len, cell_i, cell_len, arrSelected, strCellHTML, arrRecords, arrCells
          , strHTMLRecordString, strNull, bolColumns;
        
        arrSelected = element.selectedCells;
        
        strNull    = (element.getAttribute('null-values')  || "NULL");
        bolColumns = (element.getAttribute('column-names') || "true") === "true";
        
        // loop through the selected cells and create an html string using the text of the cell
        if (arrSelected.length > 0) {
            intFromRecord = arrSelected[0].parentNode.rowIndex;
            intToRecord = arrSelected[arrSelected.length - 1].parentNode.rowIndex + 1;
            
            for (i = 0, len = arrSelected.length; i < len; i += 1) {
                if (arrSelected[i].cellIndex < intFromCell) {
                    intFromCell = arrSelected[i].cellIndex;
                    intFromCell = (intFromCell === 0 ? 1 : intFromCell);
                }
                if (arrSelected[i].cellIndex + 1 > intToCell) {
                    intToCell = arrSelected[i].cellIndex + 1;
                }
            }
            
            arrRecords = xtag.query(element, 'tr');
            strHTMLCopyString = '';
            
            // if bolColumns is true and the first record is not selected: add first record first
            if (bolColumns && intFromRecord > 0) {
                arrCells = arrRecords[0].children;
                strHTMLRecordString = '';
                
                for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                    strCellHTML = '';
                    
                    if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) {
                        strCellHTML = arrCells[cell_i].firstElementChild.textValue ||
                                      arrCells[cell_i].firstElementChild.value ||
                                      (arrCells[cell_i].firstElementChild.checked || '').toString() ||
                                      arrCells[cell_i].firstElementChild.textContent || '';//.trim();
                        
                    } else if (arrCells[cell_i].lastElementChild) { 
                        strCellHTML = arrCells[cell_i].lastElementChild.textValue ||
                                      arrCells[cell_i].lastElementChild.value ||
                                      (arrCells[cell_i].lastElementChild.checked || '').toString() ||
                                      arrCells[cell_i].lastElementChild.textContent || '';
                    } else {
                        strCellHTML = arrCells[cell_i].textContent;//.trim();
                    }
                    
                    strCellHTML = encodeHTML(strCellHTML).replace(/\n/gim, '<br />');
                    
                    strCellHTML = '<' + 'td rowspan="1" colspan="1">' + (strCellHTML || '') + '</td>'
                    
                    strHTMLRecordString += (cell_i === intFromCell ? '<' + 'tr>' : '');
                    strHTMLRecordString += (strCellHTML || '');
                    strHTMLRecordString += (cell_i === (intToCell - 1) ? '<' + '/tr>' : '');
                }
                
                if (strHTMLRecordString.trim()) {
                    strHTMLCopyString += strHTMLRecordString;
                }
            }
            
            for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
                arrCells = arrRecords[i].children;
                strHTMLRecordString = '';
                
                if (!arrRecords[i].classList.contains('insert-record')) {
                    for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                        strCellHTML = '';
                        
                        if (arrCells[cell_i].hasAttribute('selected') || (i === 0 && bolColumns)) {
                            if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) {
                                strCellHTML = arrCells[cell_i].firstElementChild.textValue ||
                                              arrCells[cell_i].firstElementChild.value ||
                                              (arrCells[cell_i].firstElementChild.checked || '').toString() ||
                                              arrCells[cell_i].firstElementChild.textContent || '';//.trim();
                                
                            } else if (arrCells[cell_i].lastElementChild) { 
                                strCellHTML = arrCells[cell_i].lastElementChild.textValue ||
                                              arrCells[cell_i].lastElementChild.value ||
                                              (arrCells[cell_i].lastElementChild.checked || '').toString() ||
                                              arrCells[cell_i].lastElementChild.textContent || '';
                            } else {
                                strCellHTML = arrCells[cell_i].textContent;//.trim();
                            }
                            
                            strCellHTML = encodeHTML(strCellHTML).replace(/\n/gim, '<br />');
                            
                            if (strCellHTML === 'NULL' || strCellHTML === '\N') {
                                strCellHTML = strNull;
                            }
                        }
                        
                        strCellHTML = '<' + 'td rowspan="1" colspan="1">' + (strCellHTML || '') + '</td>'
                        
                        strHTMLRecordString += (cell_i === intFromCell ? '<' + 'tr>' : '');
                        strHTMLRecordString += (strCellHTML || '');
                        strHTMLRecordString += (cell_i === (intToCell - 1) ? '<' + '/tr>' : '');
                    }
                }
                if (strHTMLRecordString.trim()) {
                    strHTMLCopyString += strHTMLRecordString;
                }
            }
            //console.log('*****', strHTMLCopyString);
            if (strHTMLCopyString) {
                strHTMLCopyString = '<' + 'style>' +
                                        'br { mso-data-placement:same-cell; } ' +
                                        'th, td { white-space: pre-wrap; }' +
                                    '<' + '/style>' +
                                    '<' + 'table border="0" cellpadding="0" cellspacing="0">' + strHTMLCopyString + '<' + '/table>';
            }
        }
        
        return strHTMLCopyString || '';
    }
    
    function getSelectedCopyText(element) {
        var strTextCopyString, intFromRecord, intToRecord, intFromCell = 9999999, intToCell = 0,
            i, len, cell_i, cell_len, arrSelected, strCellText, arrRecords, arrCells, arrCellIndexes, strTextRecordString,
            strQuoteType, strQuoteChar, strFieldDelimiter, strRowDelimiter, strNull, bolColumns, quoteRegex;
        
        strQuoteType      = (element.getAttribute('quote-type')      || "strings");
        strQuoteChar      = (element.getAttribute('quote-char')      || '"');
        strFieldDelimiter = (element.getAttribute('field-delimiter') || "\t");
        strNull           = (element.getAttribute('null-values')     || "NULL");
        bolColumns        = (element.getAttribute('column-names')    || "true") === "true";
        strRowDelimiter   = (element.getAttribute('row-delimiter')   || "\n");
        
        quoteRegex = new RegExp(strQuoteChar, 'g');
        
        arrSelected = element.selectedCells;
        
        // loop through the selected cells and create a tsv string using the text of the cell
        if (arrSelected.length > 0) {
            intFromRecord = arrSelected[0].parentNode.rowIndex;
            intToRecord = arrSelected[arrSelected.length - 1].parentNode.rowIndex + 1;
            
            for (i = 0, len = arrSelected.length; i < len; i += 1) {
                if (arrSelected[i].cellIndex < intFromCell) {
                    intFromCell = arrSelected[i].cellIndex;
                    intFromCell = (intFromCell === 0 ? 1 : intFromCell);
                }
                if (arrSelected[i].cellIndex + 1 > intToCell) {
                    intToCell = arrSelected[i].cellIndex + 1;
                }
            }
            
            arrRecords = xtag.query(element, 'tr');
            strTextCopyString = '';
            
            // if bolColumns is true and the first record is not selected: add first record first
            if (bolColumns && intFromRecord > 0) {
                arrCells = arrRecords[0].children;
                strTextRecordString = '';
                
                for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                    strCellText = '';
                    
                    if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) {
                        strCellText = arrCells[cell_i].firstElementChild.textValue ||
                                      arrCells[cell_i].firstElementChild.value ||
                                      (arrCells[cell_i].firstElementChild.checked || '').toString() ||
                                      arrCells[cell_i].firstElementChild.textContent || '';//.trim();
                        
                    } else if (arrCells[cell_i].lastElementChild) {
                        strCellText = arrCells[cell_i].lastElementChild.textValue ||
                                      arrCells[cell_i].lastElementChild.value ||
                                      (arrCells[cell_i].lastElementChild.checked || '').toString();
                    } else {
                        strCellText = arrCells[cell_i].textContent;//.trim();
                    }
                    
                    strCellText = strCellText.replace(quoteRegex, (strQuoteChar + strQuoteChar));
                    
                    if (strCellText === 'NULL' || strCellText === '\N') {
                        strCellText = strNull;
                    } else {
                        if (strQuoteType === 'all') {
                            strCellText = strQuoteChar + strCellText + strQuoteChar;
                        } else if (strQuoteType === 'strings' && isNaN(strCellText)) {
                            strCellText = strQuoteChar + strCellText + strQuoteChar;
                        }
                    }
                    
                    strTextRecordString += (cell_i !== intFromCell ? strFieldDelimiter : '');
                    strTextRecordString += (strCellText || '');
                }
                
                strTextCopyString += strTextRecordString;
                strTextCopyString += strRowDelimiter;
            }
            
            for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
                arrCells = arrRecords[i].children;
                strTextRecordString = '';
                
                for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                    strCellText = '';
                    
                    if (arrCells[cell_i].hasAttribute('selected')) {
                        if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) { 
                            strCellText = arrCells[cell_i].firstElementChild.textValue ||
                                          arrCells[cell_i].firstElementChild.value ||
                                          (arrCells[cell_i].firstElementChild.checked || '').toString() ||
                                          arrCells[cell_i].firstElementChild.textContent;//.trim();
                            
                        } else if (arrCells[cell_i].lastElementChild) {
                            strCellText = arrCells[cell_i].lastElementChild.textValue ||
                                          arrCells[cell_i].lastElementChild.value ||
                                          (arrCells[cell_i].lastElementChild.checked || '').toString();
                        } else {
                            strCellText = arrCells[cell_i].textContent;//.trim();
                        }
                        
                        strCellText = strCellText.replace(quoteRegex, (strQuoteChar + strQuoteChar));
                        
                        if (strCellText === 'NULL' || strCellText === '\N') {
                            strCellText = strNull;
                        } else {
                            if (strQuoteType === 'all') {
                                strCellText = strQuoteChar + strCellText + strQuoteChar;
                            } else if (strQuoteType === 'strings' && isNaN(strCellText)) {
                                strCellText = strQuoteChar + strCellText + strQuoteChar;
                            }
                        }
                    } else {
                        if (strQuoteType === 'all' || strQuoteType === 'strings') {
                            strCellText = strQuoteChar + strCellText + strQuoteChar;
                        }
                    }
                    
                    strTextRecordString += (cell_i !== intFromCell ? strFieldDelimiter : '');
                    strTextRecordString += (strCellText || '');
                }
                //if (strTextRecordString.trim()) {
                strTextCopyString += strTextRecordString;
                //}
                if (i + 1 !== len) { //&& strTextRecordString.trim()
                    strTextCopyString += strRowDelimiter;
                }
            }
        }
        
        return strTextCopyString || '';
    }
    
    function handleClipboardData(event, strCopyString, strType) {
        var clipboardData = event.clipboardData || window.clipboardData, strMime;
        
        if (!clipboardData) { return; }
        if (!clipboardData.setData) { return; }
        
        if (strType === 'text') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = 'Text';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/plain';
            }
            
        } else if (strType === 'html') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = '';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/html';
            }
            
        } else {
            throw 'handleClipboardData Error: Type "' + strType + '" not recognized, recognized types are "text" and "html".';
        }
        
        if (strMime) {
            if (strCopyString && strMime) {
                return clipboardData.setData(strMime, strCopyString) !== false;
            } else {
                return clipboardData.getData(strMime);
            }
        }
    }
    
    
    
    //function handleClipboardData(event, strCopyString) {
    //    var clipboardData = event.clipboardData || window.clipboardData, strMime;
    //    
    //    if (!clipboardData) {
    //        return;
    //    }
    //    if (!clipboardData.setData) {
    //        return;
    //    }
    //    
    //    if (window.clipboardData && window.clipboardData.getData) { // IE
    //        strMime = 'Text';
    //    } else if (event.clipboardData && event.clipboardData.getData) {
    //        strMime = 'text/plain';
    //    }
    //    
    //    if (strCopyString) {
    //        return clipboardData.setData(strMime, strCopyString) !== false;
    //    } else {
    //        return clipboardData.getData(strMime);
    //    }
    //}

    GS.makeTableSelectable = function (tableElement, bolSingleRecord) {
        var copyElement;
        
        // tableElement verification
        if (!tableElement || tableElement.nodeName !== 'TABLE') {
            throw 'GS.makeTableSelectable Error: you must provide a <table> element as the first parameter.';
        }
        
        // prevent text selection
        //tableElement.setAttribute('prevent-text-selection', '');
        
        // define selectedCells getter and setter on the table element itself
        Object.defineProperty(tableElement, 'selectedCells', {
            get: function () {
                return xtag.query(this, '[selected]');
            },
            
            set: function (newValue) {
                var i, len, intIdIndex, arrCells = this.selectedCells, arrRecords, cell_i, cell_len;
                
                // clear old selection
                for (i = 0, len = arrCells.length; i < len; i += 1) {
                    arrCells[i].removeAttribute('selected');
                }
                
                arrCells = xtag.query(this, '[selected-secondary]');
                for (i = 0, len = arrCells.length; i < len; i += 1) {
                    arrCells[i].removeAttribute('selected-secondary');
                }
                
                // if newValue is not an array: make it an array
                if (typeof newValue === 'object' && newValue.length === undefined) {
                    arrCells = [newValue];
                } else {
                    arrCells = newValue;
                }
                
                // set new selection
                for (i = 0, len = arrCells.length; i < len; i += 1) {
                    arrCells[i].setAttribute('selected', '');
                }
                
                arrRecords = this.selectedRecords;
                
                for (i = 0, len = arrRecords.length; i < len; i += 1) {
                    arrCells = arrRecords[i].children;
                    
                    for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                        if (!arrCells[cell_i].hasAttribute('selected')) {
                            arrCells[cell_i].setAttribute('selected-secondary', '');
                        }
                    }
                }
                
                GS.triggerEvent(this, 'after_selection');
            }
        });
        
        // define selectedRecords getter and setter on the table element itself
        Object.defineProperty(tableElement, 'selectedRecords', {
            get: function () {
                var i, len, intRecordIndex = -1, arrRecord = [], selected = this.selectedCells;
                
                // loop through the selected cells and create an array of trs
                for (i = 0, len = selected.length; i < len; i += 1) {
                    if (selected[i].parentNode.rowIndex > intRecordIndex && selected[i].parentNode.parentNode.nodeName !== 'THEAD') {
                        intRecordIndex = selected[i].parentNode.rowIndex;
                        
                        arrRecord.push(selected[i].parentNode);
                    }
                }
                
                return arrRecord;
            },
            
            set: function (newValue) {
                var i, len, cell_i, cell_len, intIdIndex, arrCells = this.selectedCells, arrRecords, arrCellChildren;
                
                // clear old selection
                for (i = 0, len = arrCells.length; i < len; i += 1) {
                    arrCells[i].removeAttribute('selected');
                }
                
                arrCells = xtag.query(this, '[selected-secondary]');
                for (i = 0, len = arrCells.length; i < len; i += 1) {
                    arrCells[i].removeAttribute('selected-secondary');
                }
                
                // if newValue is not an array: make it an array
                if (typeof newValue === 'object' && newValue.length === undefined) {
                    arrRecords = [newValue];
                } else {
                    arrRecords = newValue;
                }
                
                // set new selection
                for (i = 0, len = arrRecords.length, arrCells = []; i < len; i += 1) {
                    arrCellChildren = arrRecords[i].children;
                    
                    for (cell_i = 0, cell_len = arrCellChildren.length; cell_i < cell_len; cell_i += 1) {
                        arrCells.push(arrCellChildren[cell_i]);
                    }
                }
                
                this.selectedCells = arrCells;
                
                GS.triggerEvent(this, 'after_selection');
            }
        });
        
        // if we are on a touchdevice or bolSingleRecord is true: single record selection
        if (evt.touchDevice || bolSingleRecord === true) {
            tableElement.addEventListener(evt.mousedown, function (event) {
                var target = event.target;
                
                if (target.nodeName === 'TD' || target.nodeName === 'TH' || getCellFromTarget(target)) {
                    tableElement.selectedCells = [];
                    
                    // if there is a parent record to the target: select all of the cells in the record
                    if (GS.findParentTag(target, 'tr')) {
                        tableElement.selectedCells = GS.findParentTag(target, 'tr').children;
                    }
                }
            });
            
        // else: cell/record selection
        } else {
            // mousedown (on selected and unselected) + drag
            //      clear previous selection(s)
            //      select cells from origin cell to current cell
            //
            // shift + mousedown (on selected and unselected) + drag
            //      alter previous selection
            //      select cells from previous origin cell to current cell
            //
            // command + mousedown (on unselected) + drag
            //      maintain previous selection(s)
            //      select cells from origin cell to current cell
            //
            // command + mousedown (on selected) + drag
            //      maintain previous selection(s)
            //      deselect cells from origin cell to current cell
            //
            // collision handling
            //      when colliding with previous selections: dont treat them different
            //
            // copy handling
            //      selection ("X" marks selected cells (imagine all cells contain the letter "a")):
            //          1  2  3  4  5
            //          -------------
            //          a  a  a  a  a
            //          a  X  X  a  a
            //          a  a  X  X  a
            //          a  a  a  a  a
            //
            //      yields ("'" marks an empty cell):
            //          2  3  4 
            //          -------
            //          a  a  ' 
            //          '  a  a 
            
            tableElement.addEventListener(evt.mousedown, function (event) {
                var target = event.target, cellFromTarget = getCellFromTarget(target), closestCell, arrSelectedCells, i, len;
                
                if (GS.findParentTag(event.target, 'table')) {
                    if (cellFromTarget) {
                        closestCell = cellFromTarget;
                    }
                    
                    if (closestCell) {
                        tableElement.dragAllowed = true;
                        tableElement.dragCurrentCell = closestCell;
                        tableElement.selectionSelectedCells = [];
                        
                        // if shift is down and there is a previous origin: use previous origin for current origin
                        if (event.shiftKey && tableElement.selectionPreviousOrigin) {
                            
                            // if there are previously selected cells: deselect the previous selected cells
                            if (tableElement.selectionPreviousSelectedCells) {
                                arrSelectedCells = tableElement.selectedCells;
                                
                                for (i = 0, len = tableElement.selectionPreviousSelectedCells.length; i < len; i += 1) {
                                    arrSelectedCells.splice(arrSelectedCells.indexOf(tableElement.selectionPreviousSelectedCells[i]), 1);
                                }
                                
                                tableElement.selectedCells = arrSelectedCells;
                            }
                            
                            tableElement.dragOrigin = tableElement.selectionPreviousOrigin;
                            tableElement.dragMode = 'select';
                            
                        // else if ctrl or cmd is down and the target cell is not selected: select cells from target cell to current cell
                        } else if (!event.shiftKey && (event.metaKey || event.ctrlKey) && !closestCell.hasAttribute('selected')) {
                            tableElement.dragOrigin = closestCell;
                            tableElement.dragMode = 'select';
                            
                        // else if ctrl or cmd is down and the target cell is selected: deselect cells from target cell to current cell
                        } else if (!event.shiftKey && (event.metaKey || event.ctrlKey) && closestCell.hasAttribute('selected')) {
                            tableElement.dragOrigin = closestCell;
                            tableElement.dragMode = 'deselect';
                            
                        // else: deselect all cells and start new selection
                        } else {
                            tableElement.selectedCells = [];
                            tableElement.dragOrigin = closestCell;
                            tableElement.dragMode = 'select';
                        }
                        
                        selectHandler(tableElement, tableElement.dragOrigin, tableElement.dragCurrentCell, tableElement.dragMode);
                    }
                }
            });
            tableElement.addEventListener(evt.mousemove, function (event) {
                var target, closestCell, cellFromTarget;
                
                // if mouse is down
                if (event.which !== 0) {
                    target = event.target;
                    cellFromTarget = getCellFromTarget(target);
                    
                    if (cellFromTarget) {
                        closestCell = cellFromTarget;
                    }
                    
                    // if selection is allowed at this point and closestCell is different from tableElement.dragCurrentCell
                    if (tableElement.dragAllowed && tableElement.dragCurrentCell !== closestCell) {
                        tableElement.dragCurrentCell = getCellFromTarget(closestCell);
                        selectHandler(tableElement, tableElement.dragOrigin, tableElement.dragCurrentCell, tableElement.dragMode);
                    }
                } else {
                    tableElement.dragAllowed = false;
                    tableElement.selectionPreviousOrigin = tableElement.dragOrigin;
                    tableElement.selectionPreviousSelectedCells = tableElement.selectionSelectedCells;
                }
            });
            tableElement.addEventListener(evt.mouseup, function (event) {
                tableElement.dragAllowed = false;
                
                if (tableElement.dragMode === 'select') {
                    tableElement.selectionPreviousOrigin = tableElement.dragOrigin;
                    tableElement.selectionPreviousSelectedCells = tableElement.selectionSelectedCells;
                }
            });
        }
        
        // add input for clipboard compatibility
        copyElement = document.createElement('input');
        copyElement.value = 'Firefox compatibility input';
        copyElement.setAttribute('gs-dynamic', '');
        copyElement.setAttribute('style', 'position: fixed; left: 50%; top: 50%; z-index: -5000; opacity: 0.00000001;');
        
        tableElement.appendChild(copyElement);
        
        // add tabindex so that we can listen for focus on the table
        tableElement.tabIndex = 0;
        
        // when a focus event happens on the table: focus the copy input if the element that is focused is the table
        tableElement.addEventListener('focus', function (event) {
            if (document.activeElement === tableElement) {
                tableElement.focus();
                GS.setInputSelection(copyElement, 0, 'Firefox compatibility input'.length);
            }
        });
        
        // clipboard handling
        document.body.addEventListener('copy', function (event) {
            var elementClosestTable = GS.findParentTag(document.activeElement, 'table')
              , strTextCopyString, strHTMLCopyString;
            
            if (elementClosestTable === tableElement &&
                (
                    document.activeElement.value === 'Firefox compatibility input' ||
                    document.activeElement.selectionStart === document.activeElement.selectionEnd
                )) {
                GS.setInputSelection(document.activeElement, document.activeElement.value.length,
                                            document.activeElement.value.length);
                
                strTextCopyString = getSelectedCopyText(tableElement);
                strHTMLCopyString = getSelectedCopyHTML(tableElement);
                
                if (strTextCopyString && strHTMLCopyString) {
                    if (handleClipboardData(event, strTextCopyString, 'text')) {
                        event.preventDefault(event);
                    }
                    if (handleClipboardData(event, strHTMLCopyString, 'html')) {
                        event.preventDefault(event);
                    }
                }
                
                GS.setInputSelection(document.activeElement, 0, document.activeElement.value.length);
            }
        });
            //var elementClosestTable = GS.findParentTag(document.activeElement, 'table'), strCopyString,
            //    i, len, cell_i, cell_len, arrSelected, intFromRecord = 9999999, intFromCell = 9999999,
            //    intToRecord = 0, intToCell = 0, strCellText, arrRecords, arrCells, strRecordString;
            //
            //if (elementClosestTable === tableElement &&
            //    (
            //        document.activeElement.value === 'Firefox compatibility input' ||
            //        document.activeElement.selectionStart === document.activeElement.selectionEnd
            //    )) {
            //    arrSelected = tableElement.selectedCells;
            //    
            //    // loop through the selected cells and create a tsv string using the text of the cell
            //    if (arrSelected.length > 0) {
            //        for (i = 0, len = arrSelected.length; i < len; i += 1) {
            //            if (arrSelected[i].parentNode.rowIndex < intFromRecord) {
            //                intFromRecord = arrSelected[i].parentNode.rowIndex;
            //            }
            //            if (arrSelected[i].cellIndex < intFromCell) {
            //                intFromCell = arrSelected[i].cellIndex;
            //            }
            //            if (arrSelected[i].parentNode.rowIndex + 1 > intToRecord) {
            //                intToRecord = arrSelected[i].parentNode.rowIndex + 1;
            //            }
            //            if (arrSelected[i].cellIndex + 1 > intToCell) {
            //                intToCell = arrSelected[i].cellIndex + 1;
            //            }
            //        }
            //        
            //        arrRecords = xtag.query(tableElement, 'tr');
            //        strCopyString = '';
            //        
            //        for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
            //            arrCells = arrRecords[i].children;
            //            
            //            for (cell_i = intFromCell, cell_len = intToCell, strRecordString = ''; cell_i < cell_len; cell_i += 1) {
            //                if (arrCells[cell_i].hasAttribute('selected')) {
            //                    if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) { 
            //                        strCellText = arrCells[cell_i].firstElementChild.textValue ||
            //                                      arrCells[cell_i].firstElementChild.value ||
            //                                      (arrCells[cell_i].firstElementChild.checked || '').toString() ||
            //                                      arrCells[cell_i].firstElementChild.textContent.trim();
            //                    } else if (arrCells[cell_i].lastElementChild) { 
            //                        strCellText = arrCells[cell_i].lastElementChild.textValue ||
            //                                      arrCells[cell_i].lastElementChild.value ||
            //                                      (arrCells[cell_i].lastElementChild.checked || '').toString() ||
            //                                      arrCells[cell_i].lastElementChild.textContent.trim();
            //                    } else {
            //                        strCellText = arrCells[cell_i].textContent.trim();
            //                    }
            //                } else {
            //                    strCellText = '';
            //                }
            //                
            //                strRecordString += (cell_i !== intFromCell ? '\t' : '') + (strCellText || '');
            //            }
            //            
            //            if (strRecordString.trim()) {
            //                strCopyString += strRecordString;
            //            }
            //            
            //            if (i + 1 !== len && strRecordString.trim()) {
            //                strCopyString += '\r\n';
            //            }
            //        }
            //    }
            //    
            //    if (strCopyString) {
            //        if (handleClipboardData(event, strCopyString)) {
            //            event.preventDefault(event);
            //        }
            //    }
            //}
    };
})();//global registerDesignSnippet, window, GS, ml, encodeHTML
//jslint browser


window.addEventListener('design-register-element', function () {
    "use strict";

    //registerDesignSnippet('GS.formatDate', 'GS.formatDate', 'GS.formatDate(${1:dteDate}, ${2:strFormat})');
});

GS.convertNumberToRoman = function (varNum) {
    "use strict";
    var intNum = parseInt(varNum, 10) || 0;
    var strNum = String(intNum);
    var arrDigits = strNum.split('');

    var arrOnes = ['', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];
    var arrTens = ['', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC'];
    var arrHundreds = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM'];

    var intOnes = parseInt(arrDigits.pop(), 10);
    var intTens = parseInt(arrDigits.pop(), 10);
    var intHundreds = parseInt(arrDigits.pop(), 10);
    var intRemaining = parseInt(arrDigits.join(''), 10);
    var arrRemaining = new Array(intRemaining + 1);

    return (
        arrRemaining.join('M') + // repeat "M" for all remaining numbers
        (arrHundreds[intHundreds] || '') + // add hundreds
        (arrTens[intTens] || '') + // add tens
        (arrOnes[intOnes] || '') // add ones
    );
};

// .--------------------------.---------------------------------------------------------------------------------------------------.
// | Pattern                  | Description                                                                                       |
// |--------------------------|---------------------------------------------------------------------------------------------------|
// | H                        | hour of day (01â12)                                                                               |
// | HH12                     | hour of day (01â12)                                                                               |
// | HH24                     | hour of day (00â23)                                                                               |
// | MI                       | minute (00â59)                                                                                    |
// | SS                       | second (00â59)                                                                                    |
// | MS                       | millisecond (000â999)                                                                             |
// | US                       | microsecond (000000â999999)                                                                       |
// | FF1                      | tenth of second (0â9)                                                                             |
// | FF2                      | hundredth of second (00â99)                                                                       |
// | FF3                      | millisecond (000â999)                                                                             |
// | FF4                      | tenth of a millisecond (0000â9999)                                                                |
// | FF5                      | hundredth of a millisecond (00000â99999)                                                          |
// | FF6                      | microsecond (000000â999999)                                                                       |
// | SSSS, SSSSS              | seconds past midnight (0â86399)                                                                   |
// | AM, am, PM or pm         | meridiem indicator (without periods)                                                              |
// | A.M., a.m., P.M. or p.m. | meridiem indicator (with periods)                                                                 |
// | Y,YYY                    | year (4 or more digits) with comma                                                                |
// | YYYY                     | year (4 or more digits)                                                                           |
// | YYY                      | last 3 digits of year                                                                             |
// | YY                       | last 2 digits of year                                                                             |
// | Y                        | last digit of year                                                                                |
// | IYYY                     | ISO 8601 week-numbering year (4 or more digits)                                                   |
// | IYY                      | last 3 digits of ISO 8601 week-numbering year                                                     |
// | IY                       | last 2 digits of ISO 8601 week-numbering year                                                     |
// | I                        | last digit of ISO 8601 week-numbering year                                                        |
// | BC, bc, AD or ad         | era indicator (without periods)                                                                   |
// | B.C., b.c., A.D. or a.d. | era indicator (with periods)                                                                      |
// | MONTH                    | full upper case month name (blank-padded to 9 chars)                                              |
// | Month                    | full capitalized month name (blank-padded to 9 chars)                                             |
// | month                    | full lower case month name (blank-padded to 9 chars)                                              |
// | MON                      | abbreviated upper case month name (3 chars in English, localized lengths vary)                    |
// | Mon                      | abbreviated capitalized month name (3 chars in English, localized lengths vary)                   |
// | mon                      | abbreviated lower case month name (3 chars in English, localized lengths vary)                    |
// | MM                       | month number (01â12)                                                                              |
// | DAY                      | full upper case day name (blank-padded to 9 chars)                                                |
// | Day                      | full capitalized day name (blank-padded to 9 chars)                                               |
// | day                      | full lower case day name (blank-padded to 9 chars)                                                |
// | DY                       | abbreviated upper case day name (3 chars in English, localized lengths vary)                      |
// | Dy                       | abbreviated capitalized day name (3 chars in English, localized lengths vary)                     |
// | dy                       | abbreviated lower case day name (3 chars in English, localized lengths vary)                      |
// | DDD                      | day of year (001â366)                                                                             |
// | IDDD                     | day of ISO 8601 week-numbering year (001â371; day 1 of the year is Monday of the first ISO week)  |
// | DD                       | day of month (01â31)                                                                              |
// | D                        | day of the week, Sunday (1) to Saturday (7)                                                       |
// | ID                       | ISO 8601 day of the week, Monday (1) to Sunday (7)                                                |
// | W                        | week of month (1â5) (the first week starts on the first day of the month)                         |
// | WW                       | week number of year (1â53) (the first week starts on the first day of the year)                   |
// | IW                       | week number of ISO 8601 week-numbering year (01â53; the first Thursday of the year is in week 1)  |
// | CC                       | century (2 digits) (the twenty-first century starts on 2001-01-01)                                |
// | J                        | Julian Date (integer days since November 24, 4714 BC at local midnight; see Section B.7)          |
// | Q                        | quarter                                                                                           |
// | RM                       | month in upper case Roman numerals (IâXII; I=January)                                             |
// | rm                       | month in lower case Roman numerals (iâxii; i=January)                                             |
// | TZ                       | upper case time-zone abbreviation (only supported in to_char)                                     |
// | tz                       | lower case time-zone abbreviation (only supported in to_char)                                     |
// | TZH                      | time-zone hours                                                                                   |
// | TZM                      | time-zone minutes                                                                                 |
// | OF                       | time-zone offset from UTC (only supported in to_char)                                             |
// '--------------------------'---------------------------------------------------------------------------------------------------'

// .--------------------------.-----------------------------------------------------------------------.---------------------------.
// | Modifier                 | Description                                                           | Example                   |
// |--------------------------|-----------------------------------------------------------------------|---------------------------|
// | FM prefix                | fill mode (suppress leading zeroes and padding blanks)                | FMMonth                   |
// | TH suffix                | upper case ordinal number suffix                                      | DDTH, e.g., 12TH          |
// | th suffix                | lower case ordinal number suffix                                      | DDth, e.g., 12th          |
// | FX prefix                | fixed format global option (see usage notes)                          | FX Month DD Day           |
// | TM prefix                | translation mode (use localized day and month names based on lc_time) | TMMonth                   |
// | SP suffix                | spell mode (not implemented)                                          | DDSP                      |
// '--------------------------'-----------------------------------------------------------------------'---------------------------'

// GS.formatDate = function (dteDate, strFormat) {
//     "use strict";
//     var arrFullMon = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
//     var arrAbbrMon = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
//     var arrFullDay = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
//     var arrAbbrDay = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

    
// };


/*


    function formatDate(dteValue, strFormat) {
        / * (this function contains a (modified) substantial portion of code from another source
            here is the copyright for sake of legality) (Uses code by Matt Kruse)
        Copyright (c) 2006-2009 Rostislav Hristov, Asual DZZD

        Permission is hereby granted, free of charge, to any person obtaining a
        copy of this software and associated documentation files
        (the "Software"), to deal in the Software without restriction,
        including without limitation the rights to use, copy, modify, merge,
        publish, distribute, sublicense, and/or sell copies of the Software,
        and to permit persons to whom the Software is furnished to do so,
        subject to the following conditions:

        The above copyright notice and this permission notice shall be included
        in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.* /
        var i = 0, j = 0, l = 0, c = '', token = '', x, y, yearLen,
            formatNumber = function (n, s) {
                if (typeof s == 'undefined' || s == 2) {
                  return (n >= 0 && n < 10 ? '0' : '') + n;
                } else {
                    if (n >= 0 && n < 10) {
                       return '00' + n;
                    }
                    if (n >= 10 && n <100) {
                       return '0' + n;
                    }
                    return n;
                }
            },
            locale = {
                monthsFull:   ['January','February','March','April','May','June', 'July','August','September','October','November','December'],
                monthsShort:  ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],
                daysFull:     ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
                daysShort:    ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],
                shortDateFormat: 'M/d/yyyy h:mm a',
                longDateFormat: 'EEEE, MMMM dd, yyyy h:mm:ss a'
            };

        y = dteValue.getFullYear();
        // Nunzio commented this out on Monday, October 19, 2015
        // It was causing an issue during typing in the year field
        / *if (y < 1000) {
            y = String(y + 1900);
        }* /

        var M = dteValue.getMonth() + 1,
            d = dteValue.getDate(),
            E = dteValue.getDay(),
            H = dteValue.getHours(),
            m = dteValue.getMinutes(),
            s = dteValue.getSeconds(),
            S = dteValue.getMilliseconds();

        //console.log(dteValue.getFullYear());

        yearLen = String(y).length;
        dteValue = {
            y: y,
            yyyy: y,
            yy: String(y).substring(yearLen - 2, yearLen),
            M: M,
            MM: formatNumber(M),
            MMM: locale.monthsShort[M-1],
            MMMM: locale.monthsFull[M-1],
            d: d,
            dd: formatNumber(d),
            EEE: locale.daysShort[E],
            EEEE: locale.daysFull[E],
            H: H,
            HH: formatNumber(H)
        };

        //console.log(dteValue);

        if (H === 0) {
            dteValue.h = 12;
        } else if (H > 12) {
            dteValue.h = H - 12;
        } else {
            dteValue.h = H;
        }

        dteValue.hh = formatNumber(dteValue.h);
        dteValue.k = H !== 0 ? H : 24;
        dteValue.kk = formatNumber(dteValue.k);

        if (H > 11) {
            dteValue.K = H - 12;
        } else {
            dteValue.K = H;
        }

        dteValue.KK = formatNumber(dteValue.K);

        if (H > 11) {
            dteValue.a = 'PM';
        } else {
            dteValue.a = 'AM';
        }

        dteValue.m = m;
        dteValue.mm = formatNumber(m);
        dteValue.s = s;
        dteValue.ss = formatNumber(s);
        dteValue.S = S;
        dteValue.SS = formatNumber(S);
        dteValue.SSS = formatNumber(S, 3);

        var result = '';

        i = 0;
        c = '';
        token = '';
        s = false;

        while (i < strFormat.length) {
            token = '';
            c = strFormat.charAt(i);
            if (c == '\'') {
                i++;
                if (strFormat.charAt(i) == c) {
                    result = result + c;
                    i++;
                } else {
                    s = !s;
                }
            } else {
                while (strFormat.charAt(i) == c) {
                    token += strFormat.charAt(i++);
                }
                if (token.indexOf('MMMM') != -1 && token.length > 4) {
                    token = 'MMMM';
                }
                if (token.indexOf('EEEE') != -1 && token.length > 4) {
                    token = 'EEEE';
                }
                if (typeof dteValue[token] != 'undefined' && !s) {
                    result = result + dteValue[token];
                } else {
                    result = result + token;
                }
            }
        }

        return result;
    }


*/


window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('GS.qryFromJSON', 'GS.qryFromJSON', 'GS.qryFromJSON(${0:jsnObjectToConvert});');
    
    registerDesignSnippet('GS.qryToJSON', 'GS.qryToJSON', 'GS.qryToJSON(${0:strQueryStringToConvert});');
    
    registerDesignSnippet('GS.qryToWhere', 'GS.qryToWhere',
                                'GS.qryToWhere(${1:strQueryString}, ${2:strColumnNameInQueryString}, ${0:strColumnNameInTarget});');
    
    registerDesignSnippet('GS.qryGetKeys', 'GS.qryGetKeys', 'GS.qryGetKeys(${0:queryString});');
    
    registerDesignSnippet('GS.qryGetVals', 'GS.qryGetVals', 'GS.qryGetVals(${0:queryString});');
    
    registerDesignSnippet('GS.qryGetVal', 'GS.qryGetVal', 'GS.qryGetVal(${1:queryString}, \'${0:keyToGet}\');');
    
    registerDesignSnippet('GS.qrySetVal', 'GS.qrySetVal', 'GS.qrySetVal(${1:queryString}, \'${0:newKeyValuePair}\');');
    
    registerDesignSnippet('GS.qryDeleteKey', 'GS.qryDeleteKey', 'GS.qryDeleteKey(${1:queryString}, \'${0:keyToDelete}\');');
    
    registerDesignSnippet('GS.getQueryString', 'GS.getQueryString', 'GS.getQueryString();');
    
    registerDesignSnippet('GS.pushQueryString', 'GS.pushQueryString', 'GS.pushQueryString(${0:newQueryString});');
    
    registerDesignSnippet('GS.removeFromQueryString', 'GS.removeFromQueryString', 'GS.removeFromQueryString(${0:removeKeys});');
});


// ########## CONVERSION FUNCTIONS ##########
GS.qryFromJSON = function (jsnToConvert) {
    'use strict';
    var key, strRet = '', strType, currentValue;
    
    for (key in jsnToConvert) {
        currentValue = jsnToConvert[key];
        strType = typeof currentValue;
        
        if (strType === 'number' || strType === 'string' || strType === 'boolean') {
            strRet += (strRet === '' ? '' : '&') + key + '=' + encodeURIComponent(jsnToConvert[key]);
            
        } else if (currentValue === null || currentValue === undefined) {
            strRet += (strRet === '' ? '' : '&') + key + '=';
            
        } else if (typeof currentValue !== 'object') {
            throw 'GS.qryFromJSON Error: Invalid value: ' + JSON.stringify(currentValue);
        }
    }
    
    return strRet;
};

GS.qryToJSON = function (strQueryString) {
    'use strict';
    var arrKeyValueList = [], jsnQueryString = {}, strKeyValue, i, len, strKey, strValue, jsnNavigator, arrSubParts, sub_i, sub_len;
    
    if (strQueryString) {
        arrKeyValueList = strQueryString.split('&');
        
        for (i = 0, len = arrKeyValueList.length; i < len; i += 1) {
            strKeyValue = arrKeyValueList[i];
            strKey      = strKeyValue.substring(0, strKeyValue.indexOf('='));
            strValue    = decodeURIComponent(strKeyValue.substring(strKeyValue.indexOf('=') + 1));
            
            jsnQueryString[strKey] = strValue;
            
            // if a dot is found in the key: create a sub JSON structure
            if (strKey.indexOf('.') > -1) {
                arrSubParts = strKey.split('.');
                
                jsnNavigator = jsnQueryString;
                for (sub_i = 0, sub_len = arrSubParts.length; sub_i < sub_len; sub_i += 1) {
                    if (sub_i < sub_len - 1) {
                        jsnNavigator[arrSubParts[sub_i]] = jsnNavigator[arrSubParts[sub_i]] || {};
                    } else {
                        jsnNavigator[arrSubParts[sub_i]] = jsnNavigator[arrSubParts[sub_i]] || strValue;
                    }
                    
                    jsnNavigator = jsnNavigator[arrSubParts[sub_i]];
                }
            }
        }
    }
    
    return jsnQueryString;
};

// get data from query string and turn it into a where clause
//      (
//          the second two params are optional
//              (
//                  they are for when you want only one column out of a query string to be converted
//              )
//      )
GS.qryToWhere = function (strQS, strColumnNameInQS, strColumnNameInTarget) {
    'use strict';
    var strWhere = '', key, jsnArgs;
    
    if (strColumnNameInQS) {
        strColumnNameInTarget = (strColumnNameInTarget || strColumnNameInQS);
        
        if (!isNaN(GS.qryGetVal(strQS, strColumnNameInQS))) {
            strWhere = strColumnNameInTarget + '=' + GS.qryGetVal(strQS, strColumnNameInQS);
        } else {
            strWhere = 'CAST(' + strColumnNameInTarget + ' AS ' + GS.database.type.text + ') = ' +
                       'CAST($WhereQUOTE$' +
                            encodeURIComponent(GS.qryGetVal(strQS, strColumnNameInQS)) +
                            '$WhereQUOTE$ AS ' + GS.database.type.text + ')';
        }
    } else {
        jsnArgs = GS.qryToJSON(strQS);

        for (key in jsnArgs) {
            if (jsnArgs.hasOwnProperty(key)) {
                if (!isNaN(jsnArgs[key])) {
                    strWhere += (strWhere === '' ? '': ' AND ') + key + '=' + jsnArgs[key];
                } else {
                    strWhere += (strWhere === '' ? '': ' AND ') +
                                'CAST(' + key + ' AS ' + GS.database.type.text + ') = ' +
                                'CAST($WhereQUOTE$' + encodeURIComponent(jsnArgs[key]) + '$WhereQUOTE$ AS ' + GS.database.type.text + ')';
                }
            }
        }
    }
    
    return strWhere;
};


// ########## LISTING FUNCTIONS ##########
GS.qryGetKeys = function (strQueryString) {
    'use strict';
    var arrKeyValueList = [], arrKeys = [], i, len, strKeyValue;
    
    if (strQueryString) {
        arrKeyValueList = strQueryString.split('&');
        
        for (i = 0, len = arrKeyValueList.length; i < len; i += 1) {
            strKeyValue = arrKeyValueList[i];
            
            arrKeys.push(strKeyValue.substring(0, strKeyValue.indexOf('=')));
        }
    }
    
    return arrKeys;
};

GS.qryGetVals = function (strQueryString) {
    'use strict';
    var arrKeyValueList = [], arrValues = [], i, len, strKeyValue;
    
    if (strQueryString) {
        arrKeyValueList = strQueryString.split('&');
        
        for (i = 0, len = arrKeyValueList.length; i < len; i += 1) {
            strKeyValue = arrKeyValueList[i];
            
            arrValues.push(decodeURIComponent(strKeyValue.substring(strKeyValue.indexOf('=') + 1)));
        }
    }
    
    return arrValues;
};


// ########## PARAMETER GET/SET FUNCTIONS ##########
GS.qryGetVal = function (strQueryString, strKey) {
    'use strict';
    var arrKeyValueList, strSlice, i, len;
    
    if (strQueryString) {
        arrKeyValueList = strQueryString.split('&');
        
        for (i = 0, len = arrKeyValueList.length; i < len; i = i + 1) {
            strSlice = arrKeyValueList[i];
            
            if (strSlice.split('=')[0] === strKey) {
                return decodeURIComponent(strSlice.substring(strSlice.indexOf('=') + 1));
            }
        }
    }
    
    return '';
};

GS.qrySetVal = function (strQueryString, strKeyValue) {
    'use strict';
    strQueryString = GS.qryDeleteKey(strQueryString, strKeyValue.split('=')[0]);
    strQueryString = strQueryString + (strQueryString ? '&' : '') + strKeyValue;
    
    return strQueryString;
};


// ########## KEY DELETE FUNCTION ##########
GS.qryDeleteKey = function (strQueryString, strKey) {
    'use strict';
    var arrKeyValueList, strSlice, i, len;
    
    if (strQueryString) {
        arrKeyValueList = strQueryString.split('&');
        
        for (i = 0, len = arrKeyValueList.length; i < len; i = i + 1) {
            strSlice = arrKeyValueList[i];
            
            if (strSlice.split('=')[0] === strKey) {
                arrKeyValueList.splice(i, 1);
                
                break;
            }
        }
        
        return arrKeyValueList.join('&');
    }
    
    return '';
};


// ########## MISC FUNCTIONS ##########
GS.getQueryString = function () {
    'use strict';
    return window.location.search.substring(1);
};

GS.pushQueryString = function (QS) {
    var arrNewQS = QS.split('&'), i, len, newQS = GS.getQueryString();
    for (i = 0, len = arrNewQS.length; i < len; i += 1) {
        newQS = GS.qrySetVal(newQS, arrNewQS[i]);
    }
    GS.pushState({}, '', '?' + newQS);
};


GS.removeFromQueryString = function (keys) {
    var arrRemoveKeys = keys.split(','), i, len, newQS = GS.getQueryString();
    for (i = 0, len = arrRemoveKeys.length; i < len; i += 1) {
        newQS = GS.qryDeleteKey(newQS, arrRemoveKeys[i]);
    }
    GS.pushState({}, '', '?' + newQS);
};

window.addEventListener('design-register-element', function () {
    'use strict';
    
    //registerDesignSnippet('GS.qryFromJSON', 'GS.qryFromJSON', 'GS.qryFromJSON(${0:jsnObjectToConvert});');
});



GS.templateColumnToValue = function (templateHTML) {
    'use strict';
    var templateElementEncoded = document.createElement('template'),
        templateElementNonEncoded = document.createElement('template'),
        arrTemplateElementEncoded, arrTemplateElementNonEncoded,
        jsnTemplates = {}, arrColumnElement = [], templateHTMLEncoded, bolInCommand, i, len, strID;
    
    // get template element encoded with all "&"s (that are not inside a doT command) encoded,
    //      so that html encoded characters are not lost in the next operations
    
    for (i = 0, len = templateHTML.length, templateHTMLEncoded = '', bolInCommand = false; i < len; i += 1) {
        if (!bolInCommand && templateHTML[i] === '{' && templateHTML[i + 1] === '{') {
            bolInCommand = true;
            i += 1;
            templateHTMLEncoded += '{{';
            
        } else if (bolInCommand && templateHTML[i] === '}' && templateHTML[i + 1] === '}') {
            bolInCommand = false;
            i += 1;
            templateHTMLEncoded += '}}';
            
        } else if (!bolInCommand && templateHTML[i] === '&') {
            templateHTMLEncoded += '&amp;';
            
        } else {
            templateHTMLEncoded += templateHTML[i];
        }
    }
    
    //console.log(templateHTML);
    //console.log(templateHTMLEncoded);
    templateElementEncoded.innerHTML = templateHTMLEncoded; //templateHTML.replace(/&/gi, '&amp;');
    
    // get template element non-encoded with everything in it, so that sub templates are not touched
    templateElementNonEncoded.innerHTML = templateHTML;
    
    // go through element encoded and replace templates with tokens
    // go through element non-encoded and gather templates and make sure they reference the same tokens
    arrTemplateElementEncoded = xtag.query(templateElementEncoded.content, 'template');
    arrTemplateElementNonEncoded = xtag.query(templateElementNonEncoded.content, 'template');
    i = 0;
    
    //console.log(arrTemplateElementEncoded);
    //console.log(arrTemplateElementNonEncoded);
    
    //console.log(arrTemplateElementEncoded.length);
    while (arrTemplateElementEncoded.length > 0 && i < 500) {
        //console.log(arrTemplateElementNonEncoded[0].parentNode);
        
        if (arrTemplateElementNonEncoded[0].parentNode &&
            arrTemplateElementNonEncoded[0].parentNode.hasAttribute &&
                (
                    arrTemplateElementNonEncoded[0].parentNode.hasAttribute('src') ||
                    arrTemplateElementNonEncoded[0].parentNode.hasAttribute('source')
                )) {
            strID = 'UnIqUE_PLaCEh0LDER-' + GS.GUID() + '-UniQUE_PLaCEh0LdER';
            jsnTemplates[strID] = arrTemplateElementNonEncoded[0].outerHTML;
            arrTemplateElementEncoded[0].outerHTML = strID;
        } else {
            // append any sub templates to the "arrTemplateElementEncoded" and "arrTemplateElementNonEncoded"
            //      variables
            arrTemplateElementEncoded = arrTemplateElementEncoded
                                            .concat(xtag.query(arrTemplateElementEncoded[0].content, 'template'));
            arrTemplateElementNonEncoded = arrTemplateElementNonEncoded
                                                .concat(xtag.query(arrTemplateElementNonEncoded[0].content, 'template'));
            
            // append any column elements in this template to the "arrColumnElement" variable
            arrColumnElement = arrColumnElement.concat(xtag.query(arrTemplateElementEncoded[0].content, '[column]'));
        }
        
        // remove the current template from the arrays
        arrTemplateElementEncoded.splice(0, 1);
        arrTemplateElementNonEncoded.splice(0, 1);
        
        i += 1;
    }
    
    // go through element encoded and add calculated "value" attribute to any element with a "column"
    //      attribute but no "value" attribute
    arrColumnElement = arrColumnElement.concat(xtag.query(templateElementEncoded.content, '[column]'));
    
    for (i = 0, len = arrColumnElement.length; i < len; i += 1) {
        if (!arrColumnElement[i].hasAttribute('value')) {
            arrColumnElement[i].setAttribute('value', '{{! row[\'' + arrColumnElement[i].getAttribute('column').replace(/\\/gi, '\\\\').replace(/\'/gi, '\\\'') + '\'] }}');
        }
    }
    
    //console.log(templateHTML);
    //console.log(arrColumnElement);
    //console.log(jsnTemplates);
    //console.log(templateElementEncoded.innerHTML);
    
    // save element encoded innerHTML as template HTML
    templateHTML = templateElementEncoded.innerHTML;
    
    // go through template HTML and replace template tokens with template HTML
    for (strID in jsnTemplates) {
        //                                      DO NOT DELETE, this allows single dollar signs to be inside dot notation
        //                                                                                                V
        templateHTML = templateHTML.replace(new RegExp(strID, 'g'), jsnTemplates[strID].replace(/\$/g, '$$$$'));
    }
    
    //console.log(element.templateHTML);
    
    return templateHTML;
};


GS.templateWithQuerystring = function (templateText) {
    'use strict';
    var strWrapperTemplate = '{{##def.snippet:\n' +
                             '    {{ var qs = jo; }} {{# def.template }}\n' +
                             '#}}\n' +
                             '{{#def.snippet}}';
    
    return doT.template(strWrapperTemplate, null, {'template': templateText})(GS.qryToJSON(GS.getQueryString())).trim();
};

GS.templateWithJSON = function (templateText, jsnJSON) {
    'use strict';
    var strWrapperTemplate = '{{ var qs = jo.qs; var jsnData = jo.data; }} ' + templateText;

    return doT.template(strWrapperTemplate)({
        "qs": GS.qryToJSON(GS.getQueryString()),
        "data": jsnJSON
    }).trim();
};


GS.templateHideSubTemplates = function (templateHTML, bolRecord) {
    'use strict';
    var templateElement, strID, arrTemplates, i, len, jsnTemplates, strRet, strStart, strEnd;
    
    if (bolRecord) {
        strStart = '<table><tbody>';
        strEnd = '</tbody></table>';
        templateHTML = (strStart + templateHTML + strEnd);
    }
    
    templateElement = document.createElement('template');
    templateElement.innerHTML = templateHTML;
    
    // temporarily remove templates
    // recursively go through templates whose parents do not have the source attribute
    i = 0;
    arrTemplates = xtag.query(templateElement.content, 'template');
    jsnTemplates = {};
    
    //console.log(arrTemplates.length);
    
    while (arrTemplates.length > 0 && i < 100) {
        //console.log(arrTemplates[0], arrTemplates[0].parentNode);
        // if the current template has a source parent: remove temporarily
        if (arrTemplates[0].parentNode &&
            arrTemplates[0].parentNode.hasAttribute && (arrTemplates[0].parentNode.hasAttribute('src') ||
                                                        arrTemplates[0].parentNode.hasAttribute('source'))) {
            strID = 'UNIqUE_PLaCEhOLDER-' + GS.GUID() + '-UNiQUE_PLaCEhOLdER';
            jsnTemplates[strID] = arrTemplates[0].outerHTML;
            arrTemplates[0].outerHTML = strID;
            
        // else: add to the arrTemplates array
        } else if (arrTemplates[0].content) {
            arrTemplates.push.apply(arrTemplates, xtag.query(arrTemplates[0].content, 'template'));
        }
        
        // remove the current template from the arrTemplates array
        arrTemplates.splice(0, 1);
        
        i += 1;
    }
    
    strRet = decodeHTML(templateElement.innerHTML);
    
    if (bolRecord) {
        strRet = strRet.substring(strStart.length, strRet.length - strEnd.length);
    }
    
    return {'templateHTML': strRet, 'templateData': jsnTemplates}
};

GS.templateShowSubTemplates = function (strRet, jsnTemplate) {
    'use strict';
    var strID;
    
    for (strID in jsnTemplate.templateData) {
        //                                       DO NOT DELETE, this allows single dollar signs to be inside dot notation
        //                                                                  V
        strRet = strRet.replace(new RegExp(strID, 'g'), jsnTemplate.templateData[strID].replace(/\$/g, '$$$$'));
    }
    
    return strRet;
};

GS.templateWithEnvelopeData = function (templateHTML, data, i, len, rowNumberOffset) {
    'use strict';
    return doT.template(ml(function () {/*
        {{##def.snippet:
            {{ var row, row_number, i, len, col_i, col_len
                 , qs = GS.qryToJSON(GS.getQueryString())
                 , rowNumberOffset = (jo.rowNumberOffset || 0);
            
            if (!isNaN(jo.i)) {
                i = jo.i;
                len = (jo.len === undefined || jo.len === null ? jo.i + 1 : jo.len);
                
            } else {
                i = 0;
                len = jo.data.dat.length;
            }
            
            for (; i < len; i += 1) {
                row = {};
                row_number = (i + 1) + rowNumberOffset;
                row.row_number = row_number;
                
                for (col_i = 0, col_len = jo.data.arr_column.length; col_i < col_len; col_i += 1) {
                    if (jo.data.dat[i][col_i] === undefined || jo.data.dat[i][col_i] === null) {
                        row[jo.data.arr_column[col_i]] = '';
                    } else {
                        row[jo.data.arr_column[col_i]] = jo.data.dat[i][col_i];
                    }
                } }}{{# def.record }}
            {{ } }}
        #}}
        {{#def.snippet}}*/console.log;
    }), null, {"record":  templateHTML})({ 'data': data, 'i': i, 'len': len, 'rowNumberOffset': rowNumberOffset });
};





window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('GS.userChangePassword', 'GS.userChangePassword', 'GS.userChangePassword();');
    //registerDesignSnippet('GS.superChangePassword', 'GS.superChangePassword', 'GS.superChangePassword();');
    //registerDesignSnippet('GS.superUserLogin', 'GS.superUserLogin', 'GS.superUserLogin(${0:loggedInCallback});');
    registerDesignSnippet('GS.normalUserLogin', 'GS.normalUserLogin', 'GS.normalUserLogin(${0:loggedInCallback});');
});

(function () {
    function changePassword(strLink, strRank) {
        var templateElement = document.createElement('template');
        
        templateElement.innerHTML = ml(function () {/*
            <gs-page>
                <gs-header><center><h3>Change {{RANK}} Password</h3></center></gs-header>
                <gs-body padded>
                    <div id="pword-error" style="color: #FF0000;"></div>
                    <label for="old-password">Old Password:</label>
                    <gs-text id="old-password" type="password"></gs-text>
                    <label for="new-password">New Password:</label>
                    <gs-text id="new-password" type="password"></gs-text>
                    <label for="new-password-confirm">Confirm New Password:</label>
                    <gs-text id="new-password-confirm" type="password"></gs-text>
                </gs-body>
                <gs-footer>
                    <gs-grid>
                        <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
                        <gs-block><gs-button id="button-change-password" disabled>Change {{RANK}} Password</gs-button></gs-block>
                    </gs-grid>
                </gs-footer>
            </gs-page>
        */}).replace(/\{\{RANK\}\}/gim, strRank);
        
        GS.openDialog(templateElement, function () {
            var dialog = this, keydownHandler;
            
            keydownHandler = function (event) {
                var intKeyCode = event.which || event.keyCode;
                
                if (intKeyCode === 13 &&
                    document.getElementById('old-password').value &&
                    document.getElementById('new-password').value &&
                    document.getElementById('new-password-confirm').value) {
                    GS.triggerEvent(document.getElementById('button-change-password'), 'click');
                    
                } else {
                    if (document.getElementById('old-password').value &&
                        document.getElementById('new-password').value &&
                        document.getElementById('new-password-confirm').value) {
                        document.getElementById('button-change-password').removeAttribute('disabled');
                    } else {
                        document.getElementById('button-change-password').setAttribute('disabled');
                    }
                }
            };
            
            document.getElementById('old-password').addEventListener('keydown', keydownHandler);
            document.getElementById('new-password').addEventListener('keydown', keydownHandler);
            document.getElementById('new-password-confirm').addEventListener('keydown', keydownHandler);
            
            document.getElementById('button-change-password').addEventListener('click', function () {
                var newPassword, parameters;
                
                if (document.getElementById('new-password').value === document.getElementById('new-password-confirm').value) {
                    parameters = 'action=change_pw' +
                                '&password_old=' + encodeURIComponent(document.getElementById('old-password').value) +
                                '&password_new=' + encodeURIComponent(document.getElementById('new-password').value);
                    
                    document.getElementById('old-password').value = '';
                    document.getElementById('new-password').value = '';
                    document.getElementById('new-password-confirm').value = '';
                    
                    GS.ajaxJSON(
                        location.pathname.indexOf('/env/') === 0 ? 
                        '/env/auth' : '/postage/auth', parameters, function (data, error) {
                        if (!error) {
                            GS.pushMessage('Password Successfully Changed', 1000);
                            GS.closeDialog(dialog, 'change');
                        } else {
                            document.getElementById('pword-error').textContent = data.error_text;
                        }
                    });
                } else {
                    document.getElementById('pword-error').textContent = 'New Password Doesn\'t Match Confirm New Password.';
                }
            });
        });
    }
    
    GS.userChangePassword = function () {
        changePassword('env', 'User');
    };
    
    //GS.superChangePassword = function () {
    //    changePassword('postage', 'SUPERUSER');
    //};
})();

// check if the user is logged in as a normal user
// if there is no login dialog create it then open it
GS.normalUserLogin = function (loggedInCallback, strOldError, strDefaultSubDomain) {
    'use strict';
    GS.removeAllLoaders();
    
    if (!window.userLogin) {
        window.userLogin = true;
        
        // this action checks to see if we are logged in as a super user
        // if not, open a login dialog
        GS.ajaxJSON('/env/action_info', '', function (data, error) {
            var templateElement = document.createElement('template');
            
            if (!error && data.dat) {
                if (typeof loggedInCallback === 'function') {
                    loggedInCallback(data.dat, strDefaultSubDomain);
                }
            } else {
                templateElement.innerHTML = ml(function () {/*
                    <gs-page>
                        <gs-header><center><h3>Login</h3></center></gs-header>
                        <gs-body padded>
                            You are not currently logged in, please fill in the login form below.<br /><br />
                            <label for="normal-uname">Username:</label>
                            <gs-text id="normal-uname" autocapitalize="off" autocomplete="off" autocorrect="off"></gs-text>
                            <label for="normal-pword">Password:</label>
                            <gs-text id="normal-pword" type="password"></gs-text>
                            {{ERROR}}
                        </gs-body>
                        <gs-footer>
                            <gs-grid>
                                <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
                                <gs-block><gs-button id="normal-login">Log In</gs-button></gs-block>
                            </gs-grid>
                        </gs-footer>
                    </gs-page>
                */}).replace('{{ERROR}}', (strOldError ? '<br /><div style="color: #FF0000">' + strOldError + '</div>' : ''));
                
                if (GS.getCookie('greyspots_uname')) {
                    xtag.query(templateElement.content, '#normal-uname')[0].setAttribute('value', decodeURIComponent(GS.getCookie('greyspots_uname')));
                    xtag.query(templateElement.content, '#normal-pword')[0].setAttribute('autofocus', '');
                } else {
                    xtag.query(templateElement.content, '#normal-uname')[0].setAttribute('autofocus', '');
                }
                
                GS.openDialog(templateElement, function () {
                    var dialog = this;
                    
                    document.getElementById('normal-pword').addEventListener('keydown', function (event) {
                        var intKeyCode = event.which || event.keyCode;
                        
                        if (intKeyCode === 13) {
                            GS.triggerEvent(document.getElementById('normal-login'), 'click');
                        }
                        //if (this.value) {
                        //    document.getElementById('normal-login').removeAttribute('disabled');
                        //} else {
                        //    document.getElementById('normal-login').setAttribute('disabled', '');
                        //}
                    });
                    
                    //document.getElementById('normal-pword').addEventListener('keyup', function () {
                    //    if (this.value) {
                    //        document.getElementById('normal-login').removeAttribute('disabled');
                    //    } else {
                    //        document.getElementById('normal-login').setAttribute('disabled', '');
                    //    }
                    //});
                    
                    document.getElementById('normal-login').addEventListener('click', function () {
                        var strUserName = document.getElementById('normal-uname').value, strLink;
                        
                        if (document.getElementById('normal-pword').value) {
                            GS.addLoader('log-in', 'Logging In...');
                            
                            GS.ajaxJSON('/env/auth', 'action=login' +
                                                       '&username=' + encodeURIComponent(document.getElementById('normal-uname').value) +
                                                       '&password=' + encodeURIComponent(document.getElementById('normal-pword').value),
                                                       function (data, error) {
                                GS.removeLoader('log-in');
                                GS.closeDialog(dialog, '');
                                window.userLogin = false;
                                
                                if (!error) {
                                    GS.setCookie('greyspots_uname', strUserName, 30);
                                    
                                    if (typeof loggedInCallback === 'function') {
                                        if (window.location.hostname.substring(0, window.location.hostname.indexOf('.')) ===
                                                        strDefaultSubDomain) {
                                            GS.normalUserLogin(loggedInCallback, '', strDefaultSubDomain);
                                        } else {
                                            loggedInCallback(data.dat, strDefaultSubDomain);
                                        }
                                    }
                                    
                                } else {
                                    GS.normalUserLogin(loggedInCallback, data.error_text, strDefaultSubDomain);
                                }
                            });
                        }
                    });
                });
            }
        });
    }
};
//jslint white:true

(function () {
    'use strict';

    // encodeForTabDelimited('asdf\\asdf\\asdf\r\nasdf\r\nasdf\tasdf\tasdf')
    function encodeForTabDelimited(strValue) {
        return  strValue === '\\N' ? strValue :
                strValue.replace(/\\/g, '\\\\') // double up backslashes
                        .replace(/\n/g, '\\n')  // replace newline with the text representation '\n'
                        .replace(/\r/g, '\\r')  // replace carriage return with the text representation '\r'
                        .replace(/\t/g, '\\t')  // replace tab with the text representation '\t'
                        .replace(/^NULL$/g, '\\N');
    }

    GS.bolPreventErrors = false;
    function webSocketConnectionErrorDialog(socket, addinText, retryCallback, cancelCallback) {

        if (!document.getElementById('dialog-from-dialog-ws-conn-error') && GS.bolPreventErrors === false) {
            var templateElement = document.createElement('template');

            GS.removeAllLoaders();

            templateElement.setAttribute('id', 'dialog-ws-conn-error');
            templateElement.setAttribute('data-theme', 'error');
            templateElement.innerHTML = ml(function () {/*
                <gs-page>
                    <gs-header><center><h3>There was an error!</h3></center></gs-header>
                    <gs-body padded>
                        <pre style="white-space: pre-wrap;">There has been an error with the Database connection.{{ADDIN}}</pre>
                    </gs-body>
                    <gs-footer>
                        <gs-grid gutter reflow-at="420">
                            <gs-block><gs-button dialogclose>Try to reconnect</gs-button></gs-block>
                            <gs-block><gs-button dialogclose>Dismiss so I can copy my progress</gs-button></gs-block>
                        </gs-grid>
                    </gs-footer>
                </gs-page>
            */}).replace('{{ADDIN}}', decodeURIComponent((addinText ? '\n\n' + addinText : '')));

            GS.openDialog(templateElement, '', function (event, strAnswer) {
                if (strAnswer === 'Try to reconnect') {
                    GS.closeSocket(GS.envSocket);
                    GS.envSocket = GS.openSocket('env', socket.GSSessionID, socket.notifications);
                } else {
                    GS.bolPreventErrors = true;
                }
            });
        }
    }

    function webSocketNormalizeError(event) {
        var i;
        var len;
        var arrLines;
        var arrLine;
        var strData;
        var jsnRet = {
            'error_title': '',
            'error_text': '',
            'error_detail': '',
            'error_hint': '',
            'error_query': '',
            'error_context': '',
            'error_position': '',
            'error_notice': '',
            'original_data': event
        };

        event = event || {};

        jsnRet.error_text = event.reason || '';

        // if there is message data: parse it
        if (event.data) {
            strData = event.data;

            // strip out messageid
            if (strData.substring(0, strData.indexOf(' ')) === 'messageid') {
                strData = strData.substring(strData.indexOf('\n') + 1);
            }

            // strip out response number
            if (strData.substring(0, strData.indexOf(' ')) === 'responsenumber') {
                strData = strData.substring(strData.indexOf('\n') + 1);
            }

            // strip out response number
            if (strData.substring(0, strData.indexOf(' ')) === 'transactionid') {
                strData = strData.substring(strData.indexOf('\n') + 1);
            }

            // strip out fatal
            if (strData.indexOf('FATAL\n') === 0) {
                strData = strData.substring(strData.indexOf('\n') + 1);
            }

            // strip out "Query failed: "
            if (strData.indexOf('Query failed: ') === 0) {
                strData = strData.substring('Query failed: '.length);
            }

            // save error text in case we dont find any error part labels
            jsnRet.error_text = strData;
            jsnRet.orig_error_text = strData;

            // trim and split on return for parsing
            arrLines = strData.trim().split('\n');

            for (i = 0, len = arrLines.length; i < len; i += 1) {
                arrLine = arrLines[i].split('\t');

                jsnRet[arrLine[0]] = GS.decodeFromTabDelimited(arrLine[1] || '');
            }

            if (!jsnRet.error_text) {
                jsnRet = {
                    'error_text': arrLines[0]
                };
            }
        }

        // get error title and error hint
        if (event.code === 1001) {
            jsnRet.error_title = 'Going Away';
            jsnRet.error_hint = 'The server or client closed the connection because of server shutdown or navigating away from the page.';

        } else if (event.code === 1002) {
            jsnRet.error_title = 'Protocol';
            jsnRet.error_hint = 'The connection was closed because of error related to the protocol used.';

        } else if (event.code === 1003) {
            jsnRet.error_title = 'Unsupported Data';
            jsnRet.error_hint = 'The connection was closed because the data that was received was not it a supported format.';

        } else if (event.code === 1005) {
            jsnRet.error_title = 'No Status Received';
            jsnRet.error_hint = 'The connection was closed because it received an empty status.';

        } else if (event.code === 1006) {
            jsnRet.error_title = 'Abnormal Closure';
            jsnRet.error_hint = 'The connection was closed because of abnormal circumstances.';

        } else if (event.code === 1007) {
            jsnRet.error_title = 'Invalid Payload Data';
            jsnRet.error_hint = 'The connection was closed because the payload type did not match the defined message type.';

        } else if (event.code === 1008) {
            jsnRet.error_title = 'Policy Violation';
            jsnRet.error_hint = 'The connection was closed because policy governing this connection was violated.';

        } else if (event.code === 1009) {
            jsnRet.error_title = 'Message Too Big';
            jsnRet.error_hint = 'The connection was closed because the message was too long for it to proccess.';

        } else if (event.code === 1010) {
            jsnRet.error_title = 'Mandatory Extension';
            jsnRet.error_hint = 'The client closed the connection because the server was supposed to negotiate extension(s) but it did not.';

        } else if (event.code === 1011) {
            jsnRet.error_title = 'Internal Server';
            jsnRet.error_hint = 'The server closed the connection because it could not fulfill the request.';

        } else if (event.code === 1015) {
            jsnRet.error_title = 'TLS handshake';
            jsnRet.error_hint = 'The connection was closed because the handshake failed.';
        }

        //console.log(jsnRet);

        return jsnRet;
    }

    function cleanErrorValue(strValue) {
        strValue = strValue || '';

        if (strValue.indexOf('DB_exec failed:') !== -1) {
            strValue = strValue.replace(/[.\s\S]*DB_exec\ failed:/mi, '');
        }

        if (strValue.indexOf('Query failed:') !== -1) {
            strValue = strValue.replace(/[.\s\S]*Query\ failed:/mi, '');
        }

        if (strValue.indexOf('FATAL') !== -1) {
            strValue = strValue.replace(/[.\s\S]*FATAL/mi, '');
        }

        strValue = strValue
                        .replace(/\\n/gi, '\n')
                        .replace(/\\t/gi, '\t')
                        .replace(/\[.*\]/gi, '')
                        .replace(/\([0-9]*\)/gi, '');

        return GS.trim(strValue.trim(), '"');
    }

    function errorJSONToHTML(errorJSON) {
        //console.log(errorJSON);
        return '<pre style="word-break: break-all; white-space: pre-wrap;">' +
                    (errorJSON.error_title ?
                        'There was ' +
                            (
                                ['A', 'E', 'I', 'O', 'U']
                                    .indexOf(errorJSON.error_title[0].toUpperCase()) === -1
                                        ? 'a'
                                        : 'an'
                            ) +
                            ' "' + encodeHTML(errorJSON.error_title) + '" error:' :
                        'There was an error:') +
                        (
                            errorJSON.error_text     ? '<br /><br />' + encodeHTML(errorJSON.error_text)
                            :   (errorJSON.error_hint     ? '<br /><br />HINT: ' + encodeHTML(errorJSON.error_hint) : '') +
                                (errorJSON.error_detail   ? '<br /><br />DETAIL: ' + encodeHTML(errorJSON.error_detail) : '') +
                                (errorJSON.error_query    ? '<br /><br />QUERY: ' + encodeHTML(errorJSON.error_query) : '') +
                                (errorJSON.error_position ? '<br /><br />ERROR POSITION: ' + encodeHTML(errorJSON.error_position) : '') +
                                (errorJSON.error_context  ? '<br /><br />CONTEXT: ' + encodeHTML(errorJSON.error_context) : '') +
                                (errorJSON.error_notice   ? '<br /><br /><br />' + encodeHTML(errorJSON.error_notice) : '')
                        ) +
                '</pre>';
    }

    GS.webSocketErrorDialog = function (jsnError, tryAgainCallback, cancelCallback) {
        if (GS.bolPreventErrors === false) {
            var templateElement = document.createElement('template'), strHTML, jsnErrorClean;

            jsnErrorClean = {};

            jsnErrorClean.error_text     = cleanErrorValue(jsnError.error_text);
            jsnErrorClean.error_hint     = cleanErrorValue(jsnError.error_hint);
            jsnErrorClean.error_detail   = cleanErrorValue(jsnError.error_detail);
            jsnErrorClean.error_query    = cleanErrorValue(jsnError.error_query);
            jsnErrorClean.error_position = cleanErrorValue(jsnError.error_position);
            jsnErrorClean.error_context  = cleanErrorValue(jsnError.error_context);
            jsnErrorClean.error_notice   = cleanErrorValue(jsnError.error_notice);

            templateElement.setAttribute('data-theme', 'error');
            strHTML = ml(function () {/*
                <gs-page>
                    <gs-header><center><h3>There was an error!</h3></center></gs-header>
                    <gs-body padded>
                        {{HTML}}
                        <br />
                        <gs-button class="error-button-show-full-text">Show Full Error Text</gs-button>
                    </gs-body>
                    <gs-footer>{{BUTTONS}}</gs-footer>
                </gs-page>
            */}).replace('{{HTML}}', errorJSONToHTML(jsnErrorClean));

            var openFunction = function () {
                xtag.query(this, '.error-button-show-full-text')[0].addEventListener('click', function () {
                    var templateElement = document.createElement('template');

                    templateElement.innerHTML = ml(function () {/*
                        <gs-page>
                            <gs-header><center><h3>Full Error Text</h3></center></gs-header>
                            <gs-body padded>
                                {{HTML}}
                            </gs-body>
                            <gs-footer><gs-button dialogclose>Done</gs-button></gs-footer>
                        </gs-page>
                    */}).replace('{{HTML}}', errorJSONToHTML(jsnError));

                    GS.openDialog(templateElement);
                });
            };

            if (typeof tryAgainCallback === 'function') {
                templateElement.innerHTML =
                    strHTML.replace(
                        '{{BUTTONS}}',
                        '<gs-grid>' +
                        '    <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>' +
                        '    <gs-block><gs-button dialogclose listen-for-return>Try Again</gs-button></gs-block>' +
                        '</gs-grid>'
                    );

                GS.openDialog(templateElement, openFunction, function (event, strAnswer) {
                    if (strAnswer === 'Try Again') {
                        tryAgainCallback(strAnswer);
                    } else {
                        if (typeof cancelCallback === 'function') {
                            cancelCallback(strAnswer);
                        }
                    }
                });

            } else {
                templateElement.innerHTML = strHTML.replace('{{BUTTONS}}', '<gs-button dialogclose listen-for-return>Ok</gs-button>');
                GS.openDialog(templateElement, openFunction);
            }
        }
    };

    GS.websockets = new Array();

    GS.closeAllSockets = function () {
        var i, len = GS.websockets.length;
        for (i = 0;i < len;i++) {
            GS.closeSocket(GS.websockets[i]);
        }
    };

    var sequence = 0, jsnMessages = {}, arrWaitingCalls = [];
    GS.openSocket = function (strLink, relinkSessionID, relinkSessionNotifications, socketname) {
        var strLoc = window.location.toString(),
            intUrlStart = strLoc.indexOf('/postage/') + 9,
            strConn = strLoc.substring(intUrlStart, strLoc.substring(intUrlStart).indexOf('/') + intUrlStart),
            strURL = '';

        if (strLoc.indexOf('/postage/') >= 0) {
            strURL =    (window.location.protocol.toLowerCase().indexOf('https') === 0 ? 'wss' : 'ws') +
                        '://' + (window.location.host || window.location.hostname) + '/postage/' + strConn + '/' + strLink +
                        (relinkSessionID ? '?sessionid=' + relinkSessionID : '');
        } else {
            strURL =    (window.location.protocol.toLowerCase().indexOf('https') === 0 ? 'wss' : 'ws') +
                        '://' + (window.location.host || window.location.hostname) + '/' + strLink +
                        (relinkSessionID ? '?sessionid=' + relinkSessionID : '');
        }

        var socket = new WebSocket(strURL);
        socket.isGSSocket = true;
        socket.stayClosed = false;
        if (socketname) {
            GS.websockets[socketname] = socket;
        }

        GS.websockets.push(socket);

        if (relinkSessionID) {
            socket.GSSessionID = relinkSessionID;
            socket.oldSessionID = relinkSessionID;
            socket.greyspotsProvidedSession = false;
        }
        if (relinkSessionNotifications) {
            socket.notifications = relinkSessionNotifications;
        } else {
            socket.notifications = [];
        }
        socket.onmessage = function (event) {
            var message = event.data;
            var messageID;
            var responseNumber;
            var key;
            var strError;
            var arrLines;
            var i;
            var len;
            var jsnMessage;
            var startFrom;
            var bolDuplicate;

            if (typeof (message) === 'object') {
                //window.binaryTestTEST = message;
                //console.log(message);
                var buf = message;
                message = String.fromCharCode.apply(null, new Uint8Array(buf));
                //console.log(buf);
                //console.log(message);
            }

            // if sessionid
            if (message.indexOf('sessionid = ') === 0) {
                socket.GSSessionID = message.substring('sessionid = '.length, message.indexOf('\n'));
                socket.greyspotsProvidedSession = true;
                GS.triggerEvent(window, 'socket-connect', {"socket": socket});

                for (key in jsnMessages) {
                    jsnMessage = jsnMessages[key];

                    if (
                        jsnMessage &&
                        (
                            jsnMessage.session === socket.GSSessionID ||
                            jsnMessage.session === socket.oldSessionID
                        ) &&
                        jsnMessage.bolFinished === false
                    ) {
                        jsnMessage.session = socket.GSSessionID;

                        startFrom = 1;
                        for (i = 0, len = jsnMessage.arrResponseNumbers.length; i < len; i += 1) {
                            // if there is a difference between the current response number and the
                            //      startFrom: stop looping because startFrom now holds the number that we want
                            if (startFrom !== jsnMessage.arrResponseNumbers[i]) {
                                break;
                            }
                            startFrom += 1;
                        }

                        GS.requestFromSocket(socket, 'SEND FROM\t' + startFrom, '', jsnMessage.id);
                    }
                }

                for (i = 0, len = arrWaitingCalls.length; i < len; i += 1) {
                    arrWaitingCalls[0]();
                    arrWaitingCalls.splice(0, 1);
                }

            // else
            } else {
                messageID = message.substring('messageid = '.length, message.indexOf('\n'));
                message = message.substring(message.indexOf('\n') + 1);
                bolDuplicate = false;

                jsnMessage = jsnMessages[messageID];

                // if there is a message entry for this message ID
                if (jsnMessage) {
                    arrLines = message.split('\n');

                    // if there is no response number: assume this is the last message and mark the message as finished
                    if (message.indexOf('responsenumber = ') === -1 ||
                        (
                            message.indexOf('responsenumber = ') === 0 &&
                            (
                                arrLines[1] === 'TRANSACTION COMPLETED' ||
                                arrLines[2] === 'OK'
                            )
                        )) {
                        jsnMessage.bolFinished = true;
                    }

                    // if there is a response number
                    if (message.indexOf('responsenumber = ') === 0) {
                        // get message number
                        responseNumber = message.substring('responsenumber = '.length, message.indexOf('\n'));
                        message = message.substring(message.indexOf('\n') + 1);

                        // append message number and message content to arrays
                        if (jsnMessage.arrResponseNumbers.indexOf(parseInt(responseNumber, 10)) === -1) {
                            jsnMessage.arrResponseNumbers.push(parseInt(responseNumber, 10));
                            jsnMessage.arrResponses.push(message);
                        } else {
                            bolDuplicate = true;
                        }

                        //console.log(relinkSessionID, jsnMessage.arrResponseNumbers, responseNumber);

                        // send confirm signal
                        GS.requestFromSocket(socket, 'CONFIRM\t' + responseNumber, '', messageID);
                    }

                    // ERROR CHECK
                    arrLines = message.split('\n');

                    // if there is a transactionid: look at the second line
                    if (arrLines[0].indexOf('transactionid') === 0 && arrLines[1] === 'FATAL') {
                        strError = 'error';
                        message = message.substring(message.indexOf('\n') + 1);
                        message = message.substring(message.indexOf('\n') + 1);
                        message = arrLines[0] + '\n' + message;

                    // else: check the first line
                    } else if (arrLines[0] === 'FATAL') {
                        strError = 'error';
                        message = message.substring(message.indexOf('\n') + 1);
                    }

                    // if transaction complete: clear message arrays and mark as finised
                    if (message === 'TRANSACTION COMPLETED') { // || message === 'EMPTY\n\\.'
                        jsnMessage.arrResponseNumbers = [];
                        jsnMessage.arrResponses = [];
                        jsnMessage.bolFinished = true;
                    }

                    // if there was a FATAL: mark as finished and apply callback
                    if (strError) {
                        jsnMessage.bolFinished = true;
                        jsnMessage.callback.apply(null, [message, strError, webSocketNormalizeError(event)]);

                    // else: call callback with message
                    } else {
                        // don't callback with duplicate data packages
                        if (!bolDuplicate) {
                            jsnMessage.callback.apply(null, [message]);
                        }
                    }

                    if (jsnMessage.bolFinished === true) {
                        delete jsnMessages[messageID];
                    }

                // else if the messageID is 'NULL': notification from the server
                } else if (messageID === 'NULL') {
                    socket.notifications.push(message);
                    GS.triggerEvent(window, 'notification', {'socket': socket, 'message': message});
                }
            }
        };

        socket.onopen = function (event) {

        };

        socket.onerror = function (event) {
            var i, len;

            console.warn('SOCKET ERROR', event);
            socket.bolError = true;
            //socket.stayClosed = true;

            //for (i = 0, len = arrWaitingCalls.length; i < len; i += 1) {
            //    arrWaitingCalls[0]();
            //    arrWaitingCalls.splice(0, 1);
            //}
        };

        socket.onclose = function (event) {
            console.warn('SOCKET CLOSING', socket.stayClosed, socket.bolError, event);

            // error closure dialog
            if (socket.stayClosed && socket.bolError && arrWaitingCalls.length > 0) {
                // abnormal closure
                if (event.code === 1006) {
                    webSocketConnectionErrorDialog(socket, 'The connection to the database has been closed. We cannot display the reasons for this closure because the browser does not give us access to those details, please check the server logs for the error details.');

                // protocol error
                } else if (event.code === 1002) {
                    webSocketConnectionErrorDialog(socket, 'The connection to the database has been closed. Either the server or the browser has closed the connection because of a Websocket Protocol error.');

                // type error
                } else if (event.code === 1003) {
                    webSocketConnectionErrorDialog(socket, 'The connection to the database has been closed. Either the server or the browser has closed the connection because of it was sent a data type it could not understand.');

                } else {
                    webSocketConnectionErrorDialog(socket, 'The connection to the database has been closed. The cause of this is unknown.');
                }
            }

            if (!socket.stayClosed) {
                setTimeout(function() {
                    console.warn('ATTEMPTING SOCKET RE-OPEN', socket);
                    var event = GS.triggerEvent(window, 'socket-reconnect', {"socket": socket});
                    var strURL;
                    if (! event.defaultPrevented) {
                        if (socketname) {
                            strURL = GS.websockets[socketname].url;
                            GS.closeSocket(GS.websockets[socketname]);
                            GS.websockets[socketname] = GS.openSocket(strURL, GS.websockets[socketname].GSSessionID, GS.websockets[socketname].notifications);

                        } else {
                            strURL = GS.envSocket.url;
                            GS.closeSocket(GS.envSocket);
                            GS.envSocket = GS.openSocket(strURL, GS.envSocket.GSSessionID, GS.envSocket.notifications);
                        }
                    }
                }, 1000);
            } else {
                if (socket.bolError) {
                    console.warn('SOCKET NOT RE-OPENING DUE TO ERROR');
                } else {
                    console.warn('SOCKET NOT RE-OPENING DUE TO MANUAL CLOSE');
                }
            }
        };

        return socket;
    };

    GS.requestFromSocket = function (socket, strMessage, callback, forceMessageID) {
        var oldOnOpen, messageID;

        if (!socket || socket.readyState === socket.CLOSED) {
            if (!GS.envSocket || GS.envSocket.readyState === socket.CLOSED) {
                //console.trace('ATTEMPTING SOCKET RE-OPEN 2');
                GS.envSocket = GS.openSocket('env');
            }
            socket = GS.envSocket;
        }

        // if the socket is open: register callback and send request
        if (
            socket.readyState === socket.OPEN &&
            socket.GSSessionID &&
            // we don't want to send a request until greyspots has sent us a session id
            socket.greyspotsProvidedSession
        ) {
            if (!forceMessageID) {
                sequence += 1;
                messageID = socket.GSSessionID + '_' + sequence;
                jsnMessages[messageID] = {
                    'id': messageID,
                    'session': socket.GSSessionID,
                    'callback': callback,
                    'arrResponseNumbers': [],
                    'arrResponses': [],
                    'bolFinished': false
                };

            } else {
                messageID = forceMessageID;
            }

            if (typeof (strMessage) === 'object') {
                jsnMessages[messageID].parameters = new Blob(['messageid = ' + messageID + '\n', strMessage], {type: 'application/x-binary'});
            } else {
                jsnMessages[messageID].parameters = 'messageid = ' + messageID + '\n' + strMessage;
            }
            socket.send(jsnMessages[messageID].parameters);
            //console.log('SOCKET MESSAGE SENT                   ', 'messageid = ' + sequence);// + '\n' + strMessage);

            return messageID;

        // if the socket is connecting: bind socket onopen to call this funtion again
        } else if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {
            //console.log('SOCKET REQUEST WHILE CONNECTING       ');

            arrWaitingCalls.push(function () {
                GS.requestFromSocket(socket, strMessage, callback);
            });

        // if the socket is closed: error
        } else if (socket.readyState === socket.CLOSED) {
            //console.log('SOCKET REQUEST WHILE CLOSED           ');
            callback.apply(null, ['Socket Is Closed', 'error', webSocketNormalizeError({'reason': 'Socket Is Closed'})]);

        // if the socket is closing: error
        } else if (socket.readyState === socket.CLOSING) {
            //console.log('SOCKET REQUEST WHILE CLOSING          ');
            callback.apply(null, ['Socket Is Closing', 'error', webSocketNormalizeError({'reason': 'Socket Is Closing'})]);
        }
    };


    GS.requestActionFromSocket = function (socket, strSchema, strObject, strArgs, finalCallback) {
        var strMessage = 'ACTION\t' + encodeForTabDelimited(strSchema) + '\t' + encodeForTabDelimited(strObject) +
                            '\t' + encodeForTabDelimited(strArgs) + '\n',
            intResponse = 0, strRet;

        //console.log(strMessage);

        GS.requestFromSocket(socket, strMessage, function (data, error, errorData) {
            var arrLines, i, len;
            if (!error) {
                if (intResponse === 0) {
                    strRet = data;

                } else {
                    finalCallback(strRet, error);
                }

            } else {
                finalCallback(errorData, error);
            }
            intResponse += 1;
        });
    };

    // abstraction function for ease of use of the RAW format
    GS.requestRawFromSocket = function (socket, strQuery, callback, bolAutocommit) {
        var intResponsePart = 0, intQueryNumber = 0, intCallbackNumber = 0, intCallbackNumberThisQuery = 0
          , intResponseNumberThisQuery = 0, arrMessages, arrColumnNames, arrColumnTypes
          , arrStart, dteStart, arrEnd, dteEnd, intRows;

        bolAutocommit = bolAutocommit !== undefined ? bolAutocommit : true;
        return GS.requestFromSocket(socket, 'RAW' + (!bolAutocommit ? '\tDISABLE AUTOCOMMIT\n' : '\n') + strQuery, function (data, error, errorData) {
            var arrRecords, arrLines, i, len, strMode;

            if (!error) {
                if (intResponseNumberThisQuery === 0) {
                    // clear variables
                    strQuery = '';
                    arrMessages = [];
                    arrColumnNames = [];
                    arrColumnTypes = [];
                }

                // if QUERY is found: reset response part to 0
                if (data.indexOf('QUERY\n') === 0) {
                    //console.log('Per Query Reset');
                    intResponsePart = 0;
                    intCallbackNumberThisQuery = 0;
                }

                // if first line is 'Rows Affected': add one to intResponsePart
                if (data.indexOf('Rows Affected\n') === 0 || data === 'EMPTY' || data === 'TRANSACTION COMPLETED' || data === 'TRANSACTION OPEN') {
                    intResponsePart += 1;
                }

                //console.log('1***', data);
                //console.log(intResponsePart, data);

                // response part 0 is:
                //      strQuery
                //      arrMessages
                //      arrColumnNames
                //      arrColumnTypes
                if (intResponsePart === 0) {
                    //console.log('2***');
                    // split lines
                    arrLines = data.split('\n');

                    // loop through lines
                    for (i = 0, len = arrLines.length; i < len; i += 1) {
                        // if mode line: set mode
                        if (arrLines[i].indexOf('QUERY\t') === 0 ||
                            arrLines[i].indexOf('START\t') === 0 ||
                            arrLines[i].indexOf('END\t') === 0 ||
                            arrLines[i].indexOf('ROWS\t') === 0 ||
                            arrLines[i].indexOf('DEBUG\t') === 0 ||
                            arrLines[i].indexOf('LOG\t') === 0 ||
                            arrLines[i].indexOf('INFO\t') === 0 ||
                            arrLines[i].indexOf('NOTICE\t') === 0 ||
                            arrLines[i].indexOf('WARNING\t') === 0 ||
                            arrLines[i] === 'COLUMNS') {

                            if (arrLines[i] === 'COLUMNS') {
                                strMode = arrLines[i];
                            } else {
                                strMode = arrLines[i].substring(0, arrLines[i].indexOf('\t'));
                            }
                        }

                        //console.log(strMode, arrLines[i]);

                        // if mode is QUERY: save query
                        if (strMode === 'QUERY') {
                            strQuery = GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1));
                            //console.log(arrLines[i], strQuery);

                        // if mode is START: save start
                        } else if (strMode === 'START') {
                            arrStart = GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1)).split('\t');
                            dteStart = new Date(arrStart[0] + ' ' + arrStart[1] + ' GMT');
                            if (arrStart[2]) {
                                dteStart.setMilliseconds(parseInt(arrStart[2], 10) / 1000);
                            }
                            //console.log(strStart, dteStart);

                        // if mode is END: save end
                        } else if (strMode === 'END') {
                            arrEnd = GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1)).split('\t');
                            dteEnd = new Date(arrEnd[0] + ' ' + arrEnd[1] + ' GMT');
                            if (arrEnd[2]) {
                                dteEnd.setMilliseconds(parseInt(arrEnd[2], 10) / 1000);
                            }
                            //console.log(strEnd, dteEnd);

                        // if mode is ROWS: save total rows
                        } else if (strMode === 'ROWS') {
                            intRows = parseInt(GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1)), 10);

                        // if mode is DEBUG: add DEBUG to array
                        } else if (strMode === 'DEBUG') {
                            arrMessages.push({
                                'level': 'DEBUG',
                                'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                            });

                        // if mode is LOG: add LOG to array
                        } else if (strMode === 'LOG') {
                            arrMessages.push({
                                'level': 'LOG',
                                'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                            });

                        // if mode is INFO: add INFO to array
                        } else if (strMode === 'INFO') {
                            arrMessages.push({
                                'level': 'INFO',
                                'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                            });

                        // if mode is NOTICE: add NOTICE to array
                        } else if (strMode === 'NOTICE') {
                            arrMessages.push({
                                'level': 'NOTICE',
                                'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                            });

                        // if mode is WARNING: add WARNING to array
                        } else if (strMode === 'WARNING') {
                            arrMessages.push({
                                'level': 'WARNING',
                                'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                            });

                        // if mode is COLUMNS: get COLUMNS
                        } else if (strMode === 'COLUMNS') {
                            arrColumnNames = arrLines[i + 1].split('\t');
                            arrColumnTypes = arrLines[i + 2].split('\t');
                            intResponsePart += 1;
                            break;
                        }
                    }

                } else if (intResponsePart >= 1) {
                    //console.log(intQueryNumber, intCallbackNumber, intCallbackNumberThisQuery,
                    //            strQuery, arrMessages, arrColumnNames, arrColumnTypes, data);
                    //console.log('3***');
                    if (typeof callback === 'function') {
                        //console.log('4*** CALLBACK');
                        callback({
                            'intQueryNumber': intQueryNumber,
                            'intCallbackNumber': intCallbackNumber,
                            'intCallbackNumberThisQuery': intCallbackNumberThisQuery,
                            'strQuery': strQuery,
                            'dteStart': dteStart,
                            'dteEnd': dteEnd,
                            'intRows': intRows,
                            'arrMessages': arrMessages,
                            'arrColumnNames': arrColumnNames,
                            'arrColumnTypes': arrColumnTypes,
                            'strMessage': (data !== 'TRANSACTION COMPLETED' || data === 'TRANSACTION OPEN' ? data : ''),
                            'bolLastMessage': (data === 'TRANSACTION COMPLETED' || data === 'TRANSACTION OPEN'),
							'bolTransactionOpen': (data === 'TRANSACTION OPEN')
                        }, error);

                        intCallbackNumber += 1;
                        intCallbackNumberThisQuery += 1;
                    }
                }

                intResponseNumberThisQuery += 1;

                if (data === '\\.' || data.indexOf('Rows Affected\n') === 0) {
                    intQueryNumber += 1;
                    intCallbackNumberThisQuery = 0;
                    intResponsePart = 0;
                    intResponseNumberThisQuery = 0;
                }

            } else {
                // if QUERY is found: reset response part to 0
                if (data.indexOf('QUERY\n') === 0) {
                    //console.log('Per Query Reset');
                    intResponsePart = 0;
                    intCallbackNumberThisQuery = 0;
                }

                if (intResponsePart === 0) {
                    //console.log('2***');
                    // split lines
                    arrLines = data.split('\n');

                    // loop through lines
                    for (i = 0, len = arrLines.length; i < len; i += 1) {
                        // if mode line: set mode
                        if (arrLines[i].indexOf('QUERY\t') === 0 ||
                            arrLines[i].indexOf('START\t') === 0 ||
                            arrLines[i].indexOf('END\t') === 0 ||
                            arrLines[i].indexOf('ROWS\t') === 0 ||
                            arrLines[i].indexOf('DEBUG\t') === 0 ||
                            arrLines[i].indexOf('LOG\t') === 0 ||
                            arrLines[i].indexOf('INFO\t') === 0 ||
                            arrLines[i].indexOf('NOTICE\t') === 0 ||
                            arrLines[i].indexOf('WARNING\t') === 0 ||
                            arrLines[i] === 'COLUMNS') {

                            if (arrLines[i] === 'COLUMNS') {
                                strMode = arrLines[i];
                            } else {
                                strMode = arrLines[i].substring(0, arrLines[i].indexOf('\t'));
                            }
                        }

                        //console.log(strMode, arrLines[i]);

                        // if mode is QUERY: save query
                        if (strMode === 'QUERY') {
                            strQuery = GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1));
                            //console.log(arrLines[i], strQuery);

                        // if mode is COLUMNS: get COLUMNS
                        } else if (strMode === 'COLUMNS') {
                            break;
                        }
                    }
                }

                errorData.strQuery = strQuery;
                errorData.arrMessages = arrMessages
                if (typeof callback === 'function') {
                    callback(errorData, error);
                }
            }
        });
    };

    GS.requestSelectFromSocket = function (socket, strSchema, strObject, strReturnCols, strWhere, strOrd, strLimit, strOffset, finalCallback) {
        var strMessage = 'SELECT\t' + (!strSchema ? '' : encodeForTabDelimited(strSchema) + '\t') + encodeForTabDelimited(strObject) +
                            '\nRETURN\t' + strReturnCols + '\n\n' +
                            'where\t' + (strOrd ? 'order by\t' : '') + 'limit\toffset\n' +
                            encodeForTabDelimited(strWhere || '1=1') + '\t' + (strOrd ? encodeForTabDelimited(strOrd) + '\t' : '') +
                            encodeForTabDelimited(strLimit || 'ALL') + '\t' + encodeForTabDelimited(strOffset || '0'),
            intResponse = 0, intCallback = 0, arrColumnNames, arrColumnTypes, arrDecodedColumnNames, arrDecodedColumnTypes;

        //console.log(strMessage);

        GS.requestFromSocket(socket, strMessage, function (data, error, errorData) {
            var arrLines, i, len;
            if (!error) {
                if (intResponse === 0) {
                    arrLines = data.split('\n');
                    arrColumnNames = arrLines[0].split('\t');
                    arrColumnTypes = arrLines[1].split('\t');
                    arrDecodedColumnNames = [];
                    arrDecodedColumnTypes = [];

                    for (i = 0, len = arrColumnNames.length; i < len; i += 1) {
                        arrDecodedColumnNames.push(GS.decodeFromTabDelimited(arrColumnNames[i]));
                    }

                    for (i = 0, len = arrColumnTypes.length; i < len; i += 1) {
                        arrDecodedColumnTypes.push(GS.decodeFromTabDelimited(arrColumnTypes[i]));
                    }

                } else {
                    finalCallback({
                        'arrColumnNames': arrColumnNames,
                        'arrColumnTypes': arrColumnTypes,
                        'arrDecodedColumnNames': arrDecodedColumnNames,
                        'arrDecodedColumnTypes': arrDecodedColumnTypes,
                        'intCallback': intCallback,
                        'strMessage': data
                    }, error);
                    intCallback += 1;
                }

            } else {
                finalCallback(errorData, error);
            }
            intResponse += 1;
        });
    };

    GS.requestArbitrarySelectFromSocket = function (socket, strSQL, strWhere, strOrd, strLimit, strOffset, finalCallback) {
        var strMessage = (
            'SELECT\t' + encodeForTabDelimited(strSQL) +
            '\nRETURN\t*\n\n' +
            'where\t' +
            (strOrd ? 'order by\t' : '') +
            'limit\t' +
            'offset\n' +
            encodeForTabDelimited(strWhere || '1=1') + '\t' +
            (strOrd ? encodeForTabDelimited(strOrd) + '\t' : '') +
            encodeForTabDelimited(strLimit || 'ALL') + '\t' +
            encodeForTabDelimited(strOffset || '0')
        );
        var intResponse = 0;
        var intCallback = 0;
        var arrColumnNames;
        var arrColumnTypes;
        var arrDecodedColumnNames;
        var arrDecodedColumnTypes;

        //console.log(strMessage);

        GS.requestFromSocket(socket, strMessage, function (data, error, errorData) {
            var arrLines, i, len;
            if (!error) {
                if (intResponse === 0) {
                    arrLines = data.split('\n');
                    arrColumnNames = arrLines[0].split('\t');
                    arrColumnTypes = arrLines[1].split('\t');
                    arrDecodedColumnNames = [];
                    arrDecodedColumnTypes = [];

                    for (i = 0, len = arrColumnNames.length; i < len; i += 1) {
                        arrDecodedColumnNames.push(GS.decodeFromTabDelimited(arrColumnNames[i]));
                    }

                    for (i = 0, len = arrColumnTypes.length; i < len; i += 1) {
                        arrDecodedColumnTypes.push(GS.decodeFromTabDelimited(arrColumnTypes[i]));
                    }

                } else {
                    finalCallback({
                        'arrColumnNames': arrColumnNames,
                        'arrColumnTypes': arrColumnTypes,
                        'arrDecodedColumnNames': arrDecodedColumnNames,
                        'arrDecodedColumnTypes': arrDecodedColumnTypes,
                        'intCallback': intCallback,
                        'strMessage': data
                    }, error);
                    intCallback += 1;
                }

            } else {
                finalCallback(errorData, error);
            }
            intResponse += 1;
        });
    };

    /*
        INSERT	test	rmultiple_pk_test
        RETURN	id1	id2	id3	page_name_pk	id4	test1	test2	test3
        PK	id1	id2	id3	page_name_pk	id4
        SEQ	test.seq1	test.seq2

        page_name_pk	test1	test2	test3
        page_name_pk1	test1	test2	test3
        page_name_pk2	test1	test2	test3
        page_name_pk3	test1	test2	test3
        page_name_pk4	test1	test2	test3



        If a column is being inserted, then the SEQ entry for it needs to be empty
    */
    GS.requestInsertFromSocket = function (socket, strSchema, strObject, strReturnCols, strPkCols, strSeqCols, insertData, beginCallback, confirmCallback, finalCallback) {
        var strMessage = 'INSERT\t' + encodeForTabDelimited(strSchema) + '\t' + encodeForTabDelimited(strObject) +
                         '\nRETURN\t' + strReturnCols +
                         (strPkCols ? '\nPK\t' + strPkCols : '') +
                         (strPkCols ? '\nSEQ\t' + strSeqCols : '') +
                         '\n\n' + insertData;

        //console.log(strMessage);

        GS.requestBegin(socket, function (data, error) {
            var transactionID;

            if (!error) {
                transactionID = data;
                if (typeof beginCallback === 'function') { beginCallback(data, error); }

                GS.requestFromSocket(socket, 'transactionid = ' + transactionID + '\n' + strMessage, function (data, error, errorData) {
                    var commitFunction, rollbackFunction;

                    if (!error) {
                        data = data.substring(data.indexOf('\n') + 1); // transactionid
                        //data = data.substring(data.indexOf('\n') + 1); // responsenumber
                    }

                    //console.log('INSERT DATA:', data);
                    //console.log('INSERT TRANSID:', transactionID);

                    commitFunction = function () {
                        GS.requestCommit(socket, transactionID, function (data, error) {
                            if (!error) { data = data.substring(data.indexOf('\n') + 1); }

                            finalCallback('COMMIT', data, error);
                        });
                    };
                    rollbackFunction = function () {
                        GS.requestRollback(socket, transactionID, function (data, error) {
                            if (!error) { data = data.substring(data.indexOf('\n') + 1); }

                            finalCallback('ROLLBACK', data, error);
                        });
                    };

                    if (!error) {
                        confirmCallback(data, error, transactionID, commitFunction, rollbackFunction);
                    } else {
                        confirmCallback(errorData, error, transactionID, commitFunction, rollbackFunction);
                    }
                });

            } else {
                if (typeof beginCallback === 'function') { beginCallback(data, error); }
            }
        });
    };


    GS.requestUpdateFromSocket = function (socket, strSchema, strObject, strReturnCols, strHashCols, updateData, beginCallback, confirmCallback, finalCallback) {
        var strMessage = 'UPDATE\t' + encodeForTabDelimited(strSchema) + '\t' + encodeForTabDelimited(strObject) +
                         '\nRETURN\t' + strReturnCols +
                         (strHashCols ? '\nHASH\t' + strHashCols : '') +
                         '\n\n' + updateData;

        //console.log(strMessage);

        GS.requestBegin(socket, function (data, error) {
            var transactionID;

            if (!error) {
                transactionID = data;
                if (typeof beginCallback === 'function') { beginCallback(data, error); }

                GS.requestFromSocket(socket, 'transactionid = ' + transactionID + '\n' + strMessage, function (data, error, errorData) {
                    var commitFunction, rollbackFunction;

                    if (!error) {
                        data = data.substring(data.indexOf('\n') + 1); // transactionid
                        //data = data.substring(data.indexOf('\n') + 1); // responsenumber
                    }

                    commitFunction = function () {
                        GS.requestCommit(socket, transactionID, function (data, error) {
                            if (!error) { data = data.substring(data.indexOf('\n') + 1); }

                            finalCallback('COMMIT', data, error);
                        });
                    };
                    rollbackFunction = function () {
                        GS.requestRollback(socket, transactionID, function (data, error) {
                            if (!error) { data = data.substring(data.indexOf('\n') + 1); }

                            finalCallback('ROLLBACK', data, error);
                        });
                    };

                    if (!error) {
                        confirmCallback(data, error, transactionID, commitFunction, rollbackFunction);
                    } else {
                        confirmCallback(errorData, error, transactionID, commitFunction, rollbackFunction);
                    }
                });

            } else {
                if (typeof beginCallback === 'function') { beginCallback(data, error); }
            }
        });
    };

    GS.requestDeleteFromSocket = function (socket, strSchema, strObject, strHashCols, deleteData, beginCallback, confirmCallback, finalCallback) {
        var strMessage = 'DELETE\t' + encodeForTabDelimited(strSchema) + '\t' + encodeForTabDelimited(strObject) +
                         (strHashCols ? '\nHASH\t' + strHashCols : '') + '\n\n' +
                         deleteData;

        //console.log(strMessage);

        GS.requestBegin(socket, function (data, error) {
            var transactionID;

            if (!error) {
                transactionID = data;
                if (typeof beginCallback === 'function') { beginCallback(data, error); }

                GS.requestFromSocket(socket, 'transactionid = ' + transactionID + '\n' + strMessage, function (data, error, errorData) {
                    var commitFunction, rollbackFunction;

                    if (!error) {
                        data = data.substring(data.indexOf('\n') + 1); // transactionid
                        //data = data.substring(data.indexOf('\n') + 1); // responsenumber
                    }

                    commitFunction = function () {
                        GS.requestCommit(socket, transactionID, function (data, error) {
                            if (!error) { data = data.substring(data.indexOf('\n') + 1); }

                            finalCallback('COMMIT', data, error);
                        });
                    };
                    rollbackFunction = function () {
                        GS.requestRollback(socket, transactionID, function (data, error) {
                            if (!error) { data = data.substring(data.indexOf('\n') + 1); }

                            finalCallback('ROLLBACK', data, error);
                        });
                    };

                    if (!error) {
                        confirmCallback(data, error, transactionID, commitFunction, rollbackFunction);
                    } else {
                        confirmCallback(errorData, error, transactionID, commitFunction, rollbackFunction);
                    }
                });

            } else {
                if (typeof beginCallback === 'function') { beginCallback(data, error); }
            }
        });
    };

    GS.requestBegin = function (socket, callback) {
        GS.requestFromSocket(socket, 'BEGIN', function (data, error, errorData) {
            var transactionID;

            if (typeof callback === 'function') {
                if (!error) {
                    transactionID = data.substring('transactionid = '.length, data.indexOf('\n'));
                    callback(transactionID, error);
                } else {
                    callback(errorData, error);
                }
            }
        });
    };

    GS.requestRollback = function (socket, transactionID, callback) {
        GS.requestFromSocket(socket, 'transactionid = ' + transactionID + '\nROLLBACK', function (data, error, errorData) {
            if (typeof callback === 'function') {
                if (!error) {
                    callback(data, error);
                } else {
                    callback(errorData, error);
                }
            }
        });
    };

    GS.requestCommit = function (socket, transactionID, callback) {
        GS.requestFromSocket(socket, 'transactionid = ' + transactionID + '\nCOMMIT', function (data, error, errorData) {
            if (typeof callback === 'function') {
                if (!error) {
                    callback(data, error);
                } else {
                    callback(errorData, error);
                }
            }
        });
    };

    GS.rebootSocket = function (socket) {
        socket.stayClosed = false;
        socket.close();
    };

    GS.closeSocket = function (socket) {
        socket.stayClosed = true;
        socket.close();
    };


    var cacheLedger = [];
    window.testtesttest = cacheLedger;
    GS.requestCachingSelect = function (socket, strSchema, strObject, strColumns, strWhere, strOrd, strLimit, strOffset, callback, bolClearCache) {
        var strKey = (strSchema + strObject + strColumns + strWhere + strOrd + strLimit + strOffset)
          , intQueryIndex, i, len, currentEntry;

        //console.log(strKey, bolClearCache, cacheLedger[strKey]);

        if (bolClearCache) {
            cacheLedger[strKey] = null;
        }

        if (cacheLedger[strKey]) {
            for (i = 0, len = cacheLedger[strKey].results.length; i < len; i += 1) {
                callback(cacheLedger[strKey].results[i][0], cacheLedger[strKey].results[i][1]);
            }
            cacheLedger[strKey].callbacks.push({'callback': callback, 'ready': true});

        } else {
            currentEntry = cacheLedger[strKey] = {
                results: [],
                callbacks: [
                    {'callback': callback, 'ready': true}
                ]
            };

            //console.log('cache:' + bolClearCache);
            GS.requestSelectFromSocket(socket, strSchema, strObject, strColumns
                                     , strWhere, strOrd, strLimit, strOffset
                                     , function (data, error) {
                var i, len;

                //console.log('data:', data);
                currentEntry.results.push([data, error]);

                for (i = 0, len = currentEntry.callbacks.length; i < len; i += 1) {
                    if (currentEntry.callbacks[i].ready) {
                        currentEntry.callbacks[i].callback(data, error);
                    }
                }
            });
        }
    };

    // Nunzio removed on 2017-05-06
    /*
    var cacheQueries = [], cacheCallbacks = [], cacheResults = [];
    GS.requestCachingSelect = function (socket, strSchema, strObject, strColumns, strWhere, strOrd, strLimit, strOffset, callback, bolClearCache) {
        var strKey = (strSchema + strObject + strColumns + strWhere + strOrd + strLimit + strOffset)
          , intQueryIndex, i, len;

        if (bolClearCache) {
            intQueryIndex = cacheQueries.indexOf(strKey);

            cacheQueries.splice(intQueryIndex, 1);
            cacheCallbacks.splice(intQueryIndex, 1);
            cacheResults.splice(intQueryIndex, 1);
        }

        intQueryIndex = cacheQueries.indexOf(strKey);

        if (intQueryIndex !== -1) {
            for (i = 0, len = cacheResults[intQueryIndex].length; i < len; i += 1) {
                callback(cacheResults[intQueryIndex][i][0], cacheResults[intQueryIndex][i][1]);
            }
            cacheCallbacks[intQueryIndex].push({'callback': callback, 'ready': true});

        } else {
            //console.log(strKey);
            //console.log(cacheQueries.length);
            cacheQueries.push(strKey);
            cacheCallbacks.push([{'callback': callback, 'ready': true}]);
            cacheResults.push([]);
            //console.log(cacheQueries.length);
            intQueryIndex = (cacheQueries.length - 1);
            //console.log(intQueryIndex);

            GS.requestSelectFromSocket(socket, strSchema, strObject, strColumns
                                     , strWhere, strOrd, strLimit, strOffset
                                     , function (data, error) {
                var i, len;

                cacheResults[intQueryIndex].push([data, error]);

                for (i = 0, len = cacheCallbacks[intQueryIndex].length; i < len; i += 1) {
                    if (cacheCallbacks[intQueryIndex][i].ready) {
                        cacheCallbacks[intQueryIndex][i].callback(data, error);
                    }
                }
            });
        }
    };*/
})();


// GS.encodeForTabDelimited('asdf\\asdf\\asdf\r\nasdf\r\nasdf\tasdf\tasdf')
GS.encodeForTabDelimited = function (strValue, nullValue) {
    'use strict';
    strValue = String(strValue || '');

    if (strValue === '\\N') {
        return strValue;
    } else {
        strValue = strValue.replace(/\\/g, '\\\\') // double up backslashes
                        .replace(/\n/g, '\\n')     // replace newline with the text representation '\n'
                        .replace(/\r/g, '\\r')     // replace carriage return with the text representation '\r'
                        .replace(/\t/g, '\\t');    // replace tab with the text representation '\t'

        if (strValue === nullValue) {
            strValue = '\\N';
        }

        return strValue;
    }
};

// GS.decodeFromTabDelimited('asdf\\\\asdf\\\\asdf\\r\\nasdf\\r\\nasdf\\tasdf\\tasdf')
GS.decodeFromTabDelimited = function (strValue, nullValue) {
    'use strict';
    var i, len, strRet = '';
    //console.log(strValue, nullValue);
    if (nullValue === undefined) {
        nullValue = '\\N';
    }

    for (i = 0, len = strValue.length; i < len; i += 1) {
        if (strValue[i] === '\\' && strValue[i + 1]) {
            i += 1;

            if (strValue[i] === 'n') {
                strRet += '\n';

            } else if (strValue[i] === 'r') {
                strRet += '\r';

            } else if (strValue[i] === 't') {
                strRet += '\t';

            } else if (strValue[i] === 'N') {
                strRet += nullValue;

            } else if (strValue[i] === '\\') {
                strRet += '\\';

            } else {
                strRet += '\\' + strValue[i];
            }

        } else {
            strRet += strValue[i];
        }
    }

    return strRet;

    //return strValue.replace(/\\\\/g, '\\')
    //               .replace(/\\n/g, '\n')
    //               .replace(/\\r/g, '\r')
    //               .replace(/\\t/g, '\t')
    //               .replace(/\\N/g, 'NULL');
};

var reconnectNumber = 0;
var reconnectCheckTimer;
window.addEventListener('socket-connect', function (event) {
    "use strict";
    var intCurrConnectNumber;

    if (event.socket && event.socket.isGSSocket) {
        intCurrConnectNumber = reconnectNumber;
    
        if (reconnectCheckTimer) {
            clearTimeout(reconnectCheckTimer);
            reconnectCheckTimer = null;
        }
    
        // if we can remain connected for 5 seconds: reset countdown
        reconnectCheckTimer = setTimeout(function () {
            if (intCurrConnectNumber === reconnectNumber) {
                reconnectNumber = 0;
            }
        }, 5000);
    }
});
window.addEventListener('socket-reconnect', function (event) {
    "use strict";
    if (event.socket && event.socket.isGSSocket) {
        reconnectNumber -= 1;

        if (reconnectNumber <= -6 * (GS.websockets.length)) {
            window.location = '/' + (window.location.toString().match(/postage|env/g)[0]) + '/auth?action=logout&error=Connection%20timed%20out';
        }
    }
});

window.addEventListener('design-register-element', function () {
    'use strict';
    
    registerDesignSnippet('GS.rightPad', 'GS.rightPad',
                                    'GS.rightPad(${1:stringToPad}, \'${2:stringToPadWith}\', ${0:lengthToPadTo});');
    
    registerDesignSnippet('GS.leftPad', 'GS.leftPad',
                                    'GS.leftPad(${1:stringToPad}, \'${2:stringToPadWith}\', ${0:lengthToPadTo});');
    
    registerDesignSnippet('GS.pxToEm', 'GS.pxToEm', 'GS.pxToEm(${1:elementToTestIn}, ${0:pxToConvert});');
    
    registerDesignSnippet('GS.emToPx', 'GS.emToPx', 'GS.emToPx(${1:elementToTestIn}, ${0:emToConvert});');
    
    registerDesignSnippet('GS.sizeToPx', 'GS.sizeToPx', 'GS.sizeToPx(${1:elementToTestIn}, ${0:CSSSizeToConvert});');

    registerDesignSnippet('GS.keyCode', 'GS.keyCode', 'GS.keyCode(\'${0:characterToGetTheKeyCodeOf}\');');
    
    registerDesignSnippet('GS.charFromKeyCode', 'GS.charFromKeyCode', 'GS.charFromKeyCode(\'${0:eventObject}\');');
    
    registerDesignSnippet('GS.getStyle', 'GS.getStyle', 'GS.getStyle(${1:element}, \'${0:CSSProperty}\');');
    
    registerDesignSnippet('GS.listAdd', 'GS.listAdd', 'GS.listAdd(${1:arrayToAddTo}, \'${0:valueToAddIfUnique}\');');
    
    registerDesignSnippet('GS.triggerEvent', 'GS.triggerEvent', 'GS.triggerEvent(${1:target}, \'${2:eventName}\', ${0:jsnModifiers});');
    
    registerDesignSnippet('GS.strToTitle', 'GS.strToTitle', 'GS.strToTitle(${0:valueToConvert});');
    
    registerDesignSnippet('GS.mousePosition', 'GS.mousePosition', 'GS.mousePosition(${0:event});');
    
    registerDesignSnippet('GS.GUID', 'GS.GUID', 'GS.GUID();');
    
    registerDesignSnippet('GS.safeDecodeURIComponent', 'GS.safeDecodeURIComponent', 'GS.safeDecodeURIComponent(${0:valueToDecode});');
    
    registerDesignSnippet('GS.getTextHeight', 'GS.getTextHeight', 'GS.getTextHeight(${1:elementToTestIn}, ${0:bolNormalLineHeight});');
    
    registerDesignSnippet('GS.getTextWidth', 'GS.getTextWidth', 'GS.getTextWidth(${1:elementToTestIn}, ${0:strTextToGetTheWidthOf});');
    
    registerDesignSnippet('GS.scrollParent', 'GS.scrollParent', 'GS.scrollParent(${0:elementToStartFrom});');
    
    registerDesignSnippet('GS.scrollIntoView', 'GS.scrollIntoView', 'GS.scrollIntoView(${0:elementToScrollIntoView});');
    
    registerDesignSnippet('GS.envGetCell', 'GS.envGetCell', 'GS.envGetCell(${1:envelopeData}, ${2:recordNumber}, \'${0:columnName}\');');
    
    registerDesignSnippet('GS.trim', 'GS.trim', 'GS.trim(${1:stringToBeTrimmed}, \'${0:stringToTrimOff}\');');
    
    registerDesignSnippet('GS.setCookie', 'GS.setCookie', 'GS.setCookie(\'${1:cookieName}\', ${2:newValue}, ${0:daysUntilExpire});');

    registerDesignSnippet('GS.getCookie', 'GS.getCookie', 'GS.getCookie(\'${1:cookieName}\');');

    registerDesignSnippet('GS.pushState', 'GS.pushState', 'GS.pushState(${1:stateObj}, ${2:title}, ${0:newURL});');

    registerDesignSnippet('GS.replaceState', 'GS.replaceState', 'GS.replaceState(${1:stateObj}, ${2:title}, ${0:newURL});');

    registerDesignSnippet('GS.searchToWhere', 'GS.searchToWhere', 'GS.searchToWhere(\'${1:columns}\', ${0:searchClause});');

    registerDesignSnippet('GS.iconList', 'GS.iconList', 'GS.iconList();');

    registerDesignSnippet('GS.lorem', 'GS.lorem', 'GS.lorem();');

    registerDesignSnippet('GS.numberSuffix', 'GS.numberSuffix', 'GS.numberSuffix(${1:intNumber});');

    registerDesignSnippet('GS.hitLink', 'GS.hitLink', 'GS.hitLink(${1:strLink});');

    registerDesignSnippet('GS.log', 'GS.log', 'GS.log(\'${1:send}\', ${2:message});');

    registerDesignSnippet('GS.sanitizeString', 'GS.sanitizeString', 'GS.sanitizeString(${1:strToSanitize}, ${2:arrAdditional});');

    registerDesignSnippet('GS.sqlSafeString', 'GS.sqlSafeString', 'GS.sqlSafeString(${1:strToSanitize});');

    registerDesignSnippet('GS.filenameSafeString', 'GS.filenameSafeString', 'GS.filenameSafeString(${1:strToSanitize});');
});

// note: these three functions are meant for shorter strings
// they are not efficient enough for longer strings, which
// usually don't need client-side sanitization anyway
GS.sanitizeString = function (strToSanitize, arrAdditional) {
    "use strict";
    var strResult;
    arrAdditional = arrAdditional || [];

    // remove control characters (this does not include \r\n\t)
    strResult = strToSanitize.replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F-\u009F]/g, '');

    // remove additional characters
    if (arrAdditional.length > 0) {
        strResult = strResult.split('').map(function (a) {
            return arrAdditional.indexOf(a) > -1 ? '' : a;
        }).join('');
    }

    return strResult;
};

GS.sqlSafeString = function (strToSanitize) {
    "use strict";
    return '\'' + GS.sanitizeString(strToSanitize.replace(/'/g, '\\\'')) + '\'';
};

GS.filenameSafeString = function (strToSanitize) {
    "use strict";
    return GS.sanitizeString(strToSanitize, [
        '('
        , ')'
        , '#'
        , '*'
        , ':'
        , '<'
        , '>'
        , '?'
        , '|'
        , '\\'
        , '&'
        , '/'
        , '\''
        , '"'
        , '\t'
        , '\r'
        , '\n'
    ]);
};



GS.positionHandlingFunction = function (element, elementTarget, intMargin, strDirectionRequest, defaultDirection, returnCallback) {
    "use strict";
    var intDialogTop = '', intDialogLeft = '', intDialogMarginTop = '', intDialogMarginLeft = '', strOldStyle
        , arrElements, arrScrollingElements, i, len, strOverflow, jsnPositionData, arrTests
        , strResolvedDirection, intDialogResolvedWidth, intDialogResolvedHeight
        , intElementMidPoint, intDialogMidPoint;

    // if the dialog is not in the DOM: unbind and skip the contents of the function using return
    if (element.parentNode !== document.body) {
        /*
        window.removeEventListener('resize', function () {GS.positionHandlingFunction(element)});
        window.removeEventListener('orientationchange', function () {GS.positionHandlingFunction(element)});
        observer.disconnect();
        */

        returnCallback();

        return;
    }

    // save old style attribute
    strOldStyle = element.getAttribute('style');

    // save scroll numbers
    arrElements = xtag.query(element, '*');
    arrScrollingElements = [];

    for (i = 0, len = arrElements.length; i < len; i += 1) {
        strOverflow = GS.getStyle(arrElements[i], 'overflow');

        if (strOverflow === 'scroll' ||
            (strOverflow === 'auto' && arrElements[i].clientHeight < arrElements[i].scrollHeight)) {
            arrScrollingElements.push(arrElements[i]);
        }
        //console.log('strOverflow', i, strOverflow);
    }

    for (i = 0, len = arrScrollingElements.length; i < len; i += 1) {
        arrScrollingElements[i].oldScrollTop = arrScrollingElements[i].scrollTop;
        arrScrollingElements[i].oldScrollLeft = arrScrollingElements[i].scrollLeft;
        //console.log('arrScrollingElements', i, arrScrollingElements[i]);
    }

    // clear dialog CSS
    element.style.top        = '';
    element.style.left       = '';
    element.style.marginTop  = '';
    element.style.marginLeft = '';
    element.style.width      = '94%';
    element.style.height     = '';
    element.style.maxHeight  = '';

    //console.log(element.oldHeight, element.offsetHeight);

    // if height hasn't changed: restore style
    if (element.oldHeight === element.offsetHeight) {
        element.setAttribute('style', strOldStyle);

        for (i = 0, len = arrScrollingElements.length; i < len; i += 1) {
            arrScrollingElements[i].scrollTop = arrScrollingElements[i].oldScrollTop;
            arrScrollingElements[i].scrollLeft = arrScrollingElements[i].oldScrollLeft;
            //console.log('arrScrollingElements', i, arrScrollingElements[i]);
        }

    // else: recalculate style
    } else {
        element.oldHeight = element.offsetHeight;

        // resolve dialog width and height

        // if dialog is taller than: window height - (intMargin * 2): add max-height and height
        if (element.clientHeight > ((window.innerHeight / 100) * 94)) {
            element.style.height = '94%';
            element.style.maxHeight = strMaxHeight;
        }

        intDialogResolvedWidth  = element.offsetWidth;
        intDialogResolvedHeight = element.offsetHeight + 1; // + 1 added to fix occasional scrollbar issue

        // set dialog width and height to resolved width and height
        element.style.width  = intDialogResolvedWidth  + 'px';
        element.style.height = intDialogResolvedHeight + 'px';

        // get target position data
        jsnPositionData = GS.getElementPositionData(elementTarget);

        // order of tests depending on direction
        if (strDirectionRequest === 'up') {
            arrTests = ['up', 'down', 'left', 'right'];

        } else if (strDirectionRequest === 'down') {
            arrTests = ['down', 'up', 'left', 'right'];

        } else if (strDirectionRequest === 'left') {
            arrTests = ['left', 'right', 'down', 'up'];

        } else if (strDirectionRequest === 'right') {
            arrTests = ['right', 'left', 'down', 'up'];

        } else { // full: no tests (just go to full)
            arrTests = [];
        }

        // up: compare room above to dialog resolved height
        //      pass: display
        //      fail: next test
        for (i = 0, len = arrTests.length; i < len; i += 1) {
            if ((arrTests[i] ===    'up' && (intDialogResolvedHeight + intMargin) <= jsnPositionData.intRoomAbove) ||
                (arrTests[i] ===  'down' && (intDialogResolvedHeight + intMargin) <= jsnPositionData.intRoomBelow) ||
                (arrTests[i] ===  'left' && (intDialogResolvedWidth  + intMargin) <=  jsnPositionData.intRoomLeft) ||
                (arrTests[i] === 'right' && (intDialogResolvedWidth  + intMargin) <= jsnPositionData.intRoomRight)) {
                //console.log('arrTests', i, arrTests[i]);
                strResolvedDirection = arrTests[i];
                break;
            }
        }

        // if we could not resolve to a particular direction: set direction to full screen
        strResolvedDirection = strResolvedDirection || defaultDirection;
        //console.log(strResolvedDirection);

        // if up or down: get as close to horizontally centered on the element as possible
        if (strResolvedDirection === 'up' || strResolvedDirection === 'down') {
            intElementMidPoint = (jsnPositionData.intElementLeft + (jsnPositionData.intElementWidth / 2));
            intDialogMidPoint = (intDialogResolvedWidth / 2);
            //console.log(intElementMidPoint, jsnPositionData.left, jsnPositionData.intElementWidth);

            // if centered goes past intMargin of the left edge of the screen: go to intMargin from the bottom
            if (intElementMidPoint - intDialogMidPoint < intMargin) {
                intDialogLeft = intMargin;
                //console.log('1***', intMargin);

            // else if centered goes past intMargin of the right edge of the screen: go to intMargin less than the width of the viewport
            } else if (intElementMidPoint + intDialogMidPoint > window.innerWidth - intMargin) {
                intDialogLeft = ((window.innerWidth - intDialogResolvedWidth) - intMargin);
                //console.log('2***', window.innerWidth, intDialogResolvedWidth, intMargin);

            // else centered does not go past intMargin of either edge of the screen: center
            } else {
                intDialogLeft = (intElementMidPoint - intDialogMidPoint);
                //console.log('3***', intElementMidPoint, intDialogMidPoint, (intElementMidPoint - intDialogMidPoint) + 'px');
            }

        // else if left or right: get as close to vertically centered next to the element as possible
        } else if (strResolvedDirection === 'left' || strResolvedDirection === 'right') {
            intElementMidPoint = (jsnPositionData.intElementTop + (jsnPositionData.intElementHeight / 2));
            intDialogMidPoint = (intDialogResolvedHeight / 2);

            //console.log('0***', intElementMidPoint, intDialogMidPoint, window.innerHeight, intMargin, intDialogResolvedHeight);

            // if centered goes past intMargin of the top edge of the screen: go to intMargin from the bottom
            if (intElementMidPoint - intDialogMidPoint < intMargin) {
                intDialogTop = intMargin;
                //console.log('1***', intMargin);

            // else if centered goes past intMargin of the bottom edge of the screen: go to intMargin less than the height of the viewport
            } else if (intElementMidPoint + intDialogMidPoint > window.innerHeight - intMargin) {
                intDialogTop = ((window.innerHeight - intDialogResolvedHeight) - intMargin);
                //console.log('2***', window.innerHeight, intDialogResolvedHeight, intMargin);

            // else centered does not go past intMargin of either edge of the screen: center
            } else {
                intDialogTop = (intElementMidPoint - intDialogMidPoint);
                //console.log('3***', intElementMidPoint, intDialogMidPoint, (intElementMidPoint - intDialogMidPoint) + 'px');
            }

        // else full: use dialog logic to get width and height and center both vertically and horizontally
        } else {
            intDialogTop        = '50%';
            intDialogLeft       = '50%';
            intDialogMarginTop  = '-' + (intDialogResolvedHeight / 2) + 'px';
            intDialogMarginLeft = '-' + (intDialogResolvedWidth / 2) + 'px';
        }

        // if direction is up: connect the bottom of the dialog to the top of the element
        if (strResolvedDirection === 'up') {
            intDialogTop = (jsnPositionData.intElementTop - intDialogResolvedHeight);

        // if direction is down: connect the top of the dialog to the bottom of the element
        } else if (strResolvedDirection === 'down') {
            intDialogTop = (jsnPositionData.intElementTop + jsnPositionData.intElementHeight);

        // if direction is left: connect the right of the dialog to the left of the element
        } else if (strResolvedDirection === 'left') {
            intDialogLeft = (jsnPositionData.intElementLeft - intDialogResolvedWidth);

        // if direction is right: connect the left of the dialog to the right of the element
        } else if (strResolvedDirection === 'right') {
            intDialogLeft = (jsnPositionData.intElementLeft + jsnPositionData.intElementWidth);
        }

        // prevent the dialog from vertically going outside the viewport
        if (intDialogTop + intDialogResolvedHeight > window.innerHeight) {
            intDialogTop -= (intDialogTop + intDialogResolvedHeight) - window.innerHeight;

        }

        // prevent the dialog from horizontally going outside the viewport
        if (intDialogLeft + intDialogResolvedWidth > window.innerWidth) {
            intDialogLeft -= (intDialogLeft + intDialogResolvedWidth) - window.innerWidth;
        }

        // apply CSS to the dialog
        element.style.top        = intDialogTop + 'px';
        element.style.left       = intDialogLeft + 'px';
        element.style.marginTop  = intDialogMarginTop + 'px';
        element.style.marginLeft = intDialogMarginLeft + 'px';
    }
};

function gt(x,y)  { return x >  y; }
function gte(x,y) { return x >= y; }
function lt(x,y)  { return x <  y; }
function lte(x,y) { return x <= y; }

// sometimes, we need to hit a link without paying attention
//      to the response and without opening a new tab. for
//      example, mailto: and tel: links
GS.hitLink = function (strLink) {
    "use strict";
    var iframeElement;

    iframeElement = document.createElement('iframe');
    iframeElement.setAttribute('hidden', '');
    iframeElement.addEventListener('load', function () {
        if (iframeElement.parentNode === document.body) {
            document.body.removeChild(iframeElement);
        }
    });

    iframeElement.setAttribute("src", strLink);
    document.body.appendChild(iframeElement);
};

GS.newDate = function (date) {
    var strDate = '' + date + '';
    if (strDate.indexOf('-') !== strDate.lastIndexOf('-')) {
        strDate = (
            strDate
                .replace(/\-/, '/')
                .replace(/\-/, '/')
        );
    }
    return new Date(strDate);
}


GS.log = function (bolsend, message) {
    "use strict";
    var msg = message;
    if (bolsend) {
        var e = new Error();
        if (!e.stack) {
            try {
                // IE requires the Error to actually be thrown or else the 
                // Error's 'stack' property is undefined.
                throw e;
            } catch (e) {
                if (!e.stack) {
                    //return 0; // IE < 10, likely
                }
            }
        }
        var stack = e.stack.toString().split(/\r\n|\n/);
        if (msg === '') {
            msg = '""';
        }
        console.log(msg, ' ' + stack[1].trim().substring(stack[1].trim().indexOf('('), stack[1].trim().length) + '');
    }
};


GS.numberSuffix = function(intNumber) {
    'use strict';
    var strNumber = String(intNumber),
        jsnSuffixes = {
            '0': 'th', '1': 'st',
            '2': 'nd', '3': 'rd',
            '4': 'th', '5': 'th',
            '6': 'th', '7': 'th',
            '8': 'th', '9': 'th'
        };
                
    return strNumber + jsnSuffixes[strNumber[strNumber.length - 1]];
}

//convert number into check number. will round if given more than two decimals.
GS.convertNumToWords = function (num) {
    'use strict';
    var intDollars = Math.trunc(num);
    var intCents = num.toFixed(2).split('.')[1];
    if ((num || 0) == 0) {
        return 'zero';
    }
    var ones = ['', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine'];
    var tens = ['', '', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety'];
    var teens = ['Ten', 'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen'];

    var bolInvert = false;

    if (intDollars < 0) {
        bolInvert = true;
        intDollars = (intDollars * -1);
    }

    function convert_tens(dollars) {
        if (dollars < 10) {
            return ones[dollars];
        } else if (dollars >= 10 && dollars < 20) {
            return teens[dollars - 10];
        } else {
            return tens[Math.floor(dollars / 10)] + " " + ones[dollars % 10];
        }
    }

    function convert_hundreds(dollars) {
        if (dollars > 99) {
            return ones[Math.floor(dollars / 100)] + ' Hundred ' + convert_tens(dollars % 100);
        } else {
            return convert_tens(dollars);
        }
    }

    function convert_thousands(dollars) {
        if (dollars >= 1000) {
            return convert_hundreds(Math.floor(dollars / 1000)) + ' Thousand ' + convert_hundreds(dollars % 1000);
        } else {
            return convert_hundreds(dollars);
        }
    }

    function convert_millions(dollars) {
        if (dollars >= 1000000) {
            return convert_millions(Math.floor(dollars / 1000000)) + ' Million ' + convert_thousands(dollars % 1000000);
        } else {
            return convert_thousands(dollars);
        }
    }

    if (num == 0) {
        return 'zero';
    } else if (num > 0 && num < 1) {
        return 'Zero and ' + intCents + '/100';
    } else {
        //num was negative
        if (bolInvert) {
            return ('Negative ' + convert_millions(intDollars) + ' and ' + intCents + '/100').replace(/(  )/g, ' ');
        } else {
            return (convert_millions(intDollars) + ' and ' + intCents + '/100').replace(/(  )/g, ' ');
        }
    }
}

// ###########################################################
// #################### PADDING FUNCTIONS ####################
// ###########################################################

// pad a string with another string on the right side of the string
//      repeating until the pad_str until the str length is >= the padToLength

//  PARAM         "str": string to pad
//  PARAM   "padString": string to pad with
//  PARAM "padToLength": number of characters to pad for
GS.rightPad = function (str, padString, padToLength) {
    'use strict';
    str = String(str);
    
    while (str.length < padToLength) {
        str += padString;
    }
   
    return str;
};


// pad a string with another string on the left side of the string
//      repeating until the padString until the str length is >= the padToLength

//  PARAM         "str": string to pad
//  PARAM   "padString": string to pad with
//  PARAM "padToLength": number of characters to pad for
GS.leftPad = function (str, padString, padToLength) {
    'use strict';
    str = String(str);
    
    while (str.length < padToLength) {
        str = padString + str;
    }
   
    return str;
};



// ################################################################
// ################ EM AND PX CONVERSION FUNCTIONS ################
// ################################################################

// convert pixels to ems
GS.pxToEm = function (elementScope, fromPX) {
    'use strict';
	var intPX = parseFloat(fromPX),
	    heightTestElement = document.createElement('div'),
	    intElementHeight;
    
    elementScope = elementScope || document.body;
    
    heightTestElement.style.fontSize = '1em';
    heightTestElement.style.margin = '0';
    heightTestElement.style.padding = '0';
    heightTestElement.style.lineHeight = '1';
    heightTestElement.style.border = '0';
    
    heightTestElement.innerHTML = 'a';
    
    elementScope.appendChild(heightTestElement);
    intElementHeight = heightTestElement.offsetHeight;
    elementScope.removeChild(heightTestElement);
    
	return parseFloat((intPX / intElementHeight).toFixed(8), 10);
};

// convert ems to pixels
GS.emToPx = function (elementScope, fromEM) {
    'use strict';
	var intEM = parseFloat(fromEM),
	    heightTestElement = document.createElement('div'),
	    intElementHeight;
    
    elementScope = elementScope || document.body;
    
    heightTestElement.style.fontSize = '1em';
    heightTestElement.style.margin = '0';
    heightTestElement.style.padding = '0';
    heightTestElement.style.lineHeight = '1';
    heightTestElement.style.border = '0';
    
    heightTestElement.innerHTML = 'a';
    
    elementScope.appendChild(heightTestElement);
    intElementHeight = heightTestElement.offsetHeight;
    elementScope.removeChild(heightTestElement);
    
	return Math.round(intEM * intElementHeight); // not sure if we want to round here but the old function did
	                                             // so I will leave it here until there is a problem -michael
};

// convert arbitrary CSS expression to pixels
GS.sizeToPx = function (elementScope, fromCSS) {
    'use strict';
	var heightTestElement = document.createElement('div'),
	    intElementHeight;
    
    elementScope = elementScope || document.body;
    
    heightTestElement.style.fontSize = fromCSS;
    heightTestElement.style.margin = '0';
    heightTestElement.style.padding = '0';
    heightTestElement.style.lineHeight = '1';
    heightTestElement.style.border = '0';
    
    heightTestElement.innerHTML = 'a';
    
    elementScope.appendChild(heightTestElement);
    intElementHeight = heightTestElement.offsetHeight;
    elementScope.removeChild(heightTestElement);
    
	return Math.round(intElementHeight); // not sure if we want to round here but the old function did
	                                             // so I will leave it here until there is a problem -michael
};

// ################################################################
// #################### MISC UTILITY FUNCTIONS ####################
// ################################################################

GS.charFromKeyCode = function (event) {
    // (this function contains a (modified) substantial portion of code from another source
    //    here is the copyright for sake of legality)
    
    // name: jQuery getChar
    // repository: https://github.com/bpeacock/key-to-charCode
    // @author Brian Peacock
    // @version 0.3
    // Copyright 2013, Brian Peacock
    // Licensed under the MIT license.
    
    'use strict';
    
    var code = event.which;
    
    //Ignore Shift Key events & arrows
    var ignoredCodes = {
        16: true,
        37: true,
        38: true,
        39: true,
        40: true,
        20: true,
        17: true,
        18: true,
        91: true
    };
    
    if (ignoredCodes[code] === true) {
        return false;
    }
    
    // These are special cases that don't fit the ASCII mapping
    var exceptions = {
        186: 59, // ;
        187: 61, // =
        188: 44, // ,
        189: 45, // -
        190: 46, // .
        191: 47, // /
        192: 96, // `
        219: 91, // [
        220: 92, // \
        221: 93, // ]
        222: 39, // '
        //numeric keypad
        96: '0'.charCodeAt(0),
        97: '1'.charCodeAt(0),
        98: '2'.charCodeAt(0),
        99: '3'.charCodeAt(0),
        100: '4'.charCodeAt(0),
        101: '5'.charCodeAt(0),
        102: '6'.charCodeAt(0),
        103: '7'.charCodeAt(0),
        104: '8'.charCodeAt(0),
        105: '9'.charCodeAt(0)
    };

    if (exceptions[code] !== undefined) {
        code = exceptions[code];
    }
    
    var ch = String.fromCharCode(code);
    
    // Handle Shift
    if (event.shiftKey) {
        var special = {
            1: '!',
            2: '@',
            3: '#',
            4: '$',
            5: '%',
            6: '^',
            7: '&',
            8: '*',
            9: '(',
            0: ')',
            ',': '<',
            '.': '>',
            '/': '?',
            ';': ':',
            "'": '"',
            '[': '{',
            ']': '}',
            '\\': '|',
            '`': '~',
            '-': '_',
            '=': '+'
        };

        if (special[ch] !== undefined) {
            ch = special[ch];
        }
    } else {
        ch = ch.toLowerCase();
    }
    
    return ch;
};

// keyCode string to number
GS.keyCode = function (inChar) {
    "use strict";
	/*
	Key 	Code
backspace 	8
tab 	9
enter 	13
shift 	16
ctrl 	17
alt 	18
pause/break 	19
caps lock 	20
escape 	27
(space) 	32
page up 	33
page down 	34
end 	35
home 	36
left arrow 	37
up arrow 	38
right arrow 	39
down arrow 	40
insert 	45
delete 	46
0 	48
1 	49
2 	50
3 	51
4 	52
5 	53
6 	54
7 	55
8 	56
9 	57
a 	65
b 	66
c 	67
d 	68

Key 	Code
e 	69
f 	70
g 	71
h 	72
i 	73
j 	74
k 	75
l 	76
m 	77
n 	78
o 	79
p 	80
q 	81
r 	82
s 	83
t 	84
u 	85
v 	86
w 	87
x 	88
y 	89
z 	90
left window key 	91
right window key 	92
select key 	93
numpad 0 	96
numpad 1 	97
numpad 2 	98
numpad 3 	99
numpad 4 	100
numpad 5 	101
numpad 6 	102
numpad 7 	103
*/
    inChar = inChar.toLowerCase();
	return '\b'          == inChar ? '8' :
	       'backspace'   == inChar ? '8' :
	       '\t'          == inChar ? '9' :
	       'tab'         == inChar ? '9' :
	       '\r'          == inChar ? '13' :
	       '\n'          == inChar ? '13' :
	       'enter'       == inChar ? '13' :
	       'return'      == inChar ? '13' :
	       'newline'     == inChar ? '13' :
	       'shift'       == inChar ? '16' :
	       'ctrl'        == inChar ? '17' :
	       'alt'         == inChar ? '18' :
	       'pause/break' == inChar ? '19' :
	       'caps lock'   == inChar ? '20' :
	       'escape'      == inChar ? '27' :
	       'space'       == inChar ? '32' :
	       ' '           == inChar ? '32' :
	       'page up'     == inChar ? '33' :
	       'page down'   == inChar ? '34' :
	       'end'         == inChar ? '35' :
	       'home'        == inChar ? '36' :
	       'left arrow'  == inChar ? '37' :
	       'up arrow'    == inChar ? '38' :
	       'right arrow' == inChar ? '39' :
	       'down arrow'  == inChar ? '40' :
	       'insert'      == inChar ? '45' :
	       'delete'      == inChar ? '46' :
	       '0'           == inChar ? '48' :
	       '1'           == inChar ? '49' :
	       '2'           == inChar ? '50' :
	       '3'           == inChar ? '51' :
	       '4'           == inChar ? '52' :
	       '5'           == inChar ? '53' :
	       '6'           == inChar ? '54' :
	       '7'           == inChar ? '55' :
	       '8'           == inChar ? '56' :
	       '9'           == inChar ? '57' :
	       'a'           == inChar ? '65' :
	       'b'           == inChar ? '66' :
	       'c'           == inChar ? '67' :
	       'd'           == inChar ? '68' :
	       'e'           == inChar ? '69' :
	       'f'           == inChar ? '70' :
	       'g'           == inChar ? '71' :
	       'h'           == inChar ? '72' :
	       'i'           == inChar ? '73' :
	       'j'           == inChar ? '74' :
	       'k'           == inChar ? '75' :
	       'l'           == inChar ? '76' :
	       'm'           == inChar ? '77' :
	       'n'           == inChar ? '78' :
	       'o'           == inChar ? '79' :
	       'p'           == inChar ? '80' :
	       'q'           == inChar ? '81' :
	       'r'           == inChar ? '82' :
	       's'           == inChar ? '83' :
	       't'           == inChar ? '84' :
	       'u'           == inChar ? '85' :
	       'v'           == inChar ? '86' :
	       'w'           == inChar ? '87' :
	       'x'           == inChar ? '88' :
	       'y'           == inChar ? '89' :
	       'z'           == inChar ? '90' :
	       'left window key'  == inChar ? '91' :
	       'right window key' == inChar ? '92' :
	       'select key'  == inChar ? '93' :
	       'numpad 0'    == inChar ? '96' :
	       'numpad 1'    == inChar ? '97' :
	       'numpad 2'    == inChar ? '98' :
	       'numpad 3'    == inChar ? '99' :
	       'numpad 4'    == inChar ? '100' :
	       'numpad 5'    == inChar ? '101' :
	       'numpad 6'    == inChar ? '102' :
	       'numpad 7'    == inChar ? '103' :
	       'numpad 8'    == inChar ? '104' :
	       'numpad 9'    == inChar ? '105' :
	       'multiply'    == inChar ? '106' :
	       'add'         == inChar ? '107' :
	       '+'           == inChar ? '107' :
	       'subtract'    == inChar ? '109' :
	       '-'           == inChar ? '109' :
	       'decimal point' == inChar ? '110' :
	       'divide'      == inChar ? '111' :
	       'f1'          == inChar ? '112' :
	       'f2'          == inChar ? '113' :
	       'f3'          == inChar ? '114' :
	       'f4'          == inChar ? '115' :
	       'f5'          == inChar ? '116' :
	       'f6'          == inChar ? '117' :
	       'f7'          == inChar ? '118' :
	       'f8'          == inChar ? '119' :
	       'f9'          == inChar ? '120' :
	       'f10'         == inChar ? '121' :
	       'f11'         == inChar ? '122' :
	       'f12'         == inChar ? '123' :
	       'num lock'    == inChar ? '144' :
	       'scroll lock' == inChar ? '145' :
	       'semi-colon'  == inChar ? '186' :
	       ';'           == inChar ? '186' :
	       'equal sign'  == inChar ? '187' :
	       '='           == inChar ? '187' :
	       'comma'       == inChar ? '188' :
	       ','           == inChar ? '188' :
	       'dash'        == inChar ? '189' :
	       '-'           == inChar ? '189' :
	       'period'      == inChar ? '190' :
	       '.'           == inChar ? '190' :
	       'forward slash' == inChar ? '191' :
	       '/'             == inChar ? '191' :
	       'grave accent'  == inChar ? '192' :
	       'open bracket'  == inChar ? '219' :
	       '['             == inChar ? '219' :
	       'back slash'    == inChar ? '220' :
	       '\\'            == inChar ? '220' :
	       'close bracket' == inChar ? '221' :
	       ']'             == inChar ? '221' :
	       'single quote'  == inChar ? '222' :
	       '\''            == inChar ? '222' :
	       '';
	/*
Key 	Code
numpad 8 	104
numpad 9 	105
multiply 	106
add 	107
subtract 	109
decimal point 	110
divide 	111
f1 	112
f2 	113
f3 	114
f4 	115
f5 	116
f6 	117
f7 	118
f8 	119
f9 	120
f10 	121
f11 	122
f12 	123
num lock 	144
scroll lock 	145
semi-colon 	186
equal sign 	187
comma 	188
dash 	189
period 	190
forward slash 	191
grave accent 	192
open bracket 	219
back slash 	220
close braket 	221
single quote 	222
*/
};

// get computed or current style (current style if it is availible)
GS.getStyle = function (element, style) {
	if (element.currentStyle !== undefined) {
        return element.currentStyle[style];
	}
    
    return document.defaultView.getComputedStyle(element, null)[style];
};

// push to array if the value is unique
GS.listAdd = function (arrArray, newValue) {
    'use strict';
    if (arrArray.indexOf(newValue) === -1) {
        arrArray.push(newValue);
    }
};

// trigger an event on a target
GS.triggerEvent = function (target, strEventName, jsnConfig) {
    'use strict';
    var event, key;
    
    //console.trace('trigger', target);
    
    if (document.createEvent) {
        event = document.createEvent('HTMLEvents');
        event.initEvent(strEventName, true, true);
    } else {
        event = document.createEventObject();
        event.eventType = strEventName;
    }
    
    event.eventName = strEventName;
    
    if (jsnConfig) {
        for (key in jsnConfig) {
            event[key] = jsnConfig[key];
        }
    }
    
    if (document.createEvent) {
        target.dispatchEvent(event);
    } else {
        target.fireEvent("on" + event.eventType, event);
    }
    
    return event;
};

// converts a string into a more user readable format
GS.strToTitle = function (strInput) {
    'use strict';
    var i, len, chrCurrent, chrLast = '', strRet = '';
    
    strInput = strInput || '';
    
    for (i = 0, len = strInput.length; i < len; i += 1) {
        chrCurrent = strInput.charAt(i);
        
        if (!(/[a-zA-Z]/).test(chrLast)) {
            strRet += chrCurrent.toUpperCase();
            
        } else if (chrCurrent === '_') {
            strRet += ' ';
            
        } else {
            strRet += chrCurrent;
        }
        
        chrLast = chrCurrent;
    }
    
    return strRet;
};

// normalize top, left, bottom and right on a mouse event
GS.mousePosition = function (event) {
    'use strict';
    var pageX = (evt.touchDevice ? event.touches[0].pageX: event.pageX),// get the left and top of the mouse
        pageY = (evt.touchDevice ? event.touches[0].pageY: event.pageY);//   (or the touch position if we are on a phone)
    
    return {
        'top':    pageY,
        'left':   pageX,
        'bottom': window.innerHeight - pageY,
        'right':  window.innerWidth - pageX,
        
        //'x':      pageY, // alias <== messed these up
        //'y':      pageX  // alias
        
        'x':      pageX, // alias
        'y':      pageY  // alias
    };
};

// original function found here: http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
GS.GUID = function () {
    var strTime = new Date().getTime().toString();
    
    function randomString() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    }
    
    return  randomString() + randomString() + '-' +
            randomString() + '-' +
            randomString() + '-' +
            randomString() + '-' +
            strTime.substring(strTime.length - 4) + '-' +
            randomString() + randomString() + randomString();
};

/*  ,---- no longer works
//  V
GS.getSelectedText = function () {
    if (window.getSelection) {
        return window.getSelection() + '';
    }
    
    // FireFox
    if (document.getSelection) {
        return document.getSelection() + '';
    }
    
    // IE 6/7
    if (document.selection) {
        return document.selection.createRange().text + '';
    }
    
    console.warn('GS.getSelectedText warning: no selection collection function found (could not find a way to get the selected text)');
    return '';
}*/

// decode uri component safe from "URI malformed" error
GS.safeDecodeURIComponent = function (string) {
    var strRet;
    
    try {
        strRet = decodeURIComponent(string);
        
    } catch (error) {
        if (error.toString().indexOf('URI malformed') > -1) {
            strRet = string;
        } else {
            throw error;
        }
    }
    
    return strRet;
};

//
GS.getTextHeight = function (scope, bolNormalLineHeight) {
    var divElement = document.createElement('div'), intHeight;
    
    scope = scope || document.body;
    
    divElement.style.visibility = 'invisible';
    divElement.style.fontSize   = '1em';
    divElement.style.margin     = '0';
    divElement.style.padding    = '0';
    divElement.style.lineHeight = (bolNormalLineHeight ? 'normal' : '1');
    divElement.style.border     = '0';
    divElement.textContent      = 'a';
    
    scope.appendChild(divElement);
    
    intHeight = divElement.clientHeight;
    
    scope.removeChild(divElement);
    
    return intHeight;
};


//
GS.getTextWidth = function (scope, strText, bolWhitePreserve) {
    var divElement = document.createElement('div'), intWidth;
    
    scope = scope || document.body;
    
    divElement.style.display       = 'inline-block';
    divElement.style.visibility    = 'invisible';
    divElement.style.fontSize      = '1em';
    divElement.style.margin        = '0';
    divElement.style.padding       = '0';
    divElement.style.letterSpacing = 'inherit';
    divElement.style.border        = '0';
    divElement.style.whiteSpace    = (bolWhitePreserve ? 'pre' : '');
    divElement.textContent         = strText;
    //console.log(strText);
    
    scope.appendChild(divElement);
    
    intWidth = divElement.clientWidth;
    
    scope.removeChild(divElement);
    
    return intWidth;
};



GS.scrollParent = function (element, strDirection) {
    "use strict";
    var strDirectionText;
    if (strDirection) {
        strDirectionText = strDirection;
    } else {
        strDirectionText = 'vertical';
    }
    var i = 0;
    var currentElement = element;
    var bolFoundScrollable = false;
    var strOverflow;

    if (currentElement) {
        while (
            currentElement &&
            currentElement.nodeName !== 'HTML' &&
            bolFoundScrollable === false &&
            i < 75
        ) {
            strOverflow = GS.getStyle(currentElement, 'overflow');
            if (
                strOverflow === 'scroll' ||
                (
                    strOverflow === 'auto' &&
                    strDirectionText === 'vertical' &&
                    currentElement.clientHeight < currentElement.scrollHeight
                ) ||
                (
                    strOverflow === 'auto' &&
                    strDirectionText === 'horizontal' &&
                    currentElement.clientWidth < currentElement.scrollWidth
                )
            ) {
                bolFoundScrollable = true;
            } else {
                currentElement = currentElement.parentNode;
                i += 1;
            }
        }

        //console.log(currentElement.nodeName);
        if (!currentElement || currentElement.nodeName === 'HTML') {
            return document.body;
        }

        return (
            bolFoundScrollable
                ? currentElement
                : undefined
        );
    }
    return undefined;
}


//
GS.scrollIntoView = function (element, strDirection) {
    var strDirectionText;
    if (strDirection) {
        strDirectionText = strDirection;
    } else {
        strDirectionText = 'vertical';
    }
    var scrollingContainer = GS.scrollParent(element, strDirectionText), arrSiblings, i, len, intScrollTop, intScrollLeft;
    if (scrollingContainer) {
        //console.log(scrollingContainer);
        if (strDirectionText === 'horizontal') {
            arrSiblings = element.parentNode.children;
            
            for (i = 0, intScrollLeft = 0, len = arrSiblings.length; i < len; i += 1) {
                if (arrSiblings[i] === element) {
                    intScrollLeft += arrSiblings[i].offsetWidth / 2;
                    
                    break;
                } else {
                    intScrollLeft += arrSiblings[i].offsetWidth;
                }
            }
            
            intScrollLeft = intScrollLeft - (scrollingContainer.offsetWidth / 2);
            scrollingContainer.scrollLeft = intScrollLeft;
        } else {
            arrSiblings = element.parentNode.children;
            
            for (i = 0, intScrollTop = 0, len = arrSiblings.length; i < len; i += 1) {
                if (arrSiblings[i] === element) {
                    intScrollTop += arrSiblings[i].offsetHeight / 2;
                    
                    break;
                } else {
                    intScrollTop += arrSiblings[i].offsetHeight;
                }
            }
            
            intScrollTop = intScrollTop - (scrollingContainer.offsetHeight / 2);
            scrollingContainer.scrollTop = intScrollTop;
        }
    }
};

// return value from: envelope data, record number and column name
GS.envGetCell = function (data, record_number, column_name) {
    'use strict';
    var index;
    
    if (data.stat) {
        data = data.dat;
    }
    
    index = data.arr_column.indexOf(column_name);
    
    if (index === -1) {
        console.error(column_name, data);
        throw 'Error in GS.envGetCell: column not found';
    }
    
    return data.dat[record_number][index];
};

GS.trim = function(string, strStringToTrim) {
    "use strict";
    var safeRegexString = strStringToTrim.replace(/([.?*+^$[\]\\(){}|-])/g,'\\$1'),
        trimRegex = new RegExp('^' + safeRegexString + '+|' + safeRegexString + '+$', 'g');
    
    return string.replace(trimRegex, '');
};

// set a cookie in the browser
GS.setCookie = function (c_name, value, exdays) {
    'use strict';
    var exDayNum;
    if (!exdays) {
        exDayNum = 30;
    } else {
        exDayNum = exdays;
    }

    var hostname = location.hostname;
    var exdate = new Date(), c_value;

    // if there's more than one dot in the *fudging* domain, remove the *fudging* subdomain.
    // but what if there's two subdomains? The world will never now!


    //jk that two subdomains thing needs to be fixed
    if (hostname.indexOf('.') !== hostname.lastIndexOf('.')) {
        hostname = hostname.substring(hostname.indexOf('.'));
    }
    exdate.setDate(exdate.getDate() + exDayNum);

    c_value = encodeURIComponent(value) + ((exDayNum === null || exDayNum === undefined) ? '' : '; expires=' + exdate.toUTCString()) + '; domain=' + hostname + '; path=/';

    document.cookie = c_name + '=' + c_value;
};


// get a cookie from the browser
GS.getCookie = function (c_name) {
    'use strict';
    var c_value = document.cookie, c_end,
        c_start = c_value.indexOf(" " + c_name + "=");
    
    if (c_start === -1) {
        c_start = c_value.indexOf(c_name + "=");
    }
    
    if (c_start === -1) {
        c_value = null;
    } else {
        c_start = c_value.indexOf("=", c_start) + 1;
        c_end = c_value.indexOf(";", c_start);
        if (c_end === -1) {
            c_end = c_value.length;
        }
        c_value = decodeURIComponent(c_value.substring(c_start, c_end));
    }
    
    return c_value;
};

GS.pushState = function (stateObj, title, url) {
    history.pushState(stateObj, title, url);
    GS.triggerEvent(window, 'pushstate');
};

GS.replaceState = function (stateObj, title, url) {
    history.replaceState(stateObj, title, url);
    GS.triggerEvent(window, 'replacestate');
};

GS.searchToWhere = function (columns, searchClause) {
    //console.log(searchClause);
    var arrToken, arrNoQuotes = [], strNoQuotes = '', arrColumn, arrRequired = [], strRequired = '', arrWhere = [], strWhere = '', strRet = '', token, numTokens, col, numCols, i, len, strSearch;
    
    if (!searchClause) {
        return '1=1';
    }
    
    arrColumn = columns.split(',');
    
    // First get all quoted tokens, leave everything else
    arrToken = searchClause.match(/[\+|\-]?"[^"]*?"/g);
    
    if (arrToken) {
        for (token = 0, numTokens = arrToken.length; token < numTokens; token += 1) {
            arrToken[token] = GS.trim(arrToken[token], '+');
            for (col = 0, numCols = arrColumn.length; col < numCols; col += 1) {
                if (arrToken[token][0] === '-') {
                    arrToken[token] = GS.trim(arrToken[token], '-');
                    arrRequired[token] =
                        (arrRequired[token] ? arrRequired[token] + ' AND ' : '') +
                        'CASE WHEN ' + arrColumn[col] +
                        ' IS NOT NULL THEN ' + arrColumn[col] +
                        ' NOT ILIKE \'%' + GS.trim(arrToken[token], '"') +
                        '%\' ELSE TRUE END';
                    arrToken[token] = '-' + arrToken[token];
                } else {
                    arrRequired[token] = 
                        (arrRequired[token] ? arrRequired[token] + ' OR ' : '') +
                        (arrColumn[col] + ' ILIKE \'%' + GS.trim(arrToken[token], '"') + '%\'');
                }
            }
        }
        
        for (i = 0, len = arrRequired.length; i < len; i += 1) {
            strRequired = (strRequired ? strRequired + ' AND ' : '') + '(' + arrRequired[i] + ')';
        }
        //console.log('strRequired:', strRequired);
    }
    
    // Get non-quoted tokens and remove extra space
    /*
    //NOT CROSS BROWSER
    arrNoQuotes = strSearch.split(/([\+|\-]?"[^"]*?")/);
    strNoQuotes = arrNoQuotes.join(' ');
    arrNoQuotes = strNoQuotes.split(/[ ]+/);
    */
    strSearch = searchClause.trim();
    strSearch = strSearch.replace('-"', '"');
    strSearch = strSearch.replace('+"', '"');
    strSearch = strSearch.replace(/"[^"]*"/, '""');
    arrNoQuotes = strSearch.split('""');
    //console.log("arrNoQuotes: ", arrNoQuotes);
    strNoQuotes = arrNoQuotes.join(' ');
    //console.log("strNoQuotes: >" + strNoQuotes + "<");
    strNoQuotes = strNoQuotes.replace('  ', ' ');
    strNoQuotes = strNoQuotes.replace('  ', ' ');
    arrNoQuotes = strNoQuotes.split(' ');
    //console.log("arrNoQuotes: ", arrNoQuotes);
    /*
    //DIDN'T WORK
    strSearch = searchClause.trim();
    strSearch = strSearch.replace('-"', '"');
    strSearch = strSearch.replace('+"', '"');
    arrNoQuotes = strSearch.split('"');
    strSearch = '';
    if (searchClause.trim()[0] === '"') {
        for (i = 1, len = arrNoQuotes.length; i < len; i += 2) {
            strSearch = strSearch + (strSearch === '' ? '' : ' ') + arrNoQuotes[i].trim();
        }
    } else {
        for (i = 0, len = arrNoQuotes.length; i < len; i += 2) {
            strSearch = strSearch + (strSearch === '' ? '' : ' ') + arrNoQuotes[i].trim();
        }
    }
    //console.log(strSearch);
    strSearch = strSearch.replace('  ', ' ');
    strSearch = strSearch.replace('  ', ' ');
    arrNoQuotes = strSearch.split(' ');
    //console.log(arrNoQuotes);
    */
    // Put items into arrRequired or arrWhere
    arrRequired = [''];
    if (arrNoQuotes.length > 0) {
        //console.log('1');
        for (token = 0, numTokens = arrNoQuotes.length; token < numTokens; token += 1) {
            //console.log('2');
            for (col = 0, numCols = arrColumn.length; col < numCols; col += 1) {
                //console.log('3 arrNoQuotes[' + token + ']: ' + arrNoQuotes[token]);
                if (arrNoQuotes[token].length > 0) {
                    //console.log('4');
                    if (arrNoQuotes[token][0] === '-') {
                        arrRequired[token] = 
                            (arrRequired[token] ? arrRequired[token] + ' AND ' : '') +
                            ' CASE WHEN ' + arrColumn[col] +
                            ' IS NOT NULL THEN ' + arrColumn[col] +
                            ' NOT ILIKE $$%' + GS.trim(GS.trim(arrNoQuotes[token], '-'), ' ') +
                            '%$$ ELSE TRUE END ';
                    } else if (arrNoQuotes[token][0] === '+') {
                        arrRequired[token] = 
                            (arrRequired[token] ? arrRequired[token] + ' OR ' : '') +
                            arrColumn[col] + ' ILIKE $$%' +
                            GS.trim(GS.trim(arrNoQuotes[token], '+'), ' ') + '%$$ ';
                    } else {
                        arrWhere[token] = 
                            (arrWhere[token] ? arrWhere[token] + ' OR ' : '') +
                            arrColumn[col] + ' ILIKE $$%' + GS.trim(arrNoQuotes[token], ' ') + '%$$ ';
                    }
                }
            }
        }
    }
    
    if (arrRequired.length > 0) {
        for (i = 0, len = arrRequired.length; i < len; i += 1) {
            if (arrRequired[i]) {
                strRequired = (strRequired ? strRequired + ' AND ' : '') + '(' + arrRequired[i] + ')';
            }
        }
    }
    //console.log('strRequired: ', strRequired);
    
    if (arrWhere.length > 0) {
        for (i = 0, len = arrWhere.length; i < len; i += 1) {
            if (arrWhere[i]) {
                strWhere = (strWhere ? strWhere + ' AND ' : '') + '(' + arrWhere[i] + ')';
            }
        }
    }
    //console.log('strWhere: ', strWhere);
    
    strRet = 
        (
            strWhere && strRequired ? '(' + strWhere + ') AND (' + strRequired + ')' :
            strWhere ? strWhere :
            strRequired
        );
    
    //console.log('strRet: ' + strRet);
    
    return strRet;
};

GS.iconList = function () {
    return [{"name":"500px","code":"f26e"},{"name":"adjust","code":"f042"},{"name":"adn","code":"f170"},{"name":"align-center","code":"f037"},{"name":"align-justify","code":"f039"},{"name":"align-left","code":"f036"},{"name":"align-right","code":"f038"},{"name":"amazon","code":"f270"},{"name":"ambulance","code":"f0f9"},{"name":"anchor","code":"f13d"},{"name":"android","code":"f17b"},{"name":"angellist","code":"f209"},{"name":"angle-double-down","code":"f103"},{"name":"angle-double-left","code":"f100"},{"name":"angle-double-right","code":"f101"},{"name":"angle-double-up","code":"f102"},{"name":"angle-down","code":"f107"},{"name":"angle-left","code":"f104"},{"name":"angle-right","code":"f105"},{"name":"angle-up","code":"f106"},{"name":"apple","code":"f179"},{"name":"archive","code":"f187"},{"name":"area-chart","code":"f1fe"},{"name":"arrow-circle-down","code":"f0ab"},{"name":"arrow-circle-left","code":"f0a8"},{"name":"arrow-circle-o-down","code":"f01a"},{"name":"arrow-circle-o-left","code":"f190"},{"name":"arrow-circle-o-right","code":"f18e"},{"name":"arrow-circle-o-up","code":"f01b"},{"name":"arrow-circle-right","code":"f0a9"},{"name":"arrow-circle-up","code":"f0aa"},{"name":"arrow-down","code":"f063"},{"name":"arrow-left","code":"f060"},{"name":"arrow-right","code":"f061"},{"name":"arrow-up","code":"f062"},{"name":"arrows","code":"f047"},{"name":"arrows-alt","code":"f0b2"},{"name":"arrows-h","code":"f07e"},{"name":"arrows-v","code":"f07d"},{"name":"asterisk","code":"f069"},{"name":"at","code":"f1fa"},{"name":"automobile","code":"f1b9"},{"name":"backward","code":"f04a"},{"name":"balance-scale","code":"f24e"},{"name":"ban","code":"f05e"},{"name":"bank","code":"f19c"},{"name":"bar-chart","code":"f080"},{"name":"bar-chart-o","code":"f080"},{"name":"barcode","code":"f02a"},{"name":"bars","code":"f0c9"},{"name":"battery-0","code":"f244"},{"name":"battery-1","code":"f243"},{"name":"battery-2","code":"f242"},{"name":"battery-3","code":"f241"},{"name":"battery-4","code":"f240"},{"name":"battery-empty","code":"f244"},{"name":"battery-full","code":"f240"},{"name":"battery-half","code":"f242"},{"name":"battery-quarter","code":"f243"},{"name":"battery-three-quarters","code":"f241"},{"name":"bed","code":"f236"},{"name":"beer","code":"f0fc"},{"name":"behance","code":"f1b4"},{"name":"behance-square","code":"f1b5"},{"name":"bell","code":"f0f3"},{"name":"bell-o","code":"f0a2"},{"name":"bell-slash","code":"f1f6"},{"name":"bell-slash-o","code":"f1f7"},{"name":"bicycle","code":"f206"},{"name":"binoculars","code":"f1e5"},{"name":"birthday-cake","code":"f1fd"},{"name":"bitbucket","code":"f171"},{"name":"bitbucket-square","code":"f172"},{"name":"bitcoin","code":"f15a"},{"name":"black-tie","code":"f27e"},{"name":"bluetooth","code":"f293"},{"name":"bluetooth-b","code":"f294"},{"name":"bold","code":"f032"},{"name":"bolt","code":"f0e7"},{"name":"bomb","code":"f1e2"},{"name":"book","code":"f02d"},{"name":"bookmark","code":"f02e"},{"name":"bookmark-o","code":"f097"},{"name":"briefcase","code":"f0b1"},{"name":"btc","code":"f15a"},{"name":"bug","code":"f188"},{"name":"building","code":"f1ad"},{"name":"building-o","code":"f0f7"},{"name":"bullhorn","code":"f0a1"},{"name":"bullseye","code":"f140"},{"name":"bus","code":"f207"},{"name":"buysellads","code":"f20d"},{"name":"cab","code":"f1ba"},{"name":"calculator","code":"f1ec"},{"name":"calendar","code":"f073"},{"name":"calendar-check-o","code":"f274"},{"name":"calendar-minus-o","code":"f272"},{"name":"calendar-o","code":"f133"},{"name":"calendar-plus-o","code":"f271"},{"name":"calendar-times-o","code":"f273"},{"name":"camera","code":"f030"},{"name":"camera-retro","code":"f083"},{"name":"car","code":"f1b9"},{"name":"caret-down","code":"f0d7"},{"name":"caret-left","code":"f0d9"},{"name":"caret-right","code":"f0da"},{"name":"caret-square-o-down","code":"f150"},{"name":"caret-square-o-left","code":"f191"},{"name":"caret-square-o-right","code":"f152"},{"name":"caret-square-o-up","code":"f151"},{"name":"caret-up","code":"f0d8"},{"name":"cart-arrow-down","code":"f218"},{"name":"cart-plus","code":"f217"},{"name":"cc","code":"f20a"},{"name":"cc-amex","code":"f1f3"},{"name":"cc-diners-club","code":"f24c"},{"name":"cc-discover","code":"f1f2"},{"name":"cc-jcb","code":"f24b"},{"name":"cc-mastercard","code":"f1f1"},{"name":"cc-paypal","code":"f1f4"},{"name":"cc-stripe","code":"f1f5"},{"name":"cc-visa","code":"f1f0"},{"name":"certificate","code":"f0a3"},{"name":"chain","code":"f0c1"},{"name":"chain-broken","code":"f127"},{"name":"check","code":"f00c"},{"name":"check-circle","code":"f058"},{"name":"check-circle-o","code":"f05d"},{"name":"check-square","code":"f14a"},{"name":"check-square-o","code":"f046"},{"name":"chevron-circle-down","code":"f13a"},{"name":"chevron-circle-left","code":"f137"},{"name":"chevron-circle-right","code":"f138"},{"name":"chevron-circle-up","code":"f139"},{"name":"chevron-down","code":"f078"},{"name":"chevron-left","code":"f053"},{"name":"chevron-right","code":"f054"},{"name":"chevron-up","code":"f077"},{"name":"child","code":"f1ae"},{"name":"chrome","code":"f268"},{"name":"circle","code":"f111"},{"name":"circle-o","code":"f10c"},{"name":"circle-o-notch","code":"f1ce"},{"name":"circle-thin","code":"f1db"},{"name":"clipboard","code":"f0ea"},{"name":"clock-o","code":"f017"},{"name":"clone","code":"f24d"},{"name":"close","code":"f00d"},{"name":"cloud","code":"f0c2"},{"name":"cloud-download","code":"f0ed"},{"name":"cloud-upload","code":"f0ee"},{"name":"cny","code":"f157"},{"name":"code","code":"f121"},{"name":"code-fork","code":"f126"},{"name":"codepen","code":"f1cb"},{"name":"codiepie","code":"f284"},{"name":"coffee","code":"f0f4"},{"name":"cog","code":"f013"},{"name":"cogs","code":"f085"},{"name":"columns","code":"f0db"},{"name":"comment","code":"f075"},{"name":"comment-o","code":"f0e5"},{"name":"commenting","code":"f27a"},{"name":"commenting-o","code":"f27b"},{"name":"comments","code":"f086"},{"name":"comments-o","code":"f0e6"},{"name":"compass","code":"f14e"},{"name":"compress","code":"f066"},{"name":"connectdevelop","code":"f20e"},{"name":"contao","code":"f26d"},{"name":"copy","code":"f0c5"},{"name":"copyright","code":"f1f9"},{"name":"creative-commons","code":"f25e"},{"name":"credit-card","code":"f09d"},{"name":"credit-card-alt","code":"f283"},{"name":"crop","code":"f125"},{"name":"crosshairs","code":"f05b"},{"name":"css3","code":"f13c"},{"name":"cube","code":"f1b2"},{"name":"cubes","code":"f1b3"},{"name":"cut","code":"f0c4"},{"name":"cutlery","code":"f0f5"},{"name":"dashboard","code":"f0e4"},{"name":"dashcube","code":"f210"},{"name":"database","code":"f1c0"},{"name":"dedent","code":"f03b"},{"name":"delicious","code":"f1a5"},{"name":"desktop","code":"f108"},{"name":"deviantart","code":"f1bd"},{"name":"diamond","code":"f219"},{"name":"digg","code":"f1a6"},{"name":"dollar","code":"f155"},{"name":"dot-circle-o","code":"f192"},{"name":"download","code":"f019"},{"name":"dribbble","code":"f17d"},{"name":"dropbox","code":"f16b"},{"name":"drupal","code":"f1a9"},{"name":"edge","code":"f282"},{"name":"edit","code":"f044"},{"name":"eject","code":"f052"},{"name":"ellipsis-h","code":"f141"},{"name":"ellipsis-v","code":"f142"},{"name":"empire","code":"f1d1"},{"name":"envelope","code":"f0e0"},{"name":"envelope-o","code":"f003"},{"name":"envelope-square","code":"f199"},{"name":"eraser","code":"f12d"},{"name":"eur","code":"f153"},{"name":"euro","code":"f153"},{"name":"exchange","code":"f0ec"},{"name":"exclamation","code":"f12a"},{"name":"exclamation-circle","code":"f06a"},{"name":"exclamation-triangle","code":"f071"},{"name":"expand","code":"f065"},{"name":"expeditedssl","code":"f23e"},{"name":"external-link","code":"f08e"},{"name":"external-link-square","code":"f14c"},{"name":"eye","code":"f06e"},{"name":"eye-slash","code":"f070"},{"name":"eyedropper","code":"f1fb"},{"name":"facebook","code":"f09a"},{"name":"facebook-f","code":"f09a"},{"name":"facebook-official","code":"f230"},{"name":"facebook-square","code":"f082"},{"name":"fast-backward","code":"f049"},{"name":"fast-forward","code":"f050"},{"name":"fax","code":"f1ac"},{"name":"feed","code":"f09e"},{"name":"female","code":"f182"},{"name":"fighter-jet","code":"f0fb"},{"name":"file","code":"f15b"},{"name":"file-archive-o","code":"f1c6"},{"name":"file-audio-o","code":"f1c7"},{"name":"file-code-o","code":"f1c9"},{"name":"file-excel-o","code":"f1c3"},{"name":"file-image-o","code":"f1c5"},{"name":"file-movie-o","code":"f1c8"},{"name":"file-o","code":"f016"},{"name":"file-pdf-o","code":"f1c1"},{"name":"file-photo-o","code":"f1c5"},{"name":"file-picture-o","code":"f1c5"},{"name":"file-powerpoint-o","code":"f1c4"},{"name":"file-sound-o","code":"f1c7"},{"name":"file-text","code":"f15c"},{"name":"file-text-o","code":"f0f6"},{"name":"file-video-o","code":"f1c8"},{"name":"file-word-o","code":"f1c2"},{"name":"file-zip-o","code":"f1c6"},{"name":"files-o","code":"f0c5"},{"name":"film","code":"f008"},{"name":"filter","code":"f0b0"},{"name":"fire","code":"f06d"},{"name":"fire-extinguisher","code":"f134"},{"name":"firefox","code":"f269"},{"name":"flag","code":"f024"},{"name":"flag-checkered","code":"f11e"},{"name":"flag-o","code":"f11d"},{"name":"flash","code":"f0e7"},{"name":"flask","code":"f0c3"},{"name":"flickr","code":"f16e"},{"name":"floppy-o","code":"f0c7"},{"name":"folder","code":"f07b"},{"name":"folder-o","code":"f114"},{"name":"folder-open","code":"f07c"},{"name":"folder-open-o","code":"f115"},{"name":"font","code":"f031"},{"name":"fonticons","code":"f280"},{"name":"fort-awesome","code":"f286"},{"name":"forumbee","code":"f211"},{"name":"forward","code":"f04e"},{"name":"foursquare","code":"f180"},{"name":"frown-o","code":"f119"},{"name":"futbol-o","code":"f1e3"},{"name":"gamepad","code":"f11b"},{"name":"gavel","code":"f0e3"},{"name":"gbp","code":"f154"},{"name":"ge","code":"f1d1"},{"name":"gear","code":"f013"},{"name":"gears","code":"f085"},{"name":"genderless","code":"f22d"},{"name":"get-pocket","code":"f265"},{"name":"gg","code":"f260"},{"name":"gg-circle","code":"f261"},{"name":"gift","code":"f06b"},{"name":"git","code":"f1d3"},{"name":"git-square","code":"f1d2"},{"name":"github","code":"f09b"},{"name":"github-alt","code":"f113"},{"name":"github-square","code":"f092"},{"name":"gittip","code":"f184"},{"name":"glass","code":"f000"},{"name":"globe","code":"f0ac"},{"name":"google","code":"f1a0"},{"name":"google-plus","code":"f0d5"},{"name":"google-plus-square","code":"f0d4"},{"name":"google-wallet","code":"f1ee"},{"name":"graduation-cap","code":"f19d"},{"name":"gratipay","code":"f184"},{"name":"group","code":"f0c0"},{"name":"h-square","code":"f0fd"},{"name":"hacker-news","code":"f1d4"},{"name":"hand-grab-o","code":"f255"},{"name":"hand-lizard-o","code":"f258"},{"name":"hand-o-down","code":"f0a7"},{"name":"hand-o-left","code":"f0a5"},{"name":"hand-o-right","code":"f0a4"},{"name":"hand-o-up","code":"f0a6"},{"name":"hand-paper-o","code":"f256"},{"name":"hand-peace-o","code":"f25b"},{"name":"hand-pointer-o","code":"f25a"},{"name":"hand-rock-o","code":"f255"},{"name":"hand-scissors-o","code":"f257"},{"name":"hand-spock-o","code":"f259"},{"name":"hand-stop-o","code":"f256"},{"name":"hashtag","code":"f292"},{"name":"hdd-o","code":"f0a0"},{"name":"header","code":"f1dc"},{"name":"headphones","code":"f025"},{"name":"heart","code":"f004"},{"name":"heart-o","code":"f08a"},{"name":"heartbeat","code":"f21e"},{"name":"history","code":"f1da"},{"name":"home","code":"f015"},{"name":"hospital-o","code":"f0f8"},{"name":"hotel","code":"f236"},{"name":"hourglass","code":"f254"},{"name":"hourglass-1","code":"f251"},{"name":"hourglass-2","code":"f252"},{"name":"hourglass-3","code":"f253"},{"name":"hourglass-end","code":"f253"},{"name":"hourglass-half","code":"f252"},{"name":"hourglass-o","code":"f250"},{"name":"hourglass-start","code":"f251"},{"name":"houzz","code":"f27c"},{"name":"html5","code":"f13b"},{"name":"i-cursor","code":"f246"},{"name":"ils","code":"f20b"},{"name":"image","code":"f03e"},{"name":"inbox","code":"f01c"},{"name":"indent","code":"f03c"},{"name":"industry","code":"f275"},{"name":"info","code":"f129"},{"name":"info-circle","code":"f05a"},{"name":"inr","code":"f156"},{"name":"instagram","code":"f16d"},{"name":"institution","code":"f19c"},{"name":"internet-explorer","code":"f26b"},{"name":"intersex","code":"f224"},{"name":"ioxhost","code":"f208"},{"name":"italic","code":"f033"},{"name":"joomla","code":"f1aa"},{"name":"jpy","code":"f157"},{"name":"jsfiddle","code":"f1cc"},{"name":"key","code":"f084"},{"name":"keyboard-o","code":"f11c"},{"name":"krw","code":"f159"},{"name":"language","code":"f1ab"},{"name":"laptop","code":"f109"},{"name":"lastfm","code":"f202"},{"name":"lastfm-square","code":"f203"},{"name":"leaf","code":"f06c"},{"name":"leanpub","code":"f212"},{"name":"legal","code":"f0e3"},{"name":"lemon-o","code":"f094"},{"name":"level-down","code":"f149"},{"name":"level-up","code":"f148"},{"name":"life-bouy","code":"f1cd"},{"name":"life-buoy","code":"f1cd"},{"name":"life-ring","code":"f1cd"},{"name":"life-saver","code":"f1cd"},{"name":"lightbulb-o","code":"f0eb"},{"name":"line-chart","code":"f201"},{"name":"link","code":"f0c1"},{"name":"linkedin","code":"f0e1"},{"name":"linkedin-square","code":"f08c"},{"name":"linux","code":"f17c"},{"name":"list","code":"f03a"},{"name":"list-alt","code":"f022"},{"name":"list-ol","code":"f0cb"},{"name":"list-ul","code":"f0ca"},{"name":"location-arrow","code":"f124"},{"name":"lock","code":"f023"},{"name":"long-arrow-down","code":"f175"},{"name":"long-arrow-left","code":"f177"},{"name":"long-arrow-right","code":"f178"},{"name":"long-arrow-up","code":"f176"},{"name":"magic","code":"f0d0"},{"name":"magnet","code":"f076"},{"name":"mail-forward","code":"f064"},{"name":"mail-reply","code":"f112"},{"name":"mail-reply-all","code":"f122"},{"name":"male","code":"f183"},{"name":"map","code":"f279"},{"name":"map-marker","code":"f041"},{"name":"map-o","code":"f278"},{"name":"map-pin","code":"f276"},{"name":"map-signs","code":"f277"},{"name":"mars","code":"f222"},{"name":"mars-double","code":"f227"},{"name":"mars-stroke","code":"f229"},{"name":"mars-stroke-h","code":"f22b"},{"name":"mars-stroke-v","code":"f22a"},{"name":"maxcdn","code":"f136"},{"name":"meanpath","code":"f20c"},{"name":"medium","code":"f23a"},{"name":"medkit","code":"f0fa"},{"name":"meh-o","code":"f11a"},{"name":"mercury","code":"f223"},{"name":"microphone","code":"f130"},{"name":"microphone-slash","code":"f131"},{"name":"minus","code":"f068"},{"name":"minus-circle","code":"f056"},{"name":"minus-square","code":"f146"},{"name":"minus-square-o","code":"f147"},{"name":"mixcloud","code":"f289"},{"name":"mobile","code":"f10b"},{"name":"mobile-phone","code":"f10b"},{"name":"modx","code":"f285"},{"name":"money","code":"f0d6"},{"name":"moon-o","code":"f186"},{"name":"mortar-board","code":"f19d"},{"name":"motorcycle","code":"f21c"},{"name":"mouse-pointer","code":"f245"},{"name":"music","code":"f001"},{"name":"navicon","code":"f0c9"},{"name":"neuter","code":"f22c"},{"name":"newspaper-o","code":"f1ea"},{"name":"object-group","code":"f247"},{"name":"object-ungroup","code":"f248"},{"name":"odnoklassniki","code":"f263"},{"name":"odnoklassniki-square","code":"f264"},{"name":"opencart","code":"f23d"},{"name":"openid","code":"f19b"},{"name":"opera","code":"f26a"},{"name":"optin-monster","code":"f23c"},{"name":"outdent","code":"f03b"},{"name":"pagelines","code":"f18c"},{"name":"paint-brush","code":"f1fc"},{"name":"paper-plane","code":"f1d8"},{"name":"paper-plane-o","code":"f1d9"},{"name":"paperclip","code":"f0c6"},{"name":"paragraph","code":"f1dd"},{"name":"paste","code":"f0ea"},{"name":"pause","code":"f04c"},{"name":"pause-circle","code":"f28b"},{"name":"pause-circle-o","code":"f28c"},{"name":"paw","code":"f1b0"},{"name":"paypal","code":"f1ed"},{"name":"pencil","code":"f040"},{"name":"pencil-square","code":"f14b"},{"name":"pencil-square-o","code":"f044"},{"name":"percent","code":"f295"},{"name":"phone","code":"f095"},{"name":"phone-square","code":"f098"},{"name":"photo","code":"f03e"},{"name":"picture-o","code":"f03e"},{"name":"pie-chart","code":"f200"},{"name":"pied-piper","code":"f1a7"},{"name":"pied-piper-alt","code":"f1a8"},{"name":"pinterest","code":"f0d2"},{"name":"pinterest-p","code":"f231"},{"name":"pinterest-square","code":"f0d3"},{"name":"plane","code":"f072"},{"name":"play","code":"f04b"},{"name":"play-circle","code":"f144"},{"name":"play-circle-o","code":"f01d"},{"name":"plug","code":"f1e6"},{"name":"plus","code":"f067"},{"name":"plus-circle","code":"f055"},{"name":"plus-square","code":"f0fe"},{"name":"plus-square-o","code":"f196"},{"name":"power-off","code":"f011"},{"name":"print","code":"f02f"},{"name":"product-hunt","code":"f288"},{"name":"puzzle-piece","code":"f12e"},{"name":"qq","code":"f1d6"},{"name":"qrcode","code":"f029"},{"name":"question","code":"f128"},{"name":"question-circle","code":"f059"},{"name":"quote-left","code":"f10d"},{"name":"quote-right","code":"f10e"},{"name":"ra","code":"f1d0"},{"name":"random","code":"f074"},{"name":"rebel","code":"f1d0"},{"name":"recycle","code":"f1b8"},{"name":"reddit","code":"f1a1"},{"name":"reddit-alien","code":"f281"},{"name":"reddit-square","code":"f1a2"},{"name":"refresh","code":"f021"},{"name":"registered","code":"f25d"},{"name":"remove","code":"f00d"},{"name":"renren","code":"f18b"},{"name":"reorder","code":"f0c9"},{"name":"repeat","code":"f01e"},{"name":"reply","code":"f112"},{"name":"reply-all","code":"f122"},{"name":"retweet","code":"f079"},{"name":"rmb","code":"f157"},{"name":"road","code":"f018"},{"name":"rocket","code":"f135"},{"name":"rotate-left","code":"f0e2"},{"name":"rotate-right","code":"f01e"},{"name":"rouble","code":"f158"},{"name":"rss","code":"f09e"},{"name":"rss-square","code":"f143"},{"name":"rub","code":"f158"},{"name":"ruble","code":"f158"},{"name":"rupee","code":"f156"},{"name":"safari","code":"f267"},{"name":"save","code":"f0c7"},{"name":"scissors","code":"f0c4"},{"name":"scribd","code":"f28a"},{"name":"search","code":"f002"},{"name":"search-minus","code":"f010"},{"name":"search-plus","code":"f00e"},{"name":"sellsy","code":"f213"},{"name":"send","code":"f1d8"},{"name":"send-o","code":"f1d9"},{"name":"server","code":"f233"},{"name":"share","code":"f064"},{"name":"share-alt","code":"f1e0"},{"name":"share-alt-square","code":"f1e1"},{"name":"share-square","code":"f14d"},{"name":"share-square-o","code":"f045"},{"name":"shekel","code":"f20b"},{"name":"sheqel","code":"f20b"},{"name":"shield","code":"f132"},{"name":"ship","code":"f21a"},{"name":"shirtsinbulk","code":"f214"},{"name":"shopping-bag","code":"f290"},{"name":"shopping-basket","code":"f291"},{"name":"shopping-cart","code":"f07a"},{"name":"sign-in","code":"f090"},{"name":"sign-out","code":"f08b"},{"name":"signal","code":"f012"},{"name":"simplybuilt","code":"f215"},{"name":"sitemap","code":"f0e8"},{"name":"skyatlas","code":"f216"},{"name":"skype","code":"f17e"},{"name":"slack","code":"f198"},{"name":"sliders","code":"f1de"},{"name":"slideshare","code":"f1e7"},{"name":"smile-o","code":"f118"},{"name":"soccer-ball-o","code":"f1e3"},{"name":"sort","code":"f0dc"},{"name":"sort-alpha-asc","code":"f15d"},{"name":"sort-alpha-desc","code":"f15e"},{"name":"sort-amount-asc","code":"f160"},{"name":"sort-amount-desc","code":"f161"},{"name":"sort-asc","code":"f0de"},{"name":"sort-desc","code":"f0dd"},{"name":"sort-down","code":"f0dd"},{"name":"sort-numeric-asc","code":"f162"},{"name":"sort-numeric-desc","code":"f163"},{"name":"sort-up","code":"f0de"},{"name":"soundcloud","code":"f1be"},{"name":"space-shuttle","code":"f197"},{"name":"spinner","code":"f110"},{"name":"spoon","code":"f1b1"},{"name":"spotify","code":"f1bc"},{"name":"square","code":"f0c8"},{"name":"square-o","code":"f096"},{"name":"stack-exchange","code":"f18d"},{"name":"stack-overflow","code":"f16c"},{"name":"star","code":"f005"},{"name":"star-half","code":"f089"},{"name":"star-half-empty","code":"f123"},{"name":"star-half-full","code":"f123"},{"name":"star-half-o","code":"f123"},{"name":"star-o","code":"f006"},{"name":"steam","code":"f1b6"},{"name":"steam-square","code":"f1b7"},{"name":"step-backward","code":"f048"},{"name":"step-forward","code":"f051"},{"name":"stethoscope","code":"f0f1"},{"name":"sticky-note","code":"f249"},{"name":"sticky-note-o","code":"f24a"},{"name":"stop","code":"f04d"},{"name":"stop-circle","code":"f28d"},{"name":"stop-circle-o","code":"f28e"},{"name":"street-view","code":"f21d"},{"name":"strikethrough","code":"f0cc"},{"name":"stumbleupon","code":"f1a4"},{"name":"stumbleupon-circle","code":"f1a3"},{"name":"subscript","code":"f12c"},{"name":"subway","code":"f239"},{"name":"suitcase","code":"f0f2"},{"name":"sun-o","code":"f185"},{"name":"superscript","code":"f12b"},{"name":"support","code":"f1cd"},{"name":"table","code":"f0ce"},{"name":"tablet","code":"f10a"},{"name":"tachometer","code":"f0e4"},{"name":"tag","code":"f02b"},{"name":"tags","code":"f02c"},{"name":"tasks","code":"f0ae"},{"name":"taxi","code":"f1ba"},{"name":"television","code":"f26c"},{"name":"tencent-weibo","code":"f1d5"},{"name":"terminal","code":"f120"},{"name":"text-height","code":"f034"},{"name":"text-width","code":"f035"},{"name":"th","code":"f00a"},{"name":"th-large","code":"f009"},{"name":"th-list","code":"f00b"},{"name":"thumb-tack","code":"f08d"},{"name":"thumbs-down","code":"f165"},{"name":"thumbs-o-down","code":"f088"},{"name":"thumbs-o-up","code":"f087"},{"name":"thumbs-up","code":"f164"},{"name":"ticket","code":"f145"},{"name":"times","code":"f00d"},{"name":"times-circle","code":"f057"},{"name":"times-circle-o","code":"f05c"},{"name":"tint","code":"f043"},{"name":"toggle-down","code":"f150"},{"name":"toggle-left","code":"f191"},{"name":"toggle-off","code":"f204"},{"name":"toggle-on","code":"f205"},{"name":"toggle-right","code":"f152"},{"name":"toggle-up","code":"f151"},{"name":"trademark","code":"f25c"},{"name":"train","code":"f238"},{"name":"transgender","code":"f224"},{"name":"transgender-alt","code":"f225"},{"name":"trash","code":"f1f8"},{"name":"trash-o","code":"f014"},{"name":"tree","code":"f1bb"},{"name":"trello","code":"f181"},{"name":"tripadvisor","code":"f262"},{"name":"trophy","code":"f091"},{"name":"truck","code":"f0d1"},{"name":"try","code":"f195"},{"name":"tty","code":"f1e4"},{"name":"tumblr","code":"f173"},{"name":"tumblr-square","code":"f174"},{"name":"turkish-lira","code":"f195"},{"name":"tv","code":"f26c"},{"name":"twitch","code":"f1e8"},{"name":"twitter","code":"f099"},{"name":"twitter-square","code":"f081"},{"name":"umbrella","code":"f0e9"},{"name":"underline","code":"f0cd"},{"name":"undo","code":"f0e2"},{"name":"university","code":"f19c"},{"name":"unlink","code":"f127"},{"name":"unlock","code":"f09c"},{"name":"unlock-alt","code":"f13e"},{"name":"unsorted","code":"f0dc"},{"name":"upload","code":"f093"},{"name":"usb","code":"f287"},{"name":"usd","code":"f155"},{"name":"user","code":"f007"},{"name":"user-md","code":"f0f0"},{"name":"user-plus","code":"f234"},{"name":"user-secret","code":"f21b"},{"name":"user-times","code":"f235"},{"name":"users","code":"f0c0"},{"name":"venus","code":"f221"},{"name":"venus-double","code":"f226"},{"name":"venus-mars","code":"f228"},{"name":"viacoin","code":"f237"},{"name":"video-camera","code":"f03d"},{"name":"vimeo","code":"f27d"},{"name":"vimeo-square","code":"f194"},{"name":"vine","code":"f1ca"},{"name":"vk","code":"f189"},{"name":"volume-down","code":"f027"},{"name":"volume-off","code":"f026"},{"name":"volume-up","code":"f028"},{"name":"warning","code":"f071"},{"name":"wechat","code":"f1d7"},{"name":"weibo","code":"f18a"},{"name":"weixin","code":"f1d7"},{"name":"whatsapp","code":"f232"},{"name":"wheelchair","code":"f193"},{"name":"wifi","code":"f1eb"},{"name":"wikipedia-w","code":"f266"},{"name":"windows","code":"f17a"},{"name":"won","code":"f159"},{"name":"wordpress","code":"f19a"},{"name":"wrench","code":"f0ad"},{"name":"xing","code":"f168"},{"name":"xing-square","code":"f169"},{"name":"y-combinator","code":"f23b"},{"name":"y-combinator-square","code":"f1d4"},{"name":"yahoo","code":"f19e"},{"name":"yc","code":"f23b"},{"name":"yc-square","code":"f1d4"},{"name":"yelp","code":"f1e9"},{"name":"yen","code":"f157"},{"name":"youtube","code":"f167"},{"name":"youtube-play","code":"f16a"},{"name":"youtube-square","code":"f166"}];
};

GS.lorem = function () {
    return 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.';
};

if (!String.prototype.repeat) {
  String.prototype.repeat = function(count) {
    'use strict';
    if (this == null) {
      throw new TypeError('can\'t convert ' + this + ' to object');
    }
    var str = '' + this;
    count = +count;
    if (count != count) {
      count = 0;
    }
    if (count < 0) {
      throw new RangeError('repeat count must be non-negative');
    }
    if (count == Infinity) {
      throw new RangeError('repeat count must be less than infinity');
    }
    count = Math.floor(count);
    if (str.length == 0 || count == 0) {
      return '';
    }
    // Ensuring count is a 31-bit integer allows us to heavily optimize the
    // main part. But anyway, most current (August 2014) browsers can't handle
    // strings 1 << 28 chars or longer, so:
    if (str.length * count >= 1 << 28) {
      throw new RangeError('repeat count must not overflow maximum string size');
    }
    var rpt = '';
    for (;;) {
      if ((count & 1) == 1) {
        rpt += str;
      }
      count >>>= 1;
      if (count == 0) {
        break;
      }
      str += str;
    }
    // Could we try:
    // return Array(count + 1).join(this);
    return rpt;
  }
}
if (!String.prototype.trim) {
  String.prototype.trim = function () {
    return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
  };
}(function (root, factory) {
    // CommonJS
    if (typeof exports === "object") {
        module.exports = exports = factory();

    // AMD
    } else if (typeof define === "function" && define.amd) {
        define([], factory);

    // Global (browser)
    } else {
        root.CryptoJS = factory();
    }
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /*
	     * Local polyfil of Object.create
	     */
	    var create = Object.create || (function () {
	        function F() {};

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	/** @preserve
	(c) 2012 by CÃ©dric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var _zl = WordArray.create([
	        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);
	    var _zr = WordArray.create([
	        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);
	    var _sl = WordArray.create([
	         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);
	    var _sr = WordArray.create([
	        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);

	    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
	    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);

	    /**
	     * RIPEMD160 hash algorithm.
	     */
	    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
	        _doReset: function () {
	            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
	        },

	        _doProcessBlock: function (M, offset) {

	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                // Swap
	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }
	            // Shortcut
	            var H  = this._hash.words;
	            var hl = _hl.words;
	            var hr = _hr.words;
	            var zl = _zl.words;
	            var zr = _zr.words;
	            var sl = _sl.words;
	            var sr = _sr.words;

	            // Working variables
	            var al, bl, cl, dl, el;
	            var ar, br, cr, dr, er;

	            ar = al = H[0];
	            br = bl = H[1];
	            cr = cl = H[2];
	            dr = dl = H[3];
	            er = el = H[4];
	            // Computation
	            var t;
	            for (var i = 0; i < 80; i += 1) {
	                t = (al +  M[offset+zl[i]])|0;
	                if (i<16){
		            t +=  f1(bl,cl,dl) + hl[0];
	                } else if (i<32) {
		            t +=  f2(bl,cl,dl) + hl[1];
	                } else if (i<48) {
		            t +=  f3(bl,cl,dl) + hl[2];
	                } else if (i<64) {
		            t +=  f4(bl,cl,dl) + hl[3];
	                } else {// if (i<80) {
		            t +=  f5(bl,cl,dl) + hl[4];
	                }
	                t = t|0;
	                t =  rotl(t,sl[i]);
	                t = (t+el)|0;
	                al = el;
	                el = dl;
	                dl = rotl(cl, 10);
	                cl = bl;
	                bl = t;

	                t = (ar + M[offset+zr[i]])|0;
	                if (i<16){
		            t +=  f5(br,cr,dr) + hr[0];
	                } else if (i<32) {
		            t +=  f4(br,cr,dr) + hr[1];
	                } else if (i<48) {
		            t +=  f3(br,cr,dr) + hr[2];
	                } else if (i<64) {
		            t +=  f2(br,cr,dr) + hr[3];
	                } else {// if (i<80) {
		            t +=  f1(br,cr,dr) + hr[4];
	                }
	                t = t|0;
	                t =  rotl(t,sr[i]) ;
	                t = (t+er)|0;
	                ar = er;
	                er = dr;
	                dr = rotl(cr, 10);
	                cr = br;
	                br = t;
	            }
	            // Intermediate hash value
	            t    = (H[1] + cl + dr)|0;
	            H[1] = (H[2] + dl + er)|0;
	            H[2] = (H[3] + el + ar)|0;
	            H[3] = (H[4] + al + br)|0;
	            H[4] = (H[0] + bl + cr)|0;
	            H[0] =  t;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	            );
	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 5; i++) {
	                // Shortcut
	                var H_i = H[i];

	                // Swap
	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });


	    function f1(x, y, z) {
	        return ((x) ^ (y) ^ (z));

	    }

	    function f2(x, y, z) {
	        return (((x)&(y)) | ((~x)&(z)));
	    }

	    function f3(x, y, z) {
	        return (((x) | (~(y))) ^ (z));
	    }

	    function f4(x, y, z) {
	        return (((x) & (z)) | ((y)&(~(z))));
	    }

	    function f5(x, y, z) {
	        return ((x) ^ ((y) |(~(z))));

	    }

	    function rotl(x,n) {
	        return (x<<n) | (x>>>(32-n));
	    }


	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.RIPEMD160('message');
	     *     var hash = CryptoJS.RIPEMD160(wordArray);
	     */
	    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
	     */
	    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
	}(Math));


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA1 = C_algo.SHA1;
	    var HMAC = C_algo.HMAC;

	    /**
	     * Password-Based Key Derivation Function 2 algorithm.
	     */
	    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hasher to use. Default: SHA1
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: SHA1,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.PBKDF2.create();
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Computes the Password-Based Key Derivation Function 2.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init HMAC
	            var hmac = HMAC.create(cfg.hasher, password);

	            // Initial values
	            var derivedKey = WordArray.create();
	            var blockIndex = WordArray.create([0x00000001]);

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var blockIndexWords = blockIndex.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                var block = hmac.update(salt).finalize(blockIndex);
	                hmac.reset();

	                // Shortcuts
	                var blockWords = block.words;
	                var blockWordsLength = blockWords.length;

	                // Iterations
	                var intermediate = block;
	                for (var i = 1; i < iterations; i++) {
	                    intermediate = hmac.finalize(intermediate);
	                    hmac.reset();

	                    // Shortcut
	                    var intermediateWords = intermediate.words;

	                    // XOR intermediate with block
	                    for (var j = 0; j < blockWordsLength; j++) {
	                        blockWords[j] ^= intermediateWords[j];
	                    }
	                }

	                derivedKey.concat(block);
	                blockIndexWords[0]++;
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Computes the Password-Based Key Derivation Function 2.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.PBKDF2(password, salt);
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.PBKDF2 = function (password, salt, cfg) {
	        return PBKDF2.create(cfg).compute(password, salt);
	    };
	}());


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                var block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA256 = C_algo.SHA256;

	    /**
	     * SHA-224 hash algorithm.
	     */
	    var SHA224 = C_algo.SHA224 = SHA256.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA256._doFinalize.call(this);

	            hash.sigBytes -= 4;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA224('message');
	     *     var hash = CryptoJS.SHA224(wordArray);
	     */
	    C.SHA224 = SHA256._createHelper(SHA224);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA224(message, key);
	     */
	    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
	}());


	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var X32WordArray = C_lib.WordArray;

	    /**
	     * x64 namespace.
	     */
	    var C_x64 = C.x64 = {};

	    /**
	     * A 64-bit word.
	     */
	    var X64Word = C_x64.Word = Base.extend({
	        /**
	         * Initializes a newly created 64-bit word.
	         *
	         * @param {number} high The high 32 bits.
	         * @param {number} low The low 32 bits.
	         *
	         * @example
	         *
	         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
	         */
	        init: function (high, low) {
	            this.high = high;
	            this.low = low;
	        }

	        /**
	         * Bitwise NOTs this word.
	         *
	         * @return {X64Word} A new x64-Word object after negating.
	         *
	         * @example
	         *
	         *     var negated = x64Word.not();
	         */
	        // not: function () {
	            // var high = ~this.high;
	            // var low = ~this.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ANDs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to AND with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ANDing.
	         *
	         * @example
	         *
	         *     var anded = x64Word.and(anotherX64Word);
	         */
	        // and: function (word) {
	            // var high = this.high & word.high;
	            // var low = this.low & word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to OR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ORing.
	         *
	         * @example
	         *
	         *     var ored = x64Word.or(anotherX64Word);
	         */
	        // or: function (word) {
	            // var high = this.high | word.high;
	            // var low = this.low | word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise XORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to XOR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after XORing.
	         *
	         * @example
	         *
	         *     var xored = x64Word.xor(anotherX64Word);
	         */
	        // xor: function (word) {
	            // var high = this.high ^ word.high;
	            // var low = this.low ^ word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the left.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftL(25);
	         */
	        // shiftL: function (n) {
	            // if (n < 32) {
	                // var high = (this.high << n) | (this.low >>> (32 - n));
	                // var low = this.low << n;
	            // } else {
	                // var high = this.low << (n - 32);
	                // var low = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the right.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftR(7);
	         */
	        // shiftR: function (n) {
	            // if (n < 32) {
	                // var low = (this.low >>> n) | (this.high << (32 - n));
	                // var high = this.high >>> n;
	            // } else {
	                // var low = this.high >>> (n - 32);
	                // var high = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Rotates this word n bits to the left.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotL(25);
	         */
	        // rotL: function (n) {
	            // return this.shiftL(n).or(this.shiftR(64 - n));
	        // },

	        /**
	         * Rotates this word n bits to the right.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotR(7);
	         */
	        // rotR: function (n) {
	            // return this.shiftR(n).or(this.shiftL(64 - n));
	        // },

	        /**
	         * Adds this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to add with this word.
	         *
	         * @return {X64Word} A new x64-Word object after adding.
	         *
	         * @example
	         *
	         *     var added = x64Word.add(anotherX64Word);
	         */
	        // add: function (word) {
	            // var low = (this.low + word.low) | 0;
	            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
	            // var high = (this.high + word.high + carry) | 0;

	            // return X64Word.create(high, low);
	        // }
	    });

	    /**
	     * An array of 64-bit words.
	     *
	     * @property {Array} words The array of CryptoJS.x64.Word objects.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var X64WordArray = C_x64.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create();
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ]);
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ], 10);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 8;
	            }
	        },

	        /**
	         * Converts this 64-bit word array to a 32-bit word array.
	         *
	         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
	         *
	         * @example
	         *
	         *     var x32WordArray = x64WordArray.toX32();
	         */
	        toX32: function () {
	            // Shortcuts
	            var x64Words = this.words;
	            var x64WordsLength = x64Words.length;

	            // Convert
	            var x32Words = [];
	            for (var i = 0; i < x64WordsLength; i++) {
	                var x64Word = x64Words[i];
	                x32Words.push(x64Word.high);
	                x32Words.push(x64Word.low);
	            }

	            return X32WordArray.create(x32Words, this.sigBytes);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {X64WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = x64WordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);

	            // Clone "words" array
	            var words = clone.words = this.words.slice(0);

	            // Clone each X64Word object
	            var wordsLength = words.length;
	            for (var i = 0; i < wordsLength; i++) {
	                words[i] = words[i].clone();
	            }

	            return clone;
	        }
	    });
	}());


	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var C_algo = C.algo;

	    // Constants tables
	    var RHO_OFFSETS = [];
	    var PI_INDEXES  = [];
	    var ROUND_CONSTANTS = [];

	    // Compute Constants
	    (function () {
	        // Compute rho offset constants
	        var x = 1, y = 0;
	        for (var t = 0; t < 24; t++) {
	            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;

	            var newX = y % 5;
	            var newY = (2 * x + 3 * y) % 5;
	            x = newX;
	            y = newY;
	        }

	        // Compute pi index constants
	        for (var x = 0; x < 5; x++) {
	            for (var y = 0; y < 5; y++) {
	                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
	            }
	        }

	        // Compute round constants
	        var LFSR = 0x01;
	        for (var i = 0; i < 24; i++) {
	            var roundConstantMsw = 0;
	            var roundConstantLsw = 0;

	            for (var j = 0; j < 7; j++) {
	                if (LFSR & 0x01) {
	                    var bitPosition = (1 << j) - 1;
	                    if (bitPosition < 32) {
	                        roundConstantLsw ^= 1 << bitPosition;
	                    } else /* if (bitPosition >= 32) */ {
	                        roundConstantMsw ^= 1 << (bitPosition - 32);
	                    }
	                }

	                // Compute next LFSR
	                if (LFSR & 0x80) {
	                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
	                    LFSR = (LFSR << 1) ^ 0x71;
	                } else {
	                    LFSR <<= 1;
	                }
	            }

	            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
	        }
	    }());

	    // Reusable objects for temporary values
	    var T = [];
	    (function () {
	        for (var i = 0; i < 25; i++) {
	            T[i] = X64Word.create();
	        }
	    }());

	    /**
	     * SHA-3 hash algorithm.
	     */
	    var SHA3 = C_algo.SHA3 = Hasher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} outputLength
	         *   The desired number of bits in the output hash.
	         *   Only values permitted are: 224, 256, 384, 512.
	         *   Default: 512
	         */
	        cfg: Hasher.cfg.extend({
	            outputLength: 512
	        }),

	        _doReset: function () {
	            var state = this._state = []
	            for (var i = 0; i < 25; i++) {
	                state[i] = new X64Word.init();
	            }

	            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var state = this._state;
	            var nBlockSizeLanes = this.blockSize / 2;

	            // Absorb
	            for (var i = 0; i < nBlockSizeLanes; i++) {
	                // Shortcuts
	                var M2i  = M[offset + 2 * i];
	                var M2i1 = M[offset + 2 * i + 1];

	                // Swap endian
	                M2i = (
	                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |
	                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)
	                );
	                M2i1 = (
	                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |
	                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)
	                );

	                // Absorb message into state
	                var lane = state[i];
	                lane.high ^= M2i1;
	                lane.low  ^= M2i;
	            }

	            // Rounds
	            for (var round = 0; round < 24; round++) {
	                // Theta
	                for (var x = 0; x < 5; x++) {
	                    // Mix column lanes
	                    var tMsw = 0, tLsw = 0;
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        tMsw ^= lane.high;
	                        tLsw ^= lane.low;
	                    }

	                    // Temporary values
	                    var Tx = T[x];
	                    Tx.high = tMsw;
	                    Tx.low  = tLsw;
	                }
	                for (var x = 0; x < 5; x++) {
	                    // Shortcuts
	                    var Tx4 = T[(x + 4) % 5];
	                    var Tx1 = T[(x + 1) % 5];
	                    var Tx1Msw = Tx1.high;
	                    var Tx1Lsw = Tx1.low;

	                    // Mix surrounding columns
	                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
	                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        lane.high ^= tMsw;
	                        lane.low  ^= tLsw;
	                    }
	                }

	                // Rho Pi
	                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
	                    // Shortcuts
	                    var lane = state[laneIndex];
	                    var laneMsw = lane.high;
	                    var laneLsw = lane.low;
	                    var rhoOffset = RHO_OFFSETS[laneIndex];

	                    // Rotate lanes
	                    if (rhoOffset < 32) {
	                        var tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
	                        var tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
	                    } else /* if (rhoOffset >= 32) */ {
	                        var tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
	                        var tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
	                    }

	                    // Transpose lanes
	                    var TPiLane = T[PI_INDEXES[laneIndex]];
	                    TPiLane.high = tMsw;
	                    TPiLane.low  = tLsw;
	                }

	                // Rho pi at x = y = 0
	                var T0 = T[0];
	                var state0 = state[0];
	                T0.high = state0.high;
	                T0.low  = state0.low;

	                // Chi
	                for (var x = 0; x < 5; x++) {
	                    for (var y = 0; y < 5; y++) {
	                        // Shortcuts
	                        var laneIndex = x + 5 * y;
	                        var lane = state[laneIndex];
	                        var TLane = T[laneIndex];
	                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];
	                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];

	                        // Mix rows
	                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
	                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);
	                    }
	                }

	                // Iota
	                var lane = state[0];
	                var roundConstant = ROUND_CONSTANTS[round];
	                lane.high ^= roundConstant.high;
	                lane.low  ^= roundConstant.low;;
	            }
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;
	            var blockSizeBits = this.blockSize * 32;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
	            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var state = this._state;
	            var outputLengthBytes = this.cfg.outputLength / 8;
	            var outputLengthLanes = outputLengthBytes / 8;

	            // Squeeze
	            var hashWords = [];
	            for (var i = 0; i < outputLengthLanes; i++) {
	                // Shortcuts
	                var lane = state[i];
	                var laneMsw = lane.high;
	                var laneLsw = lane.low;

	                // Swap endian
	                laneMsw = (
	                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |
	                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)
	                );
	                laneLsw = (
	                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |
	                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)
	                );

	                // Squeeze state to retrieve hash
	                hashWords.push(laneLsw);
	                hashWords.push(laneMsw);
	            }

	            // Return final computed hash
	            return new WordArray.init(hashWords, outputLengthBytes);
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);

	            var state = clone._state = this._state.slice(0);
	            for (var i = 0; i < 25; i++) {
	                state[i] = state[i].clone();
	            }

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA3('message');
	     *     var hash = CryptoJS.SHA3(wordArray);
	     */
	    C.SHA3 = Hasher._createHelper(SHA3);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA3(message, key);
	     */
	    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
	}(Math));


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;

	    function X64Word_create() {
	        return X64Word.create.apply(X64Word, arguments);
	    }

	    // Constants
	    var K = [
	        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
	        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
	        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
	        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
	        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
	        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
	        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
	        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
	        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
	        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
	        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
	        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
	        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
	        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
	        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
	        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
	        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
	        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
	        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
	        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
	        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
	        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
	        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
	        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
	        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
	        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
	        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
	        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
	        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
	        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
	        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
	        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
	        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
	        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
	        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
	        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
	        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
	        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
	        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
	        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
	    ];

	    // Reusable objects
	    var W = [];
	    (function () {
	        for (var i = 0; i < 80; i++) {
	            W[i] = X64Word_create();
	        }
	    }());

	    /**
	     * SHA-512 hash algorithm.
	     */
	    var SHA512 = C_algo.SHA512 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
	                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
	                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
	                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var H = this._hash.words;

	            var H0 = H[0];
	            var H1 = H[1];
	            var H2 = H[2];
	            var H3 = H[3];
	            var H4 = H[4];
	            var H5 = H[5];
	            var H6 = H[6];
	            var H7 = H[7];

	            var H0h = H0.high;
	            var H0l = H0.low;
	            var H1h = H1.high;
	            var H1l = H1.low;
	            var H2h = H2.high;
	            var H2l = H2.low;
	            var H3h = H3.high;
	            var H3l = H3.low;
	            var H4h = H4.high;
	            var H4l = H4.low;
	            var H5h = H5.high;
	            var H5l = H5.low;
	            var H6h = H6.high;
	            var H6l = H6.low;
	            var H7h = H7.high;
	            var H7l = H7.low;

	            // Working variables
	            var ah = H0h;
	            var al = H0l;
	            var bh = H1h;
	            var bl = H1l;
	            var ch = H2h;
	            var cl = H2l;
	            var dh = H3h;
	            var dl = H3l;
	            var eh = H4h;
	            var el = H4l;
	            var fh = H5h;
	            var fl = H5l;
	            var gh = H6h;
	            var gl = H6l;
	            var hh = H7h;
	            var hl = H7l;

	            // Rounds
	            for (var i = 0; i < 80; i++) {
	                // Shortcut
	                var Wi = W[i];

	                // Extend message
	                if (i < 16) {
	                    var Wih = Wi.high = M[offset + i * 2]     | 0;
	                    var Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
	                } else {
	                    // Gamma0
	                    var gamma0x  = W[i - 15];
	                    var gamma0xh = gamma0x.high;
	                    var gamma0xl = gamma0x.low;
	                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
	                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

	                    // Gamma1
	                    var gamma1x  = W[i - 2];
	                    var gamma1xh = gamma1x.high;
	                    var gamma1xl = gamma1x.low;
	                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
	                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

	                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	                    var Wi7  = W[i - 7];
	                    var Wi7h = Wi7.high;
	                    var Wi7l = Wi7.low;

	                    var Wi16  = W[i - 16];
	                    var Wi16h = Wi16.high;
	                    var Wi16l = Wi16.low;

	                    var Wil = gamma0l + Wi7l;
	                    var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
	                    var Wil = Wil + gamma1l;
	                    var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
	                    var Wil = Wil + Wi16l;
	                    var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

	                    Wi.high = Wih;
	                    Wi.low  = Wil;
	                }

	                var chh  = (eh & fh) ^ (~eh & gh);
	                var chl  = (el & fl) ^ (~el & gl);
	                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
	                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

	                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
	                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
	                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
	                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

	                // t1 = h + sigma1 + ch + K[i] + W[i]
	                var Ki  = K[i];
	                var Kih = Ki.high;
	                var Kil = Ki.low;

	                var t1l = hl + sigma1l;
	                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
	                var t1l = t1l + chl;
	                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
	                var t1l = t1l + Kil;
	                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
	                var t1l = t1l + Wil;
	                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

	                // t2 = sigma0 + maj
	                var t2l = sigma0l + majl;
	                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

	                // Update working variables
	                hh = gh;
	                hl = gl;
	                gh = fh;
	                gl = fl;
	                fh = eh;
	                fl = el;
	                el = (dl + t1l) | 0;
	                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
	                dh = ch;
	                dl = cl;
	                ch = bh;
	                cl = bl;
	                bh = ah;
	                bl = al;
	                al = (t1l + t2l) | 0;
	                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
	            }

	            // Intermediate hash value
	            H0l = H0.low  = (H0l + al);
	            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
	            H1l = H1.low  = (H1l + bl);
	            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
	            H2l = H2.low  = (H2l + cl);
	            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
	            H3l = H3.low  = (H3l + dl);
	            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
	            H4l = H4.low  = (H4l + el);
	            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
	            H5l = H5.low  = (H5l + fl);
	            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
	            H6l = H6.low  = (H6l + gl);
	            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
	            H7l = H7.low  = (H7l + hl);
	            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Convert hash to 32-bit word array before returning
	            var hash = this._hash.toX32();

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        },

	        blockSize: 1024/32
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA512('message');
	     *     var hash = CryptoJS.SHA512(wordArray);
	     */
	    C.SHA512 = Hasher._createHelper(SHA512);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA512(message, key);
	     */
	    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
	}());


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;
	    var SHA512 = C_algo.SHA512;

	    /**
	     * SHA-384 hash algorithm.
	     */
	    var SHA384 = C_algo.SHA384 = SHA512.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
	                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
	                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
	                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA512._doFinalize.call(this);

	            hash.sigBytes -= 16;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA384('message');
	     *     var hash = CryptoJS.SHA384(wordArray);
	     */
	    C.SHA384 = SHA512._createHelper(SHA384);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA384(message, key);
	     */
	    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
	}());


	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                var block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                var block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                var modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                var modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                var wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                var salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


	/**
	 * Cipher Feedback block mode.
	 */
	CryptoJS.mode.CFB = (function () {
	    var CFB = CryptoJS.lib.BlockCipherMode.extend();

	    CFB.Encryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // Remember this block to use with next block
	            this._prevBlock = words.slice(offset, offset + blockSize);
	        }
	    });

	    CFB.Decryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            // Remember this block to use with next block
	            var thisBlock = words.slice(offset, offset + blockSize);

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // This block becomes the previous block
	            this._prevBlock = thisBlock;
	        }
	    });

	    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
	        // Shortcut
	        var iv = this._iv;

	        // Generate keystream
	        if (iv) {
	            var keystream = iv.slice(0);

	            // Remove IV for subsequent blocks
	            this._iv = undefined;
	        } else {
	            var keystream = this._prevBlock;
	        }
	        cipher.encryptBlock(keystream, 0);

	        // Encrypt
	        for (var i = 0; i < blockSize; i++) {
	            words[offset + i] ^= keystream[i];
	        }
	    }

	    return CFB;
	}());


	/**
	 * Electronic Codebook block mode.
	 */
	CryptoJS.mode.ECB = (function () {
	    var ECB = CryptoJS.lib.BlockCipherMode.extend();

	    ECB.Encryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.encryptBlock(words, offset);
	        }
	    });

	    ECB.Decryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.decryptBlock(words, offset);
	        }
	    });

	    return ECB;
	}());


	/**
	 * ANSI X.923 padding strategy.
	 */
	CryptoJS.pad.AnsiX923 = {
	    pad: function (data, blockSize) {
	        // Shortcuts
	        var dataSigBytes = data.sigBytes;
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;

	        // Compute last byte position
	        var lastBytePos = dataSigBytes + nPaddingBytes - 1;

	        // Pad
	        data.clamp();
	        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
	        data.sigBytes += nPaddingBytes;
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	/**
	 * ISO 10126 padding strategy.
	 */
	CryptoJS.pad.Iso10126 = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	        // Pad
	        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
	             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	/**
	 * ISO/IEC 9797-1 Padding Method 2.
	 */
	CryptoJS.pad.Iso97971 = {
	    pad: function (data, blockSize) {
	        // Add 0x80 byte
	        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

	        // Zero pad the rest
	        CryptoJS.pad.ZeroPadding.pad(data, blockSize);
	    },

	    unpad: function (data) {
	        // Remove zero padding
	        CryptoJS.pad.ZeroPadding.unpad(data);

	        // Remove one more byte -- the 0x80 byte
	        data.sigBytes--;
	    }
	};


	/**
	 * Output Feedback block mode.
	 */
	CryptoJS.mode.OFB = (function () {
	    var OFB = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = OFB.Encryptor = OFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var keystream = this._keystream;

	            // Generate keystream
	            if (iv) {
	                keystream = this._keystream = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    OFB.Decryptor = Encryptor;

	    return OFB;
	}());


	/**
	 * A noop padding strategy.
	 */
	CryptoJS.pad.NoPadding = {
	    pad: function () {
	    },

	    unpad: function () {
	    }
	};


	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Permuted Choice 1 constants
	    var PC1 = [
	        57, 49, 41, 33, 25, 17, 9,  1,
	        58, 50, 42, 34, 26, 18, 10, 2,
	        59, 51, 43, 35, 27, 19, 11, 3,
	        60, 52, 44, 36, 63, 55, 47, 39,
	        31, 23, 15, 7,  62, 54, 46, 38,
	        30, 22, 14, 6,  61, 53, 45, 37,
	        29, 21, 13, 5,  28, 20, 12, 4
	    ];

	    // Permuted Choice 2 constants
	    var PC2 = [
	        14, 17, 11, 24, 1,  5,
	        3,  28, 15, 6,  21, 10,
	        23, 19, 12, 4,  26, 8,
	        16, 7,  27, 20, 13, 2,
	        41, 52, 31, 37, 47, 55,
	        30, 40, 51, 45, 33, 48,
	        44, 49, 39, 56, 34, 53,
	        46, 42, 50, 36, 29, 32
	    ];

	    // Cumulative bit shift constants
	    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

	    // SBOXes and round permutation constants
	    var SBOX_P = [
	        {
	            0x0: 0x808200,
	            0x10000000: 0x8000,
	            0x20000000: 0x808002,
	            0x30000000: 0x2,
	            0x40000000: 0x200,
	            0x50000000: 0x808202,
	            0x60000000: 0x800202,
	            0x70000000: 0x800000,
	            0x80000000: 0x202,
	            0x90000000: 0x800200,
	            0xa0000000: 0x8200,
	            0xb0000000: 0x808000,
	            0xc0000000: 0x8002,
	            0xd0000000: 0x800002,
	            0xe0000000: 0x0,
	            0xf0000000: 0x8202,
	            0x8000000: 0x0,
	            0x18000000: 0x808202,
	            0x28000000: 0x8202,
	            0x38000000: 0x8000,
	            0x48000000: 0x808200,
	            0x58000000: 0x200,
	            0x68000000: 0x808002,
	            0x78000000: 0x2,
	            0x88000000: 0x800200,
	            0x98000000: 0x8200,
	            0xa8000000: 0x808000,
	            0xb8000000: 0x800202,
	            0xc8000000: 0x800002,
	            0xd8000000: 0x8002,
	            0xe8000000: 0x202,
	            0xf8000000: 0x800000,
	            0x1: 0x8000,
	            0x10000001: 0x2,
	            0x20000001: 0x808200,
	            0x30000001: 0x800000,
	            0x40000001: 0x808002,
	            0x50000001: 0x8200,
	            0x60000001: 0x200,
	            0x70000001: 0x800202,
	            0x80000001: 0x808202,
	            0x90000001: 0x808000,
	            0xa0000001: 0x800002,
	            0xb0000001: 0x8202,
	            0xc0000001: 0x202,
	            0xd0000001: 0x800200,
	            0xe0000001: 0x8002,
	            0xf0000001: 0x0,
	            0x8000001: 0x808202,
	            0x18000001: 0x808000,
	            0x28000001: 0x800000,
	            0x38000001: 0x200,
	            0x48000001: 0x8000,
	            0x58000001: 0x800002,
	            0x68000001: 0x2,
	            0x78000001: 0x8202,
	            0x88000001: 0x8002,
	            0x98000001: 0x800202,
	            0xa8000001: 0x202,
	            0xb8000001: 0x808200,
	            0xc8000001: 0x800200,
	            0xd8000001: 0x0,
	            0xe8000001: 0x8200,
	            0xf8000001: 0x808002
	        },
	        {
	            0x0: 0x40084010,
	            0x1000000: 0x4000,
	            0x2000000: 0x80000,
	            0x3000000: 0x40080010,
	            0x4000000: 0x40000010,
	            0x5000000: 0x40084000,
	            0x6000000: 0x40004000,
	            0x7000000: 0x10,
	            0x8000000: 0x84000,
	            0x9000000: 0x40004010,
	            0xa000000: 0x40000000,
	            0xb000000: 0x84010,
	            0xc000000: 0x80010,
	            0xd000000: 0x0,
	            0xe000000: 0x4010,
	            0xf000000: 0x40080000,
	            0x800000: 0x40004000,
	            0x1800000: 0x84010,
	            0x2800000: 0x10,
	            0x3800000: 0x40004010,
	            0x4800000: 0x40084010,
	            0x5800000: 0x40000000,
	            0x6800000: 0x80000,
	            0x7800000: 0x40080010,
	            0x8800000: 0x80010,
	            0x9800000: 0x0,
	            0xa800000: 0x4000,
	            0xb800000: 0x40080000,
	            0xc800000: 0x40000010,
	            0xd800000: 0x84000,
	            0xe800000: 0x40084000,
	            0xf800000: 0x4010,
	            0x10000000: 0x0,
	            0x11000000: 0x40080010,
	            0x12000000: 0x40004010,
	            0x13000000: 0x40084000,
	            0x14000000: 0x40080000,
	            0x15000000: 0x10,
	            0x16000000: 0x84010,
	            0x17000000: 0x4000,
	            0x18000000: 0x4010,
	            0x19000000: 0x80000,
	            0x1a000000: 0x80010,
	            0x1b000000: 0x40000010,
	            0x1c000000: 0x84000,
	            0x1d000000: 0x40004000,
	            0x1e000000: 0x40000000,
	            0x1f000000: 0x40084010,
	            0x10800000: 0x84010,
	            0x11800000: 0x80000,
	            0x12800000: 0x40080000,
	            0x13800000: 0x4000,
	            0x14800000: 0x40004000,
	            0x15800000: 0x40084010,
	            0x16800000: 0x10,
	            0x17800000: 0x40000000,
	            0x18800000: 0x40084000,
	            0x19800000: 0x40000010,
	            0x1a800000: 0x40004010,
	            0x1b800000: 0x80010,
	            0x1c800000: 0x0,
	            0x1d800000: 0x4010,
	            0x1e800000: 0x40080010,
	            0x1f800000: 0x84000
	        },
	        {
	            0x0: 0x104,
	            0x100000: 0x0,
	            0x200000: 0x4000100,
	            0x300000: 0x10104,
	            0x400000: 0x10004,
	            0x500000: 0x4000004,
	            0x600000: 0x4010104,
	            0x700000: 0x4010000,
	            0x800000: 0x4000000,
	            0x900000: 0x4010100,
	            0xa00000: 0x10100,
	            0xb00000: 0x4010004,
	            0xc00000: 0x4000104,
	            0xd00000: 0x10000,
	            0xe00000: 0x4,
	            0xf00000: 0x100,
	            0x80000: 0x4010100,
	            0x180000: 0x4010004,
	            0x280000: 0x0,
	            0x380000: 0x4000100,
	            0x480000: 0x4000004,
	            0x580000: 0x10000,
	            0x680000: 0x10004,
	            0x780000: 0x104,
	            0x880000: 0x4,
	            0x980000: 0x100,
	            0xa80000: 0x4010000,
	            0xb80000: 0x10104,
	            0xc80000: 0x10100,
	            0xd80000: 0x4000104,
	            0xe80000: 0x4010104,
	            0xf80000: 0x4000000,
	            0x1000000: 0x4010100,
	            0x1100000: 0x10004,
	            0x1200000: 0x10000,
	            0x1300000: 0x4000100,
	            0x1400000: 0x100,
	            0x1500000: 0x4010104,
	            0x1600000: 0x4000004,
	            0x1700000: 0x0,
	            0x1800000: 0x4000104,
	            0x1900000: 0x4000000,
	            0x1a00000: 0x4,
	            0x1b00000: 0x10100,
	            0x1c00000: 0x4010000,
	            0x1d00000: 0x104,
	            0x1e00000: 0x10104,
	            0x1f00000: 0x4010004,
	            0x1080000: 0x4000000,
	            0x1180000: 0x104,
	            0x1280000: 0x4010100,
	            0x1380000: 0x0,
	            0x1480000: 0x10004,
	            0x1580000: 0x4000100,
	            0x1680000: 0x100,
	            0x1780000: 0x4010004,
	            0x1880000: 0x10000,
	            0x1980000: 0x4010104,
	            0x1a80000: 0x10104,
	            0x1b80000: 0x4000004,
	            0x1c80000: 0x4000104,
	            0x1d80000: 0x4010000,
	            0x1e80000: 0x4,
	            0x1f80000: 0x10100
	        },
	        {
	            0x0: 0x80401000,
	            0x10000: 0x80001040,
	            0x20000: 0x401040,
	            0x30000: 0x80400000,
	            0x40000: 0x0,
	            0x50000: 0x401000,
	            0x60000: 0x80000040,
	            0x70000: 0x400040,
	            0x80000: 0x80000000,
	            0x90000: 0x400000,
	            0xa0000: 0x40,
	            0xb0000: 0x80001000,
	            0xc0000: 0x80400040,
	            0xd0000: 0x1040,
	            0xe0000: 0x1000,
	            0xf0000: 0x80401040,
	            0x8000: 0x80001040,
	            0x18000: 0x40,
	            0x28000: 0x80400040,
	            0x38000: 0x80001000,
	            0x48000: 0x401000,
	            0x58000: 0x80401040,
	            0x68000: 0x0,
	            0x78000: 0x80400000,
	            0x88000: 0x1000,
	            0x98000: 0x80401000,
	            0xa8000: 0x400000,
	            0xb8000: 0x1040,
	            0xc8000: 0x80000000,
	            0xd8000: 0x400040,
	            0xe8000: 0x401040,
	            0xf8000: 0x80000040,
	            0x100000: 0x400040,
	            0x110000: 0x401000,
	            0x120000: 0x80000040,
	            0x130000: 0x0,
	            0x140000: 0x1040,
	            0x150000: 0x80400040,
	            0x160000: 0x80401000,
	            0x170000: 0x80001040,
	            0x180000: 0x80401040,
	            0x190000: 0x80000000,
	            0x1a0000: 0x80400000,
	            0x1b0000: 0x401040,
	            0x1c0000: 0x80001000,
	            0x1d0000: 0x400000,
	            0x1e0000: 0x40,
	            0x1f0000: 0x1000,
	            0x108000: 0x80400000,
	            0x118000: 0x80401040,
	            0x128000: 0x0,
	            0x138000: 0x401000,
	            0x148000: 0x400040,
	            0x158000: 0x80000000,
	            0x168000: 0x80001040,
	            0x178000: 0x40,
	            0x188000: 0x80000040,
	            0x198000: 0x1000,
	            0x1a8000: 0x80001000,
	            0x1b8000: 0x80400040,
	            0x1c8000: 0x1040,
	            0x1d8000: 0x80401000,
	            0x1e8000: 0x400000,
	            0x1f8000: 0x401040
	        },
	        {
	            0x0: 0x80,
	            0x1000: 0x1040000,
	            0x2000: 0x40000,
	            0x3000: 0x20000000,
	            0x4000: 0x20040080,
	            0x5000: 0x1000080,
	            0x6000: 0x21000080,
	            0x7000: 0x40080,
	            0x8000: 0x1000000,
	            0x9000: 0x20040000,
	            0xa000: 0x20000080,
	            0xb000: 0x21040080,
	            0xc000: 0x21040000,
	            0xd000: 0x0,
	            0xe000: 0x1040080,
	            0xf000: 0x21000000,
	            0x800: 0x1040080,
	            0x1800: 0x21000080,
	            0x2800: 0x80,
	            0x3800: 0x1040000,
	            0x4800: 0x40000,
	            0x5800: 0x20040080,
	            0x6800: 0x21040000,
	            0x7800: 0x20000000,
	            0x8800: 0x20040000,
	            0x9800: 0x0,
	            0xa800: 0x21040080,
	            0xb800: 0x1000080,
	            0xc800: 0x20000080,
	            0xd800: 0x21000000,
	            0xe800: 0x1000000,
	            0xf800: 0x40080,
	            0x10000: 0x40000,
	            0x11000: 0x80,
	            0x12000: 0x20000000,
	            0x13000: 0x21000080,
	            0x14000: 0x1000080,
	            0x15000: 0x21040000,
	            0x16000: 0x20040080,
	            0x17000: 0x1000000,
	            0x18000: 0x21040080,
	            0x19000: 0x21000000,
	            0x1a000: 0x1040000,
	            0x1b000: 0x20040000,
	            0x1c000: 0x40080,
	            0x1d000: 0x20000080,
	            0x1e000: 0x0,
	            0x1f000: 0x1040080,
	            0x10800: 0x21000080,
	            0x11800: 0x1000000,
	            0x12800: 0x1040000,
	            0x13800: 0x20040080,
	            0x14800: 0x20000000,
	            0x15800: 0x1040080,
	            0x16800: 0x80,
	            0x17800: 0x21040000,
	            0x18800: 0x40080,
	            0x19800: 0x21040080,
	            0x1a800: 0x0,
	            0x1b800: 0x21000000,
	            0x1c800: 0x1000080,
	            0x1d800: 0x40000,
	            0x1e800: 0x20040000,
	            0x1f800: 0x20000080
	        },
	        {
	            0x0: 0x10000008,
	            0x100: 0x2000,
	            0x200: 0x10200000,
	            0x300: 0x10202008,
	            0x400: 0x10002000,
	            0x500: 0x200000,
	            0x600: 0x200008,
	            0x700: 0x10000000,
	            0x800: 0x0,
	            0x900: 0x10002008,
	            0xa00: 0x202000,
	            0xb00: 0x8,
	            0xc00: 0x10200008,
	            0xd00: 0x202008,
	            0xe00: 0x2008,
	            0xf00: 0x10202000,
	            0x80: 0x10200000,
	            0x180: 0x10202008,
	            0x280: 0x8,
	            0x380: 0x200000,
	            0x480: 0x202008,
	            0x580: 0x10000008,
	            0x680: 0x10002000,
	            0x780: 0x2008,
	            0x880: 0x200008,
	            0x980: 0x2000,
	            0xa80: 0x10002008,
	            0xb80: 0x10200008,
	            0xc80: 0x0,
	            0xd80: 0x10202000,
	            0xe80: 0x202000,
	            0xf80: 0x10000000,
	            0x1000: 0x10002000,
	            0x1100: 0x10200008,
	            0x1200: 0x10202008,
	            0x1300: 0x2008,
	            0x1400: 0x200000,
	            0x1500: 0x10000000,
	            0x1600: 0x10000008,
	            0x1700: 0x202000,
	            0x1800: 0x202008,
	            0x1900: 0x0,
	            0x1a00: 0x8,
	            0x1b00: 0x10200000,
	            0x1c00: 0x2000,
	            0x1d00: 0x10002008,
	            0x1e00: 0x10202000,
	            0x1f00: 0x200008,
	            0x1080: 0x8,
	            0x1180: 0x202000,
	            0x1280: 0x200000,
	            0x1380: 0x10000008,
	            0x1480: 0x10002000,
	            0x1580: 0x2008,
	            0x1680: 0x10202008,
	            0x1780: 0x10200000,
	            0x1880: 0x10202000,
	            0x1980: 0x10200008,
	            0x1a80: 0x2000,
	            0x1b80: 0x202008,
	            0x1c80: 0x200008,
	            0x1d80: 0x0,
	            0x1e80: 0x10000000,
	            0x1f80: 0x10002008
	        },
	        {
	            0x0: 0x100000,
	            0x10: 0x2000401,
	            0x20: 0x400,
	            0x30: 0x100401,
	            0x40: 0x2100401,
	            0x50: 0x0,
	            0x60: 0x1,
	            0x70: 0x2100001,
	            0x80: 0x2000400,
	            0x90: 0x100001,
	            0xa0: 0x2000001,
	            0xb0: 0x2100400,
	            0xc0: 0x2100000,
	            0xd0: 0x401,
	            0xe0: 0x100400,
	            0xf0: 0x2000000,
	            0x8: 0x2100001,
	            0x18: 0x0,
	            0x28: 0x2000401,
	            0x38: 0x2100400,
	            0x48: 0x100000,
	            0x58: 0x2000001,
	            0x68: 0x2000000,
	            0x78: 0x401,
	            0x88: 0x100401,
	            0x98: 0x2000400,
	            0xa8: 0x2100000,
	            0xb8: 0x100001,
	            0xc8: 0x400,
	            0xd8: 0x2100401,
	            0xe8: 0x1,
	            0xf8: 0x100400,
	            0x100: 0x2000000,
	            0x110: 0x100000,
	            0x120: 0x2000401,
	            0x130: 0x2100001,
	            0x140: 0x100001,
	            0x150: 0x2000400,
	            0x160: 0x2100400,
	            0x170: 0x100401,
	            0x180: 0x401,
	            0x190: 0x2100401,
	            0x1a0: 0x100400,
	            0x1b0: 0x1,
	            0x1c0: 0x0,
	            0x1d0: 0x2100000,
	            0x1e0: 0x2000001,
	            0x1f0: 0x400,
	            0x108: 0x100400,
	            0x118: 0x2000401,
	            0x128: 0x2100001,
	            0x138: 0x1,
	            0x148: 0x2000000,
	            0x158: 0x100000,
	            0x168: 0x401,
	            0x178: 0x2100400,
	            0x188: 0x2000001,
	            0x198: 0x2100000,
	            0x1a8: 0x0,
	            0x1b8: 0x2100401,
	            0x1c8: 0x100401,
	            0x1d8: 0x400,
	            0x1e8: 0x2000400,
	            0x1f8: 0x100001
	        },
	        {
	            0x0: 0x8000820,
	            0x1: 0x20000,
	            0x2: 0x8000000,
	            0x3: 0x20,
	            0x4: 0x20020,
	            0x5: 0x8020820,
	            0x6: 0x8020800,
	            0x7: 0x800,
	            0x8: 0x8020000,
	            0x9: 0x8000800,
	            0xa: 0x20800,
	            0xb: 0x8020020,
	            0xc: 0x820,
	            0xd: 0x0,
	            0xe: 0x8000020,
	            0xf: 0x20820,
	            0x80000000: 0x800,
	            0x80000001: 0x8020820,
	            0x80000002: 0x8000820,
	            0x80000003: 0x8000000,
	            0x80000004: 0x8020000,
	            0x80000005: 0x20800,
	            0x80000006: 0x20820,
	            0x80000007: 0x20,
	            0x80000008: 0x8000020,
	            0x80000009: 0x820,
	            0x8000000a: 0x20020,
	            0x8000000b: 0x8020800,
	            0x8000000c: 0x0,
	            0x8000000d: 0x8020020,
	            0x8000000e: 0x8000800,
	            0x8000000f: 0x20000,
	            0x10: 0x20820,
	            0x11: 0x8020800,
	            0x12: 0x20,
	            0x13: 0x800,
	            0x14: 0x8000800,
	            0x15: 0x8000020,
	            0x16: 0x8020020,
	            0x17: 0x20000,
	            0x18: 0x0,
	            0x19: 0x20020,
	            0x1a: 0x8020000,
	            0x1b: 0x8000820,
	            0x1c: 0x8020820,
	            0x1d: 0x20800,
	            0x1e: 0x820,
	            0x1f: 0x8000000,
	            0x80000010: 0x20000,
	            0x80000011: 0x800,
	            0x80000012: 0x8020020,
	            0x80000013: 0x20820,
	            0x80000014: 0x20,
	            0x80000015: 0x8020000,
	            0x80000016: 0x8000000,
	            0x80000017: 0x8000820,
	            0x80000018: 0x8020820,
	            0x80000019: 0x8000020,
	            0x8000001a: 0x8000800,
	            0x8000001b: 0x0,
	            0x8000001c: 0x20800,
	            0x8000001d: 0x820,
	            0x8000001e: 0x20020,
	            0x8000001f: 0x8020800
	        }
	    ];

	    // Masks that select the SBOX input
	    var SBOX_MASK = [
	        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
	        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
	    ];

	    /**
	     * DES block cipher algorithm.
	     */
	    var DES = C_algo.DES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Select 56 bits according to PC1
	            var keyBits = [];
	            for (var i = 0; i < 56; i++) {
	                var keyBitPos = PC1[i] - 1;
	                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
	            }

	            // Assemble 16 subkeys
	            var subKeys = this._subKeys = [];
	            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
	                // Create subkey
	                var subKey = subKeys[nSubKey] = [];

	                // Shortcut
	                var bitShift = BIT_SHIFTS[nSubKey];

	                // Select 48 bits according to PC2
	                for (var i = 0; i < 24; i++) {
	                    // Select from the left 28 key bits
	                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

	                    // Select from the right 28 key bits
	                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
	                }

	                // Since each subkey is applied to an expanded 32-bit input,
	                // the subkey can be broken into 8 values scaled to 32-bits,
	                // which allows the key to be used without expansion
	                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
	                for (var i = 1; i < 7; i++) {
	                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
	                }
	                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
	            }

	            // Compute inverse subkeys
	            var invSubKeys = this._invSubKeys = [];
	            for (var i = 0; i < 16; i++) {
	                invSubKeys[i] = subKeys[15 - i];
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._subKeys);
	        },

	        decryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._invSubKeys);
	        },

	        _doCryptBlock: function (M, offset, subKeys) {
	            // Get input
	            this._lBlock = M[offset];
	            this._rBlock = M[offset + 1];

	            // Initial permutation
	            exchangeLR.call(this, 4,  0x0f0f0f0f);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeLR.call(this, 1,  0x55555555);

	            // Rounds
	            for (var round = 0; round < 16; round++) {
	                // Shortcuts
	                var subKey = subKeys[round];
	                var lBlock = this._lBlock;
	                var rBlock = this._rBlock;

	                // Feistel function
	                var f = 0;
	                for (var i = 0; i < 8; i++) {
	                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
	                }
	                this._lBlock = rBlock;
	                this._rBlock = lBlock ^ f;
	            }

	            // Undo swap from last round
	            var t = this._lBlock;
	            this._lBlock = this._rBlock;
	            this._rBlock = t;

	            // Final permutation
	            exchangeLR.call(this, 1,  0x55555555);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeLR.call(this, 4,  0x0f0f0f0f);

	            // Set output
	            M[offset] = this._lBlock;
	            M[offset + 1] = this._rBlock;
	        },

	        keySize: 64/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    // Swap bits across the left and right words
	    function exchangeLR(offset, mask) {
	        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
	        this._rBlock ^= t;
	        this._lBlock ^= t << offset;
	    }

	    function exchangeRL(offset, mask) {
	        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
	        this._lBlock ^= t;
	        this._rBlock ^= t << offset;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
	     */
	    C.DES = BlockCipher._createHelper(DES);

	    /**
	     * Triple-DES block cipher algorithm.
	     */
	    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Create DES instances
	            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
	            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
	            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
	        },

	        encryptBlock: function (M, offset) {
	            this._des1.encryptBlock(M, offset);
	            this._des2.decryptBlock(M, offset);
	            this._des3.encryptBlock(M, offset);
	        },

	        decryptBlock: function (M, offset) {
	            this._des3.decryptBlock(M, offset);
	            this._des2.encryptBlock(M, offset);
	            this._des1.decryptBlock(M, offset);
	        },

	        keySize: 192/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
	     */
	    C.TripleDES = BlockCipher._createHelper(TripleDES);
	}());


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    /**
	     * RC4 stream cipher algorithm.
	     */
	    var RC4 = C_algo.RC4 = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;
	            var keySigBytes = key.sigBytes;

	            // Init sbox
	            var S = this._S = [];
	            for (var i = 0; i < 256; i++) {
	                S[i] = i;
	            }

	            // Key setup
	            for (var i = 0, j = 0; i < 256; i++) {
	                var keyByteIndex = i % keySigBytes;
	                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;

	                j = (j + S[i] + keyByte) % 256;

	                // Swap
	                var t = S[i];
	                S[i] = S[j];
	                S[j] = t;
	            }

	            // Counters
	            this._i = this._j = 0;
	        },

	        _doProcessBlock: function (M, offset) {
	            M[offset] ^= generateKeystreamWord.call(this);
	        },

	        keySize: 256/32,

	        ivSize: 0
	    });

	    function generateKeystreamWord() {
	        // Shortcuts
	        var S = this._S;
	        var i = this._i;
	        var j = this._j;

	        // Generate keystream word
	        var keystreamWord = 0;
	        for (var n = 0; n < 4; n++) {
	            i = (i + 1) % 256;
	            j = (j + S[i]) % 256;

	            // Swap
	            var t = S[i];
	            S[i] = S[j];
	            S[j] = t;

	            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
	        }

	        // Update counters
	        this._i = i;
	        this._j = j;

	        return keystreamWord;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4 = StreamCipher._createHelper(RC4);

	    /**
	     * Modified RC4 stream cipher algorithm.
	     */
	    var RC4Drop = C_algo.RC4Drop = RC4.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} drop The number of keystream words to drop. Default 192
	         */
	        cfg: RC4.cfg.extend({
	            drop: 192
	        }),

	        _doReset: function () {
	            RC4._doReset.call(this);

	            // Drop
	            for (var i = this.cfg.drop; i > 0; i--) {
	                generateKeystreamWord.call(this);
	            }
	        }
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
	}());


	/** @preserve
	 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
	 * derived from CryptoJS.mode.CTR
	 * Jan Hruby jhruby.web@gmail.com
	 */
	CryptoJS.mode.CTRGladman = (function () {
	    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

		function incWord(word)
		{
			if (((word >> 24) & 0xff) === 0xff) { //overflow
			var b1 = (word >> 16)&0xff;
			var b2 = (word >> 8)&0xff;
			var b3 = word & 0xff;

			if (b1 === 0xff) // overflow b1
			{
			b1 = 0;
			if (b2 === 0xff)
			{
				b2 = 0;
				if (b3 === 0xff)
				{
					b3 = 0;
				}
				else
				{
					++b3;
				}
			}
			else
			{
				++b2;
			}
			}
			else
			{
			++b1;
			}

			word = 0;
			word += (b1 << 16);
			word += (b2 << 8);
			word += b3;
			}
			else
			{
			word += (0x01 << 24);
			}
			return word;
		}

		function incCounter(counter)
		{
			if ((counter[0] = incWord(counter[0])) === 0)
			{
				// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
				counter[1] = incWord(counter[1]);
			}
			return counter;
		}

	    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }

				incCounter(counter);

				var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTRGladman.Decryptor = Encryptor;

	    return CTRGladman;
	}());




	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm
	     */
	    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |
	                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);
	            }

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
	     */
	    C.Rabbit = StreamCipher._createHelper(Rabbit);
	}());


	/**
	 * Counter block mode.
	 */
	CryptoJS.mode.CTR = (function () {
	    var CTR = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = CTR.Encryptor = CTR.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Increment counter
	            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTR.Decryptor = Encryptor;

	    return CTR;
	}());


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm.
	     *
	     * This is a legacy version that neglected to convert the key to little-endian.
	     * This error doesn't affect the cipher's security,
	     * but it does affect its compatibility with other implementations.
	     */
	    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
	     */
	    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
	}());


	/**
	 * Zero padding strategy.
	 */
	CryptoJS.pad.ZeroPadding = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Pad
	        data.clamp();
	        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
	    },

	    unpad: function (data) {
	        // Shortcut
	        var dataWords = data.words;

	        // Unpad
	        var i = data.sigBytes - 1;
	        while (!((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
	            i--;
	        }
	        data.sigBytes = i + 1;
	    }
	};


	return CryptoJS;

}));(function (root, factory, undef) {
    // CommonJS
    if (typeof exports === "object") {
        module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core"));

    // AMD
    } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);

    // Global (browser)
    } else {
        factory(root.CryptoJS);
    }
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));//global GS, window, xtag, registerDesignSnippet

window.addEventListener('design-register-element', function () {
    "use strict";
    registerDesignSnippet('Add Loader (to page)', 'GS.addLoader', 'addLoader(\'${0:class-name}\', \'${1:Loading...}\');');
    registerDesignSnippet('Add Loader (to element)', 'GS.addLoader', 'addLoader(${0:document.getElementById(\'id\')}, \'${1:Loading...}\');');
    registerDesignSnippet('Remove Loader (from page)', 'GS.removeLoader', 'removeLoader(\'${0:class-name}\');');
    registerDesignSnippet('Remove Loader (from element)', 'GS.removeLoader', 'removeLoader(${0:document.getElementById(\'id\')});');
});

document.addEventListener('DOMContentLoaded', function () {
    "use strict";
    xtag.register('gs-loader', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {}
    });
});

GS.addLoader = function (loaderClassOrTarget, loaderContent) {
    "use strict";
    var loaderElement = document.createElement('gs-loader');
    var loaderClass;
    var loaderTarget;

    // turn loaderClassOrTarget into class or target
    if (typeof loaderClassOrTarget === 'string') {
        loaderClass = loaderClassOrTarget;

    } else if (typeof loaderClassOrTarget === 'object') {
        loaderTarget = loaderClassOrTarget;
    }

    // if there is a loader class: add class to loader for future identification
    if (loaderClass) {
        loaderElement.classList.add('loader-' + loaderClass);
    }

    // default loader target to body
    if (!loaderTarget) {
        loaderTarget = document.body;
    }

    // add spinning elements and loader content to loader container
    loaderElement.innerHTML = (
        '<div class="loader-positioning" gs-dynamic>' +
            '<div class="loader" gs-dynamic></div>' +
            '<div class="loader-inner spinning" gs-dynamic></div>' +
            '<div class="loader-inner-inner spinning" gs-dynamic></div>' +
            '<div class="loader-inner-inner-inner spinning" gs-dynamic></div>' +
        (
            loaderContent
                ? '<div class="loader-content" gs-dynamic role="alert">' + loaderContent + '</div>'
                : ''
        ) +
        '</div>'
    );

    // prevent scrolling on a loader
    loaderElement.addEventListener('mousewheel', function (event) {
        event.preventDefault();
    });

    // append loader to target
    loaderTarget.appendChild(loaderElement); // document.body
};

GS.removeLoader = function (loaderClassOrTarget) {
    "use strict";
    var element;
    var i;
    var len;
    var arrLoaders;
    var loaderClass;
    var loaderTarget;

    if (typeof loaderClassOrTarget === 'string') {
        loaderClass = loaderClassOrTarget;

    } else if (typeof loaderClassOrTarget === 'object') {
        loaderTarget = loaderClassOrTarget;
    }

    if (loaderClass) {
        element = document.getElementsByClassName('loader-' + loaderClass)[0];

    } else if (loaderTarget) {
        element = xtag.queryChildren(loaderTarget, 'gs-loader')[0];

    } else {
        arrLoaders = xtag.queryChildren(document.body, 'gs-loader');

        i = 0;
        len = arrLoaders.length;
        while (i < len) {
            if (!arrLoaders[i].hasAttribute('id')) {
                element = arrLoaders[i];
                break;
            }
            i += 1;
        }
    }

    if (element) {
        element.parentNode.removeChild(element);
    } else {
        console.warn(
            'GS.removeLoader Error: loader' +
            (
                loaderClass
                    ? ' class: "' + loaderClass + '"'
                    : ''
            ) +
            ' not found'
        );
    }

    element = document.createElement('div');
    element.setAttribute('gs-dynamic', '');
    element.setAttribute('hidden', '');
    element.setAttribute('role', 'alert');
    element.textContent = 'Done';
    document.body.appendChild(element);
    setTimeout(function () {
        element.parentNode.removeChild(element);
    }, 1000);
};

GS.removeAllLoaders = function () {
    "use strict";
    var i;
    var len;
    var arrLoaders = xtag.query(document.body, 'gs-loader');

    i = 0;
    len = arrLoaders.length;
    while (i < len) {
        if (!arrLoaders[i].hasAttribute('id')) {
            arrLoaders[i].parentNode.removeChild(arrLoaders[i]);
        }
        i += 1;
    }
};//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, maxlen:80, white:false, this:true

// # CODE INDEX:          <- (use "find" (CTRL-f or CMD-f) to skip to a section)
//      # TOP             <- (this just brings you back this index)
//      # SNIPPET/DESIGN
//      # SHARED VARIABLES
//      # PASSWORD RECEIVER
//      # UTILITY FUNCTIONS
//      # ELEMENT FUNCTIONS
//      # RENDER FUNCTIONS
//      # EVENT FUNCTIONS
//          # QS EVENTS
//          # FOCUS EVENTS
//          # BLUR EVENTS
//          # KEY EVENTS
//          # SELECTION EVENTS
//          # RESIZE EVENTS
//          # CMD-S EVENTS
//          # DEVELOPER EVENTS
//          # HIGH LEVEL BINDING
//      # ELEMENT INSTANTIATION
//      # ELEMENT LIFECYCLE
//      # ELEMENT ACCESSORS
//      # ELEMENT METHODS
//
// For code that needs to be completed:
//      # NEED CODING


// #############################################################################
// ############################## SNIPPET/DESIGN ###############################
// #############################################################################

window.addEventListener('design-register-element', function () {
    "use strict";
    addSnippet('<gs-ace>', '<gs-ace>', 'gs-ace column="${1:name}"></gs-ace>');
    addSnippet(
        '<gs-ace> With Label',
        '<gs-ace>',
        (
            'label for="${1:ace-insert-note}">${2:Notes}:</label>\n' +
            '<gs-ace id="${1:ace-insert-note}" column="${3:note}"></gs-ace>'
        )
    );

    addElement('gs-ace', '#controls_ace');

    // DEFINE PROPERTIES
    window.designElementProperty_GSACE = function (selected) {
        addGSControlProps();
        addText('D', 'Encrypted', 'encrypted');
        addText('O', 'Column In QS', 'qs');
        addSelect('V', 'Theme', 'theme', [
            {"val": "", "txt": "Eclipse (Default)"},
            {"val": "chrome", "txt": "Chrome"},
            {"val": "clouds", "txt": "Clouds"},
            {"val": "crimson_editor", "txt": "Crimson Editor"},
            {"val": "dawn", "txt": "Dawn"},
            {"val": "dreamweaver", "txt": "Dreamweaver"},
            {"val": "eclipse", "txt": "Eclipse"},
            {"val": "github", "txt": "GitHub"},
            {"val": "iplastic", "txt": "IPlastic"},
            {"val": "solarized_light", "txt": "Solarized Light"},
            {"val": "textmate", "txt": "TextMate"},
            {"val": "tomorrow", "txt": "Tomorrow"},
            {"val": "xcode", "txt": "XCode"},
            {"val": "kuroir", "txt": "Kuroir"},
            {"val": "katzenmilch", "txt": "KatzenMilch"},
            {"val": "sqlserver", "txt": "SQL Server"},
            {"val": "ambiance", "txt": "Ambiance"},
            {"val": "chaos", "txt": "Chaos"},
            {"val": "clouds_midnight", "txt": "Clouds Midnight"},
            {"val": "cobalt", "txt": "Cobalt"},
            {"val": "idle_fingers", "txt": "idle Fingers"},
            {"val": "kr_theme", "txt": "krTheme"},
            {"val": "merbivore", "txt": "Merbivore"},
            {"val": "merbivore_soft", "txt": "Merbivore Soft"},
            {"val": "mono_industrial", "txt": "Mono Industrial"},
            {"val": "monokai", "txt": "Monokai"},
            {"val": "pastel_on_dark", "txt": "Pastel on dark"},
            {"val": "solarized_dark", "txt": "Solarized Dark"},
            {"val": "terminal", "txt": "Terminal"},
            {"val": "tomorrow_night", "txt": "Tomorrow Night"},
            {"val": "tomorrow_night_blue", "txt": "Tomorrow Night Blue"},
            {"val": "tomorrow_night_bright", "txt": "Tomorrow Night Bright"},
            {"val": "tomorrow_night_eighties", "txt": "Tomorrow Night 80s"},
            {"val": "twilight", "txt": "Twilight"},
            {"val": "vibrant_ink", "txt": "Vibrant Ink"}
        ]);
        addSelect('D', 'Mode', 'mode', [
            {"val": "", "txt": "text (Default)"},
            'abap', 'abc', 'actionscript', 'ada', 'apache_conf', 'asciidoc',
            'assembly_x86', 'autohotkey', 'batchfile', 'c_cpp', 'c9search',
            'cirru', 'clojure', 'cobol', 'coffee', 'coldfusion', 'csharp',
            'css', 'curly', 'd', 'dart', 'diff', 'dockerfile', 'dot', 'dummy',
            'dummysyntax', 'eiffel', 'ejs', 'elixir', 'elm', 'erlang', 'forth',
            'fortran', 'ftl', 'gcode', 'gherkin', 'gitignore', 'glsl',
            'gobstones', 'golang', 'groovy', 'haml', 'handlebars', 'haskell',
            'haxe', 'html', 'html_elixir', 'html_ruby', 'ini', 'io', 'jack',
            'jade', 'java', 'javascript', 'json', 'jsoniq', 'jsp', 'jsx',
            'julia', 'latex', 'lean', 'less', 'liquid', 'lisp', 'livescript',
            'logiql', 'lsl', 'lua', 'luapage', 'lucene', 'makefile', 'markdown',
            'mask', 'matlab', 'maze', 'mel', 'mushcode', 'mysql', 'nix', 'nsis',
            'objectivec', 'ocaml', 'pascal', 'perl', 'pgsql', 'php',
            'powershell', 'praat', 'prolog', 'properties', 'protobuf', 'python',
            'r', 'razor', 'rdoc', 'rhtml', 'rst', 'ruby', 'rust', 'sass',
            'scad', 'scala', 'scheme', 'scss', 'sh', 'sjs', 'smarty',
            'snippets', 'soy_template', 'space', 'sql', 'sqlserver', 'stylus',
            'svg', 'swift', 'tcl', 'tex', 'text', 'textile', 'toml', 'twig',
            'typescript', 'vala', 'vbscript', 'velocity', 'verilog', 'vhdl',
            'wollok', 'xml', 'xquery', 'yaml', 'django'
        ]);
        addText('V', 'Rows', 'rows');
        addCheck('O', 'Autocomplete', 'Autocomplete');
        addFlexProps(selected);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

// #############################################################################
// ############################# SHARED VARIABLES ##############################
// #############################################################################

    // these are config variables
    var strAceRootFolder = '/js/ace/';

    // these are variables that are shared between gs-ace elements
    var Range;
    var snippetManager;
    var bolAceLoading = false;
    var bolAceLoaded = false;
    var arrAceLoadCallbacks = [];


// #############################################################################
// ############################ PASSWORD RECEIVER ##############################
// #############################################################################

    // if there's encrypted controls on the screen, a password dialog pops up.
    //      If we have encrypted gs-ace elements, they have to wait to render a
    //      properly decrypted value. When we get the signal that we have a
    //      password, re-render all encrypted gs-ace elements that use that key.
    window.addEventListener('try-password', function (event) {
        var strKey = event.keyVariable;
        var elems = xtag.query(document, 'gs-ace[encrypted="' + strKey + '"]');
        var i;
        var len;

        i = 0;
        len = elems.length;
        while (i < len) {
            elems[i].render();
            i += 1;
        }
    });


// #############################################################################
// ############################ UTILITY FUNCTIONS ##############################
// #############################################################################

    // loading scripts is clunky, factoring out into a function will help the
    //      code self-document.
    function loadAceFile(strPath, callback) {
        var scriptElement;

        // gotta build the script tag
        scriptElement = document.createElement('script');
        scriptElement.src = strAceRootFolder + strPath;
        scriptElement.setAttribute('data-ace-base', strAceRootFolder);
        scriptElement.onload = function () {
            if (callback) {
                callback();
            }
        };

        // appending the script to the head is what causes it to load
        document.head.appendChild(scriptElement);
    }

    // if we've stored up some elements that are waiting to be initiated because
    //      ace hasn't been loaded yet, let's run through them now and let them
    //      proceed. This function is only called after the ace files have been
    //      loaded.
    function initiateAllWaitingAceElements() {
        var i;
        var len;

        i = 0;
        len = arrAceLoadCallbacks.length;
        while (i < len) {
            arrAceLoadCallbacks[i]();
            i += 1;
        }
    }

    // we need to wait to initiate any ace elements until after all related
    //      files have been downloaded. We don't want to slow down most pages
    //      with ace, so we load the ace files on the first "inserted" lifecycle
    //      call of a gs-ace
    function loadAce(callback) {
        // if we've already loaded ace, immediate callback
        if (bolAceLoaded) {
            callback();

        // ace is in the process of being loaded, just bind and wait
        } else if (bolAceLoading) {
            arrAceLoadCallbacks.push(callback);

        // load ace, and then the supplementary files we need.
        } else {
            arrAceLoadCallbacks.push(callback);
            bolAceLoading = true;

            // we have to load ace before we load the supplementary files
            loadAceFile('ace.js', function () {
                var arrFiles;
                var i;
                var intRequested;
                var intLoaded;
                var loadedCallback;

                // this callback is run one for every file after it is loaded.
                //      Once all files have been loaded, it loops through the
                //      callbacks we've stored up for all the aces that want to
                //      run and execute them.
                loadedCallback = function () {
                    intLoaded += 1;

                    // we've loaded all the files we requested
                    if (intLoaded === intRequested) {
                        // we need the snippet/autocomplete and selection range
                        //      modules loaded into variables we can reach.
                        Range = require('ace/range').Range;
                        snippetManager = require('ace/snippets').snippetManager;

                        // allow all the gs-ace elements that are waiting for
                        //      ace to load to continue with their lifecycle
                        initiateAllWaitingAceElements();

                        // we update the state variables last to minimize the
                        //      possibility of a race condition
                        bolAceLoaded = true;
                        bolAceLoading = false;
                    }
                };

                // right now, we only load the language tools (for snippets and
                //      autocomplete) and the searchbox (for programatically
                //      opening the find/replace box). In the future, if we need
                //      to change the files we load, just change this.
                arrFiles = [
                    {"name": "ext-language_tools.js", "loaded": false},
                    {"name": "ext-searchbox.js", "loaded": false}
                ];

                // loop through all the files and start loading them
                intLoaded = 0;
                i = 0;
                intRequested = arrFiles.length;
                while (i < intRequested) {
                    loadAceFile(arrFiles[i].name, loadedCallback);
                    i += 1;
                }
            });
        }
    }

    // we need to be able to execute event attributes (like onafter_select)
    //      while being able to reference the gs-ace as "this" in the code.
    function evalInContext(element, strJS) {
        var execFunc = function () {
            return eval(strJS);
        };

        execFunc.call(element);
    }

    // we want to standardize event triggering in this element.
    function triggerEvent(element, strEvent) {
        GS.triggerEvent(element, strEvent);
        GS.triggerEvent(element, 'on' + strEvent);
        if (
            element.hasAttribute('on' + strEvent) &&
            // onfocus, onblur and onchange attributes are handled automatically
            //      by the browser
            strEvent !== 'focus' &&
            strEvent !== 'blur' &&
            strEvent !== 'change'
        ) {
            evalInContext(element, element.getAttribute('on' + strEvent));
        }
    }

    // encryption adds a layer of code in between getting and setting values. We
    //      don't want to have to repeat the decryption code multiple times. If
    //      the gs-ace isn't encrypted, it just returns the value given.
    function encryptValue(element, strValue) {
        var strKey = element.getAttribute('encrypted');

        // if there's no key, don't try to encrypt
        if (strKey && (window[strKey] || '')) {
            return CryptoJS.AES.encrypt(
                (strValue || ''),
                (window[strKey] || '')
            );
        }

        return strValue;
    }

    // encryption adds a layer of code in between getting and setting values. We
    //      don't want to have to repeat the decryption code multiple times. If
    //      the gs-ace isn't encrypted, it just returns the value given.
    function decryptValue(element, strValue) {
        var strKey = element.getAttribute('encrypted');

        // we error if we try to decrypt without a password
        if (strKey && (window[strKey] || '')) {
            return CryptoJS.AES.decrypt(
                (strValue || ''),
                (window[strKey] || '')
            ).toString(CryptoJS.enc.Utf8);
        }

        return strValue;
    }

    // encryption adds a layer of code in between getting and setting values. We
    //      don't want to have to repeat the decryption code multiple times. If
    //      the gs-ace isn't encrypted, it just returns the value attribute.
    function setEncryptElemVal(element, strValue) {
        return element.setAttribute('value', encryptValue(element, strValue));
    }

    // encryption adds a layer of code in between getting and setting values. We
    //      don't want to have to repeat the decryption code multiple times. If
    //      the gs-ace isn't encrypted, it just returns the value attribute.
    function getDecryptElemVal(element) {
        return decryptValue(element, element.getAttribute('value'));
    }

    // encryption adds a layer of code in between getting and setting values. We
    //      don't want to have to repeat the encryption code multiple times. If
    //      the gs-ace isn't encrypted, it just returns the ace value.
    function getDecryptAceVal(element) {
        return element.internalAce.getValue();
    }


// #############################################################################
// ############################# ELEMENT FUNCTIONS #############################
// #############################################################################

    // create internal structures and inner elements that persist through the
    //      whole lifetime of the element
    function prepareElement(element) {
        var root;
        var strTemp;

        // we need containers for our internal data.
        element.elems = {};
        element.internalAce = {};
        element.internalData = {};
        element.internalEvents = {};
        element.internalDisplay = {
            "markers": {}
        };

        // we need to create the div that will house the ace element. This
        //      element will persist until element death.
        root = GS.stringToElement(
            '<div class="root" gs-dynamic></div>'
        );

        // save root
        element.elems.root = root;

        // clear anything old out of the element
        element.innerHTML = '';

        // append our root element
        element.appendChild(root);

        // create ace editor here
        element.internalAce = ace.edit(root);
        element.internalAce.setShowPrintMargin(false);
        element.internalAce.setDisplayIndentGuides(true);
        element.internalAce.setShowFoldWidgets(false);
        element.internalAce.session.setUseWrapMode('free');
        element.internalAce.setBehavioursEnabled(false);

        // blocks a warning
        strTemp = '$blockScrolling';
        element.internalAce[strTemp] = Infinity;

        // get tab index and save it for later
        if (element.hasAttribute('tabindex')) {
            element.internalDisplay.tabIndex = element.getAttribute('tabindex');
            element.removeAttribute('tabindex');
        }
    }


// #############################################################################
// ############################# RENDER FUNCTIONS ##############################
// #############################################################################

    // sync ace editor element with current value and parameters
    function render(element, bolPreventUndo) {
        var strTheme;
        var strLanguage;
        var bolAutocomplete;
        var strValueAttr;

        // gather parameters
        strTheme = element.getAttribute('theme') || 'eclipse';
        strLanguage = element.getAttribute('mode') || 'text';
        bolAutocomplete = element.hasAttribute('autocomplete');

        // apply parameters
        element.internalAce.setTheme('ace/theme/' + strTheme);
        element.internalAce.session.setMode('ace/mode/' + strLanguage);
        element.internalAce.setOptions({
            'enableBasicAutocompletion': bolAutocomplete,
            'enableSnippets': bolAutocomplete,
            'enableLiveAutocompletion': bolAutocomplete
        });

        // get and set latest value

        // we only want to mess with the value if it's different from the value
        //      attribute. the setValue ace function causes a 'change' event
        //      that we don't want to occur unless the user made a change.
        strValueAttr = getDecryptElemVal(element);

        if (strValueAttr !== getDecryptAceVal(element)) {
            // if we're doing the initial value set, we don't want to allow undo
            if (bolPreventUndo) {
                element.internalAce.session.setValue(strValueAttr || '');

            // else, we want the user to be able to undo
            } else {
                element.internalAce.setValue(strValueAttr || '');
            }
        }

        // handle differences between touch and desktop
        if (evt.touchDevice) {
            element.internalAce.setOptions({maxLines: Infinity});
            element.elems.root.classList.add('childrenneedsclick');
        } else {
            element.elems.root.style.height = '100%';
        }

        // handle disabled and readonly
        element.internalAce.setReadOnly(
            element.hasAttribute('disabled') ||
            element.hasAttribute('readonly')
        );

        // handle height settings
        if (element.hasAttribute('rows')) {
            element.style.height = (
                parseInt(element.getAttribute('rows'), 10) *
                element.internalAce.renderer.lineHeight
            ) + 'px';
        } else {
            //element.style.height, need to use default attribute
            // ### NEED CODING ###
        }

        // handle tabindex setting
        if (element.internalDisplay.tabIndex !== undefined) {
            xtag.query(element, '.ace_text-input')[0].setAttribute(
                'tabindex',
                element.internalDisplay.tabIndex
            );
        }

        // cause the ace editor to perform a resize
        element.internalAce.resize();
    }


// #############################################################################
// ############################## EVENT FUNCTIONS ##############################
// #############################################################################

    // ############# QS EVENTS #############
    function unbindQuerystringEvents(element) {
        
    }
    function bindQuerystringEvents(element) {
        
    }

    // ############# FOCUS EVENTS #############
    function unbindFocus(element) {
        element.internalAce.removeEventListener(
            'focus',
            element.internalEvents.aceFocus
        );
    }
    function bindFocus(element) {
        element.internalEvents.aceFocus = function () {
            // when we enter the field, we save the last published value so that
            //      when we leave the field, we can compare the current value
            //      with the last published value, and if there's a difference,
            //      trigger a change event.
            element.internalEvents.lastPublishedValue = (
                getDecryptElemVal(element)
            );
        };

        element.internalAce.addEventListener(
            'focus',
            element.internalEvents.aceFocus
        );
    }

    // ############# BLUR EVENTS #############
    function unbindBlur(element) {
        element.internalAce.removeEventListener(
            'blur',
            element.internalEvents.aceBlur
        );
    }
    function bindBlur(element) {
        element.internalEvents.aceBlur = function () {
            var strValue = getDecryptElemVal(element);

            // if the last published value is different from when we entered
            //      the field, we want to trigger a change, because blur
            //      means we're leaving the field.
            if (element.internalEvents.lastPublishedValue !== strValue) {
                element.internalEvents.lastPublishedValue = strValue;
                triggerEvent(element, 'change');
            }
        };

        element.internalAce.addEventListener(
            'blur',
            element.internalEvents.aceBlur
        );
    }

    // ############# KEY EVENTS #############
    function unbindKey(element) {
        element.elems.root.removeEventListener(
            'keydown',
            element.internalEvents.keydownValueChange
        );
        element.internalAce.removeEventListener(
            'change',
            element.internalEvents.changeValueChange
        );
    }
    function bindKey(element) {
        element.internalEvents.keydownValueChange = function (event) {
            var intKeyCode = (event.which || event.keyCode);

            // CMD-S triggers save
            if (intKeyCode === 83 && (event.metaKey || event.ctrlKey)) {
                // we don't want the webpage to try to use CMD-S as a signal
                //      to as the user if they want to save the webpage.
                event.preventDefault();
                event.stopPropagation();

                // CMD-S always triggers a change and value_change, no matter
                //      if there's a difference in value.
                triggerEvent(element, 'value_change');
                triggerEvent(element, 'change');

                // on blur, we compare the latest published value with the
                //      current value. We don't want to trigger a change
                //      event if they leave the ace after a CMD-S
                element.internalEvents.lastPublishedValue = getDecryptElemVal();

            // space
            //} else if (intKeyCode === 32) {

            // non alpha
            } else if (
                !(
                    (intKeyCode >= 65 && intKeyCode < 90) ||
                    (intKeyCode >= 97 && intKeyCode < 122) ||
                    (intKeyCode === 45) // dash
                )
            ) {
                if (element.internalAce.completer) {
                    element.internalAce.completer.detach();
                }
            }
        };
        element.internalEvents.changeValueChange = function () {
            var strValue = getDecryptAceVal(element);

            // if the value attribute is not up to date, update value
            //      attribute and trigger change
            if (getDecryptElemVal(element) !== strValue) {
                setEncryptElemVal(element, strValue);

                // we want the developer to be able to access the new
                //      value, so we trigger the event last
                triggerEvent(element, 'value_change');
            }
        };

        element.elems.root.addEventListener(
            'keydown',
            element.internalEvents.keydownValueChange
        );
        element.internalAce.addEventListener(
            'change',
            element.internalEvents.changeValueChange
        );
    }

    // ############# SELECTION EVENTS #############
    function unbindSelection(element) {
        element.elems.root.removeEventListener(
            evt.mouseup,
            element.internalEvents.selectionChange
        );
        element.elems.root.removeEventListener(
            'keyup',
            element.internalEvents.selectionChange
        );
    }
    function bindSelection(element) {
        element.internalEvents.selectionChange = function () {
            triggerEvent(element, 'selection_change');
        };

        element.elems.root.addEventListener(
            evt.mouseup,
            element.internalEvents.selectionChange
        );
        element.elems.root.addEventListener(
            'keyup',
            element.internalEvents.selectionChange
        );
    }

    // ############# RESIZE EVENTS #############
    function unbindResize(element) {
        window.removeEventListener(
            'resize',
            element.internalEvents.windowResize
        );
        window.removeEventListener(
            evt.mousemove,
            element.internalEvents.elementResize
        );
    }
    function bindResize(element) {
        element.internalEvents.windowResize = function () {
            element.internalAce.resize();
        };
        element.internalEvents.elementResize = function () {
            if (
                element.internalDisplay.lastHeight !== element.clientHeight ||
                element.internalDisplay.lastWidth !== element.clientWidth
            ) {
                element.internalAce.resize();
                element.internalDisplay.lastHeight = element.clientHeight;
                element.internalDisplay.lastWidth = element.clientWidth;
            }
        };

        window.addEventListener(
            'resize',
            element.internalEvents.windowResize
        );
        window.addEventListener(
            evt.mousemove,
            element.internalEvents.elementResize
        );
    }

    // ############# CMD-S EVENTS #############
    function unbindCMDS(element) {
        window.removeEventListener(
            'keydown',
            element.internalEvents.cmdsPrevent
        );
    }
    function bindCMDS(element) {
        element.internalEvents.cmdsPrevent = function () {
            var intKeyCode = (event.which || event.keyCode);

            // CMD-S triggers change event in gs-ace, we don't want the window
            //      to attempt to save the webpage to the desktop. Only if all
            //      gs-ace elements have been removed from the DOM will the user
            //      be able to save the webpage again.
            if (intKeyCode === 83 && (event.metaKey || event.ctrlKey)) {
                event.preventDefault();
                event.stopPropagation();
            }
        };

        window.addEventListener(
            'keydown',
            element.internalEvents.cmdsPrevent
        );
    }

    // ############# DEVELOPER EVENTS #############
    function unbindDeveloper(element) {
        element.removeEventListener(
            evt.mousedown,
            element.internalEvents.developerMouseDown
        );
    }
    function bindDeveloper(element) {
        element.internalEvents.developerMouseDown = function (event) {
            var strHTML;
            var arrAttr;
            var jsnAttr;
            var i;
            var len;

            if ((event.ctrlKey || event.metaKey) && event.shiftKey) {
                event.preventDefault();
                event.stopPropagation();
                strHTML = '';
                arrAttr = element.attributes;
                i = 0;
                len = arrAttr.length;
                while (i < len) {
                    jsnAttr = arrAttr[i];
                    strHTML += (
                        '<b>Attribute "' + encodeHTML(jsnAttr.name) + '":</b>' +
                        '<pre>' + encodeHTML(jsnAttr.value) + '</pre>'
                    );
                    i += 1;
                }
                GS.msgbox('Developer Info', strHTML, ['Ok']);
            }
        };

        element.addEventListener(
            evt.mousedown,
            element.internalEvents.developerMouseDown
        );
    }

    // ############# HIGH LEVEL BINDING #############
    function unbindElement(element) {
        unbindQuerystringEvents(element);
        unbindFocus(element);
        unbindBlur(element);
        unbindKey(element);
        unbindSelection(element);
        unbindResize(element);
        unbindCMDS(element);
        unbindDeveloper(element);
    }
    function bindElement(element) {
        bindQuerystringEvents(element);
        bindFocus(element);
        bindBlur(element);
        bindKey(element);
        bindSelection(element);
        bindResize(element);
        bindCMDS(element);
        bindDeveloper(element);
    }


// #############################################################################
// ########################### ELEMENT INSTANTIATION ###########################
// #############################################################################

    function elementInserted(element) {
        var strKey;

        // if this ace is an encrypted ace, we may have to trigger the password
        //      popup
        strKey = element.getAttribute('encrypted');

        if (strKey && !window[strKey] && !window['getting' + strKey]) {
            window['getting' + strKey] = true;
            GS.triggerEvent(
                element,
                'password-error',
                {"reason": "no", "keyVariable": strKey}
            );
        }

        // proceed with element initiation
        if (
            // if "created"/"inserted" are not suspended: continue
            !element.hasAttribute('suspend-created') &&
            !element.hasAttribute('suspend-inserted') &&
            // if this is the first time inserted has been run: continue
            !element.inserted
        ) {
            element.inserted = true;

            // we need to wait to initiate any ace elements until after all
            //      related files have been downloaded. We don't want to slow
            //      down most pages with ace, so we load the ace files on the
            //      first "inserted" lifecycle call of a gs-ace
            loadAce(function () {
                prepareElement(element);
                bindElement(element);
                render(element, true);
            });
        }
    }

    xtag.register('gs-ace', {

// #############################################################################
// ############################# ELEMENT LIFECYCLE #############################
// #############################################################################

        lifecycle: {
            'inserted': function () {
                elementInserted(this);
            },

            'removed': function () {
                this.destroy();
            },

            'attributeChanged': function (attr) {//, oldValue, newValue
                var element = this;

                // if suspend attribute: run inserted event
                if (attr === 'suspend-created' || attr === 'suspend-inserted') {
                    elementInserted(element);

                // if the element is not suspended: handle attribute changes
                } else if (
                    !element.hasAttribute('suspend-created') &&
                    !element.hasAttribute('suspend-inserted') &&
                    // if ace isn't loaded, no need to re-render because the
                    //      first render hasn't happened yet.
                    bolAceLoaded
                ) {
                    render(element);
                }
            }
        },

// #############################################################################
// ############################# ELEMENT ACCESSORS #############################
// #############################################################################

        accessors: {
            // the "value" attribute is the master location for the text value
            //      anything else would lead to confusion. So, the .value
            //      accessor just sets the attribute.
            'value': {
                'get': function () {
                    return this.getAttribute('value');
                },
                'set': function (newValue) {
                    setEncryptElemVal(this, newValue);
                }
            }
        },

// #############################################################################
// ############################## ELEMENT METHODS ##############################
// #############################################################################

        methods: {
            // we don't want a bunch of data hanging in memory, so this allows
            //      the browser to forget everything and use that memory for
            //      other things. This is especially important if the ace has
            //      a boatload of data.
            'destroy': function () {
                var element = this;

                // sometimes, the element is destroyed before it's initialized
                // sometimes, the element gets destroyed multiple times.
                //      we don't want to cause any errors when this happens.
                if (element.elems && element.elems.root) {
                    // prevent the element from recieving any events
                    unbindElement(element);

                    // this is the fastest way to destroy all of the data
                    element.internalAce = {};
                    element.internalData = {};
                    element.internalEvents = {};
                    element.internalDisplay = {};

                    // destroy element store
                    element.elems = {};

                    // empty innerHTML
                    element.innerHTML = '';
                }
            },

            // we want to be able to have an external toolbar to toggle comments
            'toggleComments': function () {
                this.internalDisplay.editor.toggleCommentLines();
                this.internalDisplay.editor.focus();
            },

            // we want to be able to have an external toolbar to indent code
            'indentSelected': function () {
                this.internalDisplay.editor.blockIndent();
                this.internalDisplay.editor.focus();
            },

            // we want to be able to have an external toolbar to outdent code
            'outdentSelected': function () {
                this.internalDisplay.editor.blockOutdent();
                this.internalDisplay.editor.focus();
            },

            // we want to be able to extend the snippet list
            'addSnippet': function (strName, strTabTrigger, strSnippet) {
                snippetManager.register([
                    {
                        'name': strName,
                        'tabTrigger': strTabTrigger,
                        'content': strSnippet
                    }
                ]);
            },

            // we want to be able to offer different functionality depending
            //      on what the user has selected.
            'getSingleSelection': function () {
                var selection = this.internalAce.getSelection();
                var selectionRange = this.internalAce.getSelectionRange();

                if (selection.inMultiSelectMode !== true) {
                    return selectionRange;
                }

                // if the user is doing multi selection, we're not getting into
                //      that
                return {
                    "start": {"row": 0, "column": 0},
                    "end": {"row": 0, "column": 0}
                };
            },

            // sometimes, we don't want to allow the user to undo beyond a
            //      certain point. So, you can call this method to clear the
            //      undo history
            'clearUndo': function () {
                this.internalAce.session.getUndoManager().reset();
            },

            // we want to re-render the ace and it's contents
            'render': function () {
                render(this);
            },

            // we want to be able to set the search box
            'find': function (strFind, bolRegex, bolInsens, bolWholeWord) {
                var strSelector;
                var classList;
                var objSearchField;
                var regexToggle;
                var sensitiveToggle;
                var wholeToggle;

                // we only want to do something if a search string is provided
                if (strFind) {
                    // we have a search string, find
                    this.internalAce.find(strFind);
                    this.internalAce.execCommand('find');

                    // ### SEARCH FIELD ###
                    strSelector = '.ace_search_field';
                    objSearchField = xtag.query(this, strSelector)[0];
                    classList = objSearchField.classList;
                    objSearchField.value = strFind;

                    // ### REGEX BUTTON ###
                    strSelector = '.ace_button[action="toggleRegexpMode"]';
                    regexToggle = xtag.query(this, strSelector)[0];
                    classList = regexToggle.classList;

                    if (
                        // we want regex, and it's not checked, check
                        (bolRegex && !classList.contains('checked')) ||
                        // we don't want regex, and it's checked, uncheck
                        (!bolRegex && classList.contains('checked'))
                    ) {
                        GS.triggerEvent(regexToggle, 'click');
                    }

                    // ### CASE BUTTON ###
                    strSelector = '.ace_button[action="toggleCaseSensitive"]';
                    sensitiveToggle = xtag.query(this, strSelector)[0];
                    classList = sensitiveToggle.classList;

                    if (
                        // we want sensitive, and it's not checked, check
                        (!bolInsens && !classList.contains('checked')) ||
                        // we don't want sensitive, and it's checked, uncheck
                        (bolInsens && classList.contains('checked'))
                    ) {
                        GS.triggerEvent(sensitiveToggle, 'click');
                    }

                    // ### WHOLE WORDS ###
                    strSelector = '.ace_button[action="toggleWholeWords"]';
                    wholeToggle = xtag.query(this, strSelector)[0];
                    classList = wholeToggle.classList;

                    if (
                        // we want whole words, and it's not checked, check
                        (bolWholeWord && !classList.contains('checked')) ||
                        // we don't want whole words, and it's checked, uncheck
                        (!bolWholeWord && classList.contains('checked'))
                    ) {
                        GS.triggerEvent(wholeToggle, 'click');
                    }
                }
            },

            // we want to be able to change selection for the editor
            'setSelection': function (startRow, startCol, endRow, endCol) {
                var jsnRange;

                // if no start row/column have been provided: we gotta error
                if (
                    startRow === undefined || startCol === undefined ||
                    startRow === null || startCol === null
                ) {
                    throw 'GS-ACE Error: no selection start provided.';
                }

                // if only a start row/column is provided, make the selection
                //      end in the same place. effectivly moving the cursor and
                //      not having a selection
                if (
                    endRow === undefined || endCol === undefined ||
                    endRow === null || endCol === null
                ) {
                    endRow = startRow;
                    endCol = startCol;
                }

                // apply selection
                jsnRange = new Range(startRow, startCol, endRow, endCol);
                this.internalAce.selection.setSelectionRange(jsnRange);
            },

            // we need to pass the focus through
            'focus': function () {
                if (this.internalAce) {
                    this.internalAce.focus();
                }
            },

            // we want to be able to highlight portions of the text that are
            //      relevant. The primary example is the property pane in the
            //      file editor. We highlight the closest html element to the
            //      cursor and allow the user to change it in the property pane.
            'addHighlight': function (strName, stRow, stCol, enRow, enCol) {
                // we need to make sure the name is valid to use as a JSON
                //      property name and as a CSS class, because we're going to
                //      use it for both.
                if (!(/^[a-z0-9\-\_]+$/i).test('asdfasdf')) {
                    throw (
                        'GS-ACE Error: ' +
                            'invalid highlight name "' + strName + '"' +
                            ' sent to ".addHighlight()". Only use ' +
                            'alphanumeric, underscore, and/or dash.'
                    );
                }

                // if we already have one added with this name, we need to
                //      remove it before we can add it again. You can't have two
                //      with the same name.
                if (this.internalDisplay.markers[strName]) {
                    this.removeMarker(strName);
                }

                // now that we're sure that we have a good name and that we
                //      aren't going to overwrite one that already exists, let's
                //      create the marker.
                this.internalDisplay.markers[strName] = (
                    this.internalAce.session.addMarker(
                        new Range(stRow, stCol, enRow, enCol),
                        'gs-ace-marker ' + strName,
                        'background'
                    )
                );
            },

            // we want to be able to remove text highlighting
            'removeHighlight': function (strName) {
                // we don't want to remove markers that don't exist
                if (this.internalDisplay.markers[strName]) {
                    // remove the marker from ace
                    this.internalAce.session.removeMarker(
                        this.internalDisplay.markers[strName]
                    );

                    // clear our reference to the marker, so that we know it's
                    //      no longer a marker
                    this.internalDisplay.markers[strName] = null;
                }
            },

            // we need to be able to translate row/column to character number
            'rowAndColumnToCharNumber': function (stRow, stCol) {
                var strValue = getDecryptAceVal(this);
                var arrValue = strValue.split('\n');
                var charCount;
                var i;

                // if no start row/column have been provided: we gotta error
                if (
                    stRow === undefined || stCol === undefined ||
                    stRow === null || stCol === null
                ) {
                    throw 'GS-ACE Error: no row/column provided.';
                }

                // if row is beyond value, error
                if (stRow > arrValue.length) {
                    throw 'GS-ACE Error: row out of range.';
                }

                // we need to loop through each line because each line may have
                //      different amounts of characters.
                charCount = stCol;
                i = 0;
                while (i < stRow) {
                    charCount += arrValue[i].length + 1; // +1 for newline

                    // if column is beyond value, error
                    if (i === (stRow - 1) && stCol > arrValue[i].length) {
                        throw 'GS-ACE Error: column out of range.';
                    }

                    i += 1;
                }

                return charCount;
            }
        }
    });
});
//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, shimmed
//jslint browser:true, maxlen:80, white:false, this:true

window.addEventListener('design-register-element', function () {
    "use strict";
    addSnippet('<gs-body>', '<gs-body>', 'gs-body padded>\n    $0\n</gs-body>');
    addElement('gs-body', '#layout_page');

    window.designElementProperty_GSBODY = function () {
        addCheck('V', 'Padded', 'padded');
        addFlexContainerProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    xtag.register('gs-body', {
        lifecycle: {
            created: function () {
                if (
                    !this.hasAttribute('role') &&
                    !GS.findParentTag(this, 'gs-dialog')
                ) {
                    this.setAttribute('role', 'main');
                }
            }
        },
        events: {},
        accessors: {},
        methods: {}
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps

(function () {
    'use strict';

    function defineButton(strTagName, strDocLink, arrDisableWhenEmptyAttributes, designAdditionalFunction, clickFunction) {
        strDocLink = strDocLink || '#controls_buttons_toggle';
        designAdditionalFunction = designAdditionalFunction || function () {};
        clickFunction = clickFunction || function () {};

        window.addEventListener('design-register-element', function () {
            addSnippet(
                '<' + strTagName + '>',
                '<' + strTagName + '>',
                strTagName + '>${1}</' + strTagName + '>'
            );

            addElement(strTagName, strDocLink);

            window['designElementProperty_' + strTagName.replace(/[^a-z0-9]/gi, '').toUpperCase()] = function (selectedElement) {
                addCheck('D', 'Disabled', 'disabled');
                addCheck('O', 'No Focus', 'no-focus');
                addCheck('V', 'Inline', 'inline');
                addCheck('V', 'Jumbo', 'jumbo');
                addCheck('V', 'Mini', 'mini');
                addText('O', 'Hot Key', 'key');
                addCheck('O', 'No Modifier For Hot Key', 'no-modifier-key');
                addSelect('O', 'Modifier for Hot Key', 'modifier-key', [
                    {"val": "", "txt": "Default (Ctrl)"},
                    {"val": "ctrl", "txt": "Ctrl"},
                    {"val": "alt", "txt": "Alt"},
                    {"val": "meta", "txt": "Meta"}
                ]);
                designAdditionalFunction(selectedElement);
                addFocusEvents('static');
                addText('O', 'Column In QS', 'qs');
                addIconProps();
                addBasicThemingProps();
                addCornerRoundProps();
                addFlexProps();
            };
        });

        document.addEventListener('DOMContentLoaded', function () {
            function handleDisable(element) {
                var i, len;

                element.removeAttribute('disabled');

                for (i = 0, len = arrDisableWhenEmptyAttributes.length; i < len; i += 1) {
                    if (!element.getAttribute(arrDisableWhenEmptyAttributes[i])) {
                        element.setAttribute('disabled', '');
                        break;
                    }
                }
            }

            //function pushReplacePopHandler(element) {
            //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');

            //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
            //        element.setAttribute('value', GS.qryGetVal(strQueryString, strQSCol));
            //    }
            //}
            function saveDefaultAttributes(element) {
                var i;
                var len;
                var arrAttr;
                var jsnAttr;

                // we need a place to store the attributes
                element.internal.defaultAttributes = {};

                // loop through attributes and store them in the internal defaultAttributes object
                arrAttr = element.attributes;
                i = 0;
                len = arrAttr.length;
                while (i < len) {
                    jsnAttr = arrAttr[i];

                    element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

                    i += 1;
                }
            }

            function pushReplacePopHandler(element) {
                var i;
                var len;
                var strQS = GS.getQueryString();
                var strQSCol = element.getAttribute('qs');
                var strQSValue;
                var strQSAttr;
                var arrQSParts;
                var arrAttrParts;
                var strOperator;

                if (strQSCol.indexOf('=') !== -1) {
                    arrAttrParts = strQSCol.split(',');
                    i = 0;
                    len = arrAttrParts.length;
                    while (i < len) {
                        strQSCol = arrAttrParts[i];

                        if (strQSCol.indexOf('!=') !== -1) {
                            strOperator = '!=';
                            arrQSParts = strQSCol.split('!=');
                        } else {
                            strOperator = '=';
                            arrQSParts = strQSCol.split('=');
                        }

                        strQSCol = arrQSParts[0];
                        strQSAttr = arrQSParts[1] || arrQSParts[0];

                        // if the key is not present or we've got the negator: go to the attribute's default or remove it
                        if (strOperator === '!=') {
                            // if the key is not present: add the attribute
                            if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                                element.setAttribute(strQSAttr, '');
                            // else: remove the attribute
                            } else {
                                element.removeAttribute(strQSAttr);
                            }
                        } else {
                            // if the key is not present: go to the attribute's default or remove it
                            if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                                if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                    element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                                } else {
                                    element.removeAttribute(strQSAttr);
                                }
                            // else: set attribute to exact text from QS
                            } else {
                                element.setAttribute(strQSAttr, (
                                    GS.qryGetVal(strQS, strQSCol) ||
                                    element.internal.defaultAttributes[strQSAttr] ||
                                    ''
                                ));
                            }
                        }
                        i += 1;
                    }
                } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                    strQSValue = GS.qryGetVal(strQS, strQSCol);

                    if (element.internal.bolQSFirstRun !== true) {
                        if (strQSValue !== '' || !element.getAttribute('value')) {
                            element.setAttribute('value', strQSValue);
                        }
                    } else {
                        element.setAttribute('value', strQSValue);
                    }
                }

                element.internal.bolQSFirstRun = true;
            }

            // dont do anything that modifies the element here
            function elementCreated(element) {
                // if "created" hasn't been suspended: run created code
                if (!element.hasAttribute('suspend-created')) {

                }
            }

            //
            function elementInserted(element) {
                var strKey, strQSValue;

                if (element.tagName.toUpperCase() === 'GS-DELETE-BUTTON' && !element.hasAttribute('src')) {
                    console.warn(element, 'gs-delete-button needs a [src=""] attribute!');
                }

                // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
                if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    // if this is the first time inserted has been run: continue
                    if (!element.inserted) {
                        element.inserted = true;
                        element.internal = {};
                        saveDefaultAttributes(element);

                        if (element.getAttribute('qs')) {
                            //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                            //if (strQSValue !== '' || !element.getAttribute('value')) {
                            //    element.setAttribute('value', strQSValue);
                            //}
                            pushReplacePopHandler(element);
                            window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                            window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                            window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                        }

                        // add a tabindex to allow focus (if allowed)
                        if (!element.hasAttribute('no-focus')) {
                            if ((!element.tabIndex) || element.tabIndex === -1) {
                                element.tabIndex = 0;
                            }
                        } else {
                            element.removeAttribute('tabindex');
                        }
                        
                        if (!evt.touchDevice) {
                            element.addEventListener('focus', function (event) {
                                element.classList.add('focus');
                            });
                            
                            element.addEventListener('blur', function (event) {
                                element.classList.remove('focus');
                            });
                            
                            
                            element.addEventListener(evt.mousedown, function (event) {
                                element.classList.add('down');
                            });
                            
                            element.addEventListener(evt.mouseout, function (event) {
                                element.classList.remove('down');
                                element.classList.remove('hover');
                            });
                            
                            element.addEventListener(evt.mouseover, function (event) {
                                element.classList.remove('down');
                                element.classList.add('hover');
                            });

                            element.addEventListener('keydown', function (event) {
                                if (
                                    !element.hasAttribute('disabled') &&
                                    !element.classList.contains('down') &&
                                    (
                                        event.keyCode === 13 ||
                                        event.keyCode === 32
                                    )
                                ) {
                                    element.classList.add('down');
                                }

                                if (element.hasAttribute('disabled')) {
                                    event.preventDefault();
                                    event.stopPropagation();
                                    return true;
                                }
                            });

                            element.addEventListener('keyup', function (event) {
                                // if we are not disabled and we pressed return (13) or space (32): trigger click
                                if (
                                    !element.hasAttribute('disabled') &&
                                    element.classList.contains('down') &&
                                    (
                                        event.keyCode === 13 ||
                                        event.keyCode === 32
                                    )
                                ) {
                                    GS.triggerEvent(element, 'click');
                                }
                            });
                        }

                        element.addEventListener('click', function (event) {
                            element.classList.remove('down');
                            if (!element.hasAttribute('disabled')) {
                                clickFunction(element);
                            } else {
                                event.preventDefault();
                                event.stopPropagation();
                                event.stopImmediatePropagation();
                            }
                        });
                        
                        element.addEventListener('keypress', function (event) {
                            // if we pressed return (13) or space (32): prevent default and stop propagation (to prevent scrolling of the page)
                            if (
                                event.target === element &&
                                (
                                    event.keyCode === 13 ||
                                    event.keyCode === 32
                                )
                            ) {
                                console.log('press, intercepted');
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        });
                        
                        if (element.getAttribute('key')) {
                            strKey = element.getAttribute('key');
                            
                            if (GS.keyCode(strKey)) {
                                if (strKey.match(/[arfcvxzntypq]/gim)) {
                                    console.warn('gs-skype-button Warning: by setting the hot key of this button to "' + strKey + '" you may be overriding browser functionality.', element);
                                }
                                
                                window.addEventListener('keydown', function __this_function(event) {
                                    // console.log(element, element.parentNode, document.body.contains(element));
                                    if (!document.body.contains(element)) {
                                        window.removeEventListener('keydown', __this_function);
                                        return;
                                    }
                                    var arrDialog = document.querySelectorAll('gs-dialog');
                                    var bolDialog = arrDialog.length > 0;
                                    var parentDialog = GS.findParentTag(element, 'gs-dialog');
                                    if (
                                            String(event.keyCode || event.which) === GS.keyCode(strKey) &&
                                            (
                                                (
                                                    (
                                                        (
                                                            element.hasAttribute('modifier-key') &&
                                                            element.hasAttribute('no-modifier-key') &&
                                                            !event.metaKey &&
                                                            !event.altKey &&
                                                            !event.ctrlKey
                                                        ) ||
                                                        (
                                                            element.hasAttribute('modifier-key') &&
                                                            element.getAttribute('modifier-key').toLowerCase() === 'ctrl' &&
                                                            !event.metaKey &&
                                                            !event.altKey &&
                                                            event.ctrlKey
                                                        ) ||
                                                        (
                                                            element.hasAttribute('modifier-key') &&
                                                            element.getAttribute('modifier-key').toLowerCase() === 'alt' &&
                                                            !event.metaKey &&
                                                            event.altKey &&
                                                            !event.ctrlKey
                                                        ) ||
                                                        (
                                                            element.hasAttribute('modifier-key') &&
                                                            element.getAttribute('modifier-key').toLowerCase() === 'meta' &&
                                                            event.metaKey &&
                                                            !event.altKey &&
                                                            !event.ctrlKey
                                                        ) ||
                                                        (
                                                            !element.hasAttribute('modifier-key') &&
                                                            !event.metaKey &&
                                                            !event.altKey &&
                                                            !event.ctrlKey
                                                        )
                                                    ) &&
                                                    (document.activeElement.tagName.toLowerCase() !== 'input' || document.activeElement.className === 'hidden-focus-control' || strKey.length > 0) &&
                                                    (document.activeElement.tagName.toLowerCase() !== 'textarea' || document.activeElement.className === 'hidden-focus-control' || strKey.length > 0) &&
                                                    (!bolDialog || parentDialog === arrDialog[arrDialog.length - 1])
                                                )
                                            )
                                        ) {
                                        event.preventDefault();
                                        event.stopPropagation();
                                        
                                        element.focus();
                                        GS.triggerEvent(element, 'click');
                                        if (element.getAttribute('href')) {
                                            window.open(element.getAttribute('href'), element.getAttribute('target') || '_blank');
                                        }
                                    }
                                });
                                
                            } else if (strKey.length > 1) {
                                console.error('gs-skype-button Error: \'key="' + strKey + '"\' is not a valid hot-key.', element);
                            }
                        }
                        
                        handleDisable(element);
                    }
                }
            }
            
            xtag.register(strTagName, {
                lifecycle: {
                    created: function () {
                        elementCreated(this);
                    },
                    
                    inserted: function () {
                        elementInserted(this);
                    },
                    
                    attributeChanged: function (strAttrName, oldValue, newValue) {
                        // if "suspend-created" has been removed: run created and inserted code
                        if (strAttrName === 'suspend-created' && newValue === null) {
                            elementCreated(this);
                            elementInserted(this);
                            
                        // if "suspend-inserted" has been removed: run inserted code
                        } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                            elementInserted(this);
                            
                        } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                            if (strAttrName === 'no-focus') {
                                if (!this.hasAttribute('no-focus')) {
                                    if ((!this.tabIndex) || this.tabIndex === -1) {
                                        this.tabIndex = 0;
                                    }
                                } else {
                                    this.removeAttribute('tabindex');
                                }
                            } else if (strAttrName === 'disabled') {
                                this.classList.remove('down');
                            } else if (arrDisableWhenEmptyAttributes.indexOf(strAttrName) > -1) {
                                handleDisable(this);
                            }
                        }
                    }
                },
                accessors: {
                    value: {
                        get: function () {
                            return this.getAttribute('value');
                        },
                        set: function (newValue) {
                            this.setAttribute('value', newValue);
                        }
                    }
                }
            });
        });
    }
    
    
    
    defineButton('gs-email-button', '', ['value'], '', function (element) {
        var emailAddress = element.getAttribute('value'), linkIframe, loadHandler;
        
        if (emailAddress) {
            linkIframe = document.createElement('iframe');
            document.body.appendChild(linkIframe);
            
            loadHandler = function () {
                document.body.removeChild(linkIframe);
                document.removeEventListener('mousedown', loadHandler);//'mousedown'
            };
            
            document.addEventListener('mousedown', loadHandler);//'mousedown'
            // linkIframe.setAttribute('onLoad', 'console.log(\'runnin\'); loadHandler();');
            linkIframe.setAttribute('style', 'display: none;');
            linkIframe.setAttribute('src', 'mailto:' + emailAddress);
        }
    });
    
    defineButton('gs-facetime-button', '', ['value'], '', function (element) {
        var appleID = element.getAttribute('value');
        
        if (appleID) {
            window.open('facetime:' + appleID);
        }
    });

    defineButton('gs-map-button', '', ['value'], '', function (element) {
        var strLocation = encodeURIComponent(element.getAttribute('value'));

        if (strLocation) {
            if (element.hasAttribute('google') === true) {
                window.open('https://maps.google.com/maps?q=' + strLocation);
            } else if (element.hasAttribute('bing') === true) {
                window.open('http://www.bing.com/maps/default.aspx?q=' + strLocation);
            } else {
                window.open('https://maps.google.com/maps?q=' + strLocation);
            }
        }
    });

    defineButton('gs-phone-button', '', ['value'], '', function (element) {
        var phoneNumber = element.getAttribute('value');

        if (phoneNumber) {
            if (evt.deviceType === 'phone') {
                window.open('tel:' + phoneNumber);
            } else {
                GS.msgbox('Phone Number', '<center>' + phoneNumber + '</center>', ['Done']);
            }
        }
    });

    defineButton('gs-tracking-button', '', ['value'], function () {
        addAttributeSwitcherProp('D', 'Service', [
            {"val": "", "txt": "None"},
            {"val": "usps", "txt": "USPS"},
            {"val": "ups", "txt": "UPS"},
            {"val": "fedex", "txt": "FEDEX"},
            {"val": "royal", "txt": "Royal Mail"},
            {"val": "amz", "txt": "Amazon"}
        ]);

    }, function (element) {
        var strTrackingNumber = element.getAttribute('value');

        if (strTrackingNumber) {
            if (element.hasAttribute('usps') === true) {
                window.open('https://tools.usps.com/go/TrackConfirmAction?tLabels=' + strTrackingNumber);

            } else if (element.hasAttribute('ups') === true) {
                // window.open('http://www.ups.com/WebTracking/processInputRequest?tracknum=' + strTrackingNumber);
                window.open('https://www.ups.com/track?loc=en_US&tracknum=' + strTrackingNumber + '&requester=MB/trackdetails');

            } else if (element.hasAttribute('fedex') === true) {
                window.open('https://www.fedex.com/apps/fedextrack/index.html?tracknumbers=' + strTrackingNumber);

            } else if (element.hasAttribute('royal') === true) {
                window.open('https://www.royalmail.com/track-your-item?trackNumber=' + strTrackingNumber);

            } else if (element.hasAttribute('amz') === true) {
                window.open(decodeURIComponent(strTrackingNumber));

            } else {
                GS.msgbox('Please Choose...',
                          '<center>Please Choose UPS, USPS, Fedex, Royal Mail or Amazon</center>',
                          ['UPS', 'USPS', 'Fedex', 'Royal Mail', 'Amazon'],
                          function (strAnswer) {
                    if (strAnswer === 'UPS') {
                        window.open('http://www.ups.com/WebTracking/processInputRequest?tracknum=' + strTrackingNumber);
                    } else if (strAnswer === 'USPS') {
                         window.open('https://tools.usps.com/go/TrackConfirmAction?tLabels=' + strTrackingNumber);
                    } else if (strAnswer === 'Fedex') {
                         window.open('https://www.fedex.com/apps/fedextrack/index.html?tracknumbers=' + strTrackingNumber);
                    } else if (strAnswer === 'Royal Mail') {
                         window.open('https://www.royalmail.com/track-your-item?trackNumber' + strTrackingNumber);
                    } else if (strAnswer === 'Amazon') {
                         window.open(strTrackingNumber);
                    }
                });
            }
        }
    });

    defineButton('gs-skype-button', '', ['value'], '', function (element) {
        if (element.getAttribute('value')) {
            window.open('skype:' + element.getAttribute('value'));
        }
    });

    defineButton('gs-delete-button',
                 '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-delete-button.html',
                 ['value', 'src'],
                 function () {
        addText('D', 'Source', 'src');
        addText('D', 'Delete Action', 'action-delete');
    }, function (element) {
        if (element.getAttribute('value')) {
            var arrSrcParts = element.getAttribute('src').split('.');
            var strSchema = arrSrcParts[0];
            var strObject = arrSrcParts[1];
            var strPkColumn, strLockColumn;
            var deleteRecordData;
            var strHashColumns;
            var strRoles;
            var strColumns;
            var strRecord;
            var strDeleteData;
            var strHash;
            var strPkValue;
            var strLockValue;
            
            if (element.deleting) {
                console.warn('double delete!');
                return;
            }
            element.deleting = true;

            element.classList.remove('down');

            strPkColumn = element.getAttribute('column') || 'id';
            strLockColumn = strPkColumn;
            strHashColumns = strLockColumn;

            strPkValue = GS.encodeForTabDelimited(element.getAttribute('value') || '');
            strLockValue = element.getAttribute('value') || '';

            strRoles = 'pk\thash';
            strColumns = strPkColumn + '\thash';

            strHash = CryptoJS.MD5(strLockValue === 'NULL' ? '' : strLockValue).toString();

            strDeleteData = strPkValue + '\t' + strHash + '\n';
            strDeleteData = strRoles + '\n' + strColumns + '\n' + strDeleteData;

            // create delete transaction
            GS.addLoader(element, 'Deleting...');
            GS.requestDeleteFromSocket(
                GS.envSocket, strSchema, strObject, strHashColumns, strDeleteData
                , function (data, error, transactionID) {
                    if (error) {
                        GS.removeLoader(element);
                        GS.webSocketErrorDialog(data);
                    }
                }
                , function (data, error, transactionID, commitFunction, rollbackFunction) {
                    var arrElements, i, len, templateElement;
                    GS.removeLoader(element);

                    if (!error) {
                        if (data !== 'TRANSACTION COMPLETED') {

                        } else {
                            templateElement = document.createElement('template');
                            templateElement.innerHTML = ml(function () {/*
                                <gs-page>
                                    <gs-header><center><h3>Are you sure...</h3></center></gs-header>
                                    <gs-body padded>
                                        <center>Are you sure you want to delete?</center>
                                    </gs-body>
                                    <gs-footer>
                                        <gs-grid>
                                            <gs-block><gs-button dialogclose>No</gs-button></gs-block>
                                            <gs-block><gs-button id="datasheet-focus-me" dialogclose bg-primary tabindex="0">Yes</gs-button></gs-block>
                                        </gs-grid>
                                    </gs-footer>
                                </gs-page>
                            */});

                            GS.openDialog(templateElement, function () {
                                document.getElementById('datasheet-focus-me').focus();

                            }, function (event, strAnswer) {
                                if (strAnswer === 'Yes') {
                                    commitFunction();
                                    GS.addLoader(element, 'Commiting Delete Transaction...');
                                } else {
                                    rollbackFunction();
                                    GS.addLoader(element, 'Rolling Back Delete Transaction...');
                                }
                            });
                        }

                    } else {
                        rollbackFunction();
                        GS.webSocketErrorDialog(data);
                    }
                }
                , function (strAnswer, data, error) {
                    var arrElements, i, len;
                    GS.removeLoader(element);
                    element.deleting = false;

                    if (!error) {
                        if (strAnswer === 'COMMIT') {
                            GS.triggerEvent(element, 'success');
                            if (element.hasAttribute('onsuccess')) {
                                new Function(element.getAttribute('onsuccess')).apply(element);
                            }
                        }

                    } else {
                        getData(element);
                        GS.webSocketErrorDialog(data);
                    }
                }
            );
        }
    });

    defineButton('gs-option',
                 '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-optionbox.html',
                 [],
                 function () {},
                 function (element) {});


    window.addEventListener('design-register-element', function () {
        addSnippet('<gs-dialog-button> With Template', '<gs-dialog-button>', '' +
              'template id="$1">\n' +
              '    <gs-page>\n' +
              '        <gs-header>\n' +
              '            <center><h3>$3</h3></center>\n' +
              '        </gs-header>\n' +
              '        <gs-body padded>\n' +
              '            $4\n' +
              '        </gs-body>\n' +
              '        <gs-footer>\n' +
              '            <gs-grid gutter>\n' +
              '                <gs-block>\n' +
              '                    <gs-button dialogclose>Cancel</gs-button>\n' +
              '                </gs-block>\n' +
              '                <gs-block>\n' +
              '                    <gs-button dialogclose bg-primary>Save</gs-button>\n' +
              '                </gs-block>\n' +
              '            </gs-grid>\n' +
              '        </gs-footer>\n' +
              '    </gs-page>\n' +
              '</template>\n' +
              '<gs-dialog-button template="$1" before-open="$5" after-open="$6" before-close="$7" after-close="$8">' +
              '$2' +
              '</gs-dialog-button>' +
              '\n\n');
    });

    defineButton('gs-dialog-button',
        '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-dialog-button.html',
        [],
        function () {
            addText('O', 'Template', 'template');
            addText('O', 'Attach To Element', 'target-element');
            addSelect('O', 'Attachment Direction', 'direction', [
                {"val": "", "txt": "Default"},
                {"val": "left", "txt": "Left"},
                {"val": "right", "txt": "Right"},
                {"val": "up", "txt": "Up"},
                {"val": "down", "txt": "Down"}
            ]);
            addText('E', 'Before Open', 'before-open');
            addText('E', 'After Open', 'after-open');
            addText('E', 'Before Close', 'before-close');
            addText('E', 'After Close', 'after-close');
        },
        function (element) {// on click
            var targetElement;
            var strTemplate = element.getAttribute('template');
            var templateElement;
            var strTargetSelector = element.getAttribute('target');
            var strDirection = element.getAttribute('direction');
            var strBeforeOpen = element.getAttribute('before-open');
            var strAfterOpen = element.getAttribute('after-open');
            var strBeforeClose = element.getAttribute('before-close');
            var strAfterClose = element.getAttribute('after-close');
            var afterOpenFunction;
            var beforeCloseFunction;
            var afterCloseFunction;

            templateElement = (strTemplate ? document.getElementById(strTemplate) : xtag.queryChildren(element, 'template')[0]);

            if (templateElement) {
                if (strBeforeOpen) {
                    new Function(strBeforeOpen).apply(element);
                }
                GS.triggerEvent(element, 'before-open');

                afterOpenFunction = function () {
                    if (strAfterOpen) {
                        new Function(strAfterOpen).apply(this);
                    }
                    GS.triggerEvent(element, 'after-open');
                };

                beforeCloseFunction = function (event, strAnswer) {
                    // if there is a before close function: run the code
                    if (strBeforeClose) {
                        // append a definition for the "strAnswer" variable before the code (the replace calls are to make the string safe)
                        new Function('var strAnswer = \'' + strAnswer.replace(/'/g, 'donTGueSsThiSUniTokEN1975') + '\'' +
                                                    '.replace(/donTGueSsThiSUniTokEN1975/g, \'\\\'\');\n' + strBeforeClose).apply(this);
                    }
                    GS.triggerEvent(element, 'before-close', {'strAnswer': strAnswer});
                };

                afterCloseFunction = function (event, strAnswer) {
                    // if there is a after close function: run the code
                    if (strAfterClose) {
                        // append a definition for the "strAnswer" variable before the code (the replace calls are to make the string safe)
                        new Function('var strAnswer = \'' + strAnswer.replace(/'/g, 'donTGueSsThiSUniTokEN1975') + '\'' +
                                                    '.replace(/donTGueSsThiSUniTokEN1975/g, \'\\\'\');\n' + strAfterClose).apply(element);
                    }
                    GS.triggerEvent(element, 'after-close', {'strAnswer': strAnswer});
                };

                if (strTargetSelector || element.hasAttribute('target')) {
                    strTargetSelector = (strTargetSelector || 'this');
                    targetElement = (
                        strTargetSelector === 'this'
                            ? element
                            : document.querySelector(strTargetSelector)
                    );
                    strDirection = (strDirection || 'down');

                    GS.openDialogToElement(
                        targetElement,
                        templateElement,
                        strDirection,
                        afterOpenFunction,
                        beforeCloseFunction,
                        afterCloseFunction
                    );
                } else {
                    GS.openDialog(
                        templateElement,
                        afterOpenFunction,
                        beforeCloseFunction,
                        afterCloseFunction
                    );
                }
            }
        });
})();














window.addEventListener('design-register-element', function () {
    "use strict";

    addSnippet('<gs-button>', '<gs-button>', 'gs-button>${1}</gs-button>');

    addElement('gs-button', '#controls_buttons_toggle');

    window.designElementProperty_GSBUTTON = function(selectedElement) {
        addCheck('D', 'Disabled', 'disabled');
        addCheck('O', 'No Focus', 'no-focus');
        addCheck('V', 'Inline', 'inline');
        addCheck('V', 'Jumbo', 'jumbo');
        addCheck('V', 'Mini', 'mini');
        addText('O', 'Hot Key', 'key');
        addCheck('O', 'No Modifier For Hot Key', 'no-modifier-key');
        addSelect('O', 'Modifier for Hot Key', 'modifier-key', [
            {"val": "", "txt": "Default (Ctrl)"},
            {"val": "ctrl", "txt": "Ctrl"},
            {"val": "alt", "txt": "Alt"},
            {"val": "meta", "txt": "Meta"}
        ]);
        addText('O', 'Href', 'href');
        addSelect('O', 'Target', 'target', [
            {"val": "", "txt": "Default"},
            {"val": "_self", "txt": "Current Window"},
            {"val": "_blank", "txt": "New Window"}
        ]);
        addCheck('O', 'Dialog Close', 'dialogclose');
        addFocusEvents('static');
        addText('O', 'Column In QS', 'qs');
        addIconProps();
        addBasicThemingProps();
        addCornerRoundProps();
        addFlexProps();
    };
});


document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    
    function refreshAnchor(element) {
        var strLink = element.getAttribute('href') || element.getAttribute('value');

        if (element.anchorElement) {
            element.removeChild(element.anchorElement);
        }

        var strInner = element.innerText;
        
        if (strLink) {
            element.anchorElement = document.createElement('a');
            element.anchorElement.setAttribute('gs-dynamic', '');
            element.anchorElement.setAttribute('target', element.getAttribute('target') || '_blank');
            element.anchorElement.setAttribute('href', strLink);
            
            if (element.getAttribute('onclick')) {
                //element.anchorElement.setAttribute('onclick', element.getAttribute('onclick'));
            }
            
            if (element.hasAttribute('download')) {
                element.anchorElement.setAttribute('download', element.getAttribute('download'));
            }
            
            if (element.hasAttribute('dialogclose')) {
                element.anchorElement.setAttribute('dialogclose', element.getAttribute('dialogclose'));
            }
            
            element.anchorElement.innerText = strInner;
            
            element.appendChild(element.anchorElement);
        }
    }
    
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.setAttribute('value', strQSValue);
            }
        }

        element.internal.bolQSFirstRun = true;
    }
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            if (!element.hasAttribute('role')) {
                element.setAttribute('role', 'button');
            }
        }
    }
    
    //
    function elementInserted(element) {
        var strKey;
        
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (element.getAttribute('qs')) {
                    //var strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.setAttribute('value', strQSValue);
                    //}
                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                }
                
                // add a tabindex to allow focus (if allowed)
                if (!element.hasAttribute('no-focus')) {
                    if ((!element.tabIndex) || element.tabIndex === -1) {
                        element.tabIndex = 0;
                    }
                } else {
                    element.removeAttribute('tabindex');
                }


                if (element.hasAttribute('disabled')) {
                    element.setAttribute('aria-disabled', 'true');
                }

                element.classList.remove('down');
                element.classList.remove('hover');

                if (element.onclick) {
                    // This is because the general 'onclick' attribute doesn't respect the 'disabled' attribute
                    element.oldOnClick = element.onclick;
                    element.onclick = function () {
                        if (!element.hasAttribute('disabled')) {
                            element.oldOnClick.apply(element, arguments);
                        }
                    };
                }
                
                element.addEventListener('click', function (event) {
                    element.classList.remove('down');
                    if (element.hasAttribute('disabled')) {
                        event.preventDefault();
                        event.stopPropagation();
                        event.stopImmediatePropagation();
                    }
                });
                
                if (!evt.touchDevice) {
                    element.addEventListener('focus', function (event) {
                        element.classList.add('focus');
                    });
                    
                    element.addEventListener('blur', function (event) {
                        element.classList.remove('focus');
                    });
                    
                    element.addEventListener(evt.mousedown, function (event) {
                        element.classList.add('down');
                    });
                    
                    element.addEventListener(evt.mouseout, function (event) {
                        element.classList.remove('down');
                        element.classList.remove('hover');
                    });
                    
                    element.addEventListener(evt.mouseover, function (event) {
                        element.classList.remove('down');
                        element.classList.add('hover');
                    });
                    
                    element.addEventListener('keydown', function (event) {
                        if (!element.hasAttribute('disabled') &&
                            (event.keyCode === 13 || event.keyCode === 32)) {
                            element.classList.add('down');
                        }
                    });
                    
                    element.addEventListener('keyup', function (event) {
                        // if we are not disabled and we pressed return (13) or space (32): trigger click
                        if (!element.hasAttribute('disabled') && element.classList.contains('down') &&
                            (event.keyCode === 13 || event.keyCode === 32)) {
                            GS.triggerEvent(element, 'click');
                        }
                    });
                }
                
                refreshAnchor(element);
                
                element.addEventListener('click', function (event) {
                    element.classList.remove('down');
                });
                
                element.addEventListener('keypress', function (event) {
                    // if we pressed return (13) or space (32): prevent default and stop propagation (to prevent scrolling of the page)
                    if (event.keyCode === 13 || event.keyCode === 32) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                });
                
                strKey = element.getAttribute('key');
                
                if (strKey) {
                    if (GS.keyCode(strKey)) {
                        if (strKey.match(/[arfcvxzntypq]/gim)) {
                            console.warn('gs-button Warning: by setting the hot key of this button to "' + strKey + '" you may be overriding browser functionality.', element);
                        }
                        
                        window.addEventListener('keydown', function __this_function(event) {
                            // console.log(element, element.parentNode, document.body.contains(element));
                            if (!document.body.contains(element)) {
                                window.removeEventListener('keydown', __this_function);
                                return;
                            }
                            var arrDialog = document.querySelectorAll('gs-dialog');
                            var bolDialog = arrDialog.length > 0;
                            var parentDialog = GS.findParentTag(element, 'gs-dialog');
                            if (
                                    String(event.keyCode || event.which) === GS.keyCode(strKey) &&
                                    (
                                        (
                                            (
                                                (
                                                    element.hasAttribute('modifier-key') &&
                                                    element.hasAttribute('no-modifier-key') &&
                                                    !event.metaKey &&
                                                    !event.altKey &&
                                                    !event.ctrlKey
                                                ) ||
                                                (
                                                    element.hasAttribute('modifier-key') &&
                                                    element.getAttribute('modifier-key').toLowerCase() === 'ctrl' &&
                                                    !event.metaKey &&
                                                    !event.altKey &&
                                                    event.ctrlKey
                                                ) ||
                                                (
                                                    element.hasAttribute('modifier-key') &&
                                                    element.getAttribute('modifier-key').toLowerCase() === 'alt' &&
                                                    !event.metaKey &&
                                                    event.altKey &&
                                                    !event.ctrlKey
                                                ) ||
                                                (
                                                    element.hasAttribute('modifier-key') &&
                                                    element.getAttribute('modifier-key').toLowerCase() === 'meta' &&
                                                    event.metaKey &&
                                                    !event.altKey &&
                                                    !event.ctrlKey
                                                ) ||
                                                (
                                                    !element.hasAttribute('modifier-key') &&
                                                    !event.metaKey &&
                                                    !event.altKey &&
                                                    !event.ctrlKey
                                                )
                                            ) &&
                                            (document.activeElement.tagName.toLowerCase() !== 'input' || document.activeElement.className === 'hidden-focus-control' || strKey.length > 0) &&
                                            (document.activeElement.tagName.toLowerCase() !== 'textarea' || document.activeElement.className === 'hidden-focus-control' || strKey.length > 0) &&
                                            (!bolDialog || parentDialog === arrDialog[arrDialog.length - 1])
                                        )
                                    )
                                ) {
                                event.preventDefault();
                                event.stopPropagation();
                                
                                element.focus();
                                GS.triggerEvent(element, 'click');
                                if (element.getAttribute('href')) {
                                    window.open(element.getAttribute('href'), element.getAttribute('target') || '_blank');
                                }
                            }
                        });
                        
                    } else if (strKey.length > 1) {
                        console.error('gs-button Error: \'key="' + strKey + '"\' is not a valid hot-key.', element);
                    }
                }
            }
        }
    }
    
    xtag.register('gs-button', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                //console.log('attributeChanged', strAttrName, oldValue, newValue);
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'no-focus') {
                        if (!this.hasAttribute('no-focus') && !this.hasAttribute('tabindex')) {
                            this.setAttribute('tabindex', 0);
                        } else if (this.hasAttribute('no-focus')) {
                            this.removeAttribute('tabindex');
                        }
                    } else if (strAttrName === 'disabled') {
                        this.classList.remove('down');
                        if (newValue) {
                            this.setAttribute('aria-disabled', 'true');
                        } else {
                            this.removeAttribute('aria-disabled');
                        }
                    } else if (strAttrName === 'href' || strAttrName === 'target' || strAttrName === 'onclick' || strAttrName === 'download') {
                        refreshAnchor(this);
                    }
                }
            }
        },
        events: {},
        accessors: {},
        methods: {}
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, addFocusEvents
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';

    addSnippet(
        '<gs-checkbox>',
        '<gs-checkbox>',
        'gs-checkbox type="smallint" column="${1:ready_to_ship}">${2}</gs-checkbox>'
    );
    addSnippet(
        '<gs-checkbox> With Label',
        '<gs-checkbox>',
        'label for="${1:date-insert-ready_to_ship}">${2:Ready To Ship?}:</label>\n' +
                '<gs-checkbox id="${1:date-insert-ready_to_ship}" type="smallint" column="${3:ready_to_ship}"></gs-checkbox>'
    );

    addElement('gs-checkbox', '#controls_checkbox');

    window.designElementProperty_GSCHECKBOX = function () {
        addGSControlProps();
        addCheck('D', 'Triple State', 'triplestate');
        addCheck('O', 'Column In QS', 'qs');
        addCheck('V', 'Inline', 'inline');
        addSelect('D', 'Type', 'type', [
            {"val": "", "txt": "Detect"},
            {"val": "smallint", "txt": "Smallint"},
            {"val": "boolean", "txt": "Boolean"}
        ]);
        addFocusEvents();
        addCornerRoundProps();
        addFlexProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }

        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                element.internal.bolQSFirstRun = true;
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            if (!element.hasAttribute('role')) {
                element.setAttribute('role', 'checkbox');
            }
        }
    }

    function findFor(element) {
        var forElem;

        if (
            element.previousElementSibling &&
            element.previousElementSibling.tagName.toUpperCase() === 'LABEL' &&
            element.previousElementSibling.hasAttribute('for') &&
            element.previousElementSibling.getAttribute('for') === element.getAttribute('id')
        ) {
            forElem = element.previousElementSibling;
        } else if (xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]').length > 0) {
            forElem = xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]')[0];
        }

        if (forElem) {
            if (!element.hasAttribute('aria-label') && element.innerText.length === 0) {
                element.setAttribute('aria-label', forElem.innerText);
            }
        }
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};

                if (element.hasAttribute('value')) {
                    //console.log(element.getAttribute('value'));
                    if (element.getAttribute('value') === 'true' || element.getAttribute('value') === '-1') {
                        element.setAttribute('aria-checked', 'true');
                    } else if (element.getAttribute('value') === 'false' || element.getAttribute('value') === '0') {
                        element.setAttribute('aria-checked', 'false');
                    } else {
                        element.setAttribute('aria-checked', 'mixed');
                    }
                }

                // save default attribute settings so that the qs code can access those values
                saveDefaultAttributes(element);

                // if this checkbox has the "qs" attribute: fill from querystring and bind to querystring
                if (element.hasAttribute('qs')) {
                    pushReplacePopHandler(element);

                    window.addEventListener('pushstate', function () {
                        pushReplacePopHandler(element);
                    });
                    window.addEventListener('replacestate', function () {
                        pushReplacePopHandler(element);
                    });
                    window.addEventListener('popstate', function () {
                        pushReplacePopHandler(element);
                    });
                }

                element.addEventListener('focus', function () {
                    element.classList.add('focus');
                });

                element.addEventListener('blur', function () {
                    element.classList.remove('focus');
                });

                element.addEventListener(evt.mouseout, function () {
                    element.classList.remove('hover');
                });

                element.addEventListener(evt.mouseover, function () {
                    element.classList.add('hover');
                });

                // default value to false
                if (element.getAttribute('type') === 'smallint') {
                    element.value = element.getAttribute('value') || 0;
                } else {
                    element.value = element.getAttribute('value') || false;
                }

                // // add a tabindex to allow focus
                // if (!element.hasAttribute('tabindex')) {
                //     element.tabIndex = 0;
                // }
                // add a tabindex to allow focus (if allowed)
                if (!element.hasAttribute('no-focus')) {
                    if ((!element.tabIndex) || element.tabIndex === -1) {
                        element.tabIndex = 0;
                    }
                } else {
                    element.removeAttribute('tabindex');
                }
            }
        }
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            if (element.hasAttribute('id')) {
                //console.log('running');
                findFor(element);
            }
        }
    }

    xtag.register('gs-checkbox', {
        lifecycle: {
            created: function () {
                var element = this;
                // if the value was set before the "created" lifecycle code runs: set attribute
                //      (discovered when trying to set a value of a date control in the after_open of a dialog)
                //      ("delete" keyword added because of firefox)
                if (
                    !element.getAttribute('value') &&
                    element.value !== null &&
                    element.value !== undefined &&
                    (
                        typeof element.value === 'boolean' ||
                        element.value === '-1' ||
                        element.value === '0' ||
                        element.value === 'true' ||
                        element.value === 'false' ||
                        element.value === 'null' ||
                        element.value === 'n'
                    )
                ) {
                    element.setAttribute('value', element.value);
                    delete element.value;
                }

                elementCreated(element);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, ignore, newValue) {//oldValue
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // attribute code
                    if (strAttrName === 'value') {
                        if ((newValue === 'true') || (newValue === '-1')) {
                            this.setAttribute('aria-checked', 'true');
                        } else if ((newValue === 'false') || (newValue === '0')) {
                            this.setAttribute('aria-checked', 'false');
                        } else {
                            this.setAttribute('aria-checked', 'mixed');
                        }
                    }
                }
            }
        },
        events: {
            'mousedown': function () {
                if (
                    !this.hasAttribute('suspend-created') &&
                    !this.hasAttribute('suspend-inserted') &&
                    !this.hasAttribute('readonly') &&
                    !this.hasAttribute('disabled')
                ) {
                    this.classList.add('down');
                }
            },
            'mouseout': function () {
                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (this.classList.contains('down')) {
                        this.classList.remove('down');
                    }
                }
            },
            'click': function () {
                var bolTripleState;
                var strValue;
                var strType;

                if (
                    !this.hasAttribute('suspend-created') &&
                    !this.hasAttribute('suspend-inserted') &&
                    !this.hasAttribute('readonly') &&
                    !this.hasAttribute('disabled')
                ) {
                    bolTripleState = this.hasAttribute('triplestate');
                    strValue = this.getAttribute('value').trim().toLowerCase();

                    // get type from type attribute
                    strType = this.getAttribute('type');

                    // if type is not valid, get type from current value
                    if (strType !== 'smallint' && strType !== 'boolean') {
                        if (strValue === 'false' || strValue === 'true' || strValue === 'null') {
                            strType = 'boolean';
                        } else if (strValue === '0' || strValue === '-1' || strValue === 'n') {
                            strType = 'smallint';
                    // else default to boolean (this is for backwards compatibility, we prefer smallint)
                        } else {
                            strType = 'boolean';
                        }
                    }

                    // resolve current value to the correct type
                    if (strType === 'smallint') {
                        if (strValue === '0' || strValue === 'false') {
                            strValue = '0';
                        } else if (strValue === '-1' || strValue === 'true') {
                            strValue = '-1';
                        } else if (strValue === 'n' || strValue === 'null') {
                            strValue = 'n';
                        } else {
                            strValue = '0';
                        }
                    } else if (strType === 'boolean') {
                        if (strValue === '0' || strValue === 'false') {
                            strValue = 'false';
                        } else if (strValue === '-1' || strValue === 'true') {
                            strValue = 'true';
                        } else if (strValue === 'n' || strValue === 'null') {
                            strValue = 'null';
                        } else {
                            strValue = 'false';
                        }
                    }

                    // get new value based on current value
                    if (strType === 'smallint') {
                        if (strValue === '0') {
                            if (bolTripleState) {
                                strValue = 'n';
                            } else {
                                strValue = '-1';
                            }
                        } else if (strValue === '-1') {
                            strValue = '0';
                        } else if (strValue === 'n') {
                            strValue = '-1';
                        }
                    } else if (strType === 'boolean') {
                        if (strValue === 'false') {
                            if (bolTripleState) {
                                strValue = 'null';
                            } else {
                                strValue = 'true';
                            }
                        } else if (strValue === 'true') {
                            strValue = 'false';
                        } else if (strValue === 'null') {
                            strValue = 'true';
                        }
                    }

                    // set new value
                    this.setAttribute('value', strValue);

                    this.classList.remove('down');
                    xtag.fireEvent(this, 'change', {bubbles: true, cancelable: true});
                }
            },
            'keydown': function (event) {
                if (
                    !this.hasAttribute('suspend-created') &&
                    !this.hasAttribute('suspend-inserted') &&
                    !this.hasAttribute('readonly') &&
                    !this.hasAttribute('disabled')
                ) {
                    // if we pressed return (13) or space (32)
                    if (event.keyCode === 13 || event.keyCode === 32) {
                        // prevent default and stop propagation (to prevent scrolling of the page)
                        event.preventDefault();
                        event.stopPropagation();
                    }

                    // if we are not disabled and we pressed return (13) or space (32): trigger click
                    if (!this.attributes.disabled && (event.keyCode === 13 || event.keyCode === 32)) {
                        xtag.fireEvent(this, 'click', {bubbles: true, cancelable: true});
                    }
                }
            }
        },
        accessors: {
            value: {
                // get value straight from the attribute
                get: function () {
                    return this.getAttribute('value');
                },

                // set the value attribute
                set: function (newValue) {
                    this.setAttribute('value', newValue);
                }
            },
            textValue: {
                // return a text representation of the value
                get: function () {
                    var currentValue = this.getAttribute('value');

                    // if value is true: return YES
                    if (currentValue === '-1' || currentValue === 'true') {
                        return 'YES';
                    }

                    // if value is false: return NO
                    if (currentValue === '0' || currentValue === 'false') {
                        return 'NO';
                    }

                    // if value is null: return empty string
                    return '';
                },

                // set the value attribute
                set: function (newValue) {
                    if (newValue === 'YES') {
                        newValue = 'true';
                    }
                    if (newValue === 'NO') {
                        newValue = 'false';
                    }
                    this.setAttribute('value', newValue);
                }
            }
        },
        methods: {

        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, addFocusEvents, addDataEvents, addDataAttributes
//global addAutocompleteProps
//jslint browser:true, maxlen:80, white:false, this:true

// # CODE INDEX:          <- (use "find" (CTRL-f or CMD-f) to skip to a section)
//      # TOP             <- (this just brings you back this index)
//      # ELEMENT DOCUMENTATION
//      # NOTES/IDEAS
//      # SNIPPET/DESIGN
//      # FUNCTION SHORTCUTS
//      # UTILITY FUNCTIONS
//      # ELEMENT FUNCTIONS
//      # RENDER FUNCTIONS
//      # DATA FUNCTIONS
//      # EVENT FUNCTIONS
//          # QS EVENTS
//          # FOCUS EVENTS
//          # BLUR EVENTS
//          # CHANGE EVENTS
//          # KEY EVENTS
//          # DROPDOWN EVENTS
//          # DEVELOPER EVENTS
//          # HIGH LEVEL BINDING
//      # XTAG DEFINITION
//      # ELEMENT LIFECYCLE
//      # ELEMENT ACCESSORS
//      # ELEMENT METHODS
//
// For code that needs to be completed:
//      # NEED CODING


// ############################################################################
// ########################## ELEMENT DOCUMENTATION ###########################
// ############################################################################




// ############################################################################
// ############################### NOTES/IDEAS ################################
// ############################################################################
/*

FOCUS/BLUR/CHANGE stablize:
Detecting when focus enters/leaves a combo is tricky for a couple reasons.
        First, there's multiple elements capable of recieving the focus (the
        combo itself, the control, and the button. Second, the blur and focus
        events are timed such that document.activeElement isn't reliable. So,
        perhaps we should have a global event listener that handles keeping
        track of that and notifies the combobox elements when they've lost or
        gained the focus. After that, we intercept and stop propagation of all
        focus events unless it's triggered by the combo because of our global
        code (which we can do by putting a modifier on the event to mark it as
        free to pass). Stabilizing this will help stablize the change event.
        At the moment, it seems fine, but we can simplify the code if this
        works.

CODE ORGANIZATION ADJUSTMENT:
The dropdown code is under the "UTILITY FUNCTIONS" section at the moment, it
        would be better to move it to it's own section.

*/


// ############################################################################
// ############################## SNIPPET/DESIGN ##############################
// ############################################################################

window.addEventListener('design-register-element', function () {
    'use strict';

    addSnippet(
        '<gs-combo>',
        '<gs-combo>',
        ml(function () {/*gs-combo src="test.rtime_copy_datasheet">
    <template for="header">
        <gs-cell>${1}</gs-cell>
    </template>
    <template for="row">
        <gs-cell>${2}</gs-cell>
    </template>
</gs-combo>*/
        })
    );

    addElement('gs-combo', '#controls_combo');

    // DEFINE PROPERTIES
    window.designElementProperty_GSCOMBO = function (selected) {
        addGSControlProps();
        addDataAttributes('select');
        addText('V', 'Dropdown Width', 'dropdown-width');
        addText('V', 'Hide Columns', 'hide');
        addText('D', 'Null String', 'null-string');
        addFocusEvents();
        addDataEvents('select');
        addCheck('D', 'Allow Empty', 'allow-empty');
        addCheck('D', 'Limit&nbsp;To&nbsp;List', 'limit-to-list');
        addAutocompleteProps();
        addText('O', 'Column In QS', 'qs');
        addText('O', 'Refresh On QS Columns', 'refresh-on-querystring-values');
        addCheck('O', 'Refresh On QS Change', 'refresh-on-querystring-change');
        addFlexProps(selected);
    };
});

//var renderSeq = 0;
document.addEventListener('DOMContentLoaded', function () {
    'use strict';
// ############################################################################
// ############################ FUNCTION SHORTCUTS ############################
// ############################################################################

    var cmbQryKids = xtag.queryChildren;


// ############################################################################
// ############################ UTILITY FUNCTIONS #############################
// ############################################################################

    function extractAndConvertTableTemplate(element, templateElement) {
        // some genericly profound comment explaining the virtue of
        //      keeping the variable declarations at the top of the
        //      function while simultaniously being captivating and
        //      barely entertaining in a long run-on sentence.
        // That's it, that's the tweet.
        // Few will get this.
        // Tell your sons this.
        // Will not explain.
        var tableElement;
        var strHeaders;
        var strCells;
        var strData;
        var arrRows;
        var arrCells;

        var arrHeaders;
        var arrTypes;
        var arrRecords;

        var firstCell;
        var firstCellNumber;
        var i;
        var len;
        var cell_i;
        var cell_len;
        var cell;
        var strNullString;

        // we need to have the table element handy, because we'll be doing our
        //      selections to get the cells from there.
        tableElement = templateElement.content.children[0];

        // we need to know how we differentiate null strings for tab encoding
        strNullString = element.getAttribute('null-string');

        // some people, use th in the first field for a row number or other
        //      non-display information. We want to skip the first field if
        //      the first data field is a TH.
        firstCell = cmbQryKids(tableElement, 'tbody th, tbody td')[0];
        firstCellNumber = 0;
        if (firstCell.nodeName === 'TH') {
            firstCellNumber = 1;
        }

        // gather headers
        strHeaders = '';
        arrCells = cmbQryKids(tableElement, 'thead th, thead td');
        i = firstCellNumber;
        len = arrCells.length;
        while (i < len) {
            strHeaders += '<gs-cell>' + arrCells[i].innerHTML + '</gs-cell>';
            i += 1;
        }

        // if we didn't find any headers, create blank ones
        if (!strHeaders) {
            arrCells = cmbQryKids(
                tableElement,
                'tbody tr:first-child th, tbody tr:first-child td'
            );
            i = firstCellNumber;
            len = arrCells.length;
            while (i < len) {
                strHeaders += (
                    '<gs-cell>' +
                        (arrCells[i].getAttribute('heading') || '') +
                    '</gs-cell>'
                );
                i += 1;
            }
        }

        // gather rows
        arrHeaders = [];
        arrTypes = [];
        arrRecords = [];

        strData = '';
        strCells = '';

        arrRows = cmbQryKids(tableElement, 'tbody tr');
        i = 0;
        len = arrRows.length;
        while (i < len) {
            arrCells = cmbQryKids(arrRows[i], 'td, th');
            cell_i = firstCellNumber;
            cell_len = arrCells.length;
            while (cell_i < cell_len) {
                cell = arrCells[cell_i];
                // NOTE: If there is no source, then we do the static data stuff
                // Nunzio on 2021-09-20

                // if there's only one record, just use it as the template.
                if (i === 0 && len === 1 && element.hasAttribute('src')) {
                    strCells += (
                        '<gs-cell ' + (
                            arrRows[i].getAttribute('value')
                                ? 'value="' + encodeHTML(
                                    arrRows[i].getAttribute('value')
                                ) + '"'
                                : ''
                        ) + '>' +
                            arrCells[cell_i].innerHTML +
                        '</gs-cell>'
                    );

                // else, we have more than one record and we're making up a
                //      template for the developer. We use {{= because the data
                //      is going to contain the cell html in it. So, we don't
                //      want to html encode the developer's html with {{!
                } else if (i === 0 && (len > 1 || !element.hasAttribute('src'))) {
                    if (
                        cell_i === firstCellNumber &&
                        arrRows[i].hasAttribute('value')
                    ) {
                        arrHeaders.push('column_id');
                        arrTypes.push('text');
                        strCells += (
                            '<gs-cell value="{{= row.column_id }}">' +
                                '<label>' +
                                    '{{= row.column_' + cell_i + ' }}' +
                                '</label>' +
                            '</gs-cell>'
                        );
                    } else {
                        strCells += (
                            '<gs-cell>' +
                                '<label>' +
                                    '{{= row.column_' + cell_i + ' }}' +
                                '</label>' +
                            '</gs-cell>'
                        );
                    }

                    arrHeaders.push('column_' + cell_i);
                    arrTypes.push('text');
                }

                // if there's more than one record, we need to start storing
                //      data, because the developer has opted for a local
                //      combobox, not one that loads from the database
                if (len > 1 || !element.hasAttribute('src')) {
                    if (
                        cell_i === firstCellNumber &&
                        arrRows[i].hasAttribute('value')
                    ) {
                        strData += GS.encodeForTabDelimited(
                            arrRows[i].getAttribute('value'),
                            strNullString
                        ) + '\t';
                    } else if (cell_i > firstCellNumber) {
                        strData += '\t';
                    }
                    strData += GS.encodeForTabDelimited(
                        arrCells[cell_i].innerHTML,
                        strNullString
                    );
                }

                cell_i += 1;
            }
            if (strData) {
                arrRecords.push(strData);
                strData = '';
            }

            i += 1;
        }

        if (strHeaders) {
            element.internalTemplates.header = strHeaders;
        }
        if (strCells) {
            element.internalTemplates.row = strCells;
        }
        if (arrRecords.length > 0) {
            element.internalData.staticHeaders = arrHeaders;
            element.internalData.staticTypes = arrTypes;
            element.internalData.staticRecords = arrRecords;
        }
    }

    // there are multiple places where we check if we need to trigger a change
    //      event.
    function triggerChangeIfNeeded(element) {
        var jsnDisp;
        var control;

        // change events should not be triggered if the combo is not editable
        // if this combo aint gonna break, yeet outta this funky town
        if (
            element.hasAttribute('disabled') ||
            element.hasAttribute('readonly')
        ) {
            return false;
        }

        // shorcut variables
        jsnDisp = element.internalDisplay;
        control = element.elems.control;
        //console.log('lastPublishedIndex', jsnDisp.lastPublishedIndex
        //    , 'lastVerifiedIndex', jsnDisp.lastVerifiedIndex);
        //console.log('lastPublishedValue', jsnDisp.lastPublishedValue
        //    , 'lastVerifiedValue', jsnDisp.lastVerifiedValue);
        //console.log('lastPublishedDisplay', jsnDisp.lastPublishedDisplay
        //    , 'lastVerifiedDisplay', jsnDisp.lastVerifiedDisplay);

        // the published value is always filled with the last verified value on
        //      entering the field, if the verified value is different from the
        //      published value, trigger the change
        if (
            jsnDisp.lastPublishedIndex !== jsnDisp.lastVerifiedIndex ||
            jsnDisp.lastPublishedValue !== jsnDisp.lastVerifiedValue ||
            jsnDisp.lastPublishedDisplay !== jsnDisp.lastVerifiedDisplay
        ) {
            // update the last published value
            jsnDisp.lastPublishedIndex = jsnDisp.lastVerifiedIndex;
            jsnDisp.lastPublishedValue = jsnDisp.lastVerifiedValue;
            jsnDisp.lastPublishedDisplay = jsnDisp.lastVerifiedDisplay;

            // update control value and attribute value
            control.value = jsnDisp.lastVerifiedDisplay;
            element.setAttribute('value', jsnDisp.lastVerifiedValue);

            //console.log('4:', control.value);
            //console.log('5:', element.value);
            //console.log('6:', element.getAttribute('value'));
/*
            if (
                element.hasAttribute('limit-to-list') &&
                jsnDisp.lastVerifiedIndex === null &&
                jsnDisp.lastVerifiedDisplay !== ''
            ) {
                alert('The text you entered is not in the list');
                openDropDown(element);
                GS.setInputSelection(control, 0, control.value.length);
            }
*/

            // ############ cross' version 2 ############
            // if limit to list, and no value has been selected from the list
            if (
                element.hasAttribute('limit-to-list') &&
                jsnDisp.lastVerifiedIndex === null
            ) {
                if (element.hasAttribute('allow-empty')) {
                    // if the "allow-empty" attribute has a value, that is the
                    //      default "empty" value, otherwise, set to empty
                    //      string
                    control.value = (element.getAttribute('allow-empty') || '');
                    element.value = (element.getAttribute('allow-empty') || '');

                } else if (jsnDisp.lastVerifiedDisplay !== '') {
                    alert('The text you entered is not in the list.');
                    openDropDown(element);
                    GS.setInputSelection(control, 0, control.value.length);

                    // if we have a limit to list error, we want to exit the
                    //      function to prevent the change event from triggering
                    //      and causing a database update when we have an
                    //      invalid value
                    return;
                }
            }

            // we don't want to trigger a change if it's empty, when limit to
            //      list is triggered, because it will cause an update to the
            //      database, which (if the column doesn't allow empty string)
            //      could cause a database error on top of the limit-to-list
            //      error, stacking errors when the first error is all the user
            //      needs.
            if (
                !element.hasAttribute('limit-to-list') ||
                element.hasAttribute('allow-empty') ||
                element.value
            ) {
                // trigger event
                GS.triggerEvent(element, 'change');
            }
        }
    }

    // we need to be able to execute event attributes (like onafter_select)
    //      while being able to reference the combobox as "this" in the code.
    function evalInContext(element, strJS) {
        var execFunc = function () {
            return eval(strJS);
        };

        execFunc.call(element);
    }

    // we want to standardize event triggering in this element.
    function triggerEvent(element, strEvent) {
        GS.triggerEvent(element, strEvent);
        GS.triggerEvent(element, 'on' + strEvent);
        if (
            element.hasAttribute('on' + strEvent) &&
            // onfocus and onblur attributes are handled automatically by the
            //      browser
            strEvent !== 'focus' &&
            strEvent !== 'blur'
        ) {
            evalInContext(element, element.getAttribute('on' + strEvent));
        }
    }

    // the user needs to be able to set a custom websocket for this element,
    //      so this function will use an attribute to find out what socket to
    //      use (and it'll default to "GS.envSocket")
    function getSocket(element) {
        if (element.getAttribute('socket')) {
            return GS[element.getAttribute('socket')];
        }
        return GS.envSocket;
    }

    function recordToJSON(element, strRecord) {
        var col_i;
        var col_len;
        var decodeTab = GS.decodeFromTabDelimited;
        var arrRecord;
        var jsnRecord;
        var strCell;
        var delim;
        var strNull;
        var arrColNames;

        // we need the null-string in order to properly decode WS data
        strNull = element.getAttribute('null-string');

        // save the column name array for quick and easy access
        arrColNames = element.internalData.columnNames;

        // create cell array for this record
        strRecord = strRecord + '\t';
        arrRecord = [];
        col_i = 0;
        col_len = element.internalData.columnNames.length;//9999;
        while (col_i < col_len) {
            delim = strRecord.indexOf('\t');
            strCell = strRecord.substring(0, delim);
            strRecord = strRecord.substring(delim + 1);
            arrRecord.push(decodeTab(strCell, strNull));
            col_i += 1;
        }

        // create record JSON from the cell array
        col_i = 0;
        col_len = arrRecord.length;
        jsnRecord = {};
        while (col_i < col_len) {
            jsnRecord[arrColNames[col_i]] = arrRecord[col_i];
            col_i += 1;
        }

        return jsnRecord;
    }

    // There are various times that we need to find a record with a string
    function findRecord(element, strValue, strDisplay, bolPartial) {
        var i;
        var len;

        var bolFound;
        var jsnRecord;
        var currValue;
        var currDisplay;

        var valueTemplate;
        var displayTemplate;
        var valueFunc;
        var displayFunc;
        var valueRendered;
        var displayRendered;

        // we need the current hidden and display values. The attribute is the
        //      only way of setting the value of the combobox internally and
        //      externally. useing the .value accessor on the combo is just a
        //      window to setting the attribute. We'll also grab the current
        //      display value. If the hidden and display values are the same as
        //      the last verified value, we don't need to continue.
        currValue = strValue || '';
        currDisplay = strDisplay || '';

        // if partial search, lowercase
        if (bolPartial) {
            currValue = currValue.toLowerCase();
            currDisplay = currDisplay.toLowerCase();
        }

        // we need to template the hidden and display values. so, let's
        //      create the template function.
        valueTemplate = element.internalTemplates.valueText;
        displayTemplate = element.internalTemplates.valueDisplay;
        valueFunc = doT.template(
            '{{var row = jo; ' +
            'var i = jo.internal_you_cant_guess_i; ' +
            'var len = jo.internal_you_cant_guess_len; ' +
            'var row_number = jo.internal_you_cant_guess_row_number;}}' +
            valueTemplate
        );
        displayFunc = doT.template(
            '{{var row = jo; ' +
            'var i = jo.internal_you_cant_guess_i; ' +
            'var len = jo.internal_you_cant_guess_len; ' +
            'var row_number = jo.internal_you_cant_guess_row_number;}}' +
            displayTemplate
        );

        //// for now, we want to keep an eye on the render timer. We don't
        ////      want this getting slow.
        //renderSeq += 1;
        //console.time('Render (' + renderSeq + ')');

        // we're going to do a record by record search
        valueRendered = '';
        displayRendered = '';
        i = 0;
        len = element.internalData.records.length;
        while (i < len) {
            jsnRecord = recordToJSON(element, element.internalData.records[i]);
            jsnRecord.internal_you_cant_guess_row_number = (i + 1);
            jsnRecord.internal_you_cant_guess_i = i;
            jsnRecord.internal_you_cant_guess_len = len;

            // if the value or display matches (if we have a hidden value,
            //      that must match, else, we can match on display)
            if (valueTemplate) {
                valueRendered = valueFunc(jsnRecord);
            }
            displayRendered = displayFunc(jsnRecord);

            // if not partial, perform exact match
            if (
                !bolPartial &&
                (
                    (valueTemplate && valueRendered === currValue) ||
                    (displayRendered === currDisplay) ||
                    (displayRendered === currValue)
                )
            ) {
                bolFound = true;
            }

            // if partial, perform startswith match
            // Nunzio commented out the value search on 2021-10-13
            // this is because if the value column is hidden,
            //      it should not be searched
            if (
                bolPartial &&
                (
                    // (
                    //     valueTemplate &&
                    //     valueRendered.toLowerCase().indexOf(currValue) === 0
                    // ) ||
                    displayRendered.toLowerCase().indexOf(currDisplay) === 0
                )
            ) {
                bolFound = true;
            }

            // we don't want to keep searching if we've found our value.
            if (bolFound) {
                break;
            }

            i += 1;
        }

        // if nothing is found, we don't want to send a row number
        if (!bolFound) {
            bolFound = false;
            i = null;
            valueRendered = null;
            displayRendered = null;
        }

        //// report the search time
        //console.timeEnd('Render (' + renderSeq + ')');

        return {
            "found": bolFound,
            "index": i,
            "value": valueRendered,
            "display": displayRendered
        };
    }

    // to get the selected row number from the dropdown GS-TABLE, there's a lot
    //      of things that need to be in place. To prevent repeated code, we
    //      handle all those checks here.
    function getSelectedRowFromDropdown(element) {
        var gsTable;
        var arrRanges;
        var jsnRange;
        var jsnStart;
        var intRow;

        gsTable = element.elems.gsTable;
        if (!gsTable) {
            return null;
        }

        arrRanges = gsTable.internalSelection.ranges;
        if (!arrRanges) {
            return null;
        }

        jsnRange = arrRanges[0];
        if (!jsnRange) {
            return null;
        }

        jsnStart = jsnRange.start;
        if (!jsnStart) {
            return null;
        }

        intRow = jsnStart.row;
        if (typeof intRow !== 'number') {
            return null;
        }

        return intRow;
    }

    // in multiple places, we want to set the value based on the current
    //      selection of the GS-TABLE in the dropdown. Here, we try to set the
    //      control, "value" attribute and record as verified. We return true
    //      if we were able to find a value, false if weren't able to find a
    //      value.
    function setValueFromDropdown(element) {
        var intRow;
        var valueTemplate;
        var displayTemplate;
        var valueFunc;
        var displayFunc;
        var valueRendered;
        var displayRendered;
        var finalValue;
        var finalDisplay;
        var jsnRecord;
        //console.log(element);

        // get selected row number from table
        intRow = getSelectedRowFromDropdown(element);
        //console.log(
        //    intRow,
        //    element.elems.gsTable.internalSelection.ranges,
        //    element.elems.gsTable.internalData.records,
        //    element.internalData.records
        //);

        // we don't want to do anything if there's no selection we can use
        if (intRow === null) {
            // report failure
            return false;
        }

        // we need to template the hidden and display values. so, let's
        //      create the template function.
        valueTemplate = element.internalTemplates.valueText;
        displayTemplate = element.internalTemplates.valueDisplay;
        valueFunc = doT.template(
            '{{var row = jo; ' +
            'var i = jo.internal_you_cant_guess_i; ' +
            'var len = jo.internal_you_cant_guess_len; ' +
            'var row_number = jo.internal_you_cant_guess_row_number;}}' +
            valueTemplate
        );
        displayFunc = doT.template(
            '{{var row = jo; ' +
            'var i = jo.internal_you_cant_guess_i; ' +
            'var len = jo.internal_you_cant_guess_len; ' +
            'var row_number = jo.internal_you_cant_guess_row_number;}}' +
            displayTemplate
        );

        jsnRecord = recordToJSON(
            element,
            element.internalData.records[intRow]
        );

        jsnRecord.internal_you_cant_guess_i = intRow;
        jsnRecord.internal_you_cant_guess_len = (
            element.internalData.records.length
        );
        jsnRecord.internal_you_cant_guess_row_number = (intRow + 1);

        // if the value or display matches (if we have a hidden value,
        //      that must match, else, we can match on display)
        if (valueTemplate) {
            valueRendered = valueFunc(jsnRecord);
        }
        displayRendered = displayFunc(jsnRecord);
        //console.log(valueRendered, displayRendered);

        finalValue = (valueRendered || displayRendered);
        finalDisplay = (displayRendered);

        element.internalDisplay.lastVerifiedIndex = intRow;
        element.internalDisplay.lastVerifiedValue = finalValue;
        element.internalDisplay.lastVerifiedDisplay = finalDisplay;
        element.elems.control.value = finalDisplay;
        element.setAttribute('value', finalValue);

        // report success
        return true;
    }

    // when we close the dropdown, we need to unbind it so that we don't
    //      start stacking events because we never unbind anything.
    function unbindDropDown(element) {
        window.removeEventListener(
            'resize',
            element.internalEvents.closeHandler
        );
        window.removeEventListener(
            'orientationchange',
            element.internalEvents.closeHandler
        );
        window.removeEventListener(
            'mousewheel',
            element.internalEvents.closeHandler
        );
        window.removeEventListener(
            'comboclose',
            element.internalEvents.closeHandler
        );
        document.body.removeEventListener(
            'click',
            element.internalEvents.closeHandler
        );

        element.elems.gsTable.removeEventListener(
            'selection_change',
            element.internalEvents.selectionHandler
        );
    }

    // close combobox dropdown
    function closeDropDown(element) {
        // no sense in closing what's already closed
        if (element.internalDisplay.open) {
            // unbind dropdown events
            unbindDropDown(element);

            // destroy GS-TABLE, if it's there
            if (element.elems.gsTable) {
                element.elems.gsTable.destroy();
                element.elems.scrollContainer.removeChild(
                    element.elems.gsTable
                );
            }

            // remove dropdown from DOM
            document.body.removeChild(element.elems.dropDownContainer);

            // remove "open" combo status
            element.classList.remove('open');
            element.internalDisplay.open = false;

            // THIS BROKE THE COMBO!!!!
            //    WTF? IT WON'T TRIGGER A CHANGE IF YOU HAVE THIS?!!!!
            //    WHY!?!?!?!?!?!??! 7/1/22 -cross
            // make sure focus is in control
            // element.elems.control.focus();
        }
    }

    // when the dropdown is open, we bind a bunch of stuff to the window to
    //      detect when it's time to automatically close the dropdown. It's
    //      self contained, so it's not in the event functions, with are
    //      targeted to the combo itself.
    function bindDropDown(element) {
        // handle dropdown close
        element.internalEvents.closeHandler = function (event) {
            var target = event.target;
            var dropDownContainer = element.elems.dropDownContainer;
            var container = GS.findParentElement(target, dropDownContainer);
            var body = GS.findParentElement(target, 'body');

            // we've had issues where a gs-cell from the gs-table is taken
            //      out of the dom before we get to this mouse event, because
            //      we were scrolling too fast. So, if the element that
            //      triggered the mousewheel is still in the dom, and it's not
            //      in the dropdown, that's when we trigger the close.
            if (body && container !== dropDownContainer && !event.gs) {
                closeDropDown(element);
            }
        };

        window.addEventListener(
            'resize',
            element.internalEvents.closeHandler
        );
        window.addEventListener(
            'orientationchange',
            element.internalEvents.closeHandler
        );
        window.addEventListener(
            'mousewheel',
            element.internalEvents.closeHandler
        );
        window.addEventListener(
            'comboclose',
            element.internalEvents.closeHandler
        );
        document.body.addEventListener(
            'click',
            element.internalEvents.closeHandler
        );

        // handle dropdown selection
        element.internalEvents.selectionHandler = function () {
            // set control, value attribute, and record as verified
            if (setValueFromDropdown(element)) {
                // we want the dropdown to close when we've successfully
                //      selected a record
                closeDropDown(element);

                // if we chose a record, trigger a change
                triggerChangeIfNeeded(element);
            }
        };

        element.elems.gsTable.addEventListener(
            'selection_change',
            element.internalEvents.selectionHandler
        );
    }

    // the position of the dropdown is dynamic, so we need to separate out
    //      opening and positioning the dropdown box.
    function positionDropdown(element) {
        var dropDownContainer;
        var positionContainer;

        var jsnComboPos;
        var intComboHeight;
        var intComboWidth;
        var intComboTop;
        var intComboLeft;
        var intWindowHeight;
        var intWindowWidth;
        var intComboToBottom;
        var intComboToTop;

        var intDropdownWidth;

        var strWidth = '';
        var strHeight = '';
        var strLeft = '';
        var strTop = '';
        var strBottom = '';

        // element shortcuts, we want to keep the code readable
        dropDownContainer = element.elems.dropDownContainer;
        positionContainer = element.elems.positionContainer;

        // gather position variables. These are all the factors we pay
        //      attention to when deciding what the best display would be
        //      for the dropdown box.
        jsnComboPos = GS.getElementOffset(element);
        intComboHeight = element.offsetHeight;
        intComboWidth = element.offsetWidth;
        intComboTop = jsnComboPos.top;
        intComboLeft = jsnComboPos.left;
        intWindowHeight = window.innerHeight;
        intWindowWidth = window.innerWidth;
        intComboToBottom = (intWindowHeight - (intComboTop + intComboHeight));
        intComboToTop = intComboTop;

        // time to calculate the optimum styles for the dropdown container

        // let's calculate height and vertical position

        // if window is smol af, go full height
        if (intWindowHeight < 500) {
            strHeight = intWindowHeight + 'px';
            strTop = '0px';

        // open below combo, with constrained height
        } else if (intComboToBottom > 300) {
            strHeight = '200px';
            strTop = (intComboToTop + intComboHeight) + 'px';

        // open above combo, with constrained height
        } else if (intComboToTop > 300) {
            strHeight = '200px';
            strBottom = (intComboToBottom + intComboHeight) + 'px';

        // go from combo to bottom of screen
        } else if (intComboToBottom > 200) {
            strHeight = intComboToBottom + 'px';
            strTop = (intComboToTop + intComboHeight) + 'px';

        // go from combo to top of screen
        } else if (intComboToTop > 200) {
            strHeight = intComboToTop + 'px';
            strBottom = (intComboToBottom + intComboHeight) + 'px';

        // if nothing works, default to full height
        } else {
            strHeight = intWindowHeight + 'px';
            strTop = '0px';
        }

        // let's calculate width and horizontal position

        // we need to try to expand the box depending on total width of columns

        // If we got lots of room, cap the width
        if (element.internalDisplay.definedDropdownWidth) {
            intDropdownWidth = GS.sizeToPx(
                element,
                element.internalDisplay.definedDropdownWidth
            );
            intDropdownWidth = Math.min(intDropdownWidth, intWindowWidth);

            strWidth = intDropdownWidth + 'px';
            strLeft = Math.max(
                ((intComboLeft + intComboWidth) - intDropdownWidth),
                0
            ) + 'px';

        } else if (intWindowWidth > 400 && intComboWidth > 400) {
            strWidth = intComboWidth + 'px';
            strLeft = Math.max(intComboLeft, 0) + 'px';

        } else if (intWindowWidth > 400) {
            strWidth = '300px';
            strLeft = Math.max(
                ((intComboLeft + intComboWidth) - 300),
                0
            ) + 'px';

        // else full width
        } else {
            strWidth = '100%';
            strLeft = '0px';
        }

        // set position and size to what we determined, anything not set will
        //      be set to '' because that's the initial value in the variable.
        positionContainer.style.top = strTop;
        positionContainer.style.bottom = strBottom;
        positionContainer.style.left = strLeft;
        positionContainer.style.width = strWidth;
        positionContainer.style.height = strHeight;

        // we display differently if the dropdown opens below or above
        //      the combo
        if (strTop) {
            dropDownContainer.classList.add('below');
            dropDownContainer.classList.remove('above');
        } else {
            dropDownContainer.classList.add('above');
            dropDownContainer.classList.remove('below');
        }
    }

    // open combobox dropdown, this function will handle the position and
    //      filling of the dropped down portion.
    function openDropDown(element) {
        var strHeader;
        var strRow;
        var gsTable;
        var arrHeights;
        var i;
        var len;
        var intMaxTop;
        var control;
        var strHeight;
        var recordHeight;

        // no sense opening the dropdown twice, also no sense opening the
        //      dropdown to a disabled/readonly combobox
        if (
            element.internalDisplay.open === false &&
            !element.hasAttribute('disabled') &&
            !element.hasAttribute('readonly') &&
            element.internalDisplay.opening === false
        ) {
            // takes a moment to open the dropdown, don't want to open twice.
            element.internalDisplay.opening = true;

            // we cache selects that have the same parameters. This is because
            //      we might have a thousand combos in the same list. So,
            //      running a refresh is basically free unless the select
            //      parameters have changed. In which case, you'd want to
            //      refresh anyway.
            element.refresh(function () {
                // we want to focus the control, so that we can immediately
                //      start typing or so we can close the dropdown when they
                //      leave the field
                if (!evt.touchDevice) {
                    control = element.elems.control;
                    control.focus();

                    // select all text for easy override
                    GS.setInputSelection(control, 0, control.value.length);
                }

                // There may be another combobox open, trigger event to close
                //      all open combo dropdowns
                GS.triggerEvent(window, 'comboclose');

                // time to shine, get the dropdown into the DOM, it's appended
                //      to the body becuase it has to display in front of
                //      everything else. It's basically a modal dialog. POTENIAL
                //      IMPROVEMENT: we could potentially replace this a
                //      GS-DIALOG.
                document.body.appendChild(element.elems.dropDownContainer);

                // resize dropdown, we may want to re-position the dropdown at
                //      any given moment, so it's been moved into it's own
                //      function.
                positionDropdown(element);

                // gather templates
                strHeader = element.internalTemplates.header;
                strRow = element.internalTemplates.row;
                if (element.hasAttribute('default-cell-height')) {
                    strHeight = 'default-cell-height="' + element.getAttribute('default-cell-height') + '"';
                } else {
                    strHeight = '';
                }



                // fill dropdown with table, we use the GS-TABLE here so that
                //      we don't have to code table rendering all over again.
                //      This will also make it easy to handle 100000s of records
                //      worth of data
                element.elems.scrollContainer.appendChild(
                    GS.stringToElement(
                        ml(function () {/*
                            <gs-table
                                id="combo-dropdown-table"
                                selection-mode="single-row"
                                no-x-overscroll    no-y-overscroll
                                no-resize-record   no-resize-column
                                no-column-reorder  no-context-menu
                                column-auto-resize no-column-dropdown
                                no-force-select    no-copy
                                {{STRHEIGHT}}
                            >
                                <template for="header-record">
                                    {{HEADER}}
                                </template>
                                <template for="data-record">
                                    {{DATA}}
                                </template>
                            </gs-table>*/
                        })
                            .replace(/\{\{HEADER\}\}/gi, strHeader)
                            .replace(/\{\{DATA\}\}/gi, strRow)
                            .replace(/\{\{STRHEIGHT\}\}/gi, strHeight)
                    )
                );

                // get gs-table element
                gsTable = element.elems.scrollContainer.children[0];
                element.elems.gsTable = gsTable;

                // load data/columns/display info into table
                intMaxTop = 0;
                arrHeights = [];
                recordHeight = gsTable.internalDisplay.defaultRecordHeight;
                i = 0;
                len = element.internalData.records.length;
                while (i < len) {
                    intMaxTop += recordHeight;
                    arrHeights.push(recordHeight);
                    i += 1;
                }

                gsTable.internalData.records = element.internalData.records;
                gsTable.internalDisplay.recordHeights = arrHeights;
                gsTable.internalData.columnNames = (
                    element.internalData.columnNames
                );
                gsTable.internalData.columnTypes = (
                    element.internalData.columnTypes
                );
                gsTable.internalData.bolFirstLoadFinished = true;
                gsTable.internalScroll.maxTop = intMaxTop;

                // if there is a selected record
                if (element.internalDisplay.lastVerifiedIndex) {
                    // load selection into table
                    // scroll to the selected record (if any)
                    gsTable.goToLine(
                        element.internalDisplay.lastVerifiedIndex + 1
                    );
                }

                // render table now that we have everything inside it
                gsTable.refresh();
                gsTable.render();
                gsTable.renderSelection();

                // we want to close the dropdown if we scroll the window, or
                //      if we click out, scroll with the mousewheel, etc.
                bindDropDown(element);

                // we are now open, tell the world!
                element.classList.add('open');
                element.internalDisplay.open = true;
                element.internalDisplay.opening = false;
            });
        }
    }

    // toggle combobox dropdown, this function will handle making sure we don't
    //      open the dropdown twice.
    function toggleDropdown(element) {
        // no sense opening the dropdown twice
        if (element.internalDisplay.open === false) {
            openDropDown(element);

        // if we're already open, close the dropdown
        } else {
            closeDropDown(element);
        }
    }

    // now that we have the templates, we need to figure out the id and
    //      display columns. Sometimes, they're the same column, but not
    //      every time. In table templates, the display column is a dot.js
    //      template in the "value" attribute of the tr. In gs-cell
    //      templates, it's in the "value" attribute in the first gs-cell.
    function getValueAndDisplayTemplates(element) {
        var firstCell = GS.stringToElement(element.internalTemplates.row);
        var strValueAttribute;
        var strTextContent;

        strValueAttribute = firstCell.getAttribute('value');
        strTextContent = firstCell.textContent;

        // most HTML display should be HTML encoded. If that's what the
        //      developer did, we need to make sure we change it to unencoded
        //      for the value display because the input element will display the
        //      exact text we give it
        if (strTextContent.indexOf('{{!') > -1) {
            strTextContent = strTextContent.replace(/\{\{!/gi, '{{=');
        }

        element.internalTemplates.valueText = (
            strValueAttribute ||
            strTextContent
        );

        element.internalTemplates.valueDisplay = strTextContent;
    }


// #############################################################################
// ############################# ELEMENT FUNCTIONS #############################
// #############################################################################

    // some attributes can't be used in their normal, dev-friendly format,
    //      this function translates those attributes to their final formats
    // some attributes need to be defaulted, even if they're not present
    function resolveElementAttributes(element) {
        var arrParts;

        // GS-COMBO elements that are connected to Envelope need to have "pk"
        //      attribute
        if (element.getAttribute('src')
                && element.getAttribute('src')[0] !== '(') {
            // split "src" into "schema" and "object" attributes
            arrParts = GS.templateWithQuerystring(
                element.getAttribute('src')
            ).split('.');

            // I don't know who added this. I don't inderstand why someone
            //      would put something like "biz.bar.foo" in the "src"
            //      attribute. That's the case that this code handles. If
            //      you added this code: PUT A COMMENT!!!! We have comments
            //      for a reason. Don't ruin this beautiful code. Only YOU
            //      can prevent spaghetti code.
            //  ~Michael
            // It appears to be a solution to quote idented object names that
            //      contain a period like this: test."test.asdf"
            //      The problem with this solution (other than being unclear)
            //      is that it wont work for schema names that contain a period.
            //      We need a better solution for this. Perhaps it's time to
            //      create a function that understands ident quoted names for
            //      real, using actual parsing.
            //  ~Also Michael
            if (arrParts[2]) {
                arrParts[1] = arrParts[1] + '.' + arrParts[2];
            }

            // put the split sections of the object name into separate
            //      attributes
            element.setAttribute('schema', arrParts[0]);
            element.setAttribute('object', arrParts[1]);
        } else if (element.getAttribute('src')
                && element.getAttribute('src')[0] === '(') {
            element.setAttribute('object', GS.templateWithQuerystring(
                element.getAttribute('src')
            ));
        }

        // default null string attribute
        element.setAttribute(
            'null-string',
            (element.getAttribute('null-string') || '')
        );
    }

    // create internal structures and inner elements that persist through the
    //      whole lifetime of the element
    function prepareElement(element) {
        var rootElement;
        var dropDownContainer;
        var positionContainer;
        var scrollContainer;

        // we want a place to store elements
        element.elems = {};

        // we want a place to look to for data
        element.internalData = {
            "records": [],
            "columnNames": [],
            "columnTypes": [],
            "staticHeaders": [],
            "staticTypes": [],
            "staticRecords": [],
            "clearCache": false
        };

        // we need a place to store event functions because, to unbind a
        //      specific event javascript requires that you have the
        //      original function that was bound to that event
        element.internalEvents = {};

        // Some events need persistent storage of a related variable. This
        //      bucket will hold that info.
        element.internalEventData = {
            "defaultAttributes": {}
        };

        // we need a place to store our templates, so we'll create an
        //      element.internalTemplates JSON object and store each
        //      template under a unique name
        element.internalTemplates = {
            "header": "",
            "row": "",
            "valueText": "",
            "valueDisplay": ""
        };

        // we need a place to store cell dimensions and other display
        //      related info
        // anything in here set to "undefined" is set that way because the dev
        //      may set it to 0 or [] and we need to be able to tell that it
        //      hasn't been set yet
        element.internalDisplay = {
            // we always want to know if the dropdown is open or not.
            "open": false,
            "opening": false,

            // when user leaves combo or chooses item from dropdown, we compare
            //      to these to see if the verified values are different from
            //      when they entered the field. If they are, that means that
            //      it's time to trigger a change event. We set these on
            //      entering the combobox. That way, the latest published value
            //      is always fresh.
            "lastPublishedIndex": undefined,
            "lastPublishedValue": undefined,
            "lastPublishedDisplay": undefined,

            // If the combo has a "value" attribute and we find the related
            //      record and display, that's a verified value. If the user
            //      is in the middle of typing, that's not a verified value.
            //      Verified values are the latest savepoint.
            "lastVerifiedIndex": undefined,
            "lastVerifiedValue": undefined,
            "lastVerifiedDisplay": undefined,

            // we want to maintain information about the last search
            "lastNotFoundSearch": undefined,

            "definedDropdownWidth": undefined
        };

        // we need a place to store selection information
        element.internalSelection = {};

        // we need to make the persistent elements
        rootElement = document.createElement('div');
        rootElement.setAttribute('gs-dynamic', '');
        rootElement.classList.add('root');

        rootElement.innerHTML = (
            '<input role="textbox" aria-autocomplete="none" ' +
                'gs-dynamic class="control" type="text" />' +
            '<gs-button gs-dynamic aria-label="Open the Combo box" ' +
                'alt="Open the Combo box" class="drop_down_button" ' +
                'icononly icon="angle-down" tabindex="9999"></gs-button>'
            // the [tabindex="9999"] is because the blur event will only
            //      tell us where the focus went if the element that stole
            //      the focus can take focus. While it needs to accept
            //      focus for the blur event to work the way it does, we
            //      don't want users to have to tab twice in every combobox.
            //      So the combo buttons are the last thing to be tabbed to.
        );

        // We create a fresh dropdown element every time.
        dropDownContainer = document.createElement('div');

        // create and store the dropdown's children
        dropDownContainer.classList.add('gs-combo-dropdown-container');
        dropDownContainer.setAttribute('gs-dynamic', '');
        dropDownContainer.innerHTML = (
            '<div class="gs-combo-positioning-container" gs-dynamic>' +
            '    <div class="gs-combo-scroll-container" gs-dynamic></div>' +
            '</div>'
        );
        positionContainer = dropDownContainer.children[0];
        scrollContainer = positionContainer.children[0];

        // gather element shortcuts
        element.elems.root = rootElement;
        element.elems.control = rootElement.children[0];
        element.elems.button = rootElement.children[1];
        element.elems.dropDownContainer = dropDownContainer;
        element.elems.positionContainer = positionContainer;
        element.elems.scrollContainer = scrollContainer;

        // for backwards compatibility:
        element.control = element.elems.control;

        // append root
        element.appendChild(element.elems.root);
    }

    // get attributes and templates and extract all necessary information
    function siphonElement(element) {
        var headerTemplate;
        var rowTemplate;
        var unnamedTemplate;
        var i;
        var len;
        var jsnAttr;
        var arrAttributes;
        var prevElem;
        var forElem;

        // get each template element and save them to each their own variable,
        //      for easy access
        headerTemplate = cmbQryKids(element, '[for="header"]')[0];
        rowTemplate = cmbQryKids(element, '[for="row"]')[0];

        // some people put incorrect "for" attributes on templates. We need to
        //      get any unnamed or unrecognized template and assume it's old
        //      school.
        unnamedTemplate = cmbQryKids(
            element,
            (
                'template:not([for]),' +
                'template:not([for="header"]):not([for="row"])'
            )
        )[0];

        // remove all templates from the dom to prevent reflows
        if (headerTemplate) {
            element.removeChild(headerTemplate);
        }
        if (rowTemplate) {
            element.removeChild(rowTemplate);
        }
        if (unnamedTemplate) {
            element.removeChild(unnamedTemplate);
        }

        if (
            headerTemplate &&
            (
                headerTemplate.innerHTML.indexOf('&gt;') > -1 ||
                headerTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn(
                'GS-TABLE WARNING: &gt; or &lt; detected in ' +
                'header template, this can have undesired ' +
                'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                'lt(x,y), or lte(x,y) to silence this warning.'
            );
        }
        if (
            rowTemplate &&
            (
                rowTemplate.innerHTML.indexOf('&gt;') > -1 ||
                rowTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn(
                'GS-TABLE WARNING: &gt; or &lt; detected in ' +
                'row template, this can have undesired ' +
                'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                'lt(x,y), or lte(x,y) to silence this warning.'
            );
        }
        if (
            unnamedTemplate &&
            (
                unnamedTemplate.innerHTML.indexOf('&gt;') > -1 ||
                unnamedTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn(
                'GS-TABLE WARNING: &gt; or &lt; detected in ' +
                'template, this can have undesired ' +
                'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                'lt(x,y), or lte(x,y) to silence this warning.'
            );
        }

        // pull in header template. because the header template is a straight
        //      passthrough to the gs-table we'll use for the dropdown, we just
        //      need to save the text of the template.
        if (headerTemplate) {
            element.internalTemplates.header = headerTemplate.innerHTML;
        }

        // pull in record template (for backwards compatibility, we need to be
        //      able to accept a template without a "for" attribute as the
        //      record template. Additionally, we need to be able to take a
        //      TABLE element here and convert it to gs-cell. Unless it's a
        //      static combobox. In which case, we convert it to static data
        //      and gs-cells.
        if (rowTemplate) {
            if (rowTemplate.content.children[0].nodeName === 'TABLE') {
                extractAndConvertTableTemplate(element, rowTemplate);
            } else {
                element.internalTemplates.row = rowTemplate.innerHTML;
            }
        }

        if (unnamedTemplate) {
            if (unnamedTemplate.content.children[0].nodeName === 'TABLE') {
                extractAndConvertTableTemplate(element, unnamedTemplate);
            } else {
                element.internalTemplates.row = unnamedTemplate.innerHTML;
            }
        }

        // if we haven't found a template and there is no datasource to create
        //      a template from, error
        if (!element.internalTemplates.row && !element.hasAttribute('src')) {
            throw 'GS-COMBO Error: No template provided.';
        }

        // if we have the templates, extract the value and display templates
        if (element.internalTemplates.row) {
            getValueAndDisplayTemplates(element);
        }

        // if the developer has set a tabindex, we need to transfer that to the
        //      control because that's where the focus is going to go
        if (element.hasAttribute('tabindex')) {
            element.elems.control.setAttribute(
                'tabindex',
                element.getAttribute('tabindex')
            );
            element.removeAttribute('tabindex');
        }

        // some attributes are always directly passed through to the control
        arrAttributes = [
            'placeholder', 'name', 'maxlength', 'autofocus', 'readonly', 'title'
        ];

        i = 0;
        len = arrAttributes.length;
        while (i < len) {
            if (element.hasAttribute(arrAttributes[i])) {
                element.elems.control.setAttribute(
                    arrAttributes[i],
                    (element.getAttribute(arrAttributes[i]) || '')
                );
            }
            i += 1;
        }

        // autocomplete attributes
        if (element.hasAttribute('autocorrect')) {
            element.elems.control.setAttribute('autocorrect', 'off');
        }
        if (element.hasAttribute('autocapitalize')) {
            element.elems.control.setAttribute('autocapitalize', 'off');
        }
        if (element.hasAttribute('autocomplete')) {
            element.elems.control.setAttribute('autocomplete', 'off');
        }
        if (element.hasAttribute('spellcheck')) {
            element.elems.control.setAttribute('spellcheck', 'false');
        }

        // we allow users to define the dropdown width
        if (element.hasAttribute('dropdown-width')) {
            element.internalDisplay.definedDropdownWidth = (
                element.getAttribute('dropdown-width')
            );
        }

        // if this combobox has an id, the control should have a related id
        if (element.hasAttribute('id')) {
            element.elems.control.setAttribute(
                'id',
                element.getAttribute('id') + '_control'
            );
        }

        // if this combobox has an id attribute, check and update label
        //      association
        if (element.hasAttribute('id')) {
            prevElem = element.previousElementSibling;
            if (
                prevElem &&
                prevElem.tagName.toUpperCase() === 'LABEL' &&
                prevElem.hasAttribute('for') &&
                prevElem.getAttribute('for') === element.getAttribute('id')
            ) {
                forElem = prevElem;
            } else {
                forElem = xtag.query(
                    document,
                    'label[for="' + element.getAttribute('id') + '"]'
                )[0];
            }

            if (forElem) {
                forElem.setAttribute(
                    'for',
                    element.getAttribute('id') + '_control'
                );
            }
        }

        // we need to store the defaults of the attributes in case of QS
        //      binding. Because we'll need to retemplate the initial attribute
        //      setting every time.
        i = 0;
        len = element.attributes.length;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internalEventData.defaultAttributes[jsnAttr.nodeName] = (
                jsnAttr.value ||
                ''
            );
            i += 1;
        }
    }

// #############################################################################
// ############################# RENDER FUNCTIONS ##############################
// #############################################################################

    // the display value isn't always the same as the "value" attribute. If the
    //      hidden value is different from the display value, we need to search
    //      the data to render the display value.
    function renderControl(element, bolFullRerender) {
        var bolLimitToList;
        var bolLoaded;
        var jsnFound;

        var currValue;
        var currDisplay;
        var lastValue;
        var lastDisplay;
        var finalValue;
        var finalDisplay;
        var bolValueChange;
        var bolDisplayChange;

        // if no value has been set, skip
        if (!element.hasAttribute('value')) {
            return;
        }

        // if no control, this has been called too early, cancel
        if (!element.elems || !element.elems.root) {
            return;
        }

        // we need the current hidden and display values. The attribute is the
        //      only way of setting the value of the combobox internally and
        //      externally. useing the .value accessor on the combo is just a
        //      window to setting the attribute. We'll also grab the current
        //      display value. If the hidden and display values are the same as
        //      the last verified value, we don't need to continue.
        currValue = element.getAttribute('value') || '';
        currDisplay = element.elems.control.value || '';
        lastValue = element.internalDisplay.lastVerifiedValue || '';
        lastDisplay = element.internalDisplay.lastVerifiedDisplay || '';
        bolValueChange = (lastValue !== currValue);
        bolDisplayChange = (lastDisplay !== currDisplay);

        // we don't want to search if the value hasn't changed
        if (bolValueChange || bolDisplayChange || bolFullRerender) {
            // we need the null-string in order to properly decode WS data
            bolLimitToList = element.hasAttribute('limit-to-list');

            // we do things differently if the data isn't loaded yet
            bolLoaded = element.internalData.loaded;

            // find record by current value
            jsnFound = findRecord(element, currValue, currDisplay);

            // We found the record, set attribute and display text to the new
            //      values
            if (jsnFound.found) {
                finalValue = jsnFound.value;
                finalDisplay = jsnFound.display;

            // if we're not limit to list, and the display has been changed, or
            //      we have a display, set value and display to display.
            } else if (!bolLimitToList && (bolDisplayChange || currDisplay)) {
                finalValue = currDisplay;
                finalDisplay = currDisplay;

            // if we're not limit to list, and the value has been changed, or
            //      we have a value, set value and display to value.
            } else if (!bolLimitToList && (bolValueChange || currValue)) {
                finalValue = currValue;
                finalDisplay = currValue;

            // we got nothing. clear out combo
            } else {
                finalValue = '';
                finalDisplay = '';
            }

            // if there's no hidden value, coalesce to display value
            finalValue = (finalValue || finalDisplay);

            // we've verified the values, let's save them so that we can prevent
            //      re-searching through lots of data
            element.internalDisplay.lastVerifiedIndex = jsnFound.index;
            element.internalDisplay.lastVerifiedValue = finalValue;
            element.internalDisplay.lastVerifiedDisplay = finalDisplay;

            // finally, set the attribute and the display (display first,
            //      because we compare the last verified display to the current
            //      display in order to prevent recursion, and setting the
            //      attribute causes a re-render).
            if (!bolLimitToList || bolLoaded) {//bolFound || bolLoaded
                element.elems.control.value = finalDisplay;
                element.setAttribute('value', finalValue);
            }
        }

        var arrAttributes = [
            'placeholder', 'name', 'maxlength', 'autofocus', 'readonly', 'title'
        ];

        var i = 0;
        var len = arrAttributes.length;
        while (i < len) {
            if (element.hasAttribute(arrAttributes[i])) {
                element.elems.control.setAttribute(
                    arrAttributes[i],
                    (element.getAttribute(arrAttributes[i]) || '')
                );
            } else {
                element.elems.control.removeAttribute(arrAttributes[i]);
            }
            i += 1;
        }
    }


// ############################################################################
// ############################## DATA FUNCTIONS ##############################
// ############################################################################

    function dataSELECTcallback(element) {
        element.internalData.loaded = true;

        renderControl(element, true);

        triggerEvent(element, 'after_select');
    }

    function databaseWSSELECT(element) {
        var templateQS = GS.templateWithQuerystring;
        var arrRecords;
        var strHeaderCells;
        var strRecordCells;
        var arrHide;
        var arrCols;
        var strCols;
        var arrColNames;
        var saveColumns;

        // we need to get the column names and types
        saveColumns = function (data) {
            var i;
            var len;
            var strCol;
            var strType;

            element.internalData.columnNames = [];
            element.internalData.columnTypes = [];
            arrColNames = data.arrDecodedColumnNames;

            i = 0;
            len = arrColNames.length;
            while (i < len) {
                strCol = arrColNames[i];
                strType = data.arrDecodedColumnTypes[i];

                element.internalData.columnNames.push(strCol);
                element.internalData.columnTypes.push(strType);
                i += 1;
            }

            // if we don't have a template, it's because the developer expects
            //      the combo to build it's own template from the data. the
            //      "hide" attribute is a comma separated list of columns to
            //      ignore when building the template.
            if (!element.internalTemplates.row) {
                strHeaderCells = '';
                strRecordCells = '';
                i = 0;
                len = arrColNames.length;
                while (i < len) {
                    // if this column is not hidden
                    if (
                        arrHide.indexOf((i + 1) + '') === -1 &&
                        arrHide.indexOf(arrColNames[i]) === -1
                    ) {
                        strHeaderCells += (
                            '<gs-cell gs-dynamic>' +
                                encodeHTML(arrColNames[i]) +
                            '</gs-cell>'
                        );

                        // first cell needs to have the first data column as
                        //      it's hidden value attribute. This is how it was
                        //      in the old combo.
                        if (!strRecordCells) {
                            strRecordCells += (
                                '<gs-cell gs-dynamic value="' +
                                    '{{! row[\'' + arrColNames[0] + '\']}}' +
                                '">' +
                                    '{{! row[\'' + arrColNames[i] + '\'] }}' +
                                '</gs-cell>'
                            );
                        } else {
                            strRecordCells += (
                                '<gs-cell gs-dynamic>' +
                                    '{{! row[\'' + arrColNames[i] + '\'] }}' +
                                '</gs-cell>'
                            );
                        }
                    }
                    i += 1;
                }

                element.internalTemplates.header = strHeaderCells;
                element.internalTemplates.row = strRecordCells;

                // we need to know how to extract the value and display values
                getValueAndDisplayTemplates(element);
            }
        };

        // create an array of hidden column names/numbers
        arrHide = (element.getAttribute('hide') || '');
        arrHide = arrHide.split(/[\s]*,[\s]*/);

        // limit column list
        if (element.getAttribute('cols')) {
            arrCols = templateQS(element.getAttribute('cols') || '').trim();
            arrCols = arrCols.split(/[\s]*,[\s]*/);
            strCols = arrCols.join('\t');
        } else {
            strCols = '*';
        }

        // we need to make sure that no old data persists across select calls,
        //      so we'll clear out the internal data object
        element.internalData.records = [];

        // storing references to the arrays for faster access
        arrRecords = element.internalData.records;

        // we need the user to know that the envelope is re-fetching data,
        //      so we'll put a loader on
        GS.requestCachingSelect(
            getSocket(element),                                // Socket
            templateQS(element.getAttribute('schema') || ''),  // Schema
            templateQS(element.getAttribute('object') || ''),  // Object
            strCols,                                           // Columns
            templateQS(element.getAttribute('where') || ''),   // Where
            templateQS(element.getAttribute('ord') || ''),     // Order
            templateQS(element.getAttribute('limit') || ''),   // Limit
            templateQS(element.getAttribute('offset') || '0'), // Offset
            function (data, error) {
                var i;
                var strRecord;
                var strMessage;
                var index;

                // sometimes, elements get removed during the wait for a
                //      callback
                if (!element.elems.root) {
                    return false;
                }

                if (!error) {
                    // we need to get the column names and types
                    if (data.intCallback === 0) {
                        saveColumns(data);
                    }

                    // if we see the last message of the select: render
                    if (data.strMessage === 'TRANSACTION COMPLETED') {
                        element.classList.remove('error');
                        element.elems.button.setAttribute('title', '');
                        element.elems.button.setAttribute(
                            'icon',
                            'angle-down'
                        );
                        dataSELECTcallback(element);

                    // we need to capture the records and columns and store
                    //      them in the internal data
                    } else {
                        // we need to parse the TSV into records and push them
                        //      to the internalData "records" array
                        // with Envelope Websocket data all we have to is split
                        //      on \n. Also, it always ends in \n so the loop
                        //      doesn't need to do anything special to get the
                        //      last record
                        strMessage = data.strMessage;
                        strRecord = '';

                        i = 0;
                        while (i < 15) {
                            index = strMessage.indexOf('\n');
                            strRecord = strMessage.substring(0, index);
                            strMessage = strMessage.substring(index + 1);

                            if (strRecord !== '' || strMessage !== '') {
                                arrRecords.push(strRecord);
                            } else {
                                break;
                            }
                            i += 1;
                        }
                    }

                // we need to make sure that the user knows that the select
                //      failed and we need to prevent using any old select
                //      info, so we'll re-render, remove the loader and pop
                //      up an error
                } else {
                    dataSELECTcallback(element);
                    //GS.webSocketErrorDialog(data);
                    element.internalData.errorData = data;
                    element.classList.add('error');
                    element.elems.button.setAttribute(
                        'title',
                        'This combobox has failed to load.'
                    );
                    element.elems.button.setAttribute(
                        'icon',
                        'exclamation-circle'
                    );
                }
            },
            element.internalData.clearCache
        );

        element.internalData.clearCache = false;
    }

    function internalSELECT(element) {
        element.internalData.columnNames = element.internalData.staticHeaders;
        element.internalData.columnTypes = element.internalData.staticTypes;
        element.internalData.records = element.internalData.staticRecords;
        dataSELECTcallback(element);
    }

    function dataSELECT(element) {
        triggerEvent(element, 'before_select');

        if (element.hasAttribute('src')) {
            databaseWSSELECT(element);
        } else {
            internalSELECT(element);
        }
    }


// #############################################################################
// ############################## EVENT FUNCTIONS ##############################
// #############################################################################

    // ############# QS EVENTS #############
    function unbindQuerystringEvents(element) {
        window.removeEventListener(
            'pushstate',
            element.internalEvents.queryStringResolve
        );
        window.removeEventListener(
            'replacestate',
            element.internalEvents.queryStringResolve
        );
        window.removeEventListener(
            'popstate',
            element.internalEvents.queryStringResolve
        );
    }
    function bindQuerystringEvents(element) {
        element.internalEvents.queryStringResolve = function () {
            var i;
            var len;
            var strQS = GS.getQueryString();
            var strQSCol = element.getAttribute('qs');
            var strQSValue;
            var strQSAttr;
            var arrQSParts;
            var arrAttrParts;
            var arrPopKeys;
            var currentValue;
            var bolRefresh;
            var strOperator;
            var jsnDefaultAttr;

            if (strQSCol) {
                jsnDefaultAttr = element.internalEventData.defaultAttributes;

                if (strQSCol.indexOf('=') !== -1) {
                    arrAttrParts = strQSCol.split(',');
                    i = 0;
                    len = arrAttrParts.length;
                    while (i < len) {
                        strQSCol = arrAttrParts[i];

                        if (strQSCol.indexOf('!=') !== -1) {
                            strOperator = '!=';
                            arrQSParts = strQSCol.split('!=');
                        } else {
                            strOperator = '=';
                            arrQSParts = strQSCol.split('=');
                        }

                        strQSCol = arrQSParts[0];
                        strQSAttr = arrQSParts[1] || arrQSParts[0];

                        // if the key is not present or we've got the negator:
                        //      go to the attribute's default or remove it
                        if (strOperator === '!=') {
                            // if the key is not present: add the attribute
                            if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                                element.setAttribute(strQSAttr, '');
                            // else: remove the attribute
                            } else {
                                element.removeAttribute(strQSAttr);
                            }
                        } else {
                            // if the key is not present:
                            //      go to the attribute's default or remove it
                            if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                                if (jsnDefaultAttr[strQSAttr] !== undefined) {
                                    element.setAttribute(
                                        strQSAttr,
                                        (jsnDefaultAttr[strQSAttr] || '')
                                    );
                                } else {
                                    element.removeAttribute(strQSAttr);
                                }
                            // else: set attribute to exact text from QS
                            } else {
                                element.setAttribute(strQSAttr, (
                                    GS.qryGetVal(strQS, strQSCol) ||
                                    jsnDefaultAttr[strQSAttr] ||
                                    ''
                                ));
                            }
                        }
                        i += 1;
                    }
                } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                    strQSValue = GS.qryGetVal(strQS, strQSCol);

                    if (element.internalData.bolQSFirstRun !== true) {
                        if (
                            strQSValue !== '' ||
                            !element.getAttribute('value')
                        ) {
                            element.setAttribute('value', strQSValue);
                        }
                    } else {
                        element.value = strQSValue;
                    }
                }
            }

            // handle
            //      "refresh-on-querystring-values" and
            //      "refresh-on-querystring-change" attributes
            if (element.internalData.bolQSFirstRun === true) {
                if (element.hasAttribute('refresh-on-querystring-values')) {
                    arrPopKeys = (
                        element.getAttribute('refresh-on-querystring-values')
                            .split(/\s*,\s*/gim)
                    );

                    i = 0;
                    len = arrPopKeys.length;
                    while (i < len) {
                        currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);

                        if (element.popValues[arrPopKeys[i]] !== currentValue) {
                            bolRefresh = true;
                        }

                        element.popValues[arrPopKeys[i]] = currentValue;
                        i += 1;
                    }

                } else if (
                    element.hasAttribute('refresh-on-querystring-change')
                ) {
                    bolRefresh = true;
                }

                if (bolRefresh && element.hasAttribute('src')) {
                    element.refresh();

                } else if (bolRefresh && !element.hasAttribute('src')) {
                    console.warn(
                        'gs-table Warning: ' +
                                'element has "refresh-on-querystring-values" ' +
                                'or "refresh-on-querystring-change", but no ' +
                                '"src".',
                        element
                    );
                }
            } else {
                if (element.hasAttribute('refresh-on-querystring-values')) {
                    arrPopKeys = (
                        element.getAttribute('refresh-on-querystring-values')
                            .split(/\s*,\s*/gim)
                    );

                    i = 0;
                    len = arrPopKeys.length;
                    while (i < len) {
                        element.popValues[arrPopKeys[i]] = (
                            GS.qryGetVal(strQS, arrPopKeys[i])
                        );
                        i += 1;
                    }
                }
            }

            element.internalData.bolQSFirstRun = true;
        };

        if (
            element.getAttribute('qs') ||
            element.getAttribute('refresh-on-querystring-values') ||
            element.hasAttribute('refresh-on-querystring-change')
        ) {
            element.popValues = {};

            element.internalEvents.queryStringResolve();
            window.addEventListener(
                'pushstate',
                element.internalEvents.queryStringResolve
            );
            window.addEventListener(
                'replacestate',
                element.internalEvents.queryStringResolve
            );
            window.addEventListener(
                'popstate',
                element.internalEvents.queryStringResolve
            );
        }
    }


    // ############# FOCUS EVENTS #############
    function unbindFocus(element) {
        element.elems.root.removeEventListener(
            'focus',
            element.internalEvents.rootFocus,
            true
        );
        element.control.removeEventListener(
            evt.mouseout,
            element.internalEvents.mouseOut
        );
        element.control.removeEventListener(
            evt.mouseover,
            element.internalEvents.mouseOver
        );
    }
    function bindFocus(element) {
        element.internalEvents.rootFocus = function () {
            // retarget event
            event.stopPropagation();
            triggerEvent(element, 'focus');

            // save last verified value so that we can trigger a change
            //      event if we change verified value after they leave
            element.internalDisplay.lastPublishedIndex = (
                element.internalDisplay.lastVerifiedIndex
            );
            element.internalDisplay.lastPublishedValue = (
                element.internalDisplay.lastVerifiedValue
            );
            element.internalDisplay.lastPublishedDisplay = (
                element.internalDisplay.lastVerifiedDisplay
            );

            // focus display
            element.classList.add('focus');
        };

        element.elems.root.addEventListener(
            'focus',
            element.internalEvents.rootFocus,
            true
        );

        // we want the combo to get some visual depth when the user hovers
        //      their mouse over
        element.internalEvents.mouseOut = function () {
            element.classList.remove('hover');
        };
        element.internalEvents.mouseOver = function () {
            element.classList.add('hover');
        };

        element.control.addEventListener(
            evt.mouseout,
            element.internalEvents.mouseOut
        );
        element.control.addEventListener(
            evt.mouseover,
            element.internalEvents.mouseOver
        );
    }

    // ############# BLUR EVENTS #############
    function unbindBlur(element) {
        element.elems.root.removeEventListener(
            'blur',
            element.internalEvents.rootBlur,
            true
        );
    }
    function bindBlur(element) {
        element.internalEvents.rootBlur = function () {
            event.stopPropagation();

            // if the currently focused element is the dropdown button, the
            //      combobox hasn't actually lost focus.
            if (
                event.relatedTarget !== element.elems.button &&
                event.relatedTarget !== element.elems.control &&
                event.relatedTarget !== element
            ) {
                // retarget event
                triggerEvent(element, 'blur');

                // may need to trigger a change event
                triggerChangeIfNeeded(element);

                // remove focus css
                element.classList.remove('focus');
            }
        };

        element.elems.root.addEventListener(
            'blur',
            element.internalEvents.rootBlur,
            true
        );
    }

    // ############# CHANGE EVENTS #############
    function unbindChange(element) {
        element.elems.control.removeEventListener(
            'change',
            element.internalEvents.change
        );
    }
    function bindChange(element) {
        element.internalEvents.change = function () {
            event.preventDefault();
            event.stopPropagation();
            // Nunzio added this on 2021-10-12, see below
            if (!element.hasAttribute('limit-to-list')
                    && element.internalDisplay.lastVerifiedDisplay !==
                    element.control.value) {
                element.internalDisplay.lastVerifiedDisplay =
                        element.control.value;
            }

            // Nunzio added this on 2021-07-03
            // Change events weren't getting triggered when
            // typing instead of selecting from the dropdown
            triggerChangeIfNeeded(element);
        };
        element.elems.control.addEventListener(
            'change',
            element.internalEvents.change
        );
    }

    // ############# KEY EVENTS #############
    function unbindKey(element) {
        element.elems.control.removeEventListener(
            'keydown',
            element.internalEvents.keydown
        );
        element.elems.control.removeEventListener(
            'keyup',
            element.internalEvents.keyup
        );
        element.elems.control.removeEventListener(
            'paste',
            element.internalEvents.paste
        );
    }
    function bindKey(element) {
        element.internalEvents.keydown = function (event) {
            var key = (event.keyCode || event.which);
            var shft = event.shiftKey;
            var mod = (event.metaKey || event.ctrlKey);
            var del = (key === 46 || key === 8);
            var keyLeft = (key === 37);
            var keyUp = (key === 38);
            var keyRight = (key === 39);
            var keyDown = (key === 40);
            var arr = (keyLeft || keyUp || keyRight || keyDown);
            var control = element.elems.control;
            var intRow;
            var intMaxRow;

            // When the combo is disabled, only allow the tab key, or keyboard
            //      shortcuts
            if (
                (
                    element.hasAttribute('disabled') ||
                    element.hasAttribute('readonly')
                ) &&
                key !== 9 &&
                !(event.metaKey || event.ctrlKey)
            ) {
                event.preventDefault();
                event.stopPropagation();
                return false;
            }

            // vertical arrow, no error, no modifier keys
            if ((keyUp || keyDown) && !mod) {
                // dropdown not open, time to open
                if (!element.internalDisplay.open) {
                    toggleDropdown(element);

                // else, move selection
                } else {
                    // we used up the key event, nothing else should get it
                    event.preventDefault();
                    event.stopPropagation();

                    // get selected row, stop if any item we need is unavailable
                    intRow = getSelectedRowFromDropdown(element);
                    intMaxRow = (element.internalData.records.length - 1);

                    // don't move forward unless we found a row.
                    if (intRow === null) {
                        intRow = 0;

                    // next record or loop to first if already at the end
                    } else if (keyUp) {
                        if (intRow === 0) {
                            intRow = intMaxRow;
                        } else {
                            intRow -= 1;
                        }

                    // prev record or loop to first if already at the end
                    } else if (keyDown) {
                        if (intRow === intMaxRow) {
                            intRow = 0;
                        } else {
                            intRow += 1;
                        }
                    }

                    // set selection and render
                    element.elems.gsTable.goToLine(intRow + 1);

                    // set control, value attribute, and record as verified
                    if (setValueFromDropdown(element)) {
                        // select the whole value so that the user can delete
                        GS.setInputSelection(control, 0, control.value.length);
                    }
                }

            // right arrow, return, tab, no control keys, close dropdown
            } else if ((keyRight || key === 13 || key === 9) && !mod) {
                if (element.internalDisplay.open) {
                    closeDropDown(element);
                    triggerChangeIfNeeded(element);
                }

            // if the esc key is pressed
            } else if (key === 27) {
                // restore the previous value
                element.internalDisplay.lastVerifiedIndex = (
                    element.internalDisplay.lastPublishedIndex
                );
                element.internalDisplay.lastVerifiedValue = (
                    element.internalDisplay.lastPublishedValue
                );
                element.internalDisplay.lastVerifiedDisplay = (
                    element.internalDisplay.lastPublishedDisplay
                );

                // apply values
                element.elems.control.value = (
                    element.internalDisplay.lastVerifiedDisplay
                );
                element.setAttribute(
                    'value',
                    element.internalDisplay.lastVerifiedValue
                );

                // close the dropdown
                if (element.internalDisplay.open) {
                    closeDropDown(element);
                }

            // (not modifier, delete or arrow keys) OR (paste)
            } else if (
                (!mod && !del && !arr) ||
                // allow paste otherwise pasting a value and leaving the combo
                //      won't trigger resize because the verified value wont be
                //      updated.
                (!shft && mod && key === 86 && event.pasteEvent) // CMD/CTRL - V
            ) {
                // we only want to search the records on keyup, because it
                //      can be resource intensive. So, if we're not using a
                //      modifier key, delete key, or arrow key, then we want
                //      to search on the next keyup.
                element.internalEvents.searchNextKeyUp = true;

            // if delete key
            } else if (del) {
                // we only want to search the records on keyup, because it
                //      can be resource intensive. So, if we're not using a
                //      modifier key, delete key, or arrow key, then we want
                //      to search on the next keyup.
                element.internalEvents.searchNextKeyUpDelete = true;
            }
        };
        element.internalEvents.paste = function () {
            var controlElem = this;
            setTimeout(function() {
                console.log('this.value: ' + controlElem.value);
                console.log('element.control.value: ' + element.control.value);
                GS.triggerEvent(controlElem, 'keydown', {
                    "keyCode": 86,
                    "metaKey": true,
                    "pasteEvent": true
                });
                GS.triggerEvent(controlElem, 'keyup', {
                    "keyCode": 86,
                    "metaKey": true,
                    "pasteEvent": true
                });
            }, 5);
        };
        element.internalEvents.keyup = function () {
            var intLastIndex;
            var strLastDisplay;
            var strSearch;
            var jsnSelection;
            var jsnSearch;
            var gsTable;
            var strValue;
            var strDisplay;

            // get search string
            strSearch = element.elems.control.value;

            // get current selection
            jsnSelection = GS.getInputSelection(element.elems.control);

            // get last verified display value
            intLastIndex = element.internalDisplay.lastVerifiedIndex;
            strLastDisplay = element.internalDisplay.lastVerifiedDisplay;

            console.log('strSearch: ' + strSearch);
            console.log('jsnSelection: ' + jsnSelection);
            console.log('intLastIndex: ' + intLastIndex);
            console.log('strLastDisplay: ' + strLastDisplay);
            // we want to prevent extra searching if we can, because with lots
            //      of data it can get pretty intensive
            if (
                element.internalEvents.searchNextKeyUp &&
                intLastIndex !== null &&
                intLastIndex !== undefined &&
                strLastDisplay &&
                strSearch &&
                strLastDisplay.indexOf(strSearch) === 0
            ) {
                //console.log('prefill the rest of the value');
                // prefill the rest of the value
                element.elems.control.value = strLastDisplay;

                // make sure to select the added text so that it can be
                //      overridden easily
                GS.setInputSelection(
                    element.elems.control,
                    strSearch.length,
                    strLastDisplay.length
                );

            // if we want to search on the next keyup
            } else if (
                element.internalEvents.searchNextKeyUp &&
                // only search when we have a search string
                strSearch &&
                // only search when at the end of the field
                jsnSelection.start === strSearch.length &&
                // we don't want to search if a string that started this way
                //      already failed
                strSearch.indexOf(
                    element.internalDisplay.lastNotFoundSearch
                ) === -1
            ) {
                //console.log('perform partial search through our data');
                // perform partial search through our data
                jsnSearch = findRecord(element, strSearch, strSearch, true);

                if (jsnSearch.found) {
                    strValue = jsnSearch.value;
                    strDisplay = jsnSearch.display;
                } else {
                    strValue = strSearch;
                    strDisplay = strSearch;

                    // we don't want to search next key if this search didn't
                    //      find anything
                    element.internalDisplay.lastNotFoundSearch = strSearch;
                }

                // save search results as the last verified value, this will be
                //      important if we try to trigger a change
                element.internalDisplay.lastVerifiedIndex = jsnSearch.index;
                element.internalDisplay.lastVerifiedValue = strValue;
                element.internalDisplay.lastVerifiedDisplay = strDisplay;

                // prefill the rest of the value
                element.elems.control.value = strDisplay;
                element.setAttribute('value', strValue);

                //make sure to select the added text so that it can be
                //      overridden easily
                GS.setInputSelection(
                    element.elems.control,
                    strSearch.length,
                    strDisplay.length
                );

                // we want the dropdown table to stay up to date if it's open
                if (element.internalDisplay.open) {
                    gsTable = element.elems.gsTable;

                    if (jsnSearch.found) {
                        gsTable.goToLine(jsnSearch.index + 1);
                    } else {
                        // if there's no match, we want to scroll to top and
                        //      deselect all records
                        gsTable.goToLine(0);
                        gsTable.internalSelection.ranges = [];
                        gsTable.renderSelection();
                    }
                }

            // not in the list, no searching
            } else if (element.internalEvents.searchNextKeyUp) {
                //console.log('save current display value for the changeevent');
                // save current display value for the change event
                strLastDisplay = element.elems.control.value;
                element.internalDisplay.lastVerifiedIndex = null;
                element.internalDisplay.lastVerifiedValue = strLastDisplay;
                element.internalDisplay.lastVerifiedDisplay = strLastDisplay;

            // if we are clearing the field
            } else if (!strSearch) {
                //console.log('save current display value for the changeevent');
                // save current display value for the change event
                strLastDisplay = element.elems.control.value;
                element.internalDisplay.lastVerifiedIndex = null;
                element.internalDisplay.lastVerifiedValue = strLastDisplay;
                element.internalDisplay.lastVerifiedDisplay = strLastDisplay;
                element.value = '';

            // on delete, we want to search for items in case they match the
            //      list
            } else if (element.internalEvents.searchNextKeyUpDelete) {
                // // get search string
                // strSearch = element.elems.control.value;

                // // perform partial search through our data (exact was looking
                // //  for a complete match, not the start matching up)
                // jsnSearch = findRecord(element, strSearch, strSearch, true);

                // if (jsnSearch.found) {
                //     strValue = jsnSearch.value;
                //     strDisplay = jsnSearch.display;
                // } else {
                //     strValue = strSearch;
                //     strDisplay = strSearch;

                //     // we don't want to search next key if this search didn't
                //     //      find anything
                //     element.internalDisplay.lastNotFoundSearch = strSearch;
                // }

                // // save search results as the last verified value, this will be
                // //      important if we try to trigger a change
                // element.internalDisplay.lastVerifiedIndex = jsnSearch.index;
                // element.internalDisplay.lastVerifiedValue = strValue;
                // element.internalDisplay.lastVerifiedDisplay = strDisplay;

                // // prefill the rest of the value
                // // might need to comment out these two lines below, might've
                // //      been misbehaving due to previous exact search which we
                // //      have now changed to partial - Michael/Cross 6/6/2022
                // element.elems.control.value = strDisplay;
                // element.setAttribute('value', strValue);
                // element.internalEvents.searchNextKeyUpDelete = false;

                // if we are deleting, we shouldnt be autocompleting
                //      - Michael 7/1/2022
                strSearch = element.elems.control.value;
                element.internalDisplay.lastVerifiedIndex = null;
                element.internalDisplay.lastVerifiedValue = strSearch;
                element.internalDisplay.lastVerifiedDisplay = strSearch;
            }

            // reset for next cycle
            element.internalEvents.searchNextKeyUp = false;
            element.internalEvents.searchNextKeyUpDelete = false;
        };

        element.elems.control.addEventListener(
            'keydown',
            element.internalEvents.keydown
        );
        element.elems.control.addEventListener(
            'keyup',
            element.internalEvents.keyup
        );
        element.elems.control.addEventListener(
            'paste',
            element.internalEvents.paste
        );
    }

    // ############# DROPDOWN EVENTS #############
    function unbindDropdown(element) {
        element.removeEventListener(
            'click',
            element.internalEvents.dropdownClick
        );
    }
    function bindDropdown(element) {
        element.internalEvents.dropdownClick = function () {
            // if this click propagates/bubbles, it triggers the close drop down
            //      code. Because, we want to close the dropdown after the first
            //      registered click.
            //event.stopPropagation();
            // for some reason, in a gs-table the stopPropagation is not enough
            // Nunzio on 2022-01-10
            //event.preventDefault();

            // prevent this event from bubbling up and triggering the dropdown
            //      close code (we exclude events that have "gs" set to true
            event.gs = true;

            // time to toggle
            toggleDropdown(element);
        };

        element.elems.button.addEventListener(
            'click',
            element.internalEvents.dropdownClick
        );

        // for an unknown reason, clicking on the dropdown causes a click on the
        //      control. It cannot bubble up to it, but it's there, and it
        //      causes the dropdown to close. So, we're tagging it as a GS
        //      event to prevent it from closing the dropdown in GS tables.
        element.internalEvents.dropdownClick2 = function () {
            //event.stopPropagation();
            //event.preventDefault();
            event.gs = true;
        };

        element.elems.control.addEventListener(
            'click',
            element.internalEvents.dropdownClick2
        );
    }

    // ############# DEVELOPER EVENTS #############
    function unbindDeveloper(element) {
        element.removeEventListener(
            evt.mousedown,
            element.internalEvents.developerMouseDown
        );
    }
    function bindDeveloper(element) {
        element.internalEvents.developerMouseDown = function (event) {
            var bolCMDorCTRL = (event.ctrlKey || event.metaKey);
            var bolShift = (event.shiftKey);
            var strHTML;
            var arrAttr;
            var jsnAttr;
            var i;
            var len;

            if (bolCMDorCTRL && bolShift) {
                event.preventDefault();
                event.stopPropagation();

                strHTML = '';
                arrAttr = element.attributes;
                i = 0;
                len = arrAttr.length;
                while (i < len) {
                    jsnAttr = arrAttr[i];

                    strHTML += (
                        '<b>Attribute "' + encodeHTML(jsnAttr.name) + '":</b>' +
                        '<pre>' + encodeHTML(jsnAttr.value) + '</pre>'
                    );

                    i += 1;
                }

                GS.msgbox('Developer Info', strHTML, ['Ok']);
            }
        };

        element.addEventListener(
            evt.mousedown,
            element.internalEvents.developerMouseDown
        );
    }


    // ############# HIGH LEVEL BINDING #############
    function unbindElement(element) {
        unbindQuerystringEvents(element);
        unbindFocus(element);
        unbindBlur(element);
        unbindChange(element);
        unbindKey(element);
        unbindDropdown(element);
        unbindDeveloper(element);
    }
    function bindElement(element) {
        bindQuerystringEvents(element);
        bindFocus(element);
        bindBlur(element);
        bindChange(element);
        bindKey(element);
        bindDropdown(element);
        bindDeveloper(element);
    }


// #############################################################################
// ############################## XTAG DEFINITION ##############################
// #############################################################################

    function elementInserted(element) {
        if (
            // if "created"/"inserted" are not suspended: continue
            !element.hasAttribute('suspend-created') &&
            !element.hasAttribute('suspend-inserted') &&
            // if this is the first time inserted has been run: continue
            !element.inserted
        ) {
            element.inserted = true;

            resolveElementAttributes(element);
            prepareElement(element);
            siphonElement(element);
            bindElement(element);
            renderControl(element);
            dataSELECT(element);
            triggerEvent(element, 'initialized');
        }
    }

    xtag.register('gs-combo', {

// #############################################################################
// ############################# ELEMENT LIFECYCLE #############################
// #############################################################################

        lifecycle: {
            'inserted': function () {
                elementInserted(this);
            },

            'removed': function () {
                this.destroy();
            },

            'attributeChanged': function (attr) {//, oldValue, newValue
                var element = this;

                // if suspend attribute: run inserted event
                if (attr === 'suspend-created' || attr === 'suspend-inserted') {
                    elementInserted(element);

                // if the element is not suspended: handle attribute changes
                } else if (
                    !element.hasAttribute('suspend-created') &&
                    !element.hasAttribute('suspend-inserted')
                ) {
                    var arrAttributes = [
                        'placeholder', 'name', 'maxlength', 'autofocus', 'readonly', 'title'
                    ];
                    if (attr === 'value' || arrAttributes.indexOf(attr) > -1) {
                        renderControl(element);
                    }
                }
            }
        },

// #############################################################################
// ############################# ELEMENT ACCESSORS #############################
// #############################################################################

        accessors: {
            // the "value" attribute is the master location for the hidden value
            //      anything else would lead to confusion. So, the .value
            //      accessor just sets the attribute.
            'value': {
                'get': function () {
                    return this.getAttribute('value');
                },
                'set': function (newValue) {
                    if (newValue === null || newValue === '') {
                        this.elems.control.value = '';
                        this.setAttribute('value', '');
                    } else {
                        this.setAttribute('value', newValue);
                    }
                }
            },

            // the "textValue" is the value that the user sees, not the hidden
            //      value
            'textValue': {
                'get': function () {
                    return this.elems.control.value;
                },
                'set': function (newValue) {
                    this.setAttribute('value', newValue);
                }
            },

            // sometimes, we want to know if the current value is custom from
            //      the user or found in the dropdown list, this accessor
            //      returns true if the value is found in the dropdown
            'valueIsFromDropdown': {
                'get': function () {
                    return this.internalDisplay.lastVerifiedIndex !== null;
                },
                'set': function () {//newValue
                    //this.setAttribute('value', newValue);
                }
            }
        },

// #############################################################################
// ############################## ELEMENT METHODS ##############################
// #############################################################################

        methods: {
            // we don't want a bunch of data hanging in memory, so this allows
            //      the browser to forget everything and use that memory for
            //      other things. This is especially important if the combo has
            //      a boatload of data.
            'destroy': function () {
                var element = this;

                // sometimes, the element is destroyed before it's initialized
                // sometimes, the element gets destroyed multiple times.
                //      we don't want to cause any errors when this happens.
                if (element.elems && element.elems.control) {
                    //close the dropdown
                    closeDropDown(this);

                    // prevent the element from recieving any events
                    unbindElement(element);

                    // this is the fastest way to destroy all of the data
                    element.internalData = {};
                    element.internalEvents = {};
                    element.internalEventData = {};
                    element.internalTemplates = {};
                    element.internalDisplay = {};
                    element.internalSelection = {};

                    // destroy element store
                    element.elems = {};

                    // empty innerHTML
                    element.innerHTML = '';
                }
            },

            // allow the user to refetch the data
            // needs to force a reload, instead of accessing cache
            'refresh': function (callback) {
                var singleUseEvent;

                // we want to run a callback without binding to every
                //      after_select. So, it'll unbind itself after the first
                //      call.
                if (callback) {
                    singleUseEvent = function () {
                        callback();
                        this.removeEventListener('after_select', singleUseEvent);
                    };
                    this.addEventListener('after_select', singleUseEvent);
                }

                // we cache select results for comboboxes. So, we need to make
                //      sure to clear the cache before we reselect.
                this.internalData.clearCache = true;
                dataSELECT(this);
            },

            // "getData" is an alias for refresh
            'getData': function () {
                this.refresh();
            },

            // open combobox dropdown
            'open': function () {
                openDropDown(this);
            },

            // close combobox dropdown
            'close': function () {
                closeDropDown(this);
            },

            // we want to focus the control, not the combobox
            'focus': function () {
                this.elems.control.focus();
            },

            // allow the user to take columns related to the selected record
            'column': function (strColumn) {
                var element = this;
                var jsnRecord;
                var templateFunc;
                var intRow;

                intRow = element.internalDisplay.lastVerifiedIndex;

                if (typeof intRow === 'number') {
                    jsnRecord = recordToJSON(
                        element,
                        element.internalData.records[intRow]
                    );
                    templateFunc = doT.template(
                        '{{var row = jo;}}' +
                        '{{! row[\'' + strColumn + '\'] }}'
                    );

                    return templateFunc(jsnRecord);
                }
                return null;
            }
        }
    });
});
//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';
    addSnippet(
        '<gs-container>',
        '<gs-container>',
        (
            'gs-container min-width="${1:sml;med;lrg;}" ${2:padded}>\n' +
            '    ${0}\n' +
            '</gs-container>'
        )
    );

    addElement('gs-container', '#layout_container_jumbo');

    window.designElementProperty_GSCONTAINER = function () {
        addText('V', 'Min-Width Media', 'min-width');
        addText('V', 'Media', 'media');
        addCheck('V', 'Padded', 'padded');
        addFlexProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var arrTakenContainers = [];
    var intScrollBarWidth;

    function getScrollBarWidth() {
        var inner = document.createElement('div');
        var outer = document.createElement('div');
        var intWidth;

        inner.style.height = '200px';
        outer.style.position = 'absolute';
        outer.style.top = '0';
        outer.style.left = '0';
        outer.style.visibility = 'hidden';
        outer.style.overflow = 'scroll';
        outer.style.width = '50px';
        outer.style.height = '100px';
        outer.appendChild(inner);

        document.body.appendChild(outer);

        intWidth = (outer.offsetWidth - inner.offsetWidth);

        document.body.removeChild(outer);

        return intWidth;
    }

    intScrollBarWidth = getScrollBarWidth();

    function elementInserted(element) {
        var styleElement;

        // if "created" hasn't been suspended and "inserted" hasn't been
        //      suspended: run inserted code
        if (
            !element.hasAttribute('suspend-created') &&
            !element.hasAttribute('suspend-inserted')
        ) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                // if the style element for the container CSS doesn't exist:
                //      create it
                if (!document.getElementById('gs-dynamic-css')) {
                    styleElement = document.createElement('style');
                    styleElement.setAttribute('id', 'gs-dynamic-css');
                    styleElement.setAttribute('gs-dynamic', '');
                    document.head.appendChild(styleElement);
                }

                if (element.getAttribute('min-width')) {
                    element.handleMinWidthCSS();
                } else if (element.getAttribute('media')) {
                    element.handleMediaCSS();
                }
            }
        }
    }

    xtag.register('gs-container', {
        lifecycle: {
            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, ignore, newValue) {
                if (
                    strAttrName === 'suspend-created' &&
                    strAttrName === 'suspend-inserted' &&
                    newValue === null
                ) {
                    elementInserted(this);

                } else if (
                    !this.hasAttribute('suspend-created') &&
                    !this.hasAttribute('suspend-inserted')
                ) {
                    // if the "min-width" attribute changed
                    if (strAttrName === 'min-width') {
                        this.handleMinWidthCSS();

                    // if the "media" attribute changed
                    } else if (strAttrName === 'media') {
                        this.handleMediaCSS();
                    }
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            handleMinWidthCSS: function () {
                var strMinWidth = this.getAttribute('min-width');
                var arrMinWidths;
                var strCSS;
                var i;
                var len;
                var arrClassesToRemove;
                var intContainerID;
                var intWidthNumber;
                var strWidthOperator;
                var strNewWidth;

                // remove old classes
                arrClassesToRemove = (
                    String(this.classList).match(/container-id-[0-9]*/g) || []
                );

                i = 0;
                len = arrClassesToRemove.length;
                while (i < len) {
                    this.classList.remove(arrClassesToRemove[i]);
                    i += 1;
                }

                // sml;med;lrg
                // medium
                // 100;200;300;400;500;600;700;800;900;1000;1100;1200

                // remove all whitespace, lowercase, trim off semicolons
                strMinWidth = (
                    GS.trim(strMinWidth.replace(/\s+/g, '').toLowerCase(), ';')
                );

                // replace shortcuts (lrg => 1200px)
                strMinWidth = (
                    strMinWidth
                        .replace(/small|sml/g, '768px')
                        .replace(/medium|med/g, '992px')
                        .replace(/large|lrg/g, '1200px')
                );

                arrMinWidths = strMinWidth.split(';'); // seperate out layouts

                if (arrTakenContainers.indexOf(strMinWidth) === -1) {
                    arrTakenContainers.push(strMinWidth);
                    intContainerID = arrTakenContainers.length - 1;
                    strCSS = '';

                    i = 0;
                    len = arrMinWidths.length;
                    while (i < len) {
                        intWidthNumber = parseInt(arrMinWidths[i]);
                        strWidthOperator = (
                            arrMinWidths[i].replace(/[0-9]/g, '')
                        );

                        if (strWidthOperator === 'px') {
                            intWidthNumber -= intScrollBarWidth;
                        } else if (strWidthOperator === 'em') {
                            intWidthNumber -= GS.pxToEm(
                                this.parentNode,
                                intScrollBarWidth
                            );
                        }

                        strNewWidth = intWidthNumber + strWidthOperator;

                        strCSS += (
                            '\n@media (min-width:' + arrMinWidths[i] + ') {\n' +
                            '    gs-container.container-id-' + intContainerID +
                            ' { ' +
                            'width:' + strNewWidth + '; ' +
                            'margin-left:auto; ' +
                            'margin-right:auto; ' +
                            '}\n' +
                            '}\n'
                        );

                        i += 1;
                    }

                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += (
                        '\n/* container #' + intContainerID + ' */\n' + strCSS
                    );
                } else {
                    intContainerID = arrTakenContainers.indexOf(strMinWidth);
                }

                this.classList.add('container-id-' + intContainerID);
            },

            handleMediaCSS: function () {
                var strMedia = this.getAttribute('media');
                var arrMedias;
                var strCSS;
                var i;
                var len;
                var arrClassesToRemove;
                var arrParts;
                var strCurrentMedia;
                var strWidth;
                var intContainerID;

                // remove old classes
                arrClassesToRemove = (
                    String(this.classList).match(/container-id-[0-9]*/g) || []
                );

                i = 0;
                len = arrClassesToRemove.length;
                while (i < len) {
                    this.classList.remove(arrClassesToRemove[i]);
                    i += 1;
                }

                // (min-width: 500) {small}; (max-width: 500) {50}
                // (max-width: small) {small}; (min-width: small) {small}
                // (max-width: small) {50}; (min-width: small) {500}

                // trim, remove all close curly braces, lowercase, trim off
                //      semicolons
                strMedia = GS.trim(
                    strMedia.trim().replace(/\}/g, '').toLowerCase(),
                    ';'
                );

                // replace shortcuts (lrg => 1200px)
                strMedia = (
                    strMedia
                        .replace(/small|sml/g, '768px')
                        .replace(/medium|med/g, '992px')
                        .replace(/large|lrg/g, '1200px')
                );

                // seperate out layouts
                arrMedias = strMedia.split(';');

                if (arrTakenContainers.indexOf(strMedia) === -1) {
                    arrTakenContainers.push(strMedia);
                    intContainerID = arrTakenContainers.length - 1;
                    strCSS = '';

                    i = 0;
                    len = arrMedias.length;
                    while (i < len) {
                        arrParts = arrMedias[i].split('{');
                        strCurrentMedia = arrParts[0].trim() || 'all';
                        strWidth = arrParts[1].trim() || '900px';

                        strCSS += (
                            '\n@media ' + strCurrentMedia + ' {\n' +
                            '    gs-container.container-id-' + intContainerID +
                            ' ' +
                            '{ ' +
                            'width:' + strWidth + '; ' +
                            'margin-left:auto; ' +
                            'margin-right:auto; ' +
                            '}\n' +
                            '}\n'
                        );
                        i += 1;
                    }

                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += (
                        '\n/* container #' + intContainerID + ' */\n' + strCSS
                    );

                } else {
                    intContainerID = arrTakenContainers.indexOf(strMedia);
                }

                this.classList.add('container-id-' + intContainerID);
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    "use strict";
    addSnippet(
        '<gs-current-record>',
        '<gs-current-record>',
        'gs-current-record for="${1:for}"></gs-current-record>'
    );

    window.designElementProperty_GSCURRENT_RECORD = function () {
        addText('O', 'GS-Table ID', 'for');
        addCheck('V', 'Inline', 'inline');
    };
});

document.addEventListener("DOMContentLoaded", function () {
    "use strict";
    function buildElement(element) {
        element.forTable = document.getElementById(element.getAttribute('for'));

        element.forTable.addEventListener('selection_change', function () {
            element.refresh(element);
        });
        element.forTable.addEventListener('after_select', function () {
            element.refresh(element);
        });
        element.forTable.addEventListener('after_selection', function () {
            element.refresh(element);
        });

        element.firstChild.addEventListener('change', function (event) {
            var tableElem = element.forTable;
            var strValue = event.target.value;
            var intValue = parseInt(
                strValue.substring(0, strValue.indexOf(' ')),
                10
            );
            var intMaxRecord = tableElem.internalData.records.length;
            var intMinColumn = (
                tableElem.internalDisplay.recordSelectorVisible
                    ? -1
                    : 0
            );

            // if we couldn't extract a record number from the
            //      user's value, go to the first record
            if (isNaN(intValue)) {
                intValue = 1;
            }

            if (intMaxRecord === 0) {
                intValue = undefined;
            }

            // prevent intValue from being greater than the number
            //      of records
            if (intValue > intMaxRecord) {
                intValue = intMaxRecord;
            }

            // intValue is from a user and therefore one-based
            if (!isNaN(intValue)) {
                // correct one-based by subtracting one
                intValue -= 1;
            }

            // override all current ranges to select the new record
            if (intValue !== undefined) {
                tableElem.internalSelection.ranges = [
                    {
                        "start": {"row": intValue, "column": intMinColumn},
                        "end": {"row": intValue, "column": intMinColumn},
                        "negator": false
                    }
                ];
            } else {
                tableElem.internalSelection.ranges = [];
            }

            // render selection and scroll into view
            tableElem.goToLine(intValue + 1);
            event.target.parentNode.refresh(event.target.parentNode);
        });
        element.refresh(element);
    }

    function elementInserted(element) {
        if (element.children.length === 0) {
            var gsText = document.createElement("gs-text");
            element.appendChild(gsText);
        }

        // if "created" hasn't been suspended and "inserted" hasn't been
        //      suspended: run inserted code
        if (
            !element.hasAttribute("suspend-created") &&
            !element.hasAttribute("suspend-inserted")
        ) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                if (!element.children[0].classList.contains('root')) {
                    buildElement(element);
                }
            }
        }
    }

    xtag.register("gs-current-record", {
        lifecycle: {
            inserted: function () {
                elementInserted(this);
            },
            attributeChanged: function (strAttrName, ignore, newValue) {
                // if "suspend-created" has been removed: run created and
                //      inserted code
                if (strAttrName === "suspend-created" && newValue === null) {
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (
                    strAttrName === "suspend-inserted" &&
                    newValue === null
                ) {
                    elementInserted(this);
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            'refresh': function (element) {
                element.bolRefreshing = true;
                var tableElem = element.forTable;
                var intOriginRecord = (
                    tableElem.internalSelection.originRecord || 0
                );
                // we need the element that contains the selection status
                var statusElement = element.firstChild;

                // if the element that is supposed to contain the status is
                //      in the DOM
                if (statusElement) {
                    // if we know the origin record
                    if (intOriginRecord !== undefined) {
                        statusElement.value = (
                            // origin record number is zero-based
                            (intOriginRecord + 1) +
                            ' of ' +
                            tableElem.internalData.records.length
                        );
                    // else, we don't know the origin record
                    } else {
                        statusElement.value = ('nothing selected');
                    }
                }
                element.bolRefreshing = false;
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, addDataEvents, addDataAttributes
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';
    addSnippet(
        '<gs-datasheet>',
        '<gs-datasheet>',
        (
            'gs-datasheet src="${1:test.tpeople}">\n' +
            '    <template for="hud"></template>\n' +
            '    <template for="table">\n' +
            '        <table>\n' +
            '            <tbody>\n' +
            '                <tr>\n' +
            '                    <th heading="#">' +
            '<gs-static column="row_number"></gs-static>' +
            '</th>\n' +
            '                    <td heading="">$0</td>\n' +
            '                </tr>\n' +
            '            </tbody>\n' +
            '        </table>\n' +
            '    </template>\n' +
            '    <template for="insert"></template>\n' +
            '</gs-datasheet>'
        )
    );

    addElement('gs-datasheet', '#record_datasheet');

    window.designElementProperty_GSDATASHEET = function () {
        addDataAttributes('select,insert,update,delete,parent-child');
        addDataEvents('select,insert,update,delete');
        addText('V', 'Reflow At', 'reflow-at');
        addText('V', 'Scroll To Bottom', 'scroll-to-bottom');
        addText('V', 'HUD Paginate', 'no-hudpaginate');
        addText('V', 'HUD Refresh', 'no-hudrefresh');
        addText('V', 'HUD Delete', 'no-huddelete');
        addText('V', 'Expand&nbsp;To&nbsp;Content', 'expand-to-content');
        addText('D', 'Null String', 'null-string');
        addText('V', 'Filter Popup', 'no-filter');
        addText('O', 'Column In QS', 'qs');
        addText('O', 'Refresh On QS Columns', 'refresh-on-querystring-values');
        addText('O', 'Refresh On QS Change', 'refresh-on-querystring-change');
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var KEY_RETURN = 13;
    var KEY_TAB = 9;
    var KEY_BACKSPACE = 8;
    var KEY_DELETE = 46;
    var KEY_UP = 38;
    var KEY_RIGHT = 39;
    var KEY_DOWN = 40;
    var KEY_LEFT = 37;

    function deleteSelection(element) {
        var strSchema = GS.templateWithQuerystring(element.getAttribute('schema'));
        var strObject = GS.templateWithQuerystring(element.getAttribute('object'));
        var arrSelectRecords = element.selectedRecords;
        var deleteRecord;
        var deleteRecordData;
        var arrPk;
        var arrLock;
        var strHashColumns;
        var strRoles;
        var strColumns;
        var strRecord;
        var strRecordToHash;
        var strDeleteData;
        var strTemp;
        var i;
        var len;
        var col_i;
        var col_len;

        // if the first record is the header: remove it from the selection
        if (arrSelectRecords[0] && arrSelectRecords[0].parentNode.nodeName === 'THEAD') {
            arrSelectRecords.splice(0, 1);
        }

        if (
            element.numberOfSelections === 1 &&
            arrSelectRecords.length > 0 &&
            arrSelectRecords[0].children[0].hasAttribute('selected') &&
            !element.deleteButton.hasAttribute('disabled')
        ) {
            GS.triggerEvent(element, 'before_delete');
            GS.triggerEvent(element, 'onbefore_delete');
            if (element.hasAttribute('onbefore_delete')) {
                new Function(element.getAttribute('onbefore_delete')).apply(element);
            }

            // generate the information to send to the websocket
            arrPk = (element.getAttribute('pk') || '').split(/[\s]*,[\s]*/);
            arrLock = (element.getAttribute('lock') || '').split(/[\s]*,[\s]*/);

            i = 0;
            len = arrPk.length;
            strRoles = '';
            strColumns = '';
            while (i < len) {
                strRoles += (
                    (
                        strRoles
                            ? '\t'
                            : ''
                    ) + 'pk'
                );
                strColumns += (
                    (
                        strColumns
                            ? '\t'
                            : ''
                    ) + arrPk[i]
                );
                i += 1;
            }

            i = 0;
            len = arrLock.length;
            strHashColumns = '';
            while (i < len) {
                strHashColumns += (
                    (
                        strHashColumns
                            ? '\t'
                            : ''
                    ) + arrLock[i]
                );
                i += 1;
            }

            strRoles += (
                (
                    strRoles
                        ? '\t'
                        : ''
                ) + 'hash'
            );
            strColumns += (
                (
                    strColumns
                        ? '\t'
                        : ''
                ) + 'hash'
            );

            i = 0;
            len = arrSelectRecords.length;
            strDeleteData = '';
            while (i < len) {
                strRecord = '';
                deleteRecord = arrSelectRecords[i];
                deleteRecordData = element.internalData.arrRecords[parseInt(deleteRecord.getAttribute('data-index'), 10)];

                // get 'pk' columns
                col_i = 0;
                col_len = arrPk.length;
                while (col_i < col_len) {
                    strRecord += (
                        strRecord
                            ? '\t'
                            : ''
                    );
                    strRecord += GS.encodeForTabDelimited(deleteRecordData[element.internalData.arrColumnNames.indexOf(arrPk[col_i])], element.nullString);
                    col_i += 1;
                }

                // get 'hash' columns
                strRecordToHash = '';
                col_i = 0;
                col_len = arrLock.length;
                while (col_i < col_len) {
                    strRecordToHash += (
                        strRecordToHash
                            ? '\t'
                            : ''
                    );
                    strTemp = deleteRecordData[element.internalData.arrColumnNames.indexOf(arrLock[col_i])];

                    // I believe that this needs to use the null-string instead of 'NULL'
                    strRecordToHash += (
                        strTemp === 'NULL'
                            ? ''
                            : strTemp
                    );
                    col_i += 1;
                }

                strDeleteData += (
                    strRecord +
                    (
                        strRecord
                            ? '\t'
                            : ''
                    ) +
                    GS.utfSafeMD5(strRecordToHash).toString() + '\n'
                );
                arrSelectRecords[i].classList.add('bg-red');
                i += 1;
            }

            strDeleteData = (strRoles + '\n' + strColumns + '\n' + strDeleteData);

            // create delete transaction
            GS.addLoader(element, 'Creating Delete Transaction...');
            GS.requestDeleteFromSocket(
                getSocket(element),
                strSchema,
                strObject,
                strHashColumns,
                strDeleteData,
                function (data, error) {//, transactionID
                    if (error) {
                        getData(element);
                        GS.removeLoader(element);
                        GS.webSocketErrorDialog(data);
                    }
                },
                function (data, error, ignore, commitFunction, rollbackFunction) {//transactionID
                    var arrElements;
                    //var i;
                    //var len;
                    var templateElement;
                    GS.removeLoader(element);

                    if (!error) {
                        if (data !== 'TRANSACTION COMPLETED') {
                            arrElements = xtag.query(element, '.bg-red');

                            i = 0;
                            len = arrElements.length;
                            while (i < len) {
                                arrElements[i].classList.remove('bg-red');
                                arrElements[i].classList.add('bg-amber');
                                i += 1;
                            }

                        // open confirm message box
                        } else {
                            templateElement = document.createElement('template');
                            templateElement.innerHTML = ml(function () {/*
                                <gs-page>
                                    <gs-header><center><h3>Are you sure...</h3></center></gs-header>
                                    <gs-body padded>
                                        <center>Are you sure you want to delete {{numberofrecords}} records?</center>
                                    </gs-body>
                                    <gs-footer>
                                        <gs-grid>
                                            <gs-block><gs-button dialogclose>No</gs-button></gs-block>
                                            <gs-block><gs-button id="datasheet-focus-me" dialogclose bg-primary tabindex="0">Yes</gs-button></gs-block>
                                        </gs-grid>
                                    </gs-footer>
                                </gs-page>*/
                            }).replace(/\{\{numberofrecords\}\}/gi, xtag.query(element, '.bg-amber').length);

                            GS.openDialog(
                                templateElement,
                                function () {
                                    document.getElementById('datasheet-focus-me').focus();
                                },
                                function (ignore, strAnswer) {//event
                                    if (strAnswer === 'Yes') {
                                        commitFunction();
                                        GS.addLoader(element, 'Commiting Delete Transaction...');
                                    } else {
                                        rollbackFunction();
                                        GS.addLoader(element, 'Rolling Back Delete Transaction...');
                                    }
                                }
                            );
                        }
                    } else {
                        rollbackFunction();
                        getData(element);
                        GS.webSocketErrorDialog(data);
                    }
                },
                // final result callback, because we need to handle the commit/rollback response
                function (strAnswer, data, error) {
                    var arrElements;
                    //var i;
                    //var len;
                    GS.removeLoader(element);

                    if (!error) {
                        if (strAnswer === 'COMMIT') {
                            // remove amber records, because the amber records have now been deleted
                            removeRecords(element, 'bg-amber');

                            // clear internal variables for selection now that the selected records have been deleted,
                            //      because if you try to shift-select to extend the selection and the origin cell has
                            //      been deleted this may cause an error
                            clearSelection(element);

                            // trigger after_delete so that developers can react to a successful delete
                            GS.triggerEvent(element, 'after_delete');
                            GS.triggerEvent(element, 'onafter_delete');
                            if (element.hasAttribute('onafter_delete')) {
                                new Function(element.getAttribute('onafter_delete')).apply(element);
                            }

                        } else {
                            // clear bg-amber class and don't add a green fade
                            clearRecordColor(element, 'bg-amber', false);
                        }

                        // update record selector numbers to reflect current record numbers
                        //      because after you delete records there may be a gap in the numbers and that is not acceptable
                        arrElements = xtag.query(element, 'tbody > tr');

                        i = 0;
                        len = arrElements.length;
                        while (i < len) {
                            if (!arrElements[i].classList.contains('insert-record')) {
                                arrElements[i].children[0].textContent = (i + 1);
                            }
                            i += 1;
                        }

                    // if an error occurred
                    } else {
                        // get new data, because after an error we don't know the current state
                        //      of the data so a re-fetch will help mitigate inaccurate data errors
                        getData(element);

                        // open an error dialog so that the user knows there was an error
                        GS.webSocketErrorDialog(data);
                    }
                }
            );
        }
    }

    function insertDialog(element) {
        var templateElement = document.createElement('template');
        var strAddin;

        // if there is a column attribute on this element: append child column (or column) and
        //      the value to the insert string so that we can have parent-child relationships
        if (element.getAttribute('column') || element.getAttribute('qs')) {
            strAddin = (
                element.getAttribute('child-column') ||
                element.getAttribute('column') ||
                element.getAttribute('qs')
            ) + '=' + element.value;
        }

        templateElement.innerHTML = ml(function () {/*
            <gs-page gs-dynamic>
                <gs-header>
                    <center><h3>Insert</h3></center>
                </gs-header>
                <gs-body padded>
                    <gs-insert id="insert-dialog-content-container" src="{{SRC}}" addin="{{ADDIN}}">{{HTML}}</gs-insert>
                </gs-body>
                <gs-footer>
                    <gs-grid widths="1,1" class="width-2">
                        <gs-block width="1">
                            <gs-button dialogclose>Cancel</gs-button>
                        </gs-block>
                        <gs-block width="1">
                            <gs-button class="dialog-envelope-insert" listen-for-return bg-primary>Ok</gs-button>
                        </gs-block>
                    </gs-grid>
                </gs-footer>
            </gs-page>*/
        })
            .replace('{{HTML}}', element.insertTemplate)
            .replace('{{SRC}}', encodeHTML(element.getAttribute('src')))
            .replace('{{ADDIN}}', encodeHTML(strAddin || ''));

        GS.openDialog(templateElement, function () {
            var dialog = this;

            // if gs-datasheet has sequence attribute: add sequence attribute to gs-insert
            if (element.getAttribute('seq')) {
                document.getElementById('insert-dialog-content-container').setAttribute('seq', element.getAttribute('seq'));
            }

            GS.triggerEvent(element, 'insert_dialog_open');

            xtag.query(dialog, '.dialog-envelope-insert')[0].addEventListener('click', function () {
                var insertContainer = document.getElementById('insert-dialog-content-container');

                GS.triggerEvent(element, 'before_insert');
                GS.triggerEvent(element, 'onbefore_insert');
                if (element.hasAttribute('onbefore_insert')) {
                    new Function(element.getAttribute('onbefore_insert')).apply(element);
                }

                insertContainer.submit(function () { //lastval, jsnRow
                    getData(element);
                    GS.triggerEvent(element, 'after_insert');
                    GS.triggerEvent(element, 'onafter_insert');
                    if (element.hasAttribute('onafter_insert')) {
                        new Function(element.getAttribute('onafter_insert')).apply(element);
                    }
                    GS.closeDialog(dialog, 'Ok');
                });
            });
        });
    }

    function clearSelection(element) {
        element.savedSelection = [];
        element.savedSelectionCopy = [];
        element.dragOrigin = null;
        element.dragCurrentCell = null;
        element.selectionPreviousOrigin = null;
        element.numberOfSelections = 0;
        element.selectedCells = [];
    }

    function templateRecordsForInsert(element, strRecords, strClasses) {
        var arrRecords;
        var arrCells;
        var i;
        var len;
        var cell_i;
        var cell_len;
        var col_len;
        var strHTML;
        var intRowNumberAdd;

        // calculate the number of cells across
        if (element.getAttribute('cols')) {
            col_len = (element.getAttribute('cols') || '').split(/[\s]*,[\s]*/).length;
        }

        arrRecords = strRecords.split('\n');

        // calculate how much to add to the row numbers
        intRowNumberAdd = xtag.query(element, 'tr:not(.bg-red):not(.insert-record)').length - 1;

        i = 1;
        len = arrRecords.length - 1;
        strHTML = '';
        while (i < len) {
            arrCells = arrRecords[i].split('\t');

            strHTML += (
                '<tr ' +
                (
                    strClasses
                        ? ' class="' + strClasses + '"'
                        : ''
                )
            );

            cell_i = 0;
            cell_len = arrCells.length;
            while (cell_i < cell_len) {
                strHTML += (
                    'data-' + element.internalData.arrColumnNames[cell_i] +
                    '="' + encodeHTML(GS.decodeFromTabDelimited(arrCells[cell_i], element.nullString)) + '"'
                );
                cell_i += 1;
            }

            strHTML += '><th>' + (intRowNumberAdd + (i)) + '</th>';

            cell_i = 0;
            cell_len = (col_len || arrCells.length);
            while (cell_i < cell_len) {
                strHTML += (
                    '<td><textarea rows="1" column="' + element.internalData.arrColumnNames[cell_i] + '">' +
                        encodeHTML(GS.decodeFromTabDelimited(arrCells[cell_i], element.nullString) || '') +
                    '</textarea></td>'
                );
                cell_i += 1;
            }

            strHTML += '</tr>';
            i += 1;
        }

        //    strHTML = GS.templateWithEnvelopeData(element.tableTemplate.templateHTML, {
        //                        'arr_column': data.arrColumnNames
        //                      , 'dat': element.internalData.arrRecords
        //              }, intStart, element.internalData.arrRecords.length);
        //    strHTML = GS.templateShowSubTemplates(strHTML, element.tableTemplate);
        //
        //trMaker.children[0].classList.add('insert-record');

        return strHTML;
    }

    function synchronizeHeaderWidths(element) {
        var guideTR;
        var targetTR;
        var arrChildren;
        var i;
        var len;
        var subtractPadding;

        if (element.scrollCaption) {
            element.scrollCaption.style.width = (element.clientWidth) + 'px';
        }
        if (element.headerCaption) {
            element.headerCaption.style.width = (element.clientWidth) + 'px';
        }

        targetTR = element.headerTR;
        if (element.scrollContainer) {
            guideTR = xtag.query(element.scrollContainer, 'tr')[0];

            if (guideTR) {
                arrChildren = xtag.toArray(guideTR.children);
                subtractPadding = 0; //GS.emToPx(element.headerContainer, 0.2);

                if (element.scrollContainer.scrollHeight > element.scrollContainer.clientHeight) {
                    element.headerContainer.classList.add('scroll');
                } else {
                    element.headerContainer.classList.remove('scroll');
                }

                i = 0;
                len = arrChildren.length;
                while (i < len) {
                    targetTR.children[i].style.width = (arrChildren[i].clientWidth - subtractPadding) + 'px';
                    i += 1;
                }
            }
        }
    }
    function synchronizeHeaderScroll(element) {
        if (element.headerContainer && element.scrollContainer) {
            if (element.scrollContainer.scrollTop > 0) {
                element.headerContainer.classList.add('shadow');
            } else {
                element.headerContainer.classList.remove('shadow');
            }
            element.headerContainer.scrollLeft = element.scrollContainer.scrollLeft;
        }
    }

    function handleData(element, data, bolFirstLoad, bolManualRefresh) {
        var strHTML;
        var i;
        var len;
        var cell_i;
        var cell_len;
        var arrRecords;
        var arrCells;
        var disabled;
        var arrColumns;
        var arrElements;
        var tbodyElement;
        var trMaker;
        var intStart;
        var bolHeader;
        var strWidth;
        var numberOffset;

        // calculate the number of cells across
        if (element.getAttribute('cols')) {
            arrColumns = (element.getAttribute('cols') || '').split(/[\s]*,[\s]*/);

            i = 0;
            len = arrColumns.length;
            while (i < len) {
                arrColumns[i] = data.arrColumnNames.indexOf(arrColumns[i]);
                i += 1;
            }
        }

        disabled = element.hasAttribute('disabled') || !element.hasAttribute('pk');

        var strCaption = '';

        if (element.hasAttribute('caption')) {
            strCaption = '<caption><center><h4>' + element.getAttribute('caption') + '</h4></center></caption>';
        }

        // if first callback: table and header
        if (data.intCallback === 0) {
            if (!element.hasAttribute('lock')) {
                element.setAttribute('lock', data.arrColumnNames.join(','));
            }
            if (!element.hasAttribute('cols')) {
                element.setAttribute('cols', data.arrColumnNames.join(','));
            }
            if (disabled) {
                element.deleteButton.setAttribute('disabled', '');
            } else {
                element.deleteButton.removeAttribute('disabled');
            }

            element.internalData = {
                'arrColumnNames': data.arrColumnNames || [],
                'arrColumnTypes': data.arrColumnTypes || [],
                'arrRecords': []
            };

            if (element.headerTemplateRecord) {
                strHTML = GS.templateWithQuerystring(element.headerTemplateRecord);
                element.scrollContainer.innerHTML = '<table role="grid">' + strCaption + '<thead>' + strHTML + '</thead><tbody></tbody></table>';

            } else {
                arrElements = xtag.queryChildren(element.tableTemplateRecord, 'td, th');
                i = 0;
                len = arrElements.length;
                strHTML = '';
                while (i < len) {
                    strHTML += '<th scope="col" role="columnheader">' + encodeHTML(arrElements[i].getAttribute('heading') || '') + '</th>';

                    bolHeader = Boolean(arrElements[i].hasAttribute('heading') || '') || bolHeader;
                    i += 1;
                }
                strHTML = '<tr role="row">' + strHTML + '</tr>';

                if (bolHeader) {
                    element.scrollContainer.innerHTML = '<table role="grid">' + strCaption + '<thead>' + strHTML + '</thead><tbody></tbody></table>';
                } else {
                    element.scrollContainer.innerHTML = '<table role="grid">' + strCaption + '<thead hidden>' + strHTML + '</thead><tbody></tbody></table>';
                }
            }
        }

        // if not last callback: append data to end of table
        if (data.strMessage !== 'TRANSACTION COMPLETED') {
            arrRecords = data.strMessage.split('\n');

            intStart = element.internalData.arrRecords.length;

            i = 0;
            len = arrRecords.length - 1;
            strHTML = '';
            while (i < len) {
                arrCells = arrRecords[i].split('\t');

                cell_i = 0;
                cell_len = arrCells.length;
                while (cell_i < cell_len) {
                    arrCells[cell_i] = GS.decodeFromTabDelimited(arrCells[cell_i], element.nullString);
                    cell_i += 1;
                }

                element.internalData.arrRecords.push(arrCells);
                i += 1;
            }

            if (element.paginated === true && !isNaN(element.getAttribute('offset'))) {
                numberOffset = parseInt(element.getAttribute('offset'), 10);
            } else {
                numberOffset = 0;
            }

            strHTML = GS.templateWithEnvelopeData(
                element.tableTemplate.templateHTML,
                {
                    'arr_column': data.arrColumnNames,
                    'dat': element.internalData.arrRecords
                },
                intStart,
                element.internalData.arrRecords.length,
                numberOffset
            );

            strHTML = GS.templateShowSubTemplates(strHTML, element.tableTemplate);

            trMaker = document.createElement('tbody');
            trMaker.innerHTML = strHTML;
            tbodyElement = xtag.query(element.scrollContainer, 'tbody')[0];

            arrElements = xtag.toArray(trMaker.children);
            i = 0;
            len = arrElements.length;
            while (i < len) {
                tbodyElement.appendChild(arrElements[i]);
                i += 1;
            }
            //xtag.query(element.scrollContainer, 'tbody')[0].innerHTML += strHTML;

        // if last callback: insert record
        } else {
            arrElements = xtag.query(element.scrollContainer, 'tbody tr');

            if (arrElements[0] && arrElements[0].children[0].nodeName === 'TH' && !isNaN(arrElements[0].children[0].textContent)) {
                strWidth = (
                    GS.pxToEm(
                        element.hudContainer,
                        GS.getTextWidth(
                            element.hudContainer,
                            String(element.internalData.arrRecords.length + 1)
                        )
                    ) + 1
                ) + 'em';

                xtag.query(element.scrollContainer, 'thead th')[0].style.width = strWidth;
                xtag.query(element.scrollContainer, 'tbody th')[0].style.width = strWidth;
            }

            if (parseInt((element.getAttribute('limit') || '0'), 10) > arrElements.length) {
                element.pageRightButton.setAttribute('disabled', '');
            } else {
                element.pageRightButton.removeAttribute('disabled');
            }

            //if (element.insertRecordElement) {
            //    trMaker = document.createElement('tbody');
            //    trMaker.innerHTML = element.insertRecordElement.outerHTML;
            //    trMaker.children[0].classList.add('insert-record');
            //    tbodyElement = xtag.query(element.scrollContainer, 'tbody')[0];
            //
            //    //if (tbodyElement.children[0]) {
            //    //    tbodyElement.insertBefore(trMaker.children[0], tbodyElement.children[0]);
            //    //} else {
            //    tbodyElement.appendChild(trMaker.children[0]);
            //    //}
            //}

            arrElements = xtag.query(element.scrollContainer, 'tr');

            if (arrElements[0].parentNode.hasAttribute('hidden')) {
                element.headerContainer.innerHTML = '<table role="grid">' + strCaption + '<thead hidden>' + arrElements[0].outerHTML + '</thead></table>';
            } else {
                element.headerContainer.innerHTML = '<table role="grid">' + strCaption + '<thead>' + arrElements[0].outerHTML + '</thead></table>';
            }

            element.headerTR = xtag.query(element.headerContainer, 'thead')[0].children[0];
            element.scrollCaption = xtag.query(element.scrollContainer, 'caption')[0];
            element.headerCaption = xtag.query(element.headerContainer, 'caption')[0];

            refreshReflow(element);
            refreshHeight(element);
            synchronize(element, undefined, true, bolManualRefresh);
            synchronizeHeaderWidths(element);
            synchronizeHeaderScroll(element);

            if (bolFirstLoad && element.hasAttribute('scroll-to-bottom')) {
                element.scrollContainer.scrollTop = element.scrollContainer.scrollHeight;
            }

            GS.triggerEvent(element, 'after_select');
        }
    }

    // get return column list
    function getReturn(element) {
        var arrColumns = [];
        var arrSupplementalColumns = [];
        var arrColsAttr;
        var strColumns;
        var arrPK;
        var arrLock;
        var i;
        var len;

        // pk
        arrPK = (element.getAttribute('pk') || '').split(/[\s]*,[\s]*/);
        i = 0;
        len = arrPK.length;
        while (i < len) {
            if (arrPK[i]) {
                GS.listAdd(arrSupplementalColumns, arrPK[i]);
            }
            i += 1;
        }

        // lock
        arrLock = (element.getAttribute('lock') || '').split(/[\s]*,[\s]*/);
        i = 0;
        len = arrLock.length;
        while (i < len) {
            if (arrLock[i]) {
                GS.listAdd(arrSupplementalColumns, arrLock[i]);
            }
            i += 1;
        }

        if (element.internalData && element.internalData.arrColumnNames) {
            i = 0;
            len = element.internalData.arrColumnNames.length;
            while (i < len) {
                GS.listAdd(arrColumns, element.internalData.arrColumnNames[i]);
                i += 1;
            }
        } else if (element.getAttribute('cols')) {
            arrColsAttr = element.getAttribute('cols').split(/[\s]*,[\s]*/);
            i = 0;
            len = arrColsAttr.length;
            while (i < len) {
                GS.listAdd(arrColumns, arrColsAttr[i]);
                i += 1;
            }
        }

        if (arrColumns.length === 0 || (arrColumns.length === 1 && arrColumns[0] === '*')) {
            strColumns = '*';

        } else {
            i = 0;
            len = arrSupplementalColumns.length;
            while (i < len) {
                GS.listAdd(arrColumns, arrSupplementalColumns[i]);
                i += 1;
            }

            strColumns = arrColumns.join('\t');
        }

        return strColumns;
    }

    function valueListToHTML(element, valueText, fieldDelimiter, recordDelimiter, ignore, quoteCharacter, decodeFunction) { //bolFirstContainsHeadings
        var i = 0;
        var len = valueText.length;
        var col_i;
        var col_len;
        var arrRecords = [];
        var arrRecord = [];
        var bolInQuote = false;
        var strCell = '';
        var strRecord;
        var strHTML = '';
        var strPreviousChar;

        // if there is a recordDelimiter at the beginning: add 1 to "i" to skip over it
        if (valueText[0] === recordDelimiter) {
            i += 1;
        }

        // make sure there is a recordDelimiter at the end
        if (valueText[len - 1] !== recordDelimiter) {
            valueText += recordDelimiter;
            len = valueText.length;
        }

        // looper
        while (i < len) {
            if (
                valueText[i] === quoteCharacter &&
                bolInQuote === false &&
                (
                    strPreviousChar === fieldDelimiter ||
                    strPreviousChar === recordDelimiter ||
                    strPreviousChar === undefined
                )
            ) {
                bolInQuote = true;

            } else if (valueText[i] === quoteCharacter && bolInQuote === true) {
                bolInQuote = false;

            } else if (valueText[i] === fieldDelimiter && bolInQuote === false) {
                arrRecord.push(decodeFunction(strCell, element.nullString));
                strCell = '';

            } else if (valueText[i] === recordDelimiter && bolInQuote === false) {
                arrRecord.push(decodeFunction(strCell, element.nullString));
                strCell = '';

                arrRecords.push(arrRecord);
                arrRecord = [];

            } else {
                strCell += valueText[i];
            }

            strPreviousChar = valueText[i];
            i += 1;
        }

        // data structure to html
        i = 0;
        len = arrRecords.length;
        while (i < len) {
            strRecord = '';
            col_i = 0;
            col_len = arrRecords[i].length;
            while (col_i < col_len) {
                strRecord += '<td>' + encodeHTML(arrRecords[i][col_i]) + '</td>';
                col_i += 1;
            }
            strHTML += '<tr>' + strRecord + '</tr>';
            i += 1;
        }

        return '<table>' + strHTML + '</table>';
    }

    /*function quoteIdent(strValue) {
        strValue = strValue || '';

        // if first char is not a lowercase letter or there is a character that is not a lowercase letter, underscore or number
        if (!(/[a-z]/).test(strValue[0]) || (/[^a-z_]/).test(strValue)) {
            strValue = '"' + strValue.replace(/\"/gim, '""') + '"';
        }

        return strValue;
    }*/

    /* // disfated's answer at: http://stackoverflow.com/questions/202605/repeat-string-javascript
    function stringRepeat(pattern, count) {
        if (count < 1) {
            return '';
        }
        var result = '';
        while (count > 1) {
            if (count & 1) result += pattern;
            count >>= 1, pattern += pattern;
        }
        return result + pattern;
    }*/
    function stringRepeat(pattern, count) {
        var result = '';

        count += 1;
        while (count > 1) {
            result += pattern;
            count -= 1;
        }

        return result;
    }

    function getSocket(element) {
        if (element.getAttribute('socket')) {
            return GS[element.getAttribute('socket')];
        }
        return GS.envSocket;
    }

    function getData(element, refocusSelector, refocusSelection, bolFirstLoad, bolManualRefresh) {
        GS.triggerEvent(element, 'before_select');
        GS.triggerEvent(element, 'onbefore_select');
        if (element.hasAttribute('onbefore_select')) {
            new Function(element.getAttribute('onbefore_select')).apply(element);
        }

        var strSchema = GS.templateWithQuerystring(element.getAttribute('schema') || '');
        var strObject = GS.templateWithQuerystring(element.getAttribute('object') || '');
        var strReturn = getReturn(element) || '';
        var strWhere = GS.templateWithQuerystring(element.getAttribute('where') || '1=1');
        var strOrd = GS.templateWithQuerystring(element.getAttribute('ord') || '');
        var strLimit = GS.templateWithQuerystring(element.getAttribute('limit') || '');
        var strOffset = GS.templateWithQuerystring(element.getAttribute('offset') || '0');
        var strWhereColumn;

        // add in user where, if any
        if (element.getAttribute('user-where')) {
            strWhere = (
                '(' + element.getAttribute('user-where') + ')' +
                (
                    strWhere
                        ? ' AND ' + strWhere
                        : ''
                )
            );
        }

        // add in a column or qs where, if any

        // if there is a column attribute on element element: combine the where attribute with a where generated by value
        if ((element.getAttribute('column') || element.getAttribute('qs')) && element.value) {
            strWhereColumn = element.getAttribute('child-column') || element.getAttribute('column') || element.getAttribute('qs');

            if (isNaN(element.value)) {
                strWhere = (
                    'CAST(' + strWhereColumn + ' AS ' + GS.database.type.text + ') = ' +
                    'CAST($WhereQUOTE$' + (element.value) + '$WhereQUOTE$ AS ' + GS.database.type.text + ')' +
                    (
                        strWhere !== ''
                            ? ' AND (' + strWhere + ')'
                            : ''
                    )
                );
            } else {
                strWhere = (
                    strWhereColumn + '=' + (element.value) +
                    (
                        strWhere !== ''
                            ? ' AND (' + strWhere + ')'
                            : ''
                    )
                );
            }
        }

        // disabled, hide or not the pageinate buttons
        if (strLimit === '') {
            element.pageLeftButton.setAttribute('hidden', '');
            element.pageRightButton.setAttribute('hidden', '');
        } else if (strOffset === '' || strOffset === '0') {
            element.pageLeftButton.setAttribute('disabled', '');
        }

        GS.addLoader(element, 'Loading...');
        GS.requestSelectFromSocket(
            getSocket(element),
            strSchema,
            strObject,
            strReturn,
            strWhere,
            strOrd,
            strLimit,
            strOffset,
            function (data, error) {
                var refocusElement;

                if (!error) {
                    handleData(element, data, bolFirstLoad, bolManualRefresh);

                    if (data.strMessage === 'TRANSACTION COMPLETED') {
                        GS.removeLoader(element);
                        GS.triggerEvent(element, 'after_select');
                        GS.triggerEvent(element, 'onafter_select');
                        if (element.hasAttribute('onafter_select')) {
                            new Function(element.getAttribute('onafter_select')).apply(element);
                        }
                    }

                    if (data.strMessage === 'TRANSACTION COMPLETED' && refocusSelector) {
                        refocusElement = xtag.query(element, refocusSelector)[0];

                        if (refocusElement) {
                            refocusElement.focus();

                            if (refocusSelection) {
                                GS.setInputSelection(refocusElement, refocusSelection.start, refocusSelection.end);
                            }
                        }
                    }

                } else {
                    GS.removeLoader(element);
                    if (!element.scrollContainer.innerHTML) {
                        element.scrollContainer.innerHTML = '<' + 'center><h2>Couldn\'t Load Data.</h2></' + 'center>';
                    }
                    GS.webSocketErrorDialog(data);
                }
            }
        );
    }


    function getSelectedCopyHTML(element) {
        var strHTMLCopyString;
        var intFromRecord;
        var intToRecord;
        var intFromCell = 9999999;
        var intToCell = 0;
        var i;
        var len;
        var cell_i;
        var cell_len;
        var arrSelected;
        var strCellHTML;
        var arrRecords;
        var arrCells;
        var strHTMLRecordString;

        arrSelected = element.selectedCells;

        // loop through the selected cells and create an html string using the text of the cell
        if (arrSelected.length > 0) {
            intFromRecord = arrSelected[0].parentNode.rowIndex;
            intToRecord = arrSelected[arrSelected.length - 1].parentNode.rowIndex + 1;

            i = 0;
            len = arrSelected.length;
            while (i < len) {
                if (arrSelected[i].cellIndex < intFromCell) {
                    intFromCell = arrSelected[i].cellIndex;
                    intFromCell = (
                        intFromCell === 0
                            ? 1
                            : intFromCell
                    );
                }
                if (arrSelected[i].cellIndex + 1 > intToCell) {
                    intToCell = arrSelected[i].cellIndex + 1;
                }
                i += 1;
            }

            arrRecords = xtag.query(element, 'tr');
            strHTMLCopyString = '';

            i = intFromRecord;
            len = intToRecord;
            while (i < len) {
                arrCells = arrRecords[i].children;
                strHTMLRecordString = '';

                if (!arrRecords[i].classList.contains('insert-record')) {
                    cell_i = intFromCell;
                    cell_len = intToCell;
                    while (cell_i < cell_len) {
                        strCellHTML = '';

                        if (arrCells[cell_i].hasAttribute('selected')) {
                            if (arrCells[cell_i].lastElementChild) {
                                strCellHTML = (
                                    arrCells[cell_i].lastElementChild.textValue ||
                                    arrCells[cell_i].lastElementChild.value ||
                                    (arrCells[cell_i].lastElementChild.checked || '').toString()
                                );
                            } else {
                                strCellHTML = arrCells[cell_i].textContent.trim();
                            }

                            strCellHTML = encodeHTML(strCellHTML).replace(/\n/gim, '<br />');
                        }

                        strCellHTML = '<' + 'td rowspan="1" colspan="1">' + (strCellHTML || '') + '</td>';

                        strHTMLRecordString += (
                            cell_i === intFromCell
                                ? '<' + 'tr>'
                                : ''
                        );
                        strHTMLRecordString += (strCellHTML || '');
                        strHTMLRecordString += (
                            cell_i === (intToCell - 1)
                                ? '<' + '/tr>'
                                : ''
                        );
                        cell_i += 1;
                    }
                }
                if (strHTMLRecordString.trim()) {
                    strHTMLCopyString += strHTMLRecordString;
                }
                i += 1;
            }

            if (strHTMLCopyString) {
                strHTMLCopyString = (
                    '<' + 'style>' +
                        'br { mso-data-placement:same-cell; } ' +
                        'th, td { white-space: pre-wrap; }' +
                    '<' + '/style>' +
                    '<' + 'table border="0" cellpadding="0" cellspacing="0">' + strHTMLCopyString + '<' + '/table>'
                );
            }
        }

        return strHTMLCopyString || '';
    }

    function getSelectedCopyText(element) {
        var strTextCopyString;
        var intFromRecord;
        var intToRecord;
        var intFromCell = 9999999;
        var intToCell = 0;
        var i;
        var len;
        var cell_i;
        var cell_len;
        var arrSelected;
        var strCellText;
        var arrRecords;
        var arrCells;
        var strTextRecordString;

        arrSelected = element.selectedCells;

        // loop through the selected cells and create a tsv string using the text of the cell
        if (arrSelected.length > 0) {
            intFromRecord = arrSelected[0].parentNode.rowIndex;
            intToRecord = arrSelected[arrSelected.length - 1].parentNode.rowIndex + 1;

            i = 0;
            len = arrSelected.length;
            while (i < len) {
                if (arrSelected[i].cellIndex < intFromCell) {
                    intFromCell = arrSelected[i].cellIndex;
                    intFromCell = (
                        intFromCell === 0
                            ? 1
                            : intFromCell
                    );
                }
                if (arrSelected[i].cellIndex + 1 > intToCell) {
                    intToCell = arrSelected[i].cellIndex + 1;
                }
                i += 1;
            }

            arrRecords = xtag.query(element, 'tr');
            strTextCopyString = '';

            i = intFromRecord;
            len = intToRecord;
            while (i < len) {
                arrCells = arrRecords[i].children;
                strTextRecordString = '';

                cell_i = intFromCell;
                cell_len = intToCell;
                while (cell_i < cell_len) {
                    if (!arrCells[cell_i].parentNode.classList.contains('insert-record')) {
                        strCellText = '';

                        if (arrCells[cell_i].hasAttribute('selected')) {
                            if (arrCells[cell_i].lastElementChild) {
                                strCellText = (
                                    arrCells[cell_i].lastElementChild.textValue ||
                                    arrCells[cell_i].lastElementChild.value ||
                                    (arrCells[cell_i].lastElementChild.checked || '').toString()
                                );
                            } else {
                                strCellText = arrCells[cell_i].textContent.trim();
                            }

                            strCellText = strCellText.replace(/\"/gim, '""');
                        }

                        strTextRecordString += (
                            cell_i !== intFromCell
                                ? '\t'
                                : ''
                        );
                        strTextRecordString += (strCellText || '');
                    }
                    cell_i += 1;
                }
                //if (strTextRecordString.trim()) {
                strTextCopyString += strTextRecordString;
                //}
                if (i + 1 !== len) { //&& strTextRecordString.trim()
                    strTextCopyString += '\n';
                }
                i += 1;
            }
        }

        return strTextCopyString || '';
    }

    function handleClipboardData(event, strCopyString, strType) {
        var clipboardData = event.clipboardData || window.clipboardData;
        var strMime;

        if (!clipboardData) {
            return;
        }
        if (!clipboardData.setData) {
            return;
        }

        if (strType === 'text') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = 'Text';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/plain';
            }

        } else if (strType === 'html') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = '';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/html';
            }

        } else {
            throw 'handleClipboardData Error: Type "' + strType + '" not recognized, recognized types are "text" and "html".';
        }

        if (strMime) {
            if (strCopyString && strMime) {
                return clipboardData.setData(strMime, strCopyString) !== false;
            } else {
                return clipboardData.getData(strMime);
            }
        }
    }


    function synchronize(element, bolScroll, bolOnLoad, bolManualRefresh) {
        var arrRecords = xtag.query(element, 'tr');
        var selectCells = [];
        var i;
        var len;
        var arrParts;
        var focusedElement;
        var recordIndex;
        var cellIndex;

        // selection
        if (element.savedSelection) {
            // loop through savedSelection
            i = 0;
            len = element.savedSelection.length;
            while (i < len) {
                // any cell position that is in saved selection gets added to the selectCells
                arrParts = element.savedSelection[i].split(',');
                recordIndex = parseInt(arrParts[0], 10);
                cellIndex = parseInt(arrParts[1], 10);

                if (recordIndex < arrRecords.length && cellIndex < arrRecords[0].children.length) {
                    selectCells.push(arrRecords[recordIndex].children[cellIndex]);
                }
                i += 1;
            }

            // select cells
            element.selectedCells = selectCells;
        }

        // focus
        if (element.lastFocusedControl) {
            element.lastFocusedControl.focus();
            focusedElement = element.lastFocusedControl;
        } else if (!bolOnLoad || bolManualRefresh) {
            focusedElement = element.copyControl;
            element.copyControl.focus();
        }

        // if there was no control to focus and
        //      there is a selection and
        //      bolScroll is true: scroll to selected
        if (!element.lastFocusedControl && element.selectedCells.length > 0 && bolScroll) {
            GS.scrollIntoView(element.selectedCells[0].parentNode);
        }

        // if there was a control and bolScroll is true: scroll to focused record
        if (focusedElement && bolScroll) {
            GS.scrollIntoView(GS.findParentElement(document.activeElement, 'tr'));
        }

        if (focusedElement && element.lastTextSelection) {
            GS.setInputSelection(focusedElement, element.lastTextSelection.start, element.lastTextSelection.end);
        }
    }

    function selectHandler(element, dragOriginCell, dragCurrentCell, dragMode) {
        var arrRecords = xtag.query(element, 'tr');
        var dragOriginRecord = dragOriginCell.parentNode;
        var dragCurrentRecord = dragCurrentCell.parentNode;
        var intStartRecordIndex;
        var intStartCellIndex;
        var intEndRecordIndex;
        var intEndCellIndex;
        var i;
        var len;
        var col_i;
        var col_len;
        var selectionIndex;

        // if origin & currentCell are both the top-left cell and the cell is a heading: select all cells
        if (
            dragOriginRecord.rowIndex === 0 &&
            dragCurrentRecord.rowIndex === 0 &&
            dragOriginCell.cellIndex === 0 &&
            dragCurrentCell.cellIndex === 0
        ) {
            intStartRecordIndex = 0;
            intStartCellIndex = 0;
            intEndRecordIndex = arrRecords.length - 1;
            intEndCellIndex = arrRecords[0].children.length - 1;

        // else if origin is a first th: select the records from origin to currentCell
        } else if (dragOriginCell.cellIndex === 0) {
            intStartRecordIndex = Math.min(dragOriginRecord.rowIndex, dragCurrentRecord.rowIndex);
            intStartCellIndex = 0;
            intEndRecordIndex = Math.max(dragOriginRecord.rowIndex, dragCurrentRecord.rowIndex);
            intEndCellIndex = arrRecords[0].children.length - 1;

        // else if origin is a heading: select the columns from origin to currentCell
        } else if (dragOriginRecord.rowIndex === 0) {
            intStartRecordIndex = 0;
            intStartCellIndex = Math.min(dragOriginCell.cellIndex, dragCurrentCell.cellIndex);
            intEndRecordIndex = arrRecords.length - 1;
            intEndCellIndex = Math.max(dragOriginCell.cellIndex, dragCurrentCell.cellIndex);

        // else select cells from origin to currentCell
        } else {
            intStartRecordIndex = Math.min(dragOriginRecord.rowIndex, dragCurrentRecord.rowIndex);
            intStartCellIndex = Math.min(dragOriginCell.cellIndex, dragCurrentCell.cellIndex);
            intEndRecordIndex = Math.max(dragOriginRecord.rowIndex, dragCurrentRecord.rowIndex);
            intEndCellIndex = Math.max(dragOriginCell.cellIndex, dragCurrentCell.cellIndex);
        }

        element.savedSelection = element.savedSelectionCopy.slice(0);

        if (dragMode === 'select') {
            i = intStartRecordIndex;
            len = intEndRecordIndex + 1;
            while (i < len) {
                col_i = intStartCellIndex;
                col_len = intEndCellIndex + 1;
                while (col_i < col_len) {
                    if (element.savedSelection.indexOf(i + ',' + col_i) === -1) {
                        element.savedSelection.push(i + ',' + col_i);
                    }
                    col_i += 1;
                }
                i += 1;
            }

        } else { // implied if: dragMode === 'deselect'
            i = intStartRecordIndex;
            len = intEndRecordIndex + 1;
            while (i < len) {
                col_i = intStartCellIndex;
                col_len = intEndCellIndex + 1;
                while (col_i < col_len) {
                    selectionIndex = element.savedSelection.indexOf(i + ',' + col_i);

                    if (selectionIndex > -1) {
                        element.savedSelection.splice(selectionIndex, 1);
                    }
                    col_i += 1;
                }
                i += 1;
            }
        }

        synchronize(element);
    }

    function clearRecordColor(element, strClass, bolGreenFade) {
        var arrElements = xtag.query(element, 'tr.' + strClass);
        var i;
        var len;

        if (bolGreenFade) {
            i = 0;
            len = arrElements.length;
            while (i < len) {
                arrElements[i].classList.remove(strClass);
                arrElements[i].classList.add('bg-green-fade');
                i += 1;
            }

            setTimeout(function () {
                i = 0;
                len = arrElements.length;
                while (i < len) {
                    arrElements[i].classList.remove('bg-green-fade');
                    i += 1;
                }
            }, 1000);

        } else {
            i = 0;
            len = arrElements.length;
            while (i < len) {
                arrElements[i].classList.remove(strClass);
                i += 1;
            }
        }
    }

    function removeRecords(element, strClass) {
        var arrElements = xtag.query(element, 'tr.' + strClass);
        var i;
        var len;

        i = 0;
        len = arrElements.length;
        while (i < len) {
            arrElements[i].parentNode.removeChild(arrElements[i]);
            i += 1;
        }
    }

    function insertRecords(element, strColumns, strInsertData, strLocalData, bolDialog) {
        var strSchema = GS.templateWithQuerystring(element.getAttribute('schema'));
        var strObject = GS.templateWithQuerystring(element.getAttribute('object'));
        var templateElement;
        var strSeq;
        var arrSeq;
        var strPk;
        var arrPk;
        var strColumn;
        var arrColumns;
        var i;
        var len;
        var tbodyElement;
        var arrElements;
        var insertRecord;

        arrSeq = (GS.templateWithQuerystring(element.getAttribute('seq') || '')).split(/[\s]*,[\s]*/);
        arrPk = (GS.templateWithQuerystring(element.getAttribute('pk') || '')).split(/[\s]*,[\s]*/);

        arrColumns = strColumns.split('\t');
        i = 0;
        len = arrColumns.length;
        while (i < len) {
            strColumn = GS.decodeFromTabDelimited(arrColumns[i], element.nullString);

            if (arrSeq.indexOf(strColumn) > -1) {
                arrSeq[arrSeq.indexOf(strColumn)] = '';
            }
            i += 1;
        }

        // template local record data
        tbodyElement = document.createElement('tbody');
        tbodyElement.innerHTML = templateRecordsForInsert(element, strColumns + '\n' + strLocalData, 'bg-red');

        // add local records to the table before the insert record
        arrElements = xtag.toArray(tbodyElement.children);
        insertRecord = xtag.query(element, 'tr.insert-record')[0];

        i = 0;
        len = arrElements.length;
        while (i < len) {
            insertRecord.parentNode.insertBefore(arrElements[i], insertRecord);
            i += 1;
        }

        // scroll all the way down
        element.scrollContainer.scrollTop = element.scrollContainer.scrollHeight;

        // get pk and sequence values
        strPk = '';
        i = 0;
        len = arrPk.length;
        while (i < len) {
            strPk += (
                (
                    strPk
                        ? '\t'
                        : ''
                ) +
                GS.encodeForTabDelimited(arrPk[i], element.nullString)
            );
            i += 1;
        }

        strSeq = '';
        i = 0;
        len = arrSeq.length;
        while (i < len) {
            if (arrColumns.indexOf(arrPk[i]) > -1) {
                strSeq += (
                    i === 0
                        ? ''
                        : '\t'
                );
            } else {
                strSeq += (
                    (
                        i === 0
                            ? ''
                            : '\t'
                    ) +
                    GS.encodeForTabDelimited(arrSeq[i], element.nullString)
                );
            }
            i += 1;
        }

        strInsertData = strColumns + '\n' + strInsertData;

        GS.triggerEvent(element, 'before_insert');
        GS.triggerEvent(element, 'onbefore_insert');
        if (element.hasAttribute('onbefore_insert')) {
            new Function(element.getAttribute('onbefore_insert')).apply(element);
        }

        GS.addLoader(element, 'Creating Insert Transaction...');
        GS.requestInsertFromSocket(
            getSocket(element),
            strSchema,
            strObject,
            getReturn(element),
            strPk,
            strSeq,
            strInsertData,
            function (data, error) {
                if (error) {
                    removeRecords(element, 'bg-red');
                    GS.removeLoader(element);
                    GS.webSocketErrorDialog(data);
                }
            },
            function (data, error, ignore, commitFunction, rollbackFunction) { //transactionID
                //var tbodyElement;
                //var arrElements;
                var arrReplaceElements;
                //var i;
                //var len;
                //var templateElement;

                GS.removeLoader(element);

                if (!error) {
                    if (data !== 'TRANSACTION COMPLETED') {
                        data = getReturn(element) + '\n' + data;

                        // replace red records with amber records
                        tbodyElement = document.createElement('tbody');
                        tbodyElement.innerHTML = templateRecordsForInsert(element, data, 'bg-amber');
                        arrElements = xtag.toArray(tbodyElement.children);
                        arrReplaceElements = xtag.query(element, 'tr.bg-red');

                        i = 0;
                        len = arrElements.length;
                        while (i < len) {
                            arrReplaceElements[i].parentNode.replaceChild(arrElements[i], arrReplaceElements[i]);
                            i += 1;
                        }

                    // open confirm message box
                    } else {
                        if (bolDialog) {
                            templateElement = document.createElement('template');
                            templateElement.innerHTML = ml(function () {/*
                                <gs-page>
                                    <gs-header><center><h3>Are you sure...</h3></center></gs-header>
                                    <gs-body padded>
                                        <center>Are you sure you want create {{numberofrecords}} records?</center>
                                    </gs-body>
                                    <gs-footer>
                                        <gs-grid>
                                            <gs-block><gs-button dialogclose>No</gs-button></gs-block>
                                            <gs-block><gs-button id="datasheet-focus-me" dialogclose bg-primary tabindex="0">Yes</gs-button></gs-block>
                                        </gs-grid>
                                    </gs-footer>
                                </gs-page>*/
                            }).replace(/\{\{numberofrecords\}\}/gi, xtag.query(element, '.bg-amber').length);

                            GS.openDialog(
                                templateElement,
                                function () {
                                    document.getElementById('datasheet-focus-me').focus();
                                },
                                function (ignore, strAnswer) { //event
                                    if (strAnswer === 'Yes') {
                                        commitFunction();
                                        GS.addLoader(element, 'Commiting Insert...');
                                    } else {
                                        rollbackFunction();
                                        GS.addLoader(element, 'Rolling Back Insert...');
                                    }
                                }
                            );
                        } else {
                            commitFunction();
                        }
                    }
                } else {
                    removeRecords(element, 'bg-red');
                    rollbackFunction();
                    GS.webSocketErrorDialog(data);
                }
            },
            function (strAnswer, data, error) {
                GS.removeLoader(element);

                if (!error) {
                    if (strAnswer === 'COMMIT') {
                        clearRecordColor(element, 'bg-amber', true);
                        GS.triggerEvent(element, 'after_insert');
                        GS.triggerEvent(element, 'onafter_insert');
                        if (element.hasAttribute('onafter_insert')) {
                            new Function(element.getAttribute('onafter_insert')).apply(element);
                        }
                    } else {
                        removeRecords(element, 'bg-amber');
                    }
                } else {
                    removeRecords(element, 'bg-red');
                    GS.webSocketErrorDialog(data);
                }
            }
        );
    }


    function refreshRecordsAfterUpdate(element, arrRecordsToUpdate, data) {
        var arrColumns;
        var arrRecords;
        var arrValues;
        var i;
        var len;
        var record_i;
        var record_len;
        var col_i;
        var col_len;
        var controlElement;

        // if last character is a \n: remove it
        if (data[data.length - 1] === '\n') {
            data = data.substring(0, data.length - 1);
        }

        // split records
        arrRecords = data.split('\n');

        // seperate first record (for column names)
        arrColumns = arrRecords[0].split('\t');
        arrRecords.splice(0, 1);

        // loop through each record
        len = arrRecordsToUpdate.length;
        record_len = arrRecords.length;
        i = 0;
        record_i = 0;
        while (i < len && record_i < record_len) {
            if (arrRecordsToUpdate[i].classList.contains('bg-red') && arrRecords[record_i]) {
                arrRecordsToUpdate[i].classList.remove('bg-red');
                arrRecordsToUpdate[i].classList.add('bg-amber');

                // build json row
                arrValues = arrRecords[record_i].split('\t');
                col_i = 0;
                col_len = arrValues.length;
                while (col_i < col_len) {
                    arrRecordsToUpdate[i].setAttribute('data-' + arrColumns[col_i], GS.decodeFromTabDelimited(arrValues[col_i], element.nullString));

                    controlElement = xtag.query(arrRecordsToUpdate[i], '[column="' + arrColumns[col_i] + '"]')[0];
                    if (controlElement) {
                        controlElement.value = GS.decodeFromTabDelimited(arrValues[col_i], element.nullString);
                    }
                    col_i += 1;
                }
                record_i += 1;
            }
            i += 1;
        }
    }

    function updateRecords(element, strHashColumns, strUpdateData, arrUpdateRecords, bolDialog) {
        GS.triggerEvent(element, 'before_update');
        GS.triggerEvent(element, 'onbefore_update');
        if (element.hasAttribute('onbefore_update')) {
            new Function(element.getAttribute('onbefore_update')).apply(element);
        }

        var strSchema = GS.templateWithQuerystring(element.getAttribute('schema'));
        var strObject = GS.templateWithQuerystring(element.getAttribute('object'));
        var templateElement;
        var i;
        var len;
        var refreshData;

        i = 0;
        len = arrUpdateRecords.length;
        while (i < len) {
            arrUpdateRecords[i].classList.add('bg-red');
            i += 1;
        }

        element.saveState = 'saving';
        if (element.saveTimeout) {
            clearTimeout(element.saveTimeout);
        }

        element.saveTimeout = setTimeout(function () {
            if (element.saveState !== 'saved' && xtag.query(element, '.saving-warning-parent').length === 0) {
                element.saveState = 'error';
                var parentElement = document.createElement('center');
                parentElement.setAttribute('class', 'saving-warning-parent');

                var warningElement = document.createElement('div');
                warningElement.setAttribute('class', 'saving-warning');

                warningElement.innerHTML = 'YOUR CHANGES ARE NOT SAVED<br />WE HAVEN\'T HEARD BACK FROM THE SERVER<br />EITHER THE SAVING IS SLOW OR THERE\'S AN ERROR';

                parentElement.appendChild(warningElement);
                element.insertBefore(parentElement, element.children[0]);

                // element.appendChild(parentElement);
                /*
                warningElement.addEventListener('click', function () {
                    saveFile(element, strPath, changeStamp, strContent, callbackSuccess, callbackFail);
                });
                */
            }
        }, /*30*/ 5 * 1000);

        // create transaction
        GS.addLoader(element, 'Creating Update Transaction...');
        GS.requestUpdateFromSocket(
            getSocket(element),
            strSchema,
            strObject,
            getReturn(element),
            strHashColumns,
            strUpdateData,
            function (data, error) {//, transactionID
                if (error) {
                    if (element.saveTimeout) {
                        clearTimeout(element.saveTimeout);
                    }
                    element.saveState = 'error';
                    if (xtag.query(element, '.saving-warning-parent').length > 0) {
                        element.removeChild(xtag.query(element, '.saving-warning-parent')[0]);
                    }

                    getData(element);
                    GS.removeLoader(element);
                    GS.webSocketErrorDialog(data);
                }
            },
            function (data, error, ignore, commitFunction, rollbackFunction) { //transactionID
                GS.removeLoader(element);
                if (!error) {
                    if (data !== 'TRANSACTION COMPLETED') {
                        refreshData = data;
                        data = getReturn(element) + '\n' + data;

                        // make the records amber and refresh their data
                        refreshRecordsAfterUpdate(element, arrUpdateRecords, data);

                    // open confirm message box
                    } else {
                        if (element.saveTimeout) {
                            clearTimeout(element.saveTimeout);
                        }
                        element.saveState = 'saved';
                        if (xtag.query(element, '.saving-warning-parent').length > 0) {
                            element.removeChild(xtag.query(element, '.saving-warning-parent')[0]);
                        }

                        if (bolDialog) {
                            templateElement = document.createElement('template');
                            templateElement.innerHTML = ml(function () {/*
                                <gs-page>
                                    <gs-header><center><h3>Are you sure...</h3></center></gs-header>
                                    <gs-body padded>
                                        <center>Are you sure you want to update {{numberofrecords}} records?</center>
                                    </gs-body>
                                    <gs-footer>
                                        <gs-grid>
                                            <gs-block><gs-button dialogclose>No</gs-button></gs-block>
                                            <gs-block><gs-button id="datasheet-focus-me" dialogclose bg-primary tabindex="0">Yes</gs-button></gs-block>
                                        </gs-grid>
                                    </gs-footer>
                                </gs-page>*/
                            }).replace(/\{\{numberofrecords\}\}/gi, xtag.query(element, '.bg-amber').length);

                            GS.openDialog(
                                templateElement,
                                function () {
                                    document.getElementById('datasheet-focus-me').focus();
                                },
                                function (ignore, strAnswer) { //event
                                    if (strAnswer === 'Yes') {
                                        commitFunction();
                                        GS.addLoader(element, 'Commiting Update...');
                                    } else {
                                        rollbackFunction();
                                        GS.addLoader(element, 'Rolling Back Update...');
                                    }
                                }
                            );
                        } else {
                            commitFunction();
                        }
                    }

                } else {
                    if (element.saveTimeout) {
                        clearTimeout(element.saveTimeout);
                    }
                    element.saveState = 'error';
                    if (xtag.query(element, '.saving-warning-parent').length > 0) {
                        element.removeChild(xtag.query(element, '.saving-warning-parent')[0]);
                    }

                    rollbackFunction();
                    getData(element);
                    GS.webSocketErrorDialog(data);
                }
            },
            function (strAnswer, data, error) {
                var arrRecords;
                var arrCells;
                var recordIndex;
                //var i;
                //var len;
                var col_i;
                var col_len;

                GS.removeLoader(element);

                if (!error) {
                    if (strAnswer === 'COMMIT') {
                        if (element.saveTimeout) {
                            clearTimeout(element.saveTimeout);
                        }
                        element.saveState = 'saved';
                        if (xtag.query(element, '.saving-warning-parent').length > 0) {
                            element.removeChild(xtag.query(element, '.saving-warning-parent')[0]);
                        }

                        clearRecordColor(element, 'bg-amber', true);

                        // refresh internal data
                        arrRecords = refreshData.split('\n');

                        i = 0;
                        len = arrUpdateRecords.length;
                        while (i < len) {
                            arrCells = arrRecords[i].split('\t');
                            recordIndex = parseInt(arrUpdateRecords[i].getAttribute('data-index'), 10);

                            col_i = 0;
                            col_len = arrCells.length;
                            while (col_i < col_len) {
                                element.internalData.arrRecords[recordIndex][col_i] = GS.decodeFromTabDelimited(arrCells[col_i], element.nullString);
                                col_i += 1;
                            }
                            i += 1;
                        }
                        GS.triggerEvent(element, 'after_update');
                        GS.triggerEvent(element, 'onafter_update');
                        if (element.hasAttribute('onafter_update')) {
                            new Function(element.getAttribute('onafter_update')).apply(element);
                        }

                    } else {
                        getData(element);
                    }
                } else {
                    if (element.saveTimeout) {
                        clearTimeout(element.saveTimeout);
                    }
                    element.saveState = 'error';
                    if (xtag.query(element, '.saving-warning-parent').length > 0) {
                        element.removeChild(xtag.query(element, '.saving-warning-parent')[0]);
                    }

                    getData(element);
                    GS.webSocketErrorDialog(data);
                }
            }
        );
    }

    function pasteHandler(element, event) {
        var clipboardData = (event.clipboardData || window.clipboardData);
        var templateElement = document.createElement('template');
        var pasteHTML;
        var pastePlain;
        var arrPasteRecords;
        var arrSelectRecords;
        var arrSetColumns;
        var strColumn;
        var strColumns;
        var i;
        var len;
        var col_i;
        var col_len;
        var cell;
        var arrPk;
        var arrLock;
        var strRecord;
        var strInsertData;
        var strLocalData;
        var strLeftPad;
        var strRightPad;
        var strTemp;
        var strRecordToHash;
        var strHashColumns;
        var strRoles;
        var strUpdateData;
        var arrUpdateRecords;
        var arrUpdateColumns;
        var updateRecord;
        var updateRecordData;
        var pasteElement;

        if (window.clipboardData) {
            pastePlain = clipboardData.getData('Text');
        } else {
            pasteHTML = clipboardData.getData('text/html');
            pastePlain = clipboardData.getData('Text');
        }

        // if no html: build HTML using plain
        if (!pasteHTML || (pasteHTML.indexOf('<' + 'table') === -1 && pasteHTML.indexOf('<' + 'tr') === -1)) {
            pasteHTML = valueListToHTML(element, pastePlain, '\t', '\n', false, '"', GS.decodeFromTabDelimited);
        }

        //console.log('HTML:', pasteHTML);
        //console.log('PLAIN:', pastePlain);

        // put HTML into a template element for traversal
        templateElement.innerHTML = pasteHTML;

        arrPasteRecords = xtag.query(xtag.query(templateElement.content, 'table')[0], 'tr');
        arrSelectRecords = element.selectedRecords;

        // if the first record is the header: remove it from the selection
        if (arrSelectRecords[0] && arrSelectRecords[0].parentNode.nodeName === 'THEAD') {
            arrSelectRecords.splice(0, 1);
        }

        if (element.numberOfSelections === 1) {
            arrSetColumns = xtag.query(arrSelectRecords[0], 'td[selected]');

            // if the selection starts on the insert record
            if (arrSelectRecords[0].classList.contains('insert-record')) {
                strColumns = '';
                i = 0;
                len = Math.min(arrSetColumns.length, arrPasteRecords[0].children.length);
                while (i < len) {
                    strColumn = arrSetColumns[i].children[0].getAttribute('column');
                    strColumns += (
                        (
                            strColumns
                                ? '\t'
                                : ''
                        ) +
                        strColumn
                    );
                    i += 1;
                }

                // extract data from paste HTML
                strLeftPad = stringRepeat('\t', arrSetColumns[0].cellIndex - 1);
                strRightPad = stringRepeat('\t', (element.internalData.arrColumnNames.length - ((arrSetColumns[0].cellIndex - 1) + arrSetColumns.length)));

                i = 0;
                len = arrPasteRecords.length;
                strInsertData = '';
                strLocalData = '';
                while (i < len) {
                    col_i = 0;
                    col_len = arrSetColumns.length;
                    strRecord = '';
                    while (col_i < col_len) {
                        cell = arrPasteRecords[i].children[col_i];
                        strRecord += (
                            (
                                strRecord
                                    ? '\t'
                                    : ''
                            ) +
                            GS.encodeForTabDelimited(cell.innerText || cell.textContent, element.nullString)
                        );
                        col_i += 1;
                    }

                    strInsertData += strRecord + '\n';
                    strLocalData += strLeftPad + strRecord + strRightPad + '\n';
                    i += 1;
                }

                insertRecords(element, strColumns, strInsertData, strLocalData, (arrPasteRecords.length > 1));

            // else (if the selection starts on an update record)
            } else {
                // if the last record is the insert: remove it from the selection
                if (arrSelectRecords[arrSelectRecords.length - 1].parentNode.nodeName === 'THEAD') {
                    arrSelectRecords.pop();
                }

                arrPk = (GS.templateWithQuerystring(element.getAttribute('pk') || '')).split(/[\s]*,[\s]*/);
                arrLock = (GS.templateWithQuerystring(element.getAttribute('lock') || '')).split(/[\s]*,[\s]*/);

                // gathering update headers
                strRoles = '';
                strColumns = '';
                i = 0;
                len = arrPk.length;
                while (i < len) {
                    strRoles += (
                        strRoles
                            ? '\t'
                            : ''
                    ) + 'pk';
                    strColumns += (
                        strColumns
                            ? '\t'
                            : ''
                    ) + arrPk[i];
                    i += 1;
                }

                i = 0;
                len = arrLock.length;
                strHashColumns = '';
                while (i < len) {
                    strHashColumns += (
                        strHashColumns
                            ? '\t'
                            : ''
                    ) + arrLock[i];
                    i += 1;
                }
                strRoles += (
                    strRoles
                        ? '\t'
                        : ''
                ) + 'hash';
                strColumns += (
                    strColumns
                        ? '\t'
                        : ''
                ) + 'hash';

                arrUpdateColumns = [];
                i = 0;
                len = Math.min(arrSetColumns.length, arrPasteRecords[0].children.length);
                while (i < len) {
                    pasteElement = xtag.query(arrSetColumns[i], '[column]')[0];//arrSetColumns[i].children[0];

                    if (pasteElement) {
                        strColumn = pasteElement.getAttribute('column');

                        strRoles += (
                            strRoles
                                ? '\t'
                                : ''
                        ) + 'set';
                        strColumns += (
                            strColumns
                                ? '\t'
                                : ''
                        ) + strColumn;

                        arrUpdateColumns.push(strColumn);
                    }
                    i += 1;
                }

                arrUpdateRecords = [];
                strUpdateData = '';
                i = 0;
                len = Math.min(arrSelectRecords.length, arrPasteRecords.length);
                while (i < len) {
                    strRecord = '';
                    updateRecord = arrSelectRecords[i];
                    updateRecordData = element.internalData.arrRecords[parseInt(updateRecord.getAttribute('data-index'), 10)];

                    // get 'pk' columns
                    col_i = 0;
                    col_len = arrPk.length;
                    while (col_i < col_len) {
                        strRecord += (strRecord ? '\t' : '');
                        strRecord += GS.encodeForTabDelimited(updateRecordData[element.internalData.arrColumnNames.indexOf(arrPk[col_i])], element.nullString);
                        col_i += 1;
                    }

                    // get 'hash' columns
                    strRecordToHash = '';
                    col_i = 0;
                    col_len = arrLock.length;
                    while (col_i < col_len) {
                        strRecordToHash += (
                            strRecordToHash
                                ? '\t'
                                : ''
                        );
                        strTemp = updateRecordData[element.internalData.arrColumnNames.indexOf(arrLock[col_i])];
                        strRecordToHash += (
                            strTemp === 'NULL'
                                ? ''
                                : strTemp
                        );
                        col_i += 1;
                    }

                    strRecord += (
                        strRecord
                            ? '\t'
                            : ''
                    ) + GS.utfSafeMD5(strRecordToHash).toString();

                    // get 'set' columns
                    col_i = 0;
                    col_len = arrSetColumns.length;
                    while (col_i < col_len) {
                        pasteElement = xtag.query(arrSetColumns[col_i], '[column]')[0];

                        if (pasteElement) {
                            cell = arrPasteRecords[i].children[col_i];
                            strRecord += (
                                strRecord
                                    ? '\t'
                                    : ''
                            ) + GS.encodeForTabDelimited(cell.innerText || cell.textContent, element.nullString);
                        }
                        col_i += 1;
                    }

                    strUpdateData += strRecord + '\n';
                    arrUpdateRecords.push(arrSelectRecords[i]);
                    i += 1;
                }

                strUpdateData = (strRoles + '\n' + strColumns + '\n' + strUpdateData);
                updateRecords(element, strHashColumns, strUpdateData, arrUpdateRecords, (arrPasteRecords.length > 1));
            }
        }
    }

    function refreshHeight(element) {
        var intHeight;

        if (
            element.hasAttribute('expand-to-content') &&
            element.hudContainer &&
            element.scrollContainer &&
            element.scrollContainer.children[0]
        ) {
            element.style.height = '';

            intHeight = (
                element.hudContainer.scrollHeight +
                element.scrollContainer.children[0].scrollHeight
            );

            element.style.height = intHeight + 'px';
            element.style.height = (intHeight + (element.scrollContainer.scrollHeight - element.scrollContainer.clientHeight)) + 'px';
        }
    }

    function refreshReflow(element) {
        var strReflowAt = GS.templateWithQuerystring(element.getAttribute('reflow-at') || '');
        var intReflowAt;
        var intElementWidth;

        if (strReflowAt) {
            intElementWidth = element.offsetWidth;
            intReflowAt = parseInt(strReflowAt, 10);

            if (intElementWidth < intReflowAt) {
                element.dataContainer.classList.add('grid-reflow');
            } else {
                element.dataContainer.classList.remove('grid-reflow');
            }
        } else {
            element.dataContainer.classList.remove('grid-reflow');
        }
    }


    // clean the slate and set initial html
    function prepareElement(element) {
        var tableTemplateElement;
        var HUDTemplateElement;
        var strHTML;
        var recordElement;
        var insertTemplateElement;
        var arrParts;
        var headerRecordElement;
        var i;
        var len;
        var arrElements;
        var arrHeaderElements;
        var tempTemplateElement;

        // default pk and lock
        if (!element.hasAttribute('pk')) {
            element.setAttribute('pk', 'id');
        }
        if (!element.hasAttribute('lock')) {
            element.setAttribute('lock', 'change_stamp');
        }

        // harvest the templates, error if problems
        tableTemplateElement = xtag.query(element, 'template[for="table"]')[0];
        HUDTemplateElement = xtag.query(element, 'template[for="hud"]')[0];
        insertTemplateElement = xtag.query(element, 'template[for="insert"]')[0];

        if (
            HUDTemplateElement &&
            (
                HUDTemplateElement.innerHTML.indexOf('&gt;') > -1 ||
                HUDTemplateElement.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn('GS-DATASHEET WARNING: &gt; or &lt; detected in HUD template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
        }
        if (
            tableTemplateElement &&
            (
                tableTemplateElement.innerHTML.indexOf('&gt;') > -1 ||
                tableTemplateElement.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn('GS-DATASHEET WARNING: &gt; or &lt; detected in table template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
        }
        if (
            insertTemplateElement &&
            (
                insertTemplateElement.innerHTML.indexOf('&gt;') > -1 ||
                insertTemplateElement.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn('GS-DATASHEET WARNING: &gt; or &lt; detected in insert template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
        }

        if (!tableTemplateElement || tableTemplateElement.nodeName !== 'TEMPLATE') {
            throw 'gs-datasheet error: No table template provided.';
        }

        // V----- cannot do .children on template.content
        //if (tableTemplateElement.content.children[0].nodeName !== 'TABLE') {
        //    throw 'gs-datasheet error: Table is not the first element in the provided table template.';
        //}

        // make header template
        headerRecordElement = xtag.query(tableTemplateElement.content, 'thead tr')[0];
        if (headerRecordElement) {

            arrHeaderElements = xtag.query(headerRecordElement, 'td, th');
            arrElements = xtag.query(tableTemplateElement.content, 'tbody td, tbody th');

            headerRecordElement.setAttribute('role', 'row');

            i = 0;
            len = arrHeaderElements.length;
            while (i < len) {
                arrHeaderElements[i].setAttribute('role', 'columnheader');
                arrHeaderElements[i].setAttribute('scope', 'col');
                i += 1;
            }

            i = 0;
            len = arrHeaderElements.length;
            while (i < len) {
                if (!arrElements[i].hasAttribute('role')) {
                    if (i === 0) {
                        arrElements[i].setAttribute('role', 'rowheader');
                        arrElements[i].setAttribute('scope', 'row');
                    } else {
                        arrElements[i].setAttribute('role', 'gridcell');
                    }
                }
                if (!arrElements[i].hasAttribute('heading')) {
                    arrElements[i].setAttribute('heading', arrHeaderElements[i].textContent);
                }
                i += 1;
            }

            element.headerTemplateRecord = headerRecordElement.outerHTML;
        }

        // make table template
        recordElement = xtag.query(tableTemplateElement.content, 'tbody tr')[0];
        recordElement.setAttribute('role', 'row');
        recordElement.setAttribute('data-index', '{{= i }}');


        var arrCells = xtag.toArray(recordElement.children);

        i = 0;
        len = arrCells.length;
        while (i < len) {
            if (!arrCells[i].hasAttribute('role')) {
                if (i === 0) {
                    arrCells[i].setAttribute('role', 'rowheader');
                    arrCells[i].setAttribute('scope', 'row');
                } else {
                    arrCells[i].setAttribute('role', 'gridcell');
                }
            }
            i += 1;
        }


        strHTML = GS.templateColumnToValue(tableTemplateElement.innerHTML);
        tempTemplateElement = document.createElement('template');
        tempTemplateElement.innerHTML = strHTML;
        recordElement = xtag.query(tempTemplateElement.content, 'tbody tr')[0];



        element.tableTemplate = GS.templateHideSubTemplates(recordElement.outerHTML, true);
        element.tableTemplateRecord = recordElement;

        if (insertTemplateElement && insertTemplateElement.innerHTML) {
            element.insertTemplate = insertTemplateElement.innerHTML;
        }

        // split schema and object
        arrParts = GS.templateWithQuerystring(element.getAttribute('src')).split('.');

        element.setAttribute('schema', arrParts[0]);
        element.setAttribute('object', arrParts[1]);

        // replace element inner html and create element variables
        strHTML = ml(function () {/*
            <div class="root" flex-vertical flex-fill>
                <div class="hud-container">
                    <gs-button icon="refresh" aria-label="Refresh Data." remove-right icononly no-focus title="Refresh Data." class="refresh-button"></gs-button>
                    <gs-button icon="times" aria-label="Delete Selected Records." remove-left icononly no-focus title="Delete Selected Records." class="delete-button"></gs-button>

                    <gs-button icon="plus" aria-label="Create Record." icononly no-focus title="Create Record." class="insert-button"></gs-button>

                    <gs-button icon="backward" aria-label="Go to previous page." remove-right icononly no-focus title="Go to previous page." class="paginate-left"></gs-button>
                    <gs-button icon="forward" aria-label="Go to next page." remove-left icononly no-focus title="Go to next page." class="paginate-right"></gs-button>

                    {{HUDHTML}}

                    <gs-button icon="filter" icononly no-focus title="Edit Filters." class="filter-button" hidden></gs-button>
                    <textarea title="Hidden control" class="hidden-focus-control">Focus Control</textarea>
                </div>
                <div class="data-container" flex>
                    <div class="data-flex-reset">
                        <div class="scroll-container"></div>
                        <div class="header-container"></div>
                        <div class="insert-container"></div>
                    </div>
                </div>
            </div>*/
        });

        if (HUDTemplateElement) {
            strHTML = strHTML.replace(/\{\{HUDHTML\}\}/gi, HUDTemplateElement.innerHTML);
        } else {
            strHTML = strHTML.replace(/\{\{HUDHTML\}\}/gi, '');
        }

        element.innerHTML = strHTML;

        element.root = element.children[0];

        element.hudContainer = element.root.children[0];
        element.dataContainer = element.root.children[1];

        element.dataFlexReset = element.dataContainer.children[0];

        element.scrollContainer = element.dataFlexReset.children[0];
        element.headerContainer = element.dataFlexReset.children[1];
        element.insertContainer = element.dataFlexReset.children[2];

        element.refreshButton = xtag.queryChildren(element.hudContainer, '.refresh-button')[0];
        element.deleteButton = xtag.queryChildren(element.hudContainer, '.delete-button')[0];
        element.insertButton = xtag.queryChildren(element.hudContainer, '.insert-button')[0];
        element.pageLeftButton = xtag.queryChildren(element.hudContainer, '.paginate-left')[0];
        element.pageRightButton = xtag.queryChildren(element.hudContainer, '.paginate-right')[0];
        element.copyControl = xtag.queryChildren(element.hudContainer, '.hidden-focus-control')[0];
        element.filterButton = xtag.queryChildren(element.hudContainer, '.filter-button')[0];

        if (element.hasAttribute('no-huddelete') && element.hasAttribute('no-hudrefresh')) {
            element.hudContainer.removeChild(element.refreshButton);//.setAttribute('hidden', '');
            element.hudContainer.removeChild(element.deleteButton);//.setAttribute('hidden', '');

        } else if (element.hasAttribute('no-huddelete')) {
            element.hudContainer.removeChild(element.deleteButton);//.setAttribute('hidden', '');
            element.refreshButton.removeAttribute('remove-right');

        } else if (element.hasAttribute('no-hudrefresh')) {
            element.hudContainer.removeChild(element.refreshButton);//.setAttribute('hidden', '');
            element.deleteButton.removeAttribute('remove-left');
        }

        if (element.hasAttribute('no-hudpaginate')) {
            element.hudContainer.removeChild(element.pageLeftButton);//.setAttribute('hidden', '');
            element.hudContainer.removeChild(element.pageRightButton);//.setAttribute('hidden', '');
        }

        if (!element.insertTemplate) {
            element.insertButton.setAttribute('hidden', '');
        }
    }

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var arrPopKeys;
        var currentValue;
        var bolRefresh;
        var strOperator;

        if (strQSCol) {
            if (strQSCol.indexOf('=') !== -1) {
                arrAttrParts = strQSCol.split(',');
                i = 0;
                len = arrAttrParts.length;
                while (i < len) {
                    strQSCol = arrAttrParts[i];

                    if (strQSCol.indexOf('!=') !== -1) {
                        strOperator = '!=';
                        arrQSParts = strQSCol.split('!=');
                    } else {
                        strOperator = '=';
                        arrQSParts = strQSCol.split('=');
                    }

                    strQSCol = arrQSParts[0];
                    strQSAttr = arrQSParts[1] || arrQSParts[0];

                    // if the key is not present or we've got the negator: go to the attribute's default or remove it
                    if (strOperator === '!=') {
                        // if the key is not present: add the attribute
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            element.setAttribute(strQSAttr, '');
                        // else: remove the attribute
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    } else {
                        // if the key is not present: go to the attribute's default or remove it
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                            } else {
                                element.removeAttribute(strQSAttr);
                            }
                        // else: set attribute to exact text from QS
                        } else {
                            element.setAttribute(strQSAttr, (
                                GS.qryGetVal(strQS, strQSCol) ||
                                element.internal.defaultAttributes[strQSAttr] ||
                                ''
                            ));
                        }
                    }
                    i += 1;
                }
            } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                strQSValue = GS.qryGetVal(strQS, strQSCol);

                if (element.internal.bolQSFirstRun !== true) {
                    if (strQSValue !== '' || !element.getAttribute('value')) {
                        element.setAttribute('value', strQSValue);
                    }
                } else {
                    element.value = strQSValue;
                }
            }
        }

        // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
        if (element.internal.bolQSFirstRun === true) {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                i = 0;
                len = arrPopKeys.length;
                while (i < len) {
                    currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);

                    if (element.popValues[arrPopKeys[i]] !== currentValue) {
                        bolRefresh = true;
                    }

                    element.popValues[arrPopKeys[i]] = currentValue;
                    i += 1;
                }
            } else if (element.hasAttribute('refresh-on-querystring-change')) {
                bolRefresh = true;
            }

            if (bolRefresh && element.hasAttribute('src')) {
                getData(element);
            } else if (bolRefresh && !element.hasAttribute('src')) {
                console.warn('gs-combo Warning: element has "refresh-on-querystring-values" or "refresh-on-querystring-change", but no "src".', element);
            }
        } else {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                i = 0;
                len = arrPopKeys.length;
                while (i < len) {
                    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                    i += 1;
                }
            }
        }

        element.internal.bolQSFirstRun = true;
    }


    // bind delegating events
    function bindElement(element) {
        // handle "qs" attribute
        if (
            element.getAttribute('qs') ||
            element.getAttribute('refresh-on-querystring-values') ||
            element.hasAttribute('refresh-on-querystring-change')
        ) {
            element.popValues = {};
            pushReplacePopHandler(element);
            window.addEventListener('pushstate', function () {
                pushReplacePopHandler(element);
            });
            window.addEventListener('replacestate', function () {
                pushReplacePopHandler(element);
            });
            window.addEventListener('popstate', function () {
                pushReplacePopHandler(element);
            });
        }

        // on focus control: set oldvalue for update
        element.addEventListener('focus', function (event) {
            if (event.target.hasAttribute('column')) {
                event.target.strOldValue = event.target.value;
            }
        }, true);

        if (!evt.touchDevice) {
            // focus copy control
            element.addEventListener('mousedown', function (event) {
                var parentDatasheet = GS.findParentTag(event.target, 'gs-datasheet');

                // we dont want to override the focus if the currently focused
                //      element is inside the gs-datasheet and is capable of being focus
                if (
                    !GS.isElementFocusable(event.target) ||
                    !parentDatasheet ||
                    parentDatasheet.nodeName !== 'GS-DATASHEET'
                ) {
                    element.copyControl.focus();
                }
            });
        }

        // copy
        element.copyControl.addEventListener('copy', function (event) {
            var strTextCopyString;
            var strHTMLCopyString;

            if (
                document.activeElement.classList.contains('hidden-focus-control') ||
                document.activeElement.selectionStart === document.activeElement.selectionEnd
            ) {

                GS.setInputSelection(
                    document.activeElement,
                    document.activeElement.value.length,
                    document.activeElement.value.length
                );

                strTextCopyString = getSelectedCopyText(element);
                strHTMLCopyString = getSelectedCopyHTML(element);

                if (strTextCopyString && strHTMLCopyString) {
                    if (handleClipboardData(event, strTextCopyString, 'text')) {
                        event.preventDefault(event);
                    }
                    if (handleClipboardData(event, strHTMLCopyString, 'html')) {
                        event.preventDefault(event);
                    }
                }

                GS.setInputSelection(document.activeElement, 0, document.activeElement.value.length);
            }
        });

        // focus
        window.addEventListener('focus', function () {//element
            if (GS.findParentTag(document.activeElement, 'gs-datasheet') === element) {
                element.lastFocusedControl = document.activeElement;
            } else {
                element.lastFocusedControl = null;
            }
        });//, true

        // paste
        element.addEventListener('paste', function (event) {
            if (document.activeElement === element.copyControl) {
                event.preventDefault();
                pasteHandler(element, event);
            }
        });

        // selection
        if (!evt.touchDevice) {
            element.dragAllowed = false;
            element.numberOfSelections = 0;

            // on mousedown (event delagation style)
            element.addEventListener('mousedown', function (event) {
                var target = GS.findParentElement(event.target, 'th,td');
                var originalTarget = event.target;

                // if target is a cell: begin selection
                if (target && (target.nodeName === 'TH' || target.nodeName === 'TD')) {
                    if (GS.findParentElement(target, 'div').classList.contains('header-container')) {
                        target = xtag.query(element.scrollContainer, 'th, td')[target.cellIndex];
                        originalTarget = target;
                    }

                    // if shift key is down and there is currently a selection to connect to
                    element.dragOrigin = target;
                    if (event.shiftKey && xtag.query(element, '[selected]').length > 0) {
                        element.dragOrigin = element.selectionPreviousOrigin;
                    }

                    // if ctrl and cmd are not down: deselect all cells
                    if (!event.metaKey && !event.ctrlKey) {
                        element.selectedCells = [];
                        element.savedSelection = [];
                        element.numberOfSelections = 0;
                    }

                    element.savedSelectionCopy = element.savedSelection.slice(0);
                    element.dragAllowed = true;
                    element.dragCurrentCell = target;
                    element.numberOfSelections += 1;

                    element.dragMode = 'select';
                    if (target.hasAttribute('selected')) {
                        element.dragMode = 'deselect';
                    }

                    // if the original target is a cell or if the dragOrigin isn't the target cell or
                    //      if there are already selected cells: blur focused element and prevent default
                    if (
                        originalTarget.nodeName === 'TH' ||
                        originalTarget.nodeName === 'TD' ||
                        element.dragOrigin !== target ||
                        element.selectedCells.length > 0
                    ) {
                        element.lastFocusedControl = null;
                        element.copyControl.focus();
                        GS.triggerEvent(element.copyControl, 'focus');
                        event.preventDefault();
                    }

                    selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                }
            });

            element.addEventListener('mousemove', function (event) {
                var cellFromTarget;

                // if mouse is down
                if (event.which !== 0) {
                    cellFromTarget = GS.findParentElement(event.target, 'th,td');

                    // if selection is allowed at this point and closestCell is different from element.dragCurrentCell
                    if (cellFromTarget && element.dragAllowed && element.dragCurrentCell !== cellFromTarget) {
                        element.lastFocusedControl = null;
                        element.copyControl.focus();
                        GS.triggerEvent(element.copyControl, 'focus');

                        element.dragCurrentCell = cellFromTarget;
                        selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                        event.preventDefault();
                    }
                } else {
                    element.dragAllowed = false;
                    element.selectionPreviousOrigin = element.dragOrigin;
                }
            });

            element.addEventListener('mouseup', function () {
                if (element.dragAllowed) {
                    if (document.activeElement === element || document.activeElement === document.body) {
                        element.copyControl.focus();
                        GS.triggerEvent(element.copyControl, 'focus');
                    }
                    element.dragAllowed = false;
                    element.selectionPreviousOrigin = element.dragOrigin;
                }
            });
        } else {
            element.dragAllowed = false;
            element.numberOfSelections = 0;

            // on touchdown (event delagation style)
            element.addEventListener('click', function (event) {
                var target = GS.findParentElement(event.target, 'th,td');
                var originalTarget = event.target;

                // if target is a cell: begin selection
                if (target && (target.nodeName === 'TH' || target.nodeName === 'TD')) {
                    if (GS.findParentElement(target, 'div').classList.contains('header-container')) {
                        target = xtag.query(element.scrollContainer, 'th, td')[target.cellIndex];
                        originalTarget = target;
                    }

                    // if shift key is down and there is currently a selection to connect to
                    element.dragOrigin = target;
                    if (event.shiftKey && xtag.query(element, '[selected]').length > 0) {
                        element.dragOrigin = element.selectionPreviousOrigin;
                    }

                    // deselect all cells
                    element.selectedCells = [];
                    element.savedSelection = [];
                    element.numberOfSelections = 0;

                    element.savedSelectionCopy = element.savedSelection.slice(0);
                    element.dragAllowed = true;
                    element.dragCurrentCell = target;
                    element.numberOfSelections += 1;

                    element.dragMode = 'select';
                    if (target.hasAttribute('selected')) {
                        element.dragMode = 'deselect';
                    }

                    // if the original target is a cell or if the dragOrigin isn't the target cell or
                    //      if there are already selected cells: blur focused element and prevent default
                    if (
                        originalTarget.nodeName === 'TH' ||
                        originalTarget.nodeName === 'TD' ||
                        element.dragOrigin !== target ||
                        element.selectedCells.length > 0
                    ) {
                        element.lastFocusedControl = null;
                        element.copyControl.focus();
                        GS.triggerEvent(element.copyControl, 'focus');
                        event.preventDefault();
                    }

                    selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                }
            });
        }

        if (!element.hasAttribute('no-filter')) {
            // filter edit button
            element.filterButton.addEventListener('click', function () {
                var templateElement = document.createElement('template');

                templateElement.setAttribute('data-max-width', '300px');
                templateElement.setAttribute('data-overlay-close', 'true');

                templateElement.innerHTML = ml(function () {/*
                    <gs-body padded>
                        <label for="memo-datagrid-filters">Filters:</label>
                        <gs-memo id="memo-datagrid-filters" rows="6" no-resize-handle></gs-memo>
                        <br />
                        <gs-grid>
                            <gs-block><gs-button dialogclose remove-right>Cancel</gs-button></gs-block>
                            <gs-block><gs-button dialogclose remove-all style="border-left: 0 none;">Clear Filters</gs-button></gs-block>
                            <gs-block><gs-button dialogclose remove-left style="border-left: 0 none;">Update Filters</gs-button></gs-block>
                        </gs-grid>
                    </gs-body>*/
                });

                GS.openDialogToElement(
                    element.filterButton,
                    templateElement,
                    'down',
                    function () {
                        document.getElementById('memo-datagrid-filters').value = element.getAttribute('user-where').replace(/\sAND\s/gi, '\nAND ');
                    },
                    function (ignore, strAnswer) { //event
                        var strValue = document.getElementById('memo-datagrid-filters').value;

                        if (strAnswer === 'Clear Filters' || (strAnswer === 'Update Filters' && strValue.trim() === '')) {
                            element.removeAttribute('user-where');
                            element.filterButton.setAttribute('hidden', '');
                            getData(element);

                        } else if (strAnswer === 'Update Filters') {
                            element.setAttribute('user-where', strValue);
                            getData(element);
                        }
                    }
                );
            });

            // filter popup
            var cellFloatingButtonFunction = function (targetCell) {
                var jsnElementPosition = GS.getElementPositionData(targetCell);
                var strHTML;

                // targetCell is a th or if targetCell doesn't have a child with the "column" attribute:
                //      remove the floating button if it exists
                if (targetCell.nodeName === 'TH' || xtag.query(targetCell, '[column]').length === 0) {
                    if (element.cellFloatingButtonContainer && element.cellFloatingButtonContainer.parentNode) {
                        element.cellFloatingButtonContainer.parentNode.removeChild(element.cellFloatingButtonContainer);
                        element.cellFloatingButtonContainer = null;
                    }

                // else: add the floating button
                } else {
                    // if no floating button exists for this grid: create/append/bind one
                    if (!element.cellFloatingButtonContainer || !element.cellFloatingButtonContainer.parentNode) {
                        element.cellFloatingButtonContainer = document.createElement('div');
                        element.cellFloatingButtonContainer.classList.add('floating-button-container');

                        element.cellFloatingButtonContainer.innerHTML = (
                            '<gs-button icononly icon="filter" inline bg-primary no-focus></gs-button>'
                        );

                        //element.scrollContainer.appendChild(element.cellFloatingButtonContainer);
                        element.dataFlexReset.appendChild(element.cellFloatingButtonContainer);

                        element.cellFloatingButtonContainer.addEventListener(evt.mousedown, function () {
                            element.cellFloatingButtonContainer.targetControl.bolSubstring = (
                                document.activeElement === element.cellFloatingButtonContainer.targetControl
                            );
                        });

                        element.cellFloatingButtonContainer.addEventListener('click', function () {
                            var targetControl = element.cellFloatingButtonContainer.targetControl;
                            var jsnSelection;
                            var strMatchText = targetControl.value || targetControl.textContent;
                            var templateElement = document.createElement('template');

                            //console.log(targetControl, targetControl.value, strMatchText);

                            if (targetControl.nodeName === 'INPUT' || targetControl.nodeName === 'TEXTAREA') {
                                jsnSelection = GS.getInputSelection(element.cellFloatingButtonContainer.targetControl);
                            }

                            if (targetControl.bolSubstring && jsnSelection && jsnSelection.start !== jsnSelection.end) {
                                strMatchText = strMatchText.substring(jsnSelection.start, jsnSelection.end);
                            }

                            templateElement.setAttribute('data-max-width', '250px');
                            templateElement.setAttribute('data-overlay-close', 'true');

                            strHTML = '<gs-body padded>';

                            if (evt.touchDevice) {
                                strHTML += '<gs-button class="text-left" dialogclose>Select Range</gs-button>';
                                strHTML += '<gs-button class="text-left" dialogclose>Select Records</gs-button><hr />';
                            }

                            strHTML += (
                                '<gs-button class="text-left" dialogclose>Equals "<u>{{VALUE}}</u>"</gs-button>' +
                                '<gs-button class="text-left" dialogclose>Doesn\'t Equal "<u>{{VALUE}}</u>"</gs-button>' +
                                '<gs-button class="text-left" dialogclose>Contains "<u>{{VALUE}}</u>"</gs-button>' +
                                '<gs-button class="text-left" dialogclose>Doesn\'t Contain "<u>{{VALUE}}</u>"</gs-button>' +
                                '<gs-button class="text-left" dialogclose>Starts With "<u>{{VALUE}}</u>"</gs-button>' +
                                '<gs-button class="text-left" dialogclose>Ends With "<u>{{VALUE}}</u>"</gs-button>'
                            );

                            strHTML += '</gs-body>';

                            strHTML = strHTML.replace(/\{\{VALUE\}\}/gim, encodeHTML(strMatchText));

                            templateElement.innerHTML = strHTML;

                            GS.openDialogToElement(element.cellFloatingButtonContainer, templateElement, 'left', '', function (ignore, strAnswer) { //event
                                var clickFunction;
                                var addUserWhere = function (strNewWhere) {
                                    var strWhere = element.getAttribute('user-where');

                                    strWhere = (
                                        strWhere
                                            ? (strWhere + ' AND ' + strNewWhere)
                                            : strNewWhere
                                    );

                                    element.setAttribute('user-where', strWhere);
                                    element.filterButton.removeAttribute('hidden');
                                    getData(element);
                                };
                                var control = element.cellFloatingButtonContainer.targetCell.children[0];

                                if (strAnswer === 'Select Range' || strAnswer === 'Select Records') {
                                    if (strAnswer === 'Select Records') {
                                        element.dragOrigin = element.cellFloatingButtonContainer.targetCell.parentNode.children[0];
                                    } else if (strAnswer === 'Select Range') {
                                        element.dragOrigin = element.cellFloatingButtonContainer.targetCell;
                                    }

                                    element.selectedCells = [];
                                    clickFunction = function (event) {
                                        var target;

                                        if (strAnswer === 'Select Records') {
                                            target = GS.findParentElement(event.target, 'tr');
                                            element.dragCurrentCell = target.children[0];

                                        } else if (strAnswer === 'Select Range') {
                                            target = GS.findParentElement(event.target, 'td,th');
                                            element.dragCurrentCell = target;
                                        }

                                        if (target) {
                                            element.selectionPreviousOrigin = element.dragOrigin;
                                            element.savedSelection = [];
                                            element.savedSelectionCopy = [];
                                            element.numberOfSelections = 1;
                                            element.dragMode = 'select';

                                            selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);

                                            document.activeElement.blur();
                                            event.preventDefault();
                                            element.removeEventListener('click', clickFunction, true);
                                        }
                                    };

                                    element.addEventListener('click', clickFunction, true);

                                } else if (strAnswer.indexOf('Equals') === 0) {
                                    addUserWhere(
                                        'CAST(' + control.getAttribute('column') + ' AS ' + GS.database.type.text + ') ' +
                                        '= $$' + strMatchText + '$$'
                                    );

                                } else if (strAnswer.indexOf('Doesn\'t Equal') === 0) {
                                    addUserWhere(
                                        'CAST(' + control.getAttribute('column') + ' AS ' + GS.database.type.text + ') ' +
                                        '!= $$' + strMatchText + '$$'
                                    );

                                } else if (strAnswer.indexOf('Contains') === 0) {
                                    addUserWhere(
                                        'CAST(' + control.getAttribute('column') + ' AS ' + GS.database.type.text + ') ' +
                                        'LIKE $$%' + strMatchText + '%$$'
                                    );

                                } else if (strAnswer.indexOf('Doesn\'t Contain') === 0) {
                                    addUserWhere(
                                        'CAST(' + control.getAttribute('column') + ' AS ' + GS.database.type.text + ') ' +
                                        'NOT LIKE $$%' + strMatchText + '%$$'
                                    );

                                } else if (strAnswer.indexOf('Starts With') === 0) {
                                    addUserWhere(
                                        'CAST(' + control.getAttribute('column') + ' AS ' + GS.database.type.text + ') ' +
                                        'LIKE $$' + strMatchText + '%$$'
                                    );

                                } else if (strAnswer.indexOf('Ends With') === 0) {
                                    addUserWhere(
                                        'CAST(' + control.getAttribute('column') + ' AS ' + GS.database.type.text + ') ' +
                                        'LIKE $$%' + strMatchText + '$$'
                                    );
                                }
                            });
                        });
                    }

                    // hover center next to the cell
                    element.cellFloatingButtonContainer.targetCell = targetCell;
                    element.cellFloatingButtonContainer.targetControl = xtag.query(targetCell, '[column]')[0];
                    element.cellFloatingButtonContainer.children[0].removeAttribute('remove-top-left');
                    element.cellFloatingButtonContainer.children[0].removeAttribute('remove-top-right');
                    element.cellFloatingButtonContainer.children[0].removeAttribute('remove-bottom-left');
                    element.cellFloatingButtonContainer.children[0].removeAttribute('remove-bottom-right');

                    // top left
                    if (
                        jsnElementPosition.intRoomAbove > element.cellFloatingButtonContainer.clientHeight &&
                        jsnElementPosition.intRoomLeft > element.cellFloatingButtonContainer.clientWidth
                    ) {
                        element.cellFloatingButtonContainer.setAttribute(
                            'style',
                            (
                                'left: ' + ((jsnElementPosition.intElementLeft - element.cellFloatingButtonContainer.clientWidth) + 4) + 'px;' +
                                'top: ' + ((jsnElementPosition.intElementTop - element.cellFloatingButtonContainer.clientHeight) + 4) + 'px;'
                            )
                        );

                        element.cellFloatingButtonContainer.children[0].setAttribute('remove-bottom-right', '');

                    // top right
                    } else if (
                        jsnElementPosition.intRoomAbove > element.cellFloatingButtonContainer.clientHeight &&
                        jsnElementPosition.intRoomRight > element.cellFloatingButtonContainer.clientWidth
                    ) {
                        element.cellFloatingButtonContainer.setAttribute(
                            'style',
                            (
                                'left: ' + ((jsnElementPosition.intElementLeft + jsnElementPosition.intElementWidth) - 4) + 'px;' +
                                'top: ' + ((jsnElementPosition.intElementTop - element.cellFloatingButtonContainer.clientHeight) + 4) + 'px;'
                            )
                        );

                        element.cellFloatingButtonContainer.children[0].setAttribute('remove-bottom-left', '');

                    // bottom left
                    } else if (
                        jsnElementPosition.intRoomBelow > element.cellFloatingButtonContainer.clientHeight &&
                        jsnElementPosition.intRoomLeft > element.cellFloatingButtonContainer.clientWidth
                    ) {
                        element.cellFloatingButtonContainer.setAttribute(
                            'style',
                            (
                                'left: ' + ((jsnElementPosition.intElementLeft - element.cellFloatingButtonContainer.clientWidth) + 4) + 'px;' +
                                'top: ' + ((jsnElementPosition.intElementTop + jsnElementPosition.intElementHeight) - 4) + 'px;'
                            )
                        );

                        element.cellFloatingButtonContainer.children[0].setAttribute('remove-top-right', '');

                    // bottom right
                    } else if (
                        jsnElementPosition.intRoomBelow > element.cellFloatingButtonContainer.clientHeight &&
                        jsnElementPosition.intRoomRight > element.cellFloatingButtonContainer.clientWidth
                    ) {
                        element.cellFloatingButtonContainer.setAttribute(
                            'style',
                            (
                                'left: ' + ((jsnElementPosition.intElementLeft + jsnElementPosition.intElementWidth) - 4) + 'px;' +
                                'top: ' + ((jsnElementPosition.intElementTop + jsnElementPosition.intElementHeight) - 4) + 'px;'
                            )
                        );

                        element.cellFloatingButtonContainer.children[0].setAttribute('remove-top-left', '');
                    }
                }
            };

            element.addEventListener('after_selection', function () {
                var arrSelected = element.selectedCells;

                if (arrSelected.length === 1) {
                    cellFloatingButtonFunction(element.dragCurrentCell || arrSelected[arrSelected.length - 1]);

                } else if (element.cellFloatingButtonContainer && element.cellFloatingButtonContainer.parentNode) {
                    element.cellFloatingButtonContainer.parentNode.removeChild(element.cellFloatingButtonContainer);
                    element.cellFloatingButtonContainer = null;
                }
            });

            element.addEventListener('focus', function (event) {
                if (event.target.hasAttribute('column')) {
                    cellFloatingButtonFunction(event.target.parentNode);
                }
            }, true);// this true is for making it so that the focus event (which doesn't bubble) gets captured

            // on mousewheel: remove floating button (scroll version of this is in the handleData function)
            element.addEventListener('mousewheel', function () {
                if (element.cellFloatingButtonContainer && element.cellFloatingButtonContainer.parentNode) {
                    element.cellFloatingButtonContainer.parentNode.removeChild(element.cellFloatingButtonContainer);
                    element.cellFloatingButtonContainer = null;
                }
            });
            element.scrollContainer.addEventListener('scroll', function () {
                if (element.cellFloatingButtonContainer && element.cellFloatingButtonContainer.parentNode) {
                    element.cellFloatingButtonContainer.parentNode.removeChild(element.cellFloatingButtonContainer);
                    element.cellFloatingButtonContainer = null;
                }
            });
        }

        // ################################################################
        // #################### TOUCH DEVICE CLIPBOARD ####################
        // ################################################################

        if (evt.touchDevice) {
            var rangeFloatingButtonFunction = function (arrSelected) {
                var i;
                var len;
                var jsnElementPosition;
                var intTopBoundry;
                var intBottomBoundry;
                var intLeftBoundry;
                var intRightBoundry;

                // if no floating button exists for this grid: create/append/bind one
                if (!element.rangeFloatingButtonContainer || !element.rangeFloatingButtonContainer.parentNode) {
                    element.rangeFloatingButtonContainer = document.createElement('div');
                    element.rangeFloatingButtonContainer.classList.add('floating-button-container');

                    element.rangeFloatingButtonContainer.innerHTML = (
                        '<gs-button icononly icon="clipboard" inline bg-primary no-focus></gs-button>' +
                        '<div contenteditable="true" style=" position: fixed;  border: 0 none;' +
                                                            'margin: 0;        padding: 0;' +
                                                            'z-index: -5000;   opacity: 0.00000001;' +
                                                            '-webkit-appearance: none;' +
                                                            '-moz-appearance: none;"></div>'
                    );

                    element.scrollContainer.appendChild(element.rangeFloatingButtonContainer);

                    element.rangeFloatingButtonContainer.control = element.rangeFloatingButtonContainer.children[1];

                    element.rangeFloatingButtonContainer.addEventListener('click', function () {
                        element.rangeFloatingButtonContainer.control.innerHTML = getSelectedCopyHTML(element) || 'Nothing To Copy';
                        element.rangeFloatingButtonContainer.control.focus();
                        document.execCommand('selectAll', false, null);
                    });

                    element.rangeFloatingButtonContainer.control.addEventListener('cut', function () {
                        GS.triggerEvent(element, 'before_update');
                        GS.triggerEvent(element, 'onbefore_update');
                        if (element.hasAttribute('onbefore_update')) {
                            new Function(element.getAttribute('onbefore_update')).apply(element);
                        }

                        var strSchema = GS.templateWithQuerystring(element.getAttribute('schema'));
                        var strObject = GS.templateWithQuerystring(element.getAttribute('object'));
                        var strUpdateData = '';
                        var strRecord;
                        var arrSetColumnElements;
                        var strHashColumns;
                        var arrSetColumns = [];
                        var arrPk;
                        var arrLock;
                        var arrRecords;
                        //var i;
                        //var len;
                        var col_i;
                        var col_len;
                        var arrRecordsToRefresh = [];
                        var strColumns = '';
                        var strRoles = '';
                        var strColumn;
                        var strRecordToHash;
                        var strTemp;

                        // gathering variables for select traversal
                        arrRecords = element.selectedRecords;

                        // if the first record is the header: remove it
                        if (arrRecords[0] && arrRecords[0].parentNode.nodeName === 'THEAD') {
                            arrRecords[0].splice(0, 1);
                        }

                        arrSetColumnElements = xtag.query(arrRecords[0], '[selected]:not(th)');

                        arrPk = (element.getAttribute('pk') || '').split(/[\s]*,[\s]*/);
                        arrLock = (element.getAttribute('lock') || '').split(/[\s]*,[\s]*/);

                        // gathering update headers
                        i = 0;
                        len = arrPk.length;
                        while (i < len) {
                            strRoles += (
                                strRoles
                                    ? '\t'
                                    : ''
                            ) + 'pk';
                            strColumns += (
                                strColumns
                                    ? '\t'
                                    : ''
                            ) + arrPk[i];
                            i += 1;
                        }

                        strHashColumns = '';
                        i = 0;
                        len = arrLock.length;
                        while (i < len) {
                            strHashColumns += (
                                strHashColumns
                                    ? '\t'
                                    : ''
                            ) + arrLock[i];
                            i += 1;
                        }
                        strRoles += (
                            strRoles
                                ? '\t'
                                : ''
                        ) + 'hash';
                        strColumns += (
                            strColumns
                                ? '\t'
                                : ''
                        ) + 'hash';

                        i = 0;
                        len = arrSetColumnElements.length;
                        while (i < len) {
                            strColumn = arrSetColumnElements[i].children[0].getAttribute('column');

                            strRoles += (
                                strRoles
                                    ? '\t'
                                    : ''
                            ) + 'set';
                            strColumns += (
                                strColumns
                                    ? '\t'
                                    : ''
                            ) + strColumn;
                            arrSetColumns.push(strColumn);
                            i += 1;
                        }

                        i = 0;
                        len = arrRecords.length;
                        while (i < len) {
                            strRecord = '';

                            // get 'pk' columns
                            col_i = 0;
                            col_len = arrPk.length;
                            while (col_i < col_len) {
                                strRecord += (
                                    strRecord
                                        ? '\t'
                                        : ''
                                );
                                strRecord += GS.encodeForTabDelimited(arrRecords[i].getAttribute('data-' + arrPk[col_i]), element.nullString);
                                col_i += 1;
                            }

                            // get 'hash' columns
                            strRecordToHash = '';
                            col_i = 0;
                            col_len = arrLock.length;
                            while (col_i < col_len) {
                                strRecordToHash += (
                                    strRecordToHash
                                        ? '\t'
                                        : ''
                                );
                                strTemp = arrRecords[i].getAttribute('data-' + arrLock[col_i]);
                                strRecordToHash += (
                                    strTemp === 'NULL'
                                        ? ''
                                        : strTemp
                                );
                                col_i += 1;
                            }

                            strRecord += (
                                strRecord
                                    ? '\t'
                                    : ''
                            ) + GS.utfSafeMD5(strRecordToHash).toString();

                            // get 'set' columns
                            col_i = 0;
                            col_len = arrSetColumns.length;
                            while (col_i < col_len) {
                                strRecord += (
                                    strRecord
                                        ? '\t'
                                        : ''
                                );
                                col_i += 1;
                            }

                            strRecord += '\n';
                            strUpdateData += strRecord;
                            arrRecordsToRefresh.push(arrRecords[i]);

                            // make the records red
                            arrRecords[i].classList.add('bg-red');
                            i += 1;
                        }

                        strUpdateData = (strRoles + '\n' + strColumns + '\n' + strUpdateData);

                        // create update transaction
                        GS.addLoader(element, 'Creating Update Transaction...');
                        GS.requestUpdateFromSocket(
                            getSocket(element),
                            strSchema,
                            strObject,
                            getReturn(element),
                            strHashColumns,
                            strUpdateData,
                            function (data, error) { //transactionID
                                if (error) {
                                    getData(element);
                                    GS.removeLoader(element);
                                    GS.webSocketErrorDialog(data);
                                }
                            },
                            function (data, error, ignore, commitFunction, rollbackFunction) { //transactionID
                                GS.removeLoader(element);

                                if (!error) {
                                    if (data !== 'TRANSACTION COMPLETED') {
                                        data = getReturn(element) + '\n' + data;

                                        // make the records amber and refresh their data
                                        refreshRecordsAfterUpdate(element, arrRecordsToRefresh, data);////
                                    } else {
                                        commitFunction();
                                    }

                                } else {
                                    rollbackFunction();
                                    getData(element);
                                    GS.webSocketErrorDialog(data);
                                }
                            },
                            function (strAnswer, data, error) {
                                GS.removeLoader(element);

                                if (!error) {
                                    if (strAnswer === 'COMMIT') {
                                        clearRecordColor(element, 'bg-amber', true);
                                        GS.triggerEvent(element, 'after_update');
                                        GS.triggerEvent(element, 'onafter_update');
                                        if (element.hasAttribute('onafter_update')) {
                                            new Function(element.getAttribute('onafter_update')).apply(element);
                                        }

                                    } else {
                                        getData(element);
                                    }
                                } else {
                                    getData(element);
                                    GS.webSocketErrorDialog(data);
                                }
                            }
                        );
                    });
                    element.rangeFloatingButtonContainer.control.addEventListener('copy', function () {
                        setTimeout(function () {
                            element.rangeFloatingButtonContainer.control.blur();
                            element.rangeFloatingButtonContainer.control.innerHTML = '';
                        }, 1);
                    });
                    element.rangeFloatingButtonContainer.control.addEventListener('paste', function (event) {
                        pasteHandler(element, event);
                        setTimeout(function () {
                            element.rangeFloatingButtonContainer.control.blur();
                            element.rangeFloatingButtonContainer.control.innerHTML = '';
                        }, 1);
                    });
                }

                // position button
                intTopBoundry = 99999999;
                intBottomBoundry = 99999999;
                intLeftBoundry = 99999999;
                intRightBoundry = 99999999;

                i = 0;
                len = arrSelected.length;
                while (i < len) {
                    jsnElementPosition = GS.getElementPositionData(arrSelected[i]);

                    if (jsnElementPosition.intElementTop < intTopBoundry) {
                        intTopBoundry = jsnElementPosition.intElementTop;
                    }
                    if (jsnElementPosition.intElementBottom < intBottomBoundry) {
                        intBottomBoundry = jsnElementPosition.intElementBottom;
                    }
                    if (jsnElementPosition.intElementLeft < intLeftBoundry) {
                        intLeftBoundry = jsnElementPosition.intElementLeft;
                    }
                    if (jsnElementPosition.intElementRight < intRightBoundry) {
                        intRightBoundry = jsnElementPosition.intElementRight;
                    }
                    i += 1;
                }

                // top right
                if (intTopBoundry >= 0 && intRightBoundry >= 0) {
                    element.rangeFloatingButtonContainer.style.top = (intTopBoundry + 4) + 'px';
                    element.rangeFloatingButtonContainer.style.right = (intRightBoundry + 4) + 'px';

                // top left
                } else if (intTopBoundry >= 0 && intLeftBoundry >= 0) {
                    element.rangeFloatingButtonContainer.style.top = (intTopBoundry + 4) + 'px';
                    element.rangeFloatingButtonContainer.style.left = (intLeftBoundry + 4) + 'px';

                // bottom right
                } else if (intBottomBoundry >= 0 && intRightBoundry >= 0) {
                    element.rangeFloatingButtonContainer.style.bottom = (intBottomBoundry + 4) + 'px';
                    element.rangeFloatingButtonContainer.style.right = (intRightBoundry + 4) + 'px';

                // bottom left
                } else if (intBottomBoundry >= 0 && intLeftBoundry >= 0) {
                    element.rangeFloatingButtonContainer.style.bottom = (intBottomBoundry + 4) + 'px';
                    element.rangeFloatingButtonContainer.style.left = (intLeftBoundry + 4) + 'px';
                }
            };

            element.addEventListener('after_selection', function () {
                var arrSelected = element.selectedCells;

                if (arrSelected.length > 0 && element.numberOfSelections === 1) {
                    rangeFloatingButtonFunction(arrSelected);

                } else if (element.rangeFloatingButtonContainer && element.rangeFloatingButtonContainer.parentNode) {
                    element.rangeFloatingButtonContainer.parentNode.removeChild(element.rangeFloatingButtonContainer);
                    element.rangeFloatingButtonContainer = null;
                }
            });

            element.scrollContainer.addEventListener('scroll', function () {
                if (element.rangeFloatingButtonContainer && element.rangeFloatingButtonContainer.parentNode) {
                    element.rangeFloatingButtonContainer.parentNode.removeChild(element.rangeFloatingButtonContainer);
                    element.rangeFloatingButtonContainer = null;
                }
            });
        }

        // ######################################################################################################
        // ######################################################################################################
        // ######################################################################################################

        // delete, refresh, page left and page right buttons
        element.addEventListener('click', function (event) {
            var target = event.target;
            var intOffset;
            var intLimit;

            // delete button
            if (target.classList.contains('delete-button')) {
                deleteSelection(element);

            // refresh button
            } else if (target.classList.contains('refresh-button')) {
                getData(element, undefined, undefined, undefined, true);

            // refresh button
            } else if (target.classList.contains('insert-button')) {
                insertDialog(element);

            } else if (target.classList.contains('paginate-left') || target.classList.contains('paginate-right')) {
                intLimit = parseInt(element.getAttribute('limit'), 10);
                intOffset = parseInt(element.getAttribute('offset') || '0', 10);

                if (target.classList.contains('paginate-left')) {
                    intOffset -= intLimit;
                } else {
                    intOffset += intLimit;
                }

                if (intOffset <= 0) {
                    intOffset = 0;
                    element.pageLeftButton.setAttribute('disabled', '');
                } else {
                    element.pageLeftButton.removeAttribute('disabled');
                }

                element.setAttribute('offset', intOffset);
                element.paginated = true;
                getData(element);
            }
        });

        if (!evt.touchDevice) {
            element.addEventListener('keydown', function (event) {
                var intKeyCode = (event.which || event.keyCode);

                if (!element.hasAttribute('no-huddelete')) {
                    if (event.target === element.copyControl && (intKeyCode === KEY_BACKSPACE || intKeyCode === KEY_DELETE)) {
                        deleteSelection(element);
                        event.preventDefault();
                    }
                }
            });
        }

        // manuel update
        var updateFromEntry = function (target) {
            var updateRecord = GS.findParentElement(target, 'tr');
            var updateRecordData = element.internalData.arrRecords[parseInt(updateRecord.getAttribute('data-index'), 10)];
            var arrPk;
            var arrLock;
            var i;
            var len;
            var col_i;
            var col_len;
            var strRoles;
            var strColumns;
            var strHashColumns;
            var strRecordToHash;
            var strTemp;
            var strRecord;
            var strUpdateData;

            arrPk = (element.getAttribute('pk') || '').split(/[\s]*,[\s]*/);
            arrLock = (element.getAttribute('lock') || '').split(/[\s]*,[\s]*/);

            // gathering update headers
            i = 0;
            len = arrPk.length;
            strRoles = '';
            strColumns = '';
            while (i < len) {
                strRoles += (
                    strRoles
                        ? '\t'
                        : ''
                ) + 'pk';
                strColumns += (
                    strColumns
                        ? '\t'
                        : ''
                ) + arrPk[i];
                i += 1;
            }

            i = 0;
            len = arrLock.length;
            strHashColumns = '';
            while (i < len) {
                strHashColumns += (
                    strHashColumns
                        ? '\t'
                        : ''
                ) + arrLock[i];
                i += 1;
            }
            strRoles += (
                strRoles
                    ? '\t'
                    : ''
            ) + 'hash';
            strColumns += (
                strColumns
                    ? '\t'
                    : ''
            ) + 'hash';

            strRoles += (
                strRoles
                    ? '\t'
                    : ''
            ) + 'set';
            strColumns += (
                strColumns
                    ? '\t'
                    : ''
            ) + target.getAttribute('column');

            // get update data
            strRecord = '';

            // get 'pk' columns
            col_i = 0;
            col_len = arrPk.length;
            while (col_i < col_len) {
                strRecord += (
                    strRecord
                        ? '\t'
                        : ''
                );
                strRecord += GS.encodeForTabDelimited(updateRecordData[element.internalData.arrColumnNames.indexOf(arrPk[col_i])], element.nullString);
                col_i += 1;
            }

            // get 'hash' columns
            strRecordToHash = '';
            col_i = 0;
            col_len = arrLock.length;
            while (col_i < col_len) {
                strRecordToHash += (
                    strRecordToHash
                        ? '\t'
                        : ''
                );
                strTemp = updateRecordData[element.internalData.arrColumnNames.indexOf(arrLock[col_i])];
                strRecordToHash += (
                    strTemp === 'NULL'
                        ? ''
                        : strTemp
                );
                col_i += 1;
            }

            strRecord += (
                strRecord
                    ? '\t'
                    : ''
            ) + GS.utfSafeMD5(strRecordToHash).toString();

            // get 'set' column
            strRecord += (
                strRecord
                    ? '\t'
                    : ''
            ) + GS.encodeForTabDelimited(target.value, element.nullString);
            console.log(target.value, element.nullString, GS.encodeForTabDelimited(target.value, element.nullString));

            strUpdateData = (strRoles + '\n' + strColumns + '\n' + strRecord + '\n');
            updateRecords(element, strHashColumns, strUpdateData, [updateRecord], false);
        };

        element.addEventListener('change', function (event) {
            var target = event.target;

            if (
                target.hasAttribute('column') &&
                !GS.findParentElement(target, 'tr').classList.contains('insert-record') &&
                !event.shiftKey
            ) {
                updateFromEntry(target);
            }
        });

        // manuel insert
        var insertFromInsertRecord = function () {
            var arrElements = xtag.query(element, 'tr.insert-record > td > [column]');
            var i;
            var len;
            var strColumns;
            var strInsertData;
            var strLocalData;

            strColumns = '';
            strInsertData = '';
            strLocalData = '';
            i = 0;
            len = arrElements.length;
            while (i < len) {
                strColumns += (
                    strColumns
                        ? '\t'
                        : ''
                ) + arrElements[i].getAttribute('column');
                strInsertData += (
                    strInsertData
                        ? '\t'
                        : ''
                ) + GS.encodeForTabDelimited(arrElements[i].value || 'NULL', element.nullString);
                strLocalData += (
                    strLocalData
                        ? '\t'
                        : ''
                ) + GS.encodeForTabDelimited(arrElements[i].value || '', element.nullString);
                arrElements[i].value = '';
                i += 1;
            }

            insertRecords(element, strColumns, strInsertData + '\n', strLocalData + '\n', false);
        };

        element.addEventListener('keydown', function (event) {
            var intKeyCode = (event.which || event.keyCode);
            var target = event.target;

            if (target.hasAttribute('column') && GS.findParentElement(target, 'tr').classList.contains('insert-record') && !event.shiftKey) {
                if (intKeyCode === KEY_RETURN) {
                    insertFromInsertRecord();
                    event.preventDefault();
                }
            }
        });

        // arrow navigation, key selection
        if (!evt.touchDevice) {
            element.addEventListener('keydown', function (event) {
                var intKeyCode = (event.which || event.keyCode);
                var target = event.target;
                var targetValue = target.value || '';
                var bolNavigateMode = false;
                var parentCell;
                var parentRecord;
                var parentTBody;
                var jsnCursorPos;
                var intCursorPosition;
                var bolSelect;
                var bolFullSelection;
                var bolCursorAtFirst;
                var bolCursorAtTop;
                var bolCursorAtLast;
                var bolCursorAtBottom;
                var arrSelected;
                var arrRecords;
                var focusElement;

                //event.stopPropagation();

                // find out if we are in focus mode
                // if we are in a cell control: we might be in focus mode (we need to check further)
                if (
                    (event.target.nodeName === 'INPUT' || event.target.nodeName === 'TEXTAREA') &&
                    !target.classList.contains('hidden-focus-control')
                ) {
                    jsnCursorPos = GS.getInputSelection(event.target);

                    // if fill text selection and shift is down: not focus mode
                    if (!(jsnCursorPos.start === 0 && jsnCursorPos.end === event.target.value.length && event.shiftKey)) {
                        bolNavigateMode = true;
                    }
                } else if (target.hasAttribute('column')) {
                    jsnCursorPos = {'start': 0, 'end': targetValue.length};
                    if (!event.shiftKey) {
                        bolNavigateMode = true;
                    }
                }

                // if we're in navigate mode: change focused cell
                if (bolNavigateMode) {
                    if (target.nodeName === 'INPUT' || target.nodeName === 'TEXTAREA') {
                        jsnCursorPos = GS.getInputSelection(target);
                    } else {
                        jsnCursorPos = {'start': 0, 'end': targetValue.length};
                    }

                    parentCell = GS.findParentElement(target, 'th,td');
                    parentRecord = parentCell.parentNode;
                    parentTBody = parentRecord.parentNode;

                    bolFullSelection = (jsnCursorPos.start === 0 && jsnCursorPos.end === targetValue.length);

                    // if we don't have a full selection and the selection is one character position
                    if (!bolFullSelection && jsnCursorPos.start === jsnCursorPos.end) {
                        // find out where the cursor is
                        intCursorPosition = jsnCursorPos.start;
                        bolCursorAtFirst = (intCursorPosition === 0);
                        bolCursorAtTop = (
                            intCursorPosition < (targetValue.indexOf('\n') === -1
                                ? targetValue.length + 1
                                : targetValue.indexOf('\n') + 1)
                        ) || (intCursorPosition === 0);
                        bolCursorAtLast = (intCursorPosition === targetValue.length);
                        bolCursorAtBottom = (intCursorPosition > targetValue.lastIndexOf('\n'));
                    }

                    // if left arrow and (full selection or the cursor is at the first character)
                    if (intKeyCode === KEY_LEFT && (bolFullSelection || bolCursorAtFirst)) {
                        if (parentCell.previousElementSibling && parentCell.previousElementSibling.nodeName !== 'TH') {
                            focusElement = parentCell.previousElementSibling;
                            bolSelect = true;

                        } else if (parentRecord.previousElementSibling) {
                            focusElement = parentRecord.previousElementSibling.lastElementChild;
                            bolSelect = true;
                        }

                    // if up arrow and (full selection or the cursor is in the top line)
                    } else if (intKeyCode === KEY_UP && (bolFullSelection || bolCursorAtTop)) {
                        if (parentRecord.previousElementSibling) {
                            focusElement = parentRecord.previousElementSibling.children[parentCell.cellIndex];
                            bolSelect = true;

                        } else if (parentCell.previousElementSibling && parentCell.previousElementSibling.nodeName !== 'TH') {
                            focusElement = parentTBody.lastElementChild.children[parentCell.cellIndex - 1];
                            bolSelect = true;
                        }

                    // if right arrow and (full selection or the cursor is at the last character)
                    } else if (intKeyCode === KEY_RIGHT && (bolFullSelection || bolCursorAtLast)) {
                        if (parentCell.nextElementSibling && parentCell.nextElementSibling.nodeName !== 'TH') {
                            focusElement = parentCell.nextElementSibling;
                            parentCell.nextElementSibling.children[0].focus();
                            bolSelect = true;

                        } else if (parentRecord.nextElementSibling) {
                            focusElement = parentRecord.nextElementSibling.children[1];
                            bolSelect = true;
                        }

                    // if down arrow  and (full selection or the cursor is in the last line)
                    } else if (intKeyCode === KEY_DOWN && (bolFullSelection || bolCursorAtBottom)) {
                        if (parentRecord.nextElementSibling) {
                            focusElement = parentRecord.nextElementSibling.children[parentCell.cellIndex];
                            bolSelect = true;

                        } else if (parentCell.nextElementSibling && parentCell.nextElementSibling.nodeName !== 'TH') {
                            focusElement = parentTBody.firstElementChild.children[parentCell.cellIndex + 1];
                            bolSelect = true;
                        }
                    }

                    // if something was selected
                    if (bolSelect) {
                        // set selected cells
                        element.savedSelection = [];
                        element.savedSelectionCopy = [];
                        element.dragOrigin = GS.findParentElement(focusElement, 'td, th');
                        element.dragCurrentCell = element.dragOrigin;
                        element.selectionPreviousOrigin = element.dragOrigin;
                        element.numberOfSelections = 1;
                        element.dragMode = 'select';

                        selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);

                        // this makes it so that the keyup doesn't happen,
                        //      allowing the new text selection to stay
                        event.preventDefault();
                        event.stopPropagation();
                    }

                    if (focusElement) {
                        focusElement = xtag.query(focusElement, 'input, textarea, select, [tabindex]')[0];
                        if (focusElement) {
                            focusElement.focus();

                            // select all the text and scroll into view
                            if (focusElement !== window) {
                                if (focusElement.nodeName === 'INPUT' || focusElement.nodeName === 'TEXTAREA') {
                                    GS.setInputSelection(focusElement, 0, focusElement.value.length);
                                }
                                parentRecord = GS.findParentTag(focusElement, 'tr');

                                if (parentRecord && parentRecord.nodeName === 'TR') {
                                    GS.scrollIntoView(parentRecord);
                                }
                            }
                        }
                    }

                // else: change selection
                } else if (
                    event.target === element ||
                    event.target.hasAttribute('column') ||
                    event.target.classList.contains('hidden-focus-control')
                ) {
                    // if mouse selection is not happening right now
                    if (!element.dragAllowed) {
                        arrSelected = element.selectedCells;

                        // if the key was tab
                        if (intKeyCode === KEY_TAB) {
                            // if is a selection origin: focus the inner control
                            if (element.dragOrigin) {
                                element.dragOrigin.children[0].focus();

                                // this makes it so that the keyup doesn't happen,
                                //      allowing the new text selection to stay
                                event.preventDefault();
                            }

                        // else if the key was return
                        } else if (intKeyCode === KEY_RETURN) {
                            // if there is only one cell selected: go into the cell control
                            if (arrSelected.length === 1) {
                                arrSelected[0].children[0].focus();
                            } else {
                                element.dragOrigin.children[0].focus();
                            }

                            GS.setInputSelection(document.activeElement, document.activeElement.value.length);
                            GS.scrollIntoView(GS.findParentTag(document.activeElement, 'tr'));

                            // this makes it so that the keyup doesn't happen,
                            //      allowing the new text selection to stay
                            event.preventDefault();

                        // else if an arrow key was pressed
                        } else if (intKeyCode === KEY_UP || intKeyCode === KEY_DOWN || intKeyCode === KEY_LEFT || intKeyCode === KEY_RIGHT) {
                            arrRecords = xtag.query(element, 'tr');
                            element.dragMode = 'select';

                            // if no selection: select first editable cell
                            if (arrSelected.length === 0) {
                                //console.log('2***');
                                element.savedSelection = [];
                                element.savedSelectionCopy = [];
                                element.dragOrigin = xtag.query(element, 'tbody td')[0];
                                element.dragCurrentCell = element.dragOrigin;
                                element.selectionPreviousOrigin = element.dragOrigin;
                                element.numberOfSelections = 1;

                                bolSelect = true;

                            // if shift: expand current selection
                            } else if (event.shiftKey) {
                                //console.log('3***', element.dragCurrentCell);
                                element.dragOrigin = element.selectionPreviousOrigin;
                                parentRecord = element.dragCurrentCell.parentNode;

                                // if left arrow
                                if (intKeyCode === 37 && element.dragCurrentCell.previousElementSibling) {
                                    element.dragCurrentCell = element.dragCurrentCell.previousElementSibling;

                                // if up arrow
                                } else if (intKeyCode === 38 && arrRecords[parentRecord.rowIndex - 1]) {
                                    element.dragCurrentCell = arrRecords[parentRecord.rowIndex - 1].children[element.dragCurrentCell.cellIndex];

                                // if right arrow
                                } else if (intKeyCode === 39 && element.dragCurrentCell.nextElementSibling) {
                                    element.dragCurrentCell = element.dragCurrentCell.nextElementSibling;

                                // if down arrow
                                } else if (intKeyCode === 40 && arrRecords[parentRecord.rowIndex + 1]) {
                                    element.dragCurrentCell = arrRecords[parentRecord.rowIndex + 1].children[element.dragCurrentCell.cellIndex];
                                }

                                bolSelect = true;

                            // else: move selected cell based on origin cell
                            } else {
                                //console.log('4***', arrSelected.length);
                                if (arrSelected.length > 1) {
                                    element.dragCurrentCell = element.selectionPreviousOrigin;
                                }

                                parentRecord = element.dragCurrentCell.parentNode;

                                // if left arrow
                                if (intKeyCode === 37 && element.dragCurrentCell.previousElementSibling) {
                                    element.dragCurrentCell = element.dragCurrentCell.previousElementSibling;

                                // if up arrow
                                } else if (intKeyCode === 38 && arrRecords[parentRecord.rowIndex - 1]) {
                                    element.dragCurrentCell = arrRecords[parentRecord.rowIndex - 1].children[element.dragCurrentCell.cellIndex];

                                // if right arrow
                                } else if (intKeyCode === 39 && element.dragCurrentCell.nextElementSibling) {
                                    element.dragCurrentCell = element.dragCurrentCell.nextElementSibling;

                                // if down arrow
                                } else if (intKeyCode === 40 && arrRecords[parentRecord.rowIndex + 1]) {
                                    element.dragCurrentCell = arrRecords[parentRecord.rowIndex + 1].children[element.dragCurrentCell.cellIndex];
                                }

                                element.savedSelection = [];
                                element.savedSelectionCopy = [];
                                element.dragOrigin = element.dragCurrentCell;
                                element.selectionPreviousOrigin = element.dragCurrentCell;
                                element.numberOfSelections = 1;

                                bolSelect = true;
                            }

                            // if the above code has produced the info for a selection: call the select handler
                            if (bolSelect) {
                                //console.log('5***', element, element.dragOrigin, element.dragCurrentCell, element.dragMode);

                                element.lastFocusedControl = null;
                                element.copyControl.focus();

                                selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                                GS.scrollIntoView(element.dragCurrentCell.parentNode);
                                event.preventDefault();
                            }
                        }
                    }
                }
            });
        }


        element.addEventListener('mousewheel', function () {
            synchronizeHeaderScroll(element);
        });
        element.scrollContainer.addEventListener('scroll', function () {
            synchronizeHeaderScroll(element);
        });
        window.addEventListener('resize', function () {
            refreshReflow(element);
            refreshHeight(element);
            synchronizeHeaderWidths(element);
        });
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (element.hasAttribute('null-string')) {
                    element.nullString = element.getAttribute('null-string') || '';
                } else {
                    element.nullString = '';
                }

                prepareElement(element);
                bindElement(element);
                getData(element, '', '', true);
            }
        }
    }

    xtag.register('gs-datasheet', {
        lifecycle: {
            created: function () {},

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, ignore, newValue) { //oldValue
                var element = this;

                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);

                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value' && this.root) {
                        this.refresh();
                    }
                }
            }
        },
        events: {},
        accessors: {
            selectedCells: {
                get: function () {
                    return xtag.query(this.scrollContainer, '[selected]');
                },

                set: function (newValue) {
                    var i;
                    var len;
                    var arrCells = xtag.query(this, '[selected]');
                    var arrRowIndexes = [];
                    var arrHeaderIndexes = [];
                    var arrRecordSelectors;
                    var arrHeaders;

                    // clear old selection
                    i = 0;
                    len = arrCells.length;
                    while (i < len) {
                        arrCells[i].removeAttribute('selected');
                        i += 1;
                    }

                    arrCells = xtag.query(this, '[selected-secondary]');
                    i = 0;
                    len = arrCells.length;
                    while (i < len) {
                        arrCells[i].removeAttribute('selected-secondary');
                        i += 1;
                    }

                    // if newValue is not an array: make it an array
                    if (typeof newValue === 'object' && newValue.length === undefined) {
                        arrCells = [newValue];
                    } else {
                        arrCells = newValue;
                    }

                    // if this call is the result of a javascript ".selectedCells = ARRAY" call and there are more than zero cells to set
                    if (!this.dragAllowed && arrCells.length > 0) {
                        this.dragOrigin = arrCells[0];
                        this.dragCurrentCell = arrCells[arrCells.length - 1];
                    }
                    if (!this.savedSelection) {
                        this.savedSelection = [];
                    }

                    // set new selection
                    i = 0;
                    len = arrCells.length;
                    while (i < len) {
                        GS.listAdd(arrRowIndexes, arrCells[i].parentNode.rowIndex);
                        GS.listAdd(arrHeaderIndexes, arrCells[i].cellIndex);

                        this.savedSelection.push(arrCells[i].parentNode.rowIndex + ',' + arrCells[i].cellIndex);

                        arrCells[i].setAttribute('selected', '');
                        i += 1;
                    }

                    // highlight non-selected headers and row selectors

                    arrRecordSelectors = xtag.query(this, 'tbody th, thead th:first-child');
                    i = 0;
                    len = arrRecordSelectors.length;
                    while (i < len) {
                        if (arrRowIndexes.indexOf(i) !== -1 && !arrRecordSelectors[i].hasAttribute('selected')) {
                            arrRecordSelectors[i].setAttribute('selected-secondary', '');
                        }
                        i += 1;
                    }

                    arrHeaders = xtag.query(this, 'thead th');
                    i = 0;
                    len = arrHeaders.length;
                    while (i < len) {
                        if (arrHeaderIndexes.indexOf(i) !== -1 && !arrHeaders[i].hasAttribute('selected')) {
                            arrHeaders[i].setAttribute('selected-secondary', '');
                        }
                        i += 1;
                    }

                    GS.triggerEvent(this, 'after_selection');
                }
            },

            selectedRecords: {
                get: function () {
                    var i;
                    var len;
                    var intRecordIndex = -1;
                    var arrRecord = [];
                    var selected = this.selectedCells;

                    // loop through the selected cells and create an array of trs
                    i = 0;
                    len = selected.length;
                    while (i < len) {
                        if (selected[i].parentNode.rowIndex > intRecordIndex && selected[i].parentNode.parentNode.nodeName !== 'THEAD') {
                            intRecordIndex = selected[i].parentNode.rowIndex;
                            arrRecord.push(selected[i].parentNode);
                        }
                        i += 1;
                    }

                    return arrRecord;
                },

                set: function (newValue) {
                    var i;
                    var len;
                    var cell_i;
                    var cell_len;
                    var arrCells = this.selectedCells;
                    var arrRecords;
                    var arrCellChildren;

                    // clear old selection
                    i = 0;
                    len = arrCells.length;
                    while (i < len) {
                        arrCells[i].removeAttribute('selected');
                        i += 1;
                    }

                    arrCells = xtag.query(this, '[selected-secondary]');
                    i = 0;
                    len = arrCells.length;
                    while (i < len) {
                        arrCells[i].removeAttribute('selected-secondary');
                        i += 1;
                    }

                    // if newValue is not an array: make it an array
                    if (typeof newValue === 'object' && newValue.length === undefined) {
                        arrRecords = [newValue];
                    } else {
                        arrRecords = newValue;
                    }

                    // set new selection
                    arrCells = [];
                    i = 0;
                    len = arrRecords.length;
                    while (i < len) {
                        arrCellChildren = arrRecords[i].children;

                        cell_i = 0;
                        cell_len = arrCellChildren.length;
                        while (cell_i < cell_len) {
                            arrCells.push(arrCellChildren[cell_i]);
                            cell_i += 1;
                        }
                        i += 1;
                    }

                    this.selectedCells = arrCells;
                }
            },

            value: {
                get: function () {
                    return this.getAttribute('value');
                },

                set: function (newValue) {
                    return this.setAttribute('value', newValue);
                }
            }
        },
        methods: {
            'refresh': function () {
                getData(this);
            },

            'refreshFixedHeader': function () {
                synchronizeHeaderScroll(this);
                synchronizeHeaderWidths(this);
            },

            'refreshReflow': function () {
                refreshReflow(this);
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, addFocusEvents, addAutocompleteProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';

    addSnippet(
        '<gs-date>',
        '<gs-date>',
        'gs-date column="${1:name}"></gs-date>'
    );
    addSnippet(
        '<gs-date> With Label',
        '<gs-date>',
        (
            'label for="${1:date-insert-start_date}">' +
                '${2:Start Date}:' +
            '</label>\n' +
            '<gs-date id="${1:date-insert-start_date}" ' +
            'column="${3:start_date}"></gs-date>'
        )
    );

    // TODO: there is no documentation
    //addElement('gs-date', '');

    window.designElementProperty_GSDATE = function(selectedElement) {
        addGSControlProps();
        addText('O', 'Column In QS', 'qs');
        addText('V', 'Placeholder', 'placeholder');
        addText('V', 'Date Picker', 'no-picker');
        addCombo('D', 'Format', 'format', [
            {"val": "", "txt": "Default (01/01/2015)"},
            {"val": "shortdate", "txt": "Shortdate (1/1/15)"},
            {"val": "mediumdate", "txt": "Mediumdate (Jan 1, 2015)"},
            {"val": "longdate", "txt": "Longdate (January 1, 2015)"},
            {"val": "fulldate", "txt": "Fulldate (Thursday, January 1, 2015)"},
            {"val": "isodate", "txt": "Isodate (2015-01-01)"},
            {"val": "isodatetime", "txt": "Isodatetime (2015-01-01T00:00:00)"}
        ]);
        addAutocompleteProps();
        addFocusEvents();
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var singleLineTemplateElement = document.createElement('template'),
        singleLineTemplate;

    singleLineTemplateElement.innerHTML = '<input class="control" gs-dynamic type="text" />' +
                             '<gs-button class="date-picker-button" gs-dynamic inline icononly icon="calendar" no-focus>Open Date Picker</gs-button>';

    singleLineTemplate = singleLineTemplateElement.content;

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();

        //console.log('change event triggered');

        GS.triggerEvent(event.target.parentNode, 'change');

        handleFormat(event.target.parentNode, event);
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
        event.target.parentNode.classList.add('focus');
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'blur');
        event.target.parentNode.classList.remove('focus');
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseout);
        event.target.parentNode.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseover);
        event.target.parentNode.classList.add('hover');
    }


    function buttonClickFunction(event) {
        openDatePicker(event.target.parentNode);
    }

    //function pushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //
    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.setAttribute('value', GS.qryGetVal(strQueryString, strQSCol));
    //    }
    //}

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // sync control value and resize to text
    function syncView(element) {
        if (element.control) {
            element.setAttribute('value', element.control.value);
        }
    }

    function openDatePicker(element, dteDate) {
        var divElement = document.createElement('div')
          , jsnOffset = GS.getElementOffset(element.datePickerButton)
          , jsnControlOffset = GS.getElementOffset(element)
          , datePickerContainer, datePicker, strHTML = '', intTop, bolSelectOrigin
          , i, len, dateClickHandler, arrDateButtons, dteCurrent, strInputValue = element.control.value;

        // if there is a day of the week in the value: remove it
        if (strInputValue.match(/monday|tuesday|wednesday|thursday|friday|saturday|sunday/gim)) {
            strInputValue = strInputValue.replace(/monday|tuesday|wednesday|thursday|friday|saturday|sunday/gim, '')
                                         .replace(/  /gim, ' ')
                                         .trim();
        }

        // fix date being off by one day by replacing the dashes with slashes
        strInputValue = strInputValue.replace(/-/, '/')  // replace first dash with forward slash
                                     .replace(/-/, '/'); // replace second dash with forward slash

        dteCurrent = new Date(strInputValue);

        if (isNaN(dteCurrent.getTime())) {
            dteCurrent = new Date();
        }

        element.datePickerButton.setAttribute('selected', '');

        // if no date was sent
        if (!dteDate) {
            // try using the value from the input
            if (element.control.value) {
                dteDate = dteCurrent;
                bolSelectOrigin = true;

            // else just use now
            } else {
                dteDate = new Date();
            }
        }

        //if we are in the current month and year, Highlight the day we are on
        if (dteDate.getMonth() === dteCurrent.getMonth() && dteDate.getFullYear() === dteCurrent.getFullYear()) {
            bolSelectOrigin = true;
        }

        // set html using date
        strHTML = getContentForDatePicker(element, dteDate, bolSelectOrigin);

        divElement.innerHTML =  '<div class="gs-date-date-picker-container" gs-dynamic>' +
                                    '<div class="gs-date-date-picker" gs-dynamic>' + strHTML + '</div>' +
                                '</div>';

        datePickerContainer = divElement.children[0];
        element.datePickerContainer = datePickerContainer;

        datePicker = datePickerContainer.children[0];

        document.body.appendChild(datePickerContainer);

        // position datePickerContainer
        intTop = jsnOffset.top + element.offsetHeight;

        if (intTop + datePicker.offsetHeight > window.innerHeight) {
            intTop -= datePicker.offsetHeight;
            intTop -= element.offsetHeight;

            if (intTop < 0) {
                intTop = 0;
            }
        }

        datePicker.style.top = intTop + 'px';

        // if window width is wider than 450 pixels width AND the date picker will not fall off of the screen:
        if (window.innerWidth > 450 && jsnOffset.left > 450) {
            // datepicker width: 450px; right: calculated;
            datePicker.style.width = '450px';
            datePicker.style.right = window.innerWidth - (jsnOffset.left + element.datePickerButton.offsetWidth) + 'px';

        // if window width is wider than 450 pixels width AND the date picker will not fall off of the screen:
        } else if (window.innerWidth > 450 && jsnOffset.left <= 450) {
            // datepicker width: 450px; right: calculated;
            datePicker.style.width = '450px';
            datePicker.style.left = jsnControlOffset.left + 'px';

        // else:
        } else {
            // datepicker width: 96%; right: 2%;
            datePicker.style.width = '96%';
            datePicker.style.right = '2%';
        }

        // next month, previous month, next year, previous year click events
        datePickerContainer.getElementsByClassName('prev-month')[0].addEventListener('click', function () {
            dteDate.setMonth(dteDate.getMonth() - 1);
            closeDatePicker(element);
            openDatePicker(element, dteDate);
        });
        datePickerContainer.getElementsByClassName('next-month')[0].addEventListener('click', function () {
            var i, oldMonth;

            oldMonth = dteDate.getMonth();
            dteDate.setMonth(oldMonth + 1);

            // if a month is skipped (no need to worry about the loop back to january because december and january both seem to have 31 days)
            if (dteDate.getMonth() === oldMonth + 2) {
                // loop backwards until we reach the correct month
                i = 0;
                while (dteDate.getMonth() === oldMonth + 2 && i < 20) {
                    dteDate.setDate(dteDate.getDate() - 1);
                    i += 1;
                }
            }

            closeDatePicker(element);
            openDatePicker(element, dteDate);
        });
        datePickerContainer.getElementsByClassName('prev-year')[0].addEventListener('click', function () {
            dteDate.setFullYear(dteDate.getFullYear() - 1);
            closeDatePicker(element);
            openDatePicker(element, dteDate);
        });
        datePickerContainer.getElementsByClassName('next-year')[0].addEventListener('click', function () {
            dteDate.setFullYear(dteDate.getFullYear() + 1);
            closeDatePicker(element);
            openDatePicker(element, dteDate);
        });

        // background click event
        datePickerContainer.addEventListener('click', function (event) {
            if (event.target.classList.contains('gs-date-date-picker-container')) {
                closeDatePicker(element);
            }
        });

        // month-letter click event
        datePickerContainer.addEventListener('click', function (event) {
            if (event.target.classList.contains('month-letter')) {
                dteDate.setMonth(event.target.getAttribute('month'));
                closeDatePicker(element);
                openDatePicker(element, dteDate);
            }
        });

        // date click events
        dateClickHandler = function () {
            var dteNewDate = new Date(this.getAttribute('data-date'));

            closeDatePicker(element);

            element.value = (dteNewDate.getMonth() + 1) + '/' + dteNewDate.getDate() + '/' + dteNewDate.getFullYear();
            //console.trace('test', element.value);
            handleFormat(element);
            xtag.fireEvent(element, 'change', { bubbles: true, cancelable: true });
        };

        arrDateButtons = datePickerContainer.getElementsByClassName('day-marker');

        for (i = 0, len = arrDateButtons.length; i < len; i += 1) {
            arrDateButtons[i].addEventListener('click', dateClickHandler);
        }
    }

    function closeDatePicker(element) {
        element.datePickerButton.removeAttribute('selected');
        document.body.removeChild(element.datePickerContainer);
    }

    function getContentForDatePicker(element, originDate, bolSelectOrigin) {
        var strHTML = '', i, looperDate, lookaheadDate, intFirstDayOfWeek = 0, dteToday = new Date();
        
        
        if (element.hasAttribute('spanish')) {
            var arrDays = ['Domingo', 'Lune', 'Martes', 'MiÃ©rcoles', 'Jueves', 'Viernes', 'SÃ¡bado'];
            var arrShortDays = ['D', 'L', 'M', 'M', 'J', 'V', 'S'];
            var arrMonths = [
                    'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'
                ];
        } else {
            var arrDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            var arrShortDays = ['S', 'M', 'T', 'W', 'T', 'F', 'S'];
            var arrMonths = [
                    'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
                ];
        }

        looperDate = new Date(originDate);
        looperDate.setDate(1);

        if (element.hasAttribute('spanish')) {
            strHTML =   '<gs-button class="month-letter" month="0">E</gs-button>';
        } else {
            strHTML =   '<gs-button class="month-letter" month="0">J</gs-button>';
        }
        strHTML = strHTML +
                    '<gs-button class="month-letter" month="1">F</gs-button>' +
                    '<gs-button class="month-letter" month="2">M</gs-button>' +
                    '<gs-button class="month-letter" month="3">A</gs-button>' +
                    '<gs-button class="month-letter" month="4">M</gs-button>' +
                    '<gs-button class="month-letter" month="5">J</gs-button>' +
                    '<gs-button class="month-letter" month="6">J</gs-button>' +
                    '<gs-button class="month-letter" month="7">A</gs-button>' +
                    '<gs-button class="month-letter" month="8">S</gs-button>' +
                    '<gs-button class="month-letter" month="9">O</gs-button>' +
                    '<gs-button class="month-letter" month="10">N</gs-button>' +
                    '<gs-button class="month-letter" month="11">D</gs-button>' +
                    '<div class="month-marker" flex-horizontal gs-dynamic>' +
                        '<gs-button class="prev-month" inline icononly icon="arrow-left" gs-dynamic>Prev</gs-button>' +
                        '<span flex gs-dynamic>' + arrMonths[originDate.getMonth()] + '</span>' +
                        '<gs-button class="next-month" inline icononly icon="arrow-right" gs-dynamic>Next</gs-button>' +
                    '</div>' +
                    '<div class="year-marker" flex-horizontal gs-dynamic>' +
                        '<gs-button class="prev-year" inline icononly icon="arrow-left" gs-dynamic>Prev</gs-button>' +
                        '<span flex gs-dynamic>' + originDate.getFullYear() + '</span>' +
                        '<gs-button class="next-year" inline icononly icon="arrow-right" gs-dynamic>Next</gs-button>' +
                    '</div>';
        if (!isNaN(looperDate.getTime())) {

            // reverse back to the previous intFirstDayOfWeek
            i = 0;
            while (looperDate.getDay() !== intFirstDayOfWeek && i < 20) {
                looperDate.setDate(looperDate.getDate() - 1);

                i += 1;
            }
            //console.log(looperDate);

            // add day of week markers
            strHTML += '<div class="date-picker-divider" gs-dynamic></div><div class="day-of-week-markers-container" gs-dynamic>';
            for (i = 0; i < 7; i += 1) {
                strHTML += '<div class="day-of-week-marker" gs-dynamic>' + arrShortDays[i] + '</div>';
            }
            strHTML += '</div>';

            // loop through till at least the end of the month (or further to find the day that is before the next intFirstDayOfWeek)
            i = 0;

            lookaheadDate = new Date(looperDate);
            lookaheadDate.setDate(lookaheadDate.getDate() + 1);

            while (!(looperDate.getDay()         === intFirstDayOfWeek &&
                    (looperDate.getMonth()       !== originDate.getMonth() && i > 0) &&
                     lookaheadDate.getFullYear() >=  originDate.getFullYear()) &&
                   i < 50) {

                strHTML +=  '<gs-button inline class="day-marker';

                if (looperDate.getMonth() !== originDate.getMonth()) {
                    strHTML += ' other-month';
                }
                if (looperDate.getFullYear() === dteToday.getFullYear() &&
                    looperDate.getMonth() === dteToday.getMonth() &&
                    looperDate.getDate() === dteToday.getDate()) {
                    strHTML += ' today';
                }
                strHTML += '"';

                if (looperDate.getTime() === originDate.getTime() && bolSelectOrigin) {
                    strHTML += ' selected ';
                }

                strHTML +=  'data-date="' + looperDate + '" gs-dynamic>';
                if (looperDate.getFullYear() === dteToday.getFullYear() &&
                    looperDate.getMonth() === dteToday.getMonth() &&
                    looperDate.getDate() === dteToday.getDate()) {
                    strHTML += 'T';
                } else {
                    strHTML += looperDate.getDate();
                }
                strHTML += '</gs-button>';

                //console.log(looperDate, lookaheadDate);

                lookaheadDate.setDate(lookaheadDate.getDate() + 1);
                looperDate.setDate(looperDate.getDate() + 1);
                i += 1;
            }
        }

        return strHTML;
    }

    function handleFormat(element, event, bolAlertOnError) {
        ///console.log(element.value);
        if (element.value) {
            var dteValue, strValueToFormat = element.value, tempSelection = GS.getInputSelection(element.control);

            // if there is a day of the week in the value: remove it
            if (strValueToFormat.match(/monday|tuesday|wednesday|thursday|friday|saturday|sunday/gim)) {
                strValueToFormat = strValueToFormat.replace(/monday|tuesday|wednesday|thursday|friday|saturday|sunday/gim, '')
                                                   .replace(/  /gim, ' ')
                                                   .trim();
            }

            if (strValueToFormat.indexOf(':') !== -1) {
                strValueToFormat = strValueToFormat.substring(0, strValueToFormat.indexOf(':'));
                strValueToFormat = strValueToFormat.substring(0, strValueToFormat.lastIndexOf(' '));
            }

            // if there are only six numbers in the field assume that
            //      the first  two are the month
            //      the second two are the day   and
            //      the third  two are the year  and make a date out of that
            if (strValueToFormat.length === 6 && strValueToFormat.match(/[0-9]/g).join('') === element.value) {
                dteValue = new Date(strValueToFormat.substring(0, 2) + '/' +
                                    strValueToFormat.substring(2, 4) + '/' +
                                    strValueToFormat.substring(4, 6));

            // for example: 02012022
            } else if (strValueToFormat.length === 8 && strValueToFormat.match(/[0-9]/g).join('') === element.value) {
                dteValue = new Date(strValueToFormat.substring(0, 2) + '/' +
                                    strValueToFormat.substring(2, 4) + '/' +
                                    strValueToFormat.substring(4, 8));

            } else {
                //console.log(strValueToFormat.replace(/-/, '/').replace(/-/, '/').replace(/-.*/, ''));
                dteValue = new Date(strValueToFormat.replace(/-/, '/').replace(/-/, '/').replace(/-.*/, ''));
                //console.log(dteValue, dteValue.getFullYear());
            }

            //console.trace('test', element.value, strValueToFormat, dteValue);

            if (isNaN(dteValue.getTime())) {
                if (bolAlertOnError !== undefined && bolAlertOnError !== false) {
                    alert('Invalid Date: ' + element.value);
                }

                if (document.activeElement === element.control) {
                    GS.setInputSelection(element.control, tempSelection.start, tempSelection.end);

                    if (event) {
                        if (event.keyCode === GS.keyCode('backspace')) {
                            GS.setInputSelection(element.control, tempSelection.start - 1, tempSelection.start - 1);
                        } else if (event.keyCode === GS.keyCode('delete')) {
                            GS.setInputSelection(element.control, tempSelection.start, tempSelection.start);
                        }
                        event.stopPropagation();
                        event.preventDefault();
                    }
                }

            } else {
                if (element.control) {
                    element.control.value = formatDate(element, dteValue, getFormatString(element));
                    if (document.activeElement === element.control) {
                        GS.setInputSelection(element.control, tempSelection.start, tempSelection.end);
                    }
                } else {
                    element.innerHTML = formatDate(element, dteValue, getFormatString(element));
                }
            }
        } else {
            return '\\N';
        }
    }

    function getFormatString(element) {
        var strFormat;

        if (element.hasAttribute('format')) {
            strFormat = element.getAttribute('format');
        }

        if (!strFormat) {
            strFormat = 'MM/dd/yyyy';
        } else if (strFormat.toLowerCase() === 'shortdate') {
            strFormat = 'M/d/yy';
        } else if (strFormat.toLowerCase() === 'mediumdate') {
            strFormat = 'MMM d, yyyy';
        } else if (strFormat.toLowerCase() === 'longdate') {
            strFormat = 'MMMM d, yyyy';
        } else if (strFormat.toLowerCase() === 'fulldate') {
            strFormat = 'EEEE, MMMM d, yyyy';
        } else if (strFormat.toLowerCase() === 'shorttime') {
            strFormat = 'h:mm a';
        } else if (strFormat.toLowerCase() === 'mediumtime') {
            strFormat = 'h:mm:ss a';
        } else if (strFormat.toLowerCase() === 'isodate') {
            strFormat = 'yyyy-MM-dd';
        } else if (strFormat.toLowerCase() === 'isotime') {
            strFormat = 'HH:mm:ss';
        } else if (strFormat.toLowerCase() === 'isodatetime') {
            strFormat = 'yyyy-MM-dd\'T\'HH:mm:ss';
        }

        return strFormat;
    }

    function formatDate(element, dteValue, strFormat) {
        /* (this function contains a (modified) substantial portion of code from another source
            here is the copyright for sake of legality) (Uses code by Matt Kruse)
        Copyright (c) 2006-2009 Rostislav Hristov, Asual DZZD

        Permission is hereby granted, free of charge, to any person obtaining a
        copy of this software and associated documentation files
        (the "Software"), to deal in the Software without restriction,
        including without limitation the rights to use, copy, modify, merge,
        publish, distribute, sublicense, and/or sell copies of the Software,
        and to permit persons to whom the Software is furnished to do so,
        subject to the following conditions:

        The above copyright notice and this permission notice shall be included
        in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/
        var i = 0, j = 0, l = 0, c = '', token = '', x, y, yearLen,
            formatNumber = function (n, s) {
                if (typeof s == 'undefined' || s == 2) {
                  return (n >= 0 && n < 10 ? '0' : '') + n;
                } else {
                    if (n >= 0 && n < 10) {
                       return '00' + n;
                    }
                    if (n >= 10 && n <100) {
                       return '0' + n;
                    }
                    return n;
                }
            };

        if (element.hasAttribute('spanish')) {
            var locale = {
                    monthsFull:   ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'],
                    monthsShort:  ['Ene','Feb','Mar','Abr','May','Jun','Jul','Ago','Sep','Oct','Nov','Dic'],
                    daysFull:     ['Domingo', 'Lune', 'Martes', 'MiÃ©rcoles', 'Jueves', 'Viernes', 'SÃ¡bado'],
                    daysShort:    ['Dom', 'Lun', 'Mar', 'MiÃ©', 'Jue', 'Vie', 'SÃ¡b'],
                    shortDateFormat: 'M/d/yyyy h:mm a',
                    longDateFormat: 'EEEE, MMMM dd, yyyy h:mm:ss a'
                };
        } else {
            var locale = {
                    monthsFull:   ['January','February','March','April','May','June', 'July','August','September','October','November','December'],
                    monthsShort:  ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],
                    daysFull:     ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
                    daysShort:    ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],
                    shortDateFormat: 'M/d/yyyy h:mm a',
                    longDateFormat: 'EEEE, MMMM dd, yyyy h:mm:ss a'
                };
        }

        y = dteValue.getFullYear();
        // Nunzio commented this out on Monday, October 19, 2015
        // It was causing an issue during typing in the year field
        /*if (y < 1000) {
            y = String(y + 1900);
        }*/

        var M = dteValue.getMonth() + 1,
            d = dteValue.getDate(),
            E = dteValue.getDay(),
            H = dteValue.getHours(),
            m = dteValue.getMinutes(),
            s = dteValue.getSeconds(),
            S = dteValue.getMilliseconds();

        //console.log(dteValue.getFullYear());

        yearLen = String(y).length;
        dteValue = {
            y: y,
            yyyy: y,
            yy: String(y).substring(yearLen - 2, yearLen),
            M: M,
            MM: formatNumber(M),
            MMM: locale.monthsShort[M-1],
            MMMM: locale.monthsFull[M-1],
            d: d,
            dd: formatNumber(d),
            EEE: locale.daysShort[E],
            EEEE: locale.daysFull[E],
            H: H,
            HH: formatNumber(H)
        };

        //console.log(dteValue);

        if (H === 0) {
            dteValue.h = 12;
        } else if (H > 12) {
            dteValue.h = H - 12;
        } else {
            dteValue.h = H;
        }

        dteValue.hh = formatNumber(dteValue.h);
        dteValue.k = H !== 0 ? H : 24;
        dteValue.kk = formatNumber(dteValue.k);

        if (H > 11) {
            dteValue.K = H - 12;
        } else {
            dteValue.K = H;
        }

        dteValue.KK = formatNumber(dteValue.K);

        if (H > 11) {
            dteValue.a = 'PM';
        } else {
            dteValue.a = 'AM';
        }

        dteValue.m = m;
        dteValue.mm = formatNumber(m);
        dteValue.s = s;
        dteValue.ss = formatNumber(s);
        dteValue.S = S;
        dteValue.SS = formatNumber(S);
        dteValue.SSS = formatNumber(S, 3);

        var result = '';

        i = 0;
        c = '';
        token = '';
        s = false;

        while (i < strFormat.length) {
            token = '';
            c = strFormat.charAt(i);
            if (c == '\'') {
                i++;
                if (strFormat.charAt(i) == c) {
                    result = result + c;
                    i++;
                } else {
                    s = !s;
                }
            } else {
                while (strFormat.charAt(i) == c) {
                    token += strFormat.charAt(i++);
                }
                if (token.indexOf('MMMM') != -1 && token.length > 4) {
                    token = 'MMMM';
                }
                if (token.indexOf('EEEE') != -1 && token.length > 4) {
                    token = 'EEEE';
                }
                if (typeof dteValue[token] != 'undefined' && !s) {
                    result = result + dteValue[token];
                } else {
                    result = result + token;
                }
            }
        }

        return result;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value && new Date(element.value).getTime()) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = undefined;
                //element.value = null;
            }

        }
    }

    function findFor(element) {
        var forElem;
        //console.log(element, element.previousElementSibling)
        if (element.previousElementSibling && element.previousElementSibling.tagName.toUpperCase() == 'LABEL'
            && element.previousElementSibling.hasAttribute('for')
            && element.previousElementSibling.getAttribute('for') == element.getAttribute('id')
        ) {
            forElem = element.previousElementSibling;
        } else if (xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]').length > 0) {
            forElem = xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]')[0];
        }
        //console.log(forElem);
        if (forElem) {
            forElem.setAttribute('for', element.getAttribute('id') + '_control');
            if (element.control) {
                element.control.setAttribute('id', element.getAttribute('id') + '_control');
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }
            }
        }

        /*
            if (element.hasAttribute('id')) {
                findFor(element);
            }
        // please ensure that if the element has an id it is given an id
                if (element.hasAttribute('id')) {
                    element.control.setAttribute('id', element.getAttribute('id') + '_control');
                }
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }
        */
    }

    //
    function elementInserted(element) {
        console.warn('GS-DATE WARNING: this element is deprecated, please use the gs-datetime instead.');
        var today, strQSValue;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                /*
                element.addEventListener(evt.mouseout, function (event) {
                    element.classList.remove('hover');
                });

                element.addEventListener(evt.mouseover, function (event) {
                    element.classList.add('hover');
                });
                */

                if (element.hasAttribute('tabindex')) {
                    element.oldTabIndex = element.getAttribute('tabindex');
                    element.removeAttribute('tabindex');
                }

                if (element.hasAttribute('value') && element.getAttribute('value').trim().toLowerCase() === 'today') {
                    today = new Date();
                    element.setAttribute('value', GS.leftPad(today.getFullYear(), '0', 4) + '/' + GS.leftPad(today.getMonth() + 1, '0', 2) + '/' + GS.leftPad(today.getDate(), '0', 2));
                }

                // handle "qs" attribute
                if (element.getAttribute('qs')) {
                    //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.setAttribute('value', strQSValue);
                    //}

                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                }

                element.innerHTML = '';
                element.appendChild(singleLineTemplate.cloneNode(true));
                if (element.oldTabIndex) {
                    xtag.query(element, '.control')[0].setAttribute('tabindex', element.oldTabIndex);
                }

                element.refresh();
            }
            if (element.hasAttribute('id')) {
                findFor(element);
            }
        }
    }

    function getControlState(element) {
        var jsnTextSelection, intStart, intEnd, strFormat = getFormatString(element),
            strValue = element.control.value, delimiter1index, delimiter2index,
            intCurrentSection, strCurrentSection, arrParts, intCurrentSectionSize;

        jsnTextSelection = GS.getInputSelection(element.control);
        intStart = jsnTextSelection.start;
        intEnd = jsnTextSelection.end;
        delimiter1index = (strValue.indexOf('-') === -1 ? strValue.indexOf('/') : strValue.indexOf('-'));
        delimiter2index = (strValue.lastIndexOf('-') === -1 ? strValue.lastIndexOf('/') : strValue.lastIndexOf('-'));
        arrParts = strFormat.split(/[-|/]/g);

        // calculate current section number
        if (intStart > delimiter2index) {
            intCurrentSection = 2;
        } else if (intStart > delimiter1index && intStart <= delimiter2index) {
            intCurrentSection = 1;
        } else {
            intCurrentSection = 0;
        }

        // calculate current part type
        if (arrParts[intCurrentSection].indexOf('y') !== -1) {
            strCurrentSection = 'year';
        } else if (arrParts[intCurrentSection].indexOf('M') !== -1) {
            strCurrentSection = 'month';
        } else {
            strCurrentSection = 'day';
        }

        // calculate current section size
        if (intCurrentSection === 2) {
            intCurrentSectionSize = (strValue.length) - (delimiter2index + 1);
        } else if (intCurrentSection === 1) {
            intCurrentSectionSize = delimiter2index - (delimiter1index + 1);
        } else {
            intCurrentSectionSize = delimiter1index;
        }

        return {
            'jsnTextSelection': jsnTextSelection,
            'intStart': intStart,
            'intEnd': intEnd,
            'strFormat': strFormat,
            'strValue': strValue,
            'delimiter1index': delimiter1index,
            'delimiter2index': delimiter2index,
            'intCurrentSection': intCurrentSection,
            'strCurrentSection': strCurrentSection,
            'arrParts': arrParts,
            'intCurrentSectionSize': intCurrentSectionSize
        };
    }

    xtag.register('gs-date', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'disabled' && newValue !== null) {
                        // console.log(this.dteValue);
                        this.innerHTML = this.value ? formatDate(this, new Date(this.value), getFormatString(this)) : this.getAttribute('placeholder');
                    } else if (strAttrName === 'disabled' && newValue === null) {
                        this.innerHTML = '';
                        this.appendChild(singleLineTemplate.cloneNode(true));
                        if (this.oldTabIndex) {
                            xtag.query(this, '.control')[0].setAttribute('tabindex', this.oldTabIndex);
                        }
                        this.refresh();
                    } else if (strAttrName === 'value') {
                        //console.log(newValue);

                        // This caused an infinite recursion
                        //this.value = newValue;
                        this.refresh();
                    }
                }
            }
        },
        events: {
            focus: function (event) {
                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    //console.log('1***', this.control, GS.getInputSelection(this.control));
                }
            },
            click: function (event) {
                var jsnTextSelection, intStart, strFormat, strValue, delimiter1index, delimiter2index;

                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted') && !this.hasAttribute('readonly')) {
                    jsnTextSelection = GS.getInputSelection(this.control);
                    strFormat = getFormatString(this);
                    strValue = this.control.value;

                    // if format is dash delimited or slash delimited and
                    //      we are not on a touch device
                    if ((/^[M|y]{1,}[/|-]{1}[M|d]{1,}[/|-]{1}[d|y]{1,}$/).test(strFormat) &&
                        (strValue.substring(jsnTextSelection.start, jsnTextSelection.end).match(/[-|/]/g) || []).length === 0 &&
                        !evt.touchDevice) {

                        // if there is a date and it's dash or slash delimited: select date part
                        if ((/^[0-9]{1,}[-]{1}[0-9]{1,}[-]{1}[0-9]{1,}$/).test(strValue) ||
                            (/^[0-9]{1,}[/]{1}[0-9]{1,}[/]{1}[0-9]{1,}$/).test(strValue)) {

                            intStart = jsnTextSelection.start;
                            delimiter1index = (strValue.indexOf('-') === -1 ? strValue.indexOf('/') : strValue.indexOf('-'));
                            delimiter2index = (strValue.lastIndexOf('-') === -1 ? strValue.lastIndexOf('/') : strValue.lastIndexOf('-'));

                            // if greater than second delimeter
                            if (intStart > delimiter2index) {
                                //console.log('Section 3');
                                GS.setInputSelection(this.control, delimiter2index + 1, strValue.length);

                            // if in between than first and second delimeter
                            } else if (intStart > delimiter1index && intStart <= delimiter2index) {
                                //console.log('Section 2');
                                GS.setInputSelection(this.control, delimiter1index + 1, delimiter2index);

                            // else
                            } else {
                                //console.log('Section 1');
                                GS.setInputSelection(this.control, 0, delimiter1index);
                            }

                            //console.log(intStart, delimiter1index, delimiter2index);
                        }
                    }
                }
            },
            keydown: function (event) { // tried "input" event
                var jsnTextSelection, intStart, intEnd, strFormat, strValue,
                    intKeyCode = (event.keyCode || event.which), delimiter1index, delimiter2index,
                    intCurrentSection, strCurrentSection, arrParts, dteDate, intCurrentSectionSize,
                    jsnState;

                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted') && !this.hasAttribute('readonly')) {
                    jsnTextSelection = GS.getInputSelection(this.control);
                    strValue = this.control.value;
                    strFormat = getFormatString(this);

                    // if format is dash delimited or slash delimited and
                    //      the selection doesn't encompass a delimeter and
                    //      we are not on a touch device
                    if ((/^[M|y]{1,}[/|-]{1}[M|d]{1,}[/|-]{1}[d|y]{1,}$/).test(strFormat) &&
                        (strValue.substring(jsnTextSelection.start, jsnTextSelection.end).match(/[-|/]/g) || []).length === 0 &&
                        !evt.touchDevice) {

                        // if there is a date and it's dash or slash delimited
                        if ((/^[0-9]{1,}[-]{1}[0-9]{1,}[-]{1}[0-9]{1,}$/).test(strValue) ||
                            (/^[0-9]{1,}[/]{1}[0-9]{1,}[/]{1}[0-9]{1,}$/).test(strValue)) {

                            // if shift, command and option keys are not down
                            if (!event.shiftKey && !event.metaKey && !event.ctrlKey) {
                                event.stopPropagation();

                                jsnState = getControlState(this)
                                jsnTextSelection =      jsnState.jsnTextSelection
                                intStart =              jsnState.intStart
                                intEnd =                jsnState.intEnd
                                strFormat =             jsnState.strFormat
                                strValue =              jsnState.strValue
                                delimiter1index =       jsnState.delimiter1index
                                delimiter2index =       jsnState.delimiter2index
                                intCurrentSection =     jsnState.intCurrentSection
                                strCurrentSection =     jsnState.strCurrentSection
                                arrParts =              jsnState.arrParts
                                intCurrentSectionSize = jsnState.intCurrentSectionSize

                                //// log
                                //console.log('intCurrentSectionSize: ' + intCurrentSectionSize + '\n' +
                                //            'intCurrentSection:     ' + intCurrentSection + '\n' +
                                //            'delimiter1index:       ' + delimiter1index + '\n' +
                                //            'delimiter2index:       ' + delimiter2index + '\n' +
                                //            'strValue.length:       ' + strValue.length + '\n' +
                                //            'strCurrentSection:     ' + strCurrentSection + '\n' +
                                //            'strValue:              ' + strValue + '\n' +
                                //            'Selection Start:       ' + jsnTextSelection.start + '\n' +
                                //            'Selection End:         ' + jsnTextSelection.end);

                                // if number: replace current date part
                                if ((intKeyCode >= 96 && intKeyCode <= 105) || // numpad numbers
                                    (intKeyCode >= 48 && intKeyCode <= 57)) {  // other numbers
                                    this.keyupHandle = true;

                                // if (/|-):
                                } else if (intKeyCode === 111 || intKeyCode === 191 || // "/"
                                           intKeyCode === 109 || intKeyCode === 189) { // "-"
                                    // if first part: go to second part
                                    if (intCurrentSection === 0) {
                                        intCurrentSection = 1;

                                    // if second part: go to third part
                                    } else if (intCurrentSection === 1) {
                                        intCurrentSection = 2;
                                    }

                                // if horizontal arrow: move to a different date part
                                } else if (intKeyCode === 37 || // left arrow
                                           intKeyCode === 39) { // right arrow
                                    //console.log(intCurrentSection, intKeyCode);

                                    if (intCurrentSection === 2 && intKeyCode === 37) {
                                        intCurrentSection = 1;

                                    } else if (intCurrentSection === 1) {
                                        if (intKeyCode === 37) {
                                            intCurrentSection = 0;
                                        } else {
                                            intCurrentSection = 2;
                                        }

                                    } else if (intCurrentSection === 0 && intKeyCode === 39) {
                                        intCurrentSection = 1;
                                    }

                                // if vertical arrow: update current date part
                                } else if (intKeyCode === 38 || // up arrow
                                           intKeyCode === 40) { // down arrow
                                    // If the date is in ISO format, new Date() will create it in GMT then convert it to the local timezone
                                    dteDate = new Date(strValue + ' 00:00:00');

                                    // if current part is year
                                    if (strCurrentSection === 'year') {
                                        //console.log(dteDate, dteDate.getFullYear(), dteDate.getYear(), (intKeyCode === 38 ? 1 : -1),
                                        //                        dteDate.getYear() + (intKeyCode === 38 ? 1 : -1));

                                        // We're using "getFullYear" here instead of "getYear" because "getYear" for some unknown reason
                                        //      worked fine before the 29th of october 2015 (that's the date of discovery anyway) but now
                                        //      throws a number over a thousand years off instead of the actual number.
                                        // Upon looking at the docs, "getYear" is apparently subject to the demons of y2k and no longer
                                        //      supported. Wouldn't it have been better to just make "getYear" do the dame thing as
                                        //      "getFullYear"?
                                        // Still unexplained is why when I tested not more than a week ago it worked without a hitch.
                                        dteDate.setFullYear(dteDate.getFullYear() + (intKeyCode === 38 ? 1 : -1));

                                        //console.log(dteDate);

                                    // if current part is month
                                    } else if (strCurrentSection === 'month') {
                                        dteDate.setMonth(dteDate.getMonth() + (intKeyCode === 38 ? 1 : -1));

                                    // if current part is day
                                    } else if (strCurrentSection === 'day') {
                                        dteDate.setDate(dteDate.getDate() + (intKeyCode === 38 ? 1 : -1));
                                    }

                                    // set the value
                                    strValue = formatDate(this, dteDate, strFormat);
                                    this.control.value = strValue;
                                    this.triggerChangeManually = true;
                                }

                                if (this.keyupHandle !== true) {
                                    // reset the section selection in case something has changed it
                                    if (intCurrentSection === 2) {
                                        GS.setInputSelection(this.control, delimiter2index + 1, strValue.length);

                                    } else if (intCurrentSection === 1) {
                                        GS.setInputSelection(this.control, delimiter1index + 1, delimiter2index);

                                    } else {
                                        GS.setInputSelection(this.control, 0, delimiter1index);
                                    }
                                }

                                // if not return or tab or number: prevent
                                if (!(intKeyCode >= 96 && intKeyCode <= 105) && // numpad numbers
                                    !(intKeyCode >= 48 && intKeyCode <= 57) &&
                                    intKeyCode !== 13 && // return/enter
                                    intKeyCode !== 9) {  // tab
                                    event.preventDefault();
                                }
                            }
                        }
                    }
                }
            },
            keyup: function (event) {
                var jsnTextSelection, intStart, intEnd, strFormat, strValue,
                    intKeyCode = (event.keyCode || event.which),
                    delimiter1index, delimiter2index, intCurrentSection, strCurrentSection,
                    arrParts, dteDate, intCurrentSectionSize, jsnState;

                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted') && !this.hasAttribute('readonly')) {
                    strFormat = getFormatString(this);

                    // if format is dash delimited or slash delimited and
                    //      keyup has been allowed and
                    //      we are not on a touch device
                    if ((/^[M|y]{1,}[/|-]{1}[M|d]{1,}[/|-]{1}[d|y]{1,}$/).test(strFormat) && this.keyupHandle && !evt.touchDevice) {

                        // if shift, command and option keys are not down
                        if (!event.shiftKey && !event.metaKey && !event.ctrlKey) {
                            jsnState = getControlState(this)
                            jsnTextSelection =      jsnState.jsnTextSelection
                            intStart =              jsnState.intStart
                            intEnd =                jsnState.intEnd
                            strFormat =             jsnState.strFormat
                            strValue =              jsnState.strValue
                            delimiter1index =       jsnState.delimiter1index
                            delimiter2index =       jsnState.delimiter2index
                            intCurrentSection =     jsnState.intCurrentSection
                            strCurrentSection =     jsnState.strCurrentSection
                            arrParts =              jsnState.arrParts
                            intCurrentSectionSize = jsnState.intCurrentSectionSize

                            //// log
                            //console.log('intCurrentSectionSize: ' + intCurrentSectionSize + '\n' +
                            //            'intCurrentSection:     ' + intCurrentSection + '\n' +
                            //            'delimiter1index:       ' + delimiter1index + '\n' +
                            //            'delimiter2index:       ' + delimiter2index + '\n' +
                            //            'strValue.length:       ' + strValue.length + '\n' +
                            //            'strCurrentSection:     ' + strCurrentSection + '\n' +
                            //            'strValue:              ' + strValue + '\n' +
                            //            'strFormat:             ' + strFormat);

                            if ((strCurrentSection === 'day' && intCurrentSectionSize === 2) ||
                                (strCurrentSection === 'month' && intCurrentSectionSize === 2) ||
                                (strCurrentSection === 'year' && intCurrentSectionSize === strFormat.match(/y/g).length)) {

                                if (intCurrentSection === 2) {
                                    GS.setInputSelection(this.control, delimiter2index + 1, strValue.length);

                                } else if (intCurrentSection === 1) {
                                    GS.setInputSelection(this.control, delimiter1index + 1, delimiter2index);

                                } else {
                                    GS.setInputSelection(this.control, 0, delimiter1index);
                                }
                            }
                        }
                    }
                    this.keyupHandle = false;

                    //console.log(intKeyCode);
                    if (intKeyCode === 13 && this.triggerChangeManually) {
                        this.triggerChangeManually = false;
                        GS.triggerEvent(this, 'change');
                    }
                }
            },
            focusout: function () {
                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    //console.log(this.triggerChangeManually);
                    if (this.triggerChangeManually) {
                        this.triggerChangeManually = false;
                        GS.triggerEvent(this, 'change');
                    }
                }
            }


            /*// on keydown and keyup sync the value attribute and the control value
            keydown: function (event) {
                var element = this, currentDate, currentSelectionRange, currentSelectionText, currentSelectionNumber, currentSelectionFormatText,
                    currentValue, newValue, strDateFormat, formatDivider, arrMatch, currentFieldRange, newCursorPos, newFieldValue,
                    daysOfTheWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                    monthsOfTheYear = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                    strKeyCode = event.keyCode.toString();

                currentSelectionRange = GS.getInputSelection(element.control);

                if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (element.getAttribute('disabled') !== null && event.keyCode !== 9) {
                        event.preventDefault();
                        event.stopPropagation();
                    } else {
                        //console.log(strKeyCode === GS.keyCode('left arrow')  , GS.keyCode('left arrow') );
                        //console.log(strKeyCode === GS.keyCode('up arrow')    , GS.keyCode('up arrow'));
                        //console.log(strKeyCode === GS.keyCode('right arrow') , GS.keyCode('right arrow'));
                        //console.log(strKeyCode === GS.keyCode('down arrow')  , GS.keyCode('down arrow'));

                        // When the user presses an arrow key:
                        // It finds the current number that the user has selected
                        //     If they pressed up or down
                        //         (inc/dec)rement the current number (handling day and month names of course)
                        //     If they pressed left or right
                        //         Move their selection to the left or right depending on what they pressed
                        // Then moves the selection to the current number (handling day/month name length differences)

                        // Fix date format
                        strDateFormat = element.getAttribute('format');
                        //console.log(strDateFormat);
                        if (!strDateFormat) {
                            strDateFormat = 'MM/dd/yyyy';
                        } else if (strDateFormat.toLowerCase() === 'shortdate') {
                            strDateFormat = 'M/d/yy';
                        } else if (strDateFormat.toLowerCase() === 'mediumdate') {
                            strDateFormat = 'MMM d, yyyy';
                        } else if (strDateFormat.toLowerCase() === 'longdate') {
                            strDateFormat = 'MMMM d, yyyy';
                        } else if (strDateFormat.toLowerCase() === 'fulldate') {
                            strDateFormat = 'EEEE, MMMM d, yyyy';
                        } else if (strDateFormat.toLowerCase() === 'shorttime') {
                            strDateFormat = 'h:mm a';
                        } else if (strDateFormat.toLowerCase() === 'mediumtime') {
                            strDateFormat = 'h:mm:ss a';
                        } else if (strDateFormat.toLowerCase() === 'isodate') {
                            strDateFormat = 'yyyy-MM-dd';
                        } else if (strDateFormat.toLowerCase() === 'isotime') {
                            strDateFormat = 'HH:mm:ss';
                        } else if (strDateFormat.toLowerCase() === 'isodatetime') {
                            strDateFormat = 'yyyy-MM-dd\'T\'HH:mm:ss';
                        }

                        formatDivider = strDateFormat.match(/[^mdyehmsa]/gi).join('');

                        currentValue = element.control.value;
                        currentDate = new Date(currentValue.replace('\'T\'', ' ').replace(/-/g, '/'));

                        if (strDateFormat.indexOf('M') === -1) {
                            currentDate = new Date('2015/6/15 ' + currentValue);
                        }

                        arrMatch = strDateFormat.match(/(M|E)+/g);
                        if (arrMatch && arrMatch[0].length > 3) {
                            strDateFormat = strDateFormat.replace(/E+/g, new Array(daysOfTheWeek[currentDate.getDay()].length + 1).join('E'));
                            strDateFormat = strDateFormat.replace(/M+/g, new Array(monthsOfTheYear[currentDate.getDay()].length + 1).join('M'));
                        }

                        // If it was an arrow that was pressed
                        if (strKeyCode === GS.keyCode('left arrow') ||
                            strKeyCode === GS.keyCode('up arrow') ||
                            strKeyCode === GS.keyCode('right arrow') ||
                            strKeyCode === GS.keyCode('down arrow')) {

                            //console.log('test');

                            // Prevent the browser from moving the cursor and prevent envelope from using arrows
                            event.preventDefault();
                            event.stopPropagation();

                            //console.log(currentValue, formatDivider, currentSelectionRange.start, currentSelectionRange.end);

                            // Encompass the field in which the cursor is inside
                            while (currentSelectionRange.start >= 0 && formatDivider.indexOf(currentValue[currentSelectionRange.start - 1]) < 0) {
                                currentSelectionRange.start -= 1;
                            }

                            currentSelectionRange.end = currentSelectionRange.start;
                            while ( currentSelectionRange.end < currentValue.length &&
                                    formatDivider.indexOf(currentValue[currentSelectionRange.end]) < 0) {
                                currentSelectionRange.end += 1;
                            }

                            //console.log(currentValue, currentSelectionRange.start, currentSelectionRange.end);

                            GS.setInputSelection(element.control, currentSelectionRange.start, currentSelectionRange.end);

                            currentSelectionText = currentValue.substring(currentSelectionRange.start, currentSelectionRange.end);
                            currentSelectionFormatText = strDateFormat.substring(currentSelectionRange.start, currentSelectionRange.end);

                            // If it is up or down
                            if (strKeyCode === GS.keyCode('up arrow') ||
                                strKeyCode === GS.keyCode('down arrow')) {
                                var increment = strKeyCode === GS.keyCode('up arrow') ? 1 : -1;

                                if (currentSelectionFormatText[0] === 'M') {
                                    currentDate.setMonth(currentDate.getMonth() +       increment);
                                    if ((currentSelectionRange.end - currentSelectionRange.start) > 2) {
                                        currentSelectionRange.end = currentSelectionRange.start + currentSelectionText.indexOf(' ');
                                    } else {
                                        currentSelectionRange.end = currentSelectionRange.start + currentDate.getMonth().toString().length;
                                    }

                                } else if (currentSelectionFormatText[0] === 'd') {
                                    currentDate.setDate(currentDate.getDate() + increment);
                                    currentSelectionRange.end = currentSelectionRange.start + currentDate.getDate().toString().length;

                                } else if (currentSelectionFormatText[0] === 'y') {
                                    currentDate.setFullYear(currentDate.getFullYear() + increment);
                                    currentSelectionRange.end = currentSelectionRange.start + currentDate.getFullYear().toString().length;

                                } else if (currentSelectionFormatText[0] === 'E') {
                                    currentDate.setDate(currentDate.getDate() + increment);
                                    currentSelectionRange.start = 0;
                                    currentSelectionRange.end = daysOfTheWeek[currentDate.getDay()].length;

                                } else if (currentSelectionFormatText[0] === 'h' || currentSelectionFormatText[0] === 'H') {
                                    currentDate.setHours(currentDate.getHours() + increment);
                                    currentSelectionRange.end = currentSelectionRange.start + currentDate.getHours().toString().length;

                                } else if (currentSelectionFormatText[0] === 'm') {
                                    currentDate.setMinutes(currentDate.getMinutes() + increment);
                                    currentSelectionRange.end = currentSelectionRange.start + currentDate.getMinutes().toString().length;

                                } else if (currentSelectionFormatText[0] === 's') {
                                    currentDate.setSeconds(currentDate.getSeconds() + increment);
                                    currentSelectionRange.end = currentSelectionRange.start + currentDate.getSeconds().toString().length;

                                } else if (currentSelectionFormatText[0] === 'a') {
                                    currentDate.setHours(currentDate.getHours() + 12);
                                }

                                newValue = formatDate(element, currentDate, strDateFormat);
                                this.control.value = newValue;
                                currentValue = newValue;
                            } else if (strKeyCode === GS.keyCode('left arrow')) {
                                currentSelectionRange.end = currentSelectionRange.start - 2;
                                currentSelectionRange.start = currentSelectionRange.end;
                            } else if (strKeyCode === GS.keyCode('right arrow')) {
                                currentSelectionRange.end = currentSelectionRange.end + 2;
                                currentSelectionRange.start = currentSelectionRange.end;
                            }

                            // Copied from above
                            arrMatch = strDateFormat.match(/(M|E)+/g);
                            if (arrMatch && arrMatch[0].length > 3) {
                                strDateFormat = strDateFormat.replace(/E+/g, new Array(daysOfTheWeek[currentDate.getDay()].length + 1).join('E'));
                                strDateFormat = strDateFormat.replace(/M+/g, new Array(monthsOfTheYear[currentDate.getDay()].length + 1).join('M'));
                            }
                            while (currentSelectionRange.start >= 0 && formatDivider.indexOf(currentValue[currentSelectionRange.start - 1]) < 0) {
                                currentSelectionRange.start -= 1;
                            }
                            currentSelectionRange.end = currentSelectionRange.start;
                            while ( currentSelectionRange.end < currentValue.length &&
                                    formatDivider.indexOf(currentValue[currentSelectionRange.end]) < 0) {
                                currentSelectionRange.end += 1;
                            }

                            GS.setInputSelection(element.control, currentSelectionRange.start, currentSelectionRange.end);

                        // All number keys
                        } else if (event.keyCode >= 96 && event.keyCode <= 105) {
                            //// HARK YE ONLOOKER:
                            //// This code caps the number that is inputed by the user to the length that the format allows,
                            //// this will dissallow anyone form entering a year that is > 4 characters unless the
                            //// page's developer allows it in a custom format.
                            ////
                            //// This should be fixed around the year 9998 to have all default formats have 5 character years

                            currentSelectionText = currentValue.substring(currentSelectionRange.start, currentSelectionRange.end);
                            currentSelectionFormatText = strDateFormat.substring(currentSelectionRange.start, currentSelectionRange.end);

                            currentValue = element.value;

                            // This is sort of copied from above
                            // There are only two differences:
                            //     the var name
                            //     the initialization on the next line
                            currentFieldRange = {
                                start: currentSelectionRange.start
                            };
                            while (currentFieldRange.start >= 0 && formatDivider.indexOf(currentValue[currentFieldRange.start - 1]) < 0) {
                                currentFieldRange.start -= 1;
                            }
                            currentFieldRange.end = currentFieldRange.start;
                            while ( currentFieldRange.end < currentValue.length &&
                                    formatDivider.indexOf(currentValue[currentFieldRange.end]) < 0) {
                                currentFieldRange.end += 1;
                            }

                            //console.log(currentFieldRange);

                            //console.log(currentValue.substring(0, currentSelectionRange.start));
                            //console.log(GS.charFromKeyCode(event), currentSelectionText, currentSelectionFormatText, currentDate);
                            //console.log(currentValue.substring(currentSelectionRange.end));

                            // This error checking is probably unneeded, but what the hey
                            currentFieldRange.start = Math.max(currentFieldRange.start, 0);
                            arrMatch = strDateFormat.match(strDateFormat[currentFieldRange.start] + '+', 'g');
                            if (arrMatch) {
                                // Prevent the browser from putting the number in for us
                                event.preventDefault();

                                // Get the character that they pressed
                                newFieldValue = GS.charFromKeyCode(event);
                              //console.log(newFieldValue);
                                // Cap the length to the format field's length by using
                                // all characters in the field except the first one
                                newFieldValue = currentValue.substring(currentFieldRange.start + 1, currentFieldRange.start + arrMatch[0].length) + newFieldValue;
                              //console.log(newFieldValue, currentValue);

                              //console.log(currentFieldRange.start + 1, currentFieldRange.start + arrMatch[0].length);

                                // Build the value using the current field range and the new field value we built above
                                element.value =
                                    currentValue.substring(0, currentFieldRange.start) +
                                    newFieldValue +
                                    currentValue.substring(currentFieldRange.end);


                              //console.log(currentValue.substring(0, currentFieldRange.start), newFieldValue, currentValue.substring(currentFieldRange.end));

                                // This is copied from above
                                currentFieldRange = {
                                    start: currentSelectionRange.start
                                };
                                while (currentFieldRange.start >= 0 && formatDivider.indexOf(currentValue[currentFieldRange.start - 1]) < 0) {
                                    currentFieldRange.start -= 1;
                                }
                                currentFieldRange.end = currentFieldRange.start;
                                while ( currentFieldRange.end < currentValue.length &&
                                        formatDivider.indexOf(currentValue[currentFieldRange.end]) < 0) {
                                    currentFieldRange.end += 1;
                                }

                                //                                                                          This indexOf does not need to be checked for -1
                                //                                                                          Because we know for a fact that the match is in
                                //                                                                          the string we are searching
                                newCursorPos = Math.min(currentFieldRange.start + arrMatch[0].length, strDateFormat.indexOf(arrMatch[0]) + arrMatch[0].length);
                                newCursorPos = Math.max(newCursorPos, currentFieldRange.end);
                                //console.log(arrMatch[0].length, strDateFormat.indexOf(arrMatch[0]), newCursorPos, arrMatch[0]);
                                GS.setInputSelection(element.control, newCursorPos, newCursorPos);
                            }

                        }

                        //// All visible keys
                        //} else if ( event.keyCode >= 48 && event.keyCode <= 90 ||
                        //            event.keyCode >= 96 && event.keyCode <= 109 ||
                        //            event.keyCode >= 186 && event.keyCode <= 222 ||
                        //            event.keyCode === 32) {
                        //    //console.log('test');
                        //
                        //    //GS.triggerEvent(element, 'change');
                        //
                        //    if ((currentSelectionRange.end - currentSelectionRange.start) > 0) {
                        //        element.control.addEventListener('keyup', function ______self() {
                        //            GS.setInputSelection(this, currentSelectionRange.start + 1, currentSelectionRange.start) + 1;
                        //            this.removeEventListener('keyup', ______self);
                        //        });
                        //    }
                        //}

                        //console.log(event.keyCode);

                        syncView(element);
                    }
                }
            },
            keyup: function () {
                var element = this;
                if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    syncView(element);
                }
            },
            click: function () {
                var element = this, currentSelectionRange = GS.getInputSelection(element.control),
                    daysOfTheWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                    monthsOfTheYear = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                    arrMatch, strDateFormat, formatDivider, currentValue, currentDate;
                //console.log(currentSelectionRange.start, currentSelectionRange.end);

                ////// Copied from above until otherwise noted

                // Fix date format
                strDateFormat = element.getAttribute('format');
                //console.log(strDateFormat);
                if (!strDateFormat) {
                    strDateFormat = 'MM/dd/yyyy';
                } else if (strDateFormat.toLowerCase() === 'shortdate') {
                    strDateFormat = 'M/d/yy';
                } else if (strDateFormat.toLowerCase() === 'mediumdate') {
                    strDateFormat = 'MMM d, yyyy';
                } else if (strDateFormat.toLowerCase() === 'longdate') {
                    strDateFormat = 'MMMM d, yyyy';
                } else if (strDateFormat.toLowerCase() === 'fulldate') {
                    strDateFormat = 'EEEE, MMMM d, yyyy';
                } else if (strDateFormat.toLowerCase() === 'shorttime') {
                    strDateFormat = 'h:mm a';
                } else if (strDateFormat.toLowerCase() === 'mediumtime') {
                    strDateFormat = 'h:mm:ss a';
                } else if (strDateFormat.toLowerCase() === 'isodate') {
                    strDateFormat = 'yyyy-MM-dd';
                } else if (strDateFormat.toLowerCase() === 'isotime') {
                    strDateFormat = 'HH:mm:ss';
                } else if (strDateFormat.toLowerCase() === 'isodatetime') {
                    strDateFormat = 'yyyy-MM-dd\'T\'HH:mm:ss';
                }

                formatDivider = strDateFormat.match(/[^mdyehmsa]/gi).join('');

                currentValue = element.control.value;
                currentDate = new Date(currentValue.replace('\'T\'', ' ').replace(/-/g, '/'));

                if (strDateFormat.indexOf('M') === -1) {
                    currentDate = new Date('2015/6/15 ' + currentValue);
                }

                arrMatch = strDateFormat.match(/(M|E)+/g);
                if (arrMatch && arrMatch[0].length > 3) {
                    strDateFormat = strDateFormat.replace(/E+/g, new Array(daysOfTheWeek[currentDate.getDay()].length + 1).join('E'));
                    strDateFormat = strDateFormat.replace(/M+/g, new Array(monthsOfTheYear[currentDate.getDay()].length + 1).join('M'));
                }

                while (currentSelectionRange.start >= 0 && formatDivider.indexOf(currentValue[currentSelectionRange.start - 1]) < 0) {
                    currentSelectionRange.start -= 1;
                }
                currentSelectionRange.end = currentSelectionRange.start;
                while ( currentSelectionRange.end < currentValue.length &&
                        formatDivider.indexOf(currentValue[currentSelectionRange.end]) < 0) {
                    currentSelectionRange.end += 1;
                }
                //console.log(currentSelectionRange.start, currentSelectionRange.end);

                ////// Not copied
                element.ignoreSelect = true;
                GS.setInputSelection(element.control, currentSelectionRange.start, currentSelectionRange.end);

                //console.log('CLICK EVENT FIRED');
            },
            focus: function () {
                GS.triggerEvent(this, 'click');
            },
            select: function () {
                //if (!this.ignoreSelect) {
                //    GS.triggerEvent(this, 'click');
                //    this.ignoreSelect = false;
                //}
                //console.log('SELECT EVENT FIRED', GS.getInputSelection(this.control));

                // Copied from click handler until otherwise noted
                var element = this, currentSelectionRange = GS.getInputSelection(element.control),
                    daysOfTheWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                    monthsOfTheYear = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                    arrMatch, strDateFormat, formatDivider, currentValue, currentDate;
                //console.log(currentSelectionRange.start, currentSelectionRange.end);

                ////// Copied from above until otherwise noted

                // Fix date format
                strDateFormat = element.getAttribute('format');
                //console.log(strDateFormat);
                if (!strDateFormat) {
                    strDateFormat = 'MM/dd/yyyy';
                } else if (strDateFormat.toLowerCase() === 'shortdate') {
                    strDateFormat = 'M/d/yy';
                } else if (strDateFormat.toLowerCase() === 'mediumdate') {
                    strDateFormat = 'MMM d, yyyy';
                } else if (strDateFormat.toLowerCase() === 'longdate') {
                    strDateFormat = 'MMMM d, yyyy';
                } else if (strDateFormat.toLowerCase() === 'fulldate') {
                    strDateFormat = 'EEEE, MMMM d, yyyy';
                } else if (strDateFormat.toLowerCase() === 'shorttime') {
                    strDateFormat = 'h:mm a';
                } else if (strDateFormat.toLowerCase() === 'mediumtime') {
                    strDateFormat = 'h:mm:ss a';
                } else if (strDateFormat.toLowerCase() === 'isodate') {
                    strDateFormat = 'yyyy-MM-dd';
                } else if (strDateFormat.toLowerCase() === 'isotime') {
                    strDateFormat = 'HH:mm:ss';
                } else if (strDateFormat.toLowerCase() === 'isodatetime') {
                    strDateFormat = 'yyyy-MM-dd\'T\'HH:mm:ss';
                }

                formatDivider = strDateFormat.match(/[^mdyehmsa]/gi).join('');

                currentValue = element.control.value;
                currentDate = new Date(currentValue.replace('\'T\'', ' ').replace(/-/g, '/'));

                if (strDateFormat.indexOf('M') === -1) {
                    currentDate = new Date('2015/6/15 ' + currentValue);
                }

                arrMatch = strDateFormat.match(/(M|E)+/g);
                if (arrMatch && arrMatch[0].length > 3) {
                    strDateFormat = strDateFormat.replace(/E+/g, new Array(daysOfTheWeek[currentDate.getDay()].length + 1).join('E'));
                    strDateFormat = strDateFormat.replace(/M+/g, new Array(monthsOfTheYear[currentDate.getDay()].length + 1).join('M'));
                }

                // Condition copied only
                if ((currentSelectionRange.start >= 0 && formatDivider.indexOf(currentValue[currentSelectionRange.start - 1]) < 0) ||
                    (currentSelectionRange.end < currentValue.length && formatDivider.indexOf(currentValue[currentSelectionRange.end]) < 0)) {
                    GS.triggerEvent(this, 'click');
                    this.ignoreSelect = false;
                }
            }*/
        },
        accessors: {
            value: {
                // get value straight from the input
                get: function () {
                    if (this.control) {
                        return this.control.value;
                    } else if (this.hasAttribute('disabled')) {
                        return this.innerHTML;
                    }

                    return undefined;
                },

                // set the value of the input and set the value attribute
                set: function (newValue) {
                    var tempSelection = this.control ? GS.getInputSelection(this.control) : null;

                    if (this.control) {
                      //console.log(newValue);
                        if (newValue && typeof newValue === 'object') {
                            this.control.value = newValue.toLocaleDateString();
                        } else {
                            this.control.value = newValue || '';
                        }

                        if (document.activeElement === this.control) {
                           GS.setInputSelection(this.control, tempSelection.start, tempSelection.end);
                        }

                    } else if (this.hasAttribute('disabled')) {
                        if (newValue && typeof newValue === 'object') {
                            this.innerHTML = formatDate(this, newValue, getFormatString(this));
                        } else {
                          //console.log(newValue);
                            this.innerHTML = newValue || '';
                        }

                    } else {
                      //console.log(newValue);
                        this.setAttribute('value', newValue);
                    }

                    if (this.control) {
                        handleFormat(this);
                    }
                    syncView(this);
                }
            }
        },
        methods: {
            refresh: function () {
                var element = this, arrPassThroughAttributes, i, len;

                // set a variable for the control element for convenience and speed
                element.control = xtag.query(element, '.control')[0];
                // set a variable for the date picker button element for convenience and speed
                element.datePickerButton = xtag.query(element, '.date-picker-button')[0];

                //console.log(element.control, element.getAttribute('value'), element.getAttribute('column'));

                if (element.control) {
                    if (element.hasAttribute('id')) {
                        element.control.setAttribute('id', element.getAttribute('id') + '_control');
                    }
                    if (element.hasAttribute('aria-labelledby')) {
                        element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                    }
                    if (element.hasAttribute('title')) {
                        element.control.setAttribute('title', element.getAttribute('title'));
                    }

                    element.control.removeEventListener('change', changeFunction);
                    element.control.addEventListener('change', changeFunction);

                    element.control.removeEventListener('focus', focusFunction);
                    element.control.addEventListener('focus', focusFunction);

                    element.control.removeEventListener('blur', blurFunction);
                    element.control.addEventListener('blur', blurFunction);

                    element.control.removeEventListener(evt.mouseout, mouseoutFunction);
                    element.control.addEventListener(evt.mouseout, mouseoutFunction);

                    element.control.removeEventListener(evt.mouseout, mouseoverFunction);
                    element.control.addEventListener(evt.mouseover, mouseoverFunction);
                }
                if (element.datePickerButton) {
                    element.datePickerButton.addEventListener('click', buttonClickFunction);
                }

                // if there is a value already in the attributes of the element: set the control value
                if (element.control && element.hasAttribute('value')) {
                    element.control.value = element.getAttribute('value');
                    handleFormat(element, undefined, false);
                }

                if (element.control) {
                // copy passthrough attributes to control
                    arrPassThroughAttributes = [
                        'placeholder',
                        'name',
                        'maxlength',
                        'autocorrect',
                        'autocapitalize',
                        'autocomplete',
                        'autofocus',
                        'spellcheck',
                        'readonly'
                    ];
                    for (i = 0, len = arrPassThroughAttributes.length; i < len; i += 1) {
                        if (element.hasAttribute(arrPassThroughAttributes[i])) {
                            element.control.setAttribute(arrPassThroughAttributes[i], element.getAttribute(arrPassThroughAttributes[i]) || '');
                        }
                    }
                }
            },

            focus: function () {
                GS.triggerEvent(this, 'focus');
                this.control.focus();
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, addFocusEvents
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';

    addSnippet('<gs-datetime>', '<gs-datetime>', 'gs-datetime></gs-datetime>');

    // TODO: there is no documentation
    // designRegisterElement('gs-datetime', '#');

    window.designElementProperty_GSDATETIME = function() {
        addGSControlProps();
        addText('O', 'Column In QS', 'qs');
        addCheck('V', 'Calendar on desktop', 'desktop-calendar');
        addText('V', 'Placeholder', 'placeholder');
        addFocusEvents();
        addFlexProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    function transformCSS(css) {
        return  '-webkit-transform: ' + css + '; ' +
                '-moz-transform: ' + css + '; ' +
                '-ms-transform: ' + css + '; ' +
                '-o-transform: ' + css + '; ' +
                'transform: ' + css + ';';
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    /***************** DATETIME CALENDAR *****************/
    
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function datetimeOpenCalendarDialog(element) {
        'use strict';
        var i, len, dateHTML, timeHTML, pickerHTML, dialogHTML, dialogTemplate = document.createElement('template');
        var dteToday = new Date(), dteValue = element.dteValue || new Date(dteToday);

        dateHTML = ml(function () {/*
            <div class="adjust-section date-adjust-section centered">
                <div class="date-today">&#xf017;</div>
                <div class="date-input">
                    <input class="month" />
                    <span class="divider">/</span>
                    <input class="day" />
                    <span class="divider">/</span>
                    <input class="year" />
                </div>
                <div class="adjust-container">
                    <div class="date-adjust up">&#xf077;</div><div class="date-adjust down">&#xf078;</div>
                </div>
            </div>
            <div class="calendar centered">
                <gs-button class="month-letter" month="0" remove-right>J</gs-button><gs-button class="month-letter" month="1" remove-all>F</gs-button><gs-button class="month-letter" month="2" remove-all>M</gs-button><gs-button class="month-letter" month="3" remove-all>A</gs-button><gs-button class="month-letter" month="4" remove-all>M</gs-button><gs-button class="month-letter" month="5" remove-all>J</gs-button><gs-button class="month-letter" month="6" remove-all>J</gs-button><gs-button class="month-letter" month="7" remove-all>A</gs-button><gs-button class="month-letter" month="8" remove-all>S</gs-button><gs-button class="month-letter" month="9" remove-all>O</gs-button><gs-button class="month-letter" month="10" remove-all>N</gs-button><gs-button class="month-letter" month="11" remove-left>D</gs-button>
                <div flex-horizontal>
                    <gs-button icononly icon="chevron-left" class="month-adjust down"></gs-button>

                    <center flex class="month-label"></center>

                    <gs-button icononly icon="chevron-right" class="month-adjust up"></gs-button>
                </div>
                <div flex-horizontal>
                    <gs-button icononly icon="chevron-left" class="year-adjust down"></gs-button>

                    <center flex class="year-label"></center>

                    <gs-button icononly icon="chevron-right" class="year-adjust up"></gs-button>
                </div>
                <div>
                    <div class="day-letter">S</div><div class="day-letter">M</div><div class="day-letter">T</div><div class="day-letter">W</div><div class="day-letter">T</div><div class="day-letter">F</div><div class="day-letter">S</div>
                </div>
            </div>
        */});

        timeHTML = ml(function () {/*
            <div class="time-section">
                <div class="adjust-section time-adjust-section centered">
                    <div class="time-now">&#xf017;</div>
                    <div class="time-input">
                        <input class="hour" />
                        <span class="divider">:</span>
                        <input class="minute" />
                        <span class="divider">:</span>
                        <input class="second" />
                        <span class="divider"> </span>
                        <input class="ampm" />
                    </div>
                    <div class="adjust-container">
                        <div class="time-adjust up">&#xf077;</div><div class="time-adjust down">&#xf078;</div>
                    </div>
                </div>
                <div class="clock-parent">
                    <div class="clock"></div>
                </div>
            </div>
        */});

        if (element.hasDate && element.hasTime) {
            pickerHTML = ml(function () {/*
                <gs-grid widths="1,1">
                    <gs-block>
                        {{DATEHTML}}
                    </gs-block>
                    <gs-block>
                        {{TIMEHTML}}
                    </gs-block>
                </gs-grid>
            */}).replace('{{DATEHTML}}', dateHTML).replace('{{TIMEHTML}}', timeHTML);

        } else if (element.hasDate) {
            pickerHTML = dateHTML;

        } else if (element.hasTime) {
            pickerHTML = timeHTML;

        }

        dialogHTML = ml(function () {/*
            <gs-body class="gs-datetime-calendar-dialog">
                {{PICKERHTML}}
                <gs-grid widths="1,1">
                    <gs-block>
                        <gs-button dialogclose>Cancel</gs-button>
                    </gs-block>
                    <gs-block>
                        <gs-button dialogclose bg-primary>Done</gs-button>
                    </gs-block>
                </gs-grid>
            </gs-body>
        */}).replace('{{PICKERHTML}}', pickerHTML);
        dialogTemplate.innerHTML = dialogHTML;
        dialogTemplate.setAttribute('no-background', '');
        dialogTemplate.setAttribute('data-overlay-close', '');
        if (!element.hasTime) {
            dialogTemplate.setAttribute('data-max-width', '25em');
        }
        GS.openDialogToElement(element, dialogTemplate, 'down', function () {
            var dteStart = new Date(dteValue);

            var refreshDateInputs = function () {};
            var refreshTimeInputs = function () {};

            var regenerateCalendar = function () {};
            var resetClock = function () {};

            if (element.hasDate) {
                var dialog = this;

                var calendar = xtag.query(dialog, '.calendar')[0];
                var dateAdjustSection = xtag.query(dialog, '.date-adjust-section')[0];
                var dateInput = xtag.query(dateAdjustSection, '.date-input')[0];

                var dayInput = xtag.query(dateInput, '.day')[0];
                var monthInput = xtag.query(dateInput, '.month')[0];
                var yearInput = xtag.query(dateInput, '.year')[0];

                var monthLabel = xtag.query(calendar, '.month-label')[0];
                var yearLabel = xtag.query(calendar, '.year-label')[0];
                var arrMonth = [
                    'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
                ];
                
                if (element.hasAttribute('spanish')) {
                    var arrMonth = [
                        'Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'
                    ];
                } else {
                    var arrMonth = [
                        'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
                    ];
                }

                refreshDateInputs = function () {
                    dayInput.value = GS.leftPad(dteValue.getDate(), '0', 2);
                    monthInput.value = GS.leftPad(dteValue.getMonth() + 1, '0', 2);
                    yearInput.value = dteValue.getFullYear();

                    if (dateInput.selectText) {
                        GS.setInputSelection(dateInput.selectText, 0, dateInput.selectText.value.length);
                        dateInput.selectText = null;
                    }
                };
                refreshDateInputs();

                regenerateCalendar = function (dteStart) {
                    var children = xtag.queryChildren(calendar, '.day');
                    for (var i = 0, len = children.length; i < len; i += 1) {
                        calendar.removeChild(children[i]);
                    }

                    var dteCurrent = new Date(dteStart), intCurrentMonth = dteCurrent.getMonth(), intNextMonth = intCurrentMonth + 1;
                    if (intNextMonth === 12) {
                        intNextMonth = 0;
                    }

                    monthLabel.innerText = arrMonth[dteStart.getMonth()];
                    yearLabel.innerText = dteStart.getFullYear();

                    dteCurrent.setDate(1);
                    dteCurrent.setDate(dteCurrent.getDate() - dteCurrent.getDay());

                    while (dteCurrent.getMonth() !== intNextMonth || dteCurrent.getDay() !== 0) {
                        var day = document.createElement('div');
                        day.classList.add('day');
                        day.innerText = dteCurrent.getDate();
                        if (dteCurrent.getMonth() !== intCurrentMonth) {
                            day.classList.add('grey');
                        }
                        if (dteCurrent.getMonth() === dteToday.getMonth() && dteCurrent.getFullYear() === dteToday.getFullYear() && dteCurrent.getDate() === dteToday.getDate()) {
                            day.classList.add('today');
                            if (!element.hasAttribute('show-today')) {
                                day.innerText = 'T';
                            }
                        }
                        if (dteCurrent.getMonth() === dteValue.getMonth() && dteCurrent.getFullYear() === dteValue.getFullYear() && dteCurrent.getDate() === dteValue.getDate()) {
                            day.classList.add('selected');
                        }
                        day.value = new Date(dteCurrent);
                        calendar.appendChild(day);

                        dteCurrent.setDate(dteCurrent.getDate() + 1);
                    }
                };
                regenerateCalendar(dteStart);

                dateInput.addEventListener('keyup', function (event) {
                    var code = event.which || event.keyCode || event.charCode;
                    var dtePreviousValue = new Date(dteValue);
                    // 37: left
                    // 38: up
                    // 39: right
                    // 40: down
                    if (code === 38 || code === 40) {
                        event.target.value = GS.leftPad((parseInt(event.target.value, 10) + (code === 38 ? 1 : -1)).toString(), '0', 2);
                        dateInput.selectText = event.target;
                        event.preventDefault();
                    }

                    if (event.target.classList.contains('year') && code === 37) {
                        xtag.query(dateInput, '.day')[0].focus();
                        event.preventDefault();

                    } else if (event.target.classList.contains('year') && code === 39) {
                        event.preventDefault();

                    } else if (event.target.classList.contains('year')) {
                        dteValue.setFullYear(event.target.value);
                        dteStart = new Date(dteValue);
                        event.target.value = dteValue.getFullYear();

                    } else if (event.target.classList.contains('month') && code === 37) {
                        event.preventDefault();

                    } else if (event.target.classList.contains('month') && code === 39) {
                        xtag.query(dateInput, '.day')[0].focus();
                        event.preventDefault();

                    } else if (event.target.classList.contains('month')) {
                        event.target.value = GS.leftPad(event.target.value.substring(0, 2), '0', 2);
                        dteValue.setMonth(parseInt(event.target.value, 10) - 1);
                        dteStart = new Date(dteValue);
                        event.target.value = GS.leftPad(dteValue.getMonth() + 1, '0', 2);

                    } else if (event.target.classList.contains('day') && code === 37) {
                        xtag.query(dateInput, '.month')[0].focus();
                        event.preventDefault();

                    } else if (event.target.classList.contains('day') && code === 39) {
                        xtag.query(dateInput, '.year')[0].focus();
                        event.preventDefault();

                    } else if (event.target.classList.contains('day')) {
                        dteValue.setDate(event.target.value);
                        event.target.value = GS.leftPad(dteValue.getDate(), '0', 2);
                        dteStart = new Date(dteValue);
                    }

                    if (dtePreviousValue.getTime() !== dteValue.getTime()) {
                        refreshDateInputs();
                        regenerateCalendar(dteStart);
                    }
                });

                dateAdjustSection.addEventListener('mousedown', function (event) {
                    if (event.target.nodeName.toUpperCase() !== 'INPUT') {
                        event.preventDefault();
                    }
                });

                dateAdjustSection.addEventListener('click', function (event) {
                    var dtePreviousValue = new Date(dteValue);
                    var activeElement = document.activeElement; // just to shorten things a bit

                    if (activeElement.parentNode.classList.contains('date-input') && event.target.classList.contains('date-adjust')) {
                        activeElement.value = GS.leftPad((parseInt(activeElement.value, 10) + (event.target.classList.contains('up') ? 1 : -1)).toString(), '0', 2);
                        dateInput.selectText = activeElement;

                        if (activeElement.classList.contains('year')) {
                            dteValue.setFullYear(activeElement.value);

                        } else if (activeElement.classList.contains('month')) {
                            dteValue.setMonth(parseInt(activeElement.value, 10) - 1);

                        } else if (activeElement.classList.contains('day')) {
                            dteValue.setDate(activeElement.value);
                        }
                        dteStart = new Date(dteValue);

                    } else if (event.target.classList.contains('date-today')) {
                        dteValue.setFullYear(dteToday.getFullYear());
                        dteValue.setMonth(dteToday.getMonth());
                        dteValue.setDate(dteToday.getDate());

                        dteStart = new Date(dteValue);

                    }

                    if (dtePreviousValue.getTime() !== dteValue.getTime()) {
                        refreshDateInputs();
                        regenerateCalendar(dteStart);
                    }
                });

                calendar.addEventListener('click', function (event) {
                    if (event.target.classList.contains('month-letter')) {
                        dteStart.setMonth(event.target.getAttribute('month'));

                        regenerateCalendar(dteStart);

                    } else if (event.target.classList.contains('day')) {
                        var selected = xtag.query(calendar, '.selected')[0];
                        if (selected) {
                            selected.classList.remove('selected');
                            event.target.classList.add('selected');
                        }

                        dteValue = event.target.value;
                        dteStart = new Date(dteValue);

                        if (element.hasTime) {
                            refreshDateInputs();
                            if (event.target.classList.contains('grey')) {
                                regenerateCalendar(dteStart);
                            }
                        } else {
                            GS.closeDialog(dialog, 'Done');
                        }
                    } else if (event.target.classList.contains('month-adjust')) {
                        dteStart.setMonth(dteStart.getMonth() + (event.target.classList.contains('up') ? 1 : -1));

                        monthLabel.innerText = arrMonth[dteStart.getMonth()];

                        regenerateCalendar(dteStart);
                    } else if (event.target.classList.contains('year-adjust')) {
                        dteStart.setFullYear(dteStart.getFullYear() + (event.target.classList.contains('up') ? 1 : -1));

                        yearLabel.innerText = dteStart.getFullYear();

                        regenerateCalendar(dteStart);
                    }
                });
            }

            //console.log(element.hasTime);
            if (element.hasTime) {
                var clock = xtag.query(document, 'gs-dialog .clock')[0];
                var timeAdjustSection = xtag.query(document, 'gs-dialog .time-adjust-section')[0];
                var timeInput = xtag.query(timeAdjustSection, '.time-input')[0];

                var hourInput = xtag.query(timeInput, '.hour')[0];
                var minuteInput = xtag.query(timeInput, '.minute')[0];
                var secondInput = xtag.query(timeInput, '.second')[0];
                var ampmInput = xtag.query(timeInput, '.ampm')[0];

                var hourHand;
                var minuteHand;
                var secondHand;

                refreshTimeInputs = function () {
                    var hour = dteValue.getHours();
                    var ampm = hour >= 12 ? 'PM' : 'AM';
                    hour = hour === 0 ? 24 : hour;
                    hour = hour > 12 ? hour - 12 : hour;
                    hourInput.value = GS.leftPad(hour, '0', 2);
                    minuteInput.value = GS.leftPad(dteValue.getMinutes(), '0', 2);
                    secondInput.value = GS.leftPad(dteValue.getSeconds(), '0', 2);
                    ampmInput.value = ampm;

                    if (timeInput.selectText) {
                        GS.setInputSelection(timeInput.selectText, 0, timeInput.selectText.value.length);
                        timeInput.selectText = null;
                    }
                };
                refreshTimeInputs();

                var i = 0, len = 60, clockHTML = '';
                for (; i < len; i += 1) {
                    clockHTML += '<div class="marking' + ((i % 5) === 0 ? ' large' : '') + '" style="' + transformCSS('rotate(' + i * 6 + 'deg)') + '"></div>';
                }
                clockHTML += ml(function () {/*
                    <div class="position-reference"></div>
                    <div class="clock-hand hour-hand">
                        <div class="clock-hand-drag-handle"></div>
                    </div>
                    <div class="clock-hand minute-hand">
                        <div class="clock-hand-drag-handle"></div>
                    </div>
                    <div class="clock-hand second-hand">
                        <div class="clock-hand-drag-handle"></div>
                    </div>
                */});
                clock.innerHTML = clockHTML;
                hourHand = xtag.query(clock, '.hour-hand')[0];
                minuteHand = xtag.query(clock, '.minute-hand')[0];
                secondHand = xtag.query(clock, '.second-hand')[0];
                var resetClock = function () {
                    // the 180 is because the html is such that the hands point down
                    hourHand.setAttribute('style', transformCSS('rotate(' + (((dteValue.getHours() % 12) * 30) + 180) + 'deg)'));
                    minuteHand.setAttribute('style', transformCSS('rotate(' + ((dteValue.getMinutes() * 6) + 180) + 'deg)'));
                    secondHand.setAttribute('style', transformCSS('rotate(' + ((dteValue.getSeconds() * 6) + 180) + 'deg)'));
                };
                resetClock();

                timeInput.addEventListener('keyup', function (event) {
                    var code = event.which || event.keyCode || event.charCode;
                    var dtePreviousValue = new Date(dteValue);
                    // 38: up
                    // 40: down
                    // 65: a
                    // 80: p
                    if (event.target.classList.contains('ampm')) {
                        timeInput.selectText = event.target;
                        event.preventDefault();

                        if (dteValue.getHours() >= 12 && (code === 65 || code === 38 || code === 40)) {
                            dteValue.setHours(dteValue.getHours() - 12);

                        } else if (dteValue.getHours() < 12 && (code === 80 || code === 38 || code === 40)) {
                            dteValue.setHours(dteValue.getHours() + 12);

                        }

                    } else if (code === 38 || code === 40) {
                        event.target.value = GS.leftPad((parseInt(event.target.value, 10) + (code === 38 ? 1 : -1)).toString(), '0', 2);
                        timeInput.selectText = event.target;
                        event.preventDefault();
                    }

                    if (event.target.classList.contains('hour')) {
                        dteValue.setHours(event.target.value + (dteValue.getHours() > 12 ? 12 : 0));
                        dteStart = new Date(dteValue);

                    } else if (event.target.classList.contains('minute')) {
                        dteValue.setMinutes(event.target.value);
                        dteStart = new Date(dteValue);

                    } else if (event.target.classList.contains('second')) {
                        dteValue.setSeconds(event.target.value);
                        dteStart = new Date(dteValue);
                    }

                    if (dtePreviousValue.getTime() !== dteValue.getTime()) {
                        refreshTimeInputs();
                        refreshDateInputs();

                        resetClock(dteStart);
                        regenerateCalendar(dteStart);
                    }
                });

                timeAdjustSection.addEventListener('mousedown', function (event) {
                    if (event.target.nodeName.toUpperCase() !== 'INPUT') {
                        event.preventDefault();
                    }
                });

                timeAdjustSection.addEventListener('click', function (event) {
                    var dtePreviousValue = new Date(dteValue);
                    var activeElement = document.activeElement; // just to shorten things a bit

                    if (event.target.classList.contains('ampm')) {
                        GS.setInputSelection(event.target, 0, 2);

                    } else if (activeElement.parentNode.classList.contains('time-input') && event.target.classList.contains('time-adjust')) {
                        if (activeElement.classList.contains('ampm')) {
                            if (dteValue.getHours() < 12) {
                                dteValue.setHours(dteValue.getHours() + 12);

                            } else {
                                dteValue.setHours(dteValue.getHours() - 12);
                            }

                        } else {
                            activeElement.value = GS.leftPad((parseInt(activeElement.value, 10) + (event.target.classList.contains('up') ? 1 : -1)).toString(), '0', 2);
                        }
                        timeInput.selectText = activeElement;

                        if (activeElement.classList.contains('hour')) {
                            if (activeElement.value === '11' && dteValue.getHours() === 0) {
                                dteValue.setHours(-1);

                                dteStart = new Date(dteValue);
                                regenerateCalendar(dteStart);
                            } else {
                                dteValue.setHours(parseInt(activeElement.value, 10) + (dteValue.getHours() > 12 ? 12 : 0));
                            }

                        } else if (activeElement.classList.contains('minute')) {
                            dteValue.setMinutes(activeElement.value);

                        } else if (activeElement.classList.contains('second')) {
                            dteValue.setSeconds(activeElement.value);

                        }
                        dteStart = new Date(dteValue);

                    } else if (event.target.classList.contains('time-now')) {
                        var dteNow = new Date();
                        dteValue.setHours(dteToday.getHours());
                        dteValue.setMinutes(dteToday.getMinutes());
                        dteValue.setSeconds(dteToday.getSeconds());

                        dteStart = new Date(dteValue);

                    }

                    if (dtePreviousValue.getTime() !== dteValue.getTime()) {
                        refreshTimeInputs();
                        refreshDateInputs();

                        resetClock(dteStart);
                        regenerateCalendar(dteStart);
                    }
                });

                clock.addEventListener('mousedown', function (event) {
                    var target = event.target;

                    var clockRect = clock.getBoundingClientRect();
                    var refX = clockRect.left + (clockRect.width / 2);
                    var refY = clockRect.top + (clockRect.height / 2);

                    if (target.classList.contains('clock-hand-drag-handle')) {
                        target = target.parentNode;
                    }

                    if (target.classList.contains('clock-hand')) {
                        var dragHandler = function (event) {
                            var x = event.clientX - refX;
                            var y = event.clientY - refY;
                            var thetaRad = Math.atan2(y, x); // atan2 needs y first (?!?!?!?)
                            var thetaDeg = thetaRad * (180 / Math.PI);
                            if (target.classList.contains('hour-hand')) {
                                var tMod30 = thetaDeg % 30;
                                if (tMod30 <= 15) {
                                    thetaDeg -= tMod30;
                                } else {
                                    thetaDeg += 30 - tMod30;
                                }
                            } else {
                                var tMod6 = thetaDeg % 6;
                                if (tMod6 <= 3) {
                                    thetaDeg -= tMod6;
                                } else {
                                    thetaDeg += 6 - tMod6;
                                }
                            }
                            thetaDeg += 90;
                            if (thetaDeg <= 0) {
                                thetaDeg += 360;
                            }

                            if (target.classList.contains('hour-hand')) {
                                var newHours = thetaDeg / 30;
                                // 11PM -> 12AM
                                if (dteValue.getHours() === 23 && newHours === 12) {
                                    dteValue.setHours(24);

                                // 1PM -> 12PM (because below we do 12 + newHours)
                                } else if (dteValue.getHours() === 13 && newHours === 12) {
                                    dteValue.setHours(12);

                                // 12AM -> 11PM
                                } else if (dteValue.getHours() === 0 && newHours === 11) {
                                    dteValue.setHours(-1);

                                // 12AM -> 12AM
                                } else if (dteValue.getHours() === 0 && newHours === 12) {
                                    dteValue.setHours(0);

                                // 11PM -> 10PM
                                } else if (dteValue.getHours() === 23 && newHours < 11) {
                                    dteValue.setHours(12 + newHours);

                                // 12PM -> 1PM
                                } else if (dteValue.getHours() === 12 && newHours === 1) {
                                    dteValue.setHours(13);

                                // 1AM -> 12AM
                                } else if (dteValue.getHours() === 1 && newHours === 12) {
                                    dteValue.setHours(0);

                                // *PM -> *PM
                                } else if (dteValue.getHours() > 12) {
                                    dteValue.setHours(12 + newHours);

                                // *AM -> *AM
                                } else {
                                    dteValue.setHours(newHours);
                                }

                            } else if (target.classList.contains('minute-hand')) {
                                var newMinutes = thetaDeg / 6;
                                newMinutes = newMinutes === 60 ? 0 : newMinutes;
                                if (dteValue.getMinutes() === 59 && newMinutes === 0) {
                                    dteValue.setMinutes(60);

                                } else if (dteValue.getMinutes() === 0 && newMinutes === 59) {
                                    dteValue.setMinutes(-1);

                                } else {
                                    dteValue.setMinutes(newMinutes);
                                }

                            } else if (target.classList.contains('second-hand')) {
                                var newSeconds = thetaDeg / 6;
                                newSeconds = newSeconds === 60 ? 0 : newSeconds;
                                if (dteValue.getSeconds() === 59 && newSeconds === 0) {
                                    dteValue.setSeconds(60);

                                } else if (dteValue.getSeconds() === 0 && newSeconds === 59) {
                                    dteValue.setSeconds(-1);

                                } else {
                                    dteValue.setSeconds(newSeconds);
                                }

                            }

                            if (dteStart.getTime() !== dteValue.getTime()) {
                                dteStart = new Date(dteValue);

                                refreshTimeInputs();
                                refreshDateInputs();

                                resetClock(dteStart);
                                regenerateCalendar(dteStart);
                            }
                        };

                        var dragStopHandler = function (event) {
                            window.removeEventListener('mousemove', dragHandler);
                            window.removeEventListener('mouseup', dragStopHandler);
                        };

                        window.addEventListener('mousemove', dragHandler);
                        window.addEventListener('mouseup', dragStopHandler);
                    }
                });
            }
        }, function (event, strAnswer) {
            if (strAnswer === 'Done') {
                element.dteValue = dteValue;
                GS.triggerEvent(element, 'change');
            }
        });
    }


    /***************** DATETIME WHEEL *****************/

    function splitDate(element) {
        var i;
        var len;
        var arrFormat = element.getAttribute('format').split(/\b/);
        var arrDate = element.value ? element.value.split(/\b/) : formatDate(element, new Date(), getFormatString(element)).split(/\b/);
        if (arrFormat.indexOf('\'') > -1) {
            var arrTempDate = [];
            for (i = 0, len = arrDate.length; i < len; i += 1) {
                if (arrDate[i].indexOf('T') > 1) {
                    var temp = arrDate[i].split('T');
                    arrTempDate.push(temp[0], '\'', 'T', '\'', temp[1]);
                } else {
                    arrTempDate.push(arrDate[i]);
                }
            }
            arrDate = arrTempDate;
        }
        return arrDate;
    }

    function datetimeOpenWheelDialog(element) {
        var i;
        var len;
        var arrFormat = element.getAttribute('format').split(/\b/);
        var arrDate = splitDate(element);
        var dialogHTML;
        var label = element.hasAttribute('id') ? xtag.query(document, '[for="' + element.id + '"]')[0] : null;
        var labelHTML = label ? '<center><h3>' + label.innerHTML.replace(/:$/, '') + '</h3></center>' : '';
        var dialogTemplate = document.createElement('template');
        
        if (element.hasAttribute('spanish')) {
            var monthsFull   = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
            var monthsShort  = ['Ene','Feb','Mar','Abr','May','Jun','Jul','Ago','Sep','Oct','Nov','Dic'];
        } else {
            var monthsFull   = ['January','February','March','April','May','June', 'July','August','September','October','November','December'];
            var monthsShort  = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        }

        var wheelHTML = function () {
            var strRet = '';
            //console.log(arrFormat, arrDate);
            for (i = 0, len = arrFormat.length; i < len; i += 1) {
                if (arrFormat[i] === '\'') {
                    i += 1;
                }

                if (arrFormat[i] === 'MMMM') {
                    arrFormat[i] = 'MM';
                    arrDate[i] = monthsFull.indexOf(arrDate[i]) + 1;

                } else if (arrFormat[i] === 'MMM') {
                    arrFormat[i] = 'MM';
                    arrDate[i] = monthsShort.indexOf(arrDate[i]) + 1;

                } else if (arrFormat[i] === 'a') {
                    arrFormat[i] = 'ampm';

                } else if (arrFormat[i] === 'EEE' || arrFormat[i] === 'EEEE') {
                    i += 1;
                    continue;
                }
                strRet += '<gs-wheel values="' + arrFormat[i] + '" value="' + arrDate[i] + '"></gs-wheel>';
                i += 1;

                if (arrFormat[i] === '\'') {
                    i += 1;
                }

                if (i < len) {
                    strRet += '<span class="divider"' + (evt.touchDevice ? ' touch' : '') + '><span>' + arrFormat[i] + '</span></span>';
                }
            }
            return strRet;
        };

        if (element.hasAttribute('spanish')) {
            dialogHTML = ml(function () {/*
                <gs-page id="wheel-dialog">
                    <gs-header>
                        {{LABELHTML}}
                        <gs-grid widths="1,1,1">
                            <gs-block>
                                <gs-button dialogclose>Cancelar</gs-button>
                            </gs-block>
                            <gs-block>
                                <gs-button class="now-button">Ahora</gs-button>
                            </gs-block>
                            <gs-block>
                                <gs-button dialogclose bg-primary>Hecho</gs-button>
                            </gs-block>
                        </gs-grid>
                    </gs-header>
                    <gs-body class="gs-datetime-wheel-dialog">
                        <div class="root">
                            {{WHEELS}}
                        </div>
                    </gs-body>
                </gs-page>
            */}).replace('{{LABELHTML}}', labelHTML).replace('{{WHEELS}}', wheelHTML());
        } else {
            dialogHTML = ml(function () {/*
                <gs-page id="wheel-dialog">
                    <gs-header>
                        {{LABELHTML}}
                        <gs-grid widths="1,1,1">
                            <gs-block>
                                <gs-button dialogclose>Cancel</gs-button>
                            </gs-block>
                            <gs-block>
                                <gs-button class="now-button">Now</gs-button>
                            </gs-block>
                            <gs-block>
                                <gs-button dialogclose bg-primary>Done</gs-button>
                            </gs-block>
                        </gs-grid>
                    </gs-header>
                    <gs-body class="gs-datetime-wheel-dialog">
                        <div class="root">
                            {{WHEELS}}
                        </div>
                    </gs-body>
                </gs-page>
            */}).replace('{{LABELHTML}}', labelHTML).replace('{{WHEELS}}', wheelHTML());
        }
        
        dialogTemplate.innerHTML = dialogHTML;
        dialogTemplate.setAttribute('data-mode', evt.touchDevice ? 'full' : 'detect');
        GS.openDialog(dialogTemplate, function () {
            // var dialog = xtag.query(document, 'gs-dialog')[0];
            var dialog = document.getElementById('wheel-dialog');

            xtag.query(dialog, '.now-button')[0].addEventListener('click', function () {
                element.dteValue = new Date();
                arrFormat = element.getAttribute('format').split(/\b/);
                arrDate = splitDate(element);
                xtag.query(dialog, '.gs-datetime-wheel-dialog > .root')[0].innerHTML = wheelHTML();
            });

            dialog.addEventListener('change', function (event) {
                //console.log('test');
                if (event.target.getAttribute('values') === 'MM' || event.target.getAttribute('values')[0] === 'y') {
                    var year = xtag.query(dialog, 'gs-wheel[values^="y"]')[0].value;
                    var month = xtag.query(dialog, 'gs-wheel[values="MM"]')[0].value;
                    var dayElement = xtag.query(dialog, 'gs-wheel[values^="d"]')[0];
                    // month is zero based, but we pass a one based number
                    // 0 is the last day of the previous month
                    var days = new Date(year, month, 0).getDate();

                    var valuesPart = dayElement.getAttribute('values').match(/d*/)[0];
                    dayElement.parentNode.insertBefore(GS.stringToElement('<gs-wheel values="' + valuesPart + ',' + days + '" value="' + Math.min(dayElement.value, days) + '"></gs-wheel>'), dayElement);
                    dayElement.parentNode.removeChild(dayElement);
                }
            });
            if (xtag.query(dialog, 'gs-wheel[values="MM"]')[0]) {
                GS.triggerEvent(xtag.query(dialog, 'gs-wheel[values="MM"]')[0], 'change');
            }

        }, function (event, strAnswer) {
            if (strAnswer === 'Done' || strAnswer === 'Hecho') {
                var dialog = xtag.query(document, 'gs-dialog')[0];
                //console.log(dialog);

                for (i = 0, len = arrFormat.length; i < len; i += 1) {
                    if (arrFormat[i] === '\'') {
                        i += 1;
                    }

                    if (arrFormat[i] === 'MMMM') {
                        arrFormat[i] = 'MM';
                        arrDate[i] = monthsFull.indexOf(arrDate[i]);

                    } else if (arrFormat[i] === 'MMM') {
                        arrFormat[i] = 'MM';
                        arrDate[i] = monthsShort.indexOf(arrDate[i]);

                    } else if (arrFormat[i] === 'a') {
                        arrFormat[i] = 'ampm';

                    } else if (arrFormat[i] === 'EEE' || arrFormat[i] === 'EEEE') {
                        i += 1;
                        continue;
                    }

                    if (arrFormat[i] === 'dd' || arrFormat[i] === 'd') {
                        arrDate[i] = xtag.query(document, 'gs-wheel[values^="' + arrFormat[i] + '"]')[0].value;
                    } else if (xtag.query(document, 'gs-wheel[values="' + arrFormat[i] + '"]')[0]) {
                        arrDate[i] = xtag.query(document, 'gs-wheel[values="' + arrFormat[i] + '"]')[0].value;
                    }
                    i += 1;

                    if (arrFormat[i] === '\'') {
                        i += 1;
                    }
                }
                //console.log((element.hasDate ? '' : '2017/01/01 ') + arrDate.join('').replace('\'T\'', 'T'));
                element.dteValue = new Date((element.hasDate ? '' : '2017/01/01 ') + arrDate.join('').replace('\'T\'', 'T'));
                GS.triggerEvent(element, 'change');
            }
        });
    }

    function getFormatString(element) {
        var strFormat;

        if (element.hasAttribute('format')) {
            strFormat = element.getAttribute('format');
        }

        if (!strFormat) {
            strFormat = 'MM/dd/yyyy';
        } else if (strFormat.toLowerCase() === 'shortdate') {
            strFormat = 'M/d/yy';
        } else if (strFormat.toLowerCase() === 'mediumdate') {
            strFormat = 'MMM d, yyyy';
        } else if (strFormat.toLowerCase() === 'longdate') {
            strFormat = 'MMMM d, yyyy';
        } else if (strFormat.toLowerCase() === 'fulldate') {
            strFormat = 'EEEE, MMMM d, yyyy';
        } else if (strFormat.toLowerCase() === 'shorttime') {
            strFormat = 'h:mm a';
        } else if (strFormat.toLowerCase() === 'mediumtime') {
            strFormat = 'h:mm:ss a';
        } else if (strFormat.toLowerCase() === 'isodate') {
            strFormat = 'yyyy-MM-dd';
        } else if (strFormat.toLowerCase() === 'isotime') {
            strFormat = 'HH:mm:ss';
        } else if (strFormat.toLowerCase() === 'isodatetime') {
            strFormat = 'yyyy-MM-dd\'T\'HH:mm:ss';
        }

        return strFormat;
    }

    function formatDate(element, dteValue, strFormat) {
        /* (this function contains a (modified) substantial portion of code from another source
            here is the copyright for sake of legality) (Uses code by Matt Kruse)
        Copyright (c) 2006-2009 Rostislav Hristov, Asual DZZD

        Permission is hereby granted, free of charge, to any person obtaining a
        copy of this software and associated documentation files
        (the "Software"), to deal in the Software without restriction,
        including without limitation the rights to use, copy, modify, merge,
        publish, distribute, sublicense, and/or sell copies of the Software,
        and to permit persons to whom the Software is furnished to do so,
        subject to the following conditions:

        The above copyright notice and this permission notice shall be included
        in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/
        var i = 0, j = 0, l = 0, c = '', token = '', x, y, yearLen,
            formatNumber = function (n, s) {
                if (typeof s == 'undefined' || s == 2) {
                  return (n >= 0 && n < 10 ? '0' : '') + n;
                } else {
                    if (n >= 0 && n < 10) {
                       return '00' + n;
                    }
                    if (n >= 10 && n <100) {
                       return '0' + n;
                    }
                    return n;
                }
            };
            
            if (element.hasAttribute('spanish')) {
                var locale = {
                        monthsFull:   ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'],
                        monthsShort:  ['Ene','Feb','Mar','Abr','May','Jun','Jul','Ago','Sep','Oct','Nov','Dic'],
                        daysFull:     ['Domingo', 'Lune', 'Martes', 'MiÃ©rcoles', 'Jueves', 'Viernes', 'SÃ¡bado'],
                        daysShort:    ['Dom', 'Lun', 'Mar', 'MiÃ©', 'Jue', 'Vie', 'SÃ¡b'],
                        shortDateFormat: 'M/d/yyyy h:mm a',
                        longDateFormat: 'EEEE, MMMM dd, yyyy h:mm:ss a'
                    };
                    
            } else {
                var locale = {
                    monthsFull:   ['January','February','March','April','May','June', 'July','August','September','October','November','December'],
                    monthsShort:  ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],
                    daysFull:     ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
                    daysShort:    ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],
                    shortDateFormat: 'M/d/yyyy h:mm a',
                    longDateFormat: 'EEEE, MMMM dd, yyyy h:mm:ss a'
                };
            }

        y = dteValue.getFullYear();
        // Nunzio commented this out on Monday, October 19, 2015
        // It was causing an issue during typing in the year field
        /*if (y < 1000) {
            y = String(y + 1900);
        }*/

        var M = dteValue.getMonth() + 1,
            d = dteValue.getDate(),
            E = dteValue.getDay(),
            H = dteValue.getHours(),
            m = dteValue.getMinutes(),
            s = dteValue.getSeconds(),
            S = dteValue.getMilliseconds();

        yearLen = String(y).length;
        dteValue = {
            y: y,
            yyyy: y,
            yy: String(y).substring(yearLen - 2, yearLen),
            M: M,
            MM: formatNumber(M),
            MMM: locale.monthsShort[M-1],
            MMMM: locale.monthsFull[M-1],
            d: d,
            dd: formatNumber(d),
            EEE: locale.daysShort[E],
            EEEE: locale.daysFull[E],
            H: H,
            HH: formatNumber(H)
        };

        //console.log(dteValue);

        if (H === 0) {
            dteValue.h = 12;
        } else if (H > 12) {
            dteValue.h = H - 12;
        } else {
            dteValue.h = H;
        }

        dteValue.hh = formatNumber(dteValue.h);
        dteValue.k = H !== 0 ? H : 24;
        dteValue.kk = formatNumber(dteValue.k);

        if (H > 11) {
            dteValue.K = H - 12;
        } else {
            dteValue.K = H;
        }

        dteValue.KK = formatNumber(dteValue.K);

        if (H > 11) {
            dteValue.a = 'PM';
        } else {
            dteValue.a = 'AM';
        }

        dteValue.m = m;
        dteValue.mm = formatNumber(m);
        dteValue.s = s;
        dteValue.ss = formatNumber(s);
        dteValue.S = S;
        dteValue.SS = formatNumber(S);
        dteValue.SSS = formatNumber(S, 3);

        var result = '';

        i = 0;
        c = '';
        token = '';
        s = false;
        while (i < strFormat.length) {
            token = '';
            c = strFormat.charAt(i);
            if (c == '\'') {
                i++;
                if (strFormat.charAt(i) == c) {
                    result = result + c;
                    i++;
                } else {
                    s = !s;
                }
            } else {
                while (strFormat.charAt(i) == c) {
                    token += strFormat.charAt(i++);
                }
                if (token.indexOf('MMMM') != -1 && token.length > 4) {
                    token = 'MMMM';
                }
                if (token.indexOf('EEEE') != -1 && token.length > 4) {
                    token = 'EEEE';
                }
                if (typeof dteValue[token] != 'undefined' && !s) {
                    result = result + dteValue[token];
                } else {
                    result = result + token;
                }
            }
        }

        return result;
    }

    // dont do anything that modifies the element here
    function datetimeElementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        event.target.classList.add('focus');
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        event.target.classList.remove('focus');
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        event.target.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        event.target.classList.add('hover');
    }

    function datetimeElementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (!element.hasAttribute('tabindex')) {
                    element.setAttribute('tabindex', '0');
                }

                element.setAttribute('format', getFormatString(element));
                /*if (element.hasAttribute('format')) {
                    var d1 = new Date(), d2 = new Date(formatDate(element, d1, element.getAttribute('format')));
                    if (d1.getTime() !== d2.getTime()) {
                        element.timezoneOffset = d2.getTime() - d1.getTime();
                    }
                }*/
                
                //console.log(element.getAttribute('value'));
                // if (element.getAttribute('value') === 'now' || element.getAttribute('value') === 'today') {
                //     element.setAttribute('value', formatDate(element, new Date(), element.getAttribute('format')));
                // }
                //console.log(element.getAttribute('value'));


                element.hasDate = /\b(y|yyyy|yy|M|MM|MMM|MMMM|d|dd|EEE|EEEE)\b/g.test(element.getAttribute('format'));
                element.hasTime = /\b(k|kk|hh|h|H|HH|m|mm|s|ss|S|SS|SSS)\b/g.test(element.getAttribute('format'));

                if (element.getAttribute('value') === 'today' || element.getAttribute('value') === 'now') {
                    element.dteValue = new Date();
                } else if (element.getAttribute('value')) {
                    if (/^[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]($|\ )/.test(element.getAttribute('value'))) {
                        //console.log(element.getAttribute('value').replace('-', '/').replace('-', '/'));
                        element.setAttribute('value', element.getAttribute('value').replace('-', '/').replace('-', '/'));
                    }

                    if (/\.([0-9]*)$/.test(element.getAttribute('value'))) {
                        element.setAttribute('value', element.getAttribute('value').replace(/\.([0-9]*)$/, ''));
                        //alert(element.dteValue);
                    }

                    if (element.getAttribute('value').indexOf(' ') > -1) {
                        element.setAttribute('value', element.getAttribute('value').replace(/-[0-9][0-9]$/, ''));
                        element.dteValue = new Date(element.getAttribute('value'));
                    } else if (element.getAttribute('value').indexOf(':') > -1) {
                        element.dteValue = new Date('1/1/1970 ' + element.getAttribute('value'));
                    } else {
                        element.dteValue = new Date(element.getAttribute('value') + ' 00:00:00');
                    }
                    if (isNaN(element.dteValue.getTime())) {
                        element.dteValue = new Date((element.hasDate ? '' : '1/1/1970 ') + element.getAttribute('value') + (element.hasTime ? '' : ' 00:00:00'));
                    }
                    //alert(element.dteValue);
                } else if (!element.getAttribute('value')) {
                    element.innerHTML = '<span gs-dynamic class="placeholder">' + (element.getAttribute('placeholder') || '') + '</span>';
                }

                // handle "qs" attribute
                if (element.getAttribute('qs')) {
                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                }

                var label = element.hasAttribute('id') ? xtag.query(document, '[for="' + element.id + '"]')[0] : null;
                if (label) {
                    label.addEventListener('click', function () {
                        GS.triggerEvent(element, 'click');
                    });
                }

                element.addEventListener('click', function () {
                    if (!element.hasAttribute('disabled') && !element.hasAttribute('readonly')) {
                        if (!evt.touchDevice && element.hasAttribute('desktop-calendar')) {
                            datetimeOpenCalendarDialog(element);
                        } else {
                            datetimeOpenWheelDialog(element);
                        }
                    }
                });

                element.addEventListener('keyup', function (event) {
                    var code = event.which || event.keyCode || event.charCode;

                    if (code !== 9) { // tab
                        event.preventDefault();
                        GS.triggerEvent(element, 'click');
                    }
                });

                element.addEventListener('focus', focusFunction);
                element.addEventListener('blur', blurFunction);
                element.addEventListener(evt.mouseout, mouseoutFunction);
                element.addEventListener(evt.mouseover, mouseoverFunction);
            }
        }
    }

    xtag.register('gs-datetime', {
        lifecycle: {
            created: function () {
                datetimeElementCreated(this);
            },

            inserted: function () {
                datetimeElementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    datetimeElementCreated(this);
                    datetimeElementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    datetimeElementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {

                }
            }
        },
        events: {},
        accessors: {
            value: {
                get: function () {
                    return this.hasAttribute('value') && this.getAttribute('value') ? formatDate(this, new Date(this.getAttribute('value')), this.getAttribute('format')) : '';
                },
                set: function (newValue) {
                    if (newValue != null) {
                        var newerValue = GS.newDate(newValue);
                        this.setAttribute('value', newerValue);
                        this.innerText = formatDate(this, new Date(this.getAttribute('value')), this.getAttribute('format'));
                    } else {
                        this.setAttribute('value', newValue || '');
                        this.innerText = '';
                    }
                }
            },
            dteValue: {
                get: function () {
                    var value = this.value;
                    var dteValue = value ? new Date((this.hasDate ? '' : '1/1/1970 ') + value + (this.hasTime ? '' : ' 00:00:00')) : null;

                    return dteValue;
                },
                set: function (newValue) {
                    var newerValue = GS.newDate(newValue);
                    // if (this.hasAttribute('format')) {
                        this.value = newerValue;
                    // } else {
                    //     this.value = formatDate(element, newerValue, (this.hasDate ? 'yyyy/MM/dd' : '') + ' ' + (this.hasTime ? 'HH:mm:ss' : '').trim());
                    // }
                }
            }
        },
        methods: {}
    });

    /******************* WHEEL ******************/

    function addNumberToStart(element) {
        var wheel = element.wheel;
        var arrValues;

        wheel.removeChild(wheel.lastChild);

        var newRotation = parseFloat(wheel.firstChild.getAttribute('rotation'));
        var newNumber = parseInt(wheel.firstChild.getAttribute('data-number'), 10) - 1;

        newRotation += element.rotationInterval;
        if (newRotation > 0) {
            newRotation -= 360;
        }
        if (newNumber < element.min) {
            newNumber += (element.max - element.min) + 1;
        }

        if (element.getAttribute('type') === 'eighths') {
            arrValues = [
                '<sup>0</sup>/<sub>8</sub>',
                '<sup>1</sup>/<sub>8</sub>',
                '<sup>1</sup>/<sub>4</sub>',
                '<sup>3</sup>/<sub>8</sub>',
                '<sup>1</sup>/<sub>2</sub>',
                '<sup>5</sup>/<sub>8</sub>',
                '<sup>3</sup>/<sub>4</sub>',
                '<sup>7</sup>/<sub>8</sub>'
            ];
            wheel.insertBefore(GS.stringToElement('<span class="value" data-number="' + newNumber + '" rotation="' + newRotation + '" style="transform: rotateX(' + newRotation + 'deg) translateZ(' + element.radius + ');">' + arrValues[newNumber] + '</span>'), wheel.firstChild);

        } else if (element.arrvalue) {
            var j = parseInt(wheel.children[0].getAttribute('data-number'), 10) - 1;
            if (j === -1) {
                j = element.arrvalue.length - 1;
            }
            var i = j;
            arrValues = element.arrvalue;
            i = Math.abs(i) % arrValues.length;
            var arrTitles = element.arrtitle;
            wheel.insertBefore(GS.stringToElement('<span class="value" value="' + arrValues[Math.abs(i)] + '" data-number="' + j + '" rotation="' + newRotation + '" style="transform: rotateX(' + newRotation + 'deg) translateZ(' + element.radius + ');">' + arrTitles[Math.abs(i)] + '</span>'), wheel.firstChild);
        } else {
            wheel.insertBefore(GS.stringToElement('<span class="value" data-number="' + newNumber + '" rotation="' + newRotation + '" style="transform: rotateX(' + newRotation + 'deg) translateZ(' + element.radius + ');">' + GS.leftPad(newNumber, '0', 2) + '</span>'), wheel.firstChild);
        }
    }

    function addNumberToEnd(element) {
        var wheel = element.wheel;
        var arrValues;

        wheel.removeChild(wheel.firstChild);

        var newRotation = parseFloat(wheel.lastChild.getAttribute('rotation'))
          , newNumber = parseInt(wheel.lastChild.getAttribute('data-number'), 10) + 1;

        newRotation -= element.rotationInterval;
        if (newRotation <= -360) {
            newRotation += 360;
        }
        if (newNumber > element.max) {
            newNumber -= (element.max - element.min) + 1;
        }

        if (element.getAttribute('type') === 'eighths') {
            arrValues = [
                '<sup>0</sup>/<sub>8</sub>',
                '<sup>1</sup>/<sub>8</sub>',
                '<sup>1</sup>/<sub>4</sub>',
                '<sup>3</sup>/<sub>8</sub>',
                '<sup>1</sup>/<sub>2</sub>',
                '<sup>5</sup>/<sub>8</sub>',
                '<sup>3</sup>/<sub>4</sub>',
                '<sup>7</sup>/<sub>8</sub>'
            ];
            wheel.appendChild(GS.stringToElement('<span class="value" data-number="' + newNumber + '" rotation="' + newRotation + '" style="transform: rotateX(' + newRotation + 'deg) translateZ(' + element.radius + ');">' + arrValues[newNumber] + '</span>'));

        } else if (element.arrvalue) {
            var i = parseInt(wheel.children[wheel.children.length - 1].getAttribute('data-number'), 10) + 1;
            arrValues = element.arrvalue;
            i = Math.abs(i) % arrValues.length;
            var arrTitles = element.arrtitle;
            wheel.appendChild(GS.stringToElement('<span class="value" value="' + arrValues[Math.abs(i)] + '" data-number="' + i + '" rotation="' + newRotation + '" style="transform: rotateX(' + newRotation + 'deg) translateZ(' + element.radius + ');">' + arrTitles[Math.abs(i)] + '</span>'));
        } else {
            wheel.appendChild(GS.stringToElement('<span class="value" data-number="' + newNumber + '" rotation="' + newRotation + '" style="transform: rotateX(' + newRotation + 'deg) translateZ(' + element.radius + ');">' + GS.leftPad(newNumber, '0', 2) + '</span>'), wheel.firstChild);
        }
    }

    function wheelDragStartHandler(event, immediateKinetic) {
        var pageY = 0;
        if (event.touches && event.touches.length !== 1) {
            return;
        } else if (event.touches) {
            pageY = event.touches[0].pageY;
        } else if (event.pageY) {
            pageY = event.pageY;
        }
        var element = this;
        var fontSize = GS.emToPx(element, 1) / GS.emToPx(document.body, 1);
        var wheel = element.wheel;
        element.dragStart = pageY;
        element.rotationStart = element.rotation;
        element.numbersRotated = 1;
        if (element.kineticTimer) {
            clearTimeout(element.kineticTimer);
            element.kineticTimer = null;
        }
        //console.log(element.dragStart, pageY, element.velocity, element.rotation, event);
        //console.log('wheelDragStartHandler', element);

        var dragHandler = function (event) {
            var pageY = 0;
            if (event.touches && event.touches.length !== 1) {
                return;
            } else if (event.touches) {
                pageY = event.touches[0].pageY;
            } else if (event.pageY) {
                pageY = event.pageY;
            }
            //console.log('dragHandler', element);
            element.velocity = element.dragStart - pageY;
            //console.log(element.dragStart, pageY, element.velocity, element.rotation, event);

            element.rotation += element.velocity / fontSize;
            wheel.setAttribute('style', 'transform: translateZ(-' + element.radius + ') rotateX(' + element.rotation + 'deg);');

            if (!element.ampm) {
                while ((element.rotation - element.rotationStart) < ((element.numbersRotated - 1) * element.rotationInterval)) {
                    element.numbersRotated -= 1;

                    addNumberToStart(element);
                }

                while ((element.rotation - element.rotationStart) > (element.numbersRotated * element.rotationInterval)) {
                    element.numbersRotated += 1;

                    addNumberToEnd(element);
                }
            }

            element.dragStart = pageY;
        };

        var dragStopHandler = function (event) {
            if (element.ampm) {
                while (element.rotation > 180) {
                    element.rotation -= 360;
                }
                while (element.rotation < -180) {
                    element.rotation += 360;
                }

                if (element.rotation < 11.25) {
                    element.rotation = 0;
                } else if (element.rotation >= 11.25) {
                    element.rotation = 22.5;
                }

                wheel.setAttribute('style', 'transform: translateZ(-' + element.radius + ') rotateX(' + element.rotation + 'deg);');

                var valueElement = xtag.query(wheel, '[rotation="' + (element.rotation * -1) + '"]')[0];
                if (element.getAttribute('values') && element.getAttribute('values').toLowerCase() === 'ampm') {
                    element.setAttribute('value', valueElement.innerText);
                } else {
                    element.setAttribute('value', (valueElement.getAttribute('value') || valueElement.getAttribute('data-number')));
                }
                
                GS.triggerEvent(element, 'change');

            } else {
                if (Math.abs(element.velocity) > 5) {
                    var drag = 0.01;
                    var interval = 10;
                    element.kineticTimer = setTimeout(function kinetic() {
                        dragHandler({
                            pageY: element.dragStart - (element.velocity * (1 - drag))
                        });
                        drag *= 1.05;
                        if (drag < 1) {
                            element.kineticTimer = setTimeout(kinetic, interval);
                        } else {
                            element.kineticTimer = null;
                            element.velocity = 0;
                            dragStopHandler();
                        }
                    }, interval);

                } else {
                    var oldRotation = element.rotation;
                    element.rotation = Math.round(element.rotation / element.rotationInterval) * element.rotationInterval;

                    while (element.rotation >= 360) {
                        element.rotation -= 360;
                    }
                    while (element.rotation < 0) {
                        element.rotation += 360;
                    }

                    var valueElement = xtag.query(wheel, '[rotation="' + (element.rotation * -1) + '"]')[0];
                    if (element.getAttribute('values') && element.getAttribute('values').toLowerCase() === 'ampm') {
                        element.setAttribute('value', valueElement.innerText);
                    } else {
                        element.setAttribute('value', valueElement.getAttribute('data-number'));
                    }

                    element.rotation = -180;
                    wheel.setAttribute('style', 'transform: translateZ(-' + element.radius + ') rotateX(' + element.rotation + 'deg);');
                    wheelGenerateHTML(element);
                    GS.triggerEvent(element, 'change');
                }
            }

            window.removeEventListener(evt.mousemove, dragHandler);
            window.removeEventListener(evt.mouseup, dragStopHandler);
            window.removeEventListener(evt.mouseout, dragStopHandler);
        };

        if (arguments.length === 2) {
            element.velocity = 6;
            dragStopHandler(event);
        } else {
            window.addEventListener(evt.mousemove, dragHandler);
            window.addEventListener(evt.mouseup, dragStopHandler);
            window.addEventListener(evt.mouseout, dragStopHandler);
        }
    }

    function arrowClickHandler(event) {
        var element = GS.findParentTag(event.target, 'gs-wheel');
        var wheel = element.wheel;
        if (event.target.classList.contains('arrow-up')) {
            element.rotation -= element.rotationInterval;

            if (element.ampm) {
                if (element.rotation < 11.25) {
                    element.rotation = 0;
                } else if (element.rotation >= 11.25) {
                    element.rotation = 22.5;
                }
            } else {
                while (element.rotation >= 360) {
                    element.rotation -= 360;
                }
                while (element.rotation < 0) {
                    element.rotation += 360;
                }
            }

            //console.log(wheel, element.rotation);
            var valueElement = xtag.query(wheel, '[rotation="' + (element.rotation * -1) + '"]')[0];
            if (element.getAttribute('values') && element.getAttribute('values').toLowerCase() === 'ampm') {
                element.setAttribute('value', valueElement.innerText);
            } else {
                element.setAttribute('value', (valueElement.getAttribute('value') || valueElement.getAttribute('data-number')));
            }

            wheel.setAttribute('style', 'transform: translateZ(-' + element.radius + ') rotateX(' + element.rotation + 'deg);');
            if (!element.ampm) {
                addNumberToStart(element);
            }
            GS.triggerEvent(element, 'change');

        } else if (event.target.classList.contains('arrow-down')) {
            element.rotation += element.rotationInterval;

            if (element.ampm) {
                if (element.rotation < 11.25) {
                    element.rotation = 0;
                } else if (element.rotation >= 11.25) {
                    element.rotation = 22.5;
                }
            } else {
                while (element.rotation >= 360) {
                    element.rotation -= 360;
                }
                while (element.rotation < 0) {
                    element.rotation += 360;
                }
            }

            //console.log(wheel, element.rotation);
            var valueElement = xtag.query(wheel, '[rotation="' + (element.rotation * -1) + '"]')[0];
            if (element.getAttribute('values') && element.getAttribute('values').toLowerCase() === 'ampm') {
                element.setAttribute('value', valueElement.innerText);
            } else {
                element.setAttribute('value', (valueElement.getAttribute('value') || valueElement.getAttribute('data-number')));
            }

            wheel.setAttribute('style', 'transform: translateZ(-' + element.radius + ') rotateX(' + element.rotation + 'deg);');
            if (!element.ampm) {
                addNumberToEnd(element);
            }
            GS.triggerEvent(element, 'change');
        }
    }

    function wheelScrollHandler(event) {
        var element = GS.findParentTag(event.target, 'gs-wheel');
        var wheel = element.wheel;
        event.preventDefault();
        if (event.deltaY > 0) {
            element.rotation -= element.rotationInterval;

            if (element.ampm) {
                if (element.rotation < 11.25) {
                    element.rotation = 0;
                } else if (element.rotation >= 11.25) {
                    element.rotation = 22.5;
                }
            } else {
                while (element.rotation >= 360) {
                    element.rotation -= 360;
                }
                while (element.rotation < 0) {
                    element.rotation += 360;
                }
            }

            var valueElement = xtag.query(wheel, '[rotation="' + (element.rotation * -1) + '"]')[0];
            // if (element.getAttribute('values') && element.getAttribute('values').toLowerCase() === 'ampm') {
            //     element.setAttribute('value', (valueElement.getAttribute('data-number') || valueElement.innerText));
            // } else {
                element.setAttribute('value', (valueElement.getAttribute('value') || valueElement.innerText));
                //element.setAttribute('value', (valueElement.getAttribute('value') || valueElement.getAttribute('data-number')));
            // }

            wheel.setAttribute('style', 'transform: translateZ(-' + element.radius + ') rotateX(' + element.rotation + 'deg);');
            if (!element.ampm) {
                addNumberToStart(element);
            }

        } else if (event.deltaY < 0) {
            element.rotation += element.rotationInterval;

            if (element.ampm) {
                if (element.rotation < 11.25) {
                    element.rotation = 0;
                } else if (element.rotation >= 11.25) {
                    element.rotation = 22.5;
                }
            } else {
                while (element.rotation >= 360) {
                    element.rotation -= 360;
                }
                while (element.rotation < 0) {
                    element.rotation += 360;
                }
            }

            var valueElement = xtag.query(wheel, '[rotation="' + (element.rotation * -1) + '"]')[0];
            // if (element.getAttribute('values') && element.getAttribute('values').toLowerCase() === 'ampm') {
            //     element.setAttribute('value', valueElement.innerText);
            // } else {
                element.setAttribute('value', (valueElement.getAttribute('value') || valueElement.innerText));
                //element.setAttribute('value', (valueElement.getAttribute('value') || valueElement.getAttribute('data-number')));
            // }

            wheel.setAttribute('style', 'transform: translateZ(-' + element.radius + ') rotateX(' + element.rotation + 'deg);');
            if (!element.ampm) {
                addNumberToEnd(element);
            }
        }
    }

    function wheelGenerateHTML(element) {
        var bolEighths = (element.getAttribute('type') === 'eighths');
        var arrValues;

        element.rotation = -180;
        element.wheel.setAttribute('style', 'transform: translateZ(-' + element.radius + ') rotateX(' + element.rotation + 'deg);');
        element.wheel.innerHTML = '';
        for (var rotation = 0, j = parseInt(element.value - ((element.arrvalue) ? 1 : 0), 10) - 8; rotation > -360; rotation -= element.rotationInterval, j += 1) {
            if (element.ampm) {
                element.rotation = (element.value === 'AM' ? 0 : 22.5);
                element.wheel.setAttribute('style', 'transform: translateZ(-' + element.radius + ') rotateX(' + (element.value === 'AM' ? '0' : '22.5') + 'deg);');
                element.wheel.appendChild(
                    GS.stringToElement(
                        '<span class="value" data-number="' + (rotation === 0 ? 'AM' : 'PM') + '" ' +
                            'rotation="' + rotation + '" ' +
                            'style="transform: rotateX(' + rotation + 'deg) translateZ(' + element.radius + ');">' +
                                (rotation === 0 ? 'AM' : 'PM') +
                        '</span>'
                    )
                );
                if (rotation == -22.5) {
                    break;
                }

            } else if (element.arrvalue) {
                arrValues = element.arrvalue;
                if (j < 0) {
                    if (j >= 0) {
                        j = element.arrvalue.length - j;
                    } else {
                        j = (element.arrvalue.length + 1) + j;
                    }
                    var i = j;
                } else {
                    var i = j;
                }
                //console.log(i, j);
                j = ((j < 0) ? (Math.abs(i) % arrValues.length) - ((Math.abs(i) % arrValues.length) * 2) : (Math.abs(i) % arrValues.length));
                if (j == -1) {
                    j = arrValues.length - 1;
                }
                i = Math.abs(j) % arrValues.length;
                //console.log(i, j);
                if (rotation == -180) {
                    element.setAttribute('value', arrValues[Math.abs(i)]);
                    if (xtag.query(element, '.container')[0].style.width < element.longestWidth + 'px') {
                        xtag.query(element, '.container')[0].style.width = element.longestWidth + 'px';
                    }
                }
                var arrTitles = element.arrtitle;
                element.wheel.appendChild(
                    GS.stringToElement(
                        '<span class="value" value="' + arrValues[Math.abs(i)] + '" data-number="' + Math.abs(j) + '" ' +
                            'rotation="' + rotation + '" ' +
                            'style="transform: rotateX(' + rotation + 'deg) translateZ(' + element.radius + ');">' +
                                arrTitles[Math.abs(i)] +
                        '</span>'
                    )
                );
            } else if (bolEighths) {
                arrValues = [
                    '<sup>0</sup>/<sub>8</sub>',
                    '<sup>1</sup>/<sub>8</sub>',
                    '<sup>1</sup>/<sub>4</sub>',
                    '<sup>3</sup>/<sub>8</sub>',
                    '<sup>1</sup>/<sub>2</sub>',
                    '<sup>5</sup>/<sub>8</sub>',
                    '<sup>3</sup>/<sub>4</sub>',
                    '<sup>7</sup>/<sub>8</sub>'
                ];
                if (j < element.min) {
                    if (j >= 0) {
                        j = element.max - j;
                    } else {
                        j = (element.max + (element.min === 0 ? 1 : 0)) + j;
                    }
                }
                element.wheel.appendChild(
                    GS.stringToElement(
                        '<span class="value" data-number="' + j + '" ' +
                            'rotation="' + rotation + '" ' +
                            'style="transform: rotateX(' + rotation + 'deg) translateZ(' + element.radius + ');">' +
                                arrValues[j] +
                        '</span>'
                    )
                );
                if (j === element.max) {
                    j = element.min - 1;
                }

            } else {
                if (j < element.min) {
                    if (j >= 0) {
                        j = element.max - j;
                    } else {
                        j = (element.max + (element.min === 0 ? 1 : 0)) + j;
                    }
                }
                element.wheel.appendChild(
                    GS.stringToElement(
                        '<span class="value" data-number="' + j + '" ' +
                            'rotation="' + rotation + '" ' +
                            'style="transform: rotateX(' + rotation + 'deg) translateZ(' + element.radius + ');">' +
                                GS.leftPad(j, '0', 2) +
                        '</span>'
                    )
                );
                if (j === element.max) {
                    j = element.min - 1;
                }
            }
        }
    }

    // dont do anything that modifies the element here
    function wheelElementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    //
    function wheelElementInserted(element) {
        var styleElement, i, len, wheelNames, wheelHTML;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                if (evt.touchDevice) {
                    element.setAttribute('touch', '');

                    var maybePreventPullToRefresh = false;
                    var lastTouchY = 0;
                    var touchstartHandler = function (e) {
                        if (e.touches.length != 1) {
                            return;
                        }
                        lastTouchY = e.touches[0].clientY;
                        // Pull-to-refresh will only trigger if the scroll begins when the
                        // document's Y offset is zero.
                        maybePreventPullToRefresh = window.pageYOffset == 0;
                    };

                    var touchmoveHandler = function(e) {
                        var touchY = e.touches[0].clientY;
                        var touchYDelta = touchY - lastTouchY;
                        lastTouchY = touchY;

                        if (maybePreventPullToRefresh) {
                            // To suppress pull-to-refresh it is sufficient to preventDefault the
                            // first overscrolling touchmove.
                            maybePreventPullToRefresh = false;
                            if (touchYDelta > 0) {
                                e.preventDefault();
                                return;
                            }
                        }

                        e.preventDefault();
                        return;

                        if (window.pageYOffset == 0 && touchYDelta > 0) {
                            e.preventDefault();
                            return;
                        }
                    };

                    element.addEventListener('touchstart', touchstartHandler, { passive: false });
                    element.addEventListener('touchmove', touchmoveHandler, { passive: false });
                }

                element.radius = '4em'; //(element.clientHeight / 2) + 'px';
                if (element.hasAttribute('min') && element.hasAttribute('max')) {
                    element.setAttribute('values', element.getAttribute('min') + '-' + element.getAttribute('max'));
                }
                element.values = element.getAttribute('values');
                if (evt.touchDevice) {
                    element.innerHTML = ml(function () {/*
                        <div class="root">
                            <div class="transparent top"></div>
                            <div class="container">
                                <div class="wheel" style="transform: translateZ(-{{RADIUS}}) rotateX(-180deg);"></div>
                            </div>
                            <div class="transparent bottom"></div>
                        </div>
                    */}).replace('{{RADIUS}}', element.radius);
                } else {
                    element.innerHTML = ml(function () {/*
                        <div class="root">
                            <div class="arrow-up">&#xf077;</div>
                            <div class="transparent top"></div>
                            <div class="container">
                                <div class="wheel" style="transform: translateZ(-{{RADIUS}}) rotateX(-180deg);"></div>
                            </div>
                            <div class="transparent bottom"></div>
                            <div class="arrow-down">&#xf078;</div>
                        </div>
                    */}).replace('{{RADIUS}}', element.radius);
                }
                element.wheel = xtag.query(element, '.wheel')[0];
                element.arrowUp = xtag.query(element, '.arrow-up')[0];
                element.arrowDown = xtag.query(element, '.arrow-down')[0];
                element.rotation = -180;
                if (evt.touchDevice) {
                    element.addEventListener(evt.mousedown, wheelDragStartHandler);
                } else {
                    element.arrowUp.addEventListener('click', arrowClickHandler);
                    element.arrowDown.addEventListener('click', arrowClickHandler);

                    element.addEventListener('wheel', wheelScrollHandler);
                }
                element.rotationInterval = 360 / 16;
                //y|yyyy|yy|M|MM|d|dd|EEE|EEEE
                //k|kk|hh|h|H|HH|m|mm|s|ss|S|SS|SSS
                //console.log(element.values, element.values.substring(0, 2) === 'dd', element.values.substring(0, 1) === 'd');
                
                if (!element.values && element.hasAttribute('min') && element.hasAttribute('max')) {
                    element.values = (element.getAttribute('min') + '-' + element.getAttribute('max'));
                    element.min = parseInt(element.getAttribute('min'), 10);
                    element.max = parseInt(element.getAttribute('max'), 10);
                } else if (element.values === 'M' || element.values === 'MM' || element.values === 'H' || element.values === 'HH') {
                    element.min = 1;
                    element.max = 12;
                } else if (element.values === 'h' || element.values === 'hh') {
                    element.min = 0;
                    element.max = 23;
                } else if (element.values === 'k' || element.values === 'kk') {
                    element.min = 0;
                    element.max = 23;
                } else if (element.values === 'm' || element.values === 'mm' || element.values === 'ss') {
                    element.min = 0;
                    element.max = 59;
                } else if (element.values && element.values[0] === 'd') {
                    element.min = 1;
                    element.max = element.values.length > 2 ? parseInt(element.values.substring(element.values.length - 2, element.values.length), 10) : 31;
                } else if (element.values === 'y') {
                    element.min = 0;
                    element.max = 99;
                } else if (element.values === 'yyyy') {
                    var d = new Date();
                    element.min = d.getFullYear() - 50;
                    element.max = d.getFullYear() + 50;

                } else if (element.values === 'ampm') {
                    element.ampm = true;
                    element.rotation = element.value === 'AM' ? 0 : 22.5;
                    element.wheel.setAttribute('style', 'transform: translateZ(-' + element.radius + ') rotateX(' + element.rotation + 'deg);');
                } else if (element.arrvalue) {
                    
                } else {
                    // var arrValue = element.values.split('-');
                    // element.min = parseInt(arrValue[0], 10);
                    // element.max = parseInt(arrValue[1], 10);
                    var arrValue = element.values.split('-');
                    var i = parseInt(arrValue[0], 10);
                    //console.log(arrValue);
                    element.arrvalue = [];
                    element.arrtitle = [];
                    var len = parseInt(arrValue[1], 10) + 1;
                    while (i < len) {
                        element.arrvalue.push(i);
                        element.arrtitle.push(i);
                        i++;
                    }
                    element.removeAttribute('values');
                }

                wheelGenerateHTML(element);
            }
        }
    }
    
    
    function longestOfArray(a) {
        var c = 0,
            d = 0,
            l = 0,
            i = a.length;
        if (i) while (i--) {
            d = a[i].length;
            if (d > c) {
                l = i;
                c = d;
            }
        }
        return a[l];
    }

    xtag.register('gs-wheel', {
        lifecycle: {
            created: function () {
                wheelElementCreated(this);
            },

            inserted: function () {
                if (this.innerHTML.indexOf('option') !== -1) {
                    var arrValues = [], arrTitles = [];
                    for (var i = 0, len = this.children.length; i < len; i++) {
                        arrValues[i] = (this.children[i].getAttribute('value') || this.children[i].textContent);
                        arrTitles[i] = this.children[i].textContent;
                    }
                    this.arrvalue = arrValues;
                    this.arrtitle = arrTitles;
                    this.longest = longestOfArray(arrTitles);
                    this.innerHTML = '<div style="position: absolute; visibility: hidden; height: auto; width: auto; white-space: nowrap;">&nbsp;' + this.longest + '&nbsp;</div>';
                    this.longestWidth = this.children[0].offsetWidth;
                    //console.log(this.longestWidth);
                }
                wheelElementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    wheelElementCreated(this);
                    wheelElementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    wheelElementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {

                }
            }
        },
        events: {},
        accessors: {
            value: {
                get: function () {
                    return this.getAttribute('value') || '0';
                },
                set: function (newValue) {
                    this.setAttribute('value', newValue);
                    wheelGenerateHTML(this);
                }
            }
        },
        methods: {}
    });
});

//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';
    addSnippet('Dialog From Coded Template', 'Dialog From Coded Template', 'var templateElement = document.createElement(\'template\');\n' +
                                                                          '\n' +
                                                                          'templateElement.setAttribute(\'data-max-width\', \'50em;\');\n' +
                                                                          'templateElement.innerHTML = ml(function () {/*\n' +
                                                                          '<gs-page>\n' +
                                                                          '    <gs-header>\n' +
                                                                          '        <center><h3>$1</h3></center>\n' +
                                                                          '    </gs-header>\n' +
                                                                          '    <gs-body padded>\n' +
                                                                          '        $2\n' +
                                                                          '    </gs-body>\n' +
                                                                          '    <gs-footer>\n' +
                                                                          '        <gs-grid gutter>\n' +
                                                                          '            <gs-block>\n' +
                                                                          '                <gs-button dialogclose>Cancel</gs-button>\n' +
                                                                          '            </gs-block>\n' +
                                                                          '            <gs-block>\n' +
                                                                          '                <gs-button dialogclose bg-primary>Save</gs-button>\n' +
                                                                          '            </gs-block>\n' +
                                                                          '        </gs-grid>\n' +
                                                                          '    </gs-footer>\n' +
                                                                          '</gs-page>\n' +
                                                                          '*/});\n' +
                                                                          'GS.openDialog(\'${3:templateID}\', function () {\n' +
                                                                          '    // after dialog open \n' +
                                                                          '}, function (event, strAnswer) {\n' +
                                                                          '    if (strAnswer === \'${4:Save}\') {\n' +
                                                                          '        // before dialog close\n' +
                                                                          '        $0\n' +
                                                                          '    }\n' +
                                                                          '});');

    addSnippet('Dialog From Template', 'Dialog From Template', 'GS.openDialog(\'${1:templateID}\', function () {\n' +
                                                                          '    // after dialog open \n' +
                                                                          '}, function (event, strAnswer) {\n' +
                                                                          '    if (strAnswer === \'${2:Ok}\') {\n' +
                                                                          '        // before dialog close\n' +
                                                                          '        $0\n' +
                                                                          '    }\n' +
                                                                          '});');

    addSnippet('GS.openDialog', 'GS.openDialog', 'GS.openDialog(\'${1:templateID}\', function () {\n' +
                                                            '    // after dialog open \n' +
                                                            '}, function (event, strAnswer) {\n' +
                                                            '    if (strAnswer === \'${2:Ok}\') {\n' +
                                                            '        // beforedialog close\n' +
                                                            '        $0\n' +
                                                            '    }\n' +
                                                            '});');

    addSnippet('GS.closeDialog', 'GS.closeDialog', 'GS.closeDialog(${1:dialog}, ${2:\'Ok\'});');
    addSnippet('Close Dialog', 'Close Dialog', 'GS.closeDialog(${1:dialog}, ${2:\'Ok\'});');

    addSnippet('GS.msgbox', 'GS.msgbox', 'GS.msgbox(${1:\'Are you sure...\'}, ${2:\'Are you sure you want to do this?\'}, ' +
                                                                            '${3:[\'Cancel\', \'Ok\']}, function (strAnswer) {\n' +
                                                    '    if (strAnswer === ${4:\'Ok\'}) {\n' +
                                                    '        // before dialog close\n' +
                                                    '        $0\n' +
                                                    '    }\n' +
                                                    '});');
    addSnippet('Message Box', 'Message Box', 'GS.msgbox(${1:\'Are you sure...\'}, ${2:\'Are you sure you want to do this?\'}, ' +
                                                                                '${3:[\'Cancel\', \'Ok\']}, function (strAnswer) {\n' +
                                                        '    if (strAnswer === ${4:\'Ok\'}) {\n' +
                                                        '        // before dialog close\n' +
                                                        '        $0\n' +
                                                        '    }\n' +
                                                        '});');

    addSnippet('GS.inputbox', 'GS.inputbox', 'GS.inputbox(${1:\'Are you sure...\'}, ${2:\'Are you sure you want to do this?\'}, ' +
                                                                                'function (strInputValue) {\n' +
                                                        '    // before dialog close\n' +
                                                        '    $0\n' +
                                                        '}${3:, \'default\'});');
    addSnippet('Input Box', 'Input Box', 'GS.inputbox(${1:\'Are you sure...\'}, ${2:\'Are you sure you want to do this?\'}, ' +
                                                                            'function (strInputValue) {\n' +
                                                    '    // before dialog close\n' +
                                                    '    $0\n' +
                                                    '}${3:, \'default\'});');

    addSnippet('GS.openDialogToElement', 'GS.openDialogToElement',
                                        'GS.openDialogToElement(${1:document.getElementById(\'target\')}, \'${2:templateID}\', ' +
                                                                            '\'${3:right}\', function () {\n' +
                                        '    // after dialog open \n' +
                                        '}, function (event, strAnswer) {\n' +
                                        '    if (strAnswer === \'${4:Ok}\') {\n' +
                                        '        // beforedialog close\n' +
                                        '        $0\n' +
                                        '    }\n' +
                                        '});');
    addSnippet('Dialog For Element', 'Dialog For Element',
                                        'GS.openDialogToElement(${1:document.getElementById(\'target\')}, \'${2:templateID}\', ' +
                                                                            '\'${3:right}\', function () {\n' +
                                        '    // after dialog open \n' +
                                        '}, function (event, strAnswer) {\n' +
                                        '    if (strAnswer === \'${4:Ok}\') {\n' +
                                        '        // beforedialog close\n' +
                                        '        $0\n' +
                                        '    }\n' +
                                        '});');
});


(function () {
    'use strict';

    function buttonHTML(buttons) {
        var strHTML, i, len;

        buttons = buttons || ['Ok'];

        // change button parameter to array format if it is string format (and the string is recognized)
        if (typeof buttons === 'string') {
            if (buttons === 'okcancel' || buttons === 'cancelok') {
                buttons = ['Cancel', 'Ok'];

            } else if (buttons === 'ok' || buttons === 'okonly') {
                buttons = ['Ok'];

            } else if (buttons === 'cancel' || buttons === 'cancelonly') {
                buttons = ['Cancel'];

            } else if (buttons === 'yesno' || buttons === 'noyes') {
                buttons = ['No', 'Yes'];

            } else if (buttons === 'Yes' || buttons === 'yesonly') {
                buttons = ['Yes'];

            } else if (buttons === 'No' || buttons === 'noonly') {
                buttons = ['No'];
            }
        }

        if (typeof buttons === 'object') {
            if (buttons.length > 0) {
                strHTML = '<gs-grid gs-dynamic>';

                for (i = 0, len = buttons.length; i < len; i += 1) {
                    strHTML +=
                        '<gs-block gs-dynamic>' +
                            '<gs-button dialogclose ' + (buttons[i] === 'Cancel' ? 'key="escape" no-modifier-key ' : '') + (i === len - 1 ? 'bg-primary listen-for-return' : '') + ' gs-dynamic>' +
                                encodeHTML(buttons[i]) +
                            '</gs-button>' +
                        '</gs-block>';
                }

                strHTML += '</gs-grid>';

            } else {
                strHTML = '<gs-button dialogclose>Done</gs-button>';
            }
        } else {
            strHTML = buttons;
        }

        return strHTML;
    }

    // GS.msgbox('test1', 'test2', ['cancel', 'ok'], function (strAnswer) {console.log(strAnswer); });
    GS.msgbox = function (strTitle, strMessage, buttons, callback) {
        var templateElement = document.createElement('template');

        templateElement.innerHTML = '<gs-page>' +
                                    '    <gs-header><center><h3>' + strTitle + '</h3></center></gs-header>' +
                                    '    <gs-body padded>' +
                                    '        ' + strMessage +
                                    '    </gs-body>' +
                                    '    <gs-footer>' + buttonHTML(buttons) + '</gs-footer>' +
                                    '</gs-page>';

        GS.openDialog(templateElement, '', function (event, strAnswer) {
            if (typeof callback === 'function') {
                callback(strAnswer);
            }
        });
    };

    // GS.inputbox('test1', 'test2', function (strAnswer) {console.log(strAnswer); });
    GS.inputbox = function (strTitle, strMessage, callback, defaultValue) {
        var templateElement = document.createElement('template');

        templateElement.innerHTML = '<gs-page>' +
                                    '    <gs-header><center><h3>' + strTitle + '</h3></center></gs-header>' +
                                    '    <gs-body padded>' +
                                    '        ' + strMessage +
                                    '        <gs-text id="dialog-inputbox-control" value="' + (defaultValue || '') + '"></gs-text>' +
                                    '    </gs-body>' +
                                    '    <gs-footer>' + buttonHTML(['Cancel', 'Ok']) + '</gs-footer>' +
                                    '</gs-page>';

        GS.openDialog(templateElement, '', function (event, strAnswer) {
            if (strAnswer === 'Ok') {
                callback(document.getElementById('dialog-inputbox-control').value);
            } else {
                callback('');
            }
        });
    };
})();

GS.dialogClose = function (dialog, strAnswer) {
    'use strict';
    console.warn('Please use "GS.closeDialog" instead of "GS.dialogClose".');
    dialog.destroy(strAnswer);
};

GS.closeDialog = function (dialog, strAnswer) {
    'use strict';

    if (typeof dialog === 'string') {
        dialog = document.getElementById('dialog-from-' + dialog);
    }

    if (dialog) {
        dialog.destroy(strAnswer);
    } else {
        console.warn('GS.closeDialog Warning: Dialog not found.');
    }
};

(function () {
    'use strict';

    // on focus: if the currently focus element is not in the frontmost dialog: focus first control of the frontmost dialog
    document.addEventListener('focus', function (event) {
        var arrDialog = xtag.queryChildren(document.body, 'gs-dialog[focus-lock]');
        var frontDialog;
        var parentFind;
        var arrElements;
        var i;
        var len;

        //console.log('1*** focus: ', document.activeElement, arrDialog);
        if (arrDialog.length > 0) {
            frontDialog = arrDialog[arrDialog.length - 1];
            parentFind = GS.findParentElement(document.activeElement, frontDialog);

            //console.log('2***', parentFind, frontDialog);
            if (parentFind !== frontDialog) {
                arrElements = xtag.query(frontDialog, 'input, textarea, select, button, iframe, [tabindex], a');

                for (i = 0, len = arrElements.length; i < len; i += 1) {
                    if (GS.isElementFocusable(arrElements[i])) {
                        arrElements[i].focus();
                        break;
                    }
                }
                //console.log('3***');
            }
        }
    }, true);

    // DEPRECATED
    GS.dialog = function (options) {
        var strHTML, dialogOverlay, dialog, strContent = '', strButtons = '', i, len, gridEach,
            arrElements, tapHandler, strHeader, sizingFunction, observer, returnTarget;

        // change button parameter to array format if it is string format (and the string is recognized)
        if (typeof options.buttons === 'string') {
            if (options.buttons === 'okcancel' || options.buttons === 'cancelok') {
                options.buttons = ['Cancel', 'Ok'];

            } else if (options.buttons === 'ok' || options.buttons === 'okonly') {
                options.buttons = ['Ok'];

            } else if (options.buttons === 'cancel' || options.buttons === 'cancelonly') {
                options.buttons = ['Cancel'];

            } else if (options.buttons === 'yesno' || options.buttons === 'noyes') {
                options.buttons = ['No', 'Yes'];

            } else if (options.buttons === 'Yes' || options.buttons === 'yesonly') {
                options.buttons = ['Yes'];

            } else if (options.buttons === 'No' || options.buttons === 'noonly') {
                options.buttons = ['No'];
            }
        }

        // option defaults
        options.theme      = options.theme        || 'regular';
        options.type       = options.type         || 'html';
        options.header     = options.header       || '';
        options.content    = options.content      || '';
        options.buttons    = options.buttons      || ['Ok']; // either array or string
        options.max_width  = options.max_width    || '700px';
        options.max_height = options.max_height   || '700px';
        options.mode       = options.mode         || 'detect'; // phone, touch, constrained, full, detect
        options.padded     = options.padded       || false;
        options.autofocus  = (options.autofocus === undefined ? true : false);

        // if type is html or, use content as is
        if (options.type === 'html') {
            strContent = options.content;
            strHeader = options.header;

        // if type is formatted-html, wrap content with a <pre>
        } else if (options.type === 'formatted-html') {
            strContent = '<pre gs-dynamic>' + options.content + '</pre>';
            strHeader = '<pre gs-dynamic>' + options.header + '</pre>';

        // if type is text, encode to be text only
        } else if (options.type === 'text') {
            strContent = encodeHTML(options.content);
            strHeader = encodeHTML(options.header);

        // if type is formatted-text, encode to be text only, and wrap with a <pre>
        } else if (options.type === 'formatted-text') {
            strContent = '<pre gs-dynamic>' + encodeHTML(options.content) + '</pre>';
            strHeader = '<pre gs-dynamic>' + encodeHTML(options.header) + '</pre>';

        // if type is unrecognized, use content as is
        } else {
            console.warn('Dialog type not recognized... Defaulting to \'html\'.');
            strContent = options.content;
            strHeader = options.header;
        }

        // if buttons is an array, build array into button html
        if (typeof options.buttons === 'object') {
            if (options.buttons.length > 0) {
                strButtons = '<gs-grid gs-dynamic>';

                for (i = 0, len = options.buttons.length; i < len; i += 1) {
                    strButtons +=
                        '<gs-block gs-dynamic>' +
                            '<gs-button dialogclose ' + (i === len - 1 ? 'bg-primary listen-for-return' : '') + ' gs-dynamic>' +
                                encodeHTML(options.buttons[i]) +
                            '</gs-button>' +
                        '</gs-block>';
                }
                strButtons += '</gs-grid>';
            } else {
                strButtons = '';
            }

        // if buttons is not an array, use as html
        } else {
            strButtons = options.buttons;
        }

        // append dialog overlay element
        dialogOverlay = GS.stringToElement('<gs-dialog-overlay gs-dynamic></gs-dialog-overlay>');
        document.body.appendChild(dialogOverlay);

        dialogOverlay.addEventListener(evt.mousedown, function (event) {
            event.preventDefault();
        });
        dialogOverlay.addEventListener(evt.mousemove, function (event) {
            event.preventDefault();
        });

        // build dialog html
        strHTML = '<gs-dialog class="' + encodeHTML(options.theme) + '" gs-dynamic focus-lock ';

        // if mode is set to phone or touch and we are not on those types of devices: change mode to detect
        if ((options.mode === 'touch' && !evt.touchDevice) || (options.mode === 'phone' && evt.deviceType !== 'phone')) {
            options.mode = 'detect';
        }

        // deal with full page mode
        if ((options.mode === 'touch' && evt.touchDevice) || (options.mode === 'phone' && evt.deviceType === 'phone') || options.mode === 'full') {
            strHTML += 'style="width: 100%; height: 100%; top: 0;">';

        } else if (options.mode === 'constrained') {
            strHTML += 'style="max-width: ' + options.max_width + '; max-height: ' + options.max_height + '; width: 94%; height: 90%;">';// auto
                             //width: ' + options.width + '; ' +
                             //'height: ' + options.height + '; ' +
                             //'top: ' + options.top + '; ' +
                             //'margin-left: -' + ((parseInt(options.width, 10) / 2) + options.width.replace(/[0-9]/g, '')) + ';">' +

        } else { // if (options.mode === 'constrained')
            strHTML += 'style="max-width: ' + options.max_width + '; width: 94%;">';
        }

        strHTML +=      '<gs-page gs-dynamic>' +
                            (options.header ? '<gs-header gs-dynamic>' + strHeader + '</gs-header>' : '') +
                            '<gs-body' + (options.padded ? ' padded' : '') + ' gs-dynamic>' + strContent + '</gs-body>' +
                           (strButtons ? '<gs-footer gs-dynamic>' + strButtons + '</gs-footer>' : '') +
                        '</gs-page>' +
                    '</gs-dialog>';

        // append dialog
        dialog = GS.stringToElement(strHTML);
        document.body.appendChild(dialog);
        document.body.parentNode.classList.add('no-scroll-except-for-dialog');

        // bind dialog
        dialog.addEventListener('beforeclose', function (event) {
            if (typeof options.before_close === 'function') {
                options.before_close.apply(dialog, [event.originalEvent, event.data]);
            }
        });
        dialog.addEventListener('afterclose', function (event) {
            if (typeof options.after_close === 'function') {
                options.after_close.apply(dialog, [event.originalEvent, event.data]);
            }
        });

        if (!template.hasAttribute('no-focus-lock')) {
            // focus autofocus element if there is one
            arrElements = xtag.query(dialog, '[autofocus]');

            if (arrElements.length > 0) {
                arrElements[0].focus();

            // else if there is a listen-for-return: focus that
            } else {
                arrElements = xtag.query(dialog, '[listen-for-return]');

                if (arrElements.length > 0) {
                    arrElements[0].focus();
                }
            }
        }

        // bind listening for return if there is an element with the "listen-for-return"
        arrElements = xtag.query(dialog, '[listen-for-return]');

        if (arrElements.length > 0) {
            returnTarget = arrElements[0];

            dialog.addEventListener('keydown', function (event) {
                if (event.target !== returnTarget && (event.keyCode === 13 || event.which === 13)) {
                    GS.triggerEvent(returnTarget, 'click');
                }
            });

            if (arrElements.length > 1) {
                console.warn('dialog Warning: Too many [listen-for-return] elements, defaulting to the first one. Please have only one [listen-for-return] element per dialog.');
            }
        }

        // if mode is detect: do/bind detection
        if (options.mode === 'detect') {
            sizingFunction = function () {
                if (dialog.parentNode !== document.body) {
                    window.removeEventListener('resize', sizingFunction);
                    window.removeEventListener('orientationchange', sizingFunction);
                    observer.disconnect();

                    return;
                }

                // if dialog is taller than 98% of the window: add max-height and height
                if (dialog.offsetHeight > ((window.innerHeight / 100) * 98)) {
                    dialog.style.height = '98%';
                    dialog.style.maxHeight = options.max_height;
                }
            };

            sizingFunction();

            window.addEventListener('resize', sizingFunction);
            window.addEventListener('orientationchange', sizingFunction);

            observer = new MutationObserver(sizingFunction);
            observer.observe(dialog, {childList: true, subtree: true, attributes: true});
        }

        // after open function call
        if (typeof options.after_open === 'function') {
            options.after_open.apply(dialog, []);
        }

        return dialog;
    };


    GS.openDialog = function (templateLink, afterOpenFunction, beforeCloseFunction, afterCloseFunction) {
        var template, templateID, strHTML, dialogOverlay, dialog, i, len, arrCloseButtons, clickHandler, sizingFunction,
            observer, arrElements, strTag, returnTarget, strTheme, strMaxWidth, strMaxHeight, strMode, refocusElement,
            scrollTarget, jsnInitalMousePos, scrollProtectorTouchStart, scrollProtectorTouchMove, scrollProtectorMouseWheel,
            strTag, xtagSelector, intervalID, intervalI, headerId;

        // get template
        if (typeof templateLink === 'string') {
            template = document.getElementById(templateLink);
        } else {
            template = templateLink;
        }
        if (template.innerHTML.indexOf('&gt;') > -1 || template.innerHTML.indexOf('&lt;') > -1) {
            console.warn('GS-DIALOG WARNING: &gt; or &lt; detected in dialog template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
        }

        // save and blur currently focused element
        refocusElement = document.activeElement;

        if (!template.hasAttribute('no-focus-lock')) {
            refocusElement.blur();
        }

        // save template ID
        templateID = template.getAttribute('id');

        // warn if a dialog already uses this ID
        if (templateID && document.getElementById('dialog-from-' + templateID)) {
            console.warn('GS.openDialog Warning: A dialog using the ID "' + templateID + '" is already open.');
        }

        // handle autofocus
        arrElements = xtag.query(template.content, '[autofocus]');
        //console.log('arrElements', arrElements, template.content);

        // if there are not autofocus elements: add autofocus to first control in the template
        if (arrElements.length === 0) {
            arrElements = xtag.query(template.content, '*');

            if (arrElements.length > 0) {
                for (i = 0, len = arrElements.length; i < len; i += 1) {
                    strTag = arrElements[i].nodeName.toLowerCase();

                    if (GS.isElementFocusable(arrElements[i]) ||
                        (
                            xtag.tags[strTag] &&
                            xtag.tags[strTag].methods &&
                            xtag.tags[strTag].methods.focus
                        )) {
                        arrElements[i].setAttribute('autofocus', '');
                        break;
                    }
                }
            }

        // warn if there are too many autofocus elements
        } else if (arrElements.length > 1) {
            for (i = 1, len = arrElements.length; i < len; i += 1) {
                arrElements[i].removeAttribute('autofocus');
            }

            console.warn('dialog Warning: Too many [autofocus] elements, defaulting to the first one. Please have only one [autofocus] element per dialog.');
        }

        // get and default parameters
        strTheme     = (template.getAttribute('data-theme') === 'error' ? 'error' : 'regular');
        strMaxWidth  = template.getAttribute('data-max-width')  || '700px';
        strMaxHeight = template.getAttribute('data-max-height') || '700px';
        strMode      = template.getAttribute('data-mode')       || 'detect'; // phone, touch, constrained, full, detect
        if (template.content.children[0].tagName.toUpperCase() === 'GS-HEADER') {
            var header = template.content.children[0];
            var h1 = header.getElementsByTagName('h1')[0];
            var h2 = header.getElementsByTagName('h2')[0];
            var h3 = header.getElementsByTagName('h3')[0];
            var h4 = header.getElementsByTagName('h4')[0];
            var h5 = header.getElementsByTagName('h5')[0];
            var h6 = header.getElementsByTagName('h6')[0];
          //console.log(header, h1, h2, h3, h4, h5, h6);

            var h = h1 || h2 || h3 || h4 || h5 || h6;
            if (h) {
                if (!h.hasAttribute('id')) {
                    h.setAttribute('id', 'dialog-header-' + templateID);
                }
                headerId = h.getAttribute('id');
            }
        }

        // build full dialog html
        strHTML = '<gs-dialog role="alertdialog" aria-modal="true"' + (headerId ? ' aria-labelledby="' + headerId +'"' : '') + ' ' + (templateID ? 'id="dialog-from-' + templateID + '" ' : '') + 'class="' + strTheme + '" gs-dynamic ';

        if (!template.hasAttribute('no-focus-lock')) {
            strHTML += 'focus-lock ';
        }

        // if mode is set to phone or touch and we are not on those types of devices: change mode to detect
        if ((strMode === 'touch' && !evt.touchDevice) || (strMode === 'phone' && evt.deviceType !== 'phone')) {
            strMode = 'detect';
        }

        // deal with full page mode
        if ((strMode === 'touch' && evt.touchDevice) || (strMode === 'phone' && evt.deviceType === 'phone') || strMode === 'full') {
            strHTML += 'style="width: 100%; height: 100%; top: 0;">';

        } else if (strMode === 'constrained') {
            strHTML += 'style="max-width: ' + strMaxWidth + '; max-height: ' + strMaxHeight + '; width: 94%; height: 90%;">';

        } else {
            strHTML += 'style="max-width: ' + strMaxWidth + '; width: 94%;">';
        }

        strHTML +=      '<gs-page gs-dynamic>' +
                            template.innerHTML +
                        '</gs-page>' +
                    '</gs-dialog>';

        // get elements
        dialog = GS.stringToElement(strHTML);

        if (template.hasAttribute('data-no-overlay')) {
            dialogOverlay = GS.stringToElement(
                '<gs-dialog-overlay style="display: none;" gs-dynamic' +
                (
                    template.hasAttribute('no-background')
                        ? ' no-background '
                        : ''
                ) +
                '></gs-dialog-overlay>'
            );
        } else {
            dialogOverlay = GS.stringToElement(
                '<gs-dialog-overlay gs-dynamic' +
                (
                    template.hasAttribute('no-background')
                        ? ' no-background '
                        : ''
                ) +
                '></gs-dialog-overlay>'
            );
        }

        // append overlay element
        document.body.appendChild(dialogOverlay);

        // if the template has: data-overlay-close: bind overlay
        if (template.hasAttribute('data-overlay-close')) {
            dialogOverlay.addEventListener(evt.mousedown, function (event) {
                GS.closeDialog(dialog, 'overlay');
            });
        }

        // bind overlay element
        dialogOverlay.addEventListener(evt.mousedown, function (event) {
            event.preventDefault();
        });
        dialogOverlay.addEventListener(evt.mousemove, function (event) {
            event.preventDefault();
        });
        dialogOverlay.addEventListener('mousewheel', function (event) {
            event.preventDefault();
        });
    

        // used by TFW, effective 2022-06-28
        // If this note is still here in a few weeks it's probably stable (;
        // only draggable by header
        if (template.hasAttribute('data-draggable')) {
            dialog.bolDraggable = true;
            xtag.query(dialog, 'gs-header').forEach(function (curr) {
                curr.style.userSelect = 'none';
                curr.addEventListener('mousedown', function (event) {
                    dialog.dragOriginX = event.screenX;
                    dialog.dragOriginY = event.screenY;
                    dialog.bolMouseDown = true;
                });
            });
            window.addEventListener('mouseup', function (event) {
                dialog.bolMouseDown = false;
            });
            dialog.addEventListener('mousemove', function (event) {
                if (dialog.bolMouseDown) {
                    dialog.style.left = Math.min(Math.max((GS.getElementOffset(dialog).left - (dialog.dragOriginX - event.screenX)), 0), (window.innerWidth - GS.getElementOffset(dialog).width)) + 'px';
                    dialog.style.top = Math.min(Math.max((GS.getElementOffset(dialog).top - (dialog.dragOriginY - event.screenY)), 0), (window.innerHeight - GS.getElementOffset(dialog).height)) + 'px';
                    dialog.dragOriginX = event.screenX;
                    dialog.dragOriginY = event.screenY;
                }
            });
            dialog.setAttribute('draggable-window-listen', '');
        }

        // append dialog
        document.body.appendChild(dialog);
        //document.body.parentNode.classList.add('no-scroll-except-for-dialog');

        // bind dialog
        scrollProtectorTouchStart = function (event) {
            if (dialog.parentNode !== document.body) {
                dialog.removeEventListener('touchstart', scrollProtectorTouchStart);
                return true;
            }

            scrollTarget = GS.scrollParent(event.target);

            //console.log(scrollTarget);

            if (!scrollTarget || !GS.findParentTag(scrollTarget, 'gs-dialog')) {
                scrollTarget = dialog;
            }

            //console.log(scrollTarget);

            jsnInitalMousePos = GS.mousePosition(event);
        };

        scrollProtectorTouchMove = function (event) {
            var jsnMousePos = GS.mousePosition(event), bolVertical, bolHorizontal;

            if (dialog.parentNode !== document.body) {
                dialog.removeEventListener('touchmove', scrollProtectorTouchMove);
                return true;
            }

            //console.log('2***', scrollTarget, jsnInitalMousePos, jsnMousePos);

            if (Math.abs(jsnInitalMousePos.top - jsnMousePos.top) > Math.abs(jsnInitalMousePos.left - jsnMousePos.left)) {
                bolVertical = true;
            } else {
                bolHorizontal = true;
            }

            //console.log(bolVertical, bolHorizontal);

            // if down  AND we are already at the top
            // if up    AND we are already at the bottom
            // if right AND we are already at the left
            // if left  AND we are already at the right

            if ((bolVertical && (
                    (jsnInitalMousePos.top < jsnMousePos.top && scrollTarget.scrollTop <= 0) ||
                    (jsnInitalMousePos.top > jsnMousePos.top &&
                        (scrollTarget.scrollTop + scrollTarget.clientHeight) >= scrollTarget.scrollHeight))) ||
                (bolHorizontal && (
                    (jsnInitalMousePos.left < jsnMousePos.left && scrollTarget.scrollLeft <= 0) ||
                    (jsnInitalMousePos.left > jsnMousePos.left &&
                        (scrollTarget.scrollLeft + scrollTarget.clientWidth) >= scrollTarget.scrollWidth)))) {
                event.preventDefault();
                event.stopPropagation();
            }
        };

        scrollProtectorMouseWheel = function (event) {
            var target = GS.scrollParent(event.target); //event.target;

            //console.log(target);

            if (dialog.parentNode !== document.body) {
                dialog.removeEventListener('mousewheel', scrollProtectorMouseWheel);
                return true;
            }

            //console.log(event.deltaY, event.deltaX,
            //            target.scrollTop, target.scrollLeft,
            //            target.scrollHeight, target.scrollWidth,
            //            target.clientHeight, target.clientWidth);

            // if event.deltaY < 0 AND we are already at the top
            // if event.deltaY > 0 AND we are already at the bottom
            // if event.deltaX < 0 AND we are already at the left
            // if event.deltaX > 0 AND we are already at the right

            if ((event.deltaY < 0 && target.scrollTop <= 0) ||
                (event.deltaY > 0 && (target.scrollTop + target.clientHeight) >= target.scrollHeight) ||
                (event.deltaX < 0 && target.scrollLeft <= 0) ||
                (event.deltaX > 0 && (target.scrollLeft + target.clientWidth) >= target.scrollWidth)) {
                //console.log('prevented');

                event.preventDefault();
                event.stopPropagation();
            }
        };

        if (!template.hasAttribute('unprotected-scroll')) {
            if (evt.touchDevice) {
                window.addEventListener('touchstart', scrollProtectorTouchStart);
                window.addEventListener('touchmove', scrollProtectorTouchMove);
            }
    
            dialog.addEventListener('mousewheel', scrollProtectorMouseWheel);
        }

        dialog.addEventListener('beforeclose', function (event) {
            if (typeof beforeCloseFunction === 'function') {
                beforeCloseFunction.apply(dialog, [event.originalEvent, event.data]);
            }
        });

        dialog.addEventListener('afterclose', function (event) {
            refocusElement.focus();
            if (typeof afterCloseFunction === 'function') {
                afterCloseFunction.apply(dialog, [event.originalEvent, event.data]);
            }
        });


        // if mode equals 'detect'
        //console.log(strMode);
        if (strMode === 'detect') {
            // do/bind size detection
            sizingFunction = function () {
                if (dialog.parentNode !== document.body) {
                    window.removeEventListener('resize', sizingFunction);
                    window.removeEventListener('orientationchange', sizingFunction);
                    observer.disconnect();

                    return;
                }

                // if dialog is taller than 98% of the window: add max-height and height
                if (dialog.offsetHeight > ((window.innerHeight / 100) * 98)) {
                    dialog.style.height = '98%';
                    dialog.style.maxHeight = strMaxHeight;
                }
            };

            sizingFunction();

            window.addEventListener('resize', sizingFunction);
            window.addEventListener('orientationchange', sizingFunction);

            observer = new MutationObserver(sizingFunction);
            observer.observe(dialog, {childList: true, subtree: true, attributes: true});
        }


        var elementReadyCallback = function () {
            if (!template.hasAttribute('no-focus-lock')) {
                // focus autofocus element if there is one
                arrElements = xtag.query(dialog, '[autofocus]');

                if (arrElements.length > 0) {
                    arrElements[0].focus();

                // else if there is a listen-for-return: focus that
                } else {
                    arrElements = xtag.query(dialog, '[listen-for-return]');

                    if (arrElements.length > 0) {
                        arrElements[0].focus();
                    }
                }
            }

            // bind listening for return if there is an element with the "listen-for-return"
            arrElements = xtag.query(dialog, '[listen-for-return]');

            if (arrElements.length > 0) {
                returnTarget = arrElements[0];

                dialog.addEventListener('keydown', function (event) { // keydown, keyup, keypress
                    if (event.target !== returnTarget && (event.keyCode === 13 || event.which === 13)) {
                        //event.stopPropagation();
                        GS.triggerEvent(returnTarget, 'click');
                    }
                });

                if (arrElements.length > 1) {
                    console.warn('dialog Warning: Too many [listen-for-return] elements, defaulting to the first one. Please have only one [listen-for-return] element per dialog.');
                }
            }

            if (typeof afterOpenFunction === 'function') {
                afterOpenFunction.apply(dialog, []);
            }
        };


        // get a list of all the xtag elements
        // if they are not all instantiated check: on an interval until they are all instantiated


        // if element registration is shimmed: we need to wait to run the callback
        //      until after the elements are ready. to do this we'll get a list of
        //      the current elements that are xtag-defined and on a 30ms loop we'll
        //      check their __upgraded__ property until they are all true
        if (shimmed.registerElement === true && shimmed.customElements === true) {
            // build selector to get all xtag elements
            xtagSelector = '';
            for (strTag in xtag.tags) {
                xtagSelector += (xtagSelector ? ',' : '');
                xtagSelector += strTag;
            }

            // get all xtag elements
            var elem_wait = xtag.query(dialog, xtagSelector);
            var elem_i;
            var elem_len;

            // begin interval (max out at 1 second)
            intervalI = 0;
            intervalID = setInterval(function () {
                if (elem_wait.length === 0 || intervalI >= 30) {
                    clearInterval(intervalID);
                    elementReadyCallback();
                } else {
                    elem_i = 0;
                    elem_len = elem_wait.length;
                    while (elem_i < elem_len) {
                        if (elem_wait[elem_i].__upgraded__ === true) {
                            elem_wait.splice(elem_i, 1);
                            elem_i -= 1;
                            elem_len -= 1;
                        }
                        elem_i += 1;
                    }
                }
                intervalI += 1;
            }, 30);

        // else: element instantiation blocks JS execution until the elements
        //      are ready, so we don't need to wait to run the after open callback
        } else {
            elementReadyCallback();
        }


        //// after open function call
        //if (typeof afterOpenFunction === 'function') {
        //    if (dialog.inserted === true) {
        //      //console.log('1***');
        //        afterOpenFunction.apply(dialog, []);
        //    } else {
        //      //console.log('2***', new Date().getTime());
        //        dialog.addEventListener('dialog-inserted', function () {
        //          //console.log('3***', new Date().getTime());
        //            afterOpenFunction.apply(dialog, []);
        //        });
        //    }
        //}

        return dialog;
    };

    GS.openDialogToElement = function (elementTarget, templateLink, strDirectionRequest, afterOpenFunction, beforeCloseFunction, afterCloseFunction) {
        'use strict';
        var positionHandlingFunction, jsnPositionData, divElement = document.createElement('div'), dialogElement, observer,
            intDialogResolvedWidth, intDialogResolvedHeight, strResolvedDirection, intMargin = 5, intElementMidPoint,
            intDialogMidPoint, i, len, arrTests, arrCloseButtons, clickHandler, arrElements, template, strTheme, strMaxWidth,
            strMaxHeight, strTag, dialogOverlay, refocusElement, jsnInitalMousePos, scrollTarget, returnTarget,
            scrollProtectorTouchStart, scrollProtectorTouchMove, scrollProtectorMouseWheel, templateID,
            strTag, xtagSelector, intervalID, intervalI, headerId;

        // get template
        if (typeof templateLink === 'string') {
            template = document.getElementById(templateLink);
        } else {
            template = templateLink;
        }

        // save and blur currently focused element
        refocusElement = document.activeElement;

        if (!template.hasAttribute('no-focus-lock')) {
            refocusElement.blur();
        }

        // save template ID
        templateID = template.getAttribute('id');

        // warn if a dialog already uses this ID
        if (templateID && document.getElementById('dialog-from-' + templateID)) {
            console.warn('GS.openDialog Warning: A dialog using the ID "' + templateID + '" is already open.');
        }

        // handle autofocus
        arrElements = xtag.query(template.content, '[autofocus]');

        // if there are not autofocus elements: add autofocus to first control in the template
        if (arrElements.length === 0) {
            arrElements = xtag.query(template.content, '*');

            if (arrElements.length > 0) {
                for (i = 0, len = arrElements.length; i < len; i += 1) {
                    strTag = arrElements[i].nodeName.toLowerCase();

                    if (GS.isElementFocusable(arrElements[i]) ||
                        (
                            xtag.tags[strTag] &&
                            xtag.tags[strTag].methods &&
                            xtag.tags[strTag].methods.focus
                        )) {
                        arrElements[i].setAttribute('autofocus', '');
                        break;
                    }
                }
            }

        // warn if there are too many autofocus elements
        } else if (arrElements.length > 1) {
            for (i = 1, len = arrElements.length; i < len; i += 1) {
                arrElements[i].removeAttribute('autofocus');
            }

            console.warn('dialog Warning: Too many [autofocus] elements, defaulting to the first one. Please have only one [autofocus] element per dialog.');
        }

        // get and default parameters
        strTheme     = (template.getAttribute('data-theme') === 'error' ? 'error' : 'regular');
        strMaxWidth  = template.getAttribute('data-max-width')  || '700px';
        strMaxHeight = template.getAttribute('data-max-height') || '700px';

        if (template.content.children[0].tagName.toUpperCase() === 'GS-HEADER') {
            var header = template.content.children[0];
            var h1 = header.getElementsByTagName('h1')[0];
            var h2 = header.getElementsByTagName('h2')[0];
            var h3 = header.getElementsByTagName('h3')[0];
            var h4 = header.getElementsByTagName('h4')[0];
            var h5 = header.getElementsByTagName('h5')[0];
            var h6 = header.getElementsByTagName('h6')[0];
          //console.log(header, h1, h2, h3, h4, h5, h6);

            var h = h1 || h2 || h3 || h4 || h5 || h6;
            if (h) {
                if (!h.hasAttribute('id')) {
                    h.setAttribute('id', 'dialog-header-' + templateID);
                }
                headerId = h.getAttribute('id');
            }
        }

        // create dialog element
        divElement.innerHTML =
            '<gs-dialog role="alertdialog" aria-modal="true"' + (headerId ? ' aria-labelledby="' + headerId +'"' : '') + ' ' +
                    (
                        templateID
                            ? 'id="dialog-from-' + templateID + '" '
                            : ''
                    ) +
                    'class="' + strTheme + '" ' +
                    'style="width: 94%; max-width: ' + strMaxWidth + ';" ' +
                    'no-window-listen ' +
                    (
                        template.hasAttribute('no-focus-lock')
                            ? ''
                            : 'focus-lock '
                    ) +
                    'gs-dynamic>' +
                '<gs-page gs-dynamic>' +
                    template.innerHTML +
                '</gs-page>' +
            '</gs-dialog>';

        dialogElement = divElement.children[0];

        // append dialog overlay element to the body
        dialogOverlay = GS.stringToElement(
            '<gs-dialog-overlay gs-dynamic' +
                    (
                        template.hasAttribute('no-background')
                            ? ' no-background '
                            : ''
                    ) +
                '></gs-dialog-overlay>'
        );
        document.body.appendChild(dialogOverlay);

        // if the template has: data-overlay-close: bind overlay
        if (template.hasAttribute('data-overlay-close')) {
            dialogOverlay.addEventListener('click', function (event) {
                GS.closeDialog(dialogElement, 'overlay');
            });
        }

        // bind dialog overlay
        dialogOverlay.addEventListener('mousewheel', function (event) {
            event.preventDefault();
        });

        // append dialog element to the body
        document.body.appendChild(dialogElement);

        // bind dialog
        scrollProtectorTouchStart = function (event) {
            if (dialogElement.parentNode !== document.body) {
                dialogElement.removeEventListener('touchstart', scrollProtectorTouchStart);
                return true;
            }

            scrollTarget = GS.scrollParent(event.target);

            //console.log(scrollTarget);

            if (!scrollTarget || !GS.findParentTag(scrollTarget, 'gs-dialog')) {
                scrollTarget = dialogElement;
            }

            //console.log(scrollTarget);

            jsnInitalMousePos = GS.mousePosition(event);
        };

        scrollProtectorTouchMove = function (event) {
            var jsnMousePos = GS.mousePosition(event), bolVertical, bolHorizontal;

            if (dialogElement.parentNode !== document.body) {
                dialogElement.removeEventListener('touchmove', scrollProtectorTouchMove);
                return true;
            }

            //console.log('2***', scrollTarget, jsnInitalMousePos, jsnMousePos);

            if (Math.abs(jsnInitalMousePos.top - jsnMousePos.top) > Math.abs(jsnInitalMousePos.left - jsnMousePos.left)) {
                bolVertical = true;
            } else {
                bolHorizontal = true;
            }

            //console.log(bolVertical, bolHorizontal);

            // if down  AND we are already at the top
            // if up    AND we are already at the bottom
            // if right AND we are already at the left
            // if left  AND we are already at the right

            if ((bolVertical && (
                    (jsnInitalMousePos.top < jsnMousePos.top && scrollTarget.scrollTop <= 0) ||
                    (jsnInitalMousePos.top > jsnMousePos.top &&
                        (scrollTarget.scrollTop + scrollTarget.clientHeight) >= scrollTarget.scrollHeight))) ||
                (bolHorizontal && (
                    (jsnInitalMousePos.left < jsnMousePos.left && scrollTarget.scrollLeft <= 0) ||
                    (jsnInitalMousePos.left > jsnMousePos.left &&
                        (scrollTarget.scrollLeft + scrollTarget.clientWidth) >= scrollTarget.scrollWidth)))) {
                event.preventDefault();
                event.stopPropagation();
            }
        };

        scrollProtectorMouseWheel = function (event) {
            var target = GS.scrollParent(event.target); //event.target;

            if (dialogElement.parentNode !== document.body) {
                dialogElement.removeEventListener('mousewheel', scrollProtectorMouseWheel);
                return true;
            }

            //console.log(event.deltaY, event.deltaX,
            //            target.scrollTop, target.scrollLeft,
            //            target.scrollHeight, target.scrollWidth,
            //            target.clientHeight, target.clientWidth);

            // if event.deltaY < 0 AND we are already at the top
            // if event.deltaY > 0 AND we are already at the bottom
            // if event.deltaX < 0 AND we are already at the left
            // if event.deltaX > 0 AND we are already at the right

            if ((event.deltaY < 0 && target.scrollTop <= 0) ||
                (event.deltaY > 0 && (target.scrollTop + target.clientHeight) >= target.scrollHeight) ||
                (event.deltaX < 0 && target.scrollLeft <= 0) ||
                (event.deltaX > 0 && (target.scrollLeft + target.clientWidth) >= target.scrollWidth)) {
                event.preventDefault();
                event.stopPropagation();
            }
        };

        if (evt.touchDevice) {
            window.addEventListener('touchstart', scrollProtectorTouchStart);
            window.addEventListener('touchmove', scrollProtectorTouchMove);
        }

        dialogElement.addEventListener('mousewheel', scrollProtectorMouseWheel);

        dialogElement.addEventListener('beforeclose', function (event) {
            if (typeof beforeCloseFunction === 'function') {
                beforeCloseFunction.apply(dialogElement, [event.originalEvent, event.data]);
            }
        });
        dialogElement.addEventListener('afterclose', function (event) {
            refocusElement.focus();
            if (typeof afterCloseFunction === 'function') {
                afterCloseFunction.apply(dialogElement, [event.originalEvent, event.data]);
            }
        });

        if (!template.hasAttribute('no-focus-lock')) {
            // focus autofocus element if there is one
            arrElements = xtag.query(dialogElement, '[autofocus]');

            if (arrElements.length > 0) {
                arrElements[0].focus();

            // else if there is a listen-for-return: focus that
            } else {
                arrElements = xtag.query(dialogElement, '[listen-for-return]');

                if (arrElements.length > 0) {
                    arrElements[0].focus();
                }
            }
        }

        // bind listening for return if there is an element with the "listen-for-return"
        arrElements = xtag.query(dialogElement, '[listen-for-return]');

        if (arrElements.length > 0) {
            returnTarget = arrElements[0];

            dialogElement.addEventListener('keydown', function (event) {
                if (event.target !== returnTarget && (event.keyCode === 13 || event.which === 13)) {
                    GS.triggerEvent(returnTarget, 'click');
                }
            });

            if (arrElements.length > 1) {
                console.warn('dialog Warning: Too many [listen-for-return] elements, defaulting to the first one. Please have only one [listen-for-return] element per dialog.');
            }
        }

        // if no direction was sent: set direction to down
        strDirectionRequest = strDirectionRequest || 'down';

        // make strDirectionRequest lowercase
        strDirectionRequest.toLowerCase();

        // if the direction does not match any valid direction: set direction to down and warn
        if (!strDirectionRequest.match(/^up$|^down$|^left$|^right$|^full$/)) {
            console.warn('GS.openDialogToElement Error: ' +
                                'Direction \'' + strDirectionRequest + '\' not recognized. ' +
                                'Please use \'up\', \'down\', \'left\', \'right\' or \'full\'.');
            strDirectionRequest = 'down';
        }

        /*
        positionHandlingFunction = function () {
            var intDialogTop = '', intDialogLeft = '', intDialogMarginTop = '', intDialogMarginLeft = '', strOldStyle,
                arrElements, arrScrollingElements, i, len, strOverflow;

            // if the dialog is not in the DOM: unbind and skip the contents of the function using return
            if (dialogElement.parentNode !== document.body) {
                window.removeEventListener('resize', positionHandlingFunction);
                window.removeEventListener('orientationchange', positionHandlingFunction);
                observer.disconnect();
                return;
            }

            // save old style attribute
            strOldStyle = dialogElement.getAttribute('style');

            // save scroll numbers
            arrElements = xtag.query(dialogElement, '*');
            arrScrollingElements = [];

            for (i = 0, len = arrElements.length; i < len; i += 1) {
                strOverflow = GS.getStyle(arrElements[i], 'overflow');

                if (strOverflow === 'scroll' ||
                    (strOverflow === 'auto' && arrElements[i].clientHeight < arrElements[i].scrollHeight)) {
                    arrScrollingElements.push(arrElements[i]);
                }
            }

            for (i = 0, len = arrScrollingElements.length; i < len; i += 1) {
                arrScrollingElements[i].oldScrollTop = arrScrollingElements[i].scrollTop;
                arrScrollingElements[i].oldScrollLeft = arrScrollingElements[i].scrollLeft;
            }

            // clear dialog CSS
            dialogElement.style.top        = '';
            dialogElement.style.left       = '';
            dialogElement.style.marginTop  = '';
            dialogElement.style.marginLeft = '';
            dialogElement.style.width      = '94%';
            dialogElement.style.height     = '';
            dialogElement.style.maxHeight  = '';

            //console.log(dialogElement.oldHeight, dialogElement.offsetHeight);

            // if height hasn't changed: restore style
            if (dialogElement.oldHeight === dialogElement.offsetHeight) {
                dialogElement.setAttribute('style', strOldStyle);

                for (i = 0, len = arrScrollingElements.length; i < len; i += 1) {
                    arrScrollingElements[i].scrollTop = arrScrollingElements[i].oldScrollTop;
                    arrScrollingElements[i].scrollLeft = arrScrollingElements[i].oldScrollLeft;
                }

            // else: recalculate style
            } else {
                dialogElement.oldHeight = dialogElement.offsetHeight;

                // resolve dialog width and height

                // if dialog is taller than: window height - (intMargin * 2): add max-height and height
                if (dialogElement.clientHeight > ((window.innerHeight / 100) * 94)) {
                    dialogElement.style.height = '94%';
                    dialogElement.style.maxHeight = strMaxHeight;
                }

                intDialogResolvedWidth  = dialogElement.offsetWidth;
                intDialogResolvedHeight = dialogElement.offsetHeight + 1; // + 1 added to fix occasional scrollbar issue

                // set dialog width and height to resolved width and height
                dialogElement.style.width  = intDialogResolvedWidth  + 'px';
                dialogElement.style.height = intDialogResolvedHeight + 'px';

                // get target position data
                jsnPositionData = GS.getElementPositionData(elementTarget);

                // order of tests depending on direction
                if (strDirectionRequest === 'up') { // up: up, down, left, right, full
                    arrTests = ['up', 'down', 'left', 'right'];

                } else if (strDirectionRequest === 'down') { // down: down, up, left, right, full
                    arrTests = ['down', 'up', 'left', 'right'];

                } else if (strDirectionRequest === 'left') { // left: left, right, down, up, full
                    arrTests = ['left', 'right', 'down', 'up'];

                } else if (strDirectionRequest === 'right') { // right: right, left, down, up, full
                    arrTests = ['right', 'left', 'down', 'up'];

                } else { // full: no tests (just go to full)
                    arrTests = [];
                }

                // up: compare room above to dialog resolved height
                //      pass: display
                //      fail: next test
                for (i = 0, len = arrTests.length; i < len; i += 1) {
                    if ((arrTests[i] ===    'up' && (intDialogResolvedHeight + intMargin) <= jsnPositionData.intRoomAbove) ||
                        (arrTests[i] ===  'down' && (intDialogResolvedHeight + intMargin) <= jsnPositionData.intRoomBelow) ||
                        (arrTests[i] ===  'left' && (intDialogResolvedWidth  + intMargin) <=  jsnPositionData.intRoomLeft) ||
                        (arrTests[i] === 'right' && (intDialogResolvedWidth  + intMargin) <= jsnPositionData.intRoomRight)) {
                        strResolvedDirection = arrTests[i];
                        break;
                    }
                }

                // if we could not resolve to a particular direction: set direction to full screen
                strResolvedDirection = strResolvedDirection || 'full';
                //console.log(strResolvedDirection);

                // if up or down: get as close to horizontally centered on the element as possible
                if (strResolvedDirection === 'up' || strResolvedDirection === 'down') {
                    intElementMidPoint = (jsnPositionData.intElementLeft + (jsnPositionData.intElementWidth / 2));
                    intDialogMidPoint = (intDialogResolvedWidth / 2);
                    //console.log(intElementMidPoint, jsnPositionData.left, jsnPositionData.intElementWidth);

                    // if centered goes past intMargin of the left edge of the screen: go to intMargin from the bottom
                    if (intElementMidPoint - intDialogMidPoint < intMargin) {
                        intDialogLeft = intMargin;
                        //console.log('1***', intMargin);

                    // else if centered goes past intMargin of the right edge of the screen: go to intMargin less than the width of the viewport
                    } else if (intElementMidPoint + intDialogMidPoint > window.innerWidth - intMargin) {
                        intDialogLeft = ((window.innerWidth - intDialogResolvedWidth) - intMargin);
                        //console.log('2***', window.innerWidth, intDialogResolvedWidth, intMargin);

                    // else centered does not go past intMargin of either edge of the screen: center
                    } else {
                        intDialogLeft = (intElementMidPoint - intDialogMidPoint);
                        //console.log('3***', intElementMidPoint, intDialogMidPoint, (intElementMidPoint - intDialogMidPoint) + 'px');
                    }

                // else if left or right: get as close to vertically centered next to the element as possible
                } else if (strResolvedDirection === 'left' || strResolvedDirection === 'right') {
                    intElementMidPoint = (jsnPositionData.intElementTop + (jsnPositionData.intElementHeight / 2));
                    intDialogMidPoint = (intDialogResolvedHeight / 2);

                    //console.log('0***', intElementMidPoint, intDialogMidPoint, window.innerHeight, intMargin, intDialogResolvedHeight);

                    // if centered goes past intMargin of the top edge of the screen: go to intMargin from the bottom
                    if (intElementMidPoint - intDialogMidPoint < intMargin) {
                        intDialogTop = intMargin;
                        //console.log('1***', intMargin);

                    // else if centered goes past intMargin of the bottom edge of the screen: go to intMargin less than the height of the viewport
                    } else if (intElementMidPoint + intDialogMidPoint > window.innerHeight - intMargin) {
                        intDialogTop = ((window.innerHeight - intDialogResolvedHeight) - intMargin);
                        //console.log('2***', window.innerHeight, intDialogResolvedHeight, intMargin);

                    // else centered does not go past intMargin of either edge of the screen: center
                    } else {
                        intDialogTop = (intElementMidPoint - intDialogMidPoint);
                        //console.log('3***', intElementMidPoint, intDialogMidPoint, (intElementMidPoint - intDialogMidPoint) + 'px');
                    }

                // else full: use dialog logic to get width and height and center both vertically and horizontally
                } else {
                    intDialogTop        = '50%';
                    intDialogLeft       = '50%';
                    intDialogMarginTop  = '-' + (intDialogResolvedHeight / 2) + 'px';
                    intDialogMarginLeft = '-' + (intDialogResolvedWidth / 2) + 'px';
                }

                // if direction is up: connect the bottom of the dialog to the top of the element
                if (strResolvedDirection === 'up') {
                    intDialogTop = (jsnPositionData.intElementTop - intDialogResolvedHeight);

                // if direction is down: connect the top of the dialog to the bottom of the element
                } else if (strResolvedDirection === 'down') {
                    intDialogTop = (jsnPositionData.intElementTop + jsnPositionData.intElementHeight);

                // if direction is left: connect the right of the dialog to the left of the element
                } else if (strResolvedDirection === 'left') {
                    intDialogLeft = (jsnPositionData.intElementLeft - intDialogResolvedWidth);

                // if direction is right: connect the left of the dialog to the right of the element
                } else if (strResolvedDirection === 'right') {
                    intDialogLeft = (jsnPositionData.intElementLeft + jsnPositionData.intElementWidth);
                }

                // prevent the dialog from vertically going outside the viewport
                if (intDialogTop + intDialogResolvedHeight > window.innerHeight) {
                    intDialogTop -= (intDialogTop + intDialogResolvedHeight) - window.innerHeight;

                }

                // prevent the dialog from horizontally going outside the viewport
                if (intDialogLeft + intDialogResolvedWidth > window.innerWidth) {
                    intDialogLeft -= (intDialogLeft + intDialogResolvedWidth) - window.innerWidth;
                }

                // apply CSS to the dialog
                dialogElement.style.top        = intDialogTop + 'px';
                dialogElement.style.left       = intDialogLeft + 'px';
                dialogElement.style.marginTop  = intDialogMarginTop + 'px';
                dialogElement.style.marginLeft = intDialogMarginLeft + 'px';
            }
        };

        positionHandlingFunction();
        window.addEventListener('resize', positionHandlingFunction);
        window.addEventListener('orientationchange', positionHandlingFunction);
        */

        var positionHandlingFunction;

        positionHandlingFunction = function () {
            GS.positionHandlingFunction(dialogElement, elementTarget, intMargin, strDirectionRequest, 'full', function () {
                window.removeEventListener('resize', positionHandlingFunction);
                window.removeEventListener('orientationchange', positionHandlingFunction);
                observer.disconnect();
            })
        };

        positionHandlingFunction();
        window.addEventListener('resize', positionHandlingFunction);
        window.addEventListener('orientationchange', positionHandlingFunction);

        // observer: on childlist update: recalculate positioning/sizing
        observer = new MutationObserver(positionHandlingFunction);

        // the observer is on "dialogElement.children[0]" because when we refresh the position of the dialog:
        //      the "style" attribute is changed which causes the observer to run again ergo: infinite loop
        observer.observe(dialogElement.children[0], {childList: true, subtree: true, attributes: true});


        var elementReadyCallback = function () {
            if (!template.hasAttribute('no-focus-lock')) {
                // focus autofocus element if there is one
                arrElements = xtag.query(dialogElement, '[autofocus]');

                if (arrElements.length > 0) {
                    arrElements[0].focus();

                // else if there is a listen-for-return: focus that
                } else {
                    arrElements = xtag.query(dialogElement, '[listen-for-return]');

                    if (arrElements.length > 0) {
                        arrElements[0].focus();
                    }
                }
            }

            // bind listening for return if there is an element with the "listen-for-return"
            arrElements = xtag.query(dialogElement, '[listen-for-return]');

            if (arrElements.length > 0) {
                returnTarget = arrElements[0];

                dialogElement.addEventListener('keydown', function (event) { // keydown, keyup, keypress
                    if (event.target !== returnTarget && (event.keyCode === 13 || event.which === 13)) {
                        //event.stopPropagation();
                        GS.triggerEvent(returnTarget, 'click');
                    }
                });

                if (arrElements.length > 1) {
                    console.warn('dialog Warning: Too many [listen-for-return] elements, defaulting to the first one. Please have only one [listen-for-return] element per dialog.');
                }
            }

            if (typeof afterOpenFunction === 'function') {
                afterOpenFunction.apply(dialogElement, []);
            }
        };

        // if element registration is shimmed: we need to wait to run the callback
        //      until after the elements are ready. to do this we'll get a list of
        //      the current elements that are xtag-defined and on a 30ms loop we'll
        //      check their __upgraded__ property until they are all true
        if (shimmed.registerElement === true && shimmed.customElements === true) {
            // build selector to get all xtag elements
            xtagSelector = '';
            for (strTag in xtag.tags) {
                xtagSelector += (xtagSelector ? ',' : '');
                xtagSelector += strTag;
            }
            
            // get all xtag elements
            var elem_wait = xtag.query(dialogElement, xtagSelector);
            var elem_i;
            var elem_len;
            
            // begin interval (max out at 1 second)
            intervalI = 0;
            intervalID = setInterval(function () {
                if (elem_wait.length === 0 || intervalI >= 30) {
                    clearInterval(intervalID);
                    elementReadyCallback();
                } else {
                    elem_i = 0;
                    elem_len = elem_wait.length;
                    while (elem_i < elem_len) {
                        if (elem_wait[elem_i].__upgraded__ === true) {
                            elem_wait.splice(elem_i, 1);
                            elem_i -= 1;
                            elem_len -= 1;
                        }
                        elem_i += 1;
                    }
                }
                intervalI += 1;
            }, 30);

        // else: element instantiation blocks JS execution until the elements
        //      are ready, so we don't need to wait to run the after open callback
        } else {
            elementReadyCallback();
        }

        //// after open function call
        //if (typeof afterOpenFunction === 'function') {
        //    afterOpenFunction.apply(dialogElement, []);
        //}

        return dialogElement;
    };
})();

(function () {
    'use strict';
    xtag.register('gs-dialog', {
        lifecycle: {
            created: function () {
                if (this.hasAttribute('focus-lock')) {
                    document.body.focus();
                }

                //document.body.parentNode.classList.add('no-scroll-except-for-dialog');
            },

            inserted: function () {
                if (this.inserted !== true) {
                    this.inserted = true;

                    if (!this.hasAttribute('no-window-listen')) {
                        this.bind();

                        this.windowResizeHandler();
                    }

                    this.addEventListener('click', function (event) {
                        var dialogcloseElement = GS.findParentElement(event.target, '[dialogclose]');

                        if (dialogcloseElement && event.target.hasAttribute('dialogclose')) {
                            GS.findParentTag(event.target, 'gs-dialog')
                                .destroy(event.target.getAttribute('dialogclose') || dialogcloseElement.textContent, event);
                        }
                    });

                    GS.triggerEvent(this, 'dialog-inserted');
                }
            },

            removed: function () {
                this.unbind();
            }
        },
        events: {
            //'click:delegate([dialogclose])': function (event) {
            //    var dialogcloseElement = GS.findParentElement(event.target, '[dialogclose]');
            //  //console.log('running...');
            //    GS.findParentTag(event.target, 'gs-dialog')
            //            .destroy(dialogcloseElement.textContent, event);
            //}
        },
        accessors: {},
        methods: {
            bind: function () {
                var element = this;

                if (!element.hasAttribute('no-window-listen') && !element.hasAttribute('draggable-window-listen')) {
                    element.windowResizeHandler = function () {
                        element.style.left = (window.innerWidth / 2) - (element.offsetWidth / 2) + 'px';
                    };

                    window.addEventListener('resize', element.windowResizeHandler);
                    window.addEventListener('orientationchange', element.windowResizeHandler);

                } else if (element.hasAttribute('draggable-window-listen')) {
                    element.windowResizeHandler = function () {
                        element.style.left = Math.max(Math.min((window.innerWidth - element.offsetWidth), GS.getElementOffset(element).left), 0) + 'px';
                        element.style.top = Math.max(Math.min((window.innerHeight - element.offsetHeight), GS.getElementOffset(element).top), 0) + 'px';
                    };

                    window.addEventListener('resize', element.windowResizeHandler);
                    window.addEventListener('orientationchange', element.windowResizeHandler);
                }
            },

            unbind: function () {
                window.removeEventListener('resize', this.windowResizeHandler);
                window.removeEventListener('orientationchange', this.windowResizeHandler);

                GS.triggerEvent(window, 'resize');
            },

            destroy: function (strAnswer, originalEvent) {
                var beforeCloseEvent;

                if (this.parentNode === document.body) {
                    beforeCloseEvent = GS.triggerEvent(this, 'beforeclose', {'data': strAnswer, 'originalEvent': originalEvent});

                    if (!beforeCloseEvent.defaultPrevented && (!originalEvent || !originalEvent.defaultPrevented)) {
                        document.body.removeChild(this.previousElementSibling);
                        document.body.removeChild(this);

                        GS.triggerEvent(this, 'afterclose', {'data': strAnswer, 'originalEvent': originalEvent});

                        if (document.getElementsByTagName('gs-dialog').length === 0) {
                            document.body.parentNode.classList.remove('no-scroll-except-for-dialog');
                        }
                    }
                }
            }
        }
    });

    xtag.register('gs-dialog-overlay', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {}
    });
})();//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, addDataEvents, addAutocompleteProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';

    addSnippet('<gs-dt>', '<gs-dt>', 'gs-dt column="${1:name}"></gs-dt>');
    addSnippet('<gs-dt> With Label', '<gs-dt>', 'label for="${1:dt-insert-start_date}">${2:Start Date}:</label>\n' +
                                                               '<gs-dt id="${1:dt-insert-start_date}" column="${3:start_date}"></gs-dt>');

    addElement('gs-dt', '#controls_dt');

    window.designElementProperty_GSDT = function() {
        addGSControlProps();
        addText('O', 'Column In QS', 'qs');
        addText('V', 'Placeholder', 'placeholder');
        addCheck('V', 'Popup?', 'popup');
        addCombo('D', 'Format', 'format', [
            {"val": "", "txt": "Default (01/01/2015)"},
            {"val": "shortdate", "txt": "shortdate (1/1/15)"},
            {"val": "mediumdate", "txt": "mediumdate (Jan 1, 2015)"},
            {"val": "longdate", "txt": "longdate (January 1, 2015)"},
            {"val": "fulldate", "txt": "fulldate (Thursday, January 1, 2015)"},
            {"val": "isodate", "txt": "isodate (2015-01-01)"},
            {"val": "isodatetime", "txt": "isodatetime (2015-01-01T00:00:00)"},
            {"val": "shorttime", "txt": "shorttime (1:00 AM)"},
            {"val": "mediumtime", "txt": "mediumtime (01:00:00 AM)"},
            {"val": "isotime", "txt": "isotime (01:00:00)"}
        ]);
        addAutocompleteProps();
        addFocusEvents();
        addFlexProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    function getFormatString(element) {
        var strFormat;

        if (element.hasAttribute('format')) {
            strFormat = element.getAttribute('format');
        }

        if (!strFormat) {
            strFormat = 'MM/dd/yyyy';
        } else {
            strFormat = strFormat.replace(/\bshortdate\b/i, 'M/d/yy');
            strFormat = strFormat.replace(/\bnormaldate\b/i, 'MM/dd/yyyy');
            strFormat = strFormat.replace(/\bmediumdate\b/i, 'MMM d, yyyy');
            strFormat = strFormat.replace(/\blongdate\b/i, 'MMMM d, yyyy');
            strFormat = strFormat.replace(/\bfulldate\b/i, 'EEEE, MMMM d, yyyy');
            strFormat = strFormat.replace(/\bshorttime\b/i, 'h:mm a');
            strFormat = strFormat.replace(/\bmediumtime\b/i, 'h:mm:ss a');
            strFormat = strFormat.replace(/\bisodate\b/i, 'yyyy-MM-dd');
            strFormat = strFormat.replace(/\bisotime\b/i, 'HH:mm:ss');
            strFormat = strFormat.replace(/\bisodatetime\b/i, 'yyyy-MM-dd\'T\'HH:mm:ss');
        }

        return strFormat;
    }

    /*function parseDate(str, format) {
        // This truth, we hold to be self-evident. That the universe was created on January 1, 1970.
        var d = new Date('1/1/1970 00:00:00');

        var arrFullMonth = ['january','february','march','april','may','june','july','august','september','october','november','december'];
        var arrShortMonth = ['jan','feb','mar','apr','may','jun','jul','aug','sep','oct','nov','dec'];
        var arrFormatSeparators;
        var strFormatSeparators;
        var regFormatSeparators;
        var arrDate;
        var arrFormat;
        var arrValueRanges;
        var currentValueRange;
        var i;
        var j;
        var n;
        var len;

        arrFormatSeparators = format.match(/[^yMdEHhKAaPpmsS]+/g);
        strFormatSeparators = '[' + arrFormatSeparators.join('').replace(/\[/g, '\\[').replace(/\]/g, '\\]').replace(/-/g, '\\-') + ']';
        regFormatSeparators = new RegExp(strFormatSeparators, 'g');
        arrDate = str.split(regFormatSeparators);
        arrFormat = format.split(regFormatSeparators);
        i = 0;

        if (arrDate.length !== arrFormat.length) {
            return new Date('Invalid Date');
        }

        // y    Full year
        // yyyy Full year
        // yy   Last two digits of the year
        // M    Month number
        // MMM  Month name
        // MMMM Month name
        // d    Day of the month
        // E    Day name (Ignore)
        // H    Hour number (24-hour, midnight 0)
        // h    Hour number (12-hour)
        // AaPp AM/PM
        // m    Minutes
        // s    Seconds
        // S    Milliseconds

        len = arrDate.length;
        while (i < len) {
            if (arrFormat[i].length === 2) {
                arrDate[i] = GS.leftPad(arrDate[i], '0', 2).substring(0, 2);
            }

            if (arrFormat[i].length === 0) {
            } else if (arrFormat[i][0] === 'y') {
                if (arrFormat[i].length === 4 || arrFormat[i].length === 1) {
                    d.setFullYear(parseInt(arrDate[i], 10));

                } else {
                    d.setYear(parseInt(arrDate[i], 10));

                }

            } else if (arrFormat[i][0] === 'M') {
                if (arrFormat[i].length === 4) {
                    d.setMonth(arrFullMonth.indexOf(arrDate[i].toLowerCase()));

                } else if (arrFormat[i].length === 3) {
                    d.setMonth(arrShortMonth.indexOf(arrDate[i].toLowerCase()));

                } else {
                    d.setMonth(parseInt(arrDate[i], 10) - 1);

                }

            } else if (arrFormat[i][0] === 'd') {
                d.setDate(parseInt(arrDate[i], 10));

            } else if (arrFormat[i][0] === 'H') {
                d.setHours(parseInt(arrDate[i], 10));

            } else if (arrFormat[i][0] === 'h') {
                d.setHours(parseInt(arrDate[i], 10));

            } else if (/[AaPp]/.test(arrFormat[i][0])) {
                d.setHours((d.getHours() > 12 ? d.getHours() - 12 : d.getHours()) + (/[Pp]/.test(arrDate[i]) ? 12 : 0));

            } else if (arrFormat[i][0] === 'm') {
                d.setMinutes(parseInt(arrDate[i], 10));

            } else if (arrFormat[i][0] === 's') {
                d.setSeconds(parseInt(arrDate[i], 10));

            } else if (arrFormat[i][0] === 'S') {
                d.setMilliseconds(parseInt(arrDate[i], 10));

            }
            i += 1;
        }

        return d;
    }*/

    function formatDate(dteValue, strFormat) {
        /* (this function contains a (modified) substantial portion of code from another source
            here is the copyright for sake of legality) (Uses code by Matt Kruse)
        Copyright (c) 2006-2009 Rostislav Hristov, Asual DZZD

        Permission is hereby granted, free of charge, to any person obtaining a
        copy of this software and associated documentation files
        (the "Software"), to deal in the Software without restriction,
        including without limitation the rights to use, copy, modify, merge,
        publish, distribute, sublicense, and/or sell copies of the Software,
        and to permit persons to whom the Software is furnished to do so,
        subject to the following conditions:

        The above copyright notice and this permission notice shall be included
        in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/
        var i = 0, j = 0, l = 0, c = '', token = '', x, y, yearLen,
            formatNumber = function (n, s) {
                if (typeof s == 'undefined' || s == 2) {
                  return (n >= 0 && n < 10 ? '0' : '') + n;
                } else {
                    if (n >= 0 && n < 10) {
                       return '00' + n;
                    }
                    if (n >= 10 && n <100) {
                       return '0' + n;
                    }
                    return n;
                }
            },
            locale = {
                monthsFull:   ['January','February','March','April','May','June', 'July','August','September','October','November','December'],
                monthsShort:  ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],
                daysFull:     ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
                daysShort:    ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],
                shortDateFormat: 'M/d/yyyy h:mm a',
                longDateFormat: 'EEEE, MMMM dd, yyyy h:mm:ss a'
            };

        y = dteValue.getFullYear();
        // Nunzio commented this out on Monday, October 19, 2015
        // It was causing an issue during typing in the year field
        /*if (y < 1000) {
            y = String(y + 1900);
        }*/

        var M = dteValue.getMonth() + 1,
            d = dteValue.getDate(),
            E = dteValue.getDay(),
            H = dteValue.getHours(),
            m = dteValue.getMinutes(),
            s = dteValue.getSeconds(),
            S = dteValue.getMilliseconds();

        //console.log(dteValue.getFullYear());

        yearLen = String(y).length;
        dteValue = {
            y: y,
            yyyy: y,
            yy: String(y).substring(yearLen - 2, yearLen),
            M: M,
            MM: formatNumber(M),
            MMM: locale.monthsShort[M-1],
            MMMM: locale.monthsFull[M-1],
            d: d,
            dd: formatNumber(d),
            EEE: locale.daysShort[E],
            EEEE: locale.daysFull[E],
            H: H,
            HH: formatNumber(H)
        };

        //console.log(dteValue);

        if (H === 0) {
            dteValue.h = 12;
        } else if (H > 12) {
            dteValue.h = H - 12;
        } else {
            dteValue.h = H;
        }

        dteValue.hh = formatNumber(dteValue.h);
        dteValue.k = H !== 0 ? H : 24;
        dteValue.kk = formatNumber(dteValue.k);

        if (H > 11) {
            dteValue.K = H - 12;
        } else {
            dteValue.K = H;
        }

        dteValue.KK = formatNumber(dteValue.K);

        if (H > 11) {
            dteValue.a = 'PM';
        } else {
            dteValue.a = 'AM';
        }

        dteValue.m = m;
        dteValue.mm = formatNumber(m);
        dteValue.s = s;
        dteValue.ss = formatNumber(s);
        dteValue.S = S;
        dteValue.SS = formatNumber(S);
        dteValue.SSS = formatNumber(S, 3);

        var result = '';

        i = 0;
        c = '';
        token = '';
        s = false;

        while (i < strFormat.length) {
            token = '';
            c = strFormat.charAt(i);
            if (c == '\'') {
                i++;
                if (strFormat.charAt(i) == c) {
                    result = result + c;
                    i++;
                } else {
                    s = !s;
                }
            } else {
                while (strFormat.charAt(i) == c) {
                    token += strFormat.charAt(i++);
                }
                if (token.indexOf('MMMM') != -1 && token.length > 4) {
                    token = 'MMMM';
                }
                if (token.indexOf('EEEE') != -1 && token.length > 4) {
                    token = 'EEEE';
                }
                if (typeof dteValue[token] != 'undefined' && !s) {
                    result = result + dteValue[token];
                } else {
                    result = result + token;
                }
            }
        }
        console.log(result);
        return result;
    }

    function formatDateHTML(dteValue, strFormat) {
        // This function will generate spans with an attribute saying what part of the format it is
        // so when you click on a gs-dt it selects the correct component
        var strHTML;
        var strValue;
        var arrFormatSeparators;
        var strFormatSeparators;
        var regFormatSeparators;
        var arrDate;
        var arrFormat;
        var arrValueRanges;
        var i;
        var j;
        var len;

        strHTML = '';
        strValue = formatDate(dteValue, strFormat);

        arrFormatSeparators = strFormat.match(/[^yMdEHhKAaPpmsS]+/g);
        strFormatSeparators = '[' + arrFormatSeparators.join('').replace(/\[/g, '\\[').replace(/\]/g, '\\]').replace(/-/g, '\\-') + ']';
        regFormatSeparators = new RegExp(strFormatSeparators, 'g');
        arrDate = strValue.split(regFormatSeparators);
        arrFormat = strFormat.split(regFormatSeparators);
        arrValueRanges = [];
        i = 0;
        j = 0;

        len = arrDate.length;
        while (i < len) {
            arrValueRanges.push({
                start: j,
                end: j + arrDate[i].length
            });
            j += arrDate[i].length + 1;
            i += 1;
        }

        i = 0;
        while (i < len) {
            strHTML += '<span format="' + arrFormat[i] + '">' + strValue.substring(arrValueRanges[i].start, arrValueRanges[i].end) + '</span>';
            if ((i + 1) < len) {
                strHTML += strValue.substring(arrValueRanges[i].end, arrValueRanges[i + 1].start);
            }
            i += 1;
        }

        return strHTML;
    }

    function setArrowRules(element, arrFormat) {
        // this function determines if the day can change the month and if the month can change the year
        // because, if the month is before the day, then it will usually get set first
        var bolDay = false;
        var bolMonth = false;

        var i = 0;
        var len = arrFormat.length;
        var strLetter;
        var dayIndex;
        var monthIndex;
        var yearIndex;

        while (i < len) {
            strLetter = arrFormat[i][0] || 'A'; // sometimes an empty string comes through the format

            if (strLetter === 'd') {
                dayIndex = i;
            }

            if (strLetter === 'M') {
                monthIndex = i;
            }

            if (strLetter === 'y') {
                yearIndex = i;
            }

            i += 1;
        }

        element.internal.bolDayToMonth = dayIndex < monthIndex;
        element.internal.bolMonthToYear = monthIndex < yearIndex;
        element.internal.bolDayToYear = dayIndex < yearIndex && dayIndex < monthIndex;
    }

    function newDateInCurrentTimeZone(str) {
        // this function is to counteract iso style dates being treated as GMT/UTC
        var daysFull = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
        var daysShort = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
        var i = 0;
        var len = 7;
        while (i < len) {
            str = str.replace(daysFull[i], '');
            str = str.replace(daysShort[i], '');
            i += 1;
        }
        
        if (/^[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]($|\ )/.test(str)) {
            str = str.replace('-', '/').replace('-', '/');
        }
        if (/\ [0-9]/.test(str)) {
            str = str.replace(/-[0-9][0-9]$/, '');
            console.log(str);
            return new Date(str);
        } else if (str.indexOf(':') > -1) {
            console.log('1/1/1970 ' + str);
            return new Date('1/1/1970 ' + str);
        } else {
            console.log(str + ' 00:00:00');
            return new Date(str + ' 00:00:00');
        }
    }

    function getNumberOfDaysInMonth(d) {
        d = new Date(d);
        d.setMonth(d.getMonth() + 1);
        d.setDate(0);
        return d.getDate();
    }

    function insertText(str, force) {
        if (!document.queryCommandSupported('insertText') || !document.queryCommandEnabled('insertText') || force) {
            var element = document.activeElement;
            var jsnTextSelection = GS.getInputSelection(element);
            // console.trace(JSON.stringify(jsnTextSelection), element.value);
            element.value = element.value.substring(0, jsnTextSelection.start) + str + element.value.substring(jsnTextSelection.end);
            // console.log(JSON.stringify(jsnTextSelection), element.value);
            element.parentNode.cancelSelectEvent = true;
            GS.setInputSelection(element, jsnTextSelection.start + str.length, jsnTextSelection.start + str.length);
            // console.log(JSON.stringify(GS.getInputSelection(element)), jsnTextSelection.start + str.length);
        } else {
            var element = document.activeElement;
            // console.log(element);
            // console.log(element.value, element.parentNode.value);
            var res = document.execCommand('insertText', true, str);
            if (!res) {
                console.warn('Could not use insertText command, overriding. Undo will not work.');
                insertText(str, true);
            }
            // console.log(element.value, element.parentNode.value, res);
        }
    }

    function controlKeydownFunction(event) {
        var element = event.target.parentNode;

        if (!event.ctrlKey && !event.metaKey && !event.altKey) {
            var strValue = element.control.value;
            var intKeyCode = (event.keyCode || event.which);
            var jsnTextSelection;

            var format;
            var arrFormatSeparators;
            var strFormatSeparators;
            var regFormatSeparators;
            var arrDate;
            var arrFormat;
            var arrValueRanges;
            var currentValueRange;
            var i;
            var j;
            var len;

            var getValueRanges = function () {
                arrFormatSeparators = format.match(/[^yMdEHhKAaPpmsS]+/g);
                strFormatSeparators = '[' + arrFormatSeparators.join('').replace(/\[/g, '\\[').replace(/\]/g, '\\]').replace(/-/g, '\\-') + ']';
                regFormatSeparators = new RegExp(strFormatSeparators, 'g');
                arrDate = strValue.split(regFormatSeparators);
                arrFormat = format.split(regFormatSeparators);
                arrValueRanges = [];
                i = 0;
                j = 0;

                len = arrDate.length;
                while (i < len) {
                    arrValueRanges.push({
                        start: j,
                        end: j + arrDate[i].length
                    });
                    j += arrDate[i].length + 1;
                    i += 1;
                }
            };

            format = getFormatString(element);
            getValueRanges();

            jsnTextSelection = GS.getInputSelection(element.control);
            currentValueRange = -2;
            i = 0;
            len = arrValueRanges.length;
            while (i < len) {
                if (jsnTextSelection.start >= arrValueRanges[i].start && jsnTextSelection.end <= arrValueRanges[i].end) {
                    currentValueRange = i;
                    break;
                }
                i += 1;
            }

            // left     37
            // up       38
            // right    39
            // down     40

            //console.log('intKeyCode', intKeyCode);

            // arrowing and special advancement characters (see above)
            if (intKeyCode >= 37 && intKeyCode <= 40 && element.internal.validDate) {
                event.preventDefault();
                event.stopPropagation();

                // changing sections
                (function () {
                    if (intKeyCode === 37) {
                        if (currentValueRange === -2) {
                            currentValueRange = 0;
                        } else {
                            currentValueRange -= 1;
                        }

                        // when the length is zero, that only means
                        // that there were two speparators in a row
                        // e.g. ", "
                        while (currentValueRange > 0 && arrDate[currentValueRange].length === 0) {
                            currentValueRange -= 1;
                        }
                    } else if (intKeyCode === 39) {
                        if (currentValueRange === -2) {
                            currentValueRange = 0;
                        } else {
                            currentValueRange += 1;
                        }

                        // see above
                        while (currentValueRange < arrDate.length && arrDate[currentValueRange].length === 0) {
                            currentValueRange += 1;
                        }
                    }

                    if (currentValueRange === -2) {
                            currentValueRange = 0;
                    } else if (currentValueRange < 0) {
                        currentValueRange += arrValueRanges.length;
                    } else if (currentValueRange >= arrValueRanges.length) {
                        currentValueRange -= arrValueRanges.length;
                    }
                    //console.log('currentValueRange', currentValueRange);
                    GS.setInputSelection(element.control, arrValueRanges[currentValueRange].start, arrValueRanges[currentValueRange].end);
                }());

                // update value
                (function () {
                    var d = newDateInCurrentTimeZone(element.control.value);
                    var saveDay;
                    var saveMonth;
                    var saveYear;
                    console.log(element.control.value, d, arrFormat[currentValueRange]);
                    if (intKeyCode === 38) {
                        if (/y/.test(arrFormat[currentValueRange])) {
                            d.setFullYear(d.getFullYear() + 1);

                        } else if (/M/.test(arrFormat[currentValueRange])) {
                            if (!element.internal.bolMonthToYear) {
                                saveYear = d.getFullYear();
                            }
                            // this is so we can deal with the differing number of days per month
                            saveDay = d.getDate();
                            d.setDate(1);
                            d.setMonth(d.getMonth() + 1);
                            d.setDate(Math.min(saveDay, getNumberOfDaysInMonth(d)));
                            if (!element.internal.bolMonthToYear) {
                                d.setFullYear(saveYear);
                            }

                        } else if (/[dE]/.test(arrFormat[currentValueRange])) {
                            if (!element.internal.bolDayToMonth) {
                                saveMonth = d.getMonth();
                            }
                            if (!element.internal.bolDayToYear) {
                                saveYear = d.getFullYear();
                            }

                            if (!element.internal.bolDayToMonth && d.getDate() === getNumberOfDaysInMonth(d)) {
                                d.setDate(1);
                            } else {
                                d.setDate(d.getDate() + 1);
                            }

                            if (!element.internal.bolDayToMonth) {
                                d.setMonth(saveMonth);
                            }
                            if (!element.internal.bolDayToYear) {
                                d.setFullYear(saveYear);
                            }

                        } else if (/[HhK]/.test(arrFormat[currentValueRange])) {
                            d.setHours(d.getHours() + 1);

                        } else if (/[Aap]/.test(arrFormat[currentValueRange])) {
                            d.setHours(d.getHours() + (/a/i.test(arrDate[currentValueRange]) ? 12 : -12));

                        } else if (/[m]/.test(arrFormat[currentValueRange])) {
                            d.setMinutes(d.getMinutes() + 1);

                        } else if (/[s]/.test(arrFormat[currentValueRange])) {
                            d.setSeconds(d.getSeconds() + 1);

                        } else if (/[S]/.test(arrFormat[currentValueRange])) {
                            d.setMilliseconds(d.getMilliseconds() + 1);

                        }

                    } else if (intKeyCode === 40) {
                        if (arrFormat[currentValueRange] === 'yyyy') {
                            d.setFullYear(d.getFullYear() - 1);

                        } else if (/y/.test(arrFormat[currentValueRange])) {
                            d.setYear(d.getYear() - 1);

                        } else if (/M/.test(arrFormat[currentValueRange])) {
                            if (!element.internal.bolMonthToYear) {
                                saveYear = d.getFullYear();
                            }
                            // this is so we can deal with the differing number of days per month
                            saveDay = d.getDate();
                            d.setDate(1);
                            d.setMonth(d.getMonth() - 1);
                            d.setDate(Math.min(saveDay, getNumberOfDaysInMonth(d)));
                            if (!element.internal.bolMonthToYear) {
                                d.setFullYear(saveYear);
                            }

                        } else if (/[dE]/.test(arrFormat[currentValueRange])) {
                            if (!element.internal.bolDayToMonth) {
                                saveMonth = d.getMonth();
                            }
                            if (!element.internal.bolDayToYear) {
                                saveYear = d.getFullYear();
                            }

                            if (!element.internal.bolDayToMonth && d.getDate() === 1) {
                                d.setDate(getNumberOfDaysInMonth(d));
                            } else {
                                d.setDate(d.getDate() - 1);
                            }

                            if (!element.internal.bolDayToMonth) {
                                d.setMonth(saveMonth);
                            }
                            if (!element.internal.bolDayToYear) {
                                d.setFullYear(saveYear);
                            }

                        } else if (/[HhK]/.test(arrFormat[currentValueRange])) {
                            d.setHours(d.getHours() - 1);

                        } else if (/[AaPp]/.test(arrFormat[currentValueRange])) {
                            d.setHours(d.getHours() - (/a/i.test(arrDate[currentValueRange]) ? 12 : -12));

                        } else if (/[m]/.test(arrFormat[currentValueRange])) {
                            d.setMinutes(d.getMinutes() - 1);

                        } else if (/[s]/.test(arrFormat[currentValueRange])) {
                            d.setSeconds(d.getSeconds() - 1);

                        } else if (/[S]/.test(arrFormat[currentValueRange])) {
                            d.setMilliseconds(d.getMilliseconds() - 1);

                        }
                    }
                    console.log(d);

                    element.internal.validDate = d.toString() !== 'Invalid Date';
                    console.log(element.internal.validDate);
                    if (element.internal.validDate) {
                        element.internal.lastValidDate = d;
                        strValue = formatDate(d, getFormatString(element));
                        element.internal.lastValidValue = strValue;
                        getValueRanges();
                        GS.setInputSelection(element.control, 0, element.control.value.length);
                        insertText(strValue);
                        GS.setInputSelection(element.control, arrValueRanges[currentValueRange].start, arrValueRanges[currentValueRange].end);
                    } else {
                        GS.setInputSelection(element.control, 0, element.control.value.length);
                        insertText('Invalid Date');
                        setTimeout(function() {
                            element.control.value = null;
                        }, 250);
                    }
                }());

            // this is reached if it's an invalid date
            } else if (intKeyCode >= 37 && intKeyCode <= 40) {
                event.preventDefault();

            // return should save
            } else if (intKeyCode === 13) {
                GS.triggerEvent(element.control, 'change');

            } else if (intKeyCode === 32) {
                event.preventDefault();
                var d = newDateInCurrentTimeZone(element.control.value);

                element.internal.lastValidDate = d;
                strValue = formatDate(d, getFormatString(element));
                element.internal.lastValidValue = strValue;
                getValueRanges();
                GS.setInputSelection(element.control, 0, element.control.value.length);
                insertText(strValue);

                currentValueRange += 1;
                while (currentValueRange < arrDate.length && arrDate[currentValueRange].length === 0) {
                    currentValueRange += 1;
                }
                if (currentValueRange >= arrDate.length) {
                    currentValueRange -= arrDate.length;
                }

                element.cancelSelectEvent = true;
                GS.setInputSelection(element.control, arrValueRanges[currentValueRange].start, arrValueRanges[currentValueRange].end);
                strValue = element.control.value;

            // everything that doesn't already do something
            } else if (intKeyCode >= 48) {
                var bolAlpha = intKeyCode >= 65 && intKeyCode <= 90;
                var bolNum = (intKeyCode >= 48 && intKeyCode <= 57) || (intKeyCode >= 96 && intKeyCode <= 105);
                var bolAllowTyping = !element.internal.validDate;
                if (bolAlpha && (arrFormat[Math.max(currentValueRange, 0)] === 'MMM' || arrFormat[Math.max(currentValueRange, 0)] === 'MMMM' || (/[AaPp]/).test(arrFormat[Math.max(currentValueRange, 0)]))) {
                    bolAllowTyping = true;
                } else if (bolNum && arrFormat[Math.max(currentValueRange, 0)] !== 'MMM' && arrFormat[Math.max(currentValueRange, 0)] !== 'MMMM') {
                    bolAllowTyping = true;
                }

                if (!bolAllowTyping) {
                    event.preventDefault();

                // when the whole thing is selected, replace the first sub-field
                } else if (currentValueRange < 0 && GS.charFromKeyCode(event)) {
                    event.preventDefault();
                    currentValueRange = 0;
                    GS.setInputSelection(element.control, arrValueRanges[currentValueRange].start, arrValueRanges[currentValueRange].end);
                    element.cancelSelectEvent = true;
                    insertText(GS.charFromKeyCode(event));

                // disallow typing the day name sub-field
                } else if (arrFormat[currentValueRange] === 'EEE' || arrFormat[currentValueRange] === 'EEEE' || (/[AaPp]/.test(arrFormat[currentValueRange]) && intKeyCode !== 65 && intKeyCode !== 80)) {
                    event.preventDefault();

                // only allow typing a or p in AM/PM sub-field
                } else if (/[AaPp]/.test(arrFormat[currentValueRange]) && (intKeyCode === 65 || intKeyCode === 80)) {
                    event.preventDefault();
                    GS.setInputSelection(element.control, arrValueRanges[currentValueRange].start, arrValueRanges[currentValueRange].end);
                    insertText(intKeyCode === 65 ? 'AM' : 'PM');
                    GS.setInputSelection(element.control, arrValueRanges[currentValueRange].start, arrValueRanges[currentValueRange].end);
                    strValue = element.control.value;

                // if there a valid date and we are in a 2-digit field and we have 2 digits, advance
                } else if (element.internal.validDate && currentValueRange >= 0 && arrFormat[currentValueRange].length === 2 && arrDate[currentValueRange].length === 2 && (jsnTextSelection.end - jsnTextSelection.start) === 0) {
                    event.preventDefault();

                    currentValueRange += 1;
                    while (currentValueRange < arrDate.length && arrDate[currentValueRange].length === 0) {
                        currentValueRange += 1;
                    }
                    if (currentValueRange >= arrDate.length) {
                        currentValueRange -= arrDate.length;
                    }

                    element.cancelSelectEvent = true;
                    GS.setInputSelection(element.control, arrValueRanges[currentValueRange].start, arrValueRanges[currentValueRange].end);
                    insertText(GS.charFromKeyCode(event));
                    strValue = element.control.value;
                }
                element.cancelSelectEvent = true;
            }
        }
        element.internal.lastKeyupValue = !bolAllowTyping ? element.internal.lastKeyupValue : undefined;
    }

    function controlKeyupFunction(event) {
        var element = event.target.parentNode;

        var strValue = element.control.value;
        var intKeyCode = (event.keyCode || event.which);
        // slash, dash, dash (firefox), subtract, comma, colon and space
        var arrAdvanceKey = [191, 189, 173, 109, 188, 186, 32];
        var bolAdvanceKey = arrAdvanceKey.indexOf(intKeyCode) > -1;
        var jsnTextSelection;

        var format;
        var arrFormatSeparators;
        var strFormatSeparators;
        var regFormatSeparators;
        var arrDate;
        var arrFormat;
        var arrValueRanges;
        var currentValueRange;
        var intMinValidationLength;
        var intCurrentValueRangeLength;
        var i;
        var j;
        var len;

        var getValueRanges = function () {
            arrFormatSeparators = format.match(/[^yMdEHhKAaPpmsS]+/g);
            strFormatSeparators = '[' + arrFormatSeparators.join('').replace(/\[/g, '\\[').replace(/\]/g, '\\]').replace(/-/g, '\\-') + ']';
            regFormatSeparators = new RegExp(strFormatSeparators, 'g');
            arrDate = strValue.split(regFormatSeparators);
            arrFormat = format.split(regFormatSeparators);
            arrValueRanges = [];
            i = 0;
            j = 0;

            len = arrDate.length;
            while (i < len) {
                arrValueRanges.push({
                    start: j,
                    end: j + arrDate[i].length,
                    len: arrDate[i].length
                });
                j += arrDate[i].length + 1;
                i += 1;
            }
        };

        format = getFormatString(element);
        getValueRanges();

        jsnTextSelection = GS.getInputSelection(element.control);
        currentValueRange = -1;
        i = 0;
        len = arrValueRanges.length;
        while (i < len) {
            if (jsnTextSelection.start >= arrValueRanges[i].start && jsnTextSelection.end <= arrValueRanges[i].end) {
                currentValueRange = i;
                break;
            }
            i += 1;
        }

        if (!((intKeyCode >= 37 && intKeyCode <= 40) || intKeyCode === 27 || intKeyCode < 48) && currentValueRange !== -1) {
            intMinValidationLength = (
                arrFormat[currentValueRange][0] === 'M'     ? (arrFormat[currentValueRange].length === 1 ? 2 : Math.min(arrFormat[currentValueRange].length, 3)) :
                arrFormat[currentValueRange] === 'y'        ? 2 :
                arrFormat[currentValueRange] === 'yy'       ? 2 :
                arrFormat[currentValueRange] === 'yyyy'     ? 4 : 2
            );
            intCurrentValueRangeLength = arrValueRanges[currentValueRange].len;
            //console.log(intCurrentValueRangeLength, intMinValidationLength);

            if (bolAdvanceKey || (intCurrentValueRangeLength >= intMinValidationLength && !(/[AaPp]/.test(arrFormat[currentValueRange]) && intKeyCode !== 65 && intKeyCode !== 80))) {
                var d = newDateInCurrentTimeZone(element.control.value);
                // if (arrFormat[currentValueRange] === 'yyyy') {
                //     d.setFullYear(parseInt(arrDate[currentValueRange], 10));
                // }

                //console.log(element.internal.lastKeyupValue, strValue, intCurrentValueRangeLength, intMinValidationLength);

                element.internal.validDate = d.toString() !== 'Invalid Date' && (element.control.value.match(/[^0-9a-z]/gi)).length >= 2;
                //console.log(element.internal.validDate);
                if (element.internal.validDate && (element.internal.lastKeyupValue || '').toLowerCase() !== strValue.toLowerCase()) {
                    element.internal.lastKeyupValue = element.control.value;

                    element.internal.lastValidDate = d;
                    strValue = formatDate(d, getFormatString(element));
                    element.internal.lastValidValue = strValue;
                    getValueRanges();
                    GS.setInputSelection(element.control, 0, element.control.value.length);
                    insertText(strValue);
                    GS.setInputSelection(element.control, jsnTextSelection.start, jsnTextSelection.end);

                    // advance to next field if at longest valid length
                    if (bolAdvanceKey || intCurrentValueRangeLength >= intMinValidationLength) {
                        currentValueRange += 1;
                        // see above
                        while (currentValueRange < arrDate.length && arrDate[currentValueRange].length === 0) {
                            currentValueRange += 1;
                        }
                        if (currentValueRange >= arrValueRanges.length) {
                            GS.setInputSelection(element.control, 0, strValue.length);
                        } else {
                            GS.setInputSelection(element.control, arrValueRanges[currentValueRange].start, arrValueRanges[currentValueRange].end);
                        }
                    }
                }
            }
        }
    }

    function controlSelectFunction(event) {
        //console.log('controlSelectFunction', event);
        var element = event.target.parentNode;
        if (!element) {
            return;
        }
        var jsnTextSelection = GS.getInputSelection(element.control);
        if ((jsnTextSelection.end - jsnTextSelection.start) === 0 || element.cancelSelectEvent) {
            element.cancelSelectEvent = false;
            return;
        }

        var strValue = element.control.value;
        var intKeyCode = (event.keyCode || event.which);

        var format;
        var arrFormatSeparators;
        var strFormatSeparators;
        var regFormatSeparators;
        var arrDate;
        var arrFormat;
        var arrValueRanges;
        var currentValueRange;
        var i;
        var j;
        var len;

        var getValueRanges = function () {
            arrFormatSeparators = format.match(/[^yMdEHhKAaPpmsS]+/g);
            strFormatSeparators = '[' + arrFormatSeparators.join('').replace(/\[/g, '\\[').replace(/\]/g, '\\]').replace(/-/g, '\\-') + ']';
            regFormatSeparators = new RegExp(strFormatSeparators, 'g');
            arrDate = strValue.split(regFormatSeparators);
            arrFormat = format.split(regFormatSeparators);
            arrValueRanges = [];
            i = 0;
            j = 0;

            len = arrDate.length;
            while (i < len) {
                arrValueRanges.push({
                    start: j,
                    end: j + arrDate[i].length,
                    len: arrDate[i].length
                });
                j += arrDate[i].length + 1;
                i += 1;
            }
        };

        format = getFormatString(element);
        getValueRanges();

        currentValueRange = -1;
        i = 0;
        len = arrValueRanges.length;
        while (i < len) {
            if (jsnTextSelection.start >= arrValueRanges[i].start && jsnTextSelection.end <= arrValueRanges[i].end) {
                currentValueRange = i;
                break;
            }
            i += 1;
        }

        if (currentValueRange >= 0) {
            element.cancelSelectEvent = true;
            GS.setInputSelection(element.control, arrValueRanges[currentValueRange].start, arrValueRanges[currentValueRange].end);
        }
    }

    function arrowMousedownFunction(event) {
        var element = event.target.parentNode.element;//GS.findParentTag(event.target, 'gs-dt');
        event.preventDefault();
        if (evt.touchDevice) {
            element.bolArrowEvent = true;
        }

        GS.triggerEvent(element.control, 'keydown', {
            which: (
                event.target.classList.contains('dt-arrow-left')    ? 37 :
                event.target.classList.contains('dt-arrow-up')      ? 38 :
                event.target.classList.contains('dt-arrow-right')   ? 39 :
                event.target.classList.contains('dt-arrow-down')    ? 40 : 0
            )
        });
    }

    // re-target change event from control to element
    function changeFunction(event) {
        //console.log('changeFunction');
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();

        event.target.parentNode.syncGetters();//iphone sometimes doesn't do a key like with time wheels
        event.target.parentNode.internal.lastChangeValue = event.target.parentNode.value;

        if (event.target.parentNode.changeOldValue !== event.target.value) {
            event.target.parentNode.changeOldValue = event.target.value;
        //if (event.target.parentNode.oldValue !== event.target.value) {
            GS.triggerEvent(event.target.parentNode, 'change');
        }

        return false;
    }

    function focusFunction(event) {
        var element = event.target;
        if (event.target.classList.contains('control')) {
            element = element.parentNode.parentNode;
        }
        element.removeEventListener('focus', focusFunction);
        element.classList.add('focus');
        element.addControl();
        if (element.control.value && element.control.value.length > 0) {
            if (element.bolSelect) {
                element.control.setSelectionRange(0, element.control.value.length);
            } else {
                element.control.setSelectionRange(element.control.value.length, element.control.value.length);
            }
        }
        element.bolSelect = true;
    }

    function mousedownFunction(event) {
        //console.log('mousedownFunction');
        var element = event.target.tagName.toUpperCase() === 'GS-DT' ? event.target : GS.findParentTag(event.target, 'gs-dt');
        if (event.target.tagName.toUpperCase() === 'SPAN') {
            var currentFormat = event.target.getAttribute('format');
            event.preventDefault();
            event.stopPropagation();
            element.focus();

            var strValue = element.value;
            var format;
            var arrFormatSeparators;
            var strFormatSeparators;
            var regFormatSeparators;
            var arrDate;
            var arrFormat;
            var arrValueRanges;
            var currentValueRange;
            var i;
            var j;
            var len;

            var getValueRanges = function () {
                arrFormatSeparators = format.match(/[^yMdEHhKAaPpmsS]+/g);
                strFormatSeparators = '[' + arrFormatSeparators.join('').replace(/\[/g, '\\[').replace(/\]/g, '\\]').replace(/-/g, '\\-') + ']';
                regFormatSeparators = new RegExp(strFormatSeparators, 'g');
                arrDate = strValue.split(regFormatSeparators);
                arrFormat = format.split(regFormatSeparators);
                arrValueRanges = [];
                i = 0;
                j = 0;

                len = arrDate.length;
                while (i < len) {
                    arrValueRanges.push({
                        start: j,
                        end: j + arrDate[i].length
                    });
                    j += arrDate[i].length + 1;
                    i += 1;
                }
            };

            format = getFormatString(element);
            getValueRanges();
            currentValueRange = arrFormat.indexOf(currentFormat);
            GS.setInputSelection(element.control, arrValueRanges[currentValueRange].start, arrValueRanges[currentValueRange].end);
        }
    }

    function controlClickFunction(event) {
        //console.log('controlClickFunction');
        var element = GS.findParentTag(event.target, 'gs-dt');
        var currentFormat = event.target.getAttribute('format');

        var strValue = element.value;
        var format;
        var arrFormatSeparators;
        var strFormatSeparators;
        var regFormatSeparators;
        var arrDate;
        var arrFormat;
        var arrValueRanges;
        var currentValueRange;
        var i;
        var j;
        var len;
        var jsnTextSelection = GS.getInputSelection(element.control);

        var getValueRanges = function () {
            arrFormatSeparators = format.match(/[^yMdEHhKAaPpmsS]+/g);
            strFormatSeparators = '[' + arrFormatSeparators.join('').replace(/\[/g, '\\[').replace(/\]/g, '\\]').replace(/-/g, '\\-') + ']';
            regFormatSeparators = new RegExp(strFormatSeparators, 'g');
            arrDate = strValue.split(regFormatSeparators);
            arrFormat = format.split(regFormatSeparators);
            arrValueRanges = [];
            i = 0;
            j = 0;

            len = arrDate.length;
            while (i < len) {
                arrValueRanges.push({
                    start: j,
                    end: j + arrDate[i].length
                });
                j += arrDate[i].length + 1;
                i += 1;
            }
        };

        format = getFormatString(element);
        getValueRanges();

        currentValueRange = -1;
        i = 0;
        len = arrValueRanges.length;
        while (i < len) {
            if (jsnTextSelection.start >= arrValueRanges[i].start && jsnTextSelection.end <= arrValueRanges[i].end) {
                currentValueRange = i;
                break;
            }
            i += 1;
        }

        if (currentValueRange >= 0) {
            GS.setInputSelection(element.control, arrValueRanges[currentValueRange].start, arrValueRanges[currentValueRange].end);
        }
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        //console.trace(event);
        if (!event.target.parentNode.bolArrowEvent) {
            GS.triggerEvent(event.target.parentNode, 'blur'); //  || !document.queryCommandSupported('insertText') || !document.queryCommandEnabled('insertText')
            if (event.target.parentNode.internal.lastChangeValue !== event.target.parentNode.value) {
                event.target.parentNode.internal.lastChangeValue = event.target.parentNode.value;
                GS.triggerEvent(event.target.parentNode, 'change');
            }
            event.target.parentNode.classList.remove('focus');
            event.target.parentNode.removeControl();
        } else {
            var selection = GS.getInputSelection(event.target);
            event.target.focus();
            GS.setInputSelection(event.target, selection.start, selection.end);
            event.target.parentNode.bolArrowEvent = false;
        }
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseout);
        event.target.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseover);
        event.target.classList.add('hover');
    }

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function createPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.value = strQSValue;
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = null;
            }
        }
    }

    function findFor(element) {
        var forElem;
        //console.log(element, element.previousElementSibling)
        if (element.previousElementSibling && element.previousElementSibling.tagName.toUpperCase() == 'LABEL'
            && element.previousElementSibling.hasAttribute('for')
            && element.previousElementSibling.getAttribute('for') == element.getAttribute('id')
        ) {
            forElem = element.previousElementSibling;
        } else if (xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]').length > 0) {
            forElem = xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]')[0];
        }
        //console.log(forElem);
        if (forElem) {
            forElem.setAttribute('for', element.getAttribute('id') + '_control');
            if (element.control) {
                element.control.setAttribute('id', element.getAttribute('id') + '_control');
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }
            }
        }
        
        /*
            if (element.hasAttribute('id')) {
                findFor(element);
            }
        // please ensure that if the element has an id it is given an id
                if (element.hasAttribute('id')) {
                    element.control.setAttribute('id', element.getAttribute('id') + '_control');
                }
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }
        */
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (!element.hasAttribute('tabindex')) {
                    element.setAttribute('tabindex', '0');
                }
                element.bolSelect = true;

                if (element.getAttribute('value') === 'now' || element.getAttribute('value') === 'today') {
                    //console.log(formatDate(new Date(), getFormatString(element)), new Date(), getFormatString(element));
                    element.setAttribute('value', formatDate(new Date(), getFormatString(element)));
                }

                var arrFormatSeparators;
                var strFormatSeparators;
                var regFormatSeparators;
                var arrFormat;

                arrFormatSeparators = getFormatString(element).match(/[^yMdEHhKAaPpmsS]+/g);
                strFormatSeparators = '[' + arrFormatSeparators.join('').replace(/\[/g, '\\[').replace(/\]/g, '\\]').replace(/-/g, '\\-') + ']';
                regFormatSeparators = new RegExp(strFormatSeparators, 'g');
                arrFormat = getFormatString(element).split(regFormatSeparators);
                setArrowRules(element, arrFormat);

                element.internal.validDate = newDateInCurrentTimeZone(element.getAttribute('value') || '').toString() !== 'Invalid Date';
                if (element.internal.validDate) {
                    element.internal.lastValidValue = element.getAttribute('value');
                    element.internal.lastValidDate = newDateInCurrentTimeZone(element.getAttribute('value'));
                    element.internal.lastValidValue = formatDate(element.internal.lastValidDate, getFormatString(element));
                    element.setAttribute('value', element.internal.lastValidValue);
                } else {
                    element.internal.lastValidValue = '';
                    element.internal.lastValidDate = null;
                }
                element.internal.lastChangeValue = element.internal.lastValidValue;

                if (element.internal.lastValidDate) {
                    element.innerHTML = formatDateHTML(element.internal.lastValidDate, getFormatString(element));
                    element.syncGetters();
                } else if (element.hasAttribute('placeholder')) {
                    element.innerHTML = '<span class="placeholder">' + element.getAttribute('placeholder') + '</span>';
                }

                element.addEventListener('focus', focusFunction);
                element.addEventListener(evt.mousedown, mousedownFunction);
                if (evt.touchDevice) {
                    element.addEventListener(evt.click, focusFunction);
                    element.addEventListener(evt.mousedown, function (event) {
                        //alert(event.touches[0].clientX);
                        element.startX = event.touches[0].clientX;
                        element.startY = event.touches[0].clientY;
                        element.addEventListener('touchmove', function (event) {
                            //alert(event.touches[0].clientX);
                            element.lastX = event.touches[0].clientX;
                            element.lastY = event.touches[0].clientY;

                        });
                    });
                    element.addEventListener(evt.mouseup, function (event) {
                        var target = event.target;
                        //alert(target.outerHTML);
                        //alert(target.startX + ' : ' + target.lastX + ' : ' + target.startY + ' : ' + target.lastY);
                        if (target.lastX && target.lastY &&
                            (parseInt(target.lastX, 10) > (parseInt(target.startX, 10) + 10) ||
                            parseInt(target.lastX, 10) < (parseInt(target.startX, 10) - 10) ||
                            parseInt(target.lastY, 10) > (parseInt(target.startY, 10) + 10) ||
                            parseInt(target.lastY, 10) < (parseInt(target.startY, 10) - 10))
                        ) {
                        } else {
                            focusFunction(event);
                        }

                        /*
                        //if event.target is the control
                        if (event.target.tagName === 'GS-TEXT') {
                            var element = event.target;
                            //alert(event.target.outerHTML);
                            //focus it
                            focusFunction(event);
                            //if we focused it prevent click event from happening
                            if (document.activeElement == element.control) {
                                event.stopImmediatePropagation();
                                event.stopPropagation();
                                event.preventDefault();
                            }
                            //else the click event happens trying again
                        }*/
                    });
                }
                // bind/handle query string
                if (element.getAttribute('qs')) {
                    createPushReplacePopHandler(element);
                    window.addEventListener('pushstate', function () {
                        createPushReplacePopHandler(element);
                    });
                    window.addEventListener('replacestate', function () {
                        createPushReplacePopHandler(element);
                    });
                    window.addEventListener('popstate', function () {
                        createPushReplacePopHandler(element);
                    });
                }
            }
            if (element.hasAttribute('id')) {
                findFor(element);
            }
        }
    }

    xtag.register('gs-dt', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;
                if (element.control) {
                    // if "suspend-created" has been removed: run created and inserted code
                    if (strAttrName === 'suspend-created' && newValue === null) {
                        elementCreated(element);
                        elementInserted(element);

                    // if "suspend-inserted" has been removed: run inserted code
                    } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                        elementInserted(element);

                    } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                        var currentValue;

                        if (strAttrName === 'disabled' || strAttrName === 'readonly') {
                        } else if (strAttrName === 'value' && element.initalized) {
                            currentValue = element.control.value;

                            // if there is a difference between the new value in the
                            //      attribute and the valued in the front end: refresh the front end
                            if (newValue !== currentValue) {
                                element.syncView();
                            }
                        }
                    }
                }
            }
        },
        events: {
            // on keydown and keyup sync the value attribute and the control value
            'keydown': function (event) {
                var element = this;
                if (!element.hasAttribute('readonly') && !element.hasAttribute('disabled')) {
                    element.syncGetters();
                }
            },
            'keyup': function () {
                var element = this;
                if (!element.hasAttribute('readonly') && !element.hasAttribute('disabled')) {
                    element.syncGetters();
                }
            }
        },
        accessors: {
            value: {
                // get value straight from the input
                get: function () {
                    if (this.control) {
                        return this.control.value
                    } else {
                        return this.getAttribute('value');
                    }
                },

                // set the value of the input and set the value attribute
                set: function (strNewValue) {
                    this.setAttribute('value', strNewValue);
                    this.syncView();
                }
            }
        },
        methods: {
            focus: function () {
                var element = this;
                element.bolSelect = false;
                //console.log('test');
                focusFunction({ target: element });
                //GS.triggerEvent(element, 'focus');
            },

            removeControl: function () {
                var element = this;
                if (element.control) {
                    element.setAttribute('tabindex', element.control.getAttribute('tabindex'));
                }
                if (element.control.value) {
                    element.internal.validDate = newDateInCurrentTimeZone(element.control.value).toString() !== 'Invalid Date';
                    if (element.internal.validDate) {
                        element.innerHTML = formatDateHTML(newDateInCurrentTimeZone(element.control.value), getFormatString(element));
                        if (element.arrowElem) {
                            element.arrowElem.parentNode.removeChild(element.arrowElem);
                        }
                    } else {
                        element.removeAttribute('value');
                    }
                    element.syncGetters();
                } else if (element.hasAttribute('placeholder')) {
                    element.innerHTML = '<span class="placeholder">' + element.getAttribute('placeholder') + '</span>';
                    if (element.arrowElem) {
                        element.arrowElem.parentNode.removeChild(element.arrowElem);
                    }
                } else {
                    element.innerHTML = '';
                    if (element.arrowElem) {
                        element.arrowElem.parentNode.removeChild(element.arrowElem);
                    }
                }
                element.control = false;
            },

            addControl: function () {
                var element = this;
                var arrPassThroughAttributes = [
                    'placeholder', 'name', 'maxlength', 'autocorrect',
                    'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                    'readonly', 'disabled'
                ];
                var i;
                var len;
                var elementValue = element.value || '';
                var elementWidth = element.offsetWidth;

                if (element.children.length > 0 && element.children[0].classList.contains('placeholder')) {
                    elementValue = '';
                }
                if (element.value) {
                    var d = newDateInCurrentTimeZone(element.value);
                    element.internal.validDate = d.toString() !== 'Invalid Date';
                    element.internal.lastValidDate = d;
                    element.internal.lastValidValue = formatDate(element.internal.lastValidDate, getFormatString(element));
                    elementValue = element.internal.lastValidValue;
                }

                /*
                // removed because it's confusing
                if (!elementValue) {
                    element.internal.validDate = true;
                    element.internal.lastValidDate = new Date();
                    element.internal.lastValidValue = formatDate(element.internal.lastValidDate, getFormatString(element));
                    elementValue = element.internal.lastValidValue;
                }*/

                // if the gs-dt element has a tabindex: save the tabindex and remove the attribute
                if (element.hasAttribute('tabindex')) {
                    element.savedTabIndex = element.getAttribute('tabindex');
                    element.removeAttribute('tabindex');
                }
                // add control input and save it to a variable for later use
                element.innerHTML = '';
                if (!(element.hasAttribute('disabled') || element.hasAttribute('readonly'))) {
                    element.innerHTML =
                        '<input class="control needsclick" gs-dynamic type="' + (element.getAttribute('type') || 'text') + '" />';// +
                    element.control = element.children[0];
                    
                    element.control.addEventListener(evt.click, controlClickFunction);
                    if (element.hasAttribute('id')) {
                        element.control.setAttribute('id', element.getAttribute('id') + '_control');
                    }
                    if (element.hasAttribute('aria-labelledby')) {
                        element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                    }
                    if (element.hasAttribute('title')) {
                        element.control.setAttribute('title', element.getAttribute('title'));
                    }

                    // esc resets the value (the same as the reset button) (see issue #142)
                    element.control.addEventListener('keydown', function (event) {
                        element.control.focus();

                        var intKeyCode = (event.keyCode || event.which);
                        if (intKeyCode === 27) {
                            element.internal.validDate = true;
                            GS.setInputSelection(element.control, 0, element.control.value.length);
                            insertText(elementValue);
                            GS.setInputSelection(element.control, 0, element.control.value.length);
                        }
                    });

                    if (element.hasAttribute('popup')) {
                        var arrowElem = document.createElement('div');
                        arrowElem.classList.add('dt-arrows');
                        arrowElem.setAttribute('gs-dynamic', '');
                        arrowElem.innerHTML = '<gs-button no-focus icononly icon="arrow-up" class="dt-arrow dt-arrow-up"></gs-button>' +
                            '<gs-button no-focus icononly icon="arrow-down" class="dt-arrow dt-arrow-down"></gs-button>' +
                            '<gs-button no-focus icononly icon="undo" class="dt-arrow dt-reset"></gs-button>';
                        var rect = element.getBoundingClientRect();
                        element.arrowElem = arrowElem;
                        arrowElem.style.top = (rect.height + rect.top) + 'px';
                        arrowElem.element = element;
                        document.body.appendChild(arrowElem);
                        arrowElem.style.left = parseInt(rect.width + rect.left - arrowElem.offsetWidth, 10) + 'px';
                        //console.log(arrowElem.offsetWidth, arrowElem.clientWidth);
                        // element.control = arrowElem;

                        var arrows = arrowElem;//= element.children[1];
                        arrows.addEventListener(evt.mousedown, function (event) {
                            event.stopPropagation();
                            event.preventDefault();
                        });
                        arrows.children[0].addEventListener(evt.mousedown, arrowMousedownFunction);
                        arrows.children[1].addEventListener(evt.mousedown, arrowMousedownFunction);
                        arrows.children[2].addEventListener(evt.mousedown, function (event) {
                            event.preventDefault();
                            element.control.focus();

                            element.internal.validDate = true;
                            GS.setInputSelection(element.control, 0, element.control.value.length);
                            insertText(elementValue);
                            GS.setInputSelection(element.control, 0, element.control.value.length);
                        });
                    }
                } else {
                    element.innerHTML =
                        '<input class="control" gs-dynamic type="' + (element.getAttribute('type') || 'text') + '" />';
                    element.control = element.children[0];
                    if (element.hasAttribute('id')) {
                        element.control.setAttribute('id', element.getAttribute('id') + '_control');
                    }
                    if (element.hasAttribute('aria-labelledby')) {
                        element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                    }
                    if (element.hasAttribute('title')) {
                        element.control.setAttribute('title', element.getAttribute('title'));
                    }
                }

                // bind event re-targeting functions
                element.control.removeEventListener('change', changeFunction);
                element.control.addEventListener('change', changeFunction);

                element.control.removeEventListener('blur', blurFunction);
                element.control.addEventListener('blur', blurFunction);

                element.removeEventListener(evt.mouseout, mouseoutFunction);
                element.addEventListener(evt.mouseout, mouseoutFunction);

                element.removeEventListener(evt.mouseout, mouseoverFunction);
                element.addEventListener(evt.mouseover, mouseoverFunction);
                // copy passthrough attributes to control
                i = 0;
                len = arrPassThroughAttributes.length;
                while (i < len) {
                    if (element.hasAttribute(arrPassThroughAttributes[i])) {
                        if (arrPassThroughAttributes[i] === 'disabled') {
                            element.control.setAttribute(
                                'readonly',
                                element.getAttribute(arrPassThroughAttributes[i]) || ''
                            );
                        } else {
                            element.control.setAttribute(
                                arrPassThroughAttributes[i],
                                element.getAttribute(arrPassThroughAttributes[i]) || ''
                            );
                        }
                    }
                    i += 1;
                }
                //console.log(elementValue);
                element.control.value = elementValue;
                GS.setInputSelection(element.control, 0, elementValue.length);
                element.value = elementValue;
                // if we saved a tabindex: apply the tabindex to the control
                if (element.savedTabIndex !== undefined && element.savedTabIndex !== null) {
                    element.control.setAttribute('tabindex', element.savedTabIndex);
                }
                //element.style.width = elementWidth - 7 + 'px';
                //console.log(element.style.width, elementWidth + 'px');
                element.syncView();
                element.control.focus();
                element.addEventListener('focus', focusFunction);

                if (!(element.hasAttribute('disabled') || element.hasAttribute('readonly'))) {
                    element.addEventListener('keydown', controlKeydownFunction);
                    element.addEventListener('keyup', controlKeyupFunction);
                    element.control.addEventListener('select', controlSelectFunction);
                    element.control.addEventListener('click', controlSelectFunction);
                    element.control.addEventListener(evt.mouseup, controlSelectFunction);
                }
            },

            syncView: function () {
                var element = this;
                if (element.control) {
                    element.control.value = element.getAttribute('value') || '';
                } else {
                    if (element.value) {
                        element.innerHTML = formatDateHTML(newDateInCurrentTimeZone(element.getAttribute('value')), getFormatString(element));
                    } else if (element.hasAttribute('placeholder')) {
                        element.innerHTML = '<span class="placeholder">' + element.getAttribute('placeholder') + '</span>';
                    }
                }
                element.initalized = true;
            },

            syncGetters: function () {
                if (this.control) {
                    this.setAttribute('value', this.control.value);
                }
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, addDataEvents, addAutocompleteProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function (event) {
    'use strict';

    addSnippet(
        '<gs-envelope>',
        '<gs-envelope>',
        'gs-envelope src="${1:test.tpeople}">\n' +
        '    <template for="hud"></template>\n' +
        '    <template for="table">\n' +
        '        <table>\n' +
        '            <tbody>\n' +
        '                <tr>\n' +
        '                    <th heading="#">' +
        '<gs-static column="row_number"></gs-static>' +
        '</th>\n' +
        '                    <td heading="">$0</td>\n' +
        '                </tr>\n' +
        '            </tbody>\n' +
        '        </table>\n' +
        '    </template>\n' +
        '    <template for="insert"></template>\n' +
        '</gs-envelope>'
    );

    /*
    TODO: there is no documentation
    addElement('gs-envelope', '');
    */

    window.designElementProperty_GSENVELOPE = function () {
        addDataAttributes('select,insert,update,delete,parent-child');
        addText('V', 'Reflow At', 'reflow-at');
        addCheck('V', 'Scroll To Bottom', 'scroll-to-bottom');
        addCheck('V', 'HUD Orderby', 'no-hudorderby');
        addCheck('V', 'HUD Limit', 'no-hudlimit');
        addCheck('V', 'HUD Refresh', 'no-hudrefresh');
        addCheck('V', 'HUD Delete', 'no-huddelete');
        addText('V', 'Expand&nbsp;To&nbsp;Content', 'expand-to-content');
        addText('D', 'Select Action', 'action-select');
        addText('D', 'Insert Action', 'action-insert');
        addText('D', 'Update Action', 'action-update');
        addText('D', 'Delete Action', 'action-delete');
        addDataEvents('select,insert,update,delete');
        addCheck('D', 'Disable Insert', 'no-insert');
        addCheck('D', 'Disable Update', 'no-update');
        addText('D', 'Record Template', 'template');
        addText('O', 'Column In QS', 'qs');
        addText('O', 'Refresh On QS Columns', 'refresh-on-querystring-values');
        addText('O', 'Refresh On QS Change', 'refresh-on-querystring-change');
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    // ####################################################################
    // ############################## LOADER ##############################
    // ####################################################################

    function addLoader(element, strText) {
        element.loaderContainer = GS.stringToElement('<div class="loader-container" style="top: ' + element.scrollContainerElement.scrollTop + 'px;"></div>');
        element.scrollContainerElement.appendChild(element.loaderContainer);

        GS.addLoader(element.loaderContainer, strText);
    }

    function removeLoader(element) {
        if (element.loaderContainer && element.loaderContainer.parentNode === element.scrollContainerElement) {
            element.scrollContainerElement.removeChild(element.loaderContainer);
        }
        GS.removeLoader(element.loaderContainer);
    }

    // ###################################################################
    // ########################## DRAG HANDLING ##########################
    // ###################################################################

    function selectHandler(element, dragOrigin, dragCurrentCell, dragMode) {
        var bolThead;
        var bolFirstTh;
        var arrRecords;
        var arrCells;
        var arrRecordsToAffect = [];
        var arrCellsToAffect = [];
        var arrNewSelection = [];
        var arrCellsToRemoveFromSelection = [];
        var i;
        var len;
        var intFrom;
        var intTo;

        arrRecords = xtag.query(element.scrollContainerElement, 'tr');
        arrCells = xtag.query(element.scrollContainerElement, 'td, th');

        if (arrRecords.length > 0) {
            bolThead = Boolean(element.theadElement);

            if ((bolThead && arrRecords.length > 1) || (!bolThead && arrRecords > 0)) {
                if (bolThead) {
                    bolFirstTh = arrRecords[1].children[0].nodeName === 'TH';
                } else {
                    bolFirstTh = arrRecords[0].children[0].nodeName === 'TH';
                }
            }

            // if origin & currentCell are both the top-left cell and the cell is a heading: select all cells
            if (
                bolThead &&
                bolFirstTh &&
                dragOrigin.parentNode.rowIndex === 0 &&
                dragCurrentCell.parentNode.rowIndex === 0 &&
                dragOrigin.cellIndex === 0 &&
                dragCurrentCell.cellIndex === 0
            ) {
                arrCellsToAffect = arrCells;

            // else if origin & currentCell are both first ths: select the records from origin to currentCell
            } else if (bolFirstTh && dragOrigin.cellIndex === 0 && dragCurrentCell.cellIndex === 0) {
                arrRecordsToAffect = arrRecords.slice(
                    Math.min(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex),
                    Math.max(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex) + 1
                );

                i = 0;
                len = arrRecordsToAffect.length;
                while (i < len) {
                    Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children));
                    i += 1;
                }

            // else if origin & currentCell are both headings: select the columns from origin to currentCell
            } else if (bolThead && dragOrigin.parentNode.rowIndex === 0 && dragCurrentCell.parentNode.rowIndex === 0) {
                intFrom = Math.min(dragOrigin.cellIndex, dragCurrentCell.cellIndex);
                intTo = Math.max(dragOrigin.cellIndex, dragCurrentCell.cellIndex) + 1;

                i = 0;
                len = arrRecords.length;
                while (i < len) {
                    Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecords[i].children).slice(intFrom, intTo));
                    i += 1;
                }

            //// else if origin & currentCell are the same cell: select the record
            //} else if (dragOrigin === dragCurrentCell) {
            //    arrRecordsToAffect = arrRecords.slice(dragOrigin.parentNode.rowIndex, dragOrigin.parentNode.rowIndex + 1);
            //
            //    for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
            //        Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children));
            //    }

            // else select cells from origin to currentCell
            } else {
                arrRecordsToAffect = arrRecords.slice(
                    Math.min(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex),
                    Math.max(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex) + 1
                );

                intFrom = Math.min(dragOrigin.cellIndex, dragCurrentCell.cellIndex);
                intTo = Math.max(dragOrigin.cellIndex, dragCurrentCell.cellIndex) + 1;

                i = 0;
                len = arrRecordsToAffect.length;
                while (i < len) {
                    Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children).slice(intFrom, intTo));
                    i += 1;
                }
            }

            if (dragOrigin !== dragCurrentCell) {
                element.scrollContainerElement.removeAttribute('allow-text-selection');
                element.copyFocusTargetElement.focus();
                GS.setInputSelection(element.copyFocusTargetElement, 0, 'firefox...'.length);
            } else {
                element.scrollContainerElement.setAttribute('allow-text-selection', '');
            }

            if (dragMode === 'select') {

                // add new cells to element.selectionSelectedCells
                i = 0;
                len = element.selectionSelectedCells.length;
                while (i < len) {
                    if (arrCellsToAffect.indexOf(element.selectionSelectedCells[i]) === -1) {
                        arrCellsToRemoveFromSelection.push(element.selectionSelectedCells[i]);
                    }
                    i += 1;
                }
                element.selectionSelectedCells = arrCellsToAffect;

                // add new cells to element.selectedCells
                arrNewSelection = element.selectedCells;
                i = 0;
                len = arrCellsToAffect.length;
                while (i < len) {
                    GS.listAdd(arrNewSelection, arrCellsToAffect[i]);
                    i += 1;
                }
                i = 0;
                len = arrCellsToRemoveFromSelection.length;
                while (i < len) {
                    arrNewSelection.splice(arrNewSelection.indexOf(arrCellsToRemoveFromSelection[i]), 1);
                    i += 1;
                }
                element.selectedCells = arrNewSelection;

                //element.selectionSelectedCells = arrCellsToAffect;
                //element.selectedCells = arrCellsToAffect;

            } else { // implied if: dragMode === 'deselect'
                // deselect cells from arrCellsToAffect
                arrNewSelection = element.selectedCells;

                i = 0;
                len = arrCellsToAffect.length;
                while (i < len) {
                    if (arrNewSelection.indexOf(arrCellsToAffect[i]) > -1) {
                        arrNewSelection.splice(arrNewSelection.indexOf(arrCellsToAffect[i]), 1);
                    }
                    i += 1;
                }
                element.selectedCells = arrNewSelection;
            }
        }
    }

    // #######################################################################
    // ############################ DATA HANDLING ############################
    // #######################################################################
    // the user needs to be able to set a custom websocket for this element,
    //      so this function will use an attribute to find out what socket to
    //      use (and it'll default to "GS.envSocket")
    function getSocket(element) {
        if (element.getAttribute('socket')) {
            return GS[element.getAttribute('socket')];
        }
        return GS.envSocket;
    }


    // get data and send it off to be templated
    function getData(element) {
        GS.triggerEvent(element, 'before_select');
        GS.triggerEvent(element, 'onbefore_select');
        if (element.hasAttribute('onbefore_select')) {
            new Function(element.getAttribute('onbefore_select')).apply(element);
        }

        element.refreshing = true;
        var strSrc = GS.templateWithQuerystring(element.getAttribute('src') || element.getAttribute('source') || '');
        var srcParts = strSrc[0] === '(' ? [strSrc, ''] : strSrc.split('.');
        var strSchema = srcParts[0];
        var strObject = srcParts[1];
        var strWhere = GS.templateWithQuerystring(element.getAttribute('where') || '');
        var strOrd = GS.templateWithQuerystring(element.getAttribute('ord') || '');
        var strLimit = GS.templateWithQuerystring(element.getAttribute('limit') || '');
        var strOffset = GS.templateWithQuerystring(element.getAttribute('offset') || '');
        var response_i = 0;
        var response_len = 0;
        var arrTotalRecords = [];
        var strWhereColumn;
        var i;
        var len;

        // if there is a column attribute on element: combine the where attribute with a where generated by value
        if ((element.getAttribute('column') || element.getAttribute('qs')) && element.value) {
            strWhereColumn = element.getAttribute('child-column') || element.getAttribute('column') || element.getAttribute('qs');

            if (isNaN(element.value)) {
                strWhere =  'CAST(' + strWhereColumn + ' AS ' + GS.database.type.text + ') = ' +
                            'CAST($WhereQUOTE$' + (element.value) + '$WhereQUOTE$ AS ' + GS.database.type.text + ')' +
                            (strWhere !== '' ? ' AND (' + strWhere + ')' : '');
            } else {
                strWhere = strWhereColumn + '=' + (element.value) + (strWhere !== '' ? ' AND (' + strWhere + ')' : '');
            }

        // else: just use the where attribute
        }

        // if the user has set an order by: use the user order bys
        if (element.user_order_bys && element.user_order_bys.columns.length > 0) {
            i = 0;
            len = element.user_order_bys.columns.length;
            strOrd = '';
            while (i < len) {
                strOrd += (strOrd !== '' ? ', ' : '') + element.user_order_bys.columns[i] + ' ' + element.user_order_bys.directions[i].toUpperCase();
                i += 1;
            }

        // else: use the order by attribute
        }

        // save the old scrolltop (so that we can scroll back to it)
        element.oldScrollTop = element.scrollContainerElement.scrollTop;

        addLoader(element, 'Loading...');

        GS.requestCachingSelect(getSocket(element), strSchema, strObject, '*'
                                 , strWhere, strOrd, strLimit, strOffset
                                 , function (data, error) {
            element.refreshing = false;
            var arrRecords;
            var arrCells;
            var envData;
            var i;
            var len;
            var cell_i;
            var cell_len;

            if (!error) {
                if (data.strMessage !== 'TRANSACTION COMPLETED') {
                    arrRecords = GS.trim(data.strMessage, '\n').split('\n');

                    i = 0;
                    len = arrRecords.length;
                    while (i < len) {
                        arrCells = arrRecords[i].split('\t');

                        cell_i = 0;
                        cell_len = arrCells.length;
                        while (cell_i < cell_len) {
                            arrCells[cell_i] = arrCells[cell_i] === '\\N' ? null : GS.decodeFromTabDelimited(arrCells[cell_i]);
                            cell_i += 1;
                        }

                        arrTotalRecords.push(arrCells);
                        i += 1;
                    }
                } else {
                    removeLoader(element);
                    element.arrColumnNames = data.arrColumnNames;

                    envData = {'arr_column': element.arrColumnNames, 'dat': arrTotalRecords};

                    handleData(element, envData);
                }
            } else {
                handleData(element, data, error);
                //GS.removeLoader(element);
            }
        }, true);
    }

    function handleData(element, data, error) {
        var strHeaderHTML, strFixedHeaderHTML, tableElement, theadElement, tbodyElement,
            strBodyHTML, tableTemplateElement, arrCells, i, len,
            bolHeaderTextFound = false, strCurrentHeadingText, bolInitalSuccess;

        if (!error) {
            bolInitalSuccess = !element.lastSuccessData;

            // remove old error class
            element.classList.remove('error');

            // save data
            element.lastSuccessData = data;

            // create HTMl for header
            tableTemplateElement = document.createElement('template');
            tableTemplateElement.innerHTML = element.tableTemplate;

            tableElement = xtag.query(tableTemplateElement.content, 'table')[0];
            theadElement = xtag.queryChildren(tableElement, 'thead')[0];
            tbodyElement = xtag.queryChildren(tableElement, 'tbody')[0];

            // if there is a limit button
            if (element.limitButtonElement) {
                element.limitButtonElement.textContent = data.dat.length + ' records';
                element.limitButtonElement.setAttribute('class', 'row_count_btn');
            }

            //console.log(tableTemplateElement, element.tableTemplate, theadElement, tbodyElement);

            if (!theadElement) {
                arrCells = tbodyElement.getElementsByTagName('tr')[0].children;

                i = 0;
                len = arrCells.length;
                strHeaderHTML = '';
                strFixedHeaderHTML = '';
                while (i < len) {
                    strCurrentHeadingText = encodeHTML(GS.templateWithQuerystring(arrCells[i].getAttribute('heading') || ''));

                    if (strCurrentHeadingText) {
                        bolHeaderTextFound = true;
                    }

                    strHeaderHTML += '<th gs-dynamic>' + strCurrentHeadingText + '</th>';
                    strFixedHeaderHTML += '<div class="fixed-header-cell" gs-dynamic>' + strCurrentHeadingText + '</div>';
                    i += 1;
                }

                if (bolHeaderTextFound) {
                    strHeaderHTML = '<thead gs-dynamic><tr gs-dynamic>' + strHeaderHTML + '</tr></thead>';

                } else {
                    strHeaderHTML = '';
                    strFixedHeaderHTML = '';
                }
            } else {
                strHeaderHTML = theadElement.outerHTML;
                arrCells = theadElement.getElementsByTagName('tr')[0].children;

                i = 0;
                len = arrCells.length;
                strFixedHeaderHTML = '';
                while (i < len) {
                    strFixedHeaderHTML += '<div class="fixed-header-cell" gs-dynamic>' + encodeHTML(arrCells[i].textContent || '') + '</div>';
                    i += 1;
                }
            }

            element.fixedHeaderContainerElement.innerHTML = strFixedHeaderHTML;

            // create HTMl for body using the templated data
            strBodyHTML = '<tbody gs-dynamic>' + dataTemplateRecords(element, data) + '</tbody>';



            // this following observer code was added so that firefox would adjust it's headers at the right time
            //      I belive that the problem firefox had was that comboboxes were changing their width after
            //      refreshFixedHeader was being called, so this observer will call it after the childlist of the
            //      scrollcontainer changes
            // if there is already an observer: disconnect it
            if (element.headerRefreshObserver) {
                element.headerRefreshObserver.disconnect();
                element.headerRefreshObserver = undefined;
            }

            // fixed header mutation observer
            element.headerRefreshObserver = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    //console.log('1***');
                    element.refreshFixedHeader();
                });
            });

            // pass in the target node, as well as the observer options
            element.headerRefreshObserver.observe(element.scrollContainerElement, {'childList': true});


            // set scroll container html
            element.scrollContainerElement.innerHTML = '<table gs-dynamic>' +
                                                        strHeaderHTML +
                                                        strBodyHTML +
                                                    '</table>';

            element.theadElement = xtag.query(element.scrollContainerElement, 'thead')[0];
            element.tbodyElement = xtag.query(element.scrollContainerElement, 'tbody')[0];

            element.refreshFixedHeader();

            // refresh height and reflow status
            element.refreshHeight();
            element.refreshReflow();

            // set scrolltop to the old scrolltop
            element.scrollContainerElement.scrollTop = element.oldScrollTop;

            if (element.hasAttribute('scroll-to-bottom')) {
                element.scrollContainerElement.scrollTop = element.scrollContainerElement.scrollHeight;
            }

            // this is triggered after the scrolling is set so that if someone wants to scroll
            // to a record after select they aren't going to encounter a problem
            GS.triggerEvent(element, 'after_select');
            GS.triggerEvent(element, 'onafter_select');
            if (element.hasAttribute('onafter_select')) {
                new Function(element.getAttribute('onafter_select')).apply(element);
            }

        } else {
            // add error class
            element.classList.add('error');

            // error dialog
            GS.ajaxErrorDialog(data, function () {
                getData(element);
            });
        }
    }


    function updateRecord(element, record, strColumn, newValue) {
        var srcParts = GS.templateWithQuerystring(element.getAttribute('src') || element.getAttribute('source') || '').split('.');
        var strSchema = srcParts[0];
        var strObject = srcParts[1];
        var strHashCols = '';
        var strHashData = '';
        var strPk = element.getAttribute('pk') || 'id';
        var strPKValue = GS.envGetCell(
            element.lastSuccessData,
            parseInt(record.getAttribute('data-rownum'), 10),
            strPk
        );
        var strUpdateData = (
            'pk\tset\thash\n' +
            strPk + '\t' + GS.encodeForTabDelimited(strColumn) + '\thash\n' +
            GS.encodeForTabDelimited(strPKValue) + '\t' + GS.encodeForTabDelimited(newValue) + '\t'
        );
        var i;
        var len;
        var arrTotalRecords = [];
        var callbackFunction;

        GS.triggerEvent(element, 'before_update');
        GS.triggerEvent(element, 'onbefore_update');
        if (element.hasAttribute('onbefore_update')) {
            new Function(element.getAttribute('onbefore_update')).apply(element);
        }

        i = 0;
        len = element.arrWhereColumns.length;
        while (i < len) {
            if (element.arrWhereColumns[i] != 'id') {
                if (strHashCols.length > 0) {
                    strHashCols += '\t';
                    strHashData += '\t';
                }
                strHashCols += GS.encodeForTabDelimited(element.arrWhereColumns[i]);

                strHashData += GS.encodeForTabDelimited(record.getAttribute('data-' + element.arrWhereColumns[i]));
            }

            i += 1;
        }

        strUpdateData += CryptoJS.MD5(strHashData);

        element.saveState = 'saving';
        if (element.saveTimeout) {
            clearTimeout(element.saveTimeout);
        }
        //console.log('wait five seconds');
        element.saveTimeout = setTimeout(function () {
            //console.log('element.saveState', element.saveState);
            if (element.saveState !== 'saved' && xtag.query(element, '.saving-warning-parent').length === 0) {
                element.saveState = 'error';
                var parentElement = document.createElement('center');
                parentElement.setAttribute('class', 'saving-warning-parent');
                
                var warningElement = document.createElement('div');
                warningElement.setAttribute('class', 'saving-warning');
    
                // warningElement.innerHTML = 'CHANGES ARE NOT SAVED<br />CLICK HERE TO TRY AGAIN';
                warningElement.innerHTML = 'YOUR CHANGES ARE NOT SAVED<br />WE HAVEN\'T HEARD BACK FROM THE SERVER<br />EITHER THE SAVING IS SLOW OR THERE\'S AN ERROR';
                
                parentElement.appendChild(warningElement);
                element.insertBefore(parentElement, element.children[0]);
                
                // element.appendChild(parentElement);
                /*
                warningElement.addEventListener('click', function () {
                    saveFile(element, strPath, changeStamp, strContent, callbackSuccess, callbackFail);
                });
                */
            }
        }, /*30*/ 5 * 1000);
        
        addLoader(element, 'Updating Record...');
        GS.requestUpdateFromSocket(getSocket(element), strSchema, strObject, '*', strHashCols, strUpdateData, function (data, error, transactionID) {
            if (error) {
                if (element.saveTimeout) {
                    clearTimeout(element.saveTimeout);
                }
                element.saveState = 'error';
                if (xtag.query(element, '.saving-warning-parent').length > 0) {
                    element.removeChild(xtag.query(element, '.saving-warning-parent')[0]);
                }
                
                removeLoader(element);
                GS.webSocketErrorDialog(data);
            }
        }, function (data, error, transactionID, commitFunction, rollbackFunction) {
            var arrRecords;
            var arrCells;
            var envData;
            var i;
            var len;
            var cell_i;
            var cell_len;

            if (!error) {
                if (data !== 'TRANSACTION COMPLETED') {
                    if (element.saveTimeout) {
                        clearTimeout(element.saveTimeout);
                    }
                    element.saveState = 'saved';
                    if (xtag.query(element, '.saving-warning-parent').length > 0) {
                        element.removeChild(xtag.query(element, '.saving-warning-parent')[0]);
                    }

                    arrRecords = GS.trim(data, '\n').split('\n');

                    i = 0;
                    len = arrRecords.length;
                    while (i < len) {
                        arrCells = arrRecords[i].split('\t');

                        cell_i = 0;
                        cell_len = arrCells.length;
                        while (cell_i < cell_len) {
                            arrCells[cell_i] = arrCells[cell_i] === '\\N' ? null : GS.decodeFromTabDelimited(arrCells[cell_i]);
                            cell_i += 1;
                        }

                        arrTotalRecords.push(arrCells);
                        i += 1;
                    }

                } else {
                    commitFunction();
                }

            } else {
                if (element.saveTimeout) {
                    clearTimeout(element.saveTimeout);
                }
                element.saveState = 'error';
                if (xtag.query(element, '.saving-warning-parent').length > 0) {
                    element.removeChild(xtag.query(element, '.saving-warning-parent')[0]);
                }
                
                removeLoader(element);
                rollbackFunction();
                GS.webSocketErrorDialog(data);
            }
        }, function (strAnswer, data, error) {
            var arrElements, i, len;

            if (!error) {
                if (strAnswer === 'COMMIT') {
                    if (element.saveTimeout) {
                        clearTimeout(element.saveTimeout);
                    }
                    element.saveState = 'saved';
                    if (xtag.query(element, '.saving-warning-parent').length > 0) {
                        element.removeChild(xtag.query(element, '.saving-warning-parent')[0]);
                    }
                    // console.log(arrTotalRecords);
                    callbackFunction({
                        detail: {
                            response: arrTotalRecords[0],
                            error: error
                        }
                    });
                }

            } else {
                if (element.saveTimeout) {
                    clearTimeout(element.saveTimeout);
                }
                element.saveState = 'error';
                if (xtag.query(element, '.saving-warning-parent').length > 0) {
                    element.removeChild(xtag.query(element, '.saving-warning-parent')[0]);
                }
                
                getData(element);
                GS.webSocketErrorDialog(data);
            }
        });

        callbackFunction = function (event) {
            var jsnData, i, len, idIndex, tbodyElement, recordIndex, focusElement = document.activeElement
              , focusElementTag, focusElementRecord, focusElementCell, focusElementRecordIndex, focusElementCellIndex
              , focusElementIndex, focusElementCell, elementWalkResult, arrElements, arrSelection, newRecord, jsnTextSelection
              , newRecordData;
            //console.log(event);

            removeLoader(element);

            if (focusElement.hasAttribute('gs-dynamic') && focusElement.classList.contains('control')) {
                focusElement = focusElement.parentNode;
            }
            focusElementCell = getCellFromTarget(focusElement);
          //console.log(focusElement, focusElementCell);

            if (focusElementCell) {
                focusElementTag = focusElement.nodeName.toLowerCase();
                focusElementRecord = GS.findParentTag(focusElementCell, 'tr'); // getParentRecord(focusElementCell);

                focusElementRecordIndex = focusElementRecord.rowIndex;
                focusElementCellIndex = focusElementCell.cellIndex;
                focusElementIndex = xtag.query(focusElementRecord, focusElement.nodeName.toLowerCase()).indexOf(focusElement);
              //console.log(focusElementRecordIndex, focusElementCellIndex, focusElementIndex);

                //console.log(focusElementRecord,
                //            xtag.query(focusElementRecord, '*'),
                //            xtag.query(focusElementRecord, '*').indexOf(focusElement),
                //            xtag.query(focusElementRecord, focusElement.nodeName.toLowerCase()).indexOf(focusElement));
            }

            // if no error: refresh just the updated record
            if (!event.detail.error) {
                GS.triggerEvent(element, 'after_update');
                newRecordData = JSON.parse(JSON.stringify(event.detail.response));

                if (newRecordData.length > 0) {
                    // refresh record in lastSuccessData
                    idIndex = element.lastSuccessData.arr_column.indexOf('id');

                    i = 0;
                    len = element.lastSuccessData.dat.length;
                    // console.log(element.lastSuccessData.dat, idIndex, newRecordData);
                    while (i < len) {
                        // console.log(i, element.lastSuccessData.dat[i][idIndex], record.getAttribute('data-id'));
                        // if (String(element.lastSuccessData.dat[i][idIndex]) === String(record.getAttribute('data-id'))) {
                        if (String(element.lastSuccessData.dat[i][idIndex]) === String(newRecordData[idIndex])) {
                            recordIndex = i;
                            element.lastSuccessData.dat[i] = JSON.parse(JSON.stringify(event.detail.response));

                            break;
                        }
                        i += 1;
                    }

                    // save text selection status
                    if (document.activeElement.nodeName === 'INPUT' || document.activeElement.nodeName === 'TEXTAREA') {
                        jsnTextSelection = GS.getInputSelection(document.activeElement);
                    }

                    // save selection status of the cells in "record"
                    arrElements = xtag.query(record, 'td, th');
                    arrSelection = [];

                    i = 0;
                    len = arrElements.length;
                    while (i < len) {
                        if (arrElements[i].hasAttribute('selected-secondary')) {
                            arrSelection.push('selected-secondary');
                        } else if (arrElements[i].hasAttribute('selected')) {
                            arrSelection.push('selected');
                        } else {
                            arrElements.push('');
                        }
                        i += 1;
                    }

                    // replace "record" with new templated record
                    tbodyElement = document.createElement('tbody');
                    tbodyElement.innerHTML = dataTemplateRecords(element, element.lastSuccessData, recordIndex, 1); // jsnData // dataTemplate
                    newRecord = xtag.queryChildren(tbodyElement, 'tr')[0];
                    record.parentNode.replaceChild(newRecord, record);

                    // use saved selection status to select the cells in the new record
                    arrElements = xtag.query(newRecord, 'td, th');

                    i = 0;
                    len = arrElements.length;
                    while (i < len) {
                        if (arrSelection[i]) {
                            arrElements[i].setAttribute(arrSelection[i], '');
                        }
                        i += 1;
                    }

                    // refocus
                    if (focusElementCell) {
                        elementWalkResult = xtag.query(element.scrollContainerElement, 'tr')[focusElementRecordIndex];
                      //console.log(elementWalkResult);

                        if (elementWalkResult) {
                            elementWalkResult = xtag.query(elementWalkResult, focusElementTag)[focusElementIndex];
                          //console.log(elementWalkResult, focusElementTag, focusElementIndex);

                            if (elementWalkResult) {
                              //console.log('test');
                                elementWalkResult.focus();
                            }

                            //elementWalkResult = xtag.queryChildren(elementWalkResult, 'th, td')[focusElementCellIndex];
                            //
                            //if (elementWalkResult) {
                            //    elementWalkResult = xtag.query(elementWalkResult, '*')[1];
                            //
                            //    if (elementWalkResult) {
                            //        elementWalkResult.focus();
                            //    }
                            //}
                        }
                    }

                    // use saved text selection status to select active element
                    if (jsnTextSelection) {
                        GS.setInputSelection(document.activeElement, jsnTextSelection.start, jsnTextSelection.end);
                    }
                } else {
                    element.selectedCells = [];
                    record.parentNode.removeChild(record);
                }

                element.refreshFixedHeader();
                element.refreshHeight();

                GS.triggerEvent(element, 'after_update');
                GS.triggerEvent(element, 'onafter_update');
                if (element.hasAttribute('onafter_update')) {
                    new Function(element.getAttribute('onafter_update')).apply(element);
                }

            // else: errorDialog
            } else {
                // create addin to error response
                event.detail.response.error_addin = '<b gs-dynamic>Your Unsaved Value:</b> "' + newValue + '"';

                GS.ajaxErrorDialog(event.detail.response, function () {
                    updateRecord(element, record, strColumn, newValue);
                }, function () {
                    // revert
                    idIndex = element.lastSuccessData.arr_column.indexOf('id');

                    i = 0;
                    len = element.lastSuccessData.dat.length;
                    while (i < len) {
                        if (String(element.lastSuccessData.dat[i][idIndex]) === String(record.getAttribute('data-id'))) {
                            recordIndex = i;
                            break;
                        }
                        i += 1;
                    }

                    tbodyElement = document.createElement('tbody');
                    tbodyElement.innerHTML = dataTemplateRecords(element, element.lastSuccessData, recordIndex, 1);
                    record.parentNode.replaceChild(xtag.queryChildren(tbodyElement, 'tr')[0], record);
                });
            }
        };
    }

    function deleteRecords(element, arrID, arrRecord) {
        var srcParts = GS.templateWithQuerystring(element.getAttribute('src') || element.getAttribute('source') || '').split('.');
        var strSchema = srcParts[0];
        var strObject = srcParts[1];
        var strHashCols = '';
        var strHashData = '';
        var strPk = element.getAttribute('pk') || 'id';
        var strDeleteData = (
            'pk\thash\n' +
            strPk + '\thash\n'
        );
        var i;
        var len;
        var j;
        var len2;
        var arrTotalRecords = [];
        var callbackFunction;

        j = 0;
        len2 = element.arrWhereColumns.length;
        while (j < len2) {
            if (element.arrWhereColumns[j] != 'id') {
                if (strHashCols.length > 0) {
                    strHashCols += '\t';
                }
                strHashCols += GS.encodeForTabDelimited(element.arrWhereColumns[j]);
            }
            j += 1;
        }

        i = 0;
        len = arrID.length;
        while (i < len) {
            j = 0;
            len2 = element.arrWhereColumns.length;
            while (j < len2) {
                if (element.arrWhereColumns[j] != 'id') {
                    if (strHashData.length > 0) {
                        strHashData += '\t';
                    }

                    strHashData += GS.encodeForTabDelimited(arrRecord[i].getAttribute('data-' + element.arrWhereColumns[j]));
                }// else {
                //    strDeleteData += GS.encodeForTabDelimited(arrRecord[i].getAttribute('data-id'));
                //}
                j += 1;
            }
            //console.log(strHashData);
            strDeleteData += (
                GS.envGetCell(
                    element.lastSuccessData,
                    parseInt(arrRecord[i].getAttribute('data-rownum'), 10),
                    strPk
                ) +
                '\t' + CryptoJS.MD5(strHashData) + '\n'
            );
            strHashData = '';
            i += 1;
        }

        addLoader(element, 'Creating Delete Transaction...');
        GS.requestDeleteFromSocket(
            getSocket(element),
            strSchema,
            strObject,
            strHashCols,
            strDeleteData,
            function (data, error, transactionID) {
                if (error) {
                    removeLoader(element);
                    GS.webSocketErrorDialog(data);
                }
            },
            function (data, error, transactionID, commitFunction, rollbackFunction) {
                var arrElements;
                var i;
                var len;
                var templateElement;
                if (!error) {
                    if (data === 'TRANSACTION COMPLETED') {
                        // We have already confimed with the user that we are going to delete
                        commitFunction();
                    }

                } else {
                    rollbackFunction();
                    GS.webSocketErrorDialog(data);
                }
            },
            function (strAnswer, data, error) {
                var i;
                var len;
                var idColIndex;
                var deleteIndex;
                removeLoader(element);

                if (!error) {
                    if (strAnswer === 'COMMIT') {
                        GS.triggerEvent(element, 'after_delete');
                        GS.triggerEvent(element, 'onafter_delete');
                        if (element.hasAttribute('onafter_delete')) {
                            new Function(element.getAttribute('onafter_delete')).apply(element);
                        }

                        i = 0;
                        len = arrRecord.length;
                        while (i < len) {
                            arrRecord[i].parentNode.removeChild(arrRecord[i]);
                            i += 1;
                        }

                        idColIndex = element.lastSuccessData.arr_column.indexOf('id');

                        if (element.hasAttribute('limit') || element.lastSuccessData.dat.length === arrID.length) {
                            element.refresh();

                        } else {
                            // remove the record data from our stored data and
                            //      stop looping when we have deleted all the ones we are supposed to
                            i = 0;
                            len = element.lastSuccessData.dat.length;
                            while (i < len) {
                                // (arrID should only have strings so we cast the current id to string)
                                deleteIndex = arrID.indexOf(String(element.lastSuccessData.dat[i][idColIndex]));

                                if (deleteIndex > -1) {
                                    element.lastSuccessData.dat.splice(i, 1);
                                    arrID.splice(deleteIndex, 1);
                                    len -= 1;
                                    i -= 1;
                                }

                                if (arrID.length === 0) {
                                    break;
                                }
                                i += 1;
                            }

                            handleData(element, element.lastSuccessData);
                        }
                    }

                } else {
                    getData(element);
                    GS.webSocketErrorDialog(data);
                }
            }
        );
    }

    function insertRecord(element, dialog, strInsertString) {
        var srcParts = GS.templateWithQuerystring(element.getAttribute('src') || element.getAttribute('source') || '').split('.');
        var strSchema = srcParts[0];
        var strObject = srcParts[1];
        var arrInsertKeys;
        var arrInsertValues;
        var strWSInsertColumns;
        var strWSInsertData;
        var i;
        var len;
        var strPk = element.getAttribute('pk') || 'id';
        var strSeq = element.getAttribute('seq') || '';

        // if there is a column attribute on this element: append child column (or column) and the value to the insert string
        if (element.getAttribute('column') || element.getAttribute('qs')) {
            strInsertString += (strInsertString ? '&' : '') + (element.getAttribute('child-column') || element.getAttribute('column') || element.getAttribute('qs')) + '=' + (element.value);
        }

        //console.log(strInsertString);

        arrInsertKeys = GS.qryGetKeys(strInsertString);
        arrInsertValues = GS.qryGetVals(strInsertString);

        i = 0;
        len = arrInsertKeys.length;
        strWSInsertColumns = '';
        while (i < len) {
            strWSInsertColumns += arrInsertKeys[i] + ((i + 1) === len ? '\n' : '\t');
            i += 1;
        }
        i = 0;
        len = arrInsertValues.length;
        strWSInsertData = '';
        while (i < len) {
            strWSInsertData += arrInsertValues[i] + ((i + 1) === len ? '\n' : '\t');
            i += 1;
        }

        addLoader(element, 'Inserting Record...');

        GS.requestInsertFromSocket(
            getSocket(element),
            strSchema,
            strObject,
            strWSInsertColumns,
            strPk,
            strSeq,
            strWSInsertColumns + strWSInsertData,
            function (data, error, transactionID) {
                if (error) {
                    removeLoader(element);
                    GS.webSocketErrorDialog(data);
                }
            },
            function (data, error, transactionID, commitFunction, rollbackFunction) {
                var arrElements;
                var i;
                var len;
                var templateElement;

                if (!error) {
                    if (data === 'TRANSACTION COMPLETED') {
                        commitFunction();
                    }
                } else {
                    removeLoader(element);
                    rollbackFunction();
                    GS.webSocketErrorDialog(data);
                }
            },
            function (action) {
                removeLoader(element);
                if (action === 'COMMIT') {
                    GS.triggerEvent(element, 'after_insert');
                    GS.triggerEvent(element, 'onafter_insert');
                    if (element.hasAttribute('onafter_insert')) {
                        new Function(element.getAttribute('onafter_insert')).apply(element);
                    }
                    GS.closeDialog(dialog, 'Ok');
                }
                getData(element, true);
            }
        );
    }


    // ##################################################################
    // ########################### UI REFRESH ###########################
    // ##################################################################

    function refreshHud(element) {
        var elementHudTopContainer;
        var elementHudBottomContainer;
        var divElement = document.createElement('div');
        var hudInsertButton;
        var hudRefreshButton;
        var hudDeleteButton;
        var hudOrderbyButton;
        var hudLimitButton;
        var intOffset;
        var intLimit;
        var jsnOrderByCopy;
        var i;
        var len;
        var customHudTemplate;
        var customHudElements;

        elementHudTopContainer = element.hudTopElement;
        elementHudBottomContainer = element.hudBottomElement;

        elementHudTopContainer.innerHTML = '';
        elementHudBottomContainer.innerHTML = '';

        // insert hud button
        if (element.insertTemplate && !element.hasAttribute('no-insert')) {
            divElement.innerHTML = '<gs-button inline icononly icon="plus" no-focus gs-dynamic>Insert</gs-button>';

            hudInsertButton = divElement.childNodes[0];

            elementHudTopContainer.appendChild(hudInsertButton);
        }

        // refresh hud button
        if (!element.hasAttribute('no-hudrefresh')) {
            divElement.innerHTML = '<gs-button inline icononly icon="refresh" no-focus gs-dynamic>Refresh</gs-button>';

            hudRefreshButton = divElement.childNodes[0];

            elementHudTopContainer.appendChild(hudRefreshButton);
        }

        // delete hud button
        if (!element.hasAttribute('no-huddelete')) {
            divElement.innerHTML = '<gs-button inline icononly icon="times" no-focus gs-dynamic>Delete</gs-button>';

            hudDeleteButton = divElement.childNodes[0];

            elementHudTopContainer.appendChild(hudDeleteButton);
        }

        // custom hud buttons (trim so that just whitespace doesn't count)
        if (element.hudTemplate && element.hudTemplate.trim()) {
            customHudTemplate = document.createElement('template');
            customHudTemplate.innerHTML = element.hudTemplate;

            elementHudTopContainer.appendChild(customHudTemplate.content.cloneNode(true));

            // V------ you can't use .children on a template.content
            //customHudElements = customHudTemplate.content.childNodes;
            //
            //for (i = 0, len = customHudElements.length; i < len; i += 1) {
            //    //customHudElements[i].setAttribute('inline', '');
            //    elementHudTopContainer.appendChild(customHudElements[0]);
            //}
            //elementHudTopContainer.innerHTML += element.hudTemplate; <-- this causes events to be lost in the hud-top container
        }

        // order by hud button
        if (!element.hasAttribute('no-hudorderby')) {
            divElement.innerHTML = '<gs-button inline icononly icon="sort-amount-asc" no-focus gs-dynamic>Order By</gs-button>';

            hudOrderbyButton = divElement.childNodes[0];

            elementHudBottomContainer.appendChild(hudOrderbyButton);
        }

        // limit hud button
        element.limitButtonElement = '';
        if (!element.hasAttribute('no-hudlimit')) {
            //console.log(element, element.lastSuccessData);
            divElement.innerHTML = '<span flex></span><gs-button inline no-focus>Limit</gs-button>';

            hudLimitButton = divElement.childNodes[1];

            element.limitButtonElement = hudLimitButton;

            elementHudBottomContainer.appendChild(divElement.childNodes[0]);
            elementHudBottomContainer.appendChild(divElement.childNodes[0]);
        }

        if (elementHudTopContainer.innerHTML === '') {
            elementHudTopContainer.style.display = 'none';
        } else {
            elementHudTopContainer.style.display = '';
        }

        if (elementHudBottomContainer.innerHTML === '') {
            elementHudBottomContainer.style.display = 'none';
        } else {
            elementHudBottomContainer.style.display = '';
        }


        // bind hud buttons
        if (hudInsertButton) {
            hudInsertButton.addEventListener('click', function (event) {
                var templateElement = document.createElement('template');

                templateElement.innerHTML = ml(function () {/*
                    <gs-page gs-dynamic>
                        <gs-header gs-dynamic><center gs-dynamic><h3 gs-dynamic>Insert</h3></center></gs-header>
                        <gs-body padded gs-dynamic>
                            <div id="insert-dialog-content-container" gs-dynamic>{{HTML}}</div>
                        </gs-body>
                        <gs-footer gs-dynamic>
                            <gs-grid gs-dynamic widths="1,1" class="width-2">
                                <gs-block gs-dynamic width="1">
                                    <gs-button dialogclose gs-dynamic>Cancel</gs-button>
                                </gs-block>
                                <gs-block gs-dynamic width="1">
                                    <gs-button class="dialog-envelope-insert" listen-for-return bg-primary gs-dynamic>Ok</gs-button>
                                </gs-block>
                            </gs-grid>
                        </gs-footer>
                    </gs-page>
                */}).replace('{{HTML}}', element.insertTemplate);

                GS.openDialog(templateElement, function () {
                    var dialog = this;

                    GS.triggerEvent(element, 'insert_dialog_open');

                    xtag.query(dialog, '.dialog-envelope-insert')[0].addEventListener('click', function () {
                        var insertContainer = document.getElementById('insert-dialog-content-container');
                        var controls;
                        var i;
                        var len;
                        var strInsertString;
                        var currentValue;

                        GS.triggerEvent(element, 'before_insert');
                        GS.triggerEvent(element, 'onbefore_insert');
                        if (element.hasAttribute('onbefore_insert')) {
                            new Function(element.getAttribute('onbefore_insert')).apply(element);
                        }

                        controls = xtag.query(insertContainer, '[column]');

                        i = 0;
                        len = controls.length;
                        strInsertString = '';
                        while (i < len) {
                            currentValue = controls.checked !== undefined ? controls.checked : controls[i].value;

                            if (currentValue === undefined || currentValue === null) {
                                currentValue = '';
                            }

                            currentValue = encodeURIComponent(currentValue);

                            if (currentValue !== undefined && currentValue !== null && currentValue !== '') {
                                strInsertString += (strInsertString === '' ? '' : '&') +
                                                    controls[i].getAttribute('column') + '=' + currentValue;
                            }
                            i += 1;
                        }

                        insertRecord(element, dialog, strInsertString);
                    });
                });
            });
        }

        if (hudRefreshButton) {
            element.hudRefreshButton = hudRefreshButton;
            hudRefreshButton.addEventListener('click', function (event) {
                getData(element, true);
            });
        }

        if (hudDeleteButton) {
            element.hudDeleteButton = hudDeleteButton;
            //console.log('binding click on', hudDeleteButton);
            hudDeleteButton.addEventListener('click', function (event) {
                var i, len, arrRecord = element.selectedRecords, arrID = [];

                // loop through the selected cells and create an array of ids
                i = 0;
                len = arrRecord.length;
                while (i < len) {
                    arrID.push(String(arrRecord[i].dataset.id));
                    i += 1;
                }

                if (arrID.length > 0) {
                    GS.triggerEvent(element, 'before_delete');
                    GS.triggerEvent(element, 'onbefore_delete');
                    if (element.hasAttribute('onbefore_delete')) {
                        new Function(element.getAttribute('onbefore_delete')).apply(element);
                    }
                    GS.msgbox(  'Are you sure...',
                                    '<br gs-dynamic />' +
                                    '<center gs-dynamic>' +
                                        'Are you sure you want to delete ' + (arrID.length > 1 ? 'these records' : 'this record') + '?' +
                                    '</center>' +
                                    '<br gs-dynamic />',
                                ['No', 'Yes'],
                                function (strAnswer) {
                                    if (strAnswer === 'Yes') {
                                        deleteRecords(element, arrID, arrRecord);
                                    }
                                });

                } else {
                    GS.msgbox('Nothing Selected.',
                              '<br gs-dynamic /><center gs-dynamic>Nothing is selected. Please select something to delete.</center><br />',
                              ['Ok']);
                }
            });
        }

        if (hudOrderbyButton) {
            element.hudOrderbyButton = hudOrderbyButton;
            hudOrderbyButton.addEventListener('click', function (event) {
                var templateElement = document.createElement('template');

                jsnOrderByCopy = JSON.parse(JSON.stringify(element.user_order_bys));

                // TESTING LINE!!! COMMENT OUT WHEN NOT IN USE!!!
                //jsnOrderByCopy = {'columns': ['billable', 'taxable', 'id', 'user_name'], 'directions': ['asc', 'desc', 'asc', 'asc']};
                // TESTING LINE!!! COMMENT OUT WHEN NOT IN USE!!!

                templateElement.setAttribute('data-mode', 'touch');
                templateElement.innerHTML = ml(function () {/*
                    <gs-page gs-dynamic>
                        <gs-header gs-dynamic>
                            <center gs-dynamic><h3 gs-dynamic>Sorted Columns</h3></center>
                            <gs-button id="order-by-dialog-add-column" gs-dynamic>Add A Column To Sort</gs-button>
                        </gs-header>
                        <gs-body padded gs-dynamic>
                            <div id="order-by-dialog-ghost-container" gs-dynamic></div>
                            <div id="order-by-dialog-used-columns" gs-dynamic></div>
                        </gs-body>
                        <gs-footer gs-dynamic>
                            <gs-grid>
                                <gs-block><gs-button gs-dynamic dialogclose>Cancel</gs-button></gs-block>
                                <gs-block><gs-button gs-dynamic dialogclose>Ok</gs-button></gs-block>
                            </gs-grid>
                        </gs-footer>
                    </gs-page>
                */});

                GS.openDialog(templateElement, function () {
                    document.getElementById('order-by-dialog-add-column').addEventListener('click', function (event) {
                        var dialog, dialogButtons, templateElement2 = document.createElement('template');

                        templateElement2.innerHTML = ml(function () {/*
                            <gs-page gs-dynamic>
                                <gs-header gs-dynamic>
                                    <center gs-dynamic><h3 gs-dynamic>Unsorted Columns</h3></center>
                                </gs-header>
                                <gs-body padded gs-dynamic>
                                    <div id="order-by-dialog-unused-columns" gs-dynamic></div>
                                </gs-body>
                                <gs-footer gs-dynamic>
                                    <gs-button dialogclose gs-dynamic>Cancel</gs-button>
                                </gs-footer>
                            </gs-page>
                        */});

                        dialog = GS.openDialog(templateElement2, function () {
                                    var unusedColumnsContainer = document.getElementById('order-by-dialog-unused-columns');
                                    var unusedColumnTapHandler;
                                    var columnElements;
                                    var i;
                                    var len;
                                    var strHTML;

                                    i = 0;
                                    len = element.lastSuccessData.arr_column.length;
                                    strHTML = '';
                                    while (i < len) {
                                        if (jsnOrderByCopy.columns.indexOf(element.lastSuccessData.arr_column[i]) === -1) {
                                            strHTML +=  '<div class="order_by_column" data-column="' + element.lastSuccessData.arr_column[i] + '" gs-dynamic>' +
                                                            '<gs-button mini style="padding: 0.25em;" dialogclose class="column_name" gs-dynamic>' + GS.strToTitle(element.lastSuccessData.arr_column[i]) + '</gs-button>' +
                                                        '</div>';
                                        }
                                        i += 1;
                                    }

                                    unusedColumnsContainer.innerHTML = strHTML;

                                    unusedColumnTapHandler = function (event) {
                                        if (event.target.classList.contains('column_name')) {
                                            jsnOrderByCopy.columns.push(event.target.parentNode.getAttribute('data-column'));
                                        } else {
                                            jsnOrderByCopy.columns.push(event.target.getAttribute('data-column'));
                                        }
                                        jsnOrderByCopy.directions.push('asc');

                                        // refresh the column list
                                        refreshOrderBys();
                                    };

                                    columnElements = unusedColumnsContainer.getElementsByClassName('order_by_column');

                                    i = 0;
                                    len = columnElements.length;
                                    while (i < len) {
                                        columnElements[i].addEventListener('click', unusedColumnTapHandler);
                                        i += 1;
                                    }
                                });

                        dialogButtons = dialog.getElementsByTagName('gs-button');
                    });

                    var refreshOrderBys = function () {
                        var usedColumnsElement = document.getElementById('order-by-dialog-used-columns'),
                            ghostContainerElement = document.getElementById('order-by-dialog-ghost-container'),
                            strHTML, i, len, sortButtons, sortMousedownHandler, deleteButtons,
                            deleteTapHandler, directionButtons, directionTapHandler;


                        i = 0;
                        len = jsnOrderByCopy.columns.length;
                        strHTML = '';
                        while (i < len) {
                            strHTML +=  '<div class="order_by_column" flex-horizontal data-column="' + jsnOrderByCopy.columns[i] + '" data-direction="' + jsnOrderByCopy.directions[i] + '" gs-dynamic>' +
                                            '<gs-button inline remove-all icononly icon="bars" class="sort" gs-dynamic></gs-button>' +
                                            '<div class="column_name" flex gs-dynamic>' + GS.strToTitle(jsnOrderByCopy.columns[i]) + '</div>' +
                                            '<gs-button inline remove-all icononly icon="times" class="delete" gs-dynamic></gs-button>' +
                                            '<gs-button inline remove-all icononly icon="sort-amount-' + jsnOrderByCopy.directions[i] + '" class="direction" gs-dynamic></gs-button>' +
                                        '</div>';
                            i += 1;
                        }

                        usedColumnsElement.innerHTML = strHTML;

                        // bind sort buttons
                        sortMousedownHandler = function () {
                            var columns = usedColumnsElement.getElementsByClassName('order_by_column');
                            var offsetsCache = [];
                            var i;
                            var len;
                            var currentElement = this.parentNode;
                            var currentlyMarkedElement;
                            var markerElement;
                            var bolLast = false;
                            var intToIndex;
                            var currentElementClone;
                            var intCloneoffset;
                            var intFromIndex;
                            var sortMousemoveHandler;
                            var sortMouseupHandler;
                            var strColumn = currentElement.getAttribute('data-column');
                            var strDirection = currentElement.getAttribute('data-direction');

                            markerElement = document.createElement('div');
                            markerElement.classList.add('drop_marker');
                            markerElement.setAttribute('gs-dynamic', '');

                            currentElementClone = currentElement.cloneNode(true);
                            ghostContainerElement.appendChild(currentElementClone);
                            intCloneoffset = GS.getElementOffset(ghostContainerElement).top + (currentElementClone.offsetHeight / 2);

                            i = 0;
                            len = columns.length;
                            while (i < len) {
                                offsetsCache.push({
                                    'element': columns[i],
                                    'top': GS.getElementOffset(columns[i]).top,
                                    'height': columns[i].offsetHeight//, 'iscurrentelement': columns[i] === currentElement
                                });

                                if (columns[i] === currentElement) {
                                    intFromIndex = i;
                                }

                                i += 1;
                            }

                            sortMousemoveHandler = function (event) {
                                var i;
                                var len;
                                var matchedElement;
                                var bolNewLast;
                                var intTop;

                                event.preventDefault();
                                event.stopPropagation();

                                if (event.which === 0 && !evt.touchDevice) {
                                    sortMouseupHandler();

                                } else {
                                    intTop = GS.mousePosition(event).top + usedColumnsElement.parentNode.scrollTop;

                                    currentElementClone.style.top = (intTop - intCloneoffset) + 'px';

                                    //console.log('mousemove', GS.mousePosition(event).top, usedColumnsElement.parentNode.scrollTop);

                                    if (offsetsCache[0].top > intTop) {
                                        matchedElement = offsetsCache[0].element;
                                        bolNewLast = false;

                                    } else {
                                        i = 0;
                                        len = offsetsCache.length;
                                        while (i < len) {
                                            if (offsetsCache[i + 1]) {
                                                if (offsetsCache[i].top <= intTop &&
                                                    offsetsCache[i].top + ((offsetsCache[i + 1].top - offsetsCache[i].top) / 2) > intTop) {

                                                    matchedElement = offsetsCache[i].element;
                                                    bolNewLast = false;
                                                    intToIndex = i;
                                                    break;

                                                } else if (offsetsCache[i].top <= intTop &&
                                                            offsetsCache[i].top + ((offsetsCache[i + 1].top - offsetsCache[i].top) / 2) <= intTop &&
                                                            offsetsCache[i + 1].top > intTop) {

                                                    matchedElement = offsetsCache[i + 1].element;
                                                    bolNewLast = false;
                                                    intToIndex = i + 1;
                                                    break;
                                                }
                                            } else {
                                                if (offsetsCache[i].top + (offsetsCache[i].height / 2) >= intTop) {
                                                    matchedElement = offsetsCache[i].element;
                                                    bolNewLast = false;
                                                    intToIndex = i;
                                                    break;

                                                } else if (offsetsCache[i].top + (offsetsCache[i].height / 2) <= intTop) {
                                                    matchedElement = offsetsCache[i].element;
                                                    bolNewLast = true;
                                                    intToIndex = i;
                                                    break;
                                                }
                                            }
                                            i += 1;
                                        }
                                    }

                                    if (matchedElement !== currentlyMarkedElement || bolNewLast !== bolLast) {
                                        if (bolNewLast === true) {
                                            if (markerElement) {
                                                markerElement.parentNode.removeChild(markerElement);
                                            }
                                            matchedElement.parentNode.appendChild(markerElement);

                                        } else {
                                            matchedElement.parentNode.insertBefore(markerElement, matchedElement);
                                        }

                                        currentlyMarkedElement = matchedElement;
                                        bolLast = bolNewLast;

                                        //console.log(currentlyMarkedElement, bolLast);
                                    }

                                    //console.log('mousemove', intTop);
                                }
                            };

                            document.body.addEventListener(evt.mousemove, sortMousemoveHandler);

                            sortMouseupHandler = function (event) {
                                intToIndex = (intToIndex > intFromIndex ? intToIndex - 1: intToIndex);

                                // if we have valid to and from indexes:
                                if (intFromIndex !== intToIndex && intToIndex !== undefined) {

                                    if (intFromIndex !== undefined && intFromIndex !== '') {
                                        jsnOrderByCopy.columns.splice(intFromIndex, 1);
                                        jsnOrderByCopy.directions.splice(intFromIndex, 1);
                                    }

                                    jsnOrderByCopy.columns.splice(intToIndex, 0, strColumn);
                                    jsnOrderByCopy.directions.splice(intToIndex, 0, strDirection);

                                    // refresh the column list
                                    refreshOrderBys();
                                } else {
                                    markerElement.parentNode.removeChild(markerElement);
                                }

                                //console.log(intFromIndex, intToIndex);
                                ghostContainerElement.innerHTML = '';
                                document.body.removeEventListener(evt.mousemove, sortMousemoveHandler);
                                document.body.removeEventListener(evt.mouseup, sortMouseupHandler);
                            };

                            document.body.addEventListener(evt.mouseup, sortMouseupHandler);

                            //console.log('sortMousedownHandler');
                        };
                        sortButtons = usedColumnsElement.getElementsByClassName('sort');

                        i = 0;
                        len = sortButtons.length;
                        while (i < len) {
                            sortButtons[i].addEventListener(evt.mousedown, sortMousedownHandler);
                            i += 1;
                        }
                        //console.log(usedColumnsElement.getElementsByClassName('sort'));

                        // bind delete buttons
                        deleteTapHandler = function () {
                            var indexToDelete = jsnOrderByCopy.columns.indexOf(this.parentNode.getAttribute('data-column'));

                            jsnOrderByCopy.columns.splice(indexToDelete, 1);
                            jsnOrderByCopy.directions.splice(indexToDelete, 1);

                            refreshOrderBys();
                            //console.log('deleteTapHandler');
                        };
                        deleteButtons = usedColumnsElement.getElementsByClassName('delete');

                        i = 0;
                        len = deleteButtons.length;
                        while (i < len) {
                            deleteButtons[i].addEventListener('click', deleteTapHandler);
                            i += 1;
                        }
                        //console.log(usedColumnsElement.getElementsByClassName('delete'));


                        // bind direction buttons
                        directionTapHandler = function () {
                            var indexToFlip = jsnOrderByCopy.columns.indexOf(this.parentNode.getAttribute('data-column'));

                            if (jsnOrderByCopy.directions[indexToFlip] === 'asc') {
                                jsnOrderByCopy.directions[indexToFlip] = 'desc';
                            } else {
                                jsnOrderByCopy.directions[indexToFlip] = 'asc';
                            }

                            refreshOrderBys();
                            //console.log('directionTapHandler');
                        };
                        directionButtons = usedColumnsElement.getElementsByClassName('direction');

                        i = 0;
                        len = directionButtons.length;
                        while (i < len) {
                            directionButtons[i].addEventListener('click', directionTapHandler);
                            i += 1;
                        }
                        //console.log(usedColumnsElement.getElementsByClassName('direction'));
                    }

                    refreshOrderBys();
                }, function (event, strAnswer) {
                    if (strAnswer === 'Ok') {
                        element.user_order_bys = JSON.parse(JSON.stringify(jsnOrderByCopy));
                        getData(element, true);
                    }
                });
            });
        }

        if (hudLimitButton) {
            element.hudLimitButton = hudLimitButton;
            hudLimitButton.addEventListener('click', function (event) {
                var intLimit, intOffset, bolShowAll, fromValue, toValue,
                    templateElement = document.createElement('template');

                if (element.getAttribute('limit') && element.getAttribute('offset')) {
                    intOffset = parseInt(element.getAttribute('offset'), 10);
                    intLimit = parseInt(element.getAttribute('limit'), 10);

                    fromValue = intOffset;
                    toValue = intOffset + intLimit;
                    bolShowAll = false;

                } else if (element.getAttribute('limit')) {
                    fromValue = '0';
                    toValue = element.getAttribute('limit');
                    bolShowAll = false;

                } else if (element.old_offset && element.old_limit) {
                    intOffset = parseInt(element.old_offset, 10);
                    intLimit = parseInt(element.old_limit, 10);

                    fromValue = intOffset;
                    toValue = intOffset + intLimit;
                    bolShowAll = true;

                } else if (element.old_limit) {
                    fromValue = '0';
                    toValue = element.old_limit;
                    bolShowAll = true;

                } else {
                    fromValue = '0';
                    toValue = '';
                    bolShowAll = true;
                }

                templateElement.setAttribute('id', 'template-envelope-limit');
                templateElement.innerHTML = ml(function () {/*
                    <gs-page gs-dynamic>
                        <gs-header><center><h3>Limit</h3></center></gs-header>
                        <gs-body padded>
                            <gs-optionbox id="limit-dialog-choice" value="{{OPTION}}">
                                <gs-option value="range">
                                    Show Range:
                                    <gs-grid gutter>
                                        <gs-block>
                                            <b>From:</b>
                                            <gs-text id="limit-dialog-from" value="{{FROM}}" {{DISABLE}}></gs-text>
                                        </gs-block>
                                        <gs-block>
                                            <b>To:</b>
                                            <gs-text id="limit-dialog-to" value="{{TO}}" {{DISABLE}}></gs-text>
                                        </gs-block>
                                    </gs-grid>
                                </gs-option>
                                <gs-option value="all">Show All</gs-option>
                            </gs-optionbox>
                        </gs-body>
                        <gs-footer>
                            <gs-grid>
                                <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
                                <gs-block><gs-button dialogclose listen-for-return bg-primary>Ok</gs-button></gs-block>
                            </gs-grid>
                        </gs-footer>
                    </gs-page>
                */}).replace('{{OPTION}}', (bolShowAll === true ? 'all' : 'range'))
                    .replace(/\{\{DISABLE\}\}/gim, (bolShowAll === true ? 'disabled' : ''))
                    .replace('{{FROM}}', fromValue)
                    .replace('{{TO}}', toValue);

                GS.openDialog(templateElement, function () {
                    var choiceElement, showAllElement, fromElement, toElement, intLimit, intOffset, bolShowAll, fromValue, toValue;

                    choiceElement = document.getElementById('limit-dialog-choice');
                    fromElement = document.getElementById('limit-dialog-from');
                    toElement = document.getElementById('limit-dialog-to');

                    choiceElement.addEventListener('change', function (event) {
                        if (this.value === 'all') {
                            fromElement.setAttribute('disabled', '');
                            toElement.setAttribute('disabled', '');
                            GS.closeDialog('template-envelope-limit', 'Ok');
                        } else {
                            fromElement.removeAttribute('disabled');
                            toElement.removeAttribute('disabled');
                        }
                    });

                }, function (event, strAnswer) {
                    var dialog = this, choiceElement, showAllElement, fromElement, toElement, intLimit, intOffset;

                    if (strAnswer === 'Ok') {
                        choiceElement = document.getElementById('limit-dialog-choice');
                        showAllElement = document.getElementById('limit-dialog-show-all');
                        fromElement = document.getElementById('limit-dialog-from');
                        toElement = document.getElementById('limit-dialog-to');

                        if (choiceElement.value === 'all') {
                            if (element.getAttribute('limit')) {
                                element.old_limit = element.getAttribute('limit');
                                element.removeAttribute('limit');
                            }
                            if (element.getAttribute('offset')) {
                                element.old_offset = element.getAttribute('offset');
                                element.removeAttribute('offset');
                            }

                        } else {
                            if (fromElement.value) {
                                element.setAttribute('offset', fromElement.value);
                            }
                            if (toElement.value) {
                                element.setAttribute('limit', parseInt(toElement.value, 10) - parseInt(fromElement.value, 10));
                            }
                        }

                        getData(element);
                    }
                });
            });
        }
    }


    // #################################################################
    // ########################### UTILITIES ###########################
    // #################################################################

    function handleClipboardData(event, strCopyString) {
        var clipboardData = event.clipboardData || window.clipboardData, strMime;

        if (!clipboardData) {
            return;
        }
        if (!clipboardData.setData) {
            return;
        }

        if (window.clipboardData && window.clipboardData.getData) { // IE
            strMime = 'Text';
        } else if (event.clipboardData && event.clipboardData.getData) {
            strMime = 'text/plain';
        }

        if (strCopyString) {
            return clipboardData.setData(strMime, strCopyString) !== false;
        } else {
            return clipboardData.getData(strMime);
        }
    }

    function dataTemplateRecords(element, data, intStartRecordNumber, intNumberOfRecords) {
        var tableTemplateElement = document.createElement('template'), jsnTemplate, strRet, strStart, strEnd;

        tableTemplateElement.innerHTML = element.tableTemplate;

        //strStart = '<table><tbody>';
        //strEnd = '</tbody></table>';
        //jsnTemplate = GS.templateHideSubTemplates(strStart + xtag.query(tableTemplateElement.content, 'tbody')[0].innerHTML + strEnd);
        jsnTemplate = GS.templateHideSubTemplates(xtag.query(tableTemplateElement.content, 'tbody')[0].innerHTML, true);

        //jsnTemplate.templateHTML = jsnTemplate.templateHTML.substring(strStart.length, jsnTemplate.templateHTML.length - strEnd.length);
        //console.log(jsnTemplate.templateHTML);

        strRet = GS.templateWithEnvelopeData(jsnTemplate.templateHTML, data, intStartRecordNumber, intStartRecordNumber + intNumberOfRecords);

        strRet = GS.templateShowSubTemplates(strRet, jsnTemplate);

        return strRet;
    }



    // ########################################################################################
    // ########################################################################################
    // ########################################################################################
    // ########################################################################################
    // ########################################################################################
    // ########################################################################################
    // ########################################################################################
    // ########################################################################################
    // ########################################################################################

    function getCellFromTarget(element) {
        var currentElement = element;

        while (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH' && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }

        if (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH') {
            return undefined;
        }

        return currentElement;
    }

    //function pushReplacePopHandler(element) {
    //    var i, len, arrPopKeys, bolRefresh = false, currentValue, strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //
    //    if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //
    //    if (element.hasAttribute('refresh-on-querystring-values')) {
    //        arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(',');
    //
    //        for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
    //            currentValue = GS.qryGetVal(strQueryString, arrPopKeys[i]);
    //
    //            if (element.popValues[arrPopKeys[i]] !== currentValue) {
    //                bolRefresh = true;
    //            }
    //
    //            element.popValues[arrPopKeys[i]] = currentValue;
    //        }
    //    } else if (element.hasAttribute('refresh-on-querystring-change')) {
    //        bolRefresh = true;
    //    }
    //
    //    if (bolRefresh) {
    //        element.refresh();
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var arrPopKeys;
        var currentValue;
        var bolRefresh;
        var strOperator;

        if (strQSCol) {
            if (strQSCol.indexOf('=') !== -1) {
                arrAttrParts = strQSCol.split(',');
                i = 0;
                len = arrAttrParts.length;
                while (i < len) {
                    strQSCol = arrAttrParts[i];

                    if (strQSCol.indexOf('!=') !== -1) {
                        strOperator = '!=';
                        arrQSParts = strQSCol.split('!=');
                    } else {
                        strOperator = '=';
                        arrQSParts = strQSCol.split('=');
                    }

                    strQSCol = arrQSParts[0];
                    strQSAttr = arrQSParts[1] || arrQSParts[0];

                    // if the key is not present or we've got the negator: go to the attribute's default or remove it
                    if (strOperator === '!=') {
                        // if the key is not present: add the attribute
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            element.setAttribute(strQSAttr, '');
                        // else: remove the attribute
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    } else {
                        // if the key is not present: go to the attribute's default or remove it
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                            } else {
                                element.removeAttribute(strQSAttr);
                            }
                        // else: set attribute to exact text from QS
                        } else {
                            element.setAttribute(strQSAttr, (
                                GS.qryGetVal(strQS, strQSCol) ||
                                element.internal.defaultAttributes[strQSAttr] ||
                                ''
                            ));
                        }
                    }
                    i += 1;
                }
            } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                strQSValue = GS.qryGetVal(strQS, strQSCol);

                if (element.internal.bolQSFirstRun !== true) {
                    if (strQSValue !== '' || !element.getAttribute('value')) {
                        element.setAttribute('value', strQSValue);
                    }
                } else {
                    element.value = strQSValue;
                }
            }
        }

        // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
        if (element.internal.bolQSFirstRun === true) {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                i = 0;
                len = arrPopKeys.length;
                while (i < len) {
                    currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);

                    if (element.popValues[arrPopKeys[i]] !== currentValue) {
                        bolRefresh = true;
                    }

                    element.popValues[arrPopKeys[i]] = currentValue;
                    i += 1;
                }
            } else if (element.hasAttribute('refresh-on-querystring-change')) {
                bolRefresh = true;
            }

            if (bolRefresh && element.hasAttribute('src')) {
              //console.log('pushReplacePopHandler: getData', element);
                getData(element);
            } else if (bolRefresh && !element.hasAttribute('src')) {
                console.warn('gs-combo Warning: element has "refresh-on-querystring-values" or "refresh-on-querystring-change", but no "src".', element);
            }
        } else {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                i = 0;
                len = arrPopKeys.length;
                while (i < len) {
                    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                    i += 1;
                }
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    //
    function elementInserted(element) {
        var hudTemplateElement, tableTemplateElement, tableTemplateElementCopy, insertTemplateElement,
            recordElement, divElement, oldRootElement, i, len, arrElement, arrColumnElement, arrTemplates, arrWhereColumns,
            strQueryString = GS.getQueryString(), currentElement, strQSValue;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                GS.addBeforeUnloadEvent(function () {
                    document.activeElement.blur();
                });

                // handle "qs" attribute
                if (element.getAttribute('qs') ||
                        element.getAttribute('refresh-on-querystring-values') ||
                        element.hasAttribute('refresh-on-querystring-change')) {
                    element.popValues = {};
                    //strQSValue = GS.qryGetVal(strQueryString, element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.setAttribute('value', strQSValue);
                    //}
                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                }

                // primary keys attribute and defaulting
                if (element.getAttribute('lock')) {
                    arrWhereColumns = element.getAttribute('lock').split(/\s*,\s*/gim);
                    if (arrWhereColumns.length === 0) {
                        arrWhereColumns = ['change_stamp'];
                    }
                } else {
                    arrWhereColumns = ['change_stamp'];
                }
                element.arrWhereColumns = arrWhereColumns;

                // set user order bys to default to empty
                element.user_order_bys = {
                    'columns': [],
                    'directions': []
                };

                // if there is an old root element: delete it
                oldRootElement = xtag.queryChildren(element, '.root');

                if (oldRootElement.length > 0) {
                    i = 0;
                    len = oldRootElement.length;
                    while (i < len) {
                        element.removeChild(oldRootElement[i]);
                        i += 1;
                    }
                }

                // selecting for template elements
                hudTemplateElement    = xtag.queryChildren(element, 'template[for="hud"]')[0];
                tableTemplateElement  = xtag.queryChildren(element, 'template[for="table"]' + (element.hasAttribute('template') ? '[id="' + element.getAttribute('template') + '"': ''))[0];
                if (!tableTemplateElement && element.hasAttribute('template')) {
                    console.warn('ENVELOPE WARNING: Hey! You used the name of a non-existant record template!');
                    tableTemplateElement  = xtag.queryChildren(element, 'template[for="table"]')[0];
                }
                insertTemplateElement = xtag.queryChildren(element, 'template[for="insert"]')[0];
                
                if (
                    hudTemplateElement &&
                    (
                        hudTemplateElement.innerHTML.indexOf('&gt;') > -1 ||
                        hudTemplateElement.innerHTML.indexOf('&lt;') > -1
                    )
                ) {
                    console.warn('GS-ENVELOPE WARNING: &gt; or &lt; detected in HUD template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                }
                if (
                    tableTemplateElement &&
                    (
                        tableTemplateElement.innerHTML.indexOf('&gt;') > -1 ||
                        tableTemplateElement.innerHTML.indexOf('&lt;') > -1
                    )
                ) {
                    console.warn('GS-ENVELOPE WARNING: &gt; or &lt; detected in table template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                }
                if (
                    insertTemplateElement &&
                    (
                        insertTemplateElement.innerHTML.indexOf('&gt;') > -1 ||
                        insertTemplateElement.innerHTML.indexOf('&lt;') > -1
                    )
                ) {
                    console.warn('GS-ENVELOPE WARNING: &gt; or &lt; detected in insert template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                }

                element.templates = {};
                xtag.queryChildren(element, 'template[for="table"]').forEach(function (cur, i) {
                    if (i === 0) {
                        element.templates['default'] = cur;
                    }
                    if (cur.hasAttribute('id')) {
                        element.templates[cur.getAttribute('id')] = cur;
                    }
                });

                // checking/saving template elements
                if (hudTemplateElement) {
                    element.hudTemplate = hudTemplateElement.innerHTML;
                }

                if (tableTemplateElement) {
                    tableTemplateElementCopy = document.createElement('template');
                    tableTemplateElementCopy.innerHTML = tableTemplateElement.innerHTML;

                    recordElement = xtag.query(xtag.query(tableTemplateElementCopy.content, 'tbody')[0], 'tr')[0];

                    if (recordElement) {
                        recordElement.setAttribute('data-rownum', '{{! i }}');
                        // add a data- attribute for all where columns (most of the time: id and change_stamp)
                        i = 0;
                        len = element.arrWhereColumns.length;
                        while (i < len) {
                            recordElement.setAttribute('data-' + element.arrWhereColumns[i], '{{! row.' + element.arrWhereColumns[i] + ' }}');
                            i += 1;
                        }

                        // add a doT.js coded "value" attribute to any element with a "column" attribute but no "value" attribute
                        element.tableTemplate = GS.templateColumnToValue(tableTemplateElementCopy.innerHTML);
                    }
                } else {
                    throw 'Envelope error: table template is required.';
                }
                if (insertTemplateElement) {
                    element.insertTemplate = insertTemplateElement.innerHTML;
                }

                // clear element content
                element.innerHTML = '';

                // creating/setting root
                divElement = document.createElement('div');
                divElement.classList.add('root');
                divElement.setAttribute('flex-fill', '');
                divElement.setAttribute('flex-vertical', '');
                divElement.setAttribute('gs-dynamic', '');

                element.appendChild(divElement);
                element.root = divElement;

                // filling root with containers
                element.root.innerHTML = '<div class="hud-container-top" gs-dynamic></div>' +
                                         '<div class="fixed-header-container" gs-dynamic></div>' +
                                         '<div class="scroll-container" flex gs-dynamic></div>' +
                                         '<div class="hud-container-bottom" flex-horizontal gs-dynamic></div>' +
                                         '<input title="Hidden control" class="gs-envelope-copy-focus-target" value="Firefox compatibility input" gs-dynamic />';

                element.hudTopElement =                 xtag.queryChildren(element.root, '.hud-container-top')[0];
                element.fixedHeaderContainerElement =   xtag.queryChildren(element.root, '.fixed-header-container')[0];
                element.scrollContainerElement =        xtag.queryChildren(element.root, '.scroll-container')[0];
                element.hudBottomElement =              xtag.queryChildren(element.root, '.hud-container-bottom')[0];
                element.copyFocusTargetElement =        xtag.queryChildren(element.root, '.gs-envelope-copy-focus-target')[0];

                element.scrollContainerElement.setAttribute('allow-text-selection', '');

                ////REFPOINT
                //element.addEventListener('focus', function (event) {
                //    //console.log(document.activeElement, element, event.target, element.copyFocusTargetElement);
                //    if (document.activeElement === element) { // event.target
                //        element.copyFocusTargetElement.focus();
                //        GS.setInputSelection(element.copyFocusTargetElement, 0, 'firefox...'.length);
                //    }
                //});

                // binding events
                element.scrollContainerElement.addEventListener('change', function (event) {
                    var newValue, parentTr;

                    if (event.target.getAttribute('column')) {
                        if (event.target.value !== null) {
                            // changed on 2022-06-11 by Nunzio
                            // this is the behaviour of Microsoft Access, and Cross expected it
                            newValue = event.target.value === '' ? '\\N' : event.target.value;
                            // newValue = event.target.value;
                        } else {
                            newValue = event.target.checked;
                        }

                        parentTr = GS.findParentTag(event.target, 'tr');

                        // if the control is a direct child of this envelope (fixes sub envelope update)
                        if (
                            parentTr.parentNode.parentNode.parentNode === element.scrollContainerElement &&
                            !element.hasAttribute('no-update')
                        ) {
                            updateRecord(element, parentTr, event.target.getAttribute('column'), newValue);
                        }
                    }
                });
                
                // if td is clicked, and there is only one child, focus it
                element.addEventListener('click', function (event) {
                    if (event.target.tagName.toUpperCase() === 'TD' && event.target.children.length === 1) {
                        event.target.children[0].focus();
                    }
                });

                // META-SHIFT-CLICK
                if (!evt.touchDevice) {
                    element.addEventListener('click', function (event) {
                        var templateElement;

                        if (event.metaKey && event.shiftKey) {
                            templateElement = document.createElement('template');


                            var strOrderBy = '', strRelWhere = '', strElemWhere, strWhereColumn, strUserOrderBy = '', strLimit, strOffset,
                                strSource = GS.templateWithQuerystring((element.getAttribute('src') || '')),
                                strCols = GS.templateWithQuerystring(element.getAttribute('cols') || ''), strElemOrderBy;

                            // if there is a column attribute on element element: combine the where attribute with a where generated by value
                            if ((element.getAttribute('column') || element.getAttribute('qs')) && element.value) {
                                strWhereColumn = element.getAttribute('child-column') || element.getAttribute('column') || element.getAttribute('qs');

                                if (isNaN(element.value)) {
                                    strRelWhere =
                                        'CAST(' + strWhereColumn + ' AS ' + GS.database.type.text + ') = ' +
                                        'CAST($WhereQUOTE$' + (element.value) + '$WhereQUOTE$ AS ' + GS.database.type.text + ')';
                                } else {
                                    strRelWhere = strWhereColumn + '=' + (element.value);
                                }
                            }

                            strElemWhere = GS.templateWithQuerystring((element.getAttribute('where') || ''));
                            strLimit = GS.templateWithQuerystring((element.getAttribute('limit') || ''));
                            strOffset = GS.templateWithQuerystring((element.getAttribute('offset') || ''));

                            // if the user has set an order by: use the user order bys
                            if (element.user_order_bys && element.user_order_bys.columns.length > 0) {
                                i = 0;
                                len = element.user_order_bys.columns.length;
                                strUserOrderBy = '';
                                while (i < len) {
                                    strUserOrderBy += (strUserOrderBy !== '' ? ', ' : '') + element.user_order_bys.columns[i] + ' ' + element.user_order_bys.directions[i].toUpperCase();
                                    i += 1;
                                }
                            }

                            strElemOrderBy = GS.templateWithQuerystring((element.getAttribute('ord') || ''));


                            templateElement.innerHTML = ml(function () {/*
                                <gs-page>
                                    <gs-header><h3>GS-Envelope Details</h3></gs-header>
                                    <gs-body padded>
                                        <b>Source: </b>{{SOURCE}}<br />
                                        <b>Columns: </b>{{COLS}}<br />
                                        <b>Element Where: </b>{{ELEMWHERE}}<br />
                                        <b>Relationship Where: </b>{{RELWHERE}}<br />
                                        <b>Limit: </b>{{LIMIT}}<br />
                                        <b>Offset: </b>{{OFFSET}}<br />
                                        <b>Element Order By: </b>{{ELEMORD}}<br />
                                        <b>User Order By: </b>{{USERORD}}
                                    </gs-body>
                                    <gs-footer>
                                        <gs-button dialogclose>Done</gs-button>
                                    </gs-footer>
                                </gs-page>
                            */}).replace(/\{\{SOURCE\}\}/gi, strSource)
                                .replace(/\{\{COLS\}\}/gi, strCols)
                                .replace(/\{\{ELEMWHERE\}\}/gi, strElemWhere)
                                .replace(/\{\{RELWHERE\}\}/gi, strRelWhere)
                                .replace(/\{\{LIMIT\}\}/gi, strLimit)
                                .replace(/\{\{OFFSET\}\}/gi, strOffset)
                                .replace(/\{\{ELEMORD\}\}/gi, strElemOrderBy)
                                .replace(/\{\{USERORD\}\}/gi, strUserOrderBy);

                            GS.openDialog(templateElement);
                        }
                    });
                }

                // if we are not on a touch device: cell by cell selection
                if (!evt.touchDevice) {
                    // mousedown (on selected and unselected) + drag
                    //      clear previous selection(s)
                    //      select cells from origin cell to current cell
                    //
                    // shift + mousedown (on selected and unselected) + drag
                    //      alter previous selection
                    //      select cells from previous origin cell to current cell
                    //
                    // command + mousedown (on unselected) + drag
                    //      maintain previous selection(s)
                    //      select cells from origin cell to current cell
                    //
                    // command + mousedown (on selected) + drag
                    //      maintain previous selection(s)
                    //      deselect cells from origin cell to current cell
                    //
                    // collision handling
                    //      when colliding with previous selections: dont treat them different
                    //
                    // copy handling
                    //      selection ("X" marks selected cells (imagine all cells contain the letter "a")):
                    //          1  2  3  4  5
                    //          -------------
                    //          a  a  a  a  a
                    //          a  X  X  a  a
                    //          a  a  X  X  a
                    //          a  a  a  a  a
                    //
                    //      yields ("'" marks an empty cell):
                    //          2  3  4
                    //          --------
                    //          a  a  '
                    //          '  a  a

                    element.addEventListener(evt.mousedown, function (event) {
                        var target = event.target, cellFromTarget = getCellFromTarget(target), closestCell, arrSelectedCells, i, len;

                        if (GS.findParentTag(event.target, 'table') || target.classList.contains('fixed-header-cell')) {
                            if (cellFromTarget) {
                                closestCell = cellFromTarget;
                            } else if (target.classList.contains('fixed-header-cell')) {
                                closestCell = element.theadElement.children[0].children[xtag.toArray(target.parentNode.children).indexOf(target)];
                            }

                            if (closestCell) {
                                element.dragAllowed = true;
                                element.dragCurrentCell = closestCell;
                                element.selectionSelectedCells = [];

                                // if shift is down and there is a previous origin: use previous origin for current origin
                                if (event.shiftKey && element.selectionPreviousOrigin) {

                                    // if there are previously selected cells: deselect the previous selected cells
                                    if (element.selectionPreviousSelectedCells) {
                                        arrSelectedCells = element.selectedCells;

                                        i = 0;
                                        len = element.selectionPreviousSelectedCells.length;
                                        while (i < len) {
                                            arrSelectedCells.splice(arrSelectedCells.indexOf(element.selectionPreviousSelectedCells[i]), 1);
                                            i += 1;
                                        }

                                        element.selectedCells = arrSelectedCells;
                                    }

                                    element.dragOrigin = element.selectionPreviousOrigin;
                                    element.dragMode = 'select';

                                // else if ctrl or cmd is down and the target cell is not selected: select cells from target cell to current cell
                                } else if (!event.shiftKey && (event.metaKey || event.ctrlKey) && !closestCell.hasAttribute('selected')) {
                                    element.dragOrigin = closestCell;
                                    element.dragMode = 'select';

                                // else if ctrl or cmd is down and the target cell is selected: deselect cells from target cell to current cell
                                } else if (!event.shiftKey && (event.metaKey || event.ctrlKey) && closestCell.hasAttribute('selected')) {
                                    element.dragOrigin = closestCell;
                                    element.dragMode = 'deselect';

                                // else: deselect all cells and start new selection
                                } else {
                                    element.selectedCells = [];
                                    element.dragOrigin = closestCell;
                                    element.dragMode = 'select';
                                }

                                selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                            }
                        }
                    });
                    element.addEventListener(evt.mousemove, function (event) {
                        var target, closestCell, cellFromTarget;

                        // if mouse is down
                        if (event.which !== 0) {
                            target = event.target;
                            cellFromTarget = getCellFromTarget(target);

                            if (cellFromTarget) {
                                closestCell = cellFromTarget;
                            } else if (target.classList.contains('fixed-header-cell')) {
                                closestCell =
                                    element.theadElement.children[0].children[xtag.toArray(target.parentNode.children).indexOf(target)];
                            }

                            // if selection is allowed at this point and closestCell is different from element.dragCurrentCell
                            if (closestCell && element.dragAllowed && element.dragCurrentCell !== closestCell) {
                                element.dragCurrentCell = getCellFromTarget(closestCell);
                                selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                            }
                        } else {
                            element.dragAllowed = false;
                            element.selectionPreviousOrigin = element.dragOrigin;
                            element.selectionPreviousSelectedCells = element.selectionSelectedCells;
                        }
                    });
                    element.addEventListener(evt.mouseup, function (event) {
                        element.dragAllowed = false;

                        if (element.dragMode === 'select') {
                            element.selectionPreviousOrigin = element.dragOrigin;
                            element.selectionPreviousSelectedCells = element.selectionSelectedCells;
                        }
                    });

                // else we are on a touch device: record selection
                } else {
                    element.root.addEventListener(evt.mousedown, function (event) {
                        if (event.target.nodeName === 'TD' || event.target.nodeName === 'TH' || getCellFromTarget(event.target)) {
                            element.selectedCells = [];

                            // if there is a parent record to the target: select all of the cells in the record
                            if (GS.findParentTag(event.target, 'tr')) {
                                element.selectedCells = GS.findParentTag(event.target, 'tr').children;
                            }
                        }
                    });
                }

                window.addEventListener('resize', function () {
                    element.refreshFixedHeader();
                    element.refreshHeight();
                    element.refreshReflow();
                });
                window.addEventListener('orientationchange', function () {
                    element.refreshFixedHeader();
                    element.refreshHeight();
                    element.refreshReflow();
                });
                element.addEventListener('size-changed', function (event) {
                    element.refreshFixedHeader();
                    element.refreshHeight();
                    //element.refreshReflow();
                });

                // key navigation
                element.addEventListener('keydown', function (event) {
                    var target = event.target, intKeyCode = event.which || event.keyCode, jsnSelection, bolCursorElement, i, len,
                        focusElement, tbodyElement, recordElement, cellElement, cellElements, tempElement;

                    if (target !== element) {
                        bolCursorElement = target.nodeName === 'INPUT' || target.nodeName === 'TEXTAREA';

                        if (bolCursorElement) {
                            jsnSelection = GS.getInputSelection(target);
                        } else {
                            jsnSelection = {};
                        }

                        // up arrow
                        if (intKeyCode === 38) {
                            //console.log('if there is a record before this one: focus the same column in the previous record');

                            cellElement = getCellFromTarget(target);
                            recordElement = cellElement.parentNode;
                            tbodyElement = recordElement.parentNode;

                            if (recordElement.rowIndex > 1) { // recordIndex > 0
                                recordElement = tbodyElement.children[recordElement.rowIndex - 2];

                                focusElement = xtag.query(recordElement.children[cellElement.cellIndex], '[column]')[0];
                            }

                        // down arrow
                        } else if (intKeyCode === 40) {
                            //console.log('if there is another record after this one: focus the same column in the next record');

                            cellElement = getCellFromTarget(target);
                            recordElement = cellElement.parentNode;
                            tbodyElement = recordElement.parentNode;

                            if (recordElement.rowIndex < tbodyElement.children.length) {
                                recordElement = tbodyElement.children[recordElement.rowIndex];

                                //focusElement = recordElement.children[cellElement.cellIndex].children[0];
                                focusElement = xtag.query(recordElement.children[cellElement.cellIndex], '[column]')[0];
                            }

                        // if left or right arrow
                        } else if (intKeyCode === 37 || intKeyCode === 39) {
                            // left arrow and (at the beginning of the target OR target has no selected)
                            if (intKeyCode === 37 && (bolCursorElement === false || jsnSelection.start === 0)) {
                                //console.log('previous control if possible');

                                cellElement = getCellFromTarget(target);
                                recordElement = cellElement.parentNode;
                                tbodyElement = recordElement.parentNode;

                                cellElements = xtag.query(tbodyElement, 'tr > td, tr > th');

                                // loop through previous cells looking for something focusable
                                i = cellElements.indexOf(cellElement) - 1;
                                while (i > -1) {
                                    //console.log(i);

                                    tempElement = xtag.query(cellElements[i], '[column]')[0];

                                    if (tempElement && GS.isElementFocusable(tempElement)) { // tempElement.control
                                        focusElement = tempElement; // tempElement.control

                                        break;
                                    }
                                    i -= 1;
                                }

                            // right arrow and (at the end of the target OR target has no selected)
                            } else if (intKeyCode === 39 && (bolCursorElement === false || jsnSelection.end === target.value.length)) {
                                cellElement = getCellFromTarget(target);
                                recordElement = cellElement.parentNode;
                                tbodyElement = recordElement.parentNode;

                                cellElements = xtag.query(tbodyElement, 'tr > td, tr > th');

                                // loop through previous cells looking for something focusable
                                i = cellElements.indexOf(cellElement) + 1;
                                len = cellElements.length;
                                while (i < len) { // - 1
                                    tempElement = xtag.query(cellElements[i], '[column]')[0];

                                    if (tempElement && GS.isElementFocusable(tempElement)) { // tempElement.control
                                        focusElement = tempElement; // tempElement.control
                                        break;
                                    }
                                    i += 1;
                                }
                            }
                        }

                        if (focusElement && GS.isElementFocusable(focusElement)) {
                            event.preventDefault();

                            focusElement.focus();

                            if (document.activeElement.nodeName === 'INPUT' || document.activeElement.nodeName === 'TEXTAREA') {
                                GS.setInputSelection(document.activeElement, 0, document.activeElement.value.length);
                            }

                            element.selectedRecords = GS.findParentTag(focusElement, 'TR');
                        }
                    }
                });

                // copy event
                element.tabIndex = 0;
                document.body.addEventListener('copy', function (event) {//console.log('test');
                    var elementClosestEnvelope = GS.findParentTag(document.activeElement, 'gs-envelope'), strCopyString,
                        i, len, cell_i, cell_len, arrSelected, intFromRecord = 9999999, intFromCell = 9999999, intToRecord = 0, intToCell = 0,
                        strCellText, arrRecords, arrCells, strRecordString;

                    if (elementClosestEnvelope === element &&
                        (
                            document.activeElement.classList.contains('gs-envelope-copy-focus-target') ||
                            document.activeElement.selectionStart === document.activeElement.selectionEnd
                        )) {
                        arrSelected = element.selectedCells;

                        // loop through the selected cells and create a tsv string using the text of the cell
                        if (arrSelected.length > 0) {
                            i = 0;
                            len = arrSelected.length;
                            while (i < len) {
                                if (arrSelected[i].parentNode.rowIndex < intFromRecord) {
                                    intFromRecord = arrSelected[i].parentNode.rowIndex;
                                }
                                if (arrSelected[i].cellIndex < intFromCell) {
                                    intFromCell = arrSelected[i].cellIndex;
                                }
                                if (arrSelected[i].parentNode.rowIndex + 1 > intToRecord) {
                                    intToRecord = arrSelected[i].parentNode.rowIndex + 1;
                                }
                                if (arrSelected[i].cellIndex + 1 > intToCell) {
                                    intToCell = arrSelected[i].cellIndex + 1;
                                }
                                i += 1;
                            }

                            arrRecords = xtag.query(element.scrollContainerElement, 'tr');
                            strCopyString = '';

                            i = intFromRecord;
                            len = intToRecord;
                            while (i < len) {
                                arrCells = arrRecords[i].children;

                                cell_i = intFromCell;
                                cell_len = intToCell;
                                strRecordString = '';
                                while (cell_i < cell_len) {
                                    if (arrCells[cell_i].hasAttribute('selected')) {
                                        if (arrCells[cell_i].lastElementChild) {
                                            strCellText = arrCells[cell_i].lastElementChild.textValue ||
                                                          arrCells[cell_i].lastElementChild.value ||
                                                          (arrCells[cell_i].lastElementChild.checked || '').toString();
                                        } else {
                                            strCellText = arrCells[cell_i].textContent.trim();
                                        }
                                    } else {
                                        strCellText = '';
                                    }

                                    strRecordString += (cell_i !== intFromCell ? '\t' : '') + (strCellText || '');
                                    cell_i += 1;
                                }
                                if (strRecordString.trim()) {
                                    strCopyString += strRecordString;
                                }
                                if (i + 1 !== len && strRecordString.trim()) {
                                    strCopyString += '\n';
                                }
                                i += 1;
                            }
                        }

                        if (strCopyString) {
                            if (handleClipboardData(event, strCopyString)) {
                                event.preventDefault(event);
                            }
                        }
                    }
                });

                // getData
                refreshHud(element);
                getData(element);
            }
        }
    }

    xtag.register('gs-envelope', {
        lifecycle: {
            created: function () {
                //console.log(this.outerHTML);
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (strAttrName === 'template') {
                    var tableTemplateElement, tableTemplateElementCopy, recordElement, element = this, i, len;
                    tableTemplateElement  = element.templates[element.getAttribute('template') || 'default'];
                    //console.log(tableTemplateElement);
                    if (!tableTemplateElement && element.hasAttribute('template')) {
                        console.warn('ENVELOPE WARNING: Hey! You used the name of a non-existant record template!');
                        tableTemplateElement = element.templates['default'];
                    }
                    //console.log(tableTemplateElement);

                    if (tableTemplateElement) {
                        //console.log(tableTemplateElement);
                        tableTemplateElementCopy = document.createElement('template');
                        tableTemplateElementCopy.innerHTML = tableTemplateElement.innerHTML;

                        recordElement = xtag.query(xtag.query(tableTemplateElementCopy.content, 'tbody')[0], 'tr')[0];

                        if (recordElement) {
                            // add a data- attribute for all where columns (most of the time: id and change_stamp)
                            i = 0;
                            len = element.arrWhereColumns.length;
                            while (i < len) {
                                recordElement.setAttribute('data-' + element.arrWhereColumns[i], '{{! row.' + element.arrWhereColumns[i] + ' }}');
                                i += 1;
                            }

                            // add a doT.js coded "value" attribute to any element with a "column" attribute but no "value" attribute
                            element.tableTemplate = GS.templateColumnToValue(tableTemplateElementCopy.innerHTML);
                        }
                    } else {
                        throw 'Envelope error: table template is required.';
                    }
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'no-hudlimit' ||
                        strAttrName === 'no-hudorderby' ||
                        strAttrName === 'no-huddelete' ||
                        strAttrName === 'no-hudrefresh') {
                        refreshHud(this);

                    // this.root is here becuase of an issue where refresh was called before the envelope was initialized
                    } else if (strAttrName === 'value' && this.root) {
                        this.refresh();
                    }
                }
            }
        },
        events: {},
        accessors: {
            value: {
                get: function () {
                    return this.getAttribute('value');
                },

                set: function (newValue) {
                    this.setAttribute('value', newValue);
                    getData(this);
                }
            },
            selectedCells: {
                get: function () {
                    return xtag.query(this.scrollContainerElement, '[selected]');
                },

                set: function (newValue) {
                    var i, len, intIdIndex, arrCells = xtag.query(this.scrollContainerElement, '[selected]'), arrRecords, cell_i, cell_len,
                        fixedHeaderCells = xtag.queryChildren(this.fixedHeaderContainerElement, '.fixed-header-cell');

                    //console.log(arrRecords);

                    // clear old selection
                    i = 0;
                    len = fixedHeaderCells.length;
                    while (i < len) {
                        fixedHeaderCells[i].removeAttribute('selected');
                        i += 1;
                    }
                    i = 0;
                    len = arrCells.length;
                    while (i < len) {
                        arrCells[i].removeAttribute('selected');
                        i += 1;
                    }

                    arrCells = xtag.query(this.scrollContainerElement, '[selected-secondary]');
                    i = 0;
                    len = arrCells.length;
                    while (i < len) {
                        arrCells[i].removeAttribute('selected-secondary');
                        i += 1;
                    }

                    // if newValue is not an array: make it an array
                    if (typeof newValue === 'object' && newValue.length === undefined) {
                        arrCells = [newValue];
                    } else {
                        arrCells = newValue;
                    }

                    // set new selection
                    i = 0;
                    len = arrCells.length;
                    while (i < len) {
                        arrCells[i].setAttribute('selected', '');

                        if (arrCells[i].parentNode.parentNode.nodeName === 'THEAD') {
                            fixedHeaderCells[arrCells[i].cellIndex].setAttribute('selected', '');
                        }

                        i += 1;
                    }

                    arrRecords = this.selectedRecords;

                    i = 0;
                    len = arrRecords.length;
                    while (i < len) {
                        arrCells = arrRecords[i].children;
                        cell_i = 0;
                        cell_len = arrCells.length;
                        while (cell_i < cell_len) {
                            if (!arrCells[cell_i].hasAttribute('selected')) {
                                arrCells[cell_i].setAttribute('selected-secondary', '');
                            }
                            cell_i += 1;
                        }
                        i += 1;
                    }

                    GS.triggerEvent(this, 'after_selection');
                }
            },
            selectedRecords: {
                get: function () {
                    var i, len, intRecordIndex = -1, arrRecord = [], selected = this.selectedCells;

                    // loop through the selected cells and create an array of trs
                    i = 0;
                    len = selected.length;
                    while (i < len) {
                        if (selected[i].parentNode.rowIndex > intRecordIndex && selected[i].parentNode.parentNode.nodeName !== 'THEAD') {
                            intRecordIndex = selected[i].parentNode.rowIndex;

                            arrRecord.push(selected[i].parentNode);
                        }
                        i += 1;
                    }

                    return arrRecord;
                },

                set: function (newValue) {
                    var i;
                    var len;
                    var cell_i;
                    var cell_len;
                    var intIdIndex;
                    var arrCells = this.selectedCells;
                    var arrRecords;
                    var arrCellChildren;
                    var fixedHeaderCells = xtag.queryChildren(this.fixedHeaderContainerElement, '.fixed-header-cell');

                    // clear old selection
                    i = 0;
                    len = arrCells.length;
                    while (i < len) {
                        arrCells[i].removeAttribute('selected');

                        if (arrCells[i].parentNode.parentNode.nodeName === 'THEAD') {
                            fixedHeaderCells[arrCells[i].cellIndex].removeAttribute('selected', '');
                        }

                        i += 1;
                    }

                    arrCells = xtag.query(this.scrollContainerElement, '[selected-secondary]');
                    i = 0;
                    len = arrCells.length;
                    while (i < len) {
                        arrCells[i].removeAttribute('selected-secondary');
                        i += 1;
                    }

                    // if newValue is not an array: make it an array
                    if (typeof newValue === 'object' && newValue.length === undefined) {
                        arrRecords = [newValue];
                    } else {
                        arrRecords = newValue;
                    }

                    // set new selection
                    i = 0;
                    len = arrRecords.length;
                    arrCells = [];
                    while (i < len) {
                        arrCellChildren = arrRecords[i].children;

                        cell_i = 0;
                        cell_len = arrCellChildren.length;
                        while (cell_i < cell_len) {
                            arrCells.push(arrCellChildren[cell_i]);
                            cell_i += 1;
                        }

                        i += 1;
                    }

                    this.selectedCells = arrCells;

                    GS.triggerEvent(this, 'after_selection');
                }
            },
            selectedIds: {
                get: function () {
                    var i;
                    var len;
                    var arrID = [];
                    var selected = this.selectedRecords;

                    // loop through the selected records and create an array of ids
                    i = 0;
                    len = selected.length;
                    while (i < len) {
                        arrID.push(String(selected[i].dataset.id));
                        //arrID.push(String(selected[i].parentNode.dataset.id));
                        i += 1;
                    }

                    return arrID;
                },

                set: function (newValue) {
                    var i;
                    var len;
                    var cell_i;
                    var cell_len;
                    var arrCells = this.selectedCells; // intIdIndex,
                    var arrRecords = xtag.query(this.scrollContainerElement, 'tbody > tr');

                    //console.log(arrRecords);

                    // clear old selection
                    i = 0;
                    len = arrCells.length;
                    while (i < len) {
                        arrCells[i].removeAttribute('selected');
                        i += 1;
                    }

                    arrCells = xtag.query(this.scrollContainerElement, '[selected-secondary]');
                    i = 0;
                    len = arrCells.length;
                    while (i < len) {
                        arrCells[i].removeAttribute('selected-secondary');
                        i += 1;
                    }

                    // if newValue is not an array: make it an array
                    if (typeof newValue !== 'object') {
                        newValue = [String(newValue)];

                    // else: cast all new values to strings
                    } else {
                        i = 0;
                        len = newValue.length;
                        while (i < len) {
                            newValue[i] = String(newValue[i]);
                            i += 1;
                        }
                    }

                    // set new selection
                    i = 0;
                    len = arrRecords.length;
                    while (i < len) {

                        if (newValue.indexOf(arrRecords[i].getAttribute('data-id')) > -1) {//String(.dataset.id) === String()
                            arrCells = arrRecords[i].children;

                            cell_i = 0;
                            cell_len = arrCells.length;
                            while (cell_i < cell_len) {
                                arrCells[cell_i].setAttribute('selected', '');
                                cell_i += 1;
                            }
                        }
                        i += 1;
                    }

                    GS.triggerEvent(this, 'after_selection');
                }
            }
        },
        methods: {
            // just a semantic alias to the getData function
            refresh: function () {
                getData(this);
            },

            refreshReflow: function () {
                var intEnvelopeWidth = this.scrollContainerElement.clientWidth + 1,
                    bolCurrentlyReflowed,
                    intWindowWidth = window.innerWidth,
                    intReflowAt = parseInt(this.getAttribute('reflow-at'), 10);

                if (this.reflowBreakPoint === undefined) {
                    this.reflowBreakPoint = 0;
                }

                //console.log('check for reflow', window.innerWidth, this.reflowBreakPoint,
                // this.scrollContainerElement.clientWidth < this.scrollContainerElement.scrollWidth);

                bolCurrentlyReflowed = this.classList.contains('reflow');
                this.classList.remove('reflow');

                //console.log(intEnvelopeWidth, this.scrollContainerElement.scrollWidth);
                //console.log('envWidth    ', intEnvelopeWidth);
                //console.log('scrollWidth ', this.scrollContainerElement.scrollWidth);
                //console.log('reflowAt    ', this.hasAttribute('reflow-at'));
                //console.log('intReflowAt ', intReflowAt);

                //if (intWindowWidth > this.reflowBreakPoint) {
                if ((
                        intEnvelopeWidth < this.scrollContainerElement.scrollWidth &&
                        !this.hasAttribute('reflow-at')
                    ) ||
                    (
                        !isNaN(intReflowAt) &&
                        intEnvelopeWidth < intReflowAt
                    )) {
                    if (!bolCurrentlyReflowed) {
                        this.selectedCells = [];
                    }

                    this.reflowBreakPoint = intWindowWidth;
                    this.classList.add('reflow');

                } else {
                    if (bolCurrentlyReflowed) {
                        this.selectedCells = [];
                    }

                    this.reflowBreakPoint = 0;
                    this.classList.remove('reflow');
                }
            },

            refreshFixedHeader: function () {
                var elementFixedHeaderCells = xtag.queryChildren(this.fixedHeaderContainerElement, '.fixed-header-cell'),
                    theadCellElements, i, len, intLeft;

                if (this.theadElement && GS.getStyle(this.theadElement, 'display') !== 'none') {
                    //Why isn't this after we set the widths of the fixed header? -Joseph 10-01-15
                    this.fixedHeaderContainerElement.removeAttribute('hidden');
                    theadCellElements = xtag.query(this.theadElement, 'th, td');

                    i = 0;
                    len = theadCellElements.length;
                    intLeft = 0;
                    while (i < len) {
                        elementFixedHeaderCells[i].style.height = (theadCellElements[i].offsetHeight + 1) + 'px';
                        elementFixedHeaderCells[i].style.width = theadCellElements[i].offsetWidth + 'px';
                        elementFixedHeaderCells[i].style.left = (intLeft - this.scrollContainerElement.scrollLeft) + 'px';

                        intLeft += theadCellElements[i].offsetWidth;
                        i += 1;
                    }
                } else {
                    this.fixedHeaderContainerElement.setAttribute('hidden', '');
                }
            },

            refreshHeight: function () {
                var intHeight = 0;

                //console.log('1*** refreshHeight');

                // if this envelope is zero height: add expand to content automatically
                if (this.clientHeight === 0) {
                    this.setAttribute('expand-to-content', '');
                }

                //console.log('1-1*', this);
                //console.log('1-2*', this.hasAttribute('expand-to-content'));
                if (this.hasAttribute('expand-to-content')) {
                    //console.log('2***');
                    this.style.height = '';

                    intHeight += this.hudTopElement.scrollHeight;
                    //console.log('3***');
                    //intHeight += this.fixedHeaderContainerElement.scrollHeight;
                    intHeight += this.scrollContainerElement.scrollHeight;
                    intHeight += this.hudBottomElement.scrollHeight;
                    //console.log('4***', intHeight);

                    this.style.height = (intHeight + 5) + 'px'; // used to add 2
                    //console.log('5***', this.style.height);
                }
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, addDataEvents
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    "use strict";
    addSnippet(
        '<gs-folder>',
        '<gs-folder>',
        'gs-folder path="${0:/}" folder="${1:role}"></gs-folder>'
    );

    addElement('gs-folder', '#controls_folder');

    window.designElementProperty_GSFOLDER = function () {
        addText('D', 'Path', 'path');
        addCheck('V', 'Hide Folders', 'no-folders');
        addCheck('V', 'Hide Files', 'no-files');
        addCheck('V', 'Side-By-Side', 'horizontal');
        addCheck('V', 'Mini', 'mini');
        addCheck('V', 'Disabled', 'disabled');
        addDataEvents('select,insert,update,delete');
        addText('O', 'Column In QS', 'qs');
    };
});

(function () {
    'use strict';

    // #################################################################################################
    // ############################################ UTILITY ############################################
    // #################################################################################################

    function getPath(element) {
        var strAttributePath = GS.trim(GS.templateWithQuerystring(element.getAttribute('path') || ''), '/');
        var strInnerPath = element.arrPath.join('/');
        var strRet;

        if (strAttributePath && strInnerPath) {
            strRet = '/' + strAttributePath + '/' + strInnerPath + '/';
        } else if (strAttributePath) {
            strRet = '/' + strAttributePath + '/';
        } else if (strInnerPath) {
            strRet = '/' + strInnerPath + '/';
        }

        return strRet || '/';
    }

    function getRealPath(element) {
        var strAttributePath = GS.trim(GS.templateWithQuerystring(element.getAttribute('path') || ''), '/');
        var arrPath = element.arrPath;
        var strInnerPath;
        var strRet;
        var strPrefix;

        if (element.arrPath[0] === 'app' || strAttributePath.indexOf('app') === 0) {
            strPrefix = '/env';
        } else if (element.arrPath[0] === 'role' || strAttributePath.indexOf('role') === 0) {
            strPrefix = '/env';
        } else if (element.arrPath[0] === 'web_root' || strAttributePath.indexOf('web_root') === 0) {
            strPrefix = '';
            arrPath.splice(0, 1);
        }

        strInnerPath = arrPath.join('/');

        if (strAttributePath && strInnerPath) {
            strRet = '/' + strAttributePath + '/' + strInnerPath + '/';
        } else if (strAttributePath) {
            strRet = '/' + strAttributePath + '/';
        } else if (strInnerPath) {
            strRet = '/' + strInnerPath + '/';
        }

        return (strPrefix || '') + (strRet || '/');
    }

    function getData(element) {
        GS.triggerEvent(element, 'before_select');
        GS.triggerEvent(element, 'onbefore_select');
        if (element.hasAttribute('onbefore_select')) {
            new Function(element.getAttribute('onbefore_select')).apply(element);
        }

        var strPath = getPath(element);
        var bolFolders = !element.hasAttribute('no-folders');
        var bolFiles = !element.hasAttribute('no-files');
        var strHeader;
        var intResponseNumber;
        var arrAllPaths = [];

        element.folderList.innerHTML = '';
        element.fileList.innerHTML = '';

        strHeader = GS.trim('/' + element.arrPath.join('/'), '/');

        // if there is something in the header: wrap it with slashes
        if (strHeader) {
            strHeader = '/' + strHeader + '/';
        }

        element.pathTitle.textContent = strHeader;

        if (element.arrPath.length > 0) {
            element.backButton.removeAttribute('disabled');
        } else {
            element.backButton.setAttribute('disabled', '');
        }
        element.arrFile = [];
        element.arrFolder = [];
        intResponseNumber = 0;
        GS.requestFromSocket(GS.envSocket, 'FILE\tLIST\t' + GS.encodeForTabDelimited(strPath), function (data, error, errorData) {
            var arrPaths;
            var strName;
            var strType;
            var arrCells;
            var i;
            var len;
            var divElement;
            var arrFiles = [];
            var arrFolders = [];

            if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                if (data !== 'TRANSACTION COMPLETED') {
                    arrPaths = GS.trim(data, '\n').split('\n');
                    if (intResponseNumber === 0) {
                        element.folderList.innerHTML = '';
                        element.fileList.innerHTML = '';
                    }
                    i = 0;
                    len = arrPaths.length;
                    while (i < len) {
                        arrAllPaths.push(arrPaths[i]);
                        i += 1;
                    }

                    element.arrFile = arrFiles;
                    element.arrFolder = arrFolders;
                    GS.triggerEvent(element, 'change');
                    GS.triggerEvent(element, 'after_select');
                    GS.triggerEvent(element, 'onafter_select');
                    if (element.hasAttribute('onafter_select')) {
                        new Function(element.getAttribute('onafter_select')).apply(element);
                    }

                } else {
                    arrAllPaths.sort();
                    i = 0;
                    len = arrAllPaths.length;
                    while (i < len) {
                        arrCells = arrAllPaths[i].split('\t');
                        strType = GS.decodeFromTabDelimited(arrCells[1]);
                        strName = GS.trim(GS.decodeFromTabDelimited(arrCells[0]), '/');

                        if ((strType === 'folder' && bolFolders) || (strType === 'file' && bolFiles)) {
                            divElement = document.createElement('div');
                            divElement.setAttribute('flex-horizontal', '');
                            divElement.setAttribute('flex-fill', '');
                            divElement.setAttribute('class', strType + '-line');
                            divElement.setAttribute('data-name', strName);

                            if (strType === 'file') {
                                arrFiles.push(element.arrPath.join('/') + '/' + strName);
                                divElement.innerHTML = (
                                    '<gs-button class="more-file" icononly icon="bars" remove-right>File Options</gs-button>' +
                                    '<gs-button class="open-file" flex remove-left>' + encodeHTML(strName) + '</gs-button>'
                                );

                                element.fileList.appendChild(divElement);
                            }

                            if (strType === 'folder') {
                                arrFolders.push(element.arrPath.join('/') + '/' + strName);
                                divElement.innerHTML = (
                                    '<gs-button class="more-folder" icononly icon="bars" remove-right>Folder Options</gs-button>' +
                                    '<gs-button class="open-folder" flex remove-left>' + encodeHTML(strName) + '</gs-button>'
                                );

                                element.folderList.appendChild(divElement);
                            }
                        }
                        i += 1;
                    }
                    
                    if (element.folderList.innerHTML === '') {
                        element.folderList.innerHTML = '<center prevent-text-selection><h4><small>No Folders.</small></h4></center>';
                    }

                    if (element.fileList.innerHTML === '') {
                        element.fileList.innerHTML = '<center prevent-text-selection><h4><small>No Files.</small></h4></center>';
                    }
                }
            } else if (error) {
                if (!element.hasAttribute('no-list-error')) {
                    GS.webSocketErrorDialog(errorData);
                } else {
                    GS.triggerEvent(element, 'after_select');
                    GS.triggerEvent(element, 'onafter_select');
                    if (element.hasAttribute('onafter_select')) {
                        new Function(element.getAttribute('onafter_select')).apply(element);
                    }
                }
            }

            intResponseNumber += 1;
        });
    }

    function prepareElement(element) {
        element.innerHTML = ml(function () {/*
            <div class="root" flex-vertical flex-fill gs-dynamic>
                <span class="path-title"></span>
                <div class="list-container" flex-fill>
                    <div class="folder-list-container" flex-vertical flex-fill flex>
                        <div class="folder-list-header" flex-horizontal>
                            <b flex prevent-text-selection>Folders:</b>
                            <gs-button class="button-back-folder" icon="long-arrow-left" icononly remove-bottom disabled no-focus></gs-button>
                            <gs-button class="button-new-folder" icon="plus" icononly remove-bottom no-focus></gs-button>
                        </div>
                        <div class="folder-list" flex></div>
                    </div>
                    <div class="file-list-container" flex-vertical flex-fill flex>
                        <div class="file-list-header" flex-horizontal>
                            <b flex prevent-text-selection>Files:</b>
                            <gs-button class="button-new-file" icon="plus" icononly remove-bottom no-focus></gs-button>
                            <gs-button class="button-upload-file" icon="upload" icononly remove-bottom no-focus></gs-button>
                        </div>
                        <div class="file-list" flex></div>
                    </div>
                </div>
            </div>*/
        });

        element.root = xtag.queryChildren(element, '.root')[0];
        element.folderListHeader = xtag.query(element.root, '.folder-list-header')[0];
        element.fileListHeader = xtag.query(element.root, '.file-list-header')[0];

        element.folderList = xtag.query(element.root, '.folder-list')[0];
        element.fileList = xtag.query(element.root, '.file-list')[0];

        element.newFolderButton = xtag.query(element.root, '.button-new-folder')[0];
        element.newFileButton = xtag.query(element.root, '.button-new-file')[0];
        element.uploadFileButton = xtag.query(element.root, '.button-upload-file')[0];
        element.backButton = xtag.query(element.root, '.button-back-folder')[0];

        element.pathTitle = xtag.query(element.root, '.path-title')[0];

        element.arrPath = [];
    }

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        while (i < len) {
            jsnAttr = element.attributes[i];
            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol && strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else {
            if (element.internal.bolQSFirstRun === true && GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                getData(element);
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    function fileUpload(element) {
        var templateElement = document.createElement('template');
        var strHTML;

        strHTML = ml(function () {/*
            <gs-page>
                <gs-header><center><h3>Upload a File</h3></center></gs-header>
                <gs-body padded>
                    <form class="upload-form" action="/env/upload" method="POST" target="upload_response_gs_folder"
                                enctype="multipart/form-data">*/
        });

        if (element.hasAttribute('upload-choose-file-name')) {
            strHTML += ml(function () {/*
                        <br />
                        <label>File Name:</label>
                        <gs-text class="upload-name" disabled autocorrect="off" autocapitalize="off" autocomplete="off" spellcheck="false"></gs-text>*/
            });
        } else {
            strHTML += ml(function () {/*
                        <gs-text class="upload-name" hidden></gs-text>*/
            });
        }

        strHTML += ml(function () {/*
                        <input class="upload-path" name="file_name" hidden />

                        <label>File:</label>
                        <gs-text class="upload-file" name="file_content" type="file"></gs-text>
                    </form>
                    <iframe class="upload-frame" name="upload_response_gs_folder" hidden></iframe>
                </gs-body>
                <gs-footer>
                    <gs-grid>
                        <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
                        <gs-block><gs-button class="upload-button">Upload File</gs-button></gs-block>
                    </gs-grid>
                </gs-footer>
            </gs-page>*/
        });

        templateElement.innerHTML = strHTML;

        GS.openDialog(templateElement, function () {
            var dialog = this;
            var formElement = xtag.query(dialog, '.upload-form')[0];
            var fileControl = xtag.query(dialog, '.upload-file')[0];
            var nameControl = xtag.query(dialog, '.upload-name')[0];
            var pathControl = xtag.query(dialog, '.upload-path')[0];
            var uploadButton = xtag.query(dialog, '.upload-button')[0];
            var responseFrame = xtag.query(dialog, '.upload-frame')[0];
            var strFileExtension;

            // upload existing file
            uploadButton.addEventListener('click', function () {
                GS.triggerEvent(element, 'before_insert');
                GS.triggerEvent(element, 'onbefore_insert');
                if (element.hasAttribute('onbefore_insert')) {
                    new Function(element.getAttribute('onbefore_insert')).apply(element);
                }

                var strFile = fileControl.value;
                var strName = nameControl.value;

                //console.log(element.innerPath + nameControl.value);
                pathControl.setAttribute('value', getPath(element) + nameControl.value + '.' + strFileExtension);

                if (strName === '' && strFile === '') { // no values (no file and no file name)
                    GS.msgbox('Error', 'No values in form. Please fill in the form.', 'okonly');

                } else if (strFile === '') { // one value missing (no file)
                    GS.msgbox('Error', 'No file selected. Please select a file using the file input.', 'okonly');

                } else if (strName === '') { // one value missing (no file name)
                    GS.msgbox('Error', 'No value in file path textbox. Please fill in file name textbox.', 'okonly');

                } else { // values are filled in submit the form
                    responseFrame.loadListen = true;
                    formElement.submit();
                    GS.addLoader('file-upload', 'Uploading file...');
                }
            });

            fileControl.addEventListener('change', function () {
                var strValue = this.value;

                strFileExtension = strValue.substring(strValue.lastIndexOf('.') + 1);

                nameControl.removeAttribute('disabled');
                nameControl.value = strValue.substring(strValue.lastIndexOf('\\') + 1, strValue.lastIndexOf('.')) || 'filename';
                nameControl.focus();
            });

            nameControl.addEventListener('keydown', function (event) {
                if (event.keyCode === 13) {
                    GS.triggerEvent('click', uploadButton);
                }
            });

            // response frame binding
            responseFrame.addEventListener('load', function () {
                var strResponseText = responseFrame.contentWindow.document.body.textContent;
                var jsnResponse;
                var strResponse;
                var bolError;
                var strError;

                if (responseFrame.loadListen === true) {
                    // get error text
                    try {
                        jsnResponse = JSON.parse(strResponseText);
                    } catch (err) {
                        strResponse = strResponseText;
                    }

                    if (strResponse.trim() === 'Upload Succeeded') {
                        GS.closeDialog(dialog, 'cancel');
                    } else {
                        if (jsnResponse) {
                            if (jsnResponse.stat === true) {
                                bolError = false;
                            } else {
                                bolError = true;
                                if (jsnResponse.dat && jsnResponse.dat.error) {
                                    strError = jsnResponse.dat.error;
                                } else {
                                    strError = jsnResponse.dat;
                                }
                            }
                        } else {
                            bolError = true;
                            strError = strResponse;
                        }

                        // if no error destroy new file popup
                        if (!bolError) {
                            GS.closeDialog(dialog, 'cancel');

                        // if error open error popup
                        } else {
                            GS.msgbox('Error', strError, 'okonly');
                        }
                    }

                    getData(element);
                    GS.removeLoader('file-upload');
                    GS.triggerEvent(element, 'upload-complete');
                    GS.triggerEvent(element, 'after_insert');
                    GS.triggerEvent(element, 'onafter_insert');
                    if (element.hasAttribute('onafter_insert')) {
                        new Function(element.getAttribute('onafter_insert')).apply(element);
                    }
                }
            });
        });
    }


    // ################################################################################################
    // ####################################### FOLDER FUNCTIONS #######################################
    // ################################################################################################

    function folderRename(element, target, strOldPath, strFolderName) {
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                <label for="gs-file-manager-text-folder-name">Folder Name:</label>
                <gs-text id="gs-file-manager-text-folder-name"></gs-text>
                <hr />
                <gs-grid>
                    <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right>Cancel</gs-button></gs-block>
                    <gs-block><gs-button dialogclose remove-left>Rename</gs-button></gs-block>
                </gs-grid>
            </gs-body>*/
        });

        GS.openDialogToElement(
            target,
            templateElement,
            'right',
            function () {
                document.getElementById('gs-file-manager-text-folder-name').value = strFolderName;
            },
            function (ignore, strAnswer) { //event
                var strNewPath;

                if (strAnswer === 'Rename') {
                    GS.triggerEvent(element, 'before_update');
                    GS.triggerEvent(element, 'onbefore_update');
                    if (element.hasAttribute('onbefore_update')) {
                        new Function(element.getAttribute('onbefore_update')).apply(element);
                    }
                    strNewPath = getPath(element) + document.getElementById('gs-file-manager-text-folder-name').value;

                    GS.requestFromSocket(
                        GS.envSocket,
                        (
                            'FILE\tMOVE\t' +
                            GS.encodeForTabDelimited(strOldPath) + '\t' +
                            GS.encodeForTabDelimited(strNewPath) + '\n'
                        ),
                        function (data, error, errorData) {
                            if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                                if (data === 'TRANSACTION COMPLETED') {
                                    GS.triggerEvent(element, 'after_update');
                                    GS.triggerEvent(element, 'onafter_update');
                                    if (element.hasAttribute('onafter_update')) {
                                        new Function(element.getAttribute('onafter_update')).apply(element);
                                    }
                                    getData(element);
                                }
                            } else if (error) {
                                GS.webSocketErrorDialog(errorData);
                            }
                        }
                    );
                }
            }
        );
    }

    function folderDelete(element, target, strPath, strFolderName) {
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                Are you sure you want to delete the folder: "<b>{{STRPATH}}</b>"?
                <hr />
                <gs-grid>
                    <gs-block><gs-button dialogclose remove-right style="border-right: 0 none;" listen-for-return>No</gs-button></gs-block>
                    <gs-block><gs-button dialogclose remove-left>Yes</gs-button></gs-block>
                </gs-grid>
            </gs-body>*/
        }).replace(/\{\{STRPATH\}\}/gi, strFolderName);

        GS.openDialogToElement(target, templateElement, 'right', '', function (ignore, strAnswer) { //event
            if (strAnswer === 'Yes') {
                GS.triggerEvent(element, 'before_delete');
                GS.triggerEvent(element, 'onbefore_delete');
                if (element.hasAttribute('onbefore_delete')) {
                    new Function(element.getAttribute('onbefore_delete')).apply(element);
                }
                GS.requestFromSocket(
                    GS.envSocket,
                    'FILE\tDELETE\t' + GS.encodeForTabDelimited(strPath) + '\n',
                    function (data, error, errorData) {
                        if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                            if (data === 'TRANSACTION COMPLETED') {
                                GS.triggerEvent(element, 'after_delete');
                                GS.triggerEvent(element, 'onafter_delete');
                                if (element.hasAttribute('onafter_delete')) {
                                    new Function(element.getAttribute('onafter_delete')).apply(element);
                                }
                                getData(element);
                            }
                        } else if (error) {
                            GS.webSocketErrorDialog(errorData);
                        }
                    }
                );
            }
        });
    }

    function newFolder(element, target) {
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                <label for="gs-file-manager-text-folder-name">New Folder Name:</label>
                <gs-text id="gs-file-manager-text-folder-name"></gs-text>
                <hr />
                <gs-grid>
                    <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right listen-for-return>Cancel</gs-button></gs-block>
                    <gs-block><gs-button dialogclose remove-left>Create</gs-button></gs-block>
                </gs-grid>
            </gs-body>*/
        });

        GS.openDialogToElement(target, templateElement, 'down', '', function (ignore, strAnswer) { //event
            var strPath;

            if (strAnswer === 'Create') {
                GS.triggerEvent(element, 'before_insert');
                GS.triggerEvent(element, 'onbefore_insert');
                if (element.hasAttribute('onbefore_insert')) {
                    new Function(element.getAttribute('onbefore_insert')).apply(element);
                }
                strPath = getPath(element) + document.getElementById('gs-file-manager-text-folder-name').value;
                GS.requestFromSocket(
                    GS.envSocket,
                    'FILE\tCREATE_FOLDER\t' + GS.encodeForTabDelimited(strPath) + '\n',
                    function (data, error, errorData) {
                        if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                            if (data === 'TRANSACTION COMPLETED') {
                                GS.triggerEvent(element, 'after_insert');
                                GS.triggerEvent(element, 'onafter_insert');
                                if (element.hasAttribute('onafter_insert')) {
                                    new Function(element.getAttribute('onafter_insert')).apply(element);
                                }
                                getData(element);
                            }
                        } else if (error) {
                            GS.webSocketErrorDialog(errorData);
                        }
                    }
                );
            }
        });
    }

    function folderOpen(element, target) {
        var lineElement = GS.findParentElement(target, '.folder-line');

        element.arrPath.push(lineElement.getAttribute('data-name'));
        getData(element);
    }

    function backFolder(element) {
        element.arrPath.pop();
        getData(element);
    }

    function folderMenu(element, target) {
        var lineElement = GS.findParentElement(target, '.folder-line');
        var strFolderName = lineElement.getAttribute('data-name');
        var strPath = (getPath(element) + strFolderName);
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                <gs-button dialogclose remove-bottom style="border-bottom: 0 none;">Rename Folder</gs-button>
                <gs-button dialogclose remove-top>Delete Folder</gs-button>
                <hr />
                <gs-button dialogclose listen-for-return>Cancel</gs-button>
            </gs-body>*/
        });

        GS.openDialogToElement(target, templateElement, 'right', '', function (ignore, strAnswer) { //event
            if (strAnswer === 'Rename Folder') {
                folderRename(element, target, strPath, strFolderName);
            } else if (strAnswer === 'Delete Folder') {
                folderDelete(element, target, strPath, strFolderName);
            }
        });
    }

    // ################################################################################################
    // ######################################## FILE FUNCTIONS ########################################
    // ################################################################################################

    function fileRename(element, target, strOldPath, strFileName) {
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                <label for="gs-file-manager-text-file-name">File Name:</label>
                <gs-text id="gs-file-manager-text-file-name"></gs-text>
                <hr />
                <gs-grid>
                    <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right>Cancel</gs-button></gs-block>
                    <gs-block><gs-button dialogclose remove-left>Rename</gs-button></gs-block>
                </gs-grid>
            </gs-body>*/
        });

        GS.openDialogToElement(
            target,
            templateElement,
            'right',
            function () {
                document.getElementById('gs-file-manager-text-file-name').value = strFileName;
            },
            function (ignore, strAnswer) {//event
                var strNewPath;

                if (strAnswer === 'Rename') {
                    GS.triggerEvent(element, 'before_update');
                    GS.triggerEvent(element, 'onbefore_update');
                    if (element.hasAttribute('onbefore_update')) {
                        new Function(element.getAttribute('onbefore_update')).apply(element);
                    }
                    strNewPath = getPath(element) + document.getElementById('gs-file-manager-text-file-name').value;

                    GS.requestFromSocket(
                        GS.envSocket,
                        (
                            'FILE\tMOVE\t' +
                            GS.encodeForTabDelimited(strOldPath) + '\t' +
                            GS.encodeForTabDelimited(strNewPath) + '\n'
                        ),
                        function (data, error, errorData) {
                            if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                                if (data === 'TRANSACTION COMPLETED') {
                                    GS.triggerEvent(element, 'after_update');
                                    GS.triggerEvent(element, 'onafter_update');
                                    if (element.hasAttribute('onafter_update')) {
                                        new Function(element.getAttribute('onafter_update')).apply(element);
                                    }
                                    getData(element);
                                }
                            } else if (error) {
                                GS.webSocketErrorDialog(errorData);
                            }
                        }
                    );
                }
            }
        );
    }

    function fileDelete(element, target, strPath, strFileName) {
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                Are you sure you want to delete the file: "<b>{{STRPATH}}</b>"?
                <hr />
                <gs-grid>
                    <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right listen-for-return>No</gs-button></gs-block>
                    <gs-block><gs-button dialogclose remove-left>Yes</gs-button></gs-block>
                </gs-grid>
            </gs-body>*/
        }).replace(/\{\{STRPATH\}\}/gi, strFileName);

        GS.openDialogToElement(target, templateElement, 'right', '', function (ignore, strAnswer) { //event
            if (strAnswer === 'Yes') {
                GS.triggerEvent(element, 'before_delete');
                GS.triggerEvent(element, 'onbefore_delete');
                if (element.hasAttribute('onbefore_delete')) {
                    new Function(element.getAttribute('onbefore_delete')).apply(element);
                }
                GS.requestFromSocket(
                    GS.envSocket,
                    'FILE\tDELETE\t' + GS.encodeForTabDelimited(strPath) + '\n',
                    function (data, error, errorData) {
                        if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                            if (data === 'TRANSACTION COMPLETED') {
                                GS.triggerEvent(element, 'after_delete');
                                GS.triggerEvent(element, 'onafter_delete');
                                if (element.hasAttribute('onafter_delete')) {
                                    new Function(element.getAttribute('onafter_delete')).apply(element);
                                }
                                getData(element);
                            }
                        } else if (error) {
                            GS.webSocketErrorDialog(errorData);
                        }
                    }
                );
            }
        });
    }

    function fileEdit(strPath) {
        window.open('/env/app/all/file_manager/file_edit.html?socket=true&link=' + encodeURIComponent(strPath));
    }

    function newFile(element, target) {
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                <label for="gs-file-manager-text-file-name">New File Name:</label>
                <gs-text id="gs-file-manager-text-file-name"></gs-text>
                <hr />
                <gs-grid>
                    <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right>Cancel</gs-button></gs-block>
                    <gs-block><gs-button dialogclose remove-left>Create</gs-button></gs-block>
                </gs-grid>
            </gs-body>*/
        });

        GS.openDialogToElement(target, templateElement, 'down', '', function (ignore, strAnswer) {//event
            var strPath;
            var strName = document.getElementById('gs-file-manager-text-file-name').value || '';

            if (strAnswer === 'Create' && strName) {
                GS.triggerEvent(element, 'before_insert');
                GS.triggerEvent(element, 'onbefore_insert');
                if (element.hasAttribute('onbefore_insert')) {
                    new Function(element.getAttribute('onbefore_insert')).apply(element);
                }
                strPath = getPath(element) + strName;

                if (document.getElementById('gs-file-manager-text-file-name').value.trim()) {
                    GS.requestFromSocket(
                        GS.envSocket,
                        'FILE\tCREATE_FILE\t' + GS.encodeForTabDelimited(strPath) + '\n',
                        function (data, error, errorData) {
                            if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                                if (data === 'TRANSACTION COMPLETED') {
                                    GS.triggerEvent(element, 'after_insert');
                                    GS.triggerEvent(element, 'onafter_insert');
                                    if (element.hasAttribute('onafter_insert')) {
                                        new Function(element.getAttribute('onafter_insert')).apply(element);
                                    }
                                    getData(element);
                                }
                            } else if (error) {
                                GS.webSocketErrorDialog(errorData);
                            }
                        }
                    );
                }
            }
        });
    }

    function fileOpen(element, target) {
        var lineElement = GS.findParentElement(target, '.file-line');

        window.open(location.protocol + '//' + location.host + getRealPath(element) + '' + lineElement.getAttribute('data-name'));
    }

    function fileMenu(element, target) {
        var lineElement = GS.findParentElement(target, '.file-line');
        var strFileName = lineElement.getAttribute('data-name');
        var strPath = getPath(element) + strFileName;
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                <gs-button dialogclose remove-bottom style="border-bottom: 0 none;">Rename File</gs-button>
                <gs-button dialogclose remove-all style="border-bottom: 0 none;">Delete File</gs-button>
                <gs-button dialogclose remove-top>Edit File</gs-button>
                <hr />
                <gs-button dialogclose listen-for-return>Cancel</gs-button>
            </gs-body>*/
        });

        GS.openDialogToElement(target, templateElement, 'right', '', function (ignore, strAnswer) { //event
            if (strAnswer === 'Rename File') {
                fileRename(element, target, strPath, strFileName);
            } else if (strAnswer === 'Delete File') {
                fileDelete(element, target, strPath, strFileName);
            } else if (strAnswer === 'Edit File') {
                fileEdit(strPath);
            }
        });
    }


    // ################################################################################################
    // ############################################# XTAG #############################################
    // ################################################################################################

    function bindElement(element) {
        if (element.hasAttribute('qs')) {
            pushReplacePopHandler(element);
            window.addEventListener('pushstate', function () {
                pushReplacePopHandler(element);
            });
            window.addEventListener('replacestate', function () {
                pushReplacePopHandler(element);
            });
            window.addEventListener('popstate', function () {
                pushReplacePopHandler(element);
            });
        }

        element.addEventListener('click', function (event) {
            var target = event.target;

            if (target.classList.contains('button-new-folder')) {
                newFolder(element, target);
            } else if (target.classList.contains('button-new-file')) {
                newFile(element, target);
            } else if (target.classList.contains('open-file')) {
                fileOpen(element, target);
            } else if (target.classList.contains('open-folder')) {
                folderOpen(element, target);
            } else if (target.classList.contains('button-back-folder')) {
                backFolder(element, target);
            } else if (target.classList.contains('more-folder')) {
                folderMenu(element, target);
            } else if (target.classList.contains('more-file')) {
                fileMenu(element, target);
            } else if (target.classList.contains('button-upload-file')) {
                fileUpload(element, target);
            }
        });
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                prepareElement(element);
                bindElement(element);

                //// if no "qs" set or "qs" key set in query string <- non-standard behaviour, you could want
                //if ((!element.hasAttribute('qs') || GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs')))) {
                //    getData(element);
                //}

                getData(element);
                //pushReplacePopHandler(element);
            }
        }
    }

    xtag.register('gs-folder', {
        lifecycle: {
            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, ignore, newValue) { //oldValue
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                }// else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {

                //}
            }
        },
        events: {},
        accessors: {},
        methods: {
            refresh: function () {
                getData(this);
            }
        }
    });
}());//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';

    addSnippet(
        '<gs-font>',
        '<gs-font>',
        'gs-font min-width="${1}">\n' +
        '    ${0}\n' +
        '</gs-font>'
    );

    addElement('gs-font', '#layout_font_size');

    window.designElementProperty_GSFONT = function () {
        addText('V', 'Min-Width Media', 'min-width');
        addText('V', 'Media', 'media');
        addFlexProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var arrTakenFonts = [];

    //
    function elementInserted(element) {
        var styleElement;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                // if the style element for the container CSS doesn't exist: create it
                if (!document.getElementById('gs-dynamic-css')) {
                    styleElement = document.createElement('style');
                    styleElement.setAttribute('id', 'gs-dynamic-css');
                    styleElement.setAttribute('gs-dynamic', '');
                    document.head.appendChild(styleElement);
                }

                if (element.getAttribute('min-width')) {
                    element.handleMinWidthCSS();
                } else if (element.getAttribute('media')) {
                    element.handleMediaCSS();
                }
            }
        }
    }

    xtag.register('gs-font', {
        lifecycle: {
            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-inserted" has been removed: run inserted code
                if (
                    strAttrName === 'suspend-created' &&
                    strAttrName === 'suspend-inserted' &&
                    newValue === null
                ) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // if the "min-width" attribute changed
                    if (strAttrName === 'min-width') {
                        this.handleMinWidthCSS();

                    // if the "media" attribute changed
                    } else if (strAttrName === 'media') {
                        this.handleMediaCSS();
                    }
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            handleMinWidthCSS: function () {
                var strMinWidth = this.getAttribute('min-width');
                var arrMinWidths;
                var strCSS;
                var i;
                var len;
                var arrClassesToRemove;
                var intContainerID;
                var arrParts;
                var strMedia;
                var strResult;

                // remove old classes
                arrClassesToRemove = String(this.classList).match(/font-id-[0-9]*/g) || [];

                for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                    this.classList.remove(arrClassesToRemove[i]);
                }

                // all {15px}; lrg {25px};
                // all {15px}; lrg {25px};
                // all {20px}; sml {25px}; med {30px}; lrg {35px};

                // all close curly braces, remove all whitespace, lowercase, trim off semicolons
                strMinWidth = GS.trim(strMinWidth.replace(/\}/g, '').replace(/\s+/g, '').toLowerCase(), ';');

                // replace shortcuts (lrg => 1200px)
                strMinWidth = strMinWidth.replace(/all/g, '0px')
                                         .replace(/small|sml/g, '768px')
                                         .replace(/medium|med/g, '992px')
                                         .replace(/large|lrg/g, '1200px');

                arrMinWidths = strMinWidth.split(';'); // seperate out layouts

                if (arrTakenFonts.indexOf(strMinWidth) === -1) {
                    arrTakenFonts.push(strMinWidth);
                    intContainerID = arrTakenFonts.length - 1;
                    strCSS = '';

                    for (i = 0, len = arrMinWidths.length; i < len; i += 1) {
                        arrParts = arrMinWidths[i].split('{');
                        strMedia = arrParts[0];
                        strResult = arrParts[1];

                        strCSS +=   '\n@media (min-width:' + strMedia + ') {\n' +
                                    '    gs-font.font-id-' + intContainerID + ' { font-size:' + strResult + '; }\n' +
                                    '}\n';
                    }

                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* font #' + intContainerID + ' */\n' + strCSS;

                } else {
                    intContainerID = arrTakenFonts.indexOf(strMinWidth);
                }

                this.classList.add('font-id-' + intContainerID);
            },

            handleMediaCSS: function () {
                var strMedia = this.getAttribute('media');
                var arrMedias;
                var strCSS;
                var i;
                var len;
                var arrClassesToRemove;
                var arrParts;
                var strCurrentMedia;
                var strWidth;
                var intContainerID;

                // remove old classes
                arrClassesToRemove = String(this.classList).match(/font-id-[0-9]*/g) || [];

                for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                    this.classList.remove(arrClassesToRemove[i]);
                }

                // print {20px}; all and (max-width: 500px) {20px}; (min-width: 500px) {25px};

                // trim, remove all close curly braces, lowercase, trim off semicolons
                strMedia = GS.trim(strMedia.trim().replace(/\}/g, '').toLowerCase(), ';');

                // replace shortcuts (lrg => 1200px)
                strMedia = strMedia.replace(/all/g, '0px')
                                   .replace(/small|sml/g, '768px')
                                   .replace(/medium|med/g, '992px')
                                   .replace(/large|lrg/g, '1200px');

                arrMedias = strMedia.split(';'); // seperate out layouts

                if (arrTakenFonts.indexOf(strMedia) === -1) {
                    arrTakenFonts.push(strMedia);
                    intContainerID = arrTakenFonts.length - 1;
                    strCSS = '';

                    for (i = 0, len = arrMedias.length; i < len; i += 1) {
                        arrParts = arrMedias[i].split('{');
                        strCurrentMedia = arrParts[0].trim() || 'all';
                        strWidth = arrParts[1].trim() || '900px';

                        strCSS +=   '\n@media ' + strCurrentMedia + ' {\n' +
                                    '    gs-font.font-id-' + intContainerID + ' ' +
                                                '{ font-size: ' + strWidth + '; }\n' +
                                    '}\n';
                    }

                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* font #' + intContainerID + ' */\n' + strCSS;
                } else {
                    intContainerID = arrTakenFonts.indexOf(strMinWidth);
                }

                this.classList.add('font-id-' + intContainerID);
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';
    addSnippet('<gs-footer>', '<gs-footer>', 'gs-footer>$0</gs-footer>');

    addElement('gs-footer', '#layout_page');

    window.designElementProperty_GSFOOTER = function () {
        addFlexContainerProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    xtag.register('gs-footer', {
        lifecycle: {
            created: function () {
                if (!this.hasAttribute('role') && !GS.findParentTag(this, 'gs-dialog')) {
                    this.setAttribute('role', 'contentinfo');
                }
            }
        },
        events: {},
        accessors: {},
        methods: {}
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp, shimmed
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, addFocusEvents, addDataEvents, addDataAttributes
//global addAutocompleteProps
//jslint browser:true, maxlen:80, white:false, this:true

// # CODE INDEX:          <- (use "find" (CTRL-f or CMD-f) to skip to a section)
//      # TOP             <- (this just brings you back this index)
//      # ELEMENT DOCUMENTATION
//      # NOTES/IDEAS
//      # SNIPPET/DESIGN
//      # FUNCTION SHORTCUTS
//      # UTILITY FUNCTIONS
//      # ELEMENT FUNCTIONS
//      # RENDER FUNCTIONS
//      # DATA FUNCTIONS
//      # EVENT FUNCTIONS
//          # QS EVENTS
//          # CHANGE EVENTS
//          # KEY EVENTS
//          # DEVELOPER EVENTS
//          # HIGH LEVEL BINDING
//      # XTAG DEFINITION
//      # ELEMENT LIFECYCLE
//      # ELEMENT ACCESSORS
//      # ELEMENT METHODS
//
// For code that needs to be completed:
//      # NEED CODING


// ############################################################################
// ########################## ELEMENT DOCUMENTATION ###########################
// ############################################################################





// ############################################################################
// ############################### NOTES/IDEAS ################################
// ############################################################################

/*
Event 'after_select_error'

class 'saving-warning-parent'
class 'saving-warning'
Attribute 'data-theme', 'error'

Attribute 'suppress-no-record-found'


*/


// ############################################################################
// ############################## SNIPPET/DESIGN ##############################
// ############################################################################

window.addEventListener('design-register-element', function () {
    'use strict';
    addSnippet(
        '<gs-form>',
        '<gs-form>',
        (
            'gs-form src="${1:test.tpeople}">\n' +
            '    <template>\n' +
            '        ${2}\n' +
            '    </template>\n' +
            '</gs-form>'
        )
    );

    addElement('gs-form', '#record_form');

    window.designElementProperty_GSFORM = function () {
        addDataAttributes('select,update');
        addCheck('D', 'Save&nbsp;While&nbsp;Typing', 'save-while-typing');
        addCheck(
            'D',
            'Suppress<br />"No&nbsp;Record&nbsp;Found"<br />Error',
            'suppress-no-record-found'
        );
        addDataEvents('select,update');
        addText('O', 'Column In QS', 'qs');
        addText('O', 'Refresh On QS Columns', 'refresh-on-querystring-values');
        addText('O', 'Refresh On QS Change', 'refresh-on-querystring-change');
        addFlexContainerProps();
        addFlexProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
// ############################################################################
// ############################ FUNCTION SHORTCUTS ############################
// ############################################################################

    var qryKids = xtag.queryChildren;
    var qryAll = xtag.query;


// ############################################################################
// ########################## PAGE LEAVE PROTECTION ###########################
// ############################################################################

    // before the page unloads, we need to check to make sure there aren't any
    //      queued changes that have yet to be sent up the websocket. Also, if
    //      there are changes typed that haven't been committed, we want to
    //      focusout to get that update into the websocket. Once the update is
    //      in the websocket, we don't have to worry about leaving the page.
    GS.addBeforeUnloadEvent(function () {
        var arrElement;
        var i;
        var len;

        // trigger save on any incomplete controls
        document.activeElement.blur();

        // check for queued updates, or timed updates
        arrElement = qryAll(document.body, 'gs-form');

        i = 0;
        len = arrElement.length;
        while (i < len) {
            if (arrElement[i].internalData.updateQueue.length > 0) {
                return 'The page has not finished saving.';
            }
            if (arrElement[i].internalData.timerCount > 0) {
                return 'The page has not finished saving.';
            }

            i += 1;
        }
    });


// ############################################################################
// ############################ UTILITY FUNCTIONS #############################
// ############################################################################

    // we need to be able to execute event attributes (like onafter_select)
    //      while being able to reference the form as "this" in the code.
    function evalInContext(element, strJS) {
        var execFunc = function () {
            return eval(strJS);
        };

        execFunc.call(element);
    }

    // we want to standardize event triggering in this element.
    function triggerEvent(element, strEvent, jsnData) {
        var eventObject;

        eventObject = GS.triggerEvent(element, strEvent, jsnData);
        GS.triggerEvent(element, 'on' + strEvent, jsnData);
        if (
            element.hasAttribute('on' + strEvent) &&
            // onfocus and onblur attributes are handled automatically by the
            //      browser
            strEvent !== 'focus' &&
            strEvent !== 'blur'
        ) {
            evalInContext(element, element.getAttribute('on' + strEvent));
        }

        // if the user prevents the default on the "before_update"
        //      event, prevent the execution of the following update code
        if (eventObject.defaultPrevented) {
            return false;
        }

        return true;
    }

    // the user needs to be able to set a custom websocket for this element,
    //      so this function will use an attribute to find out what socket to
    //      use (and it'll default to "GS.envSocket")
    function getSocket(element) {
        if (element.getAttribute('socket')) {
            return GS[element.getAttribute('socket')];
        }
        return GS.envSocket;
    }

    // we don't want to listen to column elements that are inside other elements
    //      so, this function allows us to exclude such elements in the change
    //      events
    function columnParentsUntilForm(form, element) {
        var intColumnParents = 0;
        var currentElement = element;
        var maxLoops = 50;
        var i = 0;

        while (
            currentElement.parentNode !== form &&
            currentElement.parentNode &&
            i < maxLoops
        ) {
            if (
                //If something with a column attribute
                currentElement.parentNode.hasAttribute('column') === true ||
                //or something with a src attribute
                currentElement.parentNode.hasAttribute('src') === true
            ) {
                intColumnParents += 1;
            }

            currentElement = currentElement.parentNode;
            i += 1;
        }

        return intColumnParents;
    }

    // we want to be able to easily access a record
    function recordToJSON(element, strRecord) {
        var col_i;
        var col_len;
        var decodeTab = GS.decodeFromTabDelimited;
        var arrRecord;
        var jsnRecord;
        var strCell;
        var delim;
        var strNull;
        var arrColNames;

        // we need the null-string in order to properly decode WS data
        strNull = element.getAttribute('null-string');

        // save the column name array for quick and easy access
        arrColNames = element.internalData.columnNames;

        // create cell array for this record
        strRecord = strRecord + '\t';
        arrRecord = [];
        col_i = 0;
        col_len = element.internalData.columnNames.length;//9999;
        while (col_i < col_len) {
            delim = strRecord.indexOf('\t');
            strCell = strRecord.substring(0, delim);
            strRecord = strRecord.substring(delim + 1);
            arrRecord.push(decodeTab(strCell, strNull));
            col_i += 1;
        }

        // create record JSON from the cell array
        col_i = 0;
        col_len = arrRecord.length;
        jsnRecord = {};
        while (col_i < col_len) {
            jsnRecord[arrColNames[col_i]] = arrRecord[col_i];
            col_i += 1;
        }

        return jsnRecord;
    }

    // we need to split object names into schema and object
    function splitObjectName(strObject) {
        var arrParts;

        // split "src" into "schema" and "object" attributes
        arrParts = strObject.split('.');

        // I don't know who added this. I don't inderstand why someone
        //      would put something like "biz.bar.foo" in the "src"
        //      attribute. That's the case that this code handles. If
        //      you added this code: PUT A COMMENT!!!! We have comments
        //      for a reason. Don't ruin this beautiful code. Only YOU
        //      can prevent spaghetti code.
        //  ~Michael
        // It appears to be a solution to quote idented object names
        //      that contain a period like this: test."test.asdf"
        //      The problem with this (other than being unclear) is that
        //      it wont work for schema names that contain a period.
        //      We need a better solution for this. Perhaps it's time to
        //      create a function that understands ident quoted names
        //      for real, using actual parsing.
        //  ~Also Michael
        if (arrParts[2]) {
            arrParts[1] = arrParts[1] + '.' + arrParts[2];
        }

        return {
            "schema": arrParts[0],
            "object": arrParts[1]
        };
    }

    function convertWSFormattoAjax(element) {
        var arrTotalRecords;
        var arrRecords;
        var i;
        var len;
        var arrCells;
        var cell_i;
        var cell_len;

        // convert data into something we can use
        arrTotalRecords = [];
        arrRecords = element.internalData.records;
        i = 0;
        len = arrRecords.length;
        while (i < len) {
            arrCells = arrRecords[i].split('\t');

            cell_i = 0;
            cell_len = arrCells.length;
            while (cell_i < cell_len) {
                arrCells[cell_i] = (
                    arrCells[cell_i] === '\\N'
                        ? null
                        : GS.decodeFromTabDelimited(arrCells[cell_i])
                );
                cell_i += 1;
            }

            arrTotalRecords.push(arrCells);
            i += 1;
        }

        return {
            "arr_column": element.internalData.columnNames,
            "dat": arrTotalRecords,
            "row_count": arrTotalRecords.length
        };
    }

    function refocusElement(row, strFocusColumn, jsnSelection) {
        var parentColumn;
        var refocusFunction;
        var timer_i;
        var focusTimerID;

        parentColumn = qryAll(row, '[column="' + strFocusColumn + '"]')[0];

        refocusFunction = function () {
            parentColumn.focus();
            if (
                parentColumn &&
                jsnSelection &&
                (
                    document.activeElement.nodeName === 'INPUT' ||
                    document.activeElement.nodeName === 'TEXTAREA'
                )
            ) {
                GS.setInputSelection(
                    document.activeElement,
                    jsnSelection.start,
                    jsnSelection.end
                );
            }
        };

        if (parentColumn) {
            // if element registration is not shimmed, we can just focus into
            //      the target element
            if (shimmed.customElements === false) {
                refocusFunction();

            // else, we have to check on a loop to see if the element has been
            //      upgraded, the reason I need to use a loop here is because
            //      there is no event for when an element is upgraded (if there
            //      was then 1000 custom elements would emit 1000 events, which
            //      is a lot and we don't want to bog the browser down)
            } else {
                timer_i = 0;
                focusTimerID = setInterval(function () {
                    if (parentColumn['__upgraded__'] || timer_i >= 10) {
                        clearTimeout(focusTimerID);
                    }
                    if (parentColumn['__upgraded__']) {
                        refocusFunction();
                    }
                    timer_i += 1;
                }, 5);
            }
        }
    }


// #############################################################################
// ############################# ELEMENT FUNCTIONS #############################
// #############################################################################

    // some attributes can't be used in their normal, dev-friendly format,
    //      this function translates those attributes to their final formats
    // some attributes need to be defaulted, even if they're not present
    function resolveElementAttributes(element) {
        var strSrc;
        var jsnParts;

        // GS-COMBO elements that are connected to Envelope need to have "pk"
        //      attribute
        if (element.getAttribute('src')) {
            strSrc = GS.templateWithQuerystring(element.getAttribute('src'));

            // if arbituary query
            if (strSrc.replace(/\s*/gi, '').indexOf('(') === 0) {//SELECT
                // save query as is
                element.setAttribute('select-query', strSrc);

            // else, it's just a table/view name
            } else {
                // split "src" into "schema" and "object" attributes
                jsnParts = splitObjectName(strSrc);

                // put the split sections of the object name into separate
                //      attributes
                element.setAttribute('select-schema', jsnParts.schema);
                element.setAttribute('select-object', jsnParts.object);

                element.setAttribute('update-schema', jsnParts.schema);
                element.setAttribute('update-object', jsnParts.object);
            }

            // "update-src" should always be a table or a view
            if (element.getAttribute('update-src')) {
                // split into "schema" and "object" attributes
                jsnParts = splitObjectName(element.getAttribute('update-src'));

                element.setAttribute('update-schema', jsnParts.schema);
                element.setAttribute('update-object', jsnParts.object);
            }

            // default insert, update, and delete
            if (jsnParts) {
                if (!element.hasAttribute('update-schema')) {
                    element.setAttribute('update-schema', jsnParts.schema);
                    element.setAttribute('update-object', jsnParts.object);
                }
            }

            // if we're missing update details, warn the developer
            if (
                !element.hasAttribute('update-schema') ||
                !element.hasAttribute('update-object')
            ) {
                console.warn(
                    'GS-FORM Warning: Cannot figure out what object to ' +
                    'update, please add an "update-src" attribute with the' +
                    ' view that needs to receive the update commands.'
                );
            }
        }

        // default null string attribute
        element.setAttribute(
            'null-string',
            (element.getAttribute('null-string') || '')
        );

        // default "pk" and "lock" attributes
        element.setAttribute(
            'pk',
            (element.getAttribute('pk') || 'id')
        );
        element.setAttribute(
            'lock',
            (element.getAttribute('lock') || 'change_stamp')
        );
    }

    // create internal structures and inner elements that persist through the
    //      whole lifetime of the element
    function prepareElement(element) {
        // we want a place to store elements
        element.elems = {};

        // we want a place to look to for data
        element.internalData = {
            "records": [],
            "columnNames": [],
            "columnTypes": [],
            "clearCache": false,
            "timer": {},
            "timerCount": 0,
            "saveState": "saved",
            "updateQueue": []
        };

        // we need a place to store event functions because, to unbind a
        //      specific event javascript requires that you have the
        //      original function that was bound to that event
        element.internalEvents = {};

        // Some events need persistent storage of a related variable. This
        //      bucket will hold that info.
        element.internalEventData = {
            "defaultAttributes": {}
        };

        // we need a place to store our templates, so we'll create an
        //      element.internalTemplates JSON object and store each
        //      template under a unique name
        element.internalTemplates = {
            "row": "",
            "rowIsSimple": false
        };

        // we need a place to store cell dimensions and other display
        //      related info
        // anything in here set to "undefined" is set that way because the dev
        //      may set it to 0 or [] and we need to be able to tell that it
        //      hasn't been set yet
        element.internalDisplay = {};

        // we need a place to store selection information
        element.internalSelection = {};

        // There are no persistent elements
    }

    // get attributes and templates and extract all necessary information
    function siphonElement(element) {
        var rowTemplate;
        var i;
        var len;
        var jsnAttr;

        // get each template element and save them to each their own variable,
        //      for easy access
        rowTemplate = qryKids(element, 'template')[0];

        // remove all templates from the dom to prevent reflows
        if (rowTemplate) {
            element.removeChild(rowTemplate);
        }

        // check for greater-than and less-than operators that will mess with
        //      the templating.
        if (
            rowTemplate &&
            (
                rowTemplate.innerHTML.indexOf('&gt;') > -1 ||
                rowTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn(
                'GS-FORM WARNING: &gt; or &lt; detected in ' +
                'row template, this can have undesired ' +
                'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                'lt(x,y), or lte(x,y) to silence this warning.'
            );
        }

        // we want to use the least invasive templating possible, because its
        //      easier to maintain browser-maintained states (like focus, text
        //      selection, event paths) if we don't replace the html every
        //      update. So, if this is a "simple" template, meaning that it
        //      only uses "column" attributes to fill controls, mark it as
        //      "simple" so that we know to use the renderPartial function
        //      instead of the renderSingleRow function after an update.
        if (
            rowTemplate &&
            // no special Dot.js notation in template
            (
                rowTemplate.innerHTML.indexOf('{{') === -1 ||
                element.getAttribute('force-simple-template') === 'true'
            )
        ) {
            element.internalTemplates.rowIsSimple = true;
        }

        // pull in record template (for backwards compatibility, we need to be
        //      able to accept a template without a "for" attribute as the
        //      record template. Additionally, we need to be able to take a
        //      TABLE element here and convert it to gs-cell. Unless it's a
        //      static combobox. In which case, we convert it to static data
        //      and gs-cells.
        if (rowTemplate) {
            // add a doT.js coded "value" attribute to any element with a
            //      "column" attribute but no "value" attribute
            element.internalTemplates.row = GS.templateColumnToValue(
                rowTemplate.innerHTML
            );
        }

        // if we haven't found a template and there is no datasource to create
        //      a template from, error
        if (!element.internalTemplates.row && !element.hasAttribute('src')) {
            throw 'GS-FORM Error: No template provided.';
        }

        // we need to store the defaults of the attributes in case of QS
        //      binding. Because we'll need to retemplate the initial attribute
        //      setting every time.
        i = 0;
        len = element.attributes.length;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internalEventData.defaultAttributes[jsnAttr.nodeName] = (
                jsnAttr.value ||
                ''
            );
            i += 1;
        }
    }

// #############################################################################
// ############################# RENDER FUNCTIONS ##############################
// #############################################################################

    // builds entire html of records from scratch
    function renderFull(element) {
        var jsnTemplate;
        var strTemplate;
        var strRet;
        var strStyle = '';
        var internalData;
        var strColPK;
        var strColLock;
        var data;

        var target;
        var parentForm;
        var parentRecord;
        var parentColumn;
        var intRowNumber;
        var strFocusColumn;
        var jsnSelection;

        // get column to focus back into
        target = document.activeElement;
        parentForm = GS.findParentTag(target, 'gs-form');
        parentRecord = GS.findParentElement(target, '.form-record');
        parentColumn = GS.findParentElement(target, '[column]');

        if (
            parentForm === element &&
            parentColumn
        ) {
            strFocusColumn = parentColumn.getAttribute('column');
            jsnSelection = GS.getInputSelection(target);
            intRowNumber = parentRecord.getAttribute('data-row');
        }

        // shortcut variables
        strTemplate = element.internalTemplates.row;
        internalData = element.internalData;

        // column attributes
        strColPK = element.getAttribute('pk');
        strColLock = element.getAttribute('lock');

        // if single record, take the full height of the form element
        if (internalData.records.length === 1) {
            strStyle = 'style="height: 100%;" ';
        }

        // convert data into something we can use
        data = convertWSFormattoAjax(element);

        // we don't want to template templates for inner elements (like
        //      comboboxes), so we hide the templates from Dot.
        jsnTemplate = GS.templateHideSubTemplates(strTemplate);

        // template
        strRet = GS.templateWithEnvelopeData(
            (
                '<div ' +
                    'class="form-record" ' +
                    strStyle +
                    'data-row="{{! i }}" ' +
                    'data-pk="{{! row.' + strColPK + ' }}" ' +
                  //'data-' + strColLock + '="{{! row.' + strColLock + ' }}" ' +
                    'gs-dynamic ' +
                '>' +
                    jsnTemplate.templateHTML +
                '</div>'
            ),
            data
        );

        // show the templates we hid earlier, and put HTML into the form
        element.innerHTML = GS.templateShowSubTemplates(strRet, jsnTemplate);

        // restore focus and text selection if possible
        if (strFocusColumn) {
            parentRecord = qryKids(
                element,
                '.form-record[data-row="' + intRowNumber + '"]'
            )[0];

            if (parentRecord) {
                refocusElement(parentRecord, strFocusColumn, jsnSelection);
            }
        }
    }

    // replaces html of a single record, used if we can't resolve the changes
    //      reliably (used after updates with non-simple templates)
    function renderSingleRow(element, intRow) {
        var row;
        //var strLockColumn;
        //var strLockValue;
        var data;
        var jsnTemplate;
        var strHTML;

        var strFocusColumn;
        var jsnSelection;
        var target;
        var parentForm;
        var parentRecord;
        var parentColumn;

        // get new lock value
        //strLockColumn = element.getAttribute('lock');
        //strLockValue = element.column(strLockColumn, intRow);

        // get the row we are going to rerender
        row = qryKids(element, '.form-record[data-row="' + intRow + '"]')[0];

        // get column to focus back into
        target = document.activeElement;
        parentForm = GS.findParentTag(target, 'gs-form');
        parentRecord = GS.findParentElement(target, '.form-record');
        parentColumn = GS.findParentElement(target, '[column]');

        if (
            parentForm === element &&
            parentRecord === row &&
            parentColumn
        ) {
            strFocusColumn = parentColumn.getAttribute('column');
            jsnSelection = GS.getInputSelection(target);
        }

        // update lock column
        //row.setAttribute('data-' + strLockColumn, strLockValue);

        // convert data into something we can use
        data = convertWSFormattoAjax(element);

        // we don't want to template templates for inner elements (like
        //      comboboxes), so we hide the templates from Dot.
        jsnTemplate = GS.templateHideSubTemplates(
            element.internalTemplates.row
        );

        // template row contents
        strHTML = GS.templateWithEnvelopeData(
            jsnTemplate.templateHTML,
            data,
            intRow
        );

        // set row contents
        row.innerHTML = GS.templateShowSubTemplates(strHTML, jsnTemplate);

        // restore focus and text selection if possible
        if (strFocusColumn) {
            refocusElement(row, strFocusColumn, jsnSelection);
        }
    }

    // replace values in controls that have been updated (for simple templates)
    function renderPartial(element, intRow) {
        var data;
        var arrElement;
        var i;
        var len;
        var strColumn;
        var strControlValue;
        var strDataValue;
        var parentDataElement;

        // convert data into something we can use
        data = convertWSFormattoAjax(element);

        // update all values that have changed
        arrElement = qryKids(
            element,
            '.form-record[data-row="' + intRow + '"] [column]'
        );
        i = 0;
        len = arrElement.length;
        while (i < len) {
            strColumn = arrElement[i].getAttribute('column');
            parentDataElement = GS.findParentElement(arrElement[i], '[src]');
            if (parentDataElement === element) {
                strControlValue = arrElement[i].value;
                strDataValue = GS.envGetCell(data, intRow, strColumn);

                if (strControlValue === null || strControlValue === undefined) {
                    strControlValue = '';
                }
                if (strDataValue === null || strDataValue === undefined) {
                    strDataValue = '';
                }

                if (
                    // if the value is different and
                    strControlValue !== strDataValue &&
                    // if the control is not focussed and
                    arrElement[i] !== document.activeElement &&
                    arrElement[i].control !== document.activeElement &&
                    // if there are no saves pending
                    element.internalData.timerCount === 0 &&
                    element.internalData.updateQueue.length === 0 &&
                    element.internalData.saveState !== 'saving'
                ) {
                    //if (arrElement[i].nodeName !== 'GS-ACE') {
                    arrElement[i].value = strDataValue;
                    //} else {
                        console.log('#############################################');
                        console.log('WOULDVE CAUSED FULL TEXT ERROR');
                        console.log(JSON.stringify(element.internalData, null, 4));
                        console.log(JSON.stringify(element.internalDisplay, null, 4));
                        console.log('#############################################');
                    //}
                }
            }

            i += 1;
        }
    }


// ############################################################################
// ############################## DATA FUNCTIONS ##############################
// ############################################################################

    function dataSELECTcallback(element) {
        var templateElement;

        element.internalData.loaded = true;

        if (
            element.internalData.records.length === 0 &&
            !element.hasAttribute('limit') &&
            !element.hasAttribute('suppress-no-record-found')
        ) {
            templateElement = document.createElement('template');
            templateElement.innerHTML = ml(function () {/*
                <gs-page>
                    <gs-header><center><h3>Error</h3></center></gs-header>
                    <gs-body padded>
                        <center>No record found</center>
                    </gs-body>
                    <gs-footer>
                        <gs-grid>
                            <gs-block>
                                <gs-button dialogclose>Cancel</gs-button>
                            </gs-block>
                            <gs-block>
                                <gs-button dialogclose listen-for-return
                                    bg-primary
                                >
                                    Try Again
                                </gs-button>
                            </gs-block>
                        </gs-grid>
                    </gs-footer>
                </gs-page>*/
            });

            GS.openDialog(templateElement, '', function (ignore, strAnswer) {
                if (strAnswer === 'Try Again') {
                    element.refresh();
                }
            });
        }

        renderFull(element);

        triggerEvent(element, 'after_select');
    }

    function dataUPDATEcallback(element, strMode, jsnUpdate) {
        if (element.hasAttribute('save-while-typing')) {
            renderPartial(element, jsnUpdate.data.recordNumber);
        } else if (strMode === 'single-cell') {
            // if the template is simple, we can just manually update the
            //      controls that don't match
            if (element.internalTemplates.rowIsSimple) {
                renderPartial(element, jsnUpdate.data.recordNumber);
            } else {
                renderSingleRow(element, jsnUpdate.data.recordNumber);
            }
        } else {
            renderFull(element);
        }

        // if there are updates queued, run the next one
        if (element.internalData.updateQueue.length > 0) {
            dataUPDATE(
                element,
                element.internalData.updateQueue[0].mode,
                element.internalData.updateQueue[0].update
            );

            element.internalData.updateQueue.shift();
        }
    }


    function databaseWSUPDATE(element, strMode, jsnUpdate) {
        var i;
        var len;
        var col_i;
        var col_len;

        var updateStep;
        var jsnCurrentData;

        var strSchema;
        var strObject;
        var strReturn;
        var strHashColumns;
        var strUpdateData;

        var intUpdateColumnIndex;
        var arrPK;
        var arrLock;
        var startingIndex;
        var arrRecordIndexes;

        var strRow;
        var jsnRow;
        var cell_i;
        var cell;
        var char;

        var strRoles;
        var strColumns;
        var arrColumnNames;
        var strHashString;
        var strTemp;
        var clearWarningFunction;

        // get schema and object attributes and get the return column list
        strSchema = GS.templateWithQuerystring(
            element.getAttribute('update-schema') || ''
        );
        strObject = GS.templateWithQuerystring(
            element.getAttribute('update-object') || ''
        );

        // the return column list must be defined the same as the column list
        //      that we store the data with, so we define strReturn using the
        //      column list
        strReturn = '';
        col_i = 0;
        col_len = element.internalData.columnNames.length;
        while (col_i < col_len) {
            strReturn += (
                strReturn
                    ? '\t'
                    : ''
            );
            strReturn += (
                element.internalData.columnNames[col_i].replace(/(\\)/g, '\\\\')
            );
            col_i += 1;
        }

        // save the column name array for speed and easy access
        arrColumnNames = element.internalData.columnNames;

        // if single cell update: we only need to gather the update info for
        //      one record
        if (strMode === 'single-cell') {
            jsnCurrentData = {
                "columnName": (
                    jsnUpdate.data.columnName.replace(/(\\)/g, '\\\\')
                ),
                "recordNumber": jsnUpdate.data.recordNumber,
                "oldValue": ""
            };
            strHashColumns = '';
            strUpdateData = '';
            startingIndex = '';

            // turn the updated column name into a column index so that we can
            //      fetch the old data from the data
            intUpdateColumnIndex = (
                element
                    .internalData
                    .columnNames
                    .indexOf(jsnUpdate.data.columnName)
            );

            // get the index of the record that will be updated
            startingIndex = jsnUpdate.data.recordNumber;

            // if you refresh between the update start and end, you might have
            //      an error here ##################

            // get the cell's old value so that when we emit before_update
            //      and after_update events we can provide the old data
            jsnCurrentData.oldValue = GS.decodeFromTabDelimited(
                (element.internalData
                    .records[startingIndex]
                    .split('\t')[intUpdateColumnIndex] || '')
            );

            // get primary key and lock column names into arrays so that we can
            //      use them for getting the PK and LOCK data and so that we
            //      can tell the websocket the names of the PK and LOCK columns
            if (element.getAttribute('pk')) {
                arrPK = (
                    GS.templateWithQuerystring(
                        element.getAttribute('pk') || ''
                    )
                ).split(/[\s]*,[\s]*/);
            } else {
                arrPK = [];
            }
            if (element.getAttribute('lock')) {
                arrLock = (
                    GS.templateWithQuerystring(
                        element.getAttribute('lock') || ''
                    )
                ).split(/[\s]*,[\s]*/);
            } else {
                arrLock = [];
            }

            // define "strHashColumns", "strRoles" and strColumns as empty so
            //      that we can append to them without worrying about an
            //      "undefined" appearing
            strHashColumns = '';
            strHashString = '';
            strRoles = '';
            strColumns = '';
            strUpdateData = '';

            // create record json so that we can easily get column values
            //      we need
            strRow = element.internalData.records[startingIndex];
            jsnRow = {};

            i = 0;
            len = strRow.length;
            cell_i = 0;
            cell = "";
            while (i < len) {
                char = strRow[i];

                if (char === "\t") {
                    jsnRow[arrColumnNames[cell_i]] =
                            GS.decodeFromTabDelimited(cell, '\\N');

                    cell = "";
                    cell_i += 1;
                } else {
                    cell += char;
                }
                i += 1;
            }
            jsnRow[arrColumnNames[cell_i]] =
                    GS.decodeFromTabDelimited(cell, '\\N');

            // build up column name/role list for websocket update headers
            //      using the PK columns and append pk values
            i = 0;
            len = arrPK.length;
            while (i < len) {
                strRoles += (
                    strRoles
                        ? '\t'
                        : ''
                );
                strRoles += 'pk';
                strColumns += (
                    strColumns
                        ? '\t'
                        : ''
                );
                strColumns += arrPK[i];
                strUpdateData += (
                    strUpdateData
                        ? '\t'
                        : ''
                );
                strUpdateData += jsnRow[arrPK[i]];
                i += 1;
            }

            // build up hash column name list for websocket update headers
            //      using the LOCK columns
            i = 0;
            len = arrLock.length;
            while (i < len) {
                strHashColumns += (
                    strHashColumns
                        ? '\t'
                        : ''
                );
                strHashColumns += arrLock[i];

                strHashString += (
                    strHashString
                        ? '\t'
                        : ''
                );
                strTemp = jsnRow[arrLock[i]];

                // the C encodes null values as empty string in the hash portion
                strHashString += (
                    strTemp === '\\N'
                        ? ''
                        : GS.encodeForTabDelimited(strTemp, '\\N')
                );
                i += 1;
            }

            if (strHashString) {
                strRoles += (
                    strRoles
                        ? '\t'
                        : ''
                );
                strRoles += 'hash';

                strColumns += (
                    strColumns
                        ? '\t'
                        : ''
                );
                strColumns += 'hash';

                strUpdateData += (
                    strUpdateData
                        ? '\t'
                        : ''
                );
                strUpdateData += GS.utfSafeMD5(strHashString).toString();
            }

            // build up column name/role list for websocket update headers
            //      using the update column
            strRoles += (
                strRoles
                    ? '\t'
                    : ''
            );
            strRoles += 'set';
            strColumns += (
                strColumns
                    ? '\t'
                    : ''
            );
            strColumns += jsnUpdate.data.columnName.replace(/(\\)/g, '\\\\');

            // append new value
            strUpdateData += (
                strUpdateData
                    ? '\t'
                    : ''
            );
            strUpdateData += GS.encodeForTabDelimited(jsnUpdate.data.newValue);

            // append an extra return to the end so just in case the C needs it
            strUpdateData += '\n';

            // prepend columns and roles
            strUpdateData = (
                strRoles + '\n' +
                strColumns + '\n' +
                strUpdateData
            );

            // add record index to the array
            arrRecordIndexes = [jsnUpdate.data.recordNumber];

        // else: invalid update type: throw an error
        } else {
            throw 'GS-FORM Error: Invalid update type. Update type "' +
                    strMode + '" is not valid, please use "single-cell" ' +
                    'or "cell-range".';
        }

        // if the user prevents the default on the "before_update"
        //      event, prevent the execution of the following update code
        if (
            !triggerEvent(
                element,
                'before_update',
                {
                    "schema": strSchema,
                    "object": strObject,
                    "updateMode": strMode,
                    "oldData": jsnCurrentData,
                    "newData": jsnUpdate.data
                }
            )
        ) {
            return;
        }

        // the update step is defined as a sub function because if there
        //      are multiple cells involved in this update, we want to open
        //      a dialog before we continue, else we want to immediatly
        //      update
        updateStep = function () {
            var updatedRecords;

            // define "updatedRecords" as empty so that we can append to it
            //      without worrying about an "undefined" at the beginning of
            //      the string
            updatedRecords = '';

            //// gotta let the user know that an update is in progress
            //addLoader(element, 'data-update', 'Updating Data...');

            element.internalData.saveState = 'saving';
            console.log('UPDATE CODE: saving');
            if (element.saveTimeout) {
                clearTimeout(element.saveTimeout);
            }

            // wait five seconds to warn the user if the update is taking too
            //      long.
            element.saveTimeout = setTimeout(
                function () {
                    var arrParentElement;
                    var parentElement;
                    var warningElement;

                    // we need to know if we've already opened a warning like
                    //      this. So, we'll select for warnings that already
                    //      exist.
                    arrParentElement = qryKids(
                        element,
                        '.saving-warning-parent'
                    );

                    if (
                        // if we haven't saved and
                        element.internalData.saveState !== 'saved' &&
                        // there isn't already a warning
                        arrParentElement.length === 0
                    ) {
                        element.internalData.saveState = 'error';

                        parentElement = document.createElement('center');
                        parentElement.setAttribute(
                            'class',
                            'saving-warning-parent'
                        );

                        warningElement = document.createElement('div');
                        warningElement.setAttribute(
                            'class',
                            'saving-warning'
                        );

                        warningElement.innerHTML = (
                            'YOUR CHANGES ARE NOT SAVED<br />' +
                            'WE HAVEN\'T HEARD BACK FROM THE SERVER<br />' +
                            'EITHER THE SAVING IS SLOW OR THERE\'S AN ERROR'
                        );

                        parentElement.appendChild(warningElement);
                        element.insertBefore(
                            parentElement,
                            element.children[0]
                        );
                    }
                },
                //10         // Uncomment to test
                (5 * 1000) // Uncomment for live
            );

            clearWarningFunction = function () {
                var arrErrorElement;

                // gather warning elements
                arrErrorElement = qryKids(
                    element,
                    '.saving-warning-parent'
                );

                // if there is a warning element, remove it
                if (arrErrorElement.length > 0) {
                    element.removeChild(arrErrorElement[0]);
                }
            };

            console.log('UPDATE CODE: START');
            // begin the websocket update
            GS.requestUpdateFromSocket(
                getSocket(element),
                strSchema,
                strObject,
                strReturn,
                strHashColumns,
                strUpdateData,
                // transaction start callback
                function (data, error) { //transID

                    // if the table element has been destroyed, stop execution
                    if (!element.internalData.columnNames) {
                        if (element.saveTimeout) {
                            clearTimeout(element.saveTimeout);
                        }
                        return;
                    }

                    // update failed: remove loader, popup an error
                    //      and reverse changes
                    if (error) {
                        if (element.saveTimeout) {
                            clearTimeout(element.saveTimeout);
                        }
                        element.internalData.saveState = 'error';

                        clearWarningFunction();
                        //removeLoader(element, 'data-update', 'Change Failed');
                        GS.webSocketErrorDialog(data);

                        // request fresh data
                        //getData(element);
                    }
                },
                // transaction ready for commit/rollback callback
                // "ignore" is a placeholder for "transID" and it tells JSLINT
                //      that it is an unused variable
                function (data, error, ignore, commit, rollback) {
                    if (!error) {
                        // update made it through: commit the update
                        if (data === 'TRANSACTION COMPLETED') {
                            if (element.saveTimeout) {
                                clearTimeout(element.saveTimeout);
                            }
                            console.log('UPDATE CODE: saved');

                            clearWarningFunction();
                            commit();

                        // else: we've just received a data packet containing
                        //      the updated records current version
                        } else {
                            // save this data so that we can use it to update
                            //      the internal data if the update makes it
                            //      through
                            //  ,----- data already comes back with an extra \n
                            // v
                            //updatedRecords += (updatedRecords ? '\n' : '');
                            updatedRecords += data;
                        }

                    // update failed: popup an error, rollback and
                    //      reverse change
                    } else {
                        if (element.saveTimeout) {
                            clearTimeout(element.saveTimeout);
                        }
                        element.internalData.saveState = 'error';

                        data.error_text = (
                            '\n\n' +
                            'Your unsaved value(s): ' +
                            strUpdateData.substring(
                                strUpdateData.indexOf('\n'),
                                strUpdateData.length
                            ) +
                            '\n\n' +
                            data.error_text
                        );

                        clearWarningFunction();
                        GS.webSocketErrorDialog(data);
                        rollback();
                        dataSELECT(element);
                    }
                },
                // transaction commit/rollback finished callback
                function (strAnswer, data, error) {
                    var arrRecords;

                    // if the table element has been destroyed, stop execution
                    if (!element.internalData.columnNames) {
                        if (element.saveTimeout) {
                            clearTimeout(element.saveTimeout);
                        }
                        return;
                    }

                    //// the over-the-network part of the update has finished,
                    ////      remove the loader now so that if there is an
                    ////      execution error below, the loader wont be stuck
                    ////      visible
                    //removeLoader(
                    //    element,
                    //    'data-update',
                    //    (
                    //        error
                    //            ? 'Change Failed'
                    //            : 'Change Saved'
                    //    )
                    //);

                    if (!error) {
                        // update was successfully commited: update internal
                        //      data and re-render
                        if (strAnswer === 'COMMIT') {
                            if (element.saveTimeout) {
                                clearTimeout(element.saveTimeout);
                            }
                            element.internalData.saveState = 'saved';

                            clearWarningFunction();

                            // refresh internal data by replace each internal
                            //      record that was affected with it's new
                            //      version
                            arrRecords = updatedRecords.split('\n');
                            i = 0;
                            len = arrRecords.length - 1; // the - 1 is because
                                                         //   of the extra \n at
                                                         //   the end of the
                                                         //   returned records
                            while (i < len) {
                                element.internalData
                                    .records[arrRecordIndexes[i]] = (
                                        arrRecords[i]
                                    );
                                i += 1;
                            }

                            dataUPDATEcallback(element, strMode, jsnUpdate);

                            // trigger an after update event
                            triggerEvent(element, 'after_update', {
                                "updateMode": strMode,
                                "oldData": jsnCurrentData,
                                "newData": jsnUpdate.data
                            });

                            // backwards compatibility
                            triggerEvent(element, 'afterupdate', {
                                "updateMode": strMode,
                                "oldData": jsnCurrentData,
                                "newData": jsnUpdate.data
                            });

                        // transaction was rolled back: reverse change
                        } else {
                            //getData(element);
                        }
                    // update failed: popup an error and reverse change
                    } else {
                        if (element.saveTimeout) {
                            clearTimeout(element.saveTimeout);
                        }
                        element.internalData.saveState = 'error';

                        clearWarningFunction();
                        GS.webSocketErrorDialog(data);
                    }
                }
            );
        };

        // begin the update
        updateStep();
    }

    function databaseWSSELECT(element) {
        var templateQS = GS.templateWithQuerystring;
        var arrRecords;
        var arrCols;
        var strCols;
        var arrColNames;
        var saveColumns;

        // we need to get the column names and types
        saveColumns = function (data) {
            var i;
            var len;
            var strCol;
            var strType;

            element.internalData.columnNames = [];
            element.internalData.columnTypes = [];
            arrColNames = data.arrDecodedColumnNames;

            i = 0;
            len = arrColNames.length;
            while (i < len) {
                strCol = arrColNames[i];
                strType = data.arrDecodedColumnTypes[i];

                element.internalData.columnNames.push(strCol);
                element.internalData.columnTypes.push(strType);
                i += 1;
            }
        };

        // limit column list
        if (element.getAttribute('cols')) {
            arrCols = templateQS(element.getAttribute('cols') || '').trim();
            arrCols = arrCols.split(/[\s]*,[\s]*/);
            strCols = arrCols.join('\t');
        } else {
            strCols = '*';
        }

        // we need to make sure that no old data persists across select calls,
        //      so we'll clear out the internal data object
        element.internalData.records = [];

        // storing references to the arrays for faster access
        arrRecords = element.internalData.records;

        var returnCallback = function (data, error) {
            var i;
            var strRecord;
            var strMessage;
            var index;

            // sometimes, elements get removed during the wait for a
            //      callback
            if (!element.internalData.columnNames) {
                return false;
            }

            if (!error) {
                // we need to get the column names and types
                if (data.intCallback === 0) {
                    saveColumns(data);
                }

                // if we see the last message of the select: render
                if (data.strMessage === 'TRANSACTION COMPLETED') {
                    element.classList.remove('error');
                    dataSELECTcallback(element);

                // we need to capture the records and columns and store
                //      them in the internal data
                } else {
                    // we need to parse the TSV into records and push them
                    //      to the internalData "records" array
                    // with Envelope Websocket data all we have to is split
                    //      on \n. Also, it always ends in \n so the loop
                    //      doesn't need to do anything special to get the
                    //      last record
                    strMessage = data.strMessage;
                    strRecord = '';

                    i = 0;
                    while (i < 15) {
                        index = strMessage.indexOf('\n');
                        strRecord = strMessage.substring(0, index);
                        strMessage = strMessage.substring(index + 1);

                        if (strRecord !== '' || strMessage !== '') {
                            arrRecords.push(strRecord);
                        } else {
                            break;
                        }
                        i += 1;
                    }
                }

            // we need to make sure that the user knows that the select
            //      failed and we need to prevent using any old select
            //      info, so we'll re-render, remove the loader and pop
            //      up an error
            } else {
                dataSELECTcallback(element);
                //GS.webSocketErrorDialog(data);
                element.internalData.errorData = data;
                element.classList.add('error');
            }
        };



        var socket = getSocket(element);
        var strSchema = templateQS(element.getAttribute('select-schema') || '');
        var strObject = templateQS(element.getAttribute('select-object') || '');
        var strReturn = strCols;
        var strWhere = templateQS(element.getAttribute('where') || '');
        var strOrd = templateQS(element.getAttribute('ord') || '');
        var strLimit = templateQS(element.getAttribute('limit') || '1');
        var strOffset = templateQS(element.getAttribute('offset') || '0');
        var strQuery = GS.templateWithQuerystring(
            element.getAttribute('select-query') || ''
        );

        // we need the user to know that the envelope is re-fetching data,
        //      so we'll put a loader on
        if (strQuery) {
            GS.requestArbitrarySelectFromSocket(
                socket,
                strQuery,
                strWhere,
                strOrd,
                strLimit,
                strOffset,
                returnCallback
            );
        } else {
            GS.requestSelectFromSocket(
                socket,
                strSchema,
                strObject,
                strReturn,
                strWhere,
                strOrd,
                strLimit,
                strOffset,
                returnCallback
            );
        }

        element.internalData.clearCache = false;
    }


    function dataSELECT(element) {
        triggerEvent(element, 'before_select');

        databaseWSSELECT(element);
    }

    function dataUPDATE(element, strMode, jsnUpdate) {
        triggerEvent(element, 'before_update');

        if (element.internalData.saveState === 'saving') {
            element.internalData.updateQueue.push({
                "mode": strMode,
                "update": jsnUpdate
            });
        } else {
            databaseWSUPDATE(element, strMode, jsnUpdate);
        }
    }


// #############################################################################
// ############################## EVENT FUNCTIONS ##############################
// #############################################################################

    // ############# QS EVENTS #############
    function unbindQuerystringEvents(element) {
        window.removeEventListener('pushstate', element.internalEvents.qsR);
        window.removeEventListener('replacestate', element.internalEvents.qsR);
        window.removeEventListener('popstate', element.internalEvents.qsR);
    }
    function bindQuerystringEvents(element) {
        //element.internalEvents.queryStringResolve
        element.internalEvents.qsR = function () {
            var i;
            var len;
            var strQS = GS.getQueryString();
            var strQSCol = element.getAttribute('qs');
            var strQSValue;
            var strQSAttr;
            var arrQSParts;
            var arrAttrParts;
            var arrPopKeys;
            var currentValue;
            var bolRefresh;
            var strOperator;
            var jsnDefaultAttr;

            if (strQSCol) {
                jsnDefaultAttr = element.internalEventData.defaultAttributes;

                if (strQSCol.indexOf('=') !== -1) {
                    arrAttrParts = strQSCol.split(',');
                    i = 0;
                    len = arrAttrParts.length;
                    while (i < len) {
                        strQSCol = arrAttrParts[i];

                        if (strQSCol.indexOf('!=') !== -1) {
                            strOperator = '!=';
                            arrQSParts = strQSCol.split('!=');
                        } else {
                            strOperator = '=';
                            arrQSParts = strQSCol.split('=');
                        }

                        strQSCol = arrQSParts[0];
                        strQSAttr = arrQSParts[1] || arrQSParts[0];

                        // if the key is not present or we've got the negator:
                        //      go to the attribute's default or remove it
                        if (strOperator === '!=') {
                            // if the key is not present: add the attribute
                            if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                                element.setAttribute(strQSAttr, '');
                            // else: remove the attribute
                            } else {
                                element.removeAttribute(strQSAttr);
                            }
                        } else {
                            // if the key is not present:
                            //      go to the attribute's default or remove it
                            if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                                if (jsnDefaultAttr[strQSAttr] !== undefined) {
                                    element.setAttribute(
                                        strQSAttr,
                                        (jsnDefaultAttr[strQSAttr] || '')
                                    );
                                } else {
                                    element.removeAttribute(strQSAttr);
                                }
                            // else: set attribute to exact text from QS
                            } else {
                                element.setAttribute(strQSAttr, (
                                    GS.qryGetVal(strQS, strQSCol) ||
                                    jsnDefaultAttr[strQSAttr] ||
                                    ''
                                ));
                            }
                        }
                        i += 1;
                    }
                } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                    strQSValue = GS.qryGetVal(strQS, strQSCol);

                    if (element.internalData.bolQSFirstRun !== true) {
                        if (
                            strQSValue !== '' ||
                            !element.getAttribute('value')
                        ) {
                            element.setAttribute('value', strQSValue);
                        }
                    } else {
                        element.value = strQSValue;
                    }
                }
            }

            // handle
            //      "refresh-on-querystring-values" and
            //      "refresh-on-querystring-change" attributes
            if (element.internalData.bolQSFirstRun === true) {
                if (element.hasAttribute('refresh-on-querystring-values')) {
                    arrPopKeys = (
                        element.getAttribute('refresh-on-querystring-values')
                            .split(/\s*,\s*/gim)
                    );

                    i = 0;
                    len = arrPopKeys.length;
                    while (i < len) {
                        currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);

                        if (element.popValues[arrPopKeys[i]] !== currentValue) {
                            bolRefresh = true;
                        }

                        element.popValues[arrPopKeys[i]] = currentValue;
                        i += 1;
                    }

                } else if (
                    element.hasAttribute('refresh-on-querystring-change')
                ) {
                    bolRefresh = true;
                }

                if (bolRefresh && element.hasAttribute('src')) {
                    element.refresh();

                } else if (bolRefresh && !element.hasAttribute('src')) {
                    console.warn(
                        'gs-form Warning: ' +
                                'element has "refresh-on-querystring-values" ' +
                                'or "refresh-on-querystring-change", but no ' +
                                '"src".',
                        element
                    );
                }
            } else {
                if (element.hasAttribute('refresh-on-querystring-values')) {
                    arrPopKeys = (
                        element.getAttribute('refresh-on-querystring-values')
                            .split(/\s*,\s*/gim)
                    );

                    i = 0;
                    len = arrPopKeys.length;
                    while (i < len) {
                        element.popValues[arrPopKeys[i]] = (
                            GS.qryGetVal(strQS, arrPopKeys[i])
                        );
                        i += 1;
                    }
                }
            }

            element.internalData.bolQSFirstRun = true;
        };

        if (
            element.getAttribute('qs') ||
            element.getAttribute('refresh-on-querystring-values') ||
            element.hasAttribute('refresh-on-querystring-change')
        ) {
            element.popValues = {};
            element.internalEvents.qsR();
            window.addEventListener('pushstate', element.internalEvents.qsR);
            window.addEventListener('replacestate', element.internalEvents.qsR);
            window.addEventListener('popstate', element.internalEvents.qsR);
        }
    }

    // ############# CHANGE EVENTS #############
    function unbindChange(element) {
        // unbind save while typing
        element.removeEventListener('keydown', element.internalEvents.timed);
        element.removeEventListener('keyup', element.internalEvents.timed);
        element.removeEventListener('change', element.internalEvents.timed);

        // unbind regular save if bound
        element.removeEventListener('change', element.internalEvents.change);
    }
    function bindChange(element) {
        element.internalEvents.change = function (event) {
            var target = event.target;
            var columnParent = (
                target.hasAttribute('column')
                    ? target
                    : GS.findParentElement(target, '[column]')
            );
            var strColumn = columnParent.getAttribute('column');
            var newValue;
            var parentForm = GS.findParentTag(columnParent, 'gs-form');
            var parentRecord = GS.findParentElement(columnParent, '.form-record');
            var intRow;

            if (columnParent.value !== null) {
                // changed on 2022-06-11 by Nunzio
                // this is the behaviour of Microsoft Access, and Cross expected it
                newValue = columnParent.value === '' ? '\\N' : columnParent.value;
                // newValue = columnParent.value;
            } else {
                newValue = columnParent.checked;
            }

            if (parentRecord) {
                intRow = parseInt(parentRecord.getAttribute('data-row'), 10);
            }

            if (
                strColumn &&
                columnParentsUntilForm(element, columnParent) === 0 &&
                parentForm === element &&
                element.column(strColumn, intRow) !== newValue
            ) {
                //event.stopPropagation();

                // call the update function
                dataUPDATE(element, 'single-cell', {
                    "data": {
                        "columnName": strColumn,
                        "recordNumber": intRow,
                        "newValue": newValue
                    }
                });
            }
        };

        element.internalEvents.timed = function (event) {
            var target = event.target;
            var columnParent = (
                target.hasAttribute('column')
                    ? target
                    : GS.findParentElement(target, '[column]')
            );
            var strColumn = columnParent.getAttribute('column');
            var parentForm = GS.findParentTag(target, 'gs-form');
            var parentRecord = GS.findParentElement(target, '.form-record');
            var intRow = parseInt(parentRecord.getAttribute('data-row'), 10);
            var newValue = (
                columnParent.value !== null
                    // changed on 2022-06-11 by Nunzio
                    // this is the behaviour of Microsoft Access, and Cross expected it
                    ? (columnParent.value === '' ? '\\N' : columnParent.value)
                    // ? columnParent.value;
                    : columnParent.checked
            );
            
            console.log('triggered:', event.type, event.keyCode);

            if (
                strColumn &&
                columnParentsUntilForm(element, columnParent) === 0 &&
                parentForm === element &&
                // we don't want to send extra updates, but if someone was to
                //      delete and then undelete, we want it to count. So, if
                //      there is an update in the queue, run no matter what. If
                //      this is the only update, only run if it's actually
                //      different
                !(
                    element.internalData.timerCount === 0 &&
                    element.internalData.updateQueue.length === 0 &&
                    element.internalData.saveState !== 'saving' &&
                    element.column(strColumn, intRow) === newValue
                )
            ) {
                // cancel save timer if another update comes in before time runs
                //      out
                if (element.internalData.timer[strColumn]) {
                    clearTimeout(element.internalData.timer[strColumn]);
                    element.internalData.timerCount -= 1;
                    element.internalData.timer[strColumn] = null;
                }

                // if no more updates come in within the time allotted, commit
                element.internalData.timerCount += 1;
                element.internalData.timer[strColumn] = setTimeout(function () {
                    element.internalData.timerCount -= 1;
                    element.internalData.timer[strColumn] = null;
                    dataUPDATE(element, 'single-cell', {
                        "data": {
                            "columnName": strColumn,
                            "recordNumber": intRow,
                            "newValue": newValue
                        }
                    });
                }, 600);// used to be 300, but if you held a key down, then held
                //      a second key down at the same time, it would take enough
                //      time to switch letters to cause a save (but letters
                //      would still be being put in) hence, it would cause a
                //      partial rerender (because the value of the control is
                //      different from the database)
            }
        };

        // bind save code
        if (element.hasAttribute('save-while-typing')) {
            element.addEventListener('keydown', element.internalEvents.timed);
            element.addEventListener('keyup', element.internalEvents.timed);
            element.addEventListener('change', element.internalEvents.timed);
        } else {
            element.addEventListener('change', element.internalEvents.change);
        }
    }

    // ############# KEY EVENTS #############
    function unbindKey(element) {
        element.removeEventListener('keydown', element.internalEvents.keyNav);
    }
    function bindKey(element) {
        element.internalEvents.keyNav = function (event) {
            var target = event.target;
            var keyCode = (event.which || event.keyCode);
            var jsnSelection;
            var focusToElement;
            var i;
            var len;
            var arrElementsFocusable;
            var currentElement;

            if (
                document.activeElement.nodeName === 'INPUT' ||
                document.activeElement.nodeName === 'TEXTAREA'
            ) {
                jsnSelection = GS.getInputSelection(target);
            }

            if (
                // Left arrow
                (
                    keyCode === 37 &&
                    (!jsnSelection || jsnSelection.start === 0)
                ) ||
                // Right arrow
                (
                    keyCode === 39 &&
                    (!jsnSelection || jsnSelection.end === target.value.length)
                )
            ) {
                arrElementsFocusable = xtag.query(
                    document,
                    (
                        'input:not([disabled]), ' +
                        'select:not([disabled]), ' +
                        'memo:not([disabled]), ' +
                        'button:not([disabled]), ' +
                        '[tabindex]:not([disabled]), ' +
                        '[column]'
                    )
                );

                // Left arrow
                if (keyCode === 37) {
                    i = 0;
                    len = arrElementsFocusable.length;
                    while (i < len) {
                        currentElement = arrElementsFocusable[i];

                        if (
                            currentElement === target ||
                            (
                                (
                                    target.nodeName === 'INPUT' ||
                                    target.nodeName === 'TEXTAREA'
                                ) &&
                                currentElement === target.parentNode
                            )
                        ) {
                            if (i === 0) {
                                focusToElement = currentElement;
                            } else {
                                focusToElement = arrElementsFocusable[i - 1];
                            }
                            break;
                        }

                        i += 1;
                    }

                // Right arrow
                } else if (keyCode === 39) {
                    i = 0;
                    len = arrElementsFocusable.length;
                    while (i < len) {
                        currentElement = arrElementsFocusable[i];
                        if (currentElement === target) {
                            if (i === len) {
                                focusToElement = currentElement;
                            } else {
                                focusToElement = arrElementsFocusable[i + 1];
                            }
                            break;
                        }

                        i += 1;
                    }
                }

                if (
                    focusToElement &&
                    GS.isElementFocusable(focusToElement)
                ) {
                    event.preventDefault();
                    focusToElement.focus();

                    if (
                        document.activeElement.nodeName === 'INPUT' ||
                        document.activeElement.nodeName === 'TEXTAREA'
                    ) {
                        GS.setInputSelection(
                            document.activeElement,
                            0,
                            document.activeElement.value.length
                        );
                    }
                }
            }
        };

        element.addEventListener('keydown', element.internalEvents.keyNav);
    }

    // ############# DEVELOPER EVENTS #############
    function unbindDeveloper(element) {
        element.removeEventListener(
            evt.mousedown,
            element.internalEvents.developerMouseDown
        );
    }
    function bindDeveloper(element) {
        element.internalEvents.developerMouseDown = function (event) {
            var bolCMDorCTRL = (event.ctrlKey || event.metaKey);
            var bolShift = (event.shiftKey);
            var strHTML;
            var arrAttr;
            var jsnAttr;
            var i;
            var len;

            if (bolCMDorCTRL && bolShift) {
                event.preventDefault();
                event.stopPropagation();

                strHTML = '';
                arrAttr = element.attributes;
                i = 0;
                len = arrAttr.length;
                while (i < len) {
                    jsnAttr = arrAttr[i];

                    strHTML += (
                        '<b>Attribute "' + encodeHTML(jsnAttr.name) + '":</b>' +
                        '<pre>' + encodeHTML(jsnAttr.value) + '</pre>'
                    );

                    i += 1;
                }

                GS.msgbox('Developer Info', strHTML, ['Ok']);
            }
        };

        element.addEventListener(
            evt.mousedown,
            element.internalEvents.developerMouseDown
        );
    }


    // ############# HIGH LEVEL BINDING #############
    function unbindElement(element) {
        unbindQuerystringEvents(element);
        unbindChange(element);
        unbindKey(element);
        unbindDeveloper(element);
    }
    function bindElement(element) {
        bindQuerystringEvents(element);
        bindChange(element);
        bindKey(element);
        bindDeveloper(element);
    }


// #############################################################################
// ############################## XTAG DEFINITION ##############################
// #############################################################################

    function elementInserted(element) {
        if (
            // if "created"/"inserted" are not suspended: continue
            !element.hasAttribute('suspend-created') &&
            !element.hasAttribute('suspend-inserted') &&
            // if this is the first time inserted has been run: continue
            !element.inserted
        ) {
            element.inserted = true;

            resolveElementAttributes(element);
            prepareElement(element);
            siphonElement(element);
            bindElement(element);
            renderFull(element);
            dataSELECT(element);
            triggerEvent(element, 'initialized');
        }
    }

    xtag.register('gs-form', {

// #############################################################################
// ############################# ELEMENT LIFECYCLE #############################
// #############################################################################

        lifecycle: {
            'inserted': function () {
                elementInserted(this);
            },

            'removed': function () {
                this.destroy();
            },

            'attributeChanged': function (attr) {//, oldValue, newValue
                var element = this;

                // if suspend attribute: run inserted event
                if (attr === 'suspend-created' || attr === 'suspend-inserted') {
                    elementInserted(element);

                // if the element is not suspended: handle attribute changes
                } else if (
                    !element.hasAttribute('suspend-created') &&
                    !element.hasAttribute('suspend-inserted')
                ) {
                    var arrAttributes = [];
                    if (attr === 'value' || arrAttributes.indexOf(attr) > -1) {

                    }
                }
            }
        },

// #############################################################################
// ############################# ELEMENT ACCESSORS #############################
// #############################################################################

        accessors: {},

// #############################################################################
// ############################## ELEMENT METHODS ##############################
// #############################################################################

        methods: {
            // we don't want a bunch of data hanging in memory, so this allows
            //      the browser to forget everything and use that memory for
            //      other things. This is especially important if the combo has
            //      a boatload of data.
            'destroy': function () {
                var element = this;

                // sometimes, the element is destroyed before it's initialized
                // sometimes, the element gets destroyed multiple times.
                //      we don't want to cause any errors when this happens.
                if (element.elems && element.elems.control) {
                    // prevent the element from recieving any events
                    unbindElement(element);

                    // this is the fastest way to destroy all of the data
                    element.internalData = {};
                    element.internalEvents = {};
                    element.internalEventData = {};
                    element.internalTemplates = {};
                    element.internalDisplay = {};
                    element.internalSelection = {};

                    // destroy element store
                    element.elems = {};

                    // empty innerHTML
                    element.innerHTML = '';
                }
            },

            // allow the user to take columns related to the single record
            'column': function (strColumn, intRow) {
                var element = this;
                var jsnRecord;
                var templateFunc;

                intRow = intRow || 0;

                if (typeof intRow === 'number') {
                    jsnRecord = recordToJSON(
                        element,
                        element.internalData.records[intRow]
                    );
                    templateFunc = doT.template(
                        '{{var row = jo;}}' +
                        '{{! row[\'' + strColumn + '\'] }}'
                    );

                    return templateFunc(jsnRecord);
                }
                return null;
            },

            'refresh': function () {
                dataSELECT(this);
            },

            'save': function () {
                //updateDataWithoutTemplate(this, false);
            },

            'addMessage': function (/*strMessageName*/) {
                //return addMessage(this, strMessageName);
            },

            'removeMessage': function (/*strMessageName*/) {
                //return removeMessage(this, strMessageName);
            }
        }
    });
});






// //global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
// //global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
// //global addControlProps, addFlexContainerProps, addProp
// //global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
// //global addIconProps, shimmed, HTMLTemplateElement, addDataAttributes
// //global addDataEvents
// //jslint browser:true, white:false, this:true
// //, maxlen:80

// window.addEventListener('design-register-element', function () {
//     'use strict';
//     addSnippet(
//         '<gs-form>',
//         '<gs-form>',
//         (
//             'gs-form src="${1:test.tpeople}">\n' +
//             '    <template>\n' +
//             '        ${2}\n' +
//             '    </template>\n' +
//             '</gs-form>'
//         )
//     );

//     addElement('gs-form', '#record_form');

//     window.designElementProperty_GSFORM = function () {
//         addDataAttributes('select,update');
//         addCheck('D', 'Save&nbsp;While&nbsp;Typing', 'save-while-typing');
//         addCheck('D', 'Suppress<br />"No&nbsp;Record&nbsp;Found"<br />Error', 'suppress-no-record-found');
//         addDataEvents('select,update');
//         addText('O', 'Column In QS', 'qs');
//         addText('O', 'Refresh On QS Columns', 'refresh-on-querystring-values');
//         addText('O', 'Refresh On QS Change', 'refresh-on-querystring-change');
//         addFlexContainerProps();
//         addFlexProps();
//     };
// });

// document.addEventListener('DOMContentLoaded', function () {
//     'use strict';
//     // #################################################################
//     // ########################### UTILITIES ###########################
//     // #################################################################

//     function removeMessage(element, strMessageName) {
//         if (strMessageName === 'saving' && element.savingMessage) {
//             element.removeChild(element.savingMessage);
//             element.savingMessage = null;

//         } else if (strMessageName === 'waiting' && element.waitingMessage) {
//             element.removeChild(element.waitingMessage);
//             element.waitingMessage = null;
//         }
//     }

//     function addMessage(element, strMessageName) {
//         if (strMessageName === 'saving') {
//             if (element.savingMessage) {
//                 removeMessage(element, 'saving');
//             }
//             element.savingMessage = document.createElement('div');
//             element.savingMessage.classList.add('message');
//             element.savingMessage.innerHTML = 'Saving...';

//             element.appendChild(element.savingMessage);

//         } else if (strMessageName === 'waiting') {
//             if (element.waitingMessage) {
//                 removeMessage(element, 'waiting');
//             }
//             element.waitingMessage = document.createElement('div');
//             element.waitingMessage.classList.add('message');
//             element.waitingMessage.innerHTML = 'Waiting<br />to save...';

//             element.appendChild(element.waitingMessage);
//         }
//     }

//     function columnParentsUntilForm(form, element) {
//         var intColumnParents = 0;
//         var currentElement = element;
//         var maxLoops = 50;
//         var i = 0;

//         while (currentElement.parentNode !== form && currentElement.parentNode && i < maxLoops) {
//             if (
//                 //If something with a column attribute
//                 currentElement.parentNode.hasAttribute('column') === true ||
//                 //or something with a src attribute
//                 currentElement.parentNode.hasAttribute('src') === true
//             ) {
//                 intColumnParents += 1;
//             }

//             currentElement = currentElement.parentNode;
//             i += 1;
//         }

//         return intColumnParents;
//     }

//     function saveDefaultAttributes(element) {
//         var i;
//         var len;
//         var arrAttr;
//         var jsnAttr;

//         // we need a place to store the attributes
//         element.internal.defaultAttributes = {};

//         // loop through attributes and store them in the internal defaultAttributes object
//         arrAttr = element.attributes;
//         i = 0;
//         len = arrAttr.length;
//         while (i < len) {
//             jsnAttr = arrAttr[i];

//             element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

//             i += 1;
//         }
//     }

//     function pushReplacePopHandler(element) {
//         var i;
//         var len;
//         var strQS = GS.getQueryString();
//         var strQSCol = element.getAttribute('qs');
//         var strQSValue;
//         var strQSAttr;
//         var arrQSParts;
//         var arrAttrParts;
//         var arrPopKeys;
//         var currentValue;
//         var bolRefresh;
//         var strOperator;

//         if (strQSCol) {
//             if (strQSCol.indexOf('=') !== -1) {
//                 arrAttrParts = strQSCol.split(',');
//                 i = 0;
//                 len = arrAttrParts.length;
//                 while (i < len) {
//                     strQSCol = arrAttrParts[i];

//                     if (strQSCol.indexOf('!=') !== -1) {
//                         strOperator = '!=';
//                         arrQSParts = strQSCol.split('!=');
//                     } else {
//                         strOperator = '=';
//                         arrQSParts = strQSCol.split('=');
//                     }

//                     strQSCol = arrQSParts[0];
//                     strQSAttr = arrQSParts[1] || arrQSParts[0];

//                     // if the key is not present or we've got the negator: go to the attribute's default or remove it
//                     if (strOperator === '!=') {
//                         // if the key is not present: add the attribute
//                         if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
//                             element.setAttribute(strQSAttr, '');
//                         // else: remove the attribute
//                         } else {
//                             element.removeAttribute(strQSAttr);
//                         }
//                     } else {
//                         // if the key is not present: go to the attribute's default or remove it
//                         if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
//                             if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
//                                 element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
//                             } else {
//                                 element.removeAttribute(strQSAttr);
//                             }
//                         // else: set attribute to exact text from QS
//                         } else {
//                             element.setAttribute(strQSAttr, (
//                                 GS.qryGetVal(strQS, strQSCol) ||
//                                 element.internal.defaultAttributes[strQSAttr] ||
//                                 ''
//                             ));
//                         }
//                     }
//                     i += 1;
//                 }
//             } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
//                 strQSValue = GS.qryGetVal(strQS, strQSCol);

//                 if (element.internal.bolQSFirstRun !== true) {
//                   //console.log(element.getAttribute('value'));
//                     if (strQSValue !== '' || !element.getAttribute('value')) {
//                         element.setAttribute(
//                             'where',
//                             (
//                                 (element.getAttribute('pk') || 'id') + '=' +
//                                 (
//                                     isNaN(strQSValue)
//                                         ? '$WHEREQuoTE$' + strQSValue + '$WHEREQuoTE$'
//                                         : strQSValue
//                                 )
//                             )
//                         );
//                         bolRefresh = true;
//                     }
//                 } else {
//                     element.setAttribute(
//                         'where',
//                         (
//                             (element.getAttribute('pk') || 'id') + '=' +
//                             (
//                                 isNaN(strQSValue)
//                                     ? '$WHEREQuoTE$' + strQSValue + '$WHEREQuoTE$'
//                                     : strQSValue
//                             )
//                         )
//                     );
//                     bolRefresh = true;
//                 }
//             }
//         }

//         // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
//         if (element.internal.bolQSFirstRun === true) {
//             if (element.hasAttribute('refresh-on-querystring-values')) {
//                 arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

//                 i = 0;
//                 len = arrPopKeys.length;
//                 while (i < len) {
//                     currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);

//                     if (element.popValues[arrPopKeys[i]] !== currentValue) {
//                         bolRefresh = true;
//                     }

//                     element.popValues[arrPopKeys[i]] = currentValue;
//                     i += 1;
//                 }
//             } else if (element.hasAttribute('refresh-on-querystring-change')) {
//                 bolRefresh = true;
//             }
//         } else {
//             if (element.hasAttribute('refresh-on-querystring-values')) {
//                 arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

//                 i = 0;
//                 len = arrPopKeys.length;
//                 while (i < len) {
//                     element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
//                     i += 1;
//                 }
//             }

//             if (GS.getQueryString() || element.hasAttribute('refresh-on-querystring-change') || element.hasAttribute('src')) {
//                 bolRefresh = true;
//             }
//         }

//         if (bolRefresh && element.hasAttribute('src')) {
//             getData(element);
//         } else if (bolRefresh && !element.hasAttribute('src')) {
//             console.warn('gs-combo Warning: element has "refresh-on-querystring-values" or "refresh-on-querystring-change", but no "src".', element);
//         }

//         element.internal.bolQSFirstRun = true;
//     }

//     function triggerBeforeSelect(element) {
//         GS.triggerEvent(element, 'before_select');
//         if (element.hasAttribute('onbefore_select')) {
//             new Function(element.getAttribute('onbefore_select')).apply(element);
//         }
//     }

//     function triggerAfterSelect(element) {
//         GS.triggerEvent(element, 'after_select');
//         if (element.hasAttribute('onafter_select')) {
//             new Function(element.getAttribute('onafter_select')).apply(element);
//         }
//     }

//     function triggerAfterSelectError(element) {
//         GS.triggerEvent(element, 'after_select_error');
//         if (element.hasAttribute('onafter_select_error')) {
//             new Function(element.getAttribute('onafter_select_error')).apply(element);
//         }
//     }

//     //this one doesn't seem to be working properly
//     function triggerBeforeUpdate(element) {
//         GS.triggerEvent(element, 'before_update');
//         if (element.hasAttribute('onbefore_update')) {
//             new Function(element.getAttribute('onbefore_update')).apply(element);
//         }
//     }

//     function triggerAfterUpdate(element) {
//         GS.triggerEvent(element, 'after_update');
//         if (element.hasAttribute('onafter_update')) {
//             new Function(element.getAttribute('onafter_update')).apply(element);
//         } else if (element.hasAttribute('afterupdate')) {
//             new Function(element.getAttribute('afterupdate')).apply(element);
//         }
//     }

//     // the user needs to be able to set a custom websocket for this element,
//     //      so this function will use an attribute to find out what socket to
//     //      use (and it'll default to "GS.envSocket")
//     function getSocket(element) {
//         if (element.getAttribute('socket')) {
//             return GS[element.getAttribute('socket')];
//         }
//         return GS.envSocket;
//     }

//     // ##################################################################
//     // ######################## UPDATE FUNCTIONS ########################
//     // ##################################################################

//     function emergencyUpdate(element) {
//         if (element.currentSaveAjax) {
//             element.currentSaveAjax.abort();
//         }
//         element.bolCurrentlySaving = false;
//         updateDataWithoutTemplate(element, false);
//     }

//     function updateData(element, updateElement, strColumn, newValue) {
//         var parentRecord;
//         var strID;
//         var strHash;
//         var srcParts = GS.templateWithQuerystring(element.getAttribute('update-src') || element.getAttribute('src')).split('.');
//         var strSchema = srcParts[0];
//         var strObject = srcParts[1];
//         var strReturnCols = element.arrColumns.join('\t');
//         var strHashCols = element.lockColumn;
//         var strPk;
//         var updateFrameData;
//         var strRoles;
//         var strColumns;
//         var arrTotalRecords = [];

//         console.log(strColumn, newValue);

//         parentRecord = GS.findParentElement(updateElement, '.form-record');

//         strPk = element.getAttribute('pk') || 'id';
//         strID = parentRecord.getAttribute('data-pk');
//         strHash = CryptoJS.MD5(parentRecord.getAttribute('data-' + element.lockColumn)).toString();

//         strRoles = 'pk\thash\tset';
//         strColumns = strPk + '\thash\t' + GS.encodeForTabDelimited(strColumn);
//         updateFrameData = strID + '\t' + strHash + '\t' + GS.encodeForTabDelimited(newValue);

//         updateFrameData = (strRoles + '\n' + strColumns + '\n' + updateFrameData);

//         triggerBeforeUpdate(element);
//         //GS.triggerEvent(element, 'before_update');

//         element.saveState = 'saving';
//         if (element.saveTimeout) {
//             clearTimeout(element.saveTimeout);
//         }
//         element.saveTimeout = setTimeout(function () {
//             if (element.saveState !== 'saved' && xtag.query(element, '.saving-warning-parent').length === 0) {
//                 element.saveState = 'error';
//                 var parentElement = document.createElement('center');
//                 parentElement.setAttribute('class', 'saving-warning-parent');

//                 var warningElement = document.createElement('div');
//                 warningElement.setAttribute('class', 'saving-warning');

//                 // warningElement.innerHTML = 'CHANGES ARE NOT SAVED<br />CLICK HERE TO TRY AGAIN';
//                 warningElement.innerHTML = (
//                     'YOUR CHANGES ARE NOT SAVED<br />' +
//                     'WE HAVEN\'T HEARD BACK FROM THE SERVER<br />' +
//                     'EITHER THE SAVING IS SLOW OR THERE\'S AN ERROR'
//                 );

//                 parentElement.appendChild(warningElement);
//                 element.insertBefore(parentElement, element.children[0]);

//                 // element.appendChild(parentElement);
//                 /*
//                 warningElement.addEventListener('click', function () {
//                     saveFile(element, strPath, changeStamp, strContent, callbackSuccess, callbackFail);
//                 });
//                 */
//             }
//         }, /*30*/ 5 * 1000);

//         GS.requestUpdateFromSocket(
//             getSocket(element),
//             strSchema,
//             strObject,
//             strReturnCols,
//             strHashCols,
//             updateFrameData,
//             function (data, error) { //, transactionID
//                 if (error) {
//                     if (element.saveTimeout) {
//                         clearTimeout(element.saveTimeout);
//                     }
//                     element.saveState = 'error';

//                     getData(element);
//                     GS.removeLoader(element);
//                     GS.webSocketErrorDialog(data);
//                 }
//             },
//             function (data, error, ignore, commitFunction, rollbackFunction) { //transactionID
//                 // removed by Nunzio on 2019-07-31 because there is no loader
//                 //GS.removeLoader(element);

//                 if (!error) {
//                     if (data === 'TRANSACTION COMPLETED') {
//                         if (element.saveTimeout) {
//                             clearTimeout(element.saveTimeout);
//                         }
//                         element.saveState = 'saved';

//                         commitFunction();
//                     } else {
//                         var arrRecords;
//                         var arrCells;
//                         var i;
//                         var len;
//                         var cell_i;
//                         var cell_len;

//                         arrRecords = GS.trim(data, '\n').split('\n');

//                         i = 0;
//                         len = arrRecords.length;
//                         while (i < len) {
//                             arrCells = arrRecords[i].split('\t');

//                             cell_i = 0;
//                             cell_len = arrCells.length;
//                             while (cell_i < cell_len) {
//                                 arrCells[cell_i] = (
//                                     arrCells[cell_i] === '\\N'
//                                         ? null
//                                         : GS.decodeFromTabDelimited(arrCells[cell_i])
//                                 );
//                                 cell_i += 1;
//                             }

//                             arrTotalRecords.push(arrCells);
//                             i += 1;
//                         }
//                     }

//                 } else {
//                     if (element.saveTimeout) {
//                         clearTimeout(element.saveTimeout);
//                     }
//                     element.saveState = 'error';

//                     rollbackFunction();
//                     getData(element);
//                     GS.webSocketErrorDialog(data);
//                 }
//             },
//             function (strAnswer, data, error) {
//                 var idIndex;
//                 var i;
//                 var len;

//                 //GS.removeLoader(element);

//                 if (!error) {
//                     if (strAnswer === 'COMMIT') {
//                         if (element.saveTimeout) {
//                             clearTimeout(element.saveTimeout);
//                         }
//                         element.saveState = 'saved';

//                         idIndex = element.lastSuccessData.arr_column.indexOf(element.getAttribute('pk') || 'id');
//                         i = 0;
//                         len = element.lastSuccessData.dat.length;
//                         while (i < len) {
//                             if (String(element.lastSuccessData.dat[i][idIndex]) === strID) {
//                                 element.lastSuccessData.dat[i] = arrTotalRecords[0];
//                                 break;
//                             }
//                             i += 1;
//                         }

//                         handleData(element, element.lastSuccessData);

//                         triggerAfterUpdate(element);
//                         //GS.triggerEvent(element, 'after_update');
//                     } else {
//                         getData(element);
//                     }
//                 } else {
//                     if (element.saveTimeout) {
//                         clearTimeout(element.saveTimeout);
//                     }
//                     element.saveState = 'error';

//                     getData(element);
//                     GS.webSocketErrorDialog(data);
//                 }
//             }
//         );
//     }

//     function updateDataWithoutTemplate(element) {

//         console.log(strColumn, newValue);
//         if (element.bolCurrentlySaving === false && !element.bolErrorOpen) {
//             var strID;
//             var strHash;
//             var srcParts = GS.templateWithQuerystring(element.getAttribute('src')).split('.');
//             var strSchema = srcParts[0];
//             var strObject = srcParts[1];
//             var strReturnCols = element.arrColumns.join('\t');
//             var strHashCols = element.lockColumn;
//             var updateFrameData;
//             var strRoles;
//             var strColumns;
//             var arrTotalRecords = [];
//             var functionUpdateRecord;
//             var col_key;
//             var key;
//             var strColumn;
//             var newValue;
//             var idIndex;
//             var i;
//             var len;

//             functionUpdateRecord = function (strID, strColumn, recordIndex, strParameters) {
//                 var strWhere;
//                 var strChangeStamp;
//                 var strValue;
//                 var strPk;

//                 element.bolCurrentlySaving = true;
//                 element.jsnUpdate[strID][strColumn] = undefined;

//                 // run ajax
//                 removeMessage(element, 'waiting');
//                 addMessage(element, 'saving');
//                 element.state = 'saving';

//                 element.saveTimeout = setTimeout(function () {
//                     if (element.saveState !== 'saved' && xtag.query(element, '.saving-warning-parent').length === 0) {
//                         element.saveState = 'error';
//                         var parentElement = document.createElement('center');
//                         parentElement.setAttribute('class', 'saving-warning-parent');

//                         var warningElement = document.createElement('div');
//                         warningElement.setAttribute('class', 'saving-warning');

//                         // warningElement.innerHTML = 'CHANGES ARE NOT SAVED<br />CLICK HERE TO TRY AGAIN';
//                         warningElement.innerHTML = (
//                             'YOUR CHANGES ARE NOT SAVED<br />' +
//                             'WE HAVEN\'T HEARD BACK FROM THE SERVER<br />' +
//                             'EITHER THE SAVING IS SLOW OR THERE\'S AN ERROR'
//                         );

//                         parentElement.appendChild(warningElement);
//                         element.insertBefore(parentElement, element.children[0]);

//                         // element.appendChild(parentElement);
//                         /*
//                         warningElement.addEventListener('click', function () {
//                             saveFile(element, strPath, changeStamp, strContent, callbackSuccess, callbackFail);
//                         });
//                         */
//                     }
//                 }, /*30*/ 5 * 1000);

//                 strWhere = GS.qryGetVal(strParameters, 'where');
//                 strColumn = GS.qryGetVal(strParameters, 'column');
//                 strValue = GS.qryGetVal(strParameters, 'value');
//                 strID = GS.qryGetVal(strWhere, 'pk');
//                 strChangeStamp = GS.qryGetVal(strWhere, element.lockColumn);
//                 strHash = CryptoJS.MD5(strChangeStamp).toString();
//                 strPk = element.getAttribute('pk') || 'id';

//                 strRoles = 'pk\thash\tset';
//                 strColumns = strPk + '\thash\t' + GS.encodeForTabDelimited(strColumn);
//                 updateFrameData = strID + '\t' + strHash + '\t' + GS.encodeForTabDelimited(strValue);
//                 updateFrameData = (strRoles + '\n' + strColumns + '\n' + updateFrameData);

//                 GS.requestUpdateFromSocket(
//                     getSocket(element),
//                     strSchema,
//                     strObject,
//                     strReturnCols,
//                     strHashCols,
//                     updateFrameData,
//                     function (data, error) { // , transactionID
//                         if (error) {
//                             getData(element);
//                             GS.webSocketErrorDialog(data);
//                         }
//                     },
//                     function (data, error, ignore, commitFunction, rollbackFunction) { //transactionID
//                         if (!error) {
//                             if (data === 'TRANSACTION COMPLETED') {
//                                 commitFunction();
//                             } else {
//                                 var arrRecords;
//                                 var arrCells;
//                                 var rec_i;
//                                 var rec_len;
//                                 var cell_i;
//                                 var cell_len;

//                                 arrRecords = GS.trim(data, '\n').split('\n');

//                                 rec_i = 0;
//                                 rec_len = arrRecords.length;
//                                 while (rec_i < rec_len) {
//                                     arrCells = arrRecords[rec_i].split('\t');

//                                     cell_i = 0;
//                                     cell_len = arrCells.length;
//                                     while (cell_i < cell_len) {
//                                         arrCells[cell_i] = (
//                                             arrCells[cell_i] === '\\N'
//                                                 ? null
//                                                 : GS.decodeFromTabDelimited(arrCells[cell_i])
//                                         );
//                                         cell_i += 1;
//                                     }

//                                     arrTotalRecords.push(arrCells);
//                                     rec_i += 1;
//                                 }
//                             }

//                         } else {
//                             rollbackFunction();
//                             getData(element);
//                             GS.webSocketErrorDialog(data);
//                         }
//                     },
//                     function (strAnswer, data, error) {
//                         var col_key;
//                         var key;
//                         var bolSaveWaiting;

//                         removeMessage(element, 'saving');
//                         element.state = 'saved';
//                         if (element.saveTimeout) {
//                             clearTimeout(element.saveTimeout);
//                         }

//                         GS.removeLoader(element);

//                         if (!error) {
//                             if (strAnswer === 'COMMIT') {
//                                 element.lastSuccessData.dat[recordIndex] = arrTotalRecords[0];
//                                 element.bolCurrentlySaving = false;

//                                 // if there is another save in the pipeline: bolSaveWaiting = true
//                                 for (key in element.jsnUpdate) {
//                                     for (col_key in element.jsnUpdate[key]) {
//                                         if (element.jsnUpdate[key][col_key] !== undefined) {
//                                             bolSaveWaiting = true;
//                                             break;
//                                         }
//                                     }
//                                 }

//                                 // if there is a save waiting: update again
//                                 if (bolSaveWaiting) {
//                                     updateDataWithoutTemplate(element);

//                                 } else {
//                                     triggerAfterUpdate(element);
//                                 }
//                             } else {
//                                 getData(element);
//                             }
//                         } else {
//                             GS.webSocketErrorDialog(data);
//                         }
//                     }
//                 );
//             };

//             // loop through the jsnUpdate variable and make one update for every record that needs an update
//             for (key in element.jsnUpdate) {
//                 for (col_key in element.jsnUpdate[key]) {
//                     if (element.jsnUpdate[key][col_key] !== undefined) {
//                         strID = key;
//                         strColumn = col_key;
//                         newValue = element.jsnUpdate[key][col_key];
//                         idIndex = element.lastSuccessData.arr_column.indexOf(element.getAttribute('pk') || 'id');

//                         i = 0;
//                         len = element.lastSuccessData.dat.length;
//                         while (i < len) {
//                             if (String(element.lastSuccessData.dat[i][idIndex]) === strID) {
//                                 functionUpdateRecord(
//                                     strID,
//                                     strColumn,
//                                     i,
//                                     (
//                                         'where=' + encodeURIComponent(
//                                             'pk=' + strID +
//                                             '&' + element.lockColumn + '=' + GS.envGetCell(element.lastSuccessData, i, element.lockColumn)
//                                         ) +
//                                         '&column=' + strColumn +
//                                         '&value=' + encodeURIComponent(newValue)
//                                     )
//                                 );

//                                 break;
//                             }
//                             i += 1;
//                         }

//                         break;
//                     }
//                 }
//             }
//         }
//     }


//     // #################################################################
//     // ######################### DATA HANDLING #########################
//     // #################################################################

//     function dataTemplateRecords(element, data) {
//         var jsnTemplate;
//         var strRet;
//         var strStyle = '';

//         if (data.dat.length === 1) {
//             strStyle = 'style="height: 100%;" ';
//         }

//         jsnTemplate = GS.templateHideSubTemplates(element.templateHTML);

//         strRet = GS.templateWithEnvelopeData(
//             (
//                 '<div ' +
//                     'class="form-record" ' + strStyle +
//                     'data-pk="{{! row.' + (element.getAttribute('pk') || 'id') + ' }}" ' +
//                     'data-' + element.lockColumn + '="{{! row.' + element.lockColumn + ' }}" ' +
//                     'gs-dynamic' +
//                 '>' +
//                     jsnTemplate.templateHTML +
//                 '</div>'
//             ),
//             data
//         );
//         strRet = GS.templateShowSubTemplates(strRet, jsnTemplate);

//         return strRet;
//     }

//     // handles data result from method function: getData
//     //      success:  template
//     //      error:    add error classes
//     function handleData(element, data, error) {
//         var arrElements;
//         var i;
//         var len;
//         var intColumnElementFocusNumber;
//         var jsnSelection;
//         var matchElement;
//         var templateElement = document.createElement('template');
//         var focusTimerID;
//         var focusToElement;
//         var timer_i;

//         // clear any old error status
//         element.classList.remove('error');

//         if (!error && data.dat.length === 0 && !element.hasAttribute('limit') && !element.hasAttribute('suppress-no-record-found')) {
//             templateElement.setAttribute('data-theme', 'error');
//             templateElement.innerHTML = ml(function () {/*
//                 <gs-page>
//                     <gs-header><center><h3>Error</h3></center></gs-header>
//                     <gs-body padded>
//                         <center>No record found</center>
//                     </gs-body>
//                     <gs-footer>
//                         <gs-grid>
//                             <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
//                             <gs-block><gs-button dialogclose listen-for-return bg-primary>Try Again</gs-button></gs-block>
//                         </gs-grid>
//                     </gs-footer>
//                 </gs-page>*/
//             });

//             GS.openDialog(templateElement, '', function (ignore, strAnswer) {
//                 if (strAnswer === 'Try Again') {
//                     element.refresh();
//                 }
//             });
//         }

//         // if there was no error
//         if (!error) {
//             element.error = false;

//             // save success data
//             element.lastSuccessData = data;

//             if (GS.findParentElement(document.activeElement, 'gs-form') === element) {
//                 //console.log('Hey');
//                 arrElements = xtag.query(element, '[column]');
//                 matchElement = GS.findParentElement(document.activeElement, '[column]');

//                 if (document.activeElement.nodeName === 'INPUT' || document.activeElement.nodeName === 'TEXTAREA') {
//                     jsnSelection = GS.getInputSelection(document.activeElement);
//                 }

//                 if (matchElement) {
//                     i = 0;
//                     len = arrElements.length;
//                     while (i < len) {
//                         if (arrElements[i] === matchElement) {
//                             intColumnElementFocusNumber = i;
//                             break;
//                         }
//                         i += 1;
//                     }
//                 }
//             }

//             //console.log(element.children);
//             element.innerHTML = dataTemplateRecords(element, data);
//             //console.log(element.children);

//             // if template is not native: handle templates inside the form
//             if (shimmed.HTMLTemplateElement) {
//                 HTMLTemplateElement.bootstrap(element);
//             }

//             // handle autofocus
//             arrElements = xtag.query(element, '[autofocus]');

//             if (arrElements.length > 0 && !evt.touchDevice) {
//                 arrElements[0].focus();

//                 if (arrElements.length > 1) {
//                     console.warn('dialog Warning: Too many [autofocus] elements, defaulting to the first one. Please have only one [autofocus] element per form.');
//                 }
//             }

//             // if there is a intColumnElementFocusNumber: restore focus
//             if (intColumnElementFocusNumber) {
//                 arrElements = xtag.query(element, '[column]');

//                 if (arrElements.length > intColumnElementFocusNumber) {
//                     focusToElement = arrElements[intColumnElementFocusNumber];

//                     // if element registration is not shimmed, we can just focus into the target element
//                     if (shimmed.customElements === false) {
//                         focusToElement.focus();
//                         if (jsnSelection) {
//                             GS.setInputSelection(document.activeElement, jsnSelection.start, jsnSelection.end);
//                         }

//                     // else, we have to check on a loop to see if the element has been upgraded,
//                     //      the reason I need to use a loop here is because there is no event for
//                     //      when an element is upgraded (if there was then 1000 custom elements
//                     //      would emit 1000 events, which is a lot and we don't want to bog the
//                     //      browser down)
//                     } else {
//                         timer_i = 0;
//                         focusTimerID = setInterval(function () {
//                             if (focusToElement['__upgraded__'] || timer_i >= 10) {
//                                 clearTimeout(focusTimerID);
//                             }
//                             if (focusToElement['__upgraded__']) {
//                                 focusToElement.focus();
//                                 if (jsnSelection) {
//                                     GS.setInputSelection(document.activeElement, jsnSelection.start, jsnSelection.end);
//                                 }
//                             }
//                             timer_i += 1;
//                         }, 5);
//                     }
//                 }
//             }

//             // trigger after_select
//             triggerAfterSelect(element);
//             //GS.triggerEvent(element, 'after_select');

//         // else there was an error: add error class, title attribute
//         } else {
//             element.error = true;
//             element.classList.add('error');
//             element.innerHTML = 'This form encountered an error.';

//             //GS.ajaxErrorDialog(event.detail.response);
//             GS.ajaxErrorDialog(data);

//             // trigger after_select_error
//             triggerAfterSelectError(element);
//         }
//     }

//     // handles fetching the data
//     //      if bolInitalLoad === true then
//     //          use: initialize query COALESCE TO source query
//     //      else
//     //          use: source query
//     function getData(element) { //bolClearPrevious
//         var strSrc = GS.templateWithQuerystring(element.getAttribute('src'));
//         var bolQuery = strSrc[0] === '(';
//         var srcParts = (
//             strSrc[0] === '('
//                 ? [strSrc, '']
//                 : strSrc.split('.')
//         );
//         var strSchema = srcParts[0];
//         var strObject = srcParts[1];
//         var strColumns = GS.templateWithQuerystring(element.getAttribute('cols') || '*').split(',').join('\t');
//         var strWhere = GS.templateWithQuerystring(element.getAttribute('where') || '');
//         var strOrd = GS.templateWithQuerystring(element.getAttribute('ord') || '');
//         var strLimit = GS.templateWithQuerystring(element.getAttribute('limit') || '1');
//         var strOffset = GS.templateWithQuerystring(element.getAttribute('offset') || '');
//         var arrTotalRecords = [];

//         triggerBeforeSelect(element);
//         //GS.triggerEvent(element, 'before_select');

//         GS.requestSelectFromSocket(
//             getSocket(element),
//             (
//                 bolQuery
//                     ? ''
//                     : strSchema
//             ),
//             (
//                 bolQuery
//                     ? strSrc
//                     : strObject
//             ),
//             strColumns,
//             strWhere,
//             strOrd,
//             strLimit,
//             strOffset,
//             function (data, error) {
//                 var arrRecords;
//                 var arrCells;
//                 var i;
//                 var len;
//                 var cell_i;
//                 var cell_len;

//                 if (!error) {
//                     if (data.strMessage !== 'TRANSACTION COMPLETED') {
//                         arrRecords = GS.trim(data.strMessage, '\n').split('\n');

//                         i = 0;
//                         len = arrRecords.length;
//                         while (i < len) {
//                             arrCells = arrRecords[i].split('\t');

//                             cell_i = 0;
//                             cell_len = arrCells.length;
//                             while (cell_i < cell_len) {
//                                 arrCells[cell_i] = (
//                                     arrCells[cell_i] === '\\N'
//                                         ? null
//                                         : GS.decodeFromTabDelimited(arrCells[cell_i])
//                                 );
//                                 cell_i += 1;
//                             }

//                             arrTotalRecords.push(arrCells);
//                             i += 1;
//                         }
//                     } else {
//                         element.arrColumns = data.arrColumnNames;

//                         handleData(
//                             element,
//                             {
//                                 "arr_column": data.arrColumnNames,
//                                 "dat": arrTotalRecords,
//                                 "row_count": arrTotalRecords.length
//                             },
//                             '',
//                             'load'
//                         );
//                     }
//                 } else {
//                     GS.webSocketErrorDialog(data);

//                     // trigger after_select_error
//                     triggerAfterSelectError(element);
//                 }
//             }
//         );
//     }



//     // #################################################################
//     // ########################### LIFECYCLE ###########################
//     // #################################################################

//     // dont do anything that modifies the element here
//     function elementCreated(element) {
//         // if "created" hasn't been suspended: run created code
//         if (!element.hasAttribute('suspend-created')) {

//         }
//     }

//     function elementInserted(element) {
//         var firstChildElement;
//         var changeHandler;

//         // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
//         if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
//             if (element.children.length === 0) {
//                 throw 'GS-Form Error: No template provided';
//             }
//             // if this is the first time inserted has been run: continue
//             if (!element.inserted) {
//                 // #############################################################################################
//                 // ###  ######################
//                 // #############################################################################################

//                 element.inserted = true;
//                 element.internal = {};
//                 saveDefaultAttributes(element);

//                 firstChildElement = element.children[0];


//                 // #############################################################################################
//                 // ### PREVENT CHANGES FROM BEING LOST WHEN NAVIGATING AWAY FROM THE PAGE ######################
//                 // #############################################################################################

//                 // if this form has the "save-while-typing" attribute
//                 if (element.hasAttribute('save-while-typing')) {
//                     GS.addBeforeUnloadEvent(function () {
//                         if (
//                             (
//                                 element.bolCurrentlySaving ||
//                                 element.saveTimerID
//                             ) &&
//                             document.body.contains(element)
//                         ) {
//                             return 'The page has not finished saving.';
//                         }
//                     });
//                 } else {
//                     // this prevents the issue where you type in a change but then unload
//                     //      the page without causing a change event to fire, which means you lose your change
//                     GS.addBeforeUnloadEvent(function () {
//                         document.activeElement.blur();
//                     });
//                 }


//                 // #############################################################################################
//                 // ### DEFAULT #################################################################################
//                 // #############################################################################################

//                 // lock attribute and defaulting
//                 element.lockColumn = element.getAttribute('lock') || 'change_stamp';


//                 // #############################################################################################
//                 // ### TEMPLATE SAVING #########################################################################
//                 // #############################################################################################

//                 // if the first child is a template element: save its HTML
//                 if (firstChildElement.nodeName === 'TEMPLATE') {
//                     element.templateHTML = firstChildElement.innerHTML;

//                 // else: save the innerHTML of the form and send a warning
//                 } else {
//                     console.warn(
//                         'Warning: gs-form is now built to use a template element. ' +
//                         'Please use a template element to contain the template for this form. ' + // this warning was added: March 12th 2015
//                         'A fix has been included so that it is not necessary to use the template element, but that code may be removed at a future date.'
//                     );

//                     element.templateHTML = element.innerHTML;
//                 }

//                 // if there is no HTML: throw an error
//                 if (!element.templateHTML.trim()) {
//                     throw 'GS-FORM error: no template HTML.';
//                 }

//                 if (element.templateHTML.indexOf('&gt;') > -1 || element.templateHTML.indexOf('&lt;') > -1) {
//                     console.warn('GS-FORM WARNING: &gt; or &lt; detected in record template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
//                 }

//                 // add a doT.js coded "value" attribute to any element with a "column" attribute but no "value" attribute
//                 element.templateHTML = GS.templateColumnToValue(element.templateHTML);


//                 // #############################################################################################
//                 // ### "QS" ATTRIBUTE ##########################################################################
//                 // #############################################################################################

//                 // handle "qs" attribute
//                 if (
//                     element.getAttribute('qs') ||
//                     element.getAttribute('refresh-on-querystring-values') ||
//                     element.hasAttribute('refresh-on-querystring-change')
//                 ) {
//                     element.popValues = {};
//                     pushReplacePopHandler(element);
//                     window.addEventListener('pushstate', function () {
//                         pushReplacePopHandler(element);
//                     });
//                     window.addEventListener('replacestate', function () {
//                         pushReplacePopHandler(element);
//                     });
//                     window.addEventListener('popstate', function () {
//                         pushReplacePopHandler(element);
//                     });
//                 } else {
//                     getData(element);
//                 }


//                 // #############################################################################################
//                 // ### ARROW FIELD NAVIGATION ##################################################################
//                 // #############################################################################################

//                 element.addEventListener('keydown', function (event) {
//                     var intKeyCode = (event.which || event.keyCode);
//                     var jsnSelection;
//                     var focusToElement;
//                     var i;
//                     var len;
//                     var arrElementsFocusable;
//                     var currentElement;

//                     if (
//                         document.activeElement.nodeName === 'INPUT' ||
//                         document.activeElement.nodeName === 'TEXTAREA'
//                     ) {
//                         jsnSelection = GS.getInputSelection(event.target);
//                     }

//                     if (
//                         // Left arrow
//                         (
//                             intKeyCode === 37 &&
//                             (!jsnSelection || jsnSelection.start === 0)
//                         ) ||
//                         // Right arrow
//                         (
//                             intKeyCode === 39 &&
//                             (!jsnSelection || jsnSelection.end === event.target.value.length)
//                         )
//                     ) {
//                         // Left arrow
//                         if (
//                             intKeyCode === 37 &&
//                             (!jsnSelection || jsnSelection.start === 0)
//                         ) {
//                             arrElementsFocusable = xtag.query(
//                                 document,
//                                 (
//                                     'input:not([disabled]), ' +
//                                     'select:not([disabled]), ' +
//                                     'memo:not([disabled]), ' +
//                                     'button:not([disabled]), ' +
//                                     '[tabindex]:not([disabled]), ' +
//                                     '[column]'
//                                 )
//                             );

//                             i = 0;
//                             len = arrElementsFocusable.length;
//                             while (i < len) {
//                                 currentElement = arrElementsFocusable[i];

//                                 if (
//                                     currentElement === event.target ||
//                                     (
//                                         (
//                                             event.target.nodeName === 'INPUT' ||
//                                             event.target.nodeName === 'TEXTAREA'
//                                         ) &&
//                                         currentElement === event.target.parentNode
//                                     )
//                                 ) {
//                                     if (i === 0) {
//                                         focusToElement = currentElement;
//                                     } else {
//                                         focusToElement = arrElementsFocusable[i - 1];
//                                     }
//                                     break;
//                                 }

//                                 i += 1;
//                             }

//                         // Right arrow
//                         } else if (
//                             intKeyCode === 39 &&
//                             (!jsnSelection || jsnSelection.end === event.target.value.length)
//                         ) {
//                             arrElementsFocusable = xtag.query(
//                                 document,
//                                 (
//                                     'input:not([disabled]), ' +
//                                     'select:not([disabled]), ' +
//                                     'memo:not([disabled]), ' +
//                                     'button:not([disabled]), ' +
//                                     '[tabindex]:not([disabled]), ' +
//                                     '[column]'
//                                 )
//                             );

//                             i = 0;
//                             len = arrElementsFocusable.length;
//                             while (i < len) {
//                                 currentElement = arrElementsFocusable[i];
//                                 if (currentElement === event.target) {
//                                     if (i === len) {
//                                         focusToElement = currentElement;
//                                     } else {
//                                         focusToElement = arrElementsFocusable[i + 1];
//                                     }
//                                     break;
//                                 }

//                                 i += 1;
//                             }
//                         }

//                         if (
//                             focusToElement &&
//                             GS.isElementFocusable(focusToElement)
//                         ) {
//                             event.preventDefault();
//                             focusToElement.focus();

//                             if (
//                                 document.activeElement.nodeName === 'INPUT' ||
//                                 document.activeElement.nodeName === 'TEXTAREA'
//                             ) {
//                                 GS.setInputSelection(document.activeElement, 0, document.activeElement.value.length);
//                             }
//                         }
//                     }
//                 });

//                 // bind save code
//                 if (element.hasAttribute('save-while-typing')) {
//                     element.bolCurrentlySaving = false;
//                     element.jsnUpdate = {};
//                     element.state = 'saved';
//                     //element.currentSaveAjax = false;

//                     // possible states:
//                     //      'saved'
//                     //      'waiting to save'
//                     //      'saving'

//                     // JSON object for holding columns to update
//                     // on keydown, keyup, change add to JSON object
//                     // keep updating until all columns have been saved (undefined marks an empty column)

//                     changeHandler = function (event) {
//                         var newValue;
//                         var targetColumnParent = GS.findParentElement(event.target, '[column]');
//                         var parentRecordElement;
//                         var strID;

//                         if (
//                             targetColumnParent.getAttribute('column') &&
//                             columnParentsUntilForm(element, targetColumnParent) === 0 &&
//                             element.column(targetColumnParent.getAttribute('column')) !== targetColumnParent.value
//                         ) {
//                             //event.stopPropagation();
//                             if (element.saveTimerID) {
//                                 clearTimeout(element.saveTimerID);
//                                 element.saveTimerID = null;
//                             }

//                             addMessage(element, 'waiting');
//                             element.state = 'waiting to save';

//                             if (targetColumnParent.value !== null) {
//                                 newValue = targetColumnParent.value;
//                             } else {
//                                 newValue = targetColumnParent.checked;
//                             }

//                             parentRecordElement = GS.findParentElement(targetColumnParent, '.form-record[data-pk]');
//                             strID = parentRecordElement.getAttribute('data-pk');

//                             if (!element.jsnUpdate[strID]) {
//                                 element.jsnUpdate[strID] = {};
//                             }
//                             element.jsnUpdate[strID][targetColumnParent.getAttribute('column')] = newValue;

//                             element.saveTimerID = setTimeout(function () {
//                                 updateDataWithoutTemplate(element);
//                                 element.saveTimerID = null;
//                             }, 300);
//                         }
//                     };

//                     element.addEventListener('keydown', changeHandler);
//                     element.addEventListener('keyup', changeHandler);
//                     element.addEventListener('change', changeHandler);

//                 } else {
//                     element.addEventListener('change', function (event) {
//                         var newValue;

//                         if (
//                             event.target.getAttribute('column') &&
//                             columnParentsUntilForm(element, event.target) === 0 &&
//                             GS.findParentTag(event.target, 'gs-form') === element
//                         ) {
//                             //event.stopPropagation();

//                             if (event.target.value !== null) {
//                                 newValue = event.target.value;
//                             } else {
//                                 newValue = event.target.checked;
//                             }

//                             updateData(element, event.target, event.target.getAttribute('column'), newValue);
//                         }
//                     });
//                 }
//             }
//         }
//     }

//     xtag.register('gs-form', {
//         lifecycle: {
//             created: function () {
//                 elementCreated(this);
//             },
//             inserted: function () {
//                 elementInserted(this);
//             },

//             attributeChanged: function (strAttrName, ignore, newValue) {//oldValue
//                 // if "suspend-created" has been removed: run created and inserted code
//                 if (strAttrName === 'suspend-created' && newValue === null) {
//                     elementCreated(this);
//                     elementInserted(this);

//                 // if "suspend-inserted" has been removed: run inserted code
//                 } else if (strAttrName === 'suspend-inserted' && newValue === null) {
//                     elementInserted(this);

//                 } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
//                     // attribute code
//                 }
//             },

//             removed: function () {
//                 if (this.hasAttribute('save-while-typing') && this.saveTimerID) {
//                     clearTimeout(this.saveTimerID);
//                     emergencyUpdate(this);
//                 }
//             }
//         },
//         events: {},
//         accessors: {},
//         methods: {
//             refresh: function () {
//                 getData(this);
//             },

//             save: function () {
//                 updateDataWithoutTemplate(this, false);
//             },

//             column: function (strColumn) {
//                 return GS.envGetCell(this.lastSuccessData, 0, strColumn);
//             },

//             addMessage: function (strMessageName) {
//                 return addMessage(this, strMessageName);
//             },

//             removeMessage: function (strMessageName) {
//                 return removeMessage(this, strMessageName);
//             }
//         }
//     });
// });//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';
    addSnippet(
        '<gs-grid>',
        '<gs-grid>',
        'gs-grid widths="${1}">\n' +
        '    <gs-block>${2}</gs-block>\n' +
        '</gs-grid>'
    );

    addElement('gs-grid', '#layout_grid');

    window.designElementProperty_GSGRID = function() {
        addText('V', 'Min-Width Media', 'min-width');
        addText('V', 'Media', 'media');
        addText('V', 'Widths', 'widths');
        addCheck('V', 'Padded', 'padded');
        addCheck('V', 'Gutters', 'gutter');
        addText('V', 'Reflow At', 'reflow-at');
        addFlexProps();
    };
});

window.addEventListener('design-register-element', function () {
    'use strict';
    addSnippet(
        '<gs-block>',
        '<gs-block>',
        'gs-block>${2}</gs-block>'
    );

    addElement('gs-block', '#layout_grid');

    window.designElementProperty_GSBLOCK = function(selectedElement) {
        addText('Width', 'width');
        addText('Click', 'onclick');
        addText('Mousedown', 'onmousedown');
        addText('Mouseup', 'onmouseup');
        addText('Mousemove', 'onmousemove');
        addFlexContainerProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var arrTakenGrids = [];

    function handleObserver(element) {
        var observer = new MutationObserver(function(mutations) {
            element.handleBlocks();
        });

        observer.observe(element, {childList: true});
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            handleObserver(element);
        }
    }

    //
    function elementInserted(element) {
        var styleElement;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                // if the style element for the grid column CSS doesn't exist: create it
                if (!document.getElementById('gs-dynamic-css')) {
                    styleElement = document.createElement('style');
                    styleElement.setAttribute('id', 'gs-dynamic-css');
                    styleElement.setAttribute('gs-dynamic', '');
                    document.head.appendChild(styleElement);
                }

                // if no width parameter is set: default
                if (!element.getAttribute('widths') && !element.getAttribute('min-width') && !element.getAttribute('media')) {
                    element.bolIgnoreAttribute = true;
                    element.setAttribute('widths', new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                    .join('1').split('').join(','));
                    element.bolIgnoreAttribute = false;
                }

                element.handleCSS();
                element.handleBlocks();
            }
        }
    }
    
    xtag.register('gs-grid', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // if the "widths" attribute changed
                    if (strAttrName === 'widths' && this.bolIgnoreAttribute !== true) {
                        this.handleCSS();
                        this.handleBlocks();
                        
                    // if the "reflow-at" attribute changed
                    } else if (strAttrName === 'reflow-at') {
                        this.handleCSS();
                        
                    // if the "min-width" attribute changed
                    } else if (strAttrName === 'min-width') {
                        this.handleCSS();
                        this.handleBlocks();
                        
                    // if the "media" attribute changed
                    } else if (strAttrName === 'media') {
                        this.handleCSS();
                        this.handleBlocks();
                    }
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            
            getWidthsParameters: function (strWidths) {
                var arrWidths, intGridWidth, i, len;
                
                arrWidths = strWidths
                        .replace(/[^0-9,]/gim, '') // remove everything except commas and numbers
                        .replace(/,{1,}/gim, ',')  // replace multiple commas right next to each other with a single comma
                        .replace(/^,|,$/gim, '')   // remove commas at the end and the beginning of the line
                        .split(',');               // split on commas to make an array of numbers (which are currently type 'string')
                
                // if the array doesn't have content: error
                if (arrWidths.length === 0) {
                    throw 'gs-grid Error: no valid widths found. Please put a comma seperated list of widths in the "widths" attribute.';
                }
                
                // convert the array of strings to an array of integers
                for (i = 0, len = arrWidths.length; i < len; i += 1) {
                    arrWidths[i] = parseInt(arrWidths[i], 10);
                }
                
                // add up the array of integers to come up with a grid width
                for (i = 0, len = arrWidths.length, intGridWidth = 0; i < len; i += 1) {
                    intGridWidth += arrWidths[i];
                }
                
                return {
                    'arrWidths': arrWidths,
                    'intGridWidth': intGridWidth
                };
            },
            
            handleCSS: function () {
                var jsnWidthsParameters;
                
                if (this.getAttribute('widths')) {
                    jsnWidthsParameters = this.getWidthsParameters(this.getAttribute('widths'));
                    
                    this.handleWidthsCSS(jsnWidthsParameters.arrWidths, jsnWidthsParameters.intGridWidth);
                    
                } else if (this.getAttribute('min-width')) {
                    this.handleMinWidthCSS();
                    
                } else if (this.getAttribute('media')) {
                    this.handleMediaCSS();
                }
            },
            
            handleBlocks: function () {
                var jsnWidthsParameters;
                
                if (this.getAttribute('widths')) {
                    jsnWidthsParameters = this.getWidthsParameters(this.getAttribute('widths'));
                    
                    this.handleWidthsBlocks(jsnWidthsParameters.arrWidths, jsnWidthsParameters.intGridWidth);
                    
                } else if (this.getAttribute('min-width')) {
                    this.handleMinWidthBlocks();
                    
                } else if (this.getAttribute('media')) {
                    this.handleMediaBlocks();
                }
            },
            
            
            
            
            handleWidthsCSS: function (arrWidths, intGridWidth) {
                var styleElement = document.getElementById('gs-dynamic-css'),
                    i, len, strCurrentWidth, intCurrentWidth, widthIncreaseAmount, strCSS,
                    strReflowAt = this.getAttribute('reflow-at') || '', arrClassesToRemove;
                
                // reflow-at shortcuts
                strReflowAt = strReflowAt.replace(/small|sml/g,  '992px');
                strReflowAt = strReflowAt.replace(/medium|med/g, '1200px');
                strReflowAt = strReflowAt.replace(/large|lrg/g,  '10000px');
                
                // remove old classes
                arrClassesToRemove = String(this.classList).match(/width-[0-9]*/g) || [];
                
                for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                    this.classList.remove(arrClassesToRemove[i]);
                }
                
                // make sure that this grid hasn't been done before
                if (!styleElement.classList.contains('col-' + intGridWidth)) {
                    // column CSS
                    
                    // calculate the amount to increase every block width setting by
                    widthIncreaseAmount = 100 / intGridWidth;
                    
                    // create a style for every block
                    for (i = 0, len = intGridWidth, intCurrentWidth = 0, strCSS = ''; i < len; i += 1) {
                        intCurrentWidth += widthIncreaseAmount;
                        strCurrentWidth = String(parseFloat(intCurrentWidth.toFixed(5).toString(), 10));
                        
                        strCSS += 'gs-grid.width-' + intGridWidth + ' > gs-block[width="' + (i + 1) + '"] { width: ' + strCurrentWidth + '%; }\n';
                    }
                    
                    // add col-NUM to the styleElement's "class" attribute
                    styleElement.classList.add('col-' + intGridWidth);
                    
                    // append the column CSS
                    styleElement.innerHTML += '\n/* grid width: ' + intGridWidth + ' */\n' +
                                              strCSS +
                                              'gs-grid.width-' + intGridWidth + ' > gs-block.first-of-row { padding-left: 0; }\n' +
                                              'gs-grid.width-' + intGridWidth + ' > gs-block.last-of-row { padding-right: 0; }\n';
                }
                
                // reflow CSS
                
                // remove class from the gs-grid that allowed the generated reflow CSS to apply
                this.classList.remove('reflow-' + this.strReflowAt);
                
                // clean reflow-at attribute variable
                strReflowAt = strReflowAt.replace(/[^0-9a-z]/gi, '');
                
                // if reflow-at contains anything
                if (strReflowAt) {
                    // if reflow-at doesn't have a unit specified: add 'px' to the end of it
                    if (strReflowAt.replace(/[0-9]/gi, '') === '') {
                        strReflowAt += 'px';
                    }
                    
                    // save the current reflow width so that we can use it later
                    this.strReflowAt = strReflowAt;
                    
                    // add class to the gs-grid so that the generated reflow CSS will apply
                    this.classList.add('reflow-' + strReflowAt);
                    
                    // if the reflow CSS for this grid width doesn't already exist: append it
                    if (!styleElement.classList.contains('reflow-' + strReflowAt)) {
                        
                        // add reflow-SIZE to the styleElement's "class" attribute
                        styleElement.classList.add('reflow-' + strReflowAt);
                        
                        // append the reflow CSS
                        styleElement.innerHTML += '\n/* grid reflow width: ' + strReflowAt + ' */\n' +
                                                  '@media only all and (max-width: ' + strReflowAt + ') {\n' +
                                                  '    gs-grid.reflow-' + strReflowAt + '            { width: 100%; }\n' +
                                                  '    gs-grid.reflow-' + strReflowAt + ' > gs-block { width: auto !important; float: none; }\n' +
                                                  '    gs-grid.reflow-' + strReflowAt + ' > gs-block { padding-left: 0 !important; padding-right: 0 !important; }\n' +
                                                  '    gs-grid.reflow-' + strReflowAt + '[gutter] > gs-block { padding-left: 0 !important; padding-right: 0 !important; }\n' +
                                                  '}\n';
                    }
                }
                
                // apply CSS for blocks
                this.classList.add('width-' + intGridWidth);
            },
            
            handleMinWidthCSS: function () {
                var strMinWidth = this.getAttribute('min-width'), arrMinWidths, strCSS, strCurrentCSS,
                    i, len, arrParts, strWidth, strResult, intCurrentGridID, bolMedia, intCurrentWidth,
                    strCurrentWidth, intGridWidth, widthIncreaseAmount, grid_i, grid_len, intLayout, arrArrGridWidths,
                    column_i, column_len, arrWidths = [], width_i, strNextWidth;
                
                // 0 {1,1}; 1000 {2,1}; 10000 {2,1}; 12000 {1,1}
                // all {reflow}; sml {1,1}; med {1,1,1}; lrg {reflow}
                
                strMinWidth = strMinWidth.replace(/\s+/g, ''); // remove all whitespace
                strMinWidth = strMinWidth.replace(/\}/g, ''); // remove all close curly braces
                strMinWidth = strMinWidth.toLowerCase(); // lowercase
                strMinWidth = GS.trim(strMinWidth, ';'); // trim off semicolons
                
                // replace shortcuts (lrg => 1200px)
                strMinWidth = strMinWidth.replace(/all/g,        '0px');
                strMinWidth = strMinWidth.replace(/small|sml/g,  '768px');
                strMinWidth = strMinWidth.replace(/medium|med/g, '992px');
                strMinWidth = strMinWidth.replace(/large|lrg/g,  '1200px');
                
                arrMinWidths = strMinWidth.split(';'); // seperate out layouts
                
                //console.log(strMinWidth, arrMinWidths);
                
                if (arrTakenGrids.indexOf(strMinWidth) === -1) {
                    arrTakenGrids.push(strMinWidth);
                    intCurrentGridID = arrTakenGrids.length - 1;
                    strCSS = '';
                    arrArrGridWidths = [];
                    
                    for (i = 0, len = arrMinWidths.length, intLayout = 0; i < len; i += 1) {
                        arrParts = arrMinWidths[i].split('{');
                        strWidth = arrParts[0] || '0px';
                        strResult = arrParts[1] || new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                    .join('1').split('').join(',');
                        bolMedia = parseInt(strWidth) > 0;
                        strCurrentCSS = '';
                        
                        if (strResult === 'reflow') {
                            intLayout += 1;
                            arrArrGridWidths.push('reflow');
                            
                            // reflow css
                            strCurrentCSS += 
                                '    gs-grid.grid-id-' + intCurrentGridID + '            { width: 100%; }\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.reflow-layout-' + intLayout +
                                                                                            ' { width: auto; float: none; }\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.reflow-layout-' + intLayout +
                                                                                            ' { padding-left: 0; padding-right: 0; }\n';
                            
                        } else {
                            intLayout += 1;
                            arrArrGridWidths.push(strResult.split(','));
                            
                            // grid css
                            intGridWidth = this.getWidthsParameters(strResult).intGridWidth;
                            
                            // calculate the amount to increase every block width setting by
                            widthIncreaseAmount = 100 / intGridWidth;
                            
                            // create a style for every block
                            for (grid_i = 0, grid_len = intGridWidth, intCurrentWidth = 0; grid_i < grid_len; grid_i += 1) {
                                intCurrentWidth += widthIncreaseAmount;
                                strCurrentWidth = String(parseFloat(intCurrentWidth.toFixed(5).toString(), 10));
                                
                                strCurrentCSS += '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.width-' + (grid_i + 1) + '-layout-' + intLayout + ' { ' +
                                                     'width: ' + strCurrentWidth + '%; float: left; ' +
                                                 '}\n';
                            }
                            
                            strCurrentCSS =
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.clearfix-layout-' + intLayout +
                                            ' { clear: left; }\n\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + '[gutter] > gs-block { padding-left: 0.5em; padding-right: 0.5em; }\n\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.first-of-row-layout-' + intLayout +
                                            ' { padding-left: 0; }\n\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.last-of-row-layout-' + intLayout +
                                            ' { padding-right: 0; }\n\n' +
                                strCurrentCSS;
                        }
                        
                        //if (bolMedia) {
                        strNextWidth = '';
                        if (arrMinWidths[i + 1]) {
                            strNextWidth = arrMinWidths[i + 1].split('{')[0];
                            
                            // subtract 1 from the next width so that max-width doesn't allow the
                            //      media to apply at the same time as the next media
                            strNextWidth = (parseInt(strNextWidth) - 1) + strNextWidth.replace(/[0-9]/g, '');
                        }
                        
                        strCurrentCSS = '\n@media (min-width:' + strWidth + ')' + (strNextWidth ? ' and (max-width:' + strNextWidth + ')' : '') + ' {\n' +
                                            strCurrentCSS +
                                        '}\n';
                        //}
                        
                        strCSS += strCurrentCSS;
                    }
                    //console.log(strCSS);
                    
                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* grid #' + intCurrentGridID + ' */\n' + strCSS;
                    
                } else {
                    intCurrentGridID = arrTakenGrids.indexOf(strMinWidth);
                    arrArrGridWidths = [];
                    
                    for (i = 0, len = arrMinWidths.length, intLayout = 0; i < len; i += 1) {
                        arrParts = arrMinWidths[i].split('{');
                        strWidth = arrParts[0] || '0px';
                        strResult = arrParts[1] || new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                    .join('1').split('').join(',');
                        
                        intLayout += 1;
                        
                        if (strResult !== 'reflow') {
                            arrArrGridWidths.push(strResult.split(','));
                        } else {
                            arrArrGridWidths.push('reflow');
                        }
                    }
                }
                
                //
                this.intLayouts = intLayout;
                this.arrArrWidths = arrArrGridWidths;
                
                for (i = 0, len = this.arrArrWidths.length; i < len; i += 1) {
                    if (this.arrArrWidths[i] !== 'reflow') {
                        arrWidths.push(0);
                        width_i = arrWidths.length - 1;
                        
                        for (column_i = 0, column_len = this.arrArrWidths[i].length; column_i < column_len; column_i += 1) {
                            this.arrArrWidths[i][column_i] = parseInt(this.arrArrWidths[i][column_i], 10);
                            arrWidths[width_i] += 1;
                        }
                    } else {
                        arrWidths.push('reflow');
                    }
                }
                
                this.arrWidths = arrWidths;
                
                // add class so that the CSS can apply
                this.classList.add('grid-id-' + intCurrentGridID);
            },
            
            handleMediaCSS: function () {
                var strMinWidth = this.getAttribute('media'), arrMinWidths, strCSS, strCurrentCSS,
                    i, len, arrParts, strMedia, strResult, intCurrentGridID, bolMedia, intCurrentWidth,
                    strCurrentWidth, intGridWidth, widthIncreaseAmount, grid_i, grid_len, intLayout, arrArrGridWidths,
                    column_i, column_len, arrWidths = [], width_i;
                
                strMinWidth = strMinWidth.trim().replace(/\}/g, ''); // remove all close curly braces
                strMinWidth = strMinWidth.toLowerCase(); // lowercase
                strMinWidth = GS.trim(strMinWidth, ';'); // trim off semicolons
                
                // all {reflow}; all and (min-width: small) {2,2,2}; all and (min-width: med) {3,3}; all and (min-width: large) {reflow};
                
                // replace shortcuts (lrg => 1200px)
                strMinWidth = strMinWidth.replace(/small|sml/g,  '768px');
                strMinWidth = strMinWidth.replace(/medium|med/g, '992px');
                strMinWidth = strMinWidth.replace(/large|lrg/g,  '1200px');
                
                arrMinWidths = strMinWidth.split(';'); // seperate out layouts
                
                if (arrTakenGrids.indexOf(strMinWidth) === -1) {
                    arrTakenGrids.push(strMinWidth);
                    intCurrentGridID = arrTakenGrids.length - 1;
                    strCSS = '';
                    arrArrGridWidths = [];
                    
                    //console.log(strMinWidth, arrMinWidths);
                    
                    for (i = 0, len = arrMinWidths.length, intLayout = 0; i < len; i += 1) {
                        arrParts = arrMinWidths[i].split('{');
                        strMedia = arrParts[0].trim() || 'all';
                        strResult = arrParts[1].trim() || new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                    .join('1').split('').join(',');
                        strCurrentCSS = '';
                        
                        if (strResult === 'reflow') {
                            intLayout += 1;
                            arrArrGridWidths.push('reflow');
                            
                            // reflow css
                            strCurrentCSS += 
                                '    gs-grid.grid-id-' + intCurrentGridID + '            { width: 100%; }\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.reflow-layout-' + intLayout +
                                                                                            ' { width: auto; float: none; }\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.reflow-layout-' + intLayout +
                                                                                            ' { padding-left: 0; padding-right: 0; }\n';
                            
                        } else {
                            intLayout += 1;
                            arrArrGridWidths.push(strResult.split(','));
                            
                            // grid css
                            intGridWidth = this.getWidthsParameters(strResult).intGridWidth;
                            
                            // calculate the amount to increase every block width setting by
                            widthIncreaseAmount = 100 / intGridWidth;
                            
                            // create a style for every block
                            for (grid_i = 0, grid_len = intGridWidth, intCurrentWidth = 0; grid_i < grid_len; grid_i += 1) {
                                intCurrentWidth += widthIncreaseAmount;
                                strCurrentWidth = String(parseFloat(intCurrentWidth.toFixed(5).toString(), 10));
                                
                                strCurrentCSS += '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.width-' + (grid_i + 1) + '-layout-' + intLayout + ' { ' +
                                                     'width: ' + strCurrentWidth + '%; float: left; ' +
                                                 '}\n';
                            }
                            
                            strCurrentCSS =
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.clearfix-layout-' + intLayout +
                                            ' { clear: left; }\n\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + '[gutter] > gs-block { padding-left: 0.5em; padding-right: 0.5em; }\n\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.first-of-row-layout-' + intLayout +
                                            ' { padding-left: 0; }\n\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.last-of-row-layout-' + intLayout +
                                            ' { padding-right: 0; }\n\n' +
                                strCurrentCSS;
                        }
                        
                        strCurrentCSS = '\n@media ' + strMedia + ' {\n' +
                                            strCurrentCSS +
                                        '}\n';
                        
                        strCSS += strCurrentCSS;
                    }
                    
                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* grid #' + intCurrentGridID + ' */\n' + strCSS;
                    
                } else {
                    intCurrentGridID = arrTakenGrids.indexOf(strMinWidth);
                    arrArrGridWidths = [];
                    
                    for (i = 0, len = arrMinWidths.length, intLayout = 0; i < len; i += 1) {
                        arrParts = arrMinWidths[i].split('{');
                        strWidth = arrParts[0] || '0px';
                        strResult = arrParts[1] || new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                    .join('1').split('').join(',');
                        
                        intLayout += 1;
                        
                        if (strResult !== 'reflow') {
                            arrArrGridWidths.push(strResult.split(','));
                        } else {
                            arrArrGridWidths.push('reflow');
                        }
                    }
                }
                
                //
                this.intLayouts = intLayout;
                this.arrArrWidths = arrArrGridWidths;
                
                for (i = 0, len = this.arrArrWidths.length; i < len; i += 1) {
                    if (this.arrArrWidths[i] !== 'reflow') {
                        arrWidths.push(0);
                        width_i = arrWidths.length - 1;
                        
                        for (column_i = 0, column_len = this.arrArrWidths[i].length; column_i < column_len; column_i += 1) {
                            this.arrArrWidths[i][column_i] = parseInt(this.arrArrWidths[i][column_i], 10);
                            arrWidths[width_i] += 1;
                        }
                    } else {
                        arrWidths.push('reflow');
                    }
                }
                
                this.arrWidths = arrWidths;
                
                //
                this.classList.add('grid-id-' + intCurrentGridID);
            },
            
            
            
            
            
            handleWidthsBlocks: function (arrWidths, intGridWidth) {
                var i, len, unset_i, arrElements, intNumberOfWidths = arrWidths.length, intCurrentRowWidth = 0, intNextToAdd;
                
                // mark initally set blocks
                arrElements = xtag.queryChildren(this, 'gs-block[width]');
                
                for (i = 0, len = arrElements.length; i < len; i += 1) {
                    arrElements[i].initallySet = true;
                }
                
                // get all child blocks
                arrElements = xtag.queryChildren(this, 'gs-block');
                
                // loop through the blocks
                for (i = 0, unset_i = 0, len = arrElements.length; i < len; i += 1) {
                    intNextToAdd = parseInt(arrElements[i].getAttribute('width'), 10) || arrWidths[unset_i % intNumberOfWidths];
                    
                    // if this block wasn't initally set: remove the width attribute
                    if (!arrElements[i].initallySet) {
                        arrElements[i].removeAttribute('width');
                    }
                    arrElements[i].classList.remove('first-of-row');
                    arrElements[i].classList.remove('last-of-row');
                    arrElements[i].style.clear = '';
                    
                    // if this is the first block in the row
                    if (intCurrentRowWidth === 0) {
                        // set the clear to left, this fixes an issue where a tall cell will move a cell over to the right
                        arrElements[i].style.clear = 'left';
                        arrElements[i].classList.add('first-of-row');
                    }
                    
                    // if this is the last block in the row
                    //console.log(intCurrentRowWidth, intNextToAdd, intGridWidth);
                    if ((intCurrentRowWidth + intNextToAdd) === intGridWidth) {
                        arrElements[i].classList.add('last-of-row');
                    }
                    
                    // if this block doesn't have a set width: set its width (if there are more unset width blocks than widths: the widths repeat)
                    if (!arrElements[i].hasAttribute('width')) {
                        arrElements[i].setAttribute('width', arrWidths[unset_i % intNumberOfWidths]);
                        unset_i += 1;
                    }
                    
                    intCurrentRowWidth += intNextToAdd;
                    intCurrentRowWidth = intCurrentRowWidth % intGridWidth;
                }
            },
            
            
            
            iterateBlocks: function (intLayouts, arrArrWidths, arrIntGridWidth) {
                var arrBlocks = xtag.queryChildren(this, 'gs-block'), i, len, block_i, block_len, width_i;
                
                for (i = 0, len = intLayouts; i < len; i += 1) {
                    width_i = 0;
                    
                    //console.log(arrArrWidths[i]);
                    if (arrArrWidths[i] !== 'reflow') {
                        for (block_i = 0, block_len = arrBlocks.length; block_i < block_len; block_i += 1) {
                            // if this is the first block in the row:
                            //      set the clear to left, this fixes an issue where a tall cell will move a cell over to the right
                            if (width_i === 0) {
                                arrBlocks[block_i].classList.add('clearfix-layout-' + (i + 1));
                                arrBlocks[block_i].classList.add('first-of-row-layout-' + (i + 1));
                            } else if ((width_i + 1) === arrIntGridWidth[i]) {
                                arrBlocks[block_i].classList.add('last-of-row-layout-' + (i + 1));
                            }
                            
                            arrBlocks[block_i].classList.add('width-' + arrArrWidths[i][width_i] + '-layout-' + (i + 1));
                            
                            //console.log(width_i, arrArrWidths[i][width_i], arrIntGridWidth[i]);
                            width_i += 1;
                            width_i = width_i % arrIntGridWidth[i];
                        }
                    } else {
                        for (block_i = 0, block_len = arrBlocks.length; block_i < block_len; block_i += 1) {
                            arrBlocks[block_i].classList.add('reflow-layout-' + (i + 1));
                        }
                    }
                }
                
                
            },
            
            handleMinWidthBlocks: function () {
                this.iterateBlocks(this.intLayouts, this.arrArrWidths, this.arrWidths);
            },
            
            handleMediaBlocks: function () {
                this.iterateBlocks(this.intLayouts, this.arrArrWidths, this.arrWidths);
            }
        }
    });
    
    xtag.register('gs-block', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {}
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    "use strict";
    window.designElementProperty_GSGROUP = function () {
        addCheck('V', 'Padded', 'padded');
    };
});

document.addEventListener("DOMContentLoaded", function () {
    "use strict";
    // fill gs-group based on current content
    function buildElement(element) {
        var rootBox = document.createElement("div");
        var innerBox = document.createElement("gs-groupborder");
        var titleBox = document.createElement("gs-grouptitle");

        // fill "innerBox" by transfering all of "element"'s child nodes to it (this includes text nodes)
        var arrElements = xtag.toArray(element.childNodes);
        var i = 0;
        var len = arrElements.length;

        while (i < len) {
            innerBox.appendChild(arrElements[i]);
            i += 1;
        }

        // fill "titleBox"
        titleBox.textContent = element.getAttribute("name");

        // give "rootBox" the class "root"
        rootBox.classList.add("root");

        // make "rootBox" flex it's content vertically, and make it fill horizontally
        rootBox.setAttribute("flex-vertical", "");
        rootBox.setAttribute("flex-fill", "");

        // make "innerBox" flex to fill height
        innerBox.setAttribute("flex", "");

        // mark "titleBox" and "innerBox" as dynamic elements
        //      because we want developers to know that these
        //      are generated
        innerBox.setAttribute("gs-dynamic", "");
        titleBox.setAttribute("gs-dynamic", "");

        // append "titleBox" and "innerBox" to "rootBox"
        rootBox.appendChild(innerBox);
        rootBox.appendChild(titleBox);

        // append "rootBox" to "element"
        element.appendChild(rootBox);
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute("suspend-created") && !element.hasAttribute("suspend-inserted")) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                if (!element.children[0].classList.contains('root')) {
                    buildElement(element);
                }
            }
        }
    }

    xtag.register("gs-groupborder", {});
    xtag.register("gs-grouptitle", {});
    xtag.register("gs-group", {
        lifecycle: {
            inserted: function () {
                elementInserted(this);
            },
            attributeChanged: function (strAttrName, ignore, newValue) {
                var element = this;

                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === "suspend-created" && newValue === null) {
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === "suspend-inserted" && newValue === null) {
                    elementInserted(element);
                }
                // else if (!element.hasAttribute("suspend-created") && !element.hasAttribute("suspend-inserted")) {
                //    // attribute code
                //}
            }
        },
        events: {},
        accessors: {},
        methods: {}
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    "use strict";
    addSnippet(
        'Centered Header',
        '<gs-header>',
        '<gs-header><center><h3>$0</h3></center></gs-header>'
    );
    addSnippet(
        'Header',
        '<gs-header>',
        '<gs-header><h3>$0</h3></gs-header>'
    );
    addSnippet(
        '<gs-header>',
        '<gs-header>',
        'gs-header><h3>$0</h3></gs-header>'
    );

    addElement('gs-header', '#layout_page');

    window.designElementProperty_GSHEADER = function () {
        addFlexContainerProps();
    };
});

// document.addEventListener('DOMContentLoaded', function () {
//     xtag.register('gs-header', {
//         lifecycle: {
//             /*inserted: function () {
//                 if (this.border_line) {
//                     this.removeChild(this.border_line);
//                 }
//
//                 this.border_line = document.createElement('div');
//                 this.border_line.classList.add('border-line');
//                 this.border_line.setAttribute('gs-dynamic', '');
//
//                 this.appendChild(this.border_line);
//             },
//             removed: function () {
//                 if (this.border_line.parentNode === this) {
//                     this.removeChild(this.border_line);
//                 }
//             }*/
//         },
//         events: {},
//         accessors: {},
//         methods: {}
//     });
// });
document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    xtag.register('gs-header', {
        lifecycle: {
            created: function () {
                if (
                    !this.hasAttribute('role') &&
                    !GS.findParentTag(this, 'gs-dialog')
                ) {
                    this.setAttribute('role', 'banner');
                }
            }
        },
        events: {},
        accessors: {},
        methods: {}
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';

    addSnippet('<gs-img>', '<gs-img>', 'gs-img src="${1}"></gs-img>');
    addElement('gs-img', '#layout_image');

    window.designElementProperty_GSIMG = function(selectedElement) {
        addText('D', 'Source', 'src');
        addText('V', 'Min-Width Media', 'min-width');
        addText('V', 'Media', 'media');
        addSelect('V', 'Alignment', 'align', [
            {"val": "", "txt": "Center (Default)"},
            {"val": "left", "txt": "Left"},
            {"val": "right", "txt": "Right"}
        ]);
        addCheck('V', 'Image Cover', 'image-cover');
        addFlexProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var arrTakenlayouts = [];

    //
    function elementInserted(element) {
        var styleElement;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                // if the style element for the grid column CSS doesn't exist: create it
                if (!document.getElementById('gs-dynamic-css')) {
                    styleElement = document.createElement('style');
                    styleElement.setAttribute('id', 'gs-dynamic-css');
                    styleElement.setAttribute('gs-dynamic', '');
                    document.head.appendChild(styleElement);
                }

                element.handleSrc();

                if (element.getAttribute('min-width')) {
                    element.handleMinWidthCSS();
                } else if (element.getAttribute('media')) {
                    element.handleMediaCSS();
                }

                if (element.hasAttribute('alt')) {
                    element.setAttribute('aria-label', element.getAttribute('alt'));
                    element.removeAttribute('alt');
                }
            }
        }
    }

    xtag.register('gs-img', {
        lifecycle: {
            inserted: function () {
                elementInserted(this);
            },
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (
                    (
                        strAttrName === 'suspend-created' ||
                        strAttrName === 'suspend-inserted'
                    ) &&
                    newValue === null
                ) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // if the "min-width" attribute changed
                    if (strAttrName === 'min-width') {
                        this.handleMinWidthCSS();

                    // if the "media" attribute changed
                    } else if (strAttrName === 'media') {
                        this.handleMediaCSS();

                    // if the "src" attribute changed
                    } else if (strAttrName === 'src') {
                        this.handleSrc();
                    }
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            handleSrc: function () {
                var strSrc = this.getAttribute('src');
                
                if (strSrc) {
                    this.style.backgroundImage = 'url("' + strSrc + '")';
                } else {
                    this.style.backgroundImage = '';
                }
            },
            
            handleMinWidthCSS: function () {
                var strMinWidth = this.getAttribute('min-width'), arrLayouts, strCSS, strCurrentMinWidth,
                    i, len, arrClassesToRemove, intImageID, arrParts, strDimensions, strWidth, strHeight;
                
                // remove old classes
                arrClassesToRemove = String(this.classList).match(/image-id-[0-9]*/g) || [];
                
                for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                    this.classList.remove(arrClassesToRemove[i]);
                }
                
                // all {150px}; lrg {75px};
                // all {150px, 75px}; lrg {75px, 150px};
                
                // remove all whitespace, remove all close curly braces, lowercase, trim off semicolons
                strMinWidth = GS.trim(strMinWidth.replace(/\s+/g, '').replace(/\}/g, '').toLowerCase(), ';');
                
                // replace shortcuts (lrg => 1200px)
                strMinWidth = strMinWidth.replace(/all/g, '0px')
                                         .replace(/small|sml/g, '768px')
                                         .replace(/medium|med/g, '992px')
                                         .replace(/large|lrg/g, '1200px');
                
                // seperate out layouts
                arrLayouts = strMinWidth.split(';');
                
                //console.log(strMinWidth, arrLayouts);
                
                if (arrTakenlayouts.indexOf(strMinWidth) === -1) {
                    arrTakenlayouts.push(strMinWidth);
                    intImageID = arrTakenlayouts.length - 1;
                    strCSS = '';
                    
                    for (i = 0, len = arrLayouts.length; i < len; i += 1) {
                        arrParts = arrLayouts[i].split('{');
                        strCurrentMinWidth = arrParts[0] || '0px';
                        strDimensions = arrParts[1];
                        
                        if (strDimensions.indexOf(',') === -1) {
                            strWidth = strDimensions;
                            strHeight = strDimensions;
                        } else {
                            arrParts = strDimensions.split(',');
                            strWidth = arrParts[0];
                            strHeight = arrParts[1];
                        }
                        
                        strCSS +=   '\n@media (min-width:' + strCurrentMinWidth + ') {\n' +
                                    '    gs-img.image-id-' + intImageID + ' { width:' + strWidth + '; height: ' + strHeight + '; }\n' +
                                    '}\n';
                    }
                    
                    //console.log(strCSS);
                    
                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* image #' + intImageID + ' */\n' + strCSS;
                    
                } else {
                    intImageID = arrTakenlayouts.indexOf(strMinWidth);
                }
                
                this.classList.add('image-id-' + intImageID);
            },
            
            handleMediaCSS: function () {
                var strMedia = this.getAttribute('media'), arrLayouts, strCSS, i, len,
                    arrClassesToRemove, arrParts, strCurrentMedia, strWidth, intImageID,
                    arrParts, strCurrentMedia, strDimensions, strWidth, strHeight;
                
                // remove old classes
                arrClassesToRemove = String(this.classList).match(/image-id-[0-9]*/g) || [];
                
                for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                    this.classList.remove(arrClassesToRemove[i]);
                }
                
                // print {200px}; all and (max-width: 500px) {500px}; (min-width 500px) {600px};
                
                // trim, remove all close curly braces, lowercase, trim off semicolons
                strMedia = GS.trim(strMedia.trim().replace(/\}/g, '').toLowerCase(), ';');
                
                // replace shortcuts (lrg => 1200px)
                strMedia = strMedia.replace(/small|sml/g, '768px').replace(/medium|med/g, '992px').replace(/large|lrg/g, '1200px');
                
                arrLayouts = strMedia.split(';'); // seperate out layouts
                
                //console.log(strMedia, arrLayouts);
                
                if (arrTakenlayouts.indexOf(strMedia) === -1) {
                    arrTakenlayouts.push(strMedia);
                    intImageID = arrTakenlayouts.length - 1;
                    strCSS = '';
                    
                    for (i = 0, len = arrLayouts.length; i < len; i += 1) {
                        arrParts = arrLayouts[i].split('{');
                        strCurrentMedia = arrParts[0].trim() || 'all';
                        strDimensions = arrParts[1].trim();
                        
                        if (strDimensions.indexOf(',') === -1) {
                            strWidth = strDimensions;
                            strHeight = strDimensions;
                        } else {
                            arrParts = strDimensions.split(',');
                            strWidth = arrParts[0];
                            strHeight = arrParts[1];
                        }
                        
                        strCSS +=   '\n@media ' + strCurrentMedia + ' {\n' +
                                    '    gs-img.image-id-' + intImageID + ' { width:' + strWidth + '; height: ' + strHeight + '; }\n' +
                                    '}\n';
                    }
                    
                    //console.log(strCSS);
                    
                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* image #' + intImageID + ' */\n' + strCSS;
                    
                } else {
                    intImageID = arrTakenlayouts.indexOf(strMinWidth);
                }
                
                this.classList.add('image-id-' + intImageID);
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, addDataEvents, addDataAttributes
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    "use strict";
    addSnippet(
        '<gs-insert>',
        '<gs-insert>',
        'gs-insert src="${1:test.tpeople}">\n    ${2}\n</gs-insert>'
    );
    addElement('gs-insert', '#record_insert');

    window.designElementProperty_GSINSERT = function (selectedElement) {
        addDataAttributes('insert');
        addText('D', 'Additional&nbsp;Values', 'addin');
        addDataEvents('insert');
        addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    // the user needs to be able to set a custom websocket for this element,
    //      so this function will use an attribute to find out what socket to
    //      use (and it'll default to "GS.envSocket")
    function getSocket(element) {
        if (element.getAttribute('socket')) {
            return GS[element.getAttribute('socket')];
        }
        return GS.envSocket;
    }

    xtag.register('gs-insert', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {
            submit: function (callback) {
                var element = this;
                if (element.inProgress) { return; }
                element.inProgress = true;

                GS.triggerEvent(element, 'before_insert');
                GS.triggerEvent(element, 'onbefore_insert');
                if (element.hasAttribute('onbefore_insert')) {
                    new Function(element.getAttribute('onbefore_insert')).apply(element);
                }

                var srcParts = GS.templateWithQuerystring(element.getAttribute('src') || '').split('.');
                var strSchema = srcParts[0];
                var strObject = srcParts[1];
                var strSeqCols;
                var strPkCols;
                var strAddIn;
                var strColumns = '';
                var strResponseColumns;
                var strInsertRecord = '';
                var strInsertData;
                var arrElement;
                var arrKey;
                var arrValue;
                var i;
                var len;
                var strResponse;
                var parentSrcElement;

                // addin insert data
                strAddIn = GS.templateWithQuerystring(element.getAttribute('addin') || '');
                if (strAddIn) {
                    arrKey = GS.qryGetKeys(strAddIn);
                    arrValue = GS.qryGetVals(strAddIn);
                    if (!(arrKey.length === 1 && arrKey[0] === '')) {
                        i = 0;
                        len = arrKey.length;
                        while (i < len) {
                            strColumns += (strColumns ? '\t' : '') + GS.encodeForTabDelimited(arrKey[i]);
                            strInsertRecord += (strInsertRecord ? '\t' : '') + GS.encodeForTabDelimited(arrValue[i]);
                            i += 1;
                        }
                    }
                }

                // control insert data
                arrElement = xtag.query(element, '[column]');
                i = 0;
                len = arrElement.length;
                while (i < len) {
                    parentSrcElement = GS.findParentElement(arrElement[i].parentNode, '[src]');
                    if (
                        parentSrcElement === element &&
                        (
                            arrElement[i].value !== undefined &&
                            arrElement[i].value !== null &&
                            arrElement[i].value !== ''
                        )
                    ) {
                        strColumns += (strColumns ? '\t' : '') + GS.encodeForTabDelimited(arrElement[i].getAttribute('column'));
                        strInsertRecord += (strInsertRecord ? '\t' : '') + GS.encodeForTabDelimited(arrElement[i].value);
                    }
                    i += 1;
                }

                strPkCols = GS.templateWithQuerystring(element.getAttribute('pk') || 'id');
                strSeqCols = GS.templateWithQuerystring(element.getAttribute('seq') || '');
                strInsertData = (strColumns + '\n' + strInsertRecord);
                strResponseColumns = (strPkCols + (strPkCols ? '\t' : '') + strColumns);

                GS.requestInsertFromSocket(
                    getSocket(element),
                    strSchema,
                    strObject,
                    strResponseColumns,
                    strPkCols,
                    strSeqCols,
                    strInsertData,
                    // beginCallback
                    function () {},

                    // confirmCallback
                    function (data, error, ignore, commitFunction, rollbackFunction) { //transactionID
                        if (data !== 'TRANSACTION COMPLETED') {
                            if (!error) {
                                strResponse = data;
                                //commitFunction();
                            } else {
                                GS.webSocketErrorDialog(data);
                                rollbackFunction();
                            }
                        } else {
                            commitFunction();
                        }
                    },

                    // finalCallback
                    function (strType) { //, data, error
                        var arrColumns;
                        var arrCells;
                        var jsnRow = {};
                        var col_i;
                        var col_len;

                        if (strType === 'COMMIT') {
                            arrColumns = strResponseColumns.split('\t');
                            arrCells = (strResponse || '').split('\n')[0].split('\t');

                            if (arrColumns.length !== arrCells.length) {
                                throw 'gs-insert Error: Insert API call isn\'t returning correctly. (' + arrColumns.join(',') + ') -> (' + arrCells.join(',') + ')';
                            }

                            col_i = 0;
                            col_len = arrColumns.length;
                            while (col_i < col_len) {
                                jsnRow[GS.decodeFromTabDelimited(arrColumns[col_i])] = GS.decodeFromTabDelimited(arrCells[col_i]);
                                col_i += 1;
                            }

                            GS.triggerEvent(element, 'after_insert');
                            GS.triggerEvent(element, 'onafter_insert');
                            if (element.hasAttribute('onafter_insert')) {
                                new Function(element.getAttribute('onafter_insert')).apply(element);
                            }

                            if (typeof callback === 'function') {
                                callback(GS.decodeFromTabDelimited(arrCells[0]), jsnRow);
                            }
                        }
                        element.inProgress = false;
                    }
                );
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';
    addSnippet(
        '<gs-interval>',
        '<gs-interval>',
        'gs-interval column="${1:complete_time}"></gs-interval>'
    );
    addSnippet(
        '<gs-interval> With Label',
        '<gs-interval>',
        (
            'label for="${1:interval-insert-complete_time}">${2:Time to complete}:</label>\n' +
            '<gs-interval id="${1:interval-insert-complete_time}" column="${3:complete_time}"></gs-interval>'
        )
    );

    addElement('gs-interval', '#controls_interval');

    window.designElementProperty_GSINTERVAL = function () {
        addGSControlProps();
        addText('D', 'Hour Places', 'hour-places');
        addText('O', 'Column In QS', 'qs');
        addCheck('V', 'Time Picker', 'no-picker');
        addSelect('D', 'Unit', 'unit', [
            {"val": "", "txt": "Hours"},
            {"val": "minutes", "txt": "Minutes"},
            {"val": "seconds", "txt": "Seconds"}
        ]);
        addFlexProps();
    };
});


document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    //x attributes:
    //x      disabled:      copy to control element
    //x      tabindex:      move to control element
    //x      qs:            fill value from querystring, update value as querystring changes
    //x      value:         affects control value
    //x      no-picker:     affects innerHTML because it removes the picker button
    //x      unit
    //x      hour-places
    //x      minute-places
    //x      second-places

    //x accessors:
    //x      value:     returns text value
    //x      state:     returns text representation of state: "open" or "closed"

    //x methods:
    //x      open:   opens popup
    //x      close:  closes popup
    //x      toggle: toggles open and closed methods

    //x text editing behaviours:
    //x      text is divided by colons into portions
    //x      if value is deleted or empty, it displays with zeros

    //x events:
    //x      picker button click: runs "toggle" method
    //x      control keydown:
    //x          up arrow:    increase currently selected portion
    //x          down arrow:  previous minute
    //x          left arrow:  select previous portion
    //x          right arrow: select next portion

    //x dropdown behaviours:
    //x          if from control to bottom has enough room: popup below
    //x          else: popup above

    /*
        unit:
            hours: shows hours only
            minutes: shows minutes and hours
            seconds: shows seconds, minutes and hours
        hour-places: allows the dev to choose the maximum places in the hours
    */


    // #####################################################################################
    // ################################## EVENT  TRIGGERING ################################
    // #####################################################################################

    function handleChange(element) {
        valueUpdateAttribute(element);
        element.close();
        if (element.lastChangeValue !== element.getAttribute('value')) {
            GS.triggerEvent(element, 'change');
            element.lastChangeValue = element.getAttribute('value');
        }
    }

    // #####################################################################################
    // ################################## EVENT RETARGETING ################################
    // #####################################################################################

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();

        event.target.parentNode.setAttribute('value', event.target.value);
        handleChange(event.target.parentNode);
    }

    // re-target focus event from control to element
    function focusFunction(event) {
      //console.log('focusFunction');
        GS.triggerEvent(event.target.parentNode, 'focus');
        event.target.parentNode.classList.add('focus');
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'blur');
        event.target.parentNode.classList.remove('focus');
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseout);
        event.target.parentNode.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseover);
        event.target.parentNode.classList.add('hover');
    }


    // #####################################################################################
    // ######################################## VALUE ######################################
    // #####################################################################################

    //console.log('1***', translateValue(GS.stringToElement('<gs-interval unit="hours"></gs-interval>'), '5.255')); // 5 hours, 15 mins, 30 seconds
    //console.log('2***', translateValue(GS.stringToElement('<gs-interval unit="minutes"></gs-interval>'), '500.25')); // 8 hours, 20 mins, 15 seconds
    //console.log('3***', translateValue(GS.stringToElement('<gs-interval unit="seconds"></gs-interval>'), '5000')); // 1 hour, 23 mins, 20 seconds
    //console.log('4***', translateValue(GS.stringToElement('<gs-interval unit="seconds"></gs-interval>'), '0.03333333333333333')); // 2 mins

    function valueGetCurrentNumber(element) {
        var intValue = 0;
        if (element.internal.unit === 'minutes') {
            intValue += (element.internal.value.hours * 60);
            intValue += element.internal.value.minutes;
            //intValue += (element.internal.value.seconds / 60);
        } else if (element.internal.unit === 'seconds') {
            intValue += ((element.internal.value.hours * 60) * 60);
            intValue += (element.internal.value.minutes * 60);
            intValue += element.internal.value.seconds;
        } else {//hours
            intValue += element.internal.value.hours;
            //intValue += parseFloat((element.internal.value.minutes / 60).toFixed(5));
            //intValue += parseFloat(((element.internal.value.seconds / 60) / 60).toFixed(5));
        }

        return String(intValue);
    }

    function valueGetCurrentDisplay(element) {
        var strValue = '';
        var intHours = element.internal.value.hours;
        var intMinutes = element.internal.value.minutes;
        var intSeconds = element.internal.value.seconds;

        if (element.internal.places.hours > 0) {
            strValue += GS.leftPad(intHours || '', '0', element.internal.places.hours);
        }

        if (element.internal.places.minutes > 0) {
            strValue += (strValue ? ':' : '');
            strValue += GS.leftPad(intMinutes || '', '0', element.internal.places.minutes);
        }

        if (element.internal.places.seconds > 0) {
            strValue += (strValue ? ':' : '');
            strValue += GS.leftPad(intSeconds || '', '0', element.internal.places.seconds);
        }

        return String(strValue);
    }

    function valueUpdatePicker(element) {
        var currentValue = valueGetCurrentDisplay(element);
        var i;
        var len;
        var arrElements;
        var intColons = 0;

        //console.log('currentValue:', currentValue);
        //console.log('PLACES: ', element.internal.places.hours, element.internal.places.minutes, element.internal.places.seconds);

        // set value of the select boxes
        i = 0;
        len = element.internal.places.hours;
        arrElements = xtag.query(element.internal.picker, '[data-hour]');
        while (i < len) {
            //console.log('SELECTBOX HR: ', arrElements[i]);
            arrElements[i].value = currentValue[i];
            i += 1;
        }
        if (len > 0) {
            intColons += 1;
        }

        i = 0;
        len = element.internal.places.minutes;
        arrElements = xtag.query(element.internal.picker, '[data-minute]');
        while (i < len) {
            //console.log('SELECTBOX MIN: ', arrElements[i]);
            arrElements[i].value =
                    currentValue[element.internal.places.hours + intColons + i];
            i += 1;
        }
        if (len > 0) {
            intColons += 1;
        }

        i = 0;
        len = element.internal.places.seconds;
        arrElements = xtag.query(element.internal.picker, '[data-second]');
        while (i < len) {
            //console.log('SELECTBOX SEC: ', arrElements[i]);
            arrElements[i].value =
                    currentValue[element.internal.places.hours + element.internal.places.minutes + intColons + i];
            i += 1;
        }
    }

    function valueUpdateDisplay(element) {
        //console.trace('Fired');
        if (element.control) {
            element.control.value = valueGetCurrentDisplay(element);
        } else {
            element.textContent = valueGetCurrentDisplay(element);
        }
    }

    function valueUpdateAttribute(element) {
        element.setAttribute('value', valueGetCurrentNumber(element));
    }


    // #####################################################################################
    // ####################################### CONTROL #####################################
    // #####################################################################################

    function refreshControl(element) {
        var i;
        var len;
        var arrPassThroughAttributes;
        var strHTML;

        // clear out HTML
        element.innerHTML = '';

        // clear out element variables
        element.control = '';
        element.button = '';

        // if we are not disabled:
        if (!element.hasAttribute('disabled')) {
            // build HTML
            strHTML =
                    '<input class="control" gs-dynamic type="text" ' +
                    'autocorrect="off" autocapitalize="off" ' +
                    'autocomplete="off" spellcheck="false" />';
            if (!element.hasAttribute('no-picker')) {
                strHTML += '<gs-button class="time-picker-button" gs-dynamic inline icononly icon="hourglass-o" no-focus>Open Picker</gs-button>';
            }

            // set control HTML
            element.innerHTML = strHTML;

            // fill element variables
            element.control = element.children[0];
            if (element.hasAttribute('id')) {
                element.control.setAttribute('id', element.getAttribute('id') + '_control');
            }
            if (element.hasAttribute('aria-labelledby')) {
                element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
            }
            if (element.hasAttribute('title')) {
                element.control.setAttribute('title', element.getAttribute('title'));
            }
            element.button = element.children[1];

            // handle passthrough attributes
            arrPassThroughAttributes = ['name', 'autofocus', 'spellcheck', 'readonly'];

            i = 0;
            len = arrPassThroughAttributes.length;
            while (i < len) {
                if (element.hasAttribute(arrPassThroughAttributes[i])) {
                    element.control.setAttribute(arrPassThroughAttributes[i], element.getAttribute(arrPassThroughAttributes[i]) || '');
                }
                i += 1;
            }

            // move tabindex, tabindex is special because tabindex affects any displayed element it's used on
            if (element.hasAttribute('tabindex')) {
                element.oldTabIndex = element.getAttribute('tabindex');
                element.removeAttribute('tabindex');
            }

            if (element.oldTabIndex) {
                element.control.tabIndex = element.oldTabIndex;
            }

            // bind control retargeting
            element.control.removeEventListener('change', changeFunction);
            element.control.addEventListener('change', changeFunction);

            element.control.removeEventListener('focus', focusFunction);
            element.control.addEventListener('focus', focusFunction);

            element.control.removeEventListener('blur', blurFunction);
            element.control.addEventListener('blur', blurFunction);

            element.control.removeEventListener(evt.mouseout, mouseoutFunction);
            element.control.addEventListener(evt.mouseout, mouseoutFunction);

            element.control.removeEventListener(evt.mouseout, mouseoverFunction);
            element.control.addEventListener(evt.mouseover, mouseoverFunction);
        }

        // display value
        valueUpdateDisplay(element);
        //displayValue(element);
        //setValueDisplay(element, element.getAttribute('value'));
    }

    function valueSiphonAttribute(element) {
        var fltValue = parseFloat(element.getAttribute('value') || '0');

        var intHours;
        var intMinutes;
        var intSeconds;

        if (element.internal.unit === 'minutes') {
            intHours = Math.floor(fltValue / 60);
            fltValue = fltValue - (intHours * 60); // remove the hours from fltValue

            intMinutes = Math.floor(fltValue);
            fltValue = fltValue - Math.floor(fltValue); // remove the minutes from fltValue

            intSeconds = 0; //Math.floor(fltValue);

        } else if (element.internal.unit === 'seconds') {
            intHours = Math.floor((fltValue / 60) / 60);
            fltValue = fltValue - ((intHours * 60) * 60); // remove the hours from fltValue

            intMinutes = Math.floor(fltValue / 60);
            fltValue = fltValue - (intMinutes * 60); // remove the minutes from fltValue

            intSeconds = Math.round(fltValue);
        } else {
            intHours = Math.floor(fltValue);
            //fltValue = fltValue - intHours; // remove the hours from fltValue

            intMinutes = 0;//Math.floor(fltValue * 60);
            //fltValue = fltValue - (intMinutes / 60);

            intSeconds = 0;//Math.round((fltValue * 100) * 60);
        }

        if (isNaN(intHours)) {
            intHours = 0;
        }
        if (isNaN(intMinutes)) {
            intMinutes = 0;
        }
        if (isNaN(intSeconds)) {
            intSeconds = 0;
        }

        //console.log('siphon: ', element);
        //console.log('intHours:   ', intHours);
        //console.log('intMinutes: ', intMinutes);
        //console.log('intSeconds: ', intSeconds);

        element.internal.value.hours = intHours;
        element.internal.value.minutes = intMinutes;
        element.internal.value.seconds = intSeconds;
    }


    // #####################################################################################
    // ##################################### QUERYSTRING ###################################
    // #####################################################################################

    //function pushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString();
    //    var strQSCol = element.getAttribute('qs');

    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.setAttribute('value', GS.qryGetVal(strQueryString, strQSCol));
    //    }
    //}

    
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.setAttribute('value', strQSValue);
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    function handleQS(element) {
        //var strQSValue;

        if (!element.qsEventFunction) {
            element.qsEventFunction = function () {
                pushReplacePopHandler(element);
            };
        }

        window.removeEventListener('pushstate', element.qsEventFunction);
        window.removeEventListener('replacestate', element.qsEventFunction);
        window.removeEventListener('popstate', element.qsEventFunction);

        // handle "qs" attribute
        if (element.getAttribute('qs')) {
            pushReplacePopHandler(element);
            //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));

            //if (strQSValue !== '' || !element.getAttribute('value')) {
            //    element.setAttribute('value', strQSValue);
            //}

            window.addEventListener('pushstate', element.qsEventFunction);
            window.addEventListener('replacestate', element.qsEventFunction);
            window.addEventListener('popstate', element.qsEventFunction);
        }
    }

    // #####################################################################################
    // ################################### PARENT  ELEMENT #################################
    // #####################################################################################

    function prepElement(element) {
        element.internal = {};

        element.internal.value = {
            "hours": 0,
            "minutes": 0,
            "seconds": 0
        };

        element.internal.places = {
            "hours": 0,
            "minutes": 0,
            "seconds": 0
        };

        element.internal.unit = '';

        element.internal.picker = '';
    }

    function siphonElement(element) {
        // siphon the unit
        element.internal.unit = element.getAttribute('unit') || '';
        element.internal.unit = element.internal.unit.toLowerCase();
        element.internal.unit = element.internal.unit || 'minutes';

        if (element.internal.unit !== 'hours' &&
                element.internal.unit !== 'minutes' &&
                element.internal.unit !== 'seconds') {
            element.internal.unit = 'minutes';
            console.warn(
                'gs-interval Warning: invalid "unit" attribute. ' +
                        'Please use "hours", "minutes" or "seconds".  ' +
                        'Defaulting "unit" to "minutes"',
                element
            );
        }

        // get the place settings
        var intHourPlaces = parseInt(element.getAttribute('hour-places'), 10);
        var intMinutePlaces = 0;
        var intSecondPlaces = 0;

        // default place settings
        if (isNaN(intHourPlaces)) {
            intHourPlaces = 3;
        }
        if (element.internal.unit === 'minutes' || element.internal.unit === 'seconds') {
            intMinutePlaces = 2;
        }
        if (element.internal.unit === 'seconds') {
            intSecondPlaces = 2;
        }

        element.internal.places.hours = intHourPlaces;
        element.internal.places.minutes = intMinutePlaces;
        element.internal.places.seconds = intSecondPlaces;

        // siphon the value attribute
        // get hours/minutes/seconds from value
        valueSiphonAttribute(element);
    }

    // #####################################################################################
    // ###################################### LIFECYCLE ####################################
    // #####################################################################################

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value) {
                element.setAttribute('value', element.value);
                delete element.value;
            }
        }
    }

    function findFor(element) {
        var forElem;
        //console.log(element, element.previousElementSibling)
        if (element.previousElementSibling && element.previousElementSibling.tagName.toUpperCase() == 'LABEL'
            && element.previousElementSibling.hasAttribute('for')
            && element.previousElementSibling.getAttribute('for') == element.getAttribute('id')
        ) {
            forElem = element.previousElementSibling;
        } else if (xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]').length > 0) {
            forElem = xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]')[0];
        }
        //console.log(forElem);
        if (forElem) {
            forElem.setAttribute('for', element.getAttribute('id') + '_control');
            if (element.control) {
                element.control.setAttribute('id', element.getAttribute('id') + '_control');
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }
            }
        }
        
        /*
            if (element.hasAttribute('id')) {
                findFor(element);
            }
        // please ensure that if the element has an id it is given an id
                if (element.hasAttribute('id')) {
                    element.control.setAttribute('id', element.getAttribute('id') + '_control');
                }
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }
        */
    }

    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.innerState = 'closed';

                prepElement(element);
                siphonElement(element);
                saveDefaultAttributes(element);
                refreshControl(element);

                if (element.getAttribute('qs')) {
                    handleQS(element);
                }

                element.lastChangeValue = element.getAttribute('value');
            }
            
            if (element.hasAttribute('id')) {
                findFor(element);
            }
        }
    }

    // ######################################################################################
    // ##################################### REGISTRATION ###################################
    // ######################################################################################

    xtag.register('gs-interval', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(element);
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);

                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'disabled' || strAttrName === 'no-picker' || strAttrName === 'tabindex') {
                        siphonElement(element);
                        refreshControl(element);

                    } else if (strAttrName === 'qs') {
                        handleQS(element);

                    } else if (strAttrName === 'value' && element.inserted) {
                        ////displayValue(element);
                        //siphonElement(element);
                        //displayValue(element);
                        ////setValueDisplay(element, newValue);
                        valueSiphonAttribute(element);
                        valueUpdateDisplay(element);

                        if (element.innerState === 'open') {
                            valueUpdatePicker(element);
                        }
                    }
                }
            }
        },
        events: {
            'click': function (event) {
                var element = this;
                if (event.target === element.button) {
                    element.toggle();
                }
            },

            'mouseup': function (event) {
                var element = this;
                var strValue = element.control.value;
                var jsnTextSelection;
                var intCursor;
                var i;
                var len;
                var arrDelimiterIndexes;
                var intSection;

                if (!element.hasAttribute('readonly')) {
                    element.numberOfCharsTyped = 0;
    
                    jsnTextSelection = GS.getInputSelection(element.control);
    
                    i = 0;
                    len = strValue.length;
                    arrDelimiterIndexes = [0];
                    while (i < len) {
                        if (strValue[i] === ':') {
                            arrDelimiterIndexes.push(i);
                        }
                        i += 1;
                    }
                    arrDelimiterIndexes.push(strValue.length);
    
                    event.preventDefault();
    
                    intCursor = jsnTextSelection.start;
    
                    // find out what section the cursor is in
                    i = 1;
                    len = arrDelimiterIndexes.length;
                    while (i < len) {
                        if (intCursor >= arrDelimiterIndexes[i - 1] && intCursor <= arrDelimiterIndexes[i]) {
                            intSection = i;
                            break;
                        }
                        i += 1;
                    }
    
                    // select the section of the value that the cursor is in
                    if (intSection === 1) {
                        GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1], arrDelimiterIndexes[intSection]);
                    } else {
                        GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1] + 1, arrDelimiterIndexes[intSection]);
                    }
                }
            },

            'keydown': function (event) { // don't use the "input" event, doesn't work for this
              //console.log('keydown');
                var element = this;
                var strValue = element.control.value;
                var intKeyCode = (event.keyCode || event.which);

                var jsnTextSelection;
                var arrDelimiterIndexes;
                var i;
                var len;
                var intCursor;
                var intSection;
                var strPlace;
                var strChar;
                var strSection;

                if (!element.hasAttribute('readonly')) {
                    jsnTextSelection = GS.getInputSelection(element.control);
    
                    i = 0;
                    len = strValue.length;
                    arrDelimiterIndexes = [0];
                    while (i < len) {
                        if (strValue[i] === ':') {
                            arrDelimiterIndexes.push(i);
                        }
                        i += 1;
                    }
                    arrDelimiterIndexes.push(strValue.length);
    
                    // get cursor position
                    intCursor = jsnTextSelection.start;
    
                    // find out what section the cursor is in
                    i = 1;
                    len = arrDelimiterIndexes.length;
                    while (i < len) {
                        if (intCursor >= arrDelimiterIndexes[i - 1] && intCursor <= arrDelimiterIndexes[i]) {
                            intSection = i;
                            break;
                        }
                        i += 1;
                    }
    
                    // if key was an arrow
                    if (intKeyCode >= 37 && intKeyCode <= 40) {
                        element.numberOfCharsTyped = 0;
                        event.preventDefault();
    
                        // left     37
                        // top      38
                        // right    39
                        // down     40
    
                        // handle/right arrows moving the cursor
                        if (intKeyCode === 37) {
                            intSection -= 1;
                            intSection = Math.max(intSection, 1);
                        } else if (intKeyCode === 39) {
                            intSection += 1;
                            intSection = Math.min(intSection, arrDelimiterIndexes.length - 1);
                        }
    
                        // select the section of the value that the cursor is in
                        if (intSection === 1) {
                            GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1], arrDelimiterIndexes[intSection]);
                        } else {
                            GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1] + 1, arrDelimiterIndexes[intSection]);
                        }
    
                        // find out what section that the cursor is in (hours, minutes or seconds)
                        if (intSection === 0 || intSection === 1) {
                            strPlace = 'hours';
                        } else if (intSection === 2) {
                            strPlace = 'minutes';
                        } else if (intSection === 3 || intSection === 4) {
                            strPlace = 'seconds';
                        }
    
                        // update text selection variable
                        jsnTextSelection = GS.getInputSelection(element.control);
    
                        // handle up and down arrows incrementing/decrementing
                        //      the value of the currently selected section
                        if (intKeyCode === 38) { // up
                            if (strPlace === 'hours') {
                                element.internal.value.hours += 1;
                            } else if (strPlace === 'minutes') {
                                element.internal.value.minutes += 1;
                            } else if (strPlace === 'seconds') {
                                element.internal.value.seconds += 1;
                            }
    
                            if (String(element.internal.value.hours).length > element.internal.places.hours) {
                                element.internal.value.hours = parseInt(
                                    '999999999999999'.substring(0, element.internal.places.hours),
                                    10
                                );
                            }
                            if (element.internal.value.seconds > 59) {
                                element.internal.value.minutes += 1;
                                element.internal.value.seconds = 0;
                            }
                            if (element.internal.value.minutes > 59) {
                                element.internal.value.hours += 1;
                                element.internal.value.minutes = 0;
                            }
    
                        } else if (intKeyCode === 40) { // down
                            if (strPlace === 'hours') {
                                element.internal.value.hours -= 1;
                            } else if (strPlace === 'minutes') {
                                element.internal.value.minutes -= 1;
                            } else if (strPlace === 'seconds') {
                                element.internal.value.seconds -= 1;
                            }
    
                            if (element.internal.value.seconds < 0) {
                                if (element.internal.value.minutes > 0) {
                                    element.internal.value.minutes -= 1;
                                    element.internal.value.seconds = 59;
                                } else if (element.internal.value.hours > 0) {
                                    element.internal.value.hours -= 1;
                                    element.internal.value.minutes = 59;
                                    element.internal.value.seconds = 59;
                                } else {
                                    element.internal.value.seconds = 0;
                                }
                            }
                            if (element.internal.value.minutes < 0) {
                                if (element.internal.value.hours > 0) {
                                    element.internal.value.minutes = 59;
                                    element.internal.value.hours -= 1;
                                } else {
                                    element.internal.value.minutes = 0;
                                }
                            }
                            if (element.internal.value.hours < 0) {
                                element.internal.value.hours = 0;
                            }
                        }
    
                        if (intKeyCode === 38 || intKeyCode === 40) {
                            //trinkleValueDown(element);
                            //displayValue(element);
                            valueUpdateAttribute(element);
                            GS.setInputSelection(element.control, jsnTextSelection.start, jsnTextSelection.end);
                        }
    
                    // if key was a number
                    } else if ((intKeyCode >= 48 && intKeyCode <= 57) || (intKeyCode >= 96 && intKeyCode <= 105)) {
                        element.numberOfCharsTyped = element.numberOfCharsTyped || 0;
                        event.preventDefault();
    
                        // get the character that was typed
                        strChar = String.fromCharCode(intKeyCode);
                        if (intKeyCode === 96) { strChar = '0'; }
                        if (intKeyCode === 97) { strChar = '1'; }
                        if (intKeyCode === 98) { strChar = '2'; }
                        if (intKeyCode === 99) { strChar = '3'; }
                        if (intKeyCode === 100) { strChar = '4'; }
                        if (intKeyCode === 101) { strChar = '5'; }
                        if (intKeyCode === 102) { strChar = '6'; }
                        if (intKeyCode === 103) { strChar = '7'; }
                        if (intKeyCode === 104) { strChar = '8'; }
                        if (intKeyCode === 105) { strChar = '9'; }
                        //console.log(intKeyCode, strChar);
                        // select the section of the value that the cursor is in
                        if (intSection === 1) {
                            GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1], arrDelimiterIndexes[intSection]);
                        } else {
                            GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1] + 1, arrDelimiterIndexes[intSection]);
                        }
    
                        // find out what section that the cursor is in (hours, minutes or seconds)
                        if (intSection === 0 || intSection === 1) {
                            strPlace = 'hours';
                        } else if (intSection === 2) {
                            strPlace = 'minutes';
                        } else if (intSection === 3 || intSection === 4) {
                            strPlace = 'seconds';
                        }
    
                        // update text selection variable
                        jsnTextSelection = GS.getInputSelection(element.control);
    
                        // when you type in a number,
                        //      if no data is set saying "this is where the typing begins":
                        //              insert the number as the first character of the section
                        //              after that set data to say where the typing begins
                        //      no matter what is typed: stay in the same section
                        strSection = strValue.substring(jsnTextSelection.start, jsnTextSelection.end);
    
                        //
                        strSection = strSection + strChar;
                        strSection = strSection.slice(1);
                        // strSection =
                        //         strSection.substring(0, element.numberOfCharsTyped) +
                        //         strChar +
                        //         strSection.substring(element.numberOfCharsTyped + 1);
    
                        strValue =
                                strValue.substring(0, jsnTextSelection.start) +
                                strSection +
                                strValue.substring(jsnTextSelection.end);
                                
                        element.numberOfCharsTyped += 1;
    
                        if (element.numberOfCharsTyped === strSection.length) {
                            element.numberOfCharsTyped = 0;
                        }
    
                        if (strPlace === 'hours') {
                            element.internal.value.hours = parseInt(strSection, 10);
                        }
                        if (strPlace === 'minutes') {
                            element.internal.value.minutes = parseInt(strSection, 10);
                        }
                        if (strPlace === 'seconds') {
                            element.internal.value.seconds = parseInt(strSection, 10);
                        }
    
                        //console.log(element.control.value);
                        
                        if (strValue !== element.control.value) {
                            //trinkleValueDown(element);
                            //displayValue(element);
                            element.control.value = strValue;//valueUpdateAttribute(element);
                            GS.setInputSelection(element.control, jsnTextSelection.start, jsnTextSelection.end);
                        }
                        //console.log(element.control.value);
                        //console.log(strValue, element.control.value);
                    } else if (intKeyCode === 13) {
                        element.numberOfCharsTyped = 0;
                        event.preventDefault();
                        handleChange(element);
                    } else if (intKeyCode !== 9 && event.ctrlKey === false && event.metaKey === false) {
                        element.numberOfCharsTyped = 0;
                        event.preventDefault();
                    }
                }
            },
            'blur': function () {// don't use 'focusout', it doesn't work on firefox
                var element = this;
                if (element.innerState === 'closed') {
                    handleChange(element);
                }
            }
        },
        accessors: {
            value: {
                get: function () {
                    return this.getAttribute('value');
                },
                set: function (newValue) {
                    this.setAttribute('value', newValue);
                }
            },
            state: {
                get: function () {
                    return this.innerState;
                },
                set: function (newValue) {
                    var element = this;
                    if (newValue === 'open') {
                        element.open();
                    } else {
                        element.close();
                    }
                }
            }
        },
        methods: {
            focus: function () {
                this.control.focus();
            },

            open: function () {
                var element = this;
                var pickerContainerElement;
                var overlayElement;
                var pickerElement;
                var handleLook;
                var strHTML;
                var i;
                var len;
                var arrElements;

                if (element.innerState === 'closed') {
                    element.innerState = 'open';
                    element.lastClosedValue = element.getAttribute('value');

                    // if we are not on a touch device: focus control
                    if (!evt.touchDevice) {
                        element.control.focus();
                        GS.setInputSelection(element.control, 0, element.control.value.length);
                    }

                    // create picker elements
                    pickerContainerElement = document.createElement('div');
                    pickerContainerElement.classList.add('gs-interval-time-picker-container');

                    overlayElement = document.createElement('div');
                    overlayElement.classList.add('gs-interval-time-picker-overlay');

                    pickerElement = document.createElement('div');
                    pickerElement.classList.add('gs-interval-time-picker');
                    element.internal.picker = pickerElement;

                    // save picker container
                    element.pickerContainerElement = pickerContainerElement;

                    // append picker elements
                    pickerContainerElement.appendChild(overlayElement);
                    pickerContainerElement.appendChild(pickerElement);

                    document.body.appendChild(pickerContainerElement);

                    // fill picker popup
                    strHTML = '';
                    strHTML += '<div class="time-inner-container">';

                    i = 0;
                    len = element.internal.places.hours;
                    while (i < len) {
                        strHTML +=
                                '<select class="gs-interval-hour" data-hour="' + i + '">' +
                                '    <option value="0">&nbsp;0</option>' +
                                '    <option value="1">&nbsp;1</option>' +
                                '    <option value="2">&nbsp;2</option>' +
                                '    <option value="3">&nbsp;3</option>' +
                                '    <option value="4">&nbsp;4</option>' +
                                '    <option value="5">&nbsp;5</option>' +
                                '    <option value="6">&nbsp;6</option>' +
                                '    <option value="7">&nbsp;7</option>' +
                                '    <option value="8">&nbsp;8</option>' +
                                '    <option value="9">&nbsp;9</option>' +
                                '</select>';
                        i += 1;
                    }

                    if (element.internal.places.hours > 0 && element.internal.places.minutes > 0) {
                        strHTML += '<span class="colon">:</span>';
                    }

                    i = 0;
                    len = element.internal.places.minutes;
                    while (i < len) {
                        strHTML +=
                                '<select class="gs-interval-minute" data-minute="' + i + '">' +
                                '    <option value="0">&nbsp;0</option>' +
                                '    <option value="1">&nbsp;1</option>' +
                                '    <option value="2">&nbsp;2</option>' +
                                '    <option value="3">&nbsp;3</option>' +
                                '    <option value="4">&nbsp;4</option>' +
                                '    <option value="5">&nbsp;5</option>';

                        if (i > 0) {
                            strHTML +=
                                    '<option value="6">&nbsp;6</option>' +
                                    '<option value="7">&nbsp;7</option>' +
                                    '<option value="8">&nbsp;8</option>' +
                                    '<option value="9">&nbsp;9</option>';
                        }

                        strHTML +=
                                '</select>';
                        i += 1;
                    }

                    if (element.internal.places.minutes > 0 && element.internal.places.seconds > 0) {
                        strHTML += '<span class="colon">:</span>';
                    }

                    i = 0;
                    len = element.internal.places.seconds;
                    while (i < len) {
                        strHTML +=
                                '<select class="gs-interval-second" data-second="' + i + '">' +
                                '    <option value="0">&nbsp;0</option>' +
                                '    <option value="1">&nbsp;1</option>' +
                                '    <option value="2">&nbsp;2</option>' +
                                '    <option value="3">&nbsp;3</option>' +
                                '    <option value="4">&nbsp;4</option>' +
                                '    <option value="5">&nbsp;5</option>';

                        if (i > 0) {
                            strHTML +=
                                    '<option value="6">&nbsp;6</option>' +
                                    '<option value="7">&nbsp;7</option>' +
                                    '<option value="8">&nbsp;8</option>' +
                                    '<option value="9">&nbsp;9</option>';
                        }

                        strHTML +=
                                '</select>';
                        i += 1;
                    }

                    strHTML += '</div>';
                    pickerElement.innerHTML = strHTML;


                    // set picker value
                    valueUpdatePicker(element);

                    // bind picker click
                    overlayElement.addEventListener('click', function () {
                        element.close();
                    });

                    pickerElement.addEventListener('change', function () {//event
                        //var arrElements;
                        //var i;
                        //var len;
                        var newValue = 0;
                        var strCurrentValue;

                        if (element.internal.unit === 'hours') {
                            i = 0;
                            len = element.internal.places.hours;
                            arrElements = xtag.query(pickerElement, '[data-hour]');
                            strCurrentValue = '';
                            while (i < len) {
                                strCurrentValue += arrElements[i].value;
                                i += 1;
                            }
                            if (arrElements.length > 0) {
                                newValue += parseInt(strCurrentValue, 10);
                            }

                            //i = 0;
                            //len = element.internal.places.minutes;
                            //arrElements = xtag.query(pickerElement, '[data-minute]');
                            //strCurrentValue = '';
                            //while (i < len) {
                            //    strCurrentValue += arrElements[i].value;
                            //    i += 1;
                            //}
                            //if (arrElements.length > 0) {
                            //    newValue += (parseInt(strCurrentValue, 10) / 60);
                            //}

                            //i = 0;
                            //len = element.internal.places.seconds;
                            //arrElements = xtag.query(pickerElement, '[data-second]');
                            //strCurrentValue = '';
                            //while (i < len) {
                            //    strCurrentValue += arrElements[i].value;
                            //    i += 1;
                            //}
                            //if (arrElements.length > 0) {
                            //    newValue += ((parseInt(strCurrentValue, 10) / 60) / 60);
                            //}
                        }
                        if (element.internal.unit === 'minutes') {
                            i = 0;
                            len = element.internal.places.hours;
                            arrElements = xtag.query(pickerElement, '[data-hour]');
                            strCurrentValue = '';
                            while (i < len) {
                                strCurrentValue += arrElements[i].value;
                                i += 1;
                            }
                            if (arrElements.length > 0) {
                                newValue += parseInt(strCurrentValue, 10) * 60;
                            }

                            i = 0;
                            len = element.internal.places.minutes;
                            arrElements = xtag.query(pickerElement, '[data-minute]');
                            strCurrentValue = '';
                            while (i < len) {
                                strCurrentValue += arrElements[i].value;
                                i += 1;
                            }
                            if (arrElements.length > 0) {
                                newValue += parseInt(strCurrentValue, 10);
                            }

                            //i = 0;
                            //len = element.internal.places.seconds;
                            //arrElements = xtag.query(pickerElement, '[data-second]');
                            //strCurrentValue = '';
                            //while (i < len) {
                            //    strCurrentValue += arrElements[i].value;
                            //    i += 1;
                            //}
                            //if (arrElements.length > 0) {
                            //    newValue += ((parseInt(strCurrentValue, 10) * 60) * 60);
                            //}
                        }
                        if (element.internal.unit === 'seconds') {
                            i = 0;
                            len = element.internal.places.hours;
                            arrElements = xtag.query(pickerElement, '[data-hour]');
                            strCurrentValue = '';
                            while (i < len) {
                                strCurrentValue += arrElements[i].value;
                                i += 1;
                            }
                            if (arrElements.length > 0) {
                                newValue += ((parseInt(strCurrentValue, 10) * 60) * 60);
                            }

                            i = 0;
                            len = element.internal.places.minutes;
                            arrElements = xtag.query(pickerElement, '[data-minute]');
                            strCurrentValue = '';
                            while (i < len) {
                                strCurrentValue += arrElements[i].value;
                                i += 1;
                            }
                            if (arrElements.length > 0) {
                                newValue += parseInt(strCurrentValue, 10) * 60;
                            }

                            i = 0;
                            len = element.internal.places.seconds;
                            arrElements = xtag.query(pickerElement, '[data-second]');
                            strCurrentValue = '';
                            while (i < len) {
                                strCurrentValue += arrElements[i].value;
                                i += 1;
                            }
                            if (arrElements.length > 0) {
                                newValue += parseInt(strCurrentValue, 10);
                            }
                        }

                        element.setAttribute('value', newValue);
                        //trinkleValueDown(element);
                        //setValueDisplay(element, newValue);
                    });

                    // handle/bind positioning and look
                    handleLook = function () {
                        var positionData;
                        var intPopupHeight;
                        var intPopupWidth;

                        if (pickerContainerElement.parentNode !== document.body) {
                            window.removeEventListener('resize', handleLook);
                            window.removeEventListener('orientationchange', handleLook);
                            return;
                        }

                        // clear current styles
                        pickerElement.style.top = '';
                        pickerElement.style.left = '';
                        pickerElement.style.marginTop = '';
                        //pickerContainerElement.classList.remove('modal');

                        // get position/size data
                        positionData = GS.getElementPositionData(element);
                        intPopupHeight = pickerElement.offsetHeight;
                        intPopupWidth = pickerElement.offsetWidth;

                        // if from control to bottom has enough room: popup below
                        if (positionData.intRoomBelow > intPopupHeight) {
                            pickerElement.style.top = (positionData.objElementOffset.top + positionData.intElementHeight) + 'px';

                        // else: popup above
                        } else {
                            pickerElement.style.top = (positionData.objElementOffset.top - intPopupHeight) + 'px';
                        }

                        pickerElement.style.left =
                                (((positionData.objElementOffset.left + positionData.intElementWidth) - intPopupWidth) - 4) + 'px';
                    };

                    handleLook();

                    window.addEventListener('resize', handleLook);
                    window.addEventListener('orientationchange', handleLook);
                }
            },

            close: function () {
                var element = this;

                if (element.innerState === 'open') {
                    element.innerState = 'closed';
                    if (element.pickerContainerElement) {
                        document.body.removeChild(element.pickerContainerElement);
                        element.pickerContainerElement = '';
                    }
                    if (element.getAttribute('value') !== element.lastClosedValue) {
                        handleChange(element);
                    }
                }
            },

            toggle: function () {
                var element = this;

                if (element.innerState === 'open' || element.hasAttribute('readonly') || element.hasAttribute('disabled')) {
                    element.close();
                } else {
                    element.open();
                }
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';

    addSnippet('<gs-jumbo>', '<gs-jumbo>', 'gs-jumbo>\n    ${0}\n</gs-jumbo>');
    addElement('gs-jumbo', '#layout_container_jumbo');

    window.designElementProperty_GSJUMBO = function () {
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    xtag.register('gs-jumbo', {});
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, addFocusEvents, addDataAttributes
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    "use strict";
    addSnippet(
        'Static Template <gs-listbox>',
        '<gs-listbox>',
        (
            'gs-listbox>\n' +
            '    <template>\n' +
            '        <table>\n' +
            '            <tbody>\n' +
            '                <tr value="${1}">\n' +
            '                    <td>${0}</td>\n' +
            '                </tr>\n' +
            '            </tbody>\n' +
            '        </table>\n' +
            '    </template>\n' +
            '</gs-listbox>'
        )
    );
    addSnippet(
        'Custom Template <gs-listbox>',
        '<gs-listbox>',
        (
            'gs-listbox src="${1:test.tpeople}">\n' +
            '    <template>\n' +
            '        <table>\n' +
            '            <tbody>\n' +
            '                <tr value="{{! row.id }}">\n' +
            '                    <td>{{! row.${3:name} }}</td>\n' +
            '                </tr>\n' +
            '            </tbody>\n' +
            '        </table>\n' +
            '    </template>\n' +
            '</gs-listbox>'
        )
    );
    addSnippet(
        'Dynamic Template <gs-listbox>',
        '<gs-listbox>',
        'gs-listbox src="${1:test.tpeople}"></gs-listbox>'
    );
    addSnippet(
        '<gs-listbox>',
        '<gs-listbox>',
        'gs-listbox src="${1:test.tpeople}"></gs-listbox>'
    );
    addElement('gs-listbox', '#controls_listbox');

    window.designElementProperty_GSLISTBOX = function () {
        addGSControlProps();
        addDataAttributes('select');
        addText('V', 'Hide Columns', 'hide');
        addText('O', 'Column In QS', 'qs');
        addFocusEvents();
        addCheck('D', 'Dissallow&nbsp;Select', 'no-select');
        addCheck('V', 'Letter&nbsp;Scrollbar', 'letter-scrollbar');
        addCheck('V', 'Letter Dividers', 'letter-dividers');
        addText('O', 'Refresh On QS Columns', 'refresh-on-querystring-values');
        addCheck('O', 'Refresh On QS Change', 'refresh-on-querystring-change');
        addFlexProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    // removes selected class from old selected records adds class selected to record
    function highlightRecord(element, record) { //TODO: XLD
        var i;
        var len;
        var arrSelectedTrs;

        if (element.tableElement && xtag.queryChildren(element.tableElement, 'tbody')[0]) {
            // clear previous selection
            arrSelectedTrs = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected]');

            i = 0;
            len = arrSelectedTrs.length;
            while (i < len) {
                arrSelectedTrs[i].removeAttribute('selected');
                arrSelectedTrs[i].removeAttribute('aria-selected');
                i += 1;
            }
        }

        // select/highlight the record that was provided
        if (record) {
            if (record.length >= 0) {

                i = 0;
                len = record.length;
                while (i < len) {
                    record[i].setAttribute('selected', '');
                    record[i].setAttribute('aria-selected', 'true');
                    i += 1;
                }
            } else {
                record.setAttribute('selected', '');
                var strHiddenValue = record.firstElementChild.textContent || ' ';

                //element.hiddenFocusControl.value = strHiddenValue || 'blank';
                //element.hiddenFocusControl.setAttribute('value', strHiddenValue || ' ');
                element.hiddenFocusControl.value = ',';
                element.hiddenFocusControl.setAttribute('aria-label', strHiddenValue || ' ');
                //GS.setInputSelection(element.hiddenFocusControl, 0, strHiddenValue.length);
                record.setAttribute('aria-selected', 'true');
                element.scrollContainer.setAttribute(
                    'aria-activedescendant',
                    'box-list-' + element.internal.id + '-item-' + (parseInt(record.getAttribute('data-record_no'), 10) - 1)
                );
            }
        }
    }

    // loops through the records and finds a record using the parameter
    function findRecordFromValue(element, searchValue) {
        var i;
        var len;
        var matchedRecord;
        var arrTrs;
        var strSearchString;

        if (element.tableElement && xtag.queryChildren(element.tableElement, 'tbody')[0]) {
            arrTrs = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr');
            strSearchString = String(searchValue);
            // #######################################################################################################################
            // #######################################################################################################################
            // #######################################################################################################################
            // #######################################################################################################################
            // #######################################################################################################################
            // #######################################################################################################################
            // #######################################################################################################################
            // ############## if this function is trying to find a td that doesn't exist uncomment the next three lines ##############
            // #######################################################################################################################
            // #######################################################################################################################
            // #######################################################################################################################
            // #######################################################################################################################
            // #######################################################################################################################
            // #######################################################################################################################
            // #######################################################################################################################
            // uncommented on 2022-02-02 by Nunzio
            // FTA was having an issue on a search screen that uses a Listbox
            // allegedly this was made redundant by using a thead, but it seems to still be necessary
            // looking at the page in question, there is a thead, but the first row of the tbody
            // still has the headers
            if (arrTrs[0]
                && arrTrs[0].children[0]
                && arrTrs[0].children[0].nodeName.toUpperCase() === 'TH') {
                arrTrs.splice(0,1);
            }
            // search exact text and search both the value attribute (if present) and the first td text
            i = 0;
            len = arrTrs.length;
            while (i < len) {
                if (arrTrs[i].getAttribute('value') === strSearchString || xtag.queryChildren(arrTrs[i], 'td')[0].textContent === strSearchString) {
                    matchedRecord = arrTrs[i];
                    break;
                }
                i += 1;
            }
        }

        return matchedRecord;
    }

    function getTRFromTarget(element) {
        var currentElement = element;

        while (currentElement.nodeName !== 'TR') {
            currentElement = currentElement.parentNode;
        }

        return currentElement;
    }

    function addTableAria(element) {
        var elemTable = xtag.query(element, 'table')[0];
        //var elemThead = xtag.query(elemTable, 'thead')[0];
        var elemTbody = xtag.query(elemTable, 'tbody')[0];
        //var elemTheadTRs = elemThead ? xtag.query(elemThead, 'tr') : null;
        var elemTbodyTRs = xtag.query(elemTbody, 'tr');
        //var cellElements;
        var i;
        var len;
        //var cell_i;
        //var cell_len;

        //elemTable.setAttribute('role', 'grid');
        //elemTheadTRs[0].setAttribute('role', 'row');

        //cellElements = xtag.toArray(elemTheadTRs[0].children);
        //i = 0;
        //len = cellElements.length;
        //while (i < len) {
        //    cellElements[i].setAttribute('role', '');

        //    i += 1;
        //}

        i = 0;
        len = elemTbodyTRs.length;
        while (i < len) {
            elemTbodyTRs[i].setAttribute('id', 'box-list-' + element.internal.id + '-item-' + i);

            elemTbodyTRs[i].setAttribute('role', 'option');
            if (elemTbodyTRs[i].children[0].nodeName === 'TH') {
                elemTbodyTRs[i].setAttribute('aria-label', elemTbodyTRs[i].children[1].textContent);
            } else {
                elemTbodyTRs[i].setAttribute('aria-label', elemTbodyTRs[i].children[0].textContent);
            }

            //cellElements = xtag.toArray(elemTbodyTRs[0].children);
            //cell_i = 0;
            //cell_len = cellElements.length;
            //while (cell_i < cell_len) {
            //    cellElements[i].setAttribute('role', '');

            //    cell_i += 1;
            //}

            i += 1;
        }
    }

    //boladd should be true if event.metaKey is true

    //if boladd is true:
    //  selected records that were clicked become non-selected
    //  non-select records that were clicked become selected

    // if bolShift is true and not negative:
    //  select from element.lastClicked to the clicked record
    // if bolShift is true and negative:
    //  de-select from element.lastClicked to the clicked record
    //
    //

    function selectRecord(element, handle, bolChange, bolAdd, strType, bolShift) {
        var i;
        var len;
        var arrRecords;
        var record;
        var arrSelectedRecords;
        var clickFrom;
        var newClicked;
        var arrOrigins;
        var arrAllRecords;
        var bolDeselect;
        var intDistanceBetween;
        var intSelected;
        var bolRemoveClicked;
        var arrRecordsToAffect;

        if (!element.hasAttribute('no-select') && element.tableElement) {
            arrSelectedRecords = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected], tr[selected-secondary]');

            if (!bolAdd && !bolShift) {
                arrRecords = xtag.query(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr');
                element.secondLastClicked = null;
                i = 0;
                len = arrRecords.length;
                while (i < len) {
                    arrRecords[i].removeAttribute('selected');
                    arrRecords[i].removeAttribute('aria-selected');
                    if (arrRecords[i].classList.contains('originTR')) {
                        arrRecords[i].classList.remove('originTR');
                    }
                    i += 1;
                }
            }

            if (typeof handle === 'string' || typeof handle === 'number') {
                record = findRecordFromValue(element, handle);
                if (!record && handle !== '') {
                    console.warn('Listbox warning: record not found' + (typeof handle === 'string' ? ': "' + handle + '"' : ''));
                }
            } else {
                record = handle;
            }

            if (element.hasAttribute('multi-select')) {
                if (handle.length >= 0) {
                    record = record;
                } else {
                    record = [record];
                }
            }

            if (bolShift && strType === 'down') {
                arrOrigins = xtag.query(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr.originTR');
                arrAllRecords = xtag.query(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr');
                intDistanceBetween = 0;
                intSelected = 0;
                bolRemoveClicked = false;

                //if we have a lastClicked
                //    use that
                //else if we have an originTR
                //    use that
                //else if there is one selected record
                //    use that
                if (element.lastClicked) {
                    clickFrom = element.lastClicked;
                } else if (arrOrigins.length === 1) {
                    clickFrom = arrOrigins[0].getAttribute('data-record_no');
                } else if (arrSelectedRecords.length === 1) {
                    clickFrom = arrSelectedRecords[0].getAttribute('data-record_no');
                }

                //get the record that was just clicked
                if (typeof handle === 'object' && handle.tagName) {
                    newClicked = parseInt(handle.getAttribute('data-record_no'), 10);
                }

                if (newClicked) {
                    //find how many are selected between clickFrom and newClicked
                    if (clickFrom < newClicked) {
                        i = clickFrom;
                        len = newClicked;
                        while (i < len) {
                            if (handle.hasAttribute('selected') || handle.hasAttribute('selected-secondary')) {
                                intSelected += 1;
                            }
                            i += 1;
                        }
                    } else {
                        i = newClicked - 1;
                        len = clickFrom - 1;
                        while (i < len) {
                            if (handle.hasAttribute('selected') || handle.hasAttribute('selected-secondary')) {
                                intSelected += 1;
                            }
                            i += 1;
                        }
                    }

                    if (clickFrom < newClicked) {
                        intDistanceBetween = newClicked - clickFrom;
                    } else {
                        intDistanceBetween = clickFrom - newClicked;
                    }

                    //if all of the records are selected
                    //    bolDeselect = true
                    //else
                    //    bolDeselect = false
                    if (intDistanceBetween <= intSelected) {
                        bolDeselect = true;
                    } else {
                        bolDeselect = false;
                    }


                    //console.log(bolDeselect, intDistanceBetween, intSelected);
                    //if clickFrom is higher in the list than newClicked
                    //    select down from clickFrom to newClicked
                    //else
                    //    select down from newClicked to clickFrom
                    if (clickFrom < newClicked) {
                        if (bolDeselect) {
                            clickFrom -= 1;
                            newClicked -= 1;
                        }
                        i = clickFrom;
                        len = newClicked;
                        while (i < len) {
                            if (bolDeselect) {
                                if (arrAllRecords[i].hasAttribute('selected')) {
                                    arrAllRecords[i].removeAttribute('selected');
                                    arrAllRecords[i].removeAttribute('aria-selected');
                                }
                                if (arrAllRecords[i].hasAttribute('selected-secondary')) {
                                    arrAllRecords[i].removeAttribute('selected-secondary');
                                }
                            } else {
                                arrAllRecords[i].setAttribute('selected', '');
                                arrAllRecords[i].setAttribute('aria-selected', 'true');
                            }
                            arrAllRecords[i].classList.remove('originTR');
                            i += 1;
                        }
                    } else {
                        if (bolDeselect) {
                            newClicked += 1;
                            clickFrom += 1;
                        }
                        i = newClicked - 1;
                        len = clickFrom;
                        while (i < len) {
                            if (bolDeselect) {
                                if (arrAllRecords[i].hasAttribute('selected')) {
                                    arrAllRecords[i].removeAttribute('selected');
                                    arrAllRecords[i].removeAttribute('aria-selected');
                                }
                                if (arrAllRecords[i].hasAttribute('selected-secondary')) {
                                    arrAllRecords[i].removeAttribute('selected-secondary');
                                }
                            } else {
                                arrAllRecords[i].setAttribute('selected', '');
                                arrAllRecords[i].setAttribute('aria-selected', 'true');
                            }
                            arrAllRecords[i].classList.remove('originTR');
                            i += 1;
                        }
                    }
                }


                //if bolDeselect is false
                //    deselect from clickFrom to the first non-selected record
                if (!bolDeselect) {
                    if (clickFrom < newClicked) {
                        if (element.secondLastClicked > clickFrom && element.secondLastClicked < newClicked) {
                            bolRemoveClicked = true;
                        }
                    } else {
                        if (element.secondLastClicked < clickFrom && element.secondLastClicked > newClicked) {
                            bolRemoveClicked = true;
                        }
                    }

                    if (bolRemoveClicked) {
                        if (clickFrom < newClicked) {
                            i = element.secondLastClicked - 2;
                            while (i > 0) {
                                arrAllRecords[i].classList.remove('originTR');

                                if (arrAllRecords[i].hasAttribute('selected')) {
                                    arrAllRecords[i].removeAttribute('selected');
                                    arrAllRecords[i].removeAttribute('aria-selected');
                                } else if (arrAllRecords[i].hasAttribute('selected-secondary')) {
                                    arrAllRecords[i].removeAttribute('selected-secondary');
                                } else {
                                    break;
                                }

                                i -= 1;
                            }
                        } else {
                            i = element.secondLastClicked;
                            len = arrAllRecords.length;
                            while (i < len) {
                                arrAllRecords[i].classList.remove('originTR');
                                if (arrAllRecords[i].hasAttribute('selected')) {
                                    arrAllRecords[i].removeAttribute('selected');
                                    arrAllRecords[i].removeAttribute('aria-selected');
                                } else if (arrAllRecords[i].hasAttribute('selected-secondary')) {
                                    arrAllRecords[i].removeAttribute('selected-secondary');
                                } else {
                                    break;
                                }

                                i += 1;
                            }
                        }
                    }
                }

            } else if (strType === 'down') {
                element.originTR = record[0];

                if (bolAdd && handle.hasAttribute('selected') && arrSelectedRecords.length > 1) {
                    handle.removeAttribute('selected');
                    handle.removeAttribute('aria-selected');
                    if (handle.classList.contains('originTR')) {
                        handle.classList.remove('originTR');
                    }
                } else {
                    element.originTR.setAttribute('selected-secondary', '');
                }
            } else if (strType === 'move' && !bolShift) {
                var arrSelectedTrs = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected-secondary]');

                arrRecords = xtag.query(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr');
                arrRecordsToAffect = arrRecords.slice(
                    (Math.min(element.originTR.getAttribute('data-record_no'), record[0].getAttribute('data-record_no')) - 1),
                    (Math.max(element.originTR.getAttribute('data-record_no'), record[0].getAttribute('data-record_no')))
                );

                i = 0;
                len = arrRecordsToAffect.length;
                while (i < len) {
                    arrRecordsToAffect[i].setAttribute('selected-secondary', '');
                    i += 1;
                }

            } else if (strType === 'up') {
                if (element.tableElement && xtag.queryChildren(element.tableElement, 'tbody')[0]) {
                    // clear previous selection
                    arrSelectedTrs = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected-secondary]');

                    i = 0;
                    len = arrSelectedTrs.length;
                    while (i < len) {
                        arrSelectedTrs[i].removeAttribute('selected-secondary');
                        arrSelectedTrs[i].setAttribute('selected', '');
                        arrSelectedTrs[i].setAttribute('aria-selected', 'true');
                        i += 1;
                    }
                }
                if (record[0]) {
                    //console.trace('triggerchange 1');
                    element.triggerChange();
                }
            } else if (record) {
                // highlightRecord has its own checking for no record supplied,
                // so this deselects any rows then selects the supplied record or none
                if (element.hasAttribute('multi-select')) {
                    i = 0;
                    len = record.length;
                    while (i < len) {
                        record[i].setAttribute('selected', '');
                        record[i].setAttribute('aria-selected', 'true');
                        i += 1;
                    }
                } else {
                    record.setAttribute('selected', '');
                    var strHiddenValue = record.firstElementChild.textContent || ' ';
                    if (element.hiddenFocusControl) {
                        //element.hiddenFocusControl.value = strHiddenValue || 'blank';
                        //element.hiddenFocusControl.setAttribute('value', strHiddenValue || ' ');
                        element.hiddenFocusControl.value = ',';
                        element.hiddenFocusControl.setAttribute('aria-label', strHiddenValue || ' ');
                        //GS.setInputSelection(element.hiddenFocusControl, 0, strHiddenValue.length);
                    }
                    record.setAttribute('aria-selected', 'true');
                }
                //highlightRecord(element, record);
                element.triggerChange();
            } else if (!record && handle === '\\N') {
                element.setAttribute('value', '\\N');
                
            }

            if (element.originTR) {
                element.originTR.classList.add('originTR');
            }

            //Save last clicked tr no for Shift-selecting
            if (typeof handle === 'object' && handle.tagName && strType === 'down') {
                if (element.lastClicked) {
                    element.secondLastClicked = element.lastClicked;
                }
                element.lastClicked = parseInt(handle.getAttribute('data-record_no'), 10);
            }
        }
    }


    // #################################################################
    // ########################## USER EVENTS ##########################
    // #################################################################

    // handle behaviours on keydown
    function handleKeyDown(event) {
        var element = event.target;
        var intKeyCode = event.keyCode || event.which;
        var selectedTr;
        var trs;
        var i;
        var len;
        var selectedRecordIndex;

        if (element.tagName.toUpperCase() !== 'GS-LISTBOX') {
            element = GS.findParentTag(event.target, 'gs-listbox');
        }

        if (!element.hasAttribute('disabled')) {
            if (!element.hasAttribute('no-select')) {
                if ((intKeyCode === 40 || intKeyCode === 38) && (!event.shiftKey) && !event.metaKey && !event.ctrlKey && !element.error) {
                    trs = xtag.query(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr:not(.divider)');

                    i = 0;
                    len = trs.length;
                    while (i < len) {
                        if (trs[i].hasAttribute('selected')) {
                            selectedRecordIndex = i;
                            selectedTr = trs[i];
                            trs[i].removeAttribute('selected');
                            trs[i].removeAttribute('aria-selected');

                            break;
                        }
                        i += 1;
                    }

                    if (intKeyCode === 40) {// next record or circle to first record or start selection at the first
                        if (!selectedTr || selectedRecordIndex === trs.length - 1) {
                            highlightRecord(element, trs[0]);
                            selectedTr = trs[0];

                        } else {
                            highlightRecord(element, trs[selectedRecordIndex + 1]);
                            selectedTr = trs[selectedRecordIndex + 1];
                        }

                    } else if (intKeyCode === 38) {// prev record or circle to last record or start selection at the last
                        if (!selectedTr || selectedRecordIndex === 0) {
                            highlightRecord(element, trs[trs.length - 1]);
                            selectedTr = trs[trs.length - 1];

                        } else {
                            highlightRecord(element, trs[selectedRecordIndex - 1]);
                            selectedTr = trs[selectedRecordIndex - 1];
                        }
                    }

                    //GS.scrollIntoView(selectedTr);
                    element.scrollToSelectedRecord();
                    event.preventDefault();
                    event.stopPropagation();

                } else if (event.keyCode === 13) {
                    selectedTr = xtag.query(xtag.query(element.tableElement, 'tbody')[0], 'tr[selected]')[0];

                    if (element.tableElement && selectedTr) {
                        selectRecord(element, selectedTr, true);
                    }
                }
            }
        } else {
            if (event.keyCode !== 9) {
                event.preventDefault();
                event.stopPropagation();
            }
        }
    }

    function handleFocusout(event) {
        //TODO: XLD
        /*
        var element = event.target, selectedTr;

        if (element.tableElement) {
            selectedTr = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected]')[0];

            if (selectedTr) {
                selectRecord(element, selectedTr, true);
            }
        }
        */
    }


    // #################################################################
    // ######################### DATA HANDLING #########################
    // #################################################################

    // the user needs to be able to set a custom websocket for this element,
    //      so this function will use an attribute to find out what socket to
    //      use (and it'll default to "GS.envSocket")
    function getSocket(element) {
        if (element.getAttribute('socket')) {
            return GS[element.getAttribute('socket')];
        }
        return GS.envSocket;
    }

    // handles fetching the data
    //      if bolInitalLoad === true then
    //          use: initialize query COALESCE TO source query
    //      else
    //          use: source query
    function getData(element, callback, bolInitalLoad, bolClearPrevious) {
        var strSrc = GS.templateWithQuerystring(
            (bolInitalLoad && element.getAttribute('initialize'))
                ? element.getAttribute('initialize')
                : element.getAttribute('src')
        );
        var srcParts = strSrc[0] === '(' ? [strSrc, ''] : strSrc.split('.');
        var strSchema = srcParts[0];
        var strObject = srcParts[1];
        var strColumns = GS.templateWithQuerystring(element.getAttribute('cols') || '*').split(',').join('\t');
        var strWhere = GS.templateWithQuerystring(element.getAttribute('where') || '');
        var strOrd = GS.templateWithQuerystring(element.getAttribute('ord') || '');
        var strLimit = GS.templateWithQuerystring(element.getAttribute('limit') || '');
        var strOffset = GS.templateWithQuerystring(element.getAttribute('offset') || '');
        var response_i = 0;
        var response_len = 0;
        var arrTotalRecords = [];

        GS.triggerEvent(element, 'before_select');
        GS.triggerEvent(element, 'onbefore_select');
        if (element.hasAttribute('onbefore_select')) {
            new Function(element.getAttribute('onbefore_select')).apply(element);
        }

        GS.addLoader(element, 'Loading...');
        GS.requestSelectFromSocket(
            getSocket(element),
            strSchema,
            strObject,
            strColumns,
            strWhere,
            strOrd,
            strLimit,
            strOffset,
            function (data, error) {
                var arrRecords;
                var arrCells;
                var envData;
                var i;
                var len;
                var cell_i;
                var cell_len;

                if (!error) {
                    if (data.strMessage !== 'TRANSACTION COMPLETED') {
                        arrRecords = GS.trim(data.strMessage, '\n').split('\n');

                        i = 0;
                        len = arrRecords.length;
                        while (i < len) {
                            arrCells = arrRecords[i].split('\t');

                            cell_i = 0;
                            cell_len = arrCells.length;
                            while (cell_i < cell_len) {
                                arrCells[cell_i] = arrCells[cell_i] === '\\N' ? null : GS.decodeFromTabDelimited(arrCells[cell_i]);
                                cell_i += 1;
                            }

                            arrTotalRecords.push(arrCells);
                            i += 1;
                        }
                    } else {
                        GS.removeLoader(element);
                        element.arrColumnNames = data.arrColumnNames;

                        envData = {'arr_column': element.arrColumnNames, 'dat': arrTotalRecords};

                        handleData(element, bolInitalLoad, envData);
                        GS.triggerEvent(element, 'after_select');
                        if (typeof callback === 'function') {
                            callback();
                        }
                    }
                } else {
                    handleData(element, bolInitalLoad, data, error);
                    GS.removeLoader(element);
                }
            }
        );
    }

    // handles data result from method function: getData
    //      success:  template
    //      error:    add error classes
    function handleData(element, bolInitalLoad, data, error) {
        var strTemplate;
        var divElement;
        var tableElement;
        var theadElement;
        var theadCellElements;
        var tbodyElement;
        var tbodyCellElements;
        var lastRecordElement;
        var recordElements;
        var recordElement;
        var currentCellLabelElement;
        var template;
        var i;
        var len;
        var arrHeaders = [];
        var arrHide;
        var intVisibleColumns;
        var strHeaderCells;
        var strRecordCells;
        var jsnTemplate;
        var strHTML;

        // clear any old error status
        element.classList.remove('error');
        element.setAttribute('title', '');

        // if there was no error
        if (!error) {
            element.error = false;

            if (element.tableTemplate) {// element.tableTemplateElement
                strTemplate = element.tableTemplate;// element.tableTemplateElement
            } else {
                // create an array of hidden column numbers
                arrHide = (element.getAttribute('hide') || '').split(/[\s]*,[\s]*/);

                var strTableID = element.getAttribute('id');
                if (! strTableID) {
                    strTableID = GS.GUID();
                }

                // build up the header cells variable and the record cells variable
                strHeaderCells = '';
                strRecordCells = '';
                intVisibleColumns = 0;
                i = 0;
                len = data.arr_column.length;
                while (i < len) {
                    // if this column is not hidden
                    if (arrHide.indexOf((i + 1) + '') === -1 && arrHide.indexOf(data.arr_column[i]) === -1) {
                        // append a new cell to each of the header cells and record cells variables
                        strHeaderCells += '<th id="' + strTableID + '_' + data.arr_column[i] + '" gs-dynamic>' + encodeHTML(data.arr_column[i]) + '</th> ';
                        strRecordCells += '<td headers="' + strTableID + '_' + data.arr_column[i] + '" gs-dynamic>{{! row[\'' + data.arr_column[i] + '\'] }}</td> ';
                        intVisibleColumns += 1;
                    }
                    i += 1;
                }

                // put everything together
                strTemplate = '<table gs-dynamic>';

                if (intVisibleColumns > 1) { // data.arr_column.length (didn't take into account hidden columns)
                    strTemplate +=  '<thead gs-dynamic>' +
                                        '<tr gs-dynamic>' +
                                            strHeaderCells +
                                        '</tr>' +
                                    '</thead>';
                }

                strTemplate +=      '<tbody gs-dynamic>' +
                                        '<tr data-record_no="{{! row.row_number }}" value="{{! row[\'' + data.arr_column[0] + '\'] }}" gs-dynamic>' +
                                            strRecordCells +
                                        '</tr>' +
                                    '</tbody>' +
                                '</table>';
            }

            divElement = document.createElement('div');
            divElement.innerHTML = strTemplate;

            tableElement = xtag.queryChildren(divElement, 'table')[0];
            theadElement = xtag.queryChildren(tableElement, 'thead')[0];
            tbodyElement = xtag.queryChildren(tableElement, 'tbody')[0];

            // if there is a tbody
            if (tbodyElement) {
                recordElement = xtag.queryChildren(tbodyElement, 'tr')[0];

                // if there is a record: template
                if (recordElement) {

                    // if there is a thead element: add reflow cell headers to the tds
                    if (theadElement) {
                        theadCellElements = xtag.query(theadElement, 'td, th');
                        tbodyCellElements = xtag.query(tbodyElement, 'td, th');

                        i = 0;
                        len = theadCellElements.length;
                        while (i < len) {
                            currentCellLabelElement = document.createElement('b');
                            currentCellLabelElement.classList.add('cell-label');
                            currentCellLabelElement.setAttribute('data-text', (theadCellElements[i].textContent || '') + ':');

                            if (tbodyCellElements[i].childNodes) {
                                tbodyCellElements[i].insertBefore(currentCellLabelElement, tbodyCellElements[i].childNodes[0]);
                            } else {
                                tbodyCellElements[i].insertChild(currentCellLabelElement);
                            }
                            i += 1;
                        }
                    }

                    // template
                    jsnTemplate = GS.templateHideSubTemplates(tbodyElement.innerHTML, true);
                    strHTML = GS.templateWithEnvelopeData(jsnTemplate.templateHTML, data);
                    tbodyElement.innerHTML = GS.templateShowSubTemplates(strHTML, jsnTemplate);

                    element.tableElement = tableElement;
                    element.syncView();
                    element.internalData.records = data;
                }
            }

            if (theadElement && tbodyElement && theadElement.children[0] && theadElement.children[0].children) {
                tbodyElement.insertBefore(theadElement.children[0].cloneNode(true), tbodyElement.children[0]);
                var cols_i = 0;
                var cols_len = theadElement.children[0].children.length;
                element.tbodyheader = xtag.query(tbodyElement, 'tr:not([data-record_no])')[0];
                element.tbodyElement = tbodyElement;
                element.theadElement = theadElement;
                while (cols_i < cols_len) {
                    theadElement.children[0].children[cols_i].setAttribute(
                        'style',
                        'width: ' + element.tbodyheader.children[cols_i].clientWidth + 'px !important; padding-right: 0; padding-left: 0;'
                    );
                    cols_i++;
                }
            }

            if (bolInitalLoad && !element.getAttribute('value') && element.hasAttribute('select-first')) {
                selectRecord(element, xtag.query(element, 'tbody tr')[0].getAttribute('value'), false);
                element.scrollToSelectedRecord();
            }

            GS.triggerEvent(element, 'after_select');
            GS.triggerEvent(element, 'onafter_select');
            if (element.hasAttribute('onafter_select')) {
                new Function(element.getAttribute('onafter_select')).apply(element);
            }

        // else there was an error: add error class, title attribute
        } else {
            element.error = true;
            element.classList.add('error');
            element.setAttribute('title', 'This listbox has failed to load.');

            element.setAttribute('disabled', '');

            GS.ajaxErrorDialog(data);
        }
    }

    function getParentCell(element) {
        var currentElement = element;

        while (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH' && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }

        if (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH') {
            return undefined;
        }

        return currentElement;
    }

    function windowResizeHandler() {
        var i;
        var len;
        var arrElement;
        var element;
        var cols_i;
        var cols_len;

        arrElement = document.getElementsByTagName('gs-listbox');

        i = 0;
        len = arrElement.length;
        while (i < len) {
            if (GS.pxToEm(document.body, this.oldWidth) !== GS.pxToEm(document.body, this.offsetWidth) && // <== if the width (in ems) changes
                arrElement[i].hasAttribute('letter-scrollbar') &&
                arrElement[i].tableElement) {

                if (arrElement[i].hasAttribute('letter-dividers') || arrElement[i].hasAttribute('letter-scrollbar')) {
                    arrElement[i].refreshDividingPoints();
                }
                arrElement[i].letterScrollbarHandler();
                this.oldWidth = this.offsetWidth;
            }
            element = arrElement[i];
            if (element.theadElement && element.tbodyElement) {
                cols_i = 0;
                cols_len = element.theadElement.children[0].children.length;
                while (cols_i < cols_len) {
                    element.theadElement.children[0].children[cols_i].setAttribute('style', 'width: ' + element.tbodyheader.children[cols_i].clientWidth + 'px !important; padding-right: 0; padding-left: 0;');
                    cols_i++;
                }
            }
            i += 1;
        }
    }

    window.addEventListener('resize', windowResizeHandler);  // I want to debounce this event but that would require a timer -michael
    window.addEventListener('orientationchange', windowResizeHandler);

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var arrPopKeys;
        var currentValue;
        var bolRefresh;
        var strOperator;

        element.supressChange = false;

        if (strQSCol) {
            if (strQSCol.indexOf('=') !== -1) {
                arrAttrParts = strQSCol.split(',');
                i = 0;
                len = arrAttrParts.length;
                while (i < len) {
                    strQSCol = arrAttrParts[i];

                    if (strQSCol.indexOf('!=') !== -1) {
                        strOperator = '!=';
                        arrQSParts = strQSCol.split('!=');
                    } else {
                        strOperator = '=';
                        arrQSParts = strQSCol.split('=');
                    }

                    strQSCol = arrQSParts[0];
                    strQSAttr = arrQSParts[1] || arrQSParts[0];

                    // if the key is not present or we've got the negator: go to the attribute's default or remove it
                    if (strOperator === '!=') {
                        // if the key is not present: add the attribute
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            element.setAttribute(strQSAttr, '');
                        // else: remove the attribute
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    } else {
                        // if the key is not present: go to the attribute's default or remove it
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                            } else {
                                element.removeAttribute(strQSAttr);
                            }
                        // else: set attribute to exact text from QS
                        } else {
                            element.setAttribute(strQSAttr, (
                                GS.qryGetVal(strQS, strQSCol) ||
                                element.internal.defaultAttributes[strQSAttr] ||
                                ''
                            ));
                        }
                    }
                    i += 1;
                }
            } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                strQSValue = GS.qryGetVal(strQS, strQSCol);

                if (element.internal.bolQSFirstRun !== true) {
                    if (strQSValue !== '' || !element.getAttribute('value')) {
                        element.supressChange = true;
                        element.setAttribute('value', strQSValue);
                    }
                } else if (element.value !== strQSValue) {
                    element.value = strQSValue;
                }
            }
        }

        // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
        if (element.internal.bolQSFirstRun === true) {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                i = 0;
                len = arrPopKeys.length;
                while (i < len) {
                    currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);

                    if (element.popValues[arrPopKeys[i]] !== currentValue) {
                        bolRefresh = true;
                    }

                    element.popValues[arrPopKeys[i]] = currentValue;
                    i += 1;
                }
            } else if (element.hasAttribute('refresh-on-querystring-change')) {
                bolRefresh = true;
            }

            if (bolRefresh && element.hasAttribute('src')) {
                getData(element);
            } else if (bolRefresh && !element.hasAttribute('src')) {
                console.warn('gs-listbox Warning: element has "refresh-on-querystring-values" or "refresh-on-querystring-change", but no "src".', element);
            }
        } else {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                i = 0;
                len = arrPopKeys.length;
                while (i < len) {
                    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                    i += 1;
                }
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value && !element.getAttribute('value')) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = null;
            }

            if (!element.hasAttribute('role')) {
                element.setAttribute('role', 'listbox');
            }
        }
    }

    // ############# COPY EVENTS #############
    function unbindCopy(element) {
        element.removeEventListener(
            'copy',
            element.copySelection
        );
    }
    function bindCopy(element) {
        element.copySelection = function (event) {
            var jsnCopyString = {};
            var focusedElement;
            var i;
            var len;

            // saving the currently focused element for easy/quick access
            focusedElement = document.activeElement;

            // if the focus is on the hidden focus control of if the text
            //      selection of the currently focused element is not
            //      selecting multiple characters
            if (
                focusedElement.classList.contains('hidden-focus-control') ||
                focusedElement.selectionStart === focusedElement.selectionEnd
            ) {
                console.time('copy');

                // focus the hidden focus control and select all of it's text so
                //      that Firefox will allow us to override the clipboard
                focusedElement = element.hiddenFocusControl;
                focusedElement.focus();

                GS.setInputSelection(
                    focusedElement,
                    0,
                    focusedElement.value.length
                );

                jsnCopyString.text = '';
                jsnCopyString.html = '';

                // we want to override the text and HTML mime type clipboards,
                //      so we get the copy text for both types
                var selectedRecords = element.selectedRecord;
                if (selectedRecords[0]) {
                    i = 0;
                    len = selectedRecords.length;
                    while (i < len) {
                        if (i < 1) {
                            jsnCopyString.text += selectedRecords[i].innerText;
                            //jsnCopyString.html += selectedRecords[i].innerHTML;
                        } else {
                            jsnCopyString.text += '\n' + selectedRecords[i].innerText;
                            //jsnCopyString.html += '\n' + selectedRecords[i].innerHTML;
                        }
                        i += 1;
                    }
                //not multi-select
                } else {
                    jsnCopyString.text = selectedRecords.innerText;
                    //jsnCopyString.html = selectedRecords.innerHTML;
                }

                // override clipboard (prevent event default if we are
                //      successful)
                if (handleClipboardData(event, jsnCopyString.text, 'text')) {
                    event.preventDefault(event);
                }
                // if (handleClipboardData(event, jsnCopyString.html, 'html')) {
                //     event.preventDefault(event);
                // }

                console.timeEnd('copy');
            }
        };

        element.hiddenFocusControl.addEventListener(
            'copy',
            element.copySelection
        );
    }

    function handleClipboardData(event, strCopyString, strType) {
        var clipboardData = event.clipboardData || window.clipboardData;
        var strMime;

        if (!clipboardData) {
            return;
        }
        if (!clipboardData.setData) {
            return;
        }

        if (strType === 'text') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = 'Text';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/plain';
            }
        } else if (strType === 'html') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = '';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/html';
            }
        } else {
            throw 'handleClipboardData Error: Type "' + strType + '" not ' +
                    'recognized, recognized types are "text" and "html".';
        }

        if (strMime) {
            if (strCopyString && strMime) {
                return clipboardData.setData(strMime, strCopyString) !== false;
            } else {
                return clipboardData.getData(strMime);
            }
        }
    }

    function findFor(element) {
        var forElem;
        ////console.log(element, element.previousElementSibling)
        if (element.previousElementSibling && element.previousElementSibling.tagName.toUpperCase() == 'LABEL'
            && element.previousElementSibling.hasAttribute('for')
            && element.previousElementSibling.getAttribute('for') == element.getAttribute('id')
        ) {
            forElem = element.previousElementSibling;
        } else if (xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]').length > 0) {
            forElem = xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]')[0];
        }

        //console.log(forElem);
        if (forElem) {
            if (! element.hasAttribute('aria-label')) {
                element.setAttribute('aria-label', forElem.innerText);
            }
        }
    }

    var intListID = 0;
    function elementInserted(element) {
        var tableTemplateElement;
        var arrElement;
        var recordElement;
        var tableTemplateElementCopy;
        var strQSValue;
        var i;
        var len;
        var currentElement;
        var trSet;
        var cols_i_1;
        var cols_len_1;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.error = false;
                element.internal = {};
                element.internalData = {};

                element.internal.id = intListID;
                intListID += 1;

                saveDefaultAttributes(element);
                // handle "qs" attribute
                if (
                    element.hasAttribute('qs') ||
                    element.hasAttribute('refresh-on-querystring-values') ||
                    element.hasAttribute('refresh-on-querystring-change')
                ) {
                    element.popValues = {};
                    //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.setAttribute('value', strQSValue);
                    //}

                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                    //element.popValues = GS.qryToJSON(GS.getQueryString());
                }

                // allows the element to have focus
                if (!element.hasAttribute('tabindex')) {
                    element.setAttribute('tabindex', '0');
                }

                element.skipFocus = false;

                // select for template
                tableTemplateElement = xtag.queryChildren(element, 'template')[0];
                if (tableTemplateElement && (tableTemplateElement.innerHTML.indexOf('&gt;') > -1 || tableTemplateElement.innerHTML.indexOf('&lt;') > -1)) {
                    console.warn('GS-LISTBOX WARNING: &gt; or &lt; detected in table template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                }

                if (element.getAttribute('src') || element.getAttribute('source')) {
                    if (element.innerHTML.trim() !== '') {
                        trSet = xtag.query(tableTemplateElement.content, 'tbody > tr');//:not(.divider)');
                        i = 0;
                        len = trSet.length;
                        while (i < len) {
                            trSet[i].setAttribute('data-record_no', '{{! row.row_number }}');
                            i += 1;
                        }
                    }
                }

                if (tableTemplateElement) {
                    // add a doT.js coded "value" attribute to any element with a "column" attribute but no "value" attribute
                    element.tableTemplate = GS.templateColumnToValue(tableTemplateElement.innerHTML);
                }

                if (element.getAttribute('src') || element.getAttribute('source')) {
                    getData(element, '', true);
                } else {
                    if (tableTemplateElement) {
                        //developer provided template
                        element.tableElement = xtag.query(tableTemplateElement.content, 'table')[0];
                    } else if (xtag.queryChildren(element, 'table')[0]) {
                        element.tableElement = xtag.queryChildren(element, 'table')[0];
                    } else {
                        element.tableElement = document.createElement('table');
                    }

                    // loop through and add the data-record_no attribute
                    trSet = xtag.query(tableTemplateElement.content, 'tr');//:not(.divider)');
                    i = 0;
                    len = trSet.length;
                    while (i < len) {
                        trSet[i].setAttribute('data-record_no', i);
                        i += 1;
                    }

                    element.syncView();

                    var theadElement = xtag.query(element.tableElement, 'thead')[0];
                    var tbodyElement = xtag.query(element.tableElement, 'tbody')[0];
                    if (theadElement && tbodyElement && theadElement.children[0]) {
                        tbodyElement.insertBefore(theadElement.children[0].cloneNode(true), tbodyElement.children[0]);
                        //tbodyElement.innerHTML = theadElement.innerHTML + '' + tbodyElement.innerHTML;
                        cols_i_1 = 0;
                        cols_len_1 = theadElement.children[0].children.length;
                        element.tbodyheader = xtag.query(tbodyElement, 'tr[data-record_no="0"]')[0];
                        element.tbodyheader.removeAttribute('data-record_no');
                        element.tbodyElement = tbodyElement;
                        element.theadElement = theadElement;
                        while (cols_i_1 < cols_len_1) {
                            theadElement.children[0].children[cols_i_1].setAttribute('style', 'width: ' + element.tbodyheader.children[cols_i_1].clientWidth + 'px !important; padding-right: 0; padding-left: 0;');
                            cols_i_1++;
                        }
                    }
                }
            }
        }
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            if (element.hasAttribute('id')) {
                findFor(element);
            }
        }
    }

    xtag.register('gs-listbox', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value' && newValue !== oldValue) {
                        this.value = newValue;
                    }
                }
            }
        },
        events: {},
        accessors: {
            value: {
                get: function () {
                    var element = this;
                    var arrResult = [];
                    var i;
                    var len;

                    if (element.tableElement) {
                        var arrRecords = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected]');//:not(.divider)
                        if (element.getAttribute('value') === '\\N') {
                            return '\\N';
                        }
                        if (element.hasAttribute('multi-select')) {
                            if (element.internalData.records) {
                                i = 0;
                                len = arrRecords.length;
                                while (i < len) {
                                    if (element.internalData.records.dat[arrRecords[i].getAttribute('data-record_no') - 1]) {
                                        arrResult.push(element.internalData.records.dat[arrRecords[i].getAttribute('data-record_no') - 1][0]);
                                    }
                                    i += 1;
                                }
                                return arrResult;
                            } else {
                                return element.getAttribute('value');
                            }
                        }

                        // not multi-select
                        if (arrRecords.length > 0) {
                            if (element.internalData.records) {
                                if (element.internalData.records.dat[arrRecords[0].getAttribute('data-record_no') - 1]) {
                                    return element.internalData.records.dat[arrRecords[0].getAttribute('data-record_no') - 1][0];
                                }
                            } else {
                                return element.getAttribute('value');
                            }
                        }
                    }
                },

                set: function (strNewValue) {
                    selectRecord(this, strNewValue);
                    this.scrollToSelectedRecord();
                }
            },

            selectedRecord: {
                get: function () {
                    var element = this;
                    if (element.tableElement) {
                        var arrRecords = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected]');

                        if (this.hasAttribute('multi-select')) {
                            return arrRecords;
                        } else {
                            return arrRecords[0];
                        }
                    }
                },

                set: function (newValue) {
                    selectRecord(this, newValue);
                    this.scrollToSelectedRecord();
                }
            },

            textValue: {
                get: function () {
                    var element = this;
                    var strResult;
                    var i;
                    var len;

                    if (element.tableElement) {
                        var arrRecords = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected]');

                        if (this.hasAttribute('multi-select')) {
                            i = 0;
                            len = arrRecords.length;
                            while (i < len) {
                                if (xtag.queryChildren(arrRecords[i], 'td').length > 0) {
                                    strResult += xtag.queryChildren(arrRecords[i], 'td')[0].textContent;
                                }
                                i += 1;
                            }
                            return strResult;
                        } else {
                            return arrRecords[0].textContent;
                        }
                    }
                },

                set: function () {
                    selectRecord(this, strNewValue);
                    this.scrollToSelectedRecord();
                }
            }
        },
        methods: {
            // just a semantic alias to the getData function
            refresh: function (callback) {
                getData(this, callback);
            },

            column: function (strColumn) {
                var element = this;
                var arrStrResult = [];
                var i;
                var len;

                if (this.hasAttribute('multi-select')) {
                    i = 0;
                    len = this.selectedRecord.length;
                    while (i < len) {
                        arrStrResult.push(this.internalData.records.dat[this.selectedRecord[i].rowIndex][this.internalData.records.arr_column.indexOf(strColumn)]);
                        i += 1;
                    }
                    return arrStrResult;
                } else {
                    return this.internalData.records.dat[parseInt(this.selectedRecord.getAttribute('data-record_no'), 10) - 1][this.internalData.records.arr_column.indexOf(strColumn)];
                }
            },

            // #################################################################
            // ########### SELECTION / HIGHLIGHTING / RECORD / VALUE ###########
            // #################################################################

            // scroll the dropdown to the selected record
            scrollToSelectedRecord: function () {
                var selectedTr;

                if (this.tableElement) {
                    selectedTr = xtag.query(this.tableElement, 'tr[selected]')[0];

                    if (selectedTr) {
                        GS.scrollIntoView(selectedTr);
                    }
                }
            },

            // ################################################################
            // ####################### LETTER SCROLLBAR #######################
            // ################################################################

            letterScrollbarHandler: function () {
                var element = this;
                var i;
                var len;
                var intTextHeight;
                var intLettersDropped;
                var intSkipperHeight;
                var intElementHeight;
                var intDistance;
                var strHTML;
                var arrSkippers;

                // if there is no letter scrollbar container: create it
                if (xtag.queryChildren(element, '.letter-scrollbar-container').length === 0) {
                    element.letterScrollbarContainer = document.createElement('div');
                    element.letterScrollbarContainer.classList.add('letter-scrollbar-container');
                    element.letterScrollbarContainer.setAttribute('gs-dynamic', '');
                    element.appendChild(element.letterScrollbarContainer);

                // else: clear out the old letterScrollbarContainer
                } else {
                    element.letterScrollbarContainer.innerHTML = '';
                }

                if (element.clientHeight < element.scrollContainer.scrollHeight) {
                    intTextHeight = GS.getTextHeight(element.letterScrollbarContainer);
                    intSkipperHeight = intTextHeight * this.arrDividingPoints.length;
                    intElementHeight = element.clientHeight / this.arrDividingPoints.length;

                    if (intElementHeight < intTextHeight) {
                        intElementHeight = intTextHeight;
                    }

                    if (intSkipperHeight > element.clientHeight) {
                        intLettersDropped = 0;
                        while (intSkipperHeight > element.clientHeight && intLettersDropped < 100) {
                            intSkipperHeight -= intTextHeight;
                            intLettersDropped += 1;
                        }
                        intDistance = Math.ceil(this.arrDividingPoints.length / intLettersDropped);
                    }

                    i = 0;
                    len = this.arrDividingPoints.length;
                    strHTML = '';
                    while (i < len) {
                        if (intLettersDropped === undefined || (intLettersDropped > 0 && i % intDistance !== 0)) {
                            strHTML += '<div class="skipper" gs-dynamic ' +
                                            'style="height: ' + intElementHeight + 'px; line-height: ' + intElementHeight + 'px;" ' +
                                            'data-target-offset="' + this.arrDividingPoints[i].offset + '">' +
                                            '<span gs-dynamic>' + this.arrDividingPoints[i].letter + '</span>' +
                                        '</div>';
                        }
                        i += 1;
                    }

                    element.letterScrollbarContainer.innerHTML = strHTML;

                    if (element.paddingElement && element.paddingElement.parentNode === element.scrollContainer) {
                        element.scrollContainer.removeChild(element.paddingElement);
                    }

                    element.paddingElement = document.createElement('div');
                    element.paddingElement.setAttribute('gs-dynamic', '');
                    if (this.arrDividingPoints.length > 0) {
                    element.paddingElement.style.height = (element.clientHeight -
                                                        (element.scrollContainer.scrollHeight - parseInt(this.arrDividingPoints[this.arrDividingPoints.length - 1].offset, 10))) + 'px';
                    }
                    element.scrollContainer.appendChild(element.paddingElement);

                    // bind skipper click, mousedown-then-drag
                    arrSkippers = element.letterScrollbarContainer.children;

                    if (element.mousedownHandler) {
                        window.removeEventListener(evt.mousedown, element.mousedownHandler);
                        window.removeEventListener(evt.mousemove, element.mousemoveHandler);
                        window.removeEventListener(evt.mouseup, element.mouseupHandler);
                    }

                    element.clickHandler = function () {
                        element.style.webkitOverflowScrolling = 'initial';
                        element.scrollContainer.scrollTop = parseInt(this.getAttribute('data-target-offset'), 10);
                        element.style.webkitOverflowScrolling = 'touch';

                        //element.scrollContainer.className = element.scrollContainer.className;
                        //element.scrollContainer.style.outline = '1px solid #000000';
                        //element.scrollContainer.style.outline = '';
                    };
                    element.mousedownHandler = function (event) { // event
                        window.addEventListener(evt.mousemove, element.mousemoveHandler);
                        if (event.target.classList.contains('skipper') && evt.touchDevice) {
                            element.style.webkitOverflowScrolling = 'initial';
                        }
                        //element.mousemoveHandler(event);
                    };
                    element.mousemoveHandler = function (event) {
                        var jsnMousePosition, targetElement;

                        if (event.which !== 0 || evt.touchDevice) {
                            jsnMousePosition = GS.mousePosition(event);
                            targetElement = document.elementFromPoint(jsnMousePosition.left, jsnMousePosition.top);

                            if (targetElement) {
                                if (targetElement.nodeName === 'SPAN') {
                                    targetElement = targetElement.parentNode;
                                }

                                if (targetElement.classList.contains('skipper')) {
                                    element.style.webkitOverflowScrolling = 'initial';
                                    event.preventDefault();
                                    element.scrollContainer.scrollTop = parseInt(targetElement.getAttribute('data-target-offset'), 10);
                                }
                            }
                        } else {
                            window.removeEventListener(evt.mousemove, element.mousemoveHandler);
                        }
                    };
                    element.mouseupHandler = function () {
                        element.style.webkitOverflowScrolling = 'touch';
                        window.removeEventListener(evt.mousemove, element.mousemoveHandler);
                    };

                    element.addEventListener(evt.mousedown, element.mousedownHandler);
                    element.addEventListener(evt.mouseup, element.mouseupHandler);

                    i = 0;
                    len = arrSkippers.length;
                    while (i < len) {
                        arrSkippers[i].addEventListener('click', element.clickHandler);
                        i += 1;
                    }
                }
            },


            // #################################################################
            // ########################### UTILITIES ###########################
            // #################################################################

            refreshDividingPoints: function () {
                var tbodyElement, arrElement, arrLetter, dividerElement, strLetter, intOffset, numColumns, theadElement, i, len;

                tbodyElement = xtag.queryChildren(this.tableElement, 'tbody')[0];

                arrElement = xtag.queryChildren(tbodyElement, 'tr.divider');

                i = 0;
                len = arrElement.length;
                while (i < len) {
                    tbodyElement.removeChild(arrElement[i]);
                    i += 1;
                }

                this.arrDividingPoints = [];

                arrElement = xtag.queryChildren(tbodyElement, 'tr');

                if (arrElement.length > 0) {
                    numColumns = arrElement[0].children.length;

                    theadElement = xtag.queryChildren(this.tableElement, 'thead')[0];
                    intOffset = (theadElement ? theadElement.offsetHeight : 0);

                    arrLetter = [];
                    i = 0;
                    len = arrElement.length;
                    while (i < len) {
                        strLetter = xtag.queryChildren(arrElement[i], 'td')[0].textContent.substring(0, 1).toUpperCase();

                        if (arrLetter.indexOf(strLetter) === -1) {
                            this.arrDividingPoints.push({
                                'letter': strLetter,
                                'offset': intOffset
                            });

                            if (this.hasAttribute('letter-dividers')) {
                                dividerElement = document.createElement('tr');
                                dividerElement.classList.add('divider');
                                dividerElement.setAttribute('gs-dynamic', '');
                                dividerElement.setAttribute('data-target-offset', intOffset);
                                //if (!this.hasAttribute('letter-dividers')) { <== messed with odd and even record colors when letter-scrollbar but not letter-dividers -michael
                                //    dividerElement.setAttribute('hidden', '');
                                //}

                                dividerElement.innerHTML = '<td colspan="' + numColumns + '" gs-dynamic>' + encodeHTML(strLetter) + '</td>';

                                tbodyElement.insertBefore(dividerElement, arrElement[i]);

                                intOffset += dividerElement.offsetHeight;
                            }

                            arrLetter.push(strLetter);
                        }

                        intOffset += arrElement[i].offsetHeight;
                        i += 1;
                    }
                }
            },

            syncView: function () {
                var element = this, tbodyElement, i, len, arrElements, clickHandler, mousedownHandler, mousemoveHandler, mouseupHandler, mouseoutHandler, mouseoverHandler;

                element.removeEventListener('keydown', handleKeyDown);
                element.addEventListener('keydown', handleKeyDown);

                element.removeEventListener('focusout', handleFocusout);
                element.addEventListener('focusout', handleFocusout);

                element.innerHTML = '';

                element.scrollContainer = document.createElement('div');
                element.scrollContainer.setAttribute('gs-dynamic', '');
                element.scrollContainer.classList.add('root');
                element.scrollContainer.classList.add('scroll-container');
                element.scrollContainer.setAttribute('id', 'box-list-container-' + element.internal.id);
                element.scrollContainer.appendChild(element.tableElement);

                if (!element.hasAttribute('src')) {
                    var tableElement = element.tableElement;

                    if (element.hasAttribute('caption')) {
                        var objCaption = document.createElement('caption');
                        objCaption.innerHTML = '<center><h4>' + element.getAttribute('caption') + '</h4></center>';
                        tableElement.insertBefore(objCaption, tableElement.children[0]);
                    }
                }

                element.appendChild(element.scrollContainer);
                tbodyElement = xtag.queryChildren(element.tableElement, 'tbody')[0];

                addTableAria(element);

                // add dividers
                if (element.hasAttribute('letter-dividers') || element.hasAttribute('letter-scrollbar')) {
                    element.refreshDividingPoints();

                    // if we have the letter-scrollbar attribute: add the letter scrollbar
                    if (element.hasAttribute('letter-scrollbar')) {
                        element.letterScrollbarHandler();
                    }
                }

                // this fixes the fact that this function was clearing the selection
                if (this.getAttribute('value')) {
                    selectRecord(this, this.getAttribute('value'));
                    this.scrollToSelectedRecord();
                }

                // click handling code
                // get list of record elements
                arrElements = xtag.toArray(tbodyElement.children);

                if (element.hasAttribute('multi-select')) {
                    // if we are not on a touch device: hover and down events
                    if (!evt.touchDevice) {
                        var mouseIsDown = false;
                        mousedownHandler = function (event) {
                            mouseIsDown = true;
                            this.classList.add('down');
                            element.addEventListener(evt.mousemove, mousemoveHandler);
                            window.addEventListener(evt.mouseup, mouseupHandler);
                            selectRecord(element, this, true, (event.ctrlKey || event.metaKey), 'down', event.shiftKey);
                        };
                        mousemoveHandler = function (event) {
                            if (mouseIsDown) {
                                selectRecord(element, getTRFromTarget(event.target), true, (event.ctrlKey || event.metaKey), 'move', event.shiftKey);
                            }
                        };
                        mouseupHandler = function (event) {
                            mouseIsDown = false;
                            selectRecord(element, this, true, (event.ctrlKey || event.metaKey), 'up', event.shiftKey);
                            element.removeEventListener(evt.mousemove, mousemoveHandler);
                            window.removeEventListener(evt.mouseup, mouseupHandler);
                        };
                        mouseoutHandler = function () {
                            this.classList.remove('down');
                            this.classList.remove('hover');
                        };
                        mouseoverHandler = function () {
                            this.classList.remove('down');
                            this.classList.add('hover');
                        };

                        // add click event with click event function to all record elements that are not dividers
                        i = 0;
                        len = arrElements.length;
                        while (i < len) {
                            if (!arrElements[i].classList.contains('divider')) {
                                arrElements[i].addEventListener(evt.mousedown, mousedownHandler);
                                arrElements[i].addEventListener(evt.mouseout, mouseoutHandler);
                                arrElements[i].addEventListener(evt.mouseover, mouseoverHandler);
                            }
                            i += 1;
                        }
                    } else {
                        //TODO: toggle
                        // create click event function
                        clickHandler = function (event) {
                            this.classList.remove('down');
                            selectRecord(element, this, true);
                        };
                    }
                } else {
                    // create click event function
                    clickHandler = function (event) {
                       //console.log(this, event);
                        this.classList.remove('down');
                        selectRecord(element, this, true);
                    };

                    // add click event with click event function to all record elements that are not dividers
                    i = 0;
                    len = arrElements.length;
                    while (i < len) {
                        if (!arrElements[i].classList.contains('divider')) {
                            arrElements[i].addEventListener('click', clickHandler);
                        }
                        i += 1;
                    }

                    // if we are not on a touch device: hover and down events
                    if (!evt.touchDevice) {
                        mousedownHandler = function () {
                            this.classList.add('down');
                        };
                        mouseoutHandler = function () {
                            this.classList.remove('down');
                            this.classList.remove('hover');
                        };
                        mouseoverHandler = function () {
                            this.classList.remove('down');
                            this.classList.add('hover');
                        };

                        // add click event with click event function to all record elements that are not dividers
                        i = 0;
                        len = arrElements.length;
                        while (i < len) {
                            if (!arrElements[i].classList.contains('divider')) {
                                arrElements[i].addEventListener(evt.mousedown, mousedownHandler);
                                arrElements[i].addEventListener(evt.mouseout, mouseoutHandler);
                                arrElements[i].addEventListener(evt.mouseover, mouseoverHandler);
                            }
                            i += 1;
                        }
                    }
                }

                var focusElement = document.createElement('textarea');
                focusElement.classList.add('hidden-focus-control');
                if (element.querySelector('tr[selected] td')) {
                    focusElement.setAttribute('value', element.querySelector('tr[selected] td').textContent || ' ');
                }
                focusElement.setAttribute('aria-owns', 'box-list-container-' + element.internal.id);

                element.appendChild(focusElement);
                element.hiddenFocusControl = focusElement;

                element.addEventListener('focus', function (event) {
                    event.preventDefault();
                    event.stopPropagation();
                    if (event.target !== element.hiddenFocusControl) {
                        element.hiddenFocusControl.focus();
                        GS.triggerEvent(element.hiddenFocusControl, 'focus');
                        element.skipFocus = true;
                    }
                });
                bindCopy(element);
            },

            triggerChange: function () {
                if (this.supressChange === true) {
                    this.supressChange = false;
                } else {
                    xtag.fireEvent(this, 'change', {
                        bubbles: true,
                        cancelable: true
                    });
                }
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    "use strict";
    designRegisterElement('gs-memo', '#controls_memo');

    window.designElementProperty_GSMEMO = function (selectedElement) {
        addGSControlProps();
        addText('O', 'Column In QS', 'qs');
        addText('V', 'Placeholder', 'placeholder');
        addText('V', 'Rows', 'rows');
        addText('D', 'Encrypted', 'encrypted');
        addText('D', 'Max-length', 'max-length');
        addAutocompleteProps();
        addCheck('D', 'Show Caps Lock', 'show-caps', 'false');
        addFocusEvents();
        addFlexProps();
    };
});

// trigger resize to text on window resize
window.addEventListener('resize', function () {
    var i, len, arrElements = document.getElementsByTagName('gs-memo');
    
    for (i = 0, len = arrElements.length; i < len; i += 1) {
        //if (arrElements[i].control.clientHeight < arrElements[i].control.scrollHeight) {
        arrElements[i].handleResizeToText();
        //}
    }
});


if (!evt.touchDevice) {
    window.gsmemoNew = {};
    window.gsmemoNew.bolFirstMouseMoveWhileDown = true;
    window.gsmemoNew.currentMouseTarget = null;
    
    window.addEventListener('mousemove', function (event) {
        var mousePosition, intWhich;// = GS.mousePosition(event);
        
        // firefox sometimes doesn't permit access to "event.which"
        //      so this try/catch statement will prevent the error and nothing will run
        try {
            intWhich = event.which;
        } catch (e) {}
        
        if (window.bolFirstMouseMoveWhileDown === true && intWhich !== undefined && intWhich !== 0) {
            mousePosition = GS.mousePosition(event);
            
            window.bolFirstMouseMoveWhileDown = false;
            window.gsmemoNew.currentMouseTarget = document.elementFromPoint(mousePosition.x, mousePosition.y);
            
        } else if (intWhich !== undefined && intWhich === 0) {
            window.bolFirstMouseMoveWhileDown = true;
        }
        
        if (window.gsmemoNew.currentMouseTarget &&
            intWhich !== undefined && intWhich !== 0 &&
            window.gsmemoNew.currentMouseTarget.nodeName === 'TEXTAREA' &&
            window.gsmemoNew.currentMouseTarget.parentNode.nodeName === 'GS-MEMO' && //event.target === element.control &&
            window.bolFirstMouseMoveWhileDown === false &&
                (window.gsmemoNew.currentMouseTarget.lastWidth !== window.gsmemoNew.currentMouseTarget.clientWidth ||
                window.gsmemoNew.currentMouseTarget.lastHeight !== window.gsmemoNew.currentMouseTarget.clientHeight)) {// && //element.control === window.lastMouseDownElement) {
            
            //GS.triggerEvent(window.gsmemoNew.currentMouseTarget.parentNode, 'size-changed');
            
            window.gsmemoNew.currentMouseTarget.style.margin = '';
            window.gsmemoNew.currentMouseTarget.style.marginLeft = '';
            window.gsmemoNew.currentMouseTarget.style.marginRight = '';
            window.gsmemoNew.currentMouseTarget.style.marginTop = '';
            window.gsmemoNew.currentMouseTarget.style.marginBottom = '';
            window.gsmemoNew.currentMouseTarget.lastWidth  = window.gsmemoNew.currentMouseTarget.clientWidth;
            window.gsmemoNew.currentMouseTarget.lastHeight = window.gsmemoNew.currentMouseTarget.clientHeight;
            
            GS.triggerEvent(window.gsmemoNew.currentMouseTarget.parentNode, 'size-changed');
            
        }
    });
    
    window.addEventListener('mouseup', function (event) {
        //var mousePosition = GS.mousePosition(event);
        
        window.bolFirstMouseMoveWhileDown = true;
        //window.lastMouseDownElement = element.control;
    });
}

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    
    var multiLineTemplateElement = document.createElement('template'),
        multiLineTemplate;
    
    multiLineTemplateElement.innerHTML = '<textarea class="control" gs-dynamic></textarea>';
    
    multiLineTemplate = multiLineTemplateElement.content;
    
    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
        event.target.parentNode.syncGetters();
        
        GS.triggerEvent(event.target.parentNode, 'change');
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        var element = event.target;
        if (element.hasAttribute('defer-insert')) {
            if (event.target.classList.contains('control')) {
                element = element.parentNode.parentNode;
            }
            element.removeEventListener('focus', focusFunction);
            element.classList.add('focus');
            element.appendChild(multiLineTemplate.cloneNode(true));
            if (element.control.value && element.control.value.length > 0) {
                if (element.bolSelect) {
                    element.control.setSelectionRange(0, element.control.value.length);
                } else {
                    element.control.setSelectionRange(element.control.value.length, element.control.value.length);
                }
            }
            element.bolSelect = true;
        } else {
            GS.triggerEvent(event.target.parentNode, 'focus');
            event.target.parentNode.classList.add('focus');
        }
    }

    // re-target blur event from control to element
    function blurFunction(event) {
                                
        GS.triggerEvent(event.target.parentNode, 'blur');
        event.target.parentNode.classList.remove('focus');
        if (event.target.parentNode.hasAttribute('defer-insert')) {
            event.target.parentNode.removeControl();
        }
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseout);
        event.target.parentNode.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseover);
        event.target.parentNode.classList.add('hover');
    }

    
    //
    function keydownFunction(event) {
        var element = event.target;
        if (!element.hasAttribute('readonly')) {
            if (element.hasAttribute('disabled') && !(event.keyCode === 122 && event.metaKey)) {
                event.preventDefault();
                event.stopPropagation();
            } else if (event.keyCode === 9 && element.parentNode.hasAttribute('allow-tab-char') === true) {
                event.preventDefault();
                event.stopPropagation();
                var cursor_pos_memo = parseInt(element.selectionStart, 10);
                element.value = element.value.substring(0, cursor_pos_memo) + '\t' + element.value.substring(cursor_pos_memo, element.value.length);
                GS.setInputSelection(element, parseInt(cursor_pos_memo, 10) + 1, parseInt(cursor_pos_memo, 10) + 1);
            } else {
                //this.parentNode.syncView();
                if (element.parentNode.hasAttribute('encrypted')) {
                    element.parentNode.setAttribute('value', CryptoJS.AES.encrypt(element.value, (window[element.parentNode.getAttribute('encrypted')] || '')));
                } else {
                    element.parentNode.setAttribute('value', element.value);
                }
                element.parentNode.handleResizeToText();
            }
        }
        // if (element.classList.contains('control')) {
        //     element = GS.findParentTag(element, 'gs-memo');
        // }
        // if (element.hasAttribute('encrypted')) {
        //     element.syncGetters();
        //     if (!element.hasAttribute('defer-insert')) {
        //         element.value = element.getAttribute('value');
        //     } else {
        //         element.value = CryptoJS.AES.encrypt(element.control.value, (window[element.getAttribute('encrypted')] || ''));
        //     }
        // }
    }
    
    //
    function keyupFunction(event) {
        var element = event.target;
        if (!element.hasAttribute('readonly')) {
            //this.parentNode.syncView();
            if (element.parentNode.hasAttribute('encrypted')) {
                element.parentNode.setAttribute('value', CryptoJS.AES.encrypt(element.value, (window[element.parentNode.getAttribute('encrypted')] || '')));
            } else {
                element.parentNode.setAttribute('value', element.value);
            }
            element.parentNode.handleResizeToText();
        }
    }
    
    function insertFunction(event) {
                                
        var element = event.target;
        element.parentNode.handleResizeToText();
    }
    
    ////
    //function createPushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //    
    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}
    
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function createPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.value = strQSValue;
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value) {
                element.setAttribute('value', element.value);
                delete element.value;
            }
        }
    }

    function findFor(element) {
        var forElem;
        if (element.previousElementSibling && element.previousElementSibling.tagName.toUpperCase() == 'LABEL'
            && element.previousElementSibling.hasAttribute('for')
            && element.previousElementSibling.getAttribute('for') == element.getAttribute('id')
        ) {
            forElem = element.previousElementSibling;
        } else if (xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]').length > 0) {
            forElem = xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]')[0];
        }
        if (forElem) {
            forElem.setAttribute('for', element.getAttribute('id') + '_control');
            if (element.control) {
                element.control.setAttribute('id', element.getAttribute('id') + '_control');
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }
            }
        }
    }

    //
    function elementInserted(element) {
        //var strQSValue;
        if (element.hasAttribute('encrypted') && !window[element.getAttribute('encrypted')] && !window['getting' + element.getAttribute('encrypted')]) {
            window['getting' + element.getAttribute('encrypted')] = true;
            GS.triggerEvent(element, 'password-error', {'reason': 'no', 'keyVariable': element.getAttribute('encrypted')});
        }
        if (element.hasAttribute('defer-insert')) {
            // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
            if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                // if this is the first time inserted has been run: continue
                if (!element.inserted) {
                    element.inserted = true;
                    element.internal = {};
                    saveDefaultAttributes(element);

                    if (!element.hasAttribute('tabindex')) {
                        element.setAttribute('tabindex', '0');
                    }
                    element.bolSelect = true;
                    element.skip = false;
                    var elementValue = (element.getAttribute('value') || '');
                    if (elementValue) {
                        if (element.hasAttribute('encrypted') && window[element.getAttribute('encrypted')]) {
                            elementValue = CryptoJS.AES.decrypt(element.getAttribute('value'), (window[element.getAttribute('encrypted')] || '')).toString(CryptoJS.enc.Utf8);
                            element.syncGetters();
                        } else if (element.hasAttribute('encrypted')) {
                            element.skip = true;
                        }
                        element.innerHTML = '<span class="control" gs-dynamic>' + elementValue + '</span>';
                        element.control = element.children[0];
                        if (element.hasAttribute('id')) {
                            element.control.setAttribute('id', element.getAttribute('id') + '_control');
                        }
                        if (element.hasAttribute('aria-labelledby')) {
                            element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                        }
                        if (element.hasAttribute('title')) {
                            element.control.setAttribute('title', element.getAttribute('title'));
                        }
                        if (!element.skip) {
                            element.control.value = elementValue;
                        }
                        element.syncGetters();
                    } else if (element.hasAttribute('placeholder')) {
                        element.innerHTML = '<span class="placeholder">' + element.getAttribute('placeholder') + '</span>';
                        element.control = false;
                    } else {
                        element.innerHTML = '<span class="control" gs-dynamic>' + elementValue + '</span>';
                        element.control = element.children[0];
                        if (element.hasAttribute('id')) {
                            element.control.setAttribute('id', element.getAttribute('id') + '_control');
                        }
                        if (element.hasAttribute('aria-labelledby')) {
                            element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                        }
                        if (element.hasAttribute('title')) {
                            element.control.setAttribute('title', element.getAttribute('title'));
                        }
                        if (!element.skip) {
                            element.control.value = elementValue;
                        }
                        element.syncGetters();
                    }
                    if (!element.hasAttribute('autoresize')) {
                        element.style.height = ((element.getAttribute('rows') || 2) * 1.2) + 'em';
                    }
                    if (element.control) {
                        element.control.lastWidth = element.control.clientWidth;
                        element.control.lastHeight = element.control.clientHeight;
                        element.syncView();
                    }
                    
                    element.addEventListener('focus', focusFunction);
                    if (evt.touchDevice) {
                        element.addEventListener(evt.click, focusFunction);
                        element.addEventListener(evt.mousedown, function (event) {
                            //alert(event.touches[0].clientX);
                            element.startX = event.touches[0].clientX;
                            element.startY = event.touches[0].clientY;
                            element.addEventListener('touchmove', function (event) {
                                //alert(event.touches[0].clientX);
                                element.lastX = event.touches[0].clientX;
                                element.lastY = event.touches[0].clientY;
                                
                            });
                        });
                        element.addEventListener(evt.mouseup, function (event) {
                            var element = event.target;
                            //alert(element.outerHTML);
                            //alert(element.startX + ' : ' + element.lastX + ' : ' + element.startY + ' : ' + element.lastY);
                            if (element.lastX && element.lastY &&
                                (parseInt(element.lastX, 10) > (parseInt(element.startX, 10) + 10) ||
                                parseInt(element.lastX, 10) < (parseInt(element.startX, 10) - 10) ||
                                parseInt(element.lastY, 10) > (parseInt(element.startY, 10) + 10) ||
                                parseInt(element.lastY, 10) < (parseInt(element.startY, 10) - 10))
                            ) {
                            } else {
                                focusFunction(event);
                            }
                            
                            /*//if event.target is the control
                            if (event.target.tagName === 'GS-TEXT') {
                                var element = event.target;
                                //alert(event.target.outerHTML);
                                //focus it
                                focusFunction(event);
                                //if we focused it prevent click event from happening
                                if (document.activeElement == element.control) {
                                    event.stopImmediatePropagation();
                                    event.stopPropagation();
                                    event.preventDefault();
                                }
                                //else the click event happens trying again
                            }*/
                        });
                    }
                    if (element.getAttribute('qs')) {
                        //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                        //
                        //if (strQSValue !== '' || !element.getAttribute('value')) {
                        //    element.value = strQSValue;
                        //}
    
                        createPushReplacePopHandler(element);
                        window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                        window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                        window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                    }
                }
            }
        } else {
            // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
            if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                // if this is the first time inserted has been run: continue
                if (!element.inserted) {
                    element.inserted = true;
                    element.internal = {};
                    saveDefaultAttributes(element);
                    
                    if (element.hasAttribute('tabindex')) {
                        element.setAttribute('data-tabindex', element.getAttribute('tabindex'));
                        element.removeAttribute('tabindex');
                    }
                    if (!element.children[0] || !element.children[0].classList.contains('control')) {
                        element.appendChild(multiLineTemplate.cloneNode(true));
                    }
                    if (element.hasAttribute('data-tabindex')) {
                        xtag.query(element, '.control')[0].setAttribute('tabindex', element.getAttribute('data-tabindex'));
                    }
                    // set a variable with the control element for convenience and speed
                    element.control = xtag.queryChildren(element, '.control')[0];
                    if (element.hasAttribute('id')) {
                        element.control.setAttribute('id', element.getAttribute('id') + '_control');
                    }
                    if (element.hasAttribute('aria-labelledby')) {
                        element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                    }
                    if (element.hasAttribute('title')) {
                        element.control.setAttribute('title', element.getAttribute('title'));
                    }
                    // console.log(element, element.getAttribute('rows'));
                    if (!element.hasAttribute('autoresize')) {
                        element.style.height = ((element.getAttribute('rows') || 2) * 1.2) + 'em';
                    }
                    // console.log(element, element.style.height);

                    element.control.lastWidth = element.control.clientWidth;
                    element.control.lastHeight = element.control.clientHeight;
                    element.syncView();

                    if (element.getAttribute('qs')) {
                        //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                        //
                        //if (strQSValue !== '' || !element.getAttribute('value')) {
                        //    element.value = strQSValue;
                        //}

                        createPushReplacePopHandler(element);
                        window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                        window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                        window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                    }
                }
            }
        }
        if (element.hasAttribute('id')) {
            findFor(element);
        }
    }

    xtag.register('gs-memo', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'value' && this.initalized && oldValue !== newValue) {
                    var currentValue = this.control.value;
                    var newCryptedValue = newValue;
                    // if there is a difference between the new value in the
                    //      attribute and the valued in the front end: refresh the front end
                    newCryptedValue = this.hasAttribute('uppercase') ? newCryptedValue.toUpperCase() : newCryptedValue;
                    currentValue = this.hasAttribute('uppercase') ? currentValue.toUpperCase() : currentValue;
                    if (newCryptedValue !== currentValue) {
                        this.setAttribute('value', newCryptedValue);
                        if (this.hasAttribute('encrypted')) {
                        } else {
                            this.control.value = newCryptedValue;
                        }
                    } else {
                        this.setAttribute('value', currentValue);
                        if (this.hasAttribute('encrypted')) {
                        } else {
                            this.control.value = currentValue;
                        }
                    }
                } else if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'disabled' && newValue !== null) {
                        this.innerHTML = this.getAttribute('value') || this.getAttribute('placeholder');
                    } else if (strAttrName === 'disabled' && newValue === null) {
                        this.innerHTML = '';
                        this.appendChild(multiLineTemplate.cloneNode(true));
                        if (this.hasAttribute('data-tabindex')) {
                            xtag.query(this, '.control')[0].setAttribute('tabindex', this.getAttribute('data-tabindex'));
                        }
                        // set a variable with the control element for convenience and speed
                        this.control = xtag.queryChildren(this, '.control')[0];
                        if (this.hasAttribute('id')) {
                            this.control.setAttribute('id', this.getAttribute('id') + '_control');
                        }
                        if (this.hasAttribute('aria-labelledby')) {
                            this.control.setAttribute('aria-labelledby', this.getAttribute('aria-labelledby'));
                        }
                        if (this.hasAttribute('title')) {
                            this.control.setAttribute('title', this.getAttribute('title'));
                        }
                        
                        this.control.lastWidth = this.control.clientWidth;
                        this.control.lastHeight = this.control.clientHeight;
                        this.syncView();
                    }
                }
            }
        },
        events: {},
        accessors: {
            value: {
                // get value straight from the input
                get: function () {
                    if (this.hasAttribute('defer-insert')) {
                        return this.getAttribute('value');
                    } else {
                        return this.getAttribute('value');
                    }
                },

                set: function (strNewValue) {
                    if (this.hasAttribute('defer-insert')) {
                        if (this.hasAttribute('encrypted')) {
                            if (CryptoJS.AES.decrypt(this.hasAttribute('uppercase') ? strNewValue.toUpperCase() : strNewValue, (window[this.getAttribute('encrypted')] || '')).toString(CryptoJS.enc.Utf8) === '') {
                                this.setAttribute('value', CryptoJS.AES.encrypt(this.hasAttribute('uppercase') ? strNewValue.toUpperCase() : strNewValue, (window[this.getAttribute('encrypted')] || '')));
                            } else {
                                this.setAttribute('value', this.hasAttribute('uppercase') ? strNewValue.toUpperCase() : strNewValue);
                            }
                        } else {
                            this.setAttribute('value', this.hasAttribute('uppercase') ? strNewValue.toUpperCase() : strNewValue);
                            this.syncView();
                        }
                    } else {
                        this.setAttribute('value', this.hasAttribute('uppercase') ? strNewValue.toUpperCase() : strNewValue);
                    }
                }
            },
            textValue: {
                // get value straight from the input
                get: function () {
                    if (this.hasAttribute('defer-insert')) {
                        if (this.control) {
                            return this.hasAttribute('uppercase') ? this.control.value.toUpperCase() : this.control.value;
                        } else {
                            return '';
                        }
                    } else {
                        if (this.control) {
                            return this.hasAttribute('uppercase') ? this.control.value.toUpperCase() : this.control.value;
                        } else {
                            return this.hasAttribute('uppercase') ? this.innerHTML.toUpperCase() : this.innerHTML;
                        }
                    }
                },
                
                // set the value attribute
                set: function (newValue) {
                    //this.setAttribute('value', newValue);
                    // this.value = newValue;
                
                    if (this.control) {
                        this.control.value = this.hasAttribute('uppercase') ? newValue.toUpperCase() : newValue;
                    } else {
                        this.innerHTML = this.hasAttribute('uppercase') ? newValue.toUpperCase() : newValue;
                    }
                }
            }
        },
        methods: {
            focus: function () {
                if (this.hasAttribute('defer-insert')) {
                    var element = this;
                    element.bolSelect = false;
                    focusFunction({ target: element });
                } else {
                    if (this.control) {
                        this.control.focus();
                    }
                }
                //GS.triggerEvent(element, 'focus');
            },

            removeControl: function () {
                var element = this;
                var elementHeight = element.control.clientHeight;
                var elementValue = element.control.value
                // if (element.hasAttribute('encrypted')) {
                //     elementValue = CryptoJS.AES.decrypt(elementValue, (window[this.getAttribute('encrypted')] || '')).toString(CryptoJS.enc.Utf8);
                // }
                if (element.control) {
                    element.setAttribute('tabindex', element.control.getAttribute('tabindex'));
                }
                if (element.control.value) {
                    element.innerHTML = '<span style="white-space: pre-wrap;" class="control" gs-dynamic></span>';
                    element.control = element.children[0];
                    
                    if (element.hasAttribute('id')) {
                        element.control.setAttribute('id', element.getAttribute('id') + '_control');
                    }
                    if (element.hasAttribute('aria-labelledby')) {
                        element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                    }
                    if (element.hasAttribute('title')) {
                        element.control.setAttribute('title', element.getAttribute('title'));
                    }
                    element.control.textContent = elementValue;
                    element.control.value = elementValue;
                    element.syncGetters();
                } else if (element.hasAttribute('placeholder')) {
                    element.innerHTML = '<span class="placeholder">' + element.getAttribute('placeholder') + '</span>';
                } else {
                    element.innerHTML = '<span style="white-space: pre-wrap;" class="control" gs-dynamic></span>';
                    element.control = element.children[0];
                    if (element.hasAttribute('id')) {
                        element.control.setAttribute('id', element.getAttribute('id') + '_control');
                    }
                    if (element.hasAttribute('aria-labelledby')) {
                        element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                    }
                    if (element.hasAttribute('title')) {
                        element.control.setAttribute('title', element.getAttribute('title'));
                    }
                    element.control.textContent = elementValue;
                    element.control.value = elementValue;
                    element.syncGetters();
                }
                element.style.height = elementHeight + 'px';
            },

            addControl: function () {
                var element = this;
                var arrPassThroughAttributes = [
                    'placeholder', 'name', 'maxlength', 'autocorrect',
                    'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                    'readonly', 'disabled'
                ];
                var i;
                var len;
                var elementValue = element.textContent || element.value || '';
                if (element.children[0] && element.children[0].classList.contains('placeholder')) {
                    elementValue = '';
                }
                // if the gs-text element has a tabindex: save the tabindex and remove the attribute
                if (element.hasAttribute('tabindex')) {
                    element.savedTabIndex = element.getAttribute('tabindex');
                    element.removeAttribute('tabindex');
                }
                // add control input and save it to a variable for later use
                element.innerHTML = '';
                element.innerHTML = '<textarea class="control" gs-dynamic></textarea>';//'<input class="control" gs-dynamic type="' + (element.getAttribute('type') || 'text') + '" />';
                element.control = element.children[0];
                if (element.hasAttribute('id')) {
                    element.control.setAttribute('id', element.getAttribute('id') + '_control');
                }
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }

                // bind event re-targeting functions
                element.control.removeEventListener('change', changeFunction);
                element.control.addEventListener('change', changeFunction);


                element.control.removeEventListener('blur', blurFunction);
                element.control.addEventListener('blur', blurFunction);

                element.removeEventListener(evt.mouseout, mouseoutFunction);
                element.addEventListener(evt.mouseout, mouseoutFunction);

                element.removeEventListener(evt.mouseout, mouseoverFunction);
                element.addEventListener(evt.mouseover, mouseoverFunction);
                // copy passthrough attributes to control
                i = 0;
                len = arrPassThroughAttributes.length;
                while (i < len) {
                    // console.log(arrPassThroughAttributes[i]);
                    if (element.hasAttribute(arrPassThroughAttributes[i])) {
                        // console.log('found', arrPassThroughAttributes[i]);
                        if (arrPassThroughAttributes[i] === 'disabled') {
                        // console.log('setting', 'readonly');
                            element.control.setAttribute(
                                'readonly',
                                element.getAttribute(arrPassThroughAttributes[i]) || ''
                            );
                        } else {
                            // console.log('setting', arrPassThroughAttributes[i]);
                            element.control.setAttribute(
                                arrPassThroughAttributes[i],
                                element.getAttribute(arrPassThroughAttributes[i]) || ''
                            );
                        }
                    }
                    i += 1;
                }
                element.control.value = elementValue;
                if (element.hasAttribute('encrypted')) {
                    element.value = CryptoJS.AES.encrypt(elementValue, (window[element.getAttribute('encrypted')] || ''));
                } else {
                    element.value = elementValue;
                }
                // if we saved a tabindex: apply the tabindex to the control
                if (element.savedTabIndex !== undefined && element.savedTabIndex !== null) {
                    element.control.setAttribute('tabindex', element.savedTabIndex);
                }
                //element.syncView();
                element.control.style.height = element.style.minHeight;
                element.control.focus();
                element.addEventListener('focus', focusFunction);
            },
            
            // sync control and resize to text
            syncView: function () {
                                
                var element = this, arrPassThroughAttributes, i, len;
                
                /*
                if (this.innerHTML === '') {
                    this.appendChild(multiLineTemplate.cloneNode(true));
                }
                */
                /*
                if ((! this.hasAttribute('disabled')) && (! this.control)) {
                    this.appendChild(multiLineTemplate.cloneNode(true));
                    // set a variable with the control element for convenience and speed
                    this.control = xtag.queryChildren(this, '.control')[0];
                    
                    this.control.lastWidth = this.control.clientWidth;
                    this.control.lastHeight = this.control.clientHeight;
                }
                */
                
                if (this.hasAttribute('rows')) {
                    if (this.control) {
                        this.control.setAttribute('rows', this.getAttribute('rows'));
                    }
                }
                
                if (this.control) {
                    this.control.removeEventListener('change', changeFunction);
                    this.control.addEventListener('change', changeFunction);
                    
                    this.control.removeEventListener('focus', focusFunction);
                    this.control.addEventListener('focus', focusFunction);
                    
                    this.control.removeEventListener('blur', blurFunction);
                    this.control.addEventListener('blur', blurFunction);

                    this.control.removeEventListener(evt.mouseout, mouseoutFunction);
                    this.control.addEventListener(evt.mouseout, mouseoutFunction);
                    
                    this.control.removeEventListener(evt.mouseout, mouseoverFunction);
                    this.control.addEventListener(evt.mouseover, mouseoverFunction);
                    
                    this.control.removeEventListener('keydown', keydownFunction);
                    this.control.addEventListener('keydown', keydownFunction);
                    
                    this.control.removeEventListener('keyup', keyupFunction);
                    this.control.addEventListener('keyup', keyupFunction);
                    
                    this.control.removeEventListener('insert', insertFunction);
                    this.control.addEventListener('insert', insertFunction);
                }
                //console.log(this.control.nodeName);
                if (this.control && this.control.nodeName === 'TEXTAREA') {
                    if (this.hasAttribute('encrypted')) {
                        if (window[this.getAttribute('encrypted')] && this.control.value !== this.getAttribute('value')) {
                            this.control.value = CryptoJS.AES.decrypt(this.getAttribute('value') || '', (window[this.getAttribute('encrypted')] || '')).toString(CryptoJS.enc.Utf8);
                            // this.innerHTML = CryptoJS.AES.decrypt(this.getAttribute('value') || '', (window[this.getAttribute('encrypted')] || '')).toString(CryptoJS.enc.Utf8);
                          //console.log(this.control.value);
                        } else {
                        }
                    } else {
                        this.control.value = this.getAttribute('value');
                    }
                } else {
                  //console.log(this.outerHTML);
                    if (this.hasAttribute('encrypted')) {
                        if (window[this.getAttribute('encrypted')] && this.control.value !== this.getAttribute('value')) {
                            this.control.innerHTML = CryptoJS.AES.decrypt(this.getAttribute('value'), (window[this.getAttribute('encrypted')] || '')).toString(CryptoJS.enc.Utf8) || this.getAttribute('placeholder') || '';
                        }
                    } else {
                        this.control.innerHTML = this.getAttribute('value') || this.getAttribute('placeholder') || '';
                    }
                    
                }
                    
                if (this.getAttribute('value')) {
                    this.handleResizeToText();
                }
                
                if (this.control) {
                    arrPassThroughAttributes = [
                        'placeholder',
                        'name',
                        'maxlength',
                        'autocorrect',
                        'autocapitalize',
                        'autocomplete',
                        'autofocus',
                        'rows',
                        'spellcheck',
                        'readonly'
                    ];
                    for (i = 0, len = arrPassThroughAttributes.length; i < len; i += 1) {
                        if (this.hasAttribute(arrPassThroughAttributes[i])) {
                            this.control.setAttribute(arrPassThroughAttributes[i], this.getAttribute(arrPassThroughAttributes[i]) || '');
                        }
                    }
                }
                this.initalized = true;
                
                // copy passthrough attributes to control
            },
            
            syncGetters: function () {
                if (this.control) {
                    if (this.hasAttribute('encrypted')) {
                        if (window[this.getAttribute('encrypted')]) {
                            this.setAttribute('value', CryptoJS.AES.encrypt(this.hasAttribute('uppercase') ? this.control.value.toUpperCase() : this.control.value, (window[this.getAttribute('encrypted')] || '')));
                        }
                    } else {
                        this.setAttribute('value', this.hasAttribute('uppercase') ? this.control.value.toUpperCase() : this.control.value);
                    }
                    
                }
            },
            
            // if element is multiline and autoresize is not turned off: resize the element to fit the content
            handleResizeToText: function () {
                var element = this, intMinHeight;
                
                if (element.control) {
                    if (element.hasAttribute('autoresize')) {
                        element.control.style.height = '';
                        intMinHeight = element.control.offsetHeight;
                        element.control.style.height = ''; // '0';
                        
                        if (element.control.scrollHeight > intMinHeight) {
                            element.control.style.height = (element.control.scrollHeight + 1) + 'px';
                        } else {
                            element.control.style.height = (intMinHeight + 1) + 'px';
                        }
                        
                        if (element.hasAttribute('defer-insert')) {
                            element.style.height = (parseInt(element.control.style.height.replace('px','')) + 2) + 'px';
                        }
                    }
                    
                    
                    if (element.control.lastWidth !== element.control.clientWidth && element.control.lastHeight !== element.control.clientHeight) {
                        element.control.lastWidth = element.control.clientWidth;
                        element.control.lastHeight = element.control.clientHeight;
                        
                        GS.triggerEvent(element, 'size-changed');
                    }
                }
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';
    registerDesignSnippet(
        '<gs-scroller>',
        '<gs-scroller>',
        'gs-scroller>\n' +
        '    <gs-scroller-inner style="width: ${1:1000px}; height: ${2:1000px};">\n' +
        '        ${0}\n' +
        '    </gs-scroller-inner>\n' +
        '</gs-scroller>'
    );
    designRegisterElement('gs-scroller', '#layout_scroller');

    window.designElementProperty_GSSCROLLER = function () {
    };
});


Math.easeOutQuad = function (current_time, start_value, end_change, end_time) {
    'use strict';
    // Quadratic equation (produced by Robert Penner (www.robertpenner.com))
    current_time /= end_time;
    return -end_change * current_time * (current_time - 2) + start_value;
};

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    // using element, direction and X delta: move element using quadratic equation
    function easeOutX(dragElement, target, bolRight, intXDelta, intervalEaseXID) {
        var intFrames = Math.ceil(intXDelta / 0.25), intFrame = 0, intInterval = 20
          , intTotalTime = (intFrames * intInterval);

        //console.log(bolRight, intXDelta);

        if (intXDelta > 5) {
            intervalEaseXID = setInterval(function () {
                var intLeft;
                
                if (intFrame < intFrames) {
                    intLeft = parseInt(dragElement.style.left, 10);
                    
                    if (bolRight) {
                        intLeft = intLeft - Math.easeOutQuad((intFrame * intInterval), intXDelta, -intXDelta, intTotalTime);
                    } else {
                        intLeft = intLeft + Math.easeOutQuad((intFrame * intInterval), intXDelta, -intXDelta, intTotalTime);
                    }
                    
                    setElementLeft(dragElement, target, intLeft);
                } else {
                    clearTimeout(intervalEaseXID);
                }
                
                intFrame += 1;
            }, intInterval);
        }
        return intervalEaseXID;
    }
    
    // using element, direction and Y delta: move element using quadratic equation
    function easeOutY(dragElement, target, bolBottom, intYDelta, intervalEaseYID) {
        var intFrames = Math.ceil(intYDelta / 0.25), intFrame = 0, intInterval = 20
          , intTotalTime = (intFrames * intInterval);
        
        if (intYDelta > 5) {
            intervalEaseYID = setInterval(function () {
                var intTop;
                
                if (intFrame < intFrames) {
                    intTop = parseInt(dragElement.style.top, 10);
                    
                    if (bolBottom) {
                        intTop = intTop - Math.easeOutQuad((intFrame * intInterval), intYDelta, -intYDelta, intTotalTime);
                    } else {
                        intTop = intTop + Math.easeOutQuad((intFrame * intInterval), intYDelta, -intYDelta, intTotalTime);
                    }
                    
                    setElementTop(dragElement, target, intTop);
                } else {
                    clearTimeout(intervalEaseYID);
                }
                
                intFrame += 1;
            }, intInterval);
        }
        return intervalEaseYID;
    }
    
    // set left and respect boundries
    function setElementLeft(dragElement, target, intLeft) {
        var intWidth = dragElement.offsetWidth, minRight = target.offsetWidth;
        
        // target right edge must never get < container right edge
        if ((intLeft + intWidth) < minRight) {
            intLeft = (minRight - intWidth);
        }
        
        // target left edge must never get > container left edge
        if (intLeft > 0) {
            intLeft = 0;
        }
        
        dragElement.style.left = intLeft + 'px';
    }
    
    // set top and respect boundries
    function setElementTop(dragElement, target, intTop) {
        var intHeight = dragElement.offsetHeight, minBottom = target.offsetHeight;
        
        // target bottom edge must never get < container bottom edge
        if ((intTop + intHeight) < minBottom) {
            intTop = (minBottom - intHeight);
        }
        
        // target top edge must never get > container top edge
        if (intTop > 0) {
            intTop = 0;
        }
        
        dragElement.style.top = intTop + 'px';
    }
    
    function handleVerticalBoundries(dragElement, target) {
        var intTop = parseFloat(dragElement.style.top)
          , intHeight = dragElement.offsetHeight
          , minBottom = target.offsetHeight;
        
        // target bottom edge must never get < container bottom edge
        if ((intTop + intHeight) < minBottom) {
            intTop = (minBottom - intHeight);
        }
        
        // target top edge must never get > container top edge
        if (intTop > 0) {
            intTop = 0;
        }
        
        dragElement.style.top = intTop + 'px';
    }
    
    function handleHorizontalBoundries(dragElement, target) {
        var intLeft = parseFloat(dragElement.style.left)
          , intWidth = dragElement.offsetWidth
          , minRight = target.offsetWidth;
        
        // target right edge must never get < container right edge
        if ((intLeft + intWidth) < minRight) {
            intLeft = (minRight - intWidth);
        }
        
        // target left edge must never get > container left edge
        if (intLeft > 0) {
            intLeft = 0;
        }
        
        dragElement.style.left = intLeft + 'px';
    }
    
    function bindEvents(element) {
        var target = element, dragElement = element.children[0], intervalEaseXID
          , intervalEaseYID, lastClearTime, intScrollDelta = 0, minZoom = 0.5
          , maxZoom = 6;
        
        // zoom with mousewheel
        target.addEventListener('wheel', function (event) {
            var intDelta = event.deltaY, intNewZoom, currentTime
              , jsnMousePosition = GS.mousePosition(event), mouseEMX, mouseEMY, mousePXX, mousePXY
              , jsnOffsets = GS.getElementOffset(dragElement)
              , jsnTargetOffset
              , intCurrentZoom = (parseFloat(dragElement.style.fontSize) || 1)
              , intOldHeight = dragElement.offsetHeight
              , intOldWidth = dragElement.offsetWidth
              , intNewHeight, intNewWidth, intWidthDifference, intHeightDifference
              , intRelativeX, intRelativeY, intPercentX, intPercentY;
            
            event.preventDefault();
            event.stopPropagation();
            
            // get mouse position over dragElement in ems
            mousePXY = (jsnMousePosition.y - jsnOffsets.top);
            mousePXX = (jsnMousePosition.x - jsnOffsets.left);
            
            mouseEMY = GS.pxToEm(dragElement, mousePXY);
            mouseEMX = GS.pxToEm(dragElement, mousePXX);
            //console.log(jsnOffsets.top, jsnMousePosition.y, mouseEMY);
            //console.log(jsnOffsets.left, jsnMousePosition.x, mouseEMX);
            
            //console.log(event, event.deltaY, intDelta);
            if (lastClearTime) {
                currentTime = new Date().getTime();
                
                //console.log(currentTime - lastClearTime);
                if ((currentTime - lastClearTime) > 200) {
                    intScrollDelta = 0;
                    lastClearTime = new Date().getTime();
                }
            }
            
            // need to add clear if change direction
            
            lastClearTime = new Date().getTime();
            
            // if negative delta: increase custom delta by 0.1
            //      (unless we're at the maximum zoom, in which case: reset the delta)
            if (intDelta < 0) {
                intScrollDelta = (intScrollDelta > 0 ? intScrollDelta : 0);
                intScrollDelta = 0.05;
                if (intCurrentZoom < maxZoom) {
                    intScrollDelta += 0.05;
                } else {
                    intScrollDelta = 0;
                }
                
            // if positive delta: decrease custom delta by 0.1
            //      (unless we're at the minimum zoom, in which case: reset the delta)
            } else {
                intScrollDelta = (intScrollDelta < 0 ? intScrollDelta : 0);
                intScrollDelta = -0.05;
                if (intCurrentZoom > minZoom) {
                    intScrollDelta -= 0.05;
                } else {
                    intScrollDelta = 0;
                }
            }
            
            // add new delta to current zoom
            intNewZoom = (intCurrentZoom + intScrollDelta);
            
            // if the new zoom is above 6em: cap it off at 6em
            intNewZoom = (intNewZoom > maxZoom ? maxZoom : intNewZoom);
            
            // if the new zoom is below minZoom: cap it off at minZoom
            intNewZoom = (intNewZoom < minZoom ? minZoom : intNewZoom);
            
            //console.log('1:' + intNewZoom, '2:' + intScrollDelta, '3:' + intCurrentZoom);
            
            // apply new zoom
            dragElement.style.fontSize = intNewZoom + 'em';
            
            if (intCurrentZoom !== intNewZoom) {
                // get new height
                intNewWidth = dragElement.offsetWidth;
                intNewHeight = dragElement.offsetHeight;
                
                // adjust to mouse position
                
                // get full height difference
                intWidthDifference = (intNewWidth - intOldWidth);
                intHeightDifference = (intNewHeight - intOldHeight);
                
                // get relative x and y
                jsnTargetOffset = GS.getElementOffset(dragElement);
                intRelativeX = (jsnMousePosition.x - jsnTargetOffset.left);
                intRelativeY = (jsnMousePosition.y - jsnTargetOffset.top);
                
                // get percentage of x and y
                intPercentX = ((intRelativeX / intOldWidth) * 100);
                intPercentY = ((intRelativeY / intOldHeight) * 100);
                
                //console.log(intNewWidth, intOldWidth, intWidthDifference, intRelativeX, intPercentX);
                //console.log(intNewHeight, intOldHeight, intHeightDifference, intRelativeY, intPercentY);
                
                // percentage of height difference
                dragElement.style.left = (parseFloat(dragElement.style.left || '0') - ((intWidthDifference / 100) * intPercentX)) + 'px';
                dragElement.style.top = (parseFloat(dragElement.style.top || '0') - ((intHeightDifference / 100) * intPercentY)) + 'px';
            }
            
            // handle boundries
            handleVerticalBoundries(dragElement, target);
            handleHorizontalBoundries(dragElement, target);
        });
        
        // scrolling by dragging
        target.addEventListener(evt.mousedown, function (event) {
            var jsnMousePosition = GS.mousePosition(event)
              , jsnTargetOffsets = GS.getElementOffset(target)
              , jsnOffsets = GS.getElementOffset(dragElement)
              , startX = jsnMousePosition.x
              , startY = jsnMousePosition.y
              , offsetX = jsnOffsets.left - jsnTargetOffsets.left
              , offsetY = jsnOffsets.top - jsnTargetOffsets.top
              , lastX = 0, lastY = 0, currentX = 0, currentY = 0
              , deltaX, deltaY
              , mousemoveHandler, mouseupHandler;
            
            // stop text selection
            event.preventDefault();
            
            // stop easing functions
            clearTimeout(intervalEaseXID);
            clearTimeout(intervalEaseYID);
            
            // add "down" class
            dragElement.classList.add('down');
            
            mousemoveHandler = function (event) {
                var jsnMousePosition;
                
                if (event.which === 0 && !evt.touchDevice) {
                    mouseupHandler(event);
                    
                } else {
                    // handle move
                    jsnMousePosition = GS.mousePosition(event);
                    
                    // saving the current postition and the previous position for calculating the delta
                    lastX = currentX;
                    lastY = currentY;
                    currentX = jsnMousePosition.x;// - jsnTargetOffsets.left;
                    currentY = jsnMousePosition.y;// - jsnTargetOffsets.top;
                    
                    // moving element
                    //console.log(offsetX, currentX, startX);//, jsnTargetOffsets.left);
                    //console.log(offsetY, currentY, startY);//, jsnTargetOffsets.top);
                    setElementLeft(dragElement, target, (offsetX + (currentX - startX)));
                    setElementTop(dragElement, target, (offsetY + (currentY - startY)));
                    
                    event.preventDefault();
                }
            };
            
            mouseupHandler = function (event) {
                // calculate delta
                deltaX = lastX - currentX;
                deltaY = lastY - currentY;
                
                // ease out
                intervalEaseXID = easeOutX(dragElement, target, (deltaX > 0), Math.abs(deltaX), intervalEaseXID);
                intervalEaseYID = easeOutY(dragElement, target, (deltaY > 0), Math.abs(deltaY), intervalEaseYID);
                
                // remove "down" class
                dragElement.classList.remove('down');
                
                // unbind mousemove and mouseup
                document.body.removeEventListener(evt.mousemove, mousemoveHandler);
                document.body.removeEventListener(evt.mouseup, mouseupHandler);
            };
            
            document.body.addEventListener(evt.mousemove, mousemoveHandler);
            document.body.addEventListener(evt.mouseup, mouseupHandler);
        });
    }
    
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            
        }
    }
    
    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                
                if (element.children.length > 1) {
                    throw 'gs-scroller Error: Too many children. gs-scroller elements must have one child and it must be a <gs-scroller-inner> element.';
                    
                } else if (element.children.length === 0) {
                    throw 'gs-scroller Error: No children. gs-scroller elements must have one child and it must be a <gs-scroller-inner> element.';
                    
                } else if (element.children[0].nodeName !== 'GS-SCROLLER-INNER') {
                    throw 'gs-scroller Error: Invalid child. gs-scroller elements must have one child and it must be a <gs-scroller-inner> element.';
                }
                
                // if we're not on a touch device: bind events and set the title text
                if (!evt.touchDevice) {
                    // bind events
                    bindEvents(element);
                    
                    // title text
                    element.children[0].setAttribute('title', 'Click and drag to move around, scroll to zoom.');
                    
                // else: make the element scrollable
                } else {
                    element.classList.add('scrollable');
                }
            }
        }
    }
    
    xtag.register('gs-scroller-inner', {});
    xtag.register('gs-scroller', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    
                }
            }
        },
        events: {},
        accessors: {},
        methods: {}
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    "use strict";
    registerDesignSnippet(
        '<gs-number>',
        '<gs-number>',
        'gs-number column="${1:name}"></gs-number>'
    );
    registerDesignSnippet(
        '<gs-number> With Label',
        '<gs-number>',
        (
            'label for="${1:text-insert-account-name}">${2:Account Name}:</label>\n' +
            '<gs-number id="${1:date-insert-account-name}" column="${3:account_name}"></gs-number>'
        )
    );

    designRegisterElement('gs-number', '#controls_text');

    window.designElementProperty_GSTEXT = function () {
        addGSControlProps();
        addText('O', 'Column In QS', 'qs');
        addText('V', 'Placeholder', 'placeholder');
        addText('D', 'Max-length', 'max-length');
        addAutocompleteProps();
        addCheck('V', 'Show Caps Lock', 'show-caps', 'false');
        addFocusEvents();
        addFlexProps();
    };
});

window.addEventListener('keydown', function (event) {
    window.caps = event.getModifierState && event.getModifierState('CapsLock');
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
        event.target.parentNode.syncGetters();//iphone sometimes doesn't do a key like with time wheels

        GS.triggerEvent(event.target.parentNode, 'change');

        return false;
    }

    function focusNextElement() {
        //add all elements we want to include in our selection
        var focussableElements = 'a:not([disabled]), button:not([disabled]), input:not([disabled]), gs-button:not([disabled])';
        if (document.activeElement) {
            var focussable = Array.prototype.filter.call(document.querySelectorAll(focussableElements),
            function (element) {
                //check for visibility while always include the current activeElement 
                return element.offsetWidth > 0 || element.offsetHeight > 0 || element === document.activeElement
            });
            var index = focussable.indexOf(document.activeElement);
            if(index > -1) {
               var nextElement = focussable[index + 1] || focussable[0];
               nextElement.focus();
            }                    
        }
    }

    function checkMaxLength(event) {
        var element = event.target;
        if (element.classList.contains('control')) {
            element = GS.findParentTag(element, 'gs-number');
        }
        element.syncGetters();
        if (element.hasAttribute('max-length') && element.value.length >= element.getAttribute('max-length')) {
            if (element.value.length > element.getAttribute('max-length')) {
                element.value = element.value.substring(0,element.getAttribute('max-length'));
            }
            if (element.control.hasAttribute('tabindex') && xtag.query(document, '[tabindex="' + (parseInt(element.control.getAttribute('tabindex'), 10) + 1) + '"]').length > 0) {
                xtag.query(document, '[tabindex="' + (parseInt(element.control.getAttribute('tabindex'), 10) + 1) + '"]')[0].focus();
            // find next focusable element
            } else {
                focusNextElement();
            }
        }
    }
    
    function CapsLock(event) {
        var element = event.target;
        if (element.classList.contains('control')) {
            element = GS.findParentTag(element, 'gs-number');
        }
        var temp_caps = event.getModifierState && event.getModifierState( 'CapsLock' );
        if (temp_caps) {
            element.classList.add('caps');
        } else {
            if (element.classList.contains('caps')) {
                element.classList.remove('caps');
            }
        }
    }

    function focusFunction(event) {
        var element = event.target;
        if (element.classList.contains('focus')) {
            return;
        }
        
        element = element.parentNode;
        GS.triggerEvent(event.target.parentNode, 'focus');
        event.target.parentNode.classList.add('focus');
        if (window.caps) {
            element.classList.add('caps');
        }
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        var element = event.target.parentNode;
        GS.triggerEvent(event.target.parentNode, 'blur');
        event.target.parentNode.classList.remove('focus');
        //remove icon
        if (element.classList.contains('caps')) {
            element.classList.remove('caps');
        }
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseout);
        event.target.parentNode.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseover);
        event.target.parentNode.classList.add('hover');
    }

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function createPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.value = strQSValue;
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value) {
                element.setAttribute('value', element.value);
                delete element.value;
            }
        }
    }

    function findFor(element) {
        var forElem;
        if (element.previousElementSibling && element.previousElementSibling.tagName.toUpperCase() == 'LABEL'
            && element.previousElementSibling.hasAttribute('for')
            && element.previousElementSibling.getAttribute('for') == element.getAttribute('id')
        ) {
            forElem = element.previousElementSibling;
        } else if (xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]').length > 0) {
            forElem = xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]')[0];
        }
        if (forElem) {
            forElem.setAttribute('for', element.getAttribute('id') + '_control');
            if (element.control) {
                element.control.setAttribute('id', element.getAttribute('id') + '_control');
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }
            }
        }
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                // handle control
                element.handleContents();

                // fill control
                element.syncView();

                // bind/handle query string
                if (element.getAttribute('qs')) {
                    createPushReplacePopHandler(element);
                    window.addEventListener('pushstate', function () {
                        createPushReplacePopHandler(element);
                    });
                    window.addEventListener('replacestate', function () {
                        createPushReplacePopHandler(element);
                    });
                    window.addEventListener('popstate', function () {
                        createPushReplacePopHandler(element);
                    });
                }

                // if this element is empty when it is inserted: initalize
                if (element.innerHTML.trim() === '') {
                    // handle control
                    element.handleContents();

                    // fill control
                    element.syncView();
                }
            }
        }

        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            if (element.hasAttribute('id')) {
                findFor(element);
            }
        }
    }

    xtag.register('gs-number', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(element);
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);

                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    var currentValue;

                    if (strAttrName === 'disabled' || strAttrName === 'readonly') {
                        // handle control
                        element.handleContents();

                        // fill control
                        element.syncView();

                    } else if (strAttrName === 'value' && element.initalized) {
                        currentValue = element.control.value;

                        // if there is a difference between the new value in the
                        //      attribute and the valued in the front end: refresh the front end
                        if (newValue !== currentValue) {
                            element.syncView();
                        }
                    }
                    var arrPassThroughAttributes = [
                            'placeholder', 'name', 'maxlength', 'autocorrect',
                            'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                            'readonly', 'disabled'
                        ];
                    if (element.control) {
                        if (element.hasAttribute(strAttrName) && arrPassThroughAttributes.indexOf(strAttrName) !== -1) {
                            element.control.setAttribute(strAttrName, newValue);
                        }
                        if (!element.hasAttribute(strAttrName) && element.control.hasAttribute(strAttrName) && arrPassThroughAttributes.indexOf(strAttrName) !== -1) {
                            element.control.removeAttribute(strAttrName);
                        }
                    }
                }
            }
        },
        events: {
            // on keydown and keyup sync the value attribute and the control value
            'keydown': function (event) {
                var element = this;
                this.control.value = this.control.value.replace(/[^0-9\.]/g,'');
                if (!element.hasAttribute('readonly') && !element.hasAttribute('disabled')) {
                        element.syncGetters();
                }
            },
            'keyup': function () {
                var element = this;
                this.control.value = this.control.value.replace(/[^0-9\.]/g,'');
                if (!element.hasAttribute('readonly') && !element.hasAttribute('disabled')) {
                    element.syncGetters();
                }
            }
        },
        accessors: {
            value: {
                // get value straight from the input
                get: function () {
                    var element = this;
                    return this.getAttribute('value');
                },

                // set the value of the input and set the value attribute
                set: function (strNewValue) {
                    this.setAttribute('value', strNewValue);
                }
            }
        },
        methods: {
            focus: function () {
                var element = this;
                if (element.control) {
                    element.control.focus();
                }
            },

            handleContents: function () {
                var element = this;
                var arrPassThroughAttributes = [
                        'placeholder', 'name', 'maxlength', 'autocorrect',
                        'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                        'readonly', 'disabled'
                    ];
                var i;
                var len;

                // if the gs-number element has a tabindex: save the tabindex and remove the attribute
                if (element.hasAttribute('tabindex')) {
                    element.savedTabIndex = element.getAttribute('tabindex');
                    element.removeAttribute('tabindex');
                }

                element.innerHTML = '<input class="control" gs-dynamic type="' + ((element.getAttribute('input-type') || element.getAttribute('type')) || 'text') + '" />';
                element.control = element.children[0];
                if (element.hasAttribute('id')) {
                    element.control.setAttribute('id', element.getAttribute('id') + '_control');
                }
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('aria-label')) {
                    element.control.setAttribute('aria-label', element.getAttribute('aria-label'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }

                // bind event re-targeting functions
                element.control.removeEventListener('keydown', CapsLock);
                element.control.addEventListener('keydown', CapsLock);

                element.control.removeEventListener('change', changeFunction);
                element.control.addEventListener('change', changeFunction);

                element.control.removeEventListener('focus', focusFunction);
                element.control.addEventListener('focus', focusFunction);
                
                element.removeEventListener('keyup', checkMaxLength);
                element.addEventListener('keyup', checkMaxLength);

                element.control.removeEventListener('blur', blurFunction);
                element.control.addEventListener('blur', blurFunction);

                element.control.removeEventListener(evt.mouseout, mouseoutFunction);
                element.control.addEventListener(evt.mouseout, mouseoutFunction);
                
                element.control.removeEventListener(evt.mouseout, mouseoverFunction);
                element.control.addEventListener(evt.mouseover, mouseoverFunction);
                
                // copy passthrough attributes to control
                i = 0;
                len = arrPassThroughAttributes.length;
                while (i < len) {
                    if (element.hasAttribute(arrPassThroughAttributes[i])) {
                        if (arrPassThroughAttributes[i] === 'disabled') {
                            element.control.setAttribute(
                                'readonly',
                                element.getAttribute(arrPassThroughAttributes[i]) || ''
                            );
                        } else {
                            element.control.setAttribute(
                                arrPassThroughAttributes[i],
                                element.getAttribute(arrPassThroughAttributes[i]) || ''
                            );
                        }
                    }
                    i += 1;
                }

                // if we saved a tabindex: apply the tabindex to the control
                if (element.savedTabIndex !== undefined && element.savedTabIndex !== null) {
                    element.control.setAttribute('tabindex', element.savedTabIndex);
                }
            },

            syncView: function () {
                var element = this;
                element.control.value = ((element.getAttribute('value') === '\\N') ? '' : element.getAttribute('value') || '');
                element.initalized = true;
                
            },

            syncGetters: function () {
                var element = this;
                element.setAttribute('value', (element.control.value || '\\N'));
            }
        }
    });
});
//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, addFocusEvents
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    "use strict";

    addSnippet(
        '<gs-optionbox>',
        '<gs-optionbox>',
        (
            'gs-optionbox column="${1}">\n' +
            '    <gs-option value="${2}">${3}</gs-option>\n' +
            '</gs-optionbox>'
        )
    );

    addElement('gs-optionbox', '#controls_optionbox');
    addElement('gs-option', '#controls_optionbox');

    window.designElementProperty_GSOPTIONBOX = function () {
        addGSControlProps();
        addCheck('D', 'Clearable', 'clearable');
        addText('O', 'Column In QS', 'qs');
        addCheck('V', 'No Targets', 'no-target');
        addFocusEvents();
        addFlexContainerProps();
        addFlexProps();
    };

    window.designElementProperty_GSOPTION = function () {
        addText('Value', 'value');
        addFlexContainerProps();
        addFlexProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    // removes selected attribute from old selected option adds selected attribute to option
    function highlightOption(element, option, bolFocus) {
        var i;
        var len;
        var arrSelectedOptions;
        var arrAriaSelectedOptions;

        // clear previous selection
        arrSelectedOptions = xtag.query(element, 'gs-option[selected]');
        arrAriaSelectedOptions = xtag.query(element, 'gs-option');
        i = 0;
        len = arrSelectedOptions.length;
        while (i < len) {
            arrSelectedOptions[i].removeAttribute('selected');
            if (!arrSelectedOptions[i].hasAttribute('no-focus')) {
                arrSelectedOptions[i].setAttribute('tabindex', '-1');
            }
            i += 1;
        }

        i = 0;
        len = arrAriaSelectedOptions.length;
        while (i < len) {
            arrAriaSelectedOptions[i].setAttribute('aria-checked', 'false');
            i += 1;
        }

        // select/highlight the record that was provided
        if (option) {
            option.setAttribute('selected', '');
            option.setAttribute('aria-checked', 'true');

            if (!option.hasAttribute('no-focus')) {
                option.setAttribute('tabindex', '0');
                if (bolFocus) {
                    option.focus();
                }
            }
        }
    }

    // loops through the options and finds a option using the parameter
    function findOptionFromString(element, strSearchString) {
        var i;
        var len;
        var matchedOption;
        var arrOptions = xtag.query(element, 'gs-option');

        // search exact text and search both the value attribute (if present) and the text content
        i = 0;
        len = arrOptions.length;
        while (i < len) {
            if (arrOptions[i].getAttribute('value') === strSearchString || arrOptions[i].textContent === strSearchString) {
                matchedOption = arrOptions[i];
                break;
            }
            i += 1;
        }

        return matchedOption;
    }

    function selectOption(element, handle, bolChange) {
        var option;
        var strOptionValue;
        var strOptionText;

        if (typeof handle === 'string') {
            option = findOptionFromString(element, handle);

            if (!option) {
                throw 'gs-optionbox Error: value: \'' + handle + '\' not found.';
            }
        } else {
            option = handle;
        }

        highlightOption(element, option, bolChange); //if bolChange is true, focus selected control

        if (option) {
            strOptionValue = option.getAttribute('value');
            strOptionText = option.textContent;
        } else {
            strOptionValue = '';
            strOptionText = '';
        }

        if (element.value !== (strOptionValue || strOptionText)) {
            element.innerValue = strOptionValue || strOptionText;
            element.innerSelectedOption = option;

            if (bolChange) {
                xtag.fireEvent(element, 'change', {bubbles: true, cancelable: true});
            }
        }
    }

    // #################################################################
    // ########################## USER EVENTS ##########################
    // #################################################################
    // handle behaviours on keydown
    function handleKeyDown(event) {
        //console.log('handleKeyDown', event, event.target);
        var element = GS.findParentTag(event.target, 'gs-optionbox');
        var intKeyCode = event.keyCode || event.which;
        var selectedOption;
        var selectedOptionIndex;
        var arrOptions;
        var i;
        var len;

        if (!element.hasAttribute('disabled') && event.target.tagName.toUpperCase() === 'GS-OPTION') {
            if ((intKeyCode === 40 || intKeyCode === 39 || intKeyCode === 38 || intKeyCode === 37) && !event.shiftKey && !event.metaKey && !event.ctrlKey && !element.error) {
                arrOptions = xtag.query(element, 'gs-option');

                i = 0;
                len = arrOptions.length;
                while (i < len) {
                    if (arrOptions[i].hasAttribute('selected')) {
                        selectedOptionIndex = i;
                        selectedOption = arrOptions[i];
                    }

                    if (selectedOption) {
                        break;
                    }

                    i += 1;
                }

                //console.log(selectedOption, selectedOptionIndex, arrOptions.length);

                if (selectedOption && selectedOptionIndex !== arrOptions.length - 1 && (intKeyCode === 40 || intKeyCode === 39)) {
                    selectOption(element, arrOptions[selectedOptionIndex + 1], true);
                } else if (selectedOption && selectedOptionIndex !== 0 && (intKeyCode === 38 || intKeyCode === 37)) {
                    selectOption(element, arrOptions[selectedOptionIndex - 1], true);
                // select first record
                } else if (intKeyCode === 40 || intKeyCode === 39) {
                    selectOption(element, arrOptions[0], true);
                // select last record
                } else if (intKeyCode === 38 || intKeyCode === 37) {
                    selectOption(element, arrOptions[arrOptions.length - 1], true);
                }
                event.preventDefault();
                event.stopPropagation();

            }
        } else if (event.target.tagName.toUpperCase() === 'GS-OPTION') {
            if (event.keyCode !== 9) {
                event.preventDefault();
                event.stopPropagation();
            }
        }

        //console.log('handleKeyDown', intKeyCode, event);
    }
    function handleKeyPress(event) {
        //console.log('handleKeyPress', event, event.target);
        var element = event.target;
        var intKeyCode = event.keyCode || event.which;

        if (!element.hasAttribute('disabled') && event.target.tagName.toUpperCase() === 'GS-OPTION') {
            if ((intKeyCode === 40 || intKeyCode === 39 || intKeyCode === 38 || intKeyCode === 37) && !event.shiftKey && !event.metaKey && !event.ctrlKey && !element.error) {
                event.preventDefault();
                event.stopPropagation();

            }
        } else if (event.target.tagName.toUpperCase() === 'GS-OPTION') {
            if (event.keyCode !== 9) {
                event.preventDefault();
                event.stopPropagation();
            }
        }

        //console.log('handleKeyDown', intKeyCode, event);
    }

    function getParentOption(element) {
        var currentElement = element;

        while (currentElement.nodeName !== 'GS-OPTION' && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }

        if (currentElement.nodeName !== 'GS-OPTION') {
            return undefined;
        }

        return currentElement;
    }

    //function createPushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //
    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function createPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    function enhanceChildren(element) {
        var arrElement;
        var i;
        var len;

        arrElement = xtag.query(element, 'gs-option');

        i = 0;
        len = arrElement.length;
        while (i < len) {
            // this if allows the developer to define the icon position
            if (!arrElement[i].hasAttribute('icontop')
                    && !arrElement[i].hasAttribute('iconleft')
                    && !arrElement[i].hasAttribute('iconbottom')
                    && !arrElement[i].hasAttribute('iconright')) {
                arrElement[i].setAttribute('iconleft', '');
            }
            arrElement[i].setAttribute('icon', '');
            arrElement[i].setAttribute('role', 'radio');
            if (!arrElement[i].hasAttribute('no-focus')) {
                arrElement[i].setAttribute('tabindex', '-1');
                // arrElement[i].addEventListener('focus', function () {
                //     selectOption(element, this, true);
                // });
            }
            i += 1;
        }
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value) {
                element.setAttribute('value', element.value);
                delete element.value;
                // element.value = null;
            }
        }
    }

    function findFor(element) {
        var forElem;
        //console.log(element, element.previousElementSibling)
        if (element.previousElementSibling && element.previousElementSibling.tagName.toUpperCase() == 'LABEL'
            && element.previousElementSibling.hasAttribute('for')
            && element.previousElementSibling.getAttribute('for') == element.getAttribute('id')
        ) {
            forElem = element.previousElementSibling;
        } else if (xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]').length > 0) {
            forElem = xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]')[0];
        }

        //console.log(forElem);
        if (forElem) {
            if (! element.hasAttribute('aria-label')) {
                element.setAttribute('aria-label', forElem.innerText);
            }
        }
    }

    //
    function elementInserted(element) {
        var strQSValue;
        var observer;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (!element.hasAttribute('role')) {
                    element.setAttribute('role', 'radiogroup');
                }

                //// allows the element to have focus
                //if (!element.hasAttribute('tabindex')) {
                //    element.setAttribute('tabindex', '0');
                //}

                if (element.getAttribute('value')) {
                    selectOption(element, element.getAttribute('value'), false);
                }

                if (element.getAttribute('qs')) {
                    //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));

                    //if (strQSValue !== '') {
                    //    selectOption(element, strQSValue, false);
                    //}
                    createPushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                }

                // if we are not [no-target]
                if (!element.hasAttribute('no-target')) {
                    enhanceChildren(element);

                    // put an observer on the option element to enhance new children

                    // create an observer instance
                    observer = new MutationObserver(function(mutations) {
                        var bolRefreshOptionList = true;

                        // check each mutation: if only option and optgroup tags were added: refersh option tags in select
                        mutations.forEach(function(mutation) {
                            var i;
                            var len;

                            i = 0;
                            len = mutation.addedNodes.length;
                            while (i < len) {
                                if (mutation.addedNodes[i].nodeName !== 'GS-OPTION') {
                                    bolRefreshOptionList = false;
                                }
                                i += 1;
                            }
                        });

                        if (bolRefreshOptionList) {
                            enhanceChildren(element);
                        }
                    });

                    // pass in the element node, as well as the observer options
                    observer.observe(element, {childList: true});
                }
            }
        }
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            if (element.hasAttribute('id')) {
                //console.log('running');
                findFor(element);
            }
        }
    }

    xtag.register('gs-optionbox', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;

                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(element);
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);

                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value' && newValue !== oldValue) {
                        selectOption(element, newValue);
                    }
                }
            }
        },
        events: {
            'keydown': function (event) {
                var element = this;

                if (
                    !element.hasAttribute('suspend-created') &&
                    !element.hasAttribute('suspend-inserted')
                ) {
                    handleKeyDown(event);
                }
            },
            'keypress': function (event) {
                var element = this;

                if (
                    !element.hasAttribute('suspend-created') &&
                    !element.hasAttribute('suspend-inserted')
                ) {
                    handleKeyPress(event);
                }
            },

            'click': function (event) {
                var element = this;

                if (
                    !element.hasAttribute('suspend-created') &&
                    !element.hasAttribute('suspend-inserted') &&
                    !element.hasAttribute('readonly')
                ) {
                    var parentOption = getParentOption(event.target);

                    //console.log(parentOption);

                    //  else if (this.hasAttribute('clearable') && newValue === oldValue) {
                    //   //console.log('running');
                    //     selectOption(this, undefined);
                    // }

                    if (parentOption && !parentOption.hasAttribute('selected')) {
                        selectOption(element, parentOption, true);
                    } else if (parentOption && parentOption.hasAttribute('selected') && element.hasAttribute('clearable')) {
                        selectOption(element, (element.getAttribute('empty-value') || undefined), (element.getAttribute('empty-value') ? true : undefined));
                    }
                }
            }
        },
        accessors: {
            value: {
                get: function () {
                    return this.innerValue;
                },
                set: function (strNewValue) {
                    selectOption(this, String(strNewValue));
                }
            },

            selectedOption: {
                get: function () {
                    return this.innerSelectedOption;
                },
                set: function (newValue) {
                    selectOption(this, newValue);
                }
            },

            textValue: {
                get: function () {
                    return this.innerSelectedOption.textContent;
                },
                set: function (newValue) {
                    selectOption(this, newValue);
                }
            }
        }
    });
});
//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    "use strict";
    addSnippet(
        'Empty <gs-page>',
        '<gs-page>',
        (
            'gs-page>\n' +
            '    $0\n' +
            '</gs-page>'
        )
    );
    addSnippet(
        '<gs-page> With Header',
        '<gs-page>',
        (
            'gs-page>\n' +
            '    <gs-header>\n' +
            '        <center><h3>${1}</h3></center>\n' +
            '    </gs-header>\n' +
            '    <gs-body>\n' +
            '        $0\n' +
            '    </gs-body>\n' +
            '</gs-page>'
        )
    );
    addSnippet(
        'Full <gs-page>',
        '<gs-page>',
        (
            'gs-page>\n' +
            '    <gs-header>\n' +
            '        <center><h3>${1}</h3></center>\n' +
            '    </gs-header>\n' +
            '    <gs-body>\n' +
            '        $0\n' +
            '    </gs-body>\n' +
            '    <gs-footer>${2}</gs-footer>\n' +
            '</gs-page>'
        )
    );

    addElement('gs-page', '#layout_page');

    window.designElementProperty_GSPAGE = function () {
        addFlexProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            var observer;
            var headerElement = xtag.queryChildren(element, 'gs-header')[0];
            var footerElement = xtag.queryChildren(element, 'gs-footer')[0];

            // create an observer instance
            observer = new MutationObserver(function(mutations) {
                element.recalculatePadding();
                //console.log('mutation observed');
            });

            // pass in the element node, as well as the observer options
            if (headerElement) {
                observer.observe(headerElement, {childList: true, subtree: true});
            }
            if (footerElement) {
                observer.observe(footerElement, {childList: true, subtree: true});
            }
        }
    }
    
    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                
                element.recalculatePadding();
                
                window.addEventListener('load', function () {
                    element.recalculatePadding();
                });
                window.addEventListener('resize', function () {
                    element.recalculatePadding();
                });
                element.recalculatePadding();
                if (element.parentNode.tagName.toLowerCase() === 'gs-dialog') {
                    element.setAttribute('role', 'complementary');
                }
            }
        }
    }
    
    xtag.register('gs-page', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // attribute code
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            recalculatePadding: function () {
                var headerElement = xtag.queryChildren(this, 'gs-header')[0],
                    footerElement = xtag.queryChildren(this, 'gs-footer')[0];
                
                if (headerElement) {
                    //console.log('1***', headerElement.offsetHeight);
                    this.style.paddingTop = headerElement.offsetHeight + 'px';
                } else {
                    this.style.paddingTop = '';
                }
                if (footerElement) {
                    //console.log('2***', footerElement.offsetHeight);
                    this.style.paddingBottom = footerElement.offsetHeight + 'px';
                } else {
                    this.style.paddingBottom = '';
                }
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';
    addSnippet(
        '<gs-panel>',
        '<gs-panel>',
        (
            'gs-panel id="panel">\n' +
            '    <gs-page id="${1:left-bar}" style="width: 17em;">\n' +
            '        \n' +
            '    </gs-page>\n' +
            '    <gs-page>\n' +
            '        \n' +
            '    </gs-page>\n' +
            '</gs-panel>'
        )
    );

    addElement('gs-panel', '#layout_panel');

    window.designElementProperty_GSPANEL = function(selectedElement) {
        addCheck('O', 'Dismissible By Clicking The Shadow', 'no-shadow-dismiss');
        addCheck('O', 'Dismissible On Desktop', 'dismissible');
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    function pushReplacePopHandler(element) {
        var query = GS.getQueryString();
        var arrQueryKeys = GS.qryGetKeys(query);
        var strID = element.getAttribute('id');
        var strAttributeName;
        var i;
        var len;
        var strNewValue;

        for (i = 0, len = arrQueryKeys.length; i < len; i += 1) {
            if (arrQueryKeys[i].indexOf(strID + '.') === 0 &&
                element.panelIDs.indexOf(arrQueryKeys[i].split('.')[1]) > -1) {
                
                strAttributeName = arrQueryKeys[i].split('.')[1];
                strNewValue = GS.qryGetVal(query, arrQueryKeys[i]);
                
                if (element.getAttribute(strAttributeName) !== strNewValue) {
                    element.setAttribute(strAttributeName, strNewValue);
                }
            }
        }
        
        for (i = 0, len = element.arrQueryStringAttributes.length; i < len; i += 1) {
            if (arrQueryKeys.indexOf(element.arrQueryStringAttributes[i]) === -1) {
                element.removeAttribute(element.arrQueryStringAttributes[i].split('.')[1]);
            }
        }
    }
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            
        }
    }
    
    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                
                var arrElement, i, len, blockerElement, blockerClickHandler;
                
                element.arrQueryStringAttributes = [];
                element.panelIDs = [];
                
                blockerClickHandler = function (event) {
                    var target = event.target;
                    
                    if (target.classList.contains('gs-panel-page-blocker')) {
                        element.hide(target.getAttribute('blocking'));
                    }
                };
                
                arrElement = xtag.queryChildren(element, '*');
                
                for (i = 0, len = arrElement.length; i < len; i += 1) {
                    if (arrElement[i].style.width === '') {
                        arrElement[i].setAttribute('flex', '');
                    } else {
                        if (!arrElement[i].hasAttribute('id')) {
                            console.warn('gs-panel Warning: No ID attribute on side-page element:',
                                         GS.cloneElement(arrElement[i]),
                                         ', please set ID the attribute');
                            
                            arrElement[i].setAttribute('id', 'side-' + GS.GUID().substring(0, 8));
                        }
                        element.panelIDs.push(arrElement[i].getAttribute('id'));
                        
                        blockerElement = document.createElement('div');
                        blockerElement.classList.add('gs-panel-page-blocker');
                        blockerElement.setAttribute('gs-dynamic', '');
                        blockerElement.setAttribute('blocking', arrElement[i].getAttribute('id'));
                        blockerElement.setAttribute('id', arrElement[i].getAttribute('id') + '-blocker');
                        
                        element.insertBefore(blockerElement, arrElement[i]);
                        
                        arrElement[i].setAttribute('panel-set-width', '');
                        
                        if (arrElement[i].hasAttribute('hidden')) {
                            arrElement[i].removeAttribute('hidden');
                            element.hide(arrElement[i].getAttribute('id'));
                            
                        } else {
                            if (element.getAttribute(arrElement[i].getAttribute('id')) === 'hide') {
                                element.hide(arrElement[i].getAttribute('id'));
                            }
                        }
                        
                        if (!element.hasAttribute('no-shadow-dismiss')) {
                            blockerElement.addEventListener('click', blockerClickHandler);
                        }
                    }
                }
                
                window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                
                if (element.hasAttribute('id')) {
                    pushReplacePopHandler(element);
                }
            }
        }
    }
    
    xtag.register('gs-panel', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (document.getElementById(strAttrName) &&
                        document.getElementById(strAttrName).parentNode === this) {
                        if (newValue === 'hide' || newValue === 'show') {
                            this[newValue](strAttrName);
                        }
                        /*if (newValue === 'hide') {
                            this.hide(strAttrName);
                        } else if (newValue === 'show') {
                            this.show(strAttrName);
                        }*/
                    }
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            'show': function (strID) {
                var strQueryString = GS.getQueryString(), strElementID = this.getAttribute('id');
                //document.getElementById(strID).setAttribute('shown', '');
                //document.getElementById(strID).removeAttribute('hidden');
                //document.getElementById(strID + '-blocker').setAttribute('shown', '');
                //document.getElementById(strID + '-blocker').removeAttribute('hidden');
                
                //document.getElementById(strID).style.display = '';
                //document.getElementById(strID + '-blocker').style.display = '';
                
                //if (window.innerWidth <= 768 || this.hasAttribute('dismissible')) {
                
                if ((strElementID && GS.qryGetKeys(strQueryString).indexOf(strElementID + '.' + strID) > -1) &&
                    GS.qryGetVal(strQueryString, strElementID + '.' + strID) === 'hide') {
                    GS.pushQueryString(strElementID + '.' + strID + '=show');
                    
                }
                this.setAttribute(strID, 'show');
                
                //document.getElementById(strID).style.left = '';
                //document.getElementById(strID).style.position = '';
                //document.getElementById(strID + '-blocker').style.left = ''; // <-- works on a phone
                document.getElementById(strID).removeAttribute('panel-hide');
                document.getElementById(strID + '-blocker').removeAttribute('panel-hide');
                
                //this.hiddenIDs.splice(this.hiddenIDs.indexOf(strID), 1);
                //
                GS.triggerEvent(document.getElementById(strID), 'show');
                GS.triggerEvent(window, 'resize'); //, {'triggered': true});
                //}
            },
            
            'hide': function (strID) {
                var strQueryString = GS.getQueryString(), strElementID = this.getAttribute('id');
                //document.getElementById(strID).setAttribute('hidden', '');
                //document.getElementById(strID).removeAttribute('shown');
                //document.getElementById(strID + '-blocker').setAttribute('hidden', '');
                //document.getElementById(strID + '-blocker').removeAttribute('shown');
                
                //document.getElementById(strID).style.display = 'none';
                //document.getElementById(strID + '-blocker').style.display = 'none';
                
                if ((strElementID && GS.qryGetKeys(strQueryString).indexOf(strElementID + '.' + strID) > -1) &&
                    GS.qryGetVal(strQueryString, strElementID + '.' + strID) === 'show') {
                    GS.pushQueryString(strElementID + '.' + strID + '=hide');
                    
                }
                
                this.setAttribute(strID, 'hide');
                
                document.getElementById(strID).setAttribute('panel-hide', '');
                document.getElementById(strID + '-blocker').setAttribute('panel-hide', '');
                
                //if (window.innerWidth <= 768 || this.hasAttribute('dismissible')) {
                //    document.getElementById(strID).style.left = '-100%';
                //    document.getElementById(strID).style.position = 'absolute';
                //    document.getElementById(strID + '-blocker').style.left = '-100%'; // <-- works on a phone
                //    
                //    this.hiddenIDs.push(strID);
                //    
                GS.triggerEvent(document.getElementById(strID), 'hide');
                GS.triggerEvent(window, 'resize'); //, {'triggered': true});
                //}
            },
            
            'toggle': function (strID) {
                var element = document.getElementById(strID);
                
                if (element.hasAttribute('shown') || !element.hasAttribute('panel-hide')) {
                    this.hide(strID);
                } else {
                    this.show(strID);
                }
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    "use strict";

    addSnippet('<gs-progress>', '<gs-progress>', 'gs-progress></gs-progress>');

    /*
    TODO: there is no documentation
    designRegisterElement('gs-progress', '');
    */

    window.designElementProperty_GSPROGRESS = function () {
        addText('D', 'Value', 'value');
        addFlexProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            var observer;
            var headerElement = xtag.queryChildren(element, 'gs-header')[0];
            var footerElement = xtag.queryChildren(element, 'gs-footer')[0];

            // create an observer instance
            observer = new MutationObserver(function(mutations) {
                element.recalculatePadding();
            });

            // pass in the element node, as well as the observer options
            if (headerElement) {
                observer.observe(headerElement, {childList: true, subtree: true});
            }
            if (footerElement) {
                observer.observe(footerElement, {childList: true, subtree: true});
            }
        }
    }

    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                
                element.control = document.createElement('div');
                element.control.setAttribute('gs-dynamic', '');
                element.control.classList.add('control');
                element.control.style.width = element.value + '%';
                element.appendChild(element.control);
            }
        }
    }
    
    xtag.register('gs-progress', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // attribute code
                    if (strAttrName === 'value') {
                        this.control.style.width = this.value + '%';
                    }
                }
            }
        },
        events: {},
        accessors: {
            value: {
                get: function () {
                    return this.getAttribute('value');
                },
                set: function (newValue) {
                    this.setAttribute('value', newValue);
                }
            }
        },
        methods: {
            recalculatePadding: function () {
                var headerElement = xtag.queryChildren(this, 'gs-header')[0],
                    footerElement = xtag.queryChildren(this, 'gs-footer')[0];
                
                if (headerElement) {
                    //console.log('1***', headerElement.offsetHeight);
                    this.style.paddingTop = headerElement.offsetHeight + 'px';
                } else {
                    this.style.paddingTop = '';
                }
                if (footerElement) {
                    //console.log('2***', footerElement.offsetHeight);
                    this.style.paddingBottom = footerElement.offsetHeight + 'px';
                } else {
                    this.style.paddingBottom = '';
                }
            }
        }
    });
});
//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';
    addSnippet('Push Message', 'GS.pushMessage', 'pushMessage(\'${1:HTML}\', ${2:1500}, function () {${3}});');
});

GS.pushMessage = function (strHTML, intTime, callback) {
    var pushMessageElement;
    var containerElement;

    // if there is no html to put in the pushmessage: throw an error
    if (strHTML === undefined) {
        throw 'GS.pushMessage Error: no HTML to display.';
    }

    // if there is no container: add it
    if (document.getElementsByTagName('gs-pushmessage-container').length === 0) {
        containerElement = document.createElement('gs-pushmessage-container');
        containerElement.setAttribute('gs-dynamic', '');
        document.body.appendChild(containerElement);
    } else {
        containerElement = document.getElementsByTagName('gs-pushmessage-container')[0];
    }

    // create the pushmessage
    pushMessageElement = document.createElement('gs-pushmessage');
    pushMessageElement.setAttribute('gs-dynamic', '');
    pushMessageElement.setAttribute('role', 'alert');
    pushMessageElement.innerHTML = strHTML;

    // append the pushmessage to the container
    containerElement.appendChild(pushMessageElement);

    // if there is a callback: run it
    if (typeof callback === 'function') {
        callback.apply(pushMessageElement);
    }

    // if there is a time: set a timeout to close the message
    if (intTime) {
        setTimeout(function () {
            GS.closePushMessage(pushMessageElement);
        }, intTime);
    }

    // return the pushmessage
    return pushMessageElement;
};

window.addEventListener('design-register-element', function () {
    'use strict';
    addSnippet('GS.closePushMessage', 'GS.closePushMessage', 'GS.closePushMessage(${0:pushMessageElement});');
    addSnippet('Close Push Message', 'Close Push Message', 'GS.closePushMessage(${0:pushMessageElement});');
});

GS.closePushMessage = function (pushMessageElement) {
    var containerElement = document.getElementsByTagName('gs-pushmessage-container')[0];

    // fade the pushmessage out
    GS.animateStyle(pushMessageElement, 'opacity', '1', '0', function () {

        // if there is only one pushmessage element: remove the container
        if (document.getElementsByTagName('gs-pushmessage').length === 1) {
            document.body.removeChild(containerElement);

        // else: just remove the element
        } else {
            containerElement.removeChild(pushMessageElement);
        }
    }, 250, 100);
};


document.addEventListener('DOMContentLoaded', function () {
    "use strict";
    xtag.register('gs-pushmessage', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {}
    });

    xtag.register('gs-pushmessage-container', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {}
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, addAutocompleteProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    "use strict";

    addSnippet('<gs-search>', '<gs-search>', 'gs-search id="${1}"></gs-search>');
    addElement('gs-search', '#controls_search');

    window.designElementProperty_GSSEARCH = function () {
        addText('V', 'Placeholder', 'placeholder');
        addCheck('D', 'Disabled', 'disabled');
        addCheck('D', 'Readonly', 'readonly');
        addCheck('V', 'Mini', 'mini');
        addCheck('O', 'Column In QS', 'qs');
        addAutocompleteProps();
        addFocusEvents();
        addFlexProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var singleLineTemplateElement = document.createElement('template');
    var singleLineTemplate;

    singleLineTemplateElement.innerHTML = '<input class="control" gs-dynamic type="text" placeholder="Search..." />';
    singleLineTemplate = singleLineTemplateElement.content;

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();

        GS.triggerEvent(event.target.parentNode, 'change');
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        var element = event.target;
        if (event.target.classList.contains('control')) {
            element = element.parentNode.parentNode;
        }
        if (element.hasAttribute('defer-insert')) {
            // if (element.hasAttribute('in-cell')) {
            //     var cellElem = GS.findParentTag(element, "gs-cell");
            //     var tableElem = GS.findParentTag(cellElem, "gs-table");
            //     var row = cellElem.getAttribute('data-row-number');
            //     if (row === 'insert') {
            //         row = tableElem.internalData.records.length;
            //     } else {
            //         row = parseInt(row, 10);
            //     }
            //     tableElem.internalSelection.ranges[0].start = {
            //         "row": row,
            //         "column": parseInt(cellElem.getAttribute('data-col-number'), 10)
            //     };
            //     tableElem.internalSelection.ranges[0].end = {
            //         "row": row,
            //         "column": parseInt(cellElem.getAttribute('data-col-number'), 10)
            //     };
            //     tableElem.render();
            // }
            element.removeEventListener('focus', focusFunction);
            element.classList.add('focus');
            element.addControl();
            if (element.control.value && element.control.value.length > 0) {
                if (element.bolSelect) {
                    element.control.setSelectionRange(0, element.control.value.length);
                } else {
                    element.control.setSelectionRange(element.control.value.length, element.control.value.length);
                }
            }
            element.bolSelect = true;
        } else {
            GS.triggerEvent(event.target.parentNode, 'focus');
            event.target.parentNode.classList.add('focus');
        }
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        var element = event.target;
        if (event.target.classList.contains('control')) {
            element = element.parentNode.parentNode;
        }
        GS.triggerEvent(event.target.parentNode, 'blur');
        event.target.parentNode.classList.remove('focus');
        if (event.target.parentNode.hasAttribute('defer-insert')) {
            event.target.parentNode.removeControl();
        }
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseout);
        event.target.parentNode.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseover);
        event.target.parentNode.classList.add('hover');
    }

    //function loadPushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString();
    //    var strQSCol = element.getAttribute('qs') || element.getAttribute('id');

    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function loadPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol && strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== element.getAttribute('value') && (strQSValue !== '' || !element.getAttribute('value'))) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                if (strQSValue !== element.getAttribute('value')) {
                    element.value = strQSValue;
                }
            }
        }

        element.internal.bolQSFirstRun = true;
    }



    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

        function findFor(element) {
        var forElem;
        //console.log(element, element.previousElementSibling)
        if (element.previousElementSibling && element.previousElementSibling.tagName.toUpperCase() == 'LABEL'
            && element.previousElementSibling.hasAttribute('for')
            && element.previousElementSibling.getAttribute('for') == element.getAttribute('id')
        ) {
            forElem = element.previousElementSibling;
        } else if (xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]').length > 0) {
            forElem = xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]')[0];
        }
        //console.log(forElem);
        if (forElem) {
            forElem.setAttribute('for', element.getAttribute('id') + '_control');
            if (element.control) {
                element.control.setAttribute('id', element.getAttribute('id') + '_control');
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }
            }
        }
        
        /*
            if (element.hasAttribute('id')) {
                findFor(element);
            }
        // please ensure that if the element has an id it is given an id
                if (element.hasAttribute('id')) {
                    element.control.setAttribute('id', element.getAttribute('id') + '_control');
                }
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }
        */
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (element.hasAttribute('defer-insert')) {
                    if (!element.hasAttribute('tabindex')) {
                        element.setAttribute('tabindex', '0');
                    }
                    element.bolSelect = true;
    
                    // if (GS.findParentTag(element, "gs-cell") && GS.findParentTag(element, "gs-cell").tagName.toUpperCase() === "GS-CELL") {
                    //     element.setAttribute('in-cell', '');
                    // }
    
                    if (element.getAttribute('value')) {
                        element.innerHTML = element.getAttribute('value');
                        element.syncGetters();
                    } else if (element.hasAttribute('placeholder')) {
                        element.innerHTML = '<span class="placeholder">' + element.getAttribute('placeholder') + '</span>';
                    }
    
                    element.addEventListener('focus', focusFunction);
                    if (evt.touchDevice) {
                        element.addEventListener(evt.click, focusFunction);
                        element.addEventListener(evt.mousedown, function (event) {
                            //if event.target is the control
                            if (event.target.tagName === 'GS-TEXT') {
                                var element = event.target;
                                //alert(event.target.outerHTML);
                                //focus it
                                focusFunction(event);
                                //if we focused it prevent click event from happening
                                if (document.activeElement == element.control) {
                                    event.stopImmediatePropagation();
                                    event.stopPropagation();
                                    event.preventDefault();
                                }
                                //else the click event happens trying again
                            }
                        });
                    }
                } else {
                    if (element.hasAttribute('tabindex')) {
                        element.oldTabIndex = element.getAttribute('tabindex');
                        element.removeAttribute('tabindex');
                    }

                    element.refresh();
                }

                loadPushReplacePopHandler(element);
                window.addEventListener('pushstate',    function () { loadPushReplacePopHandler(element); });
                window.addEventListener('replacestate', function () { loadPushReplacePopHandler(element); });
                window.addEventListener('popstate',     function () { loadPushReplacePopHandler(element); });
            }
            if (element.hasAttribute('id')) {
                findFor(element);
            }
        }
    }

    xtag.register('gs-search', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            inserted: function () {
                elementInserted(this);
            },
            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(element);
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);

                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'disabled') {
                        element.refresh();
                    } else if (strAttrName === 'value' && newValue !== oldValue) {
                        element.value = newValue;
                    }
                }
            }
        },
        events: {
            // on keydown and keyup sync the value attribute and the control value
            'keydown': function (event) {
                var element = this;
                if (element.hasAttribute('insert-defer')) {
                    if (!element.hasAttribute('readonly') && !element.hasAttribute('disabled')) {
                        element.syncGetters();
                    }
                } else {
                    if (!this.hasAttribute('readonly')) {
                        if (this.hasAttribute('disabled') && event.keyCode !== 9) {
                            event.preventDefault();
                            event.stopPropagation();
                        } else {
                            this.syncView();
                        }
                    }
                }
            },
            'keyup': function () {
                var element = this;
                if (element.hasAttribute('insert-defer')) {
                    if (!element.hasAttribute('readonly') && !element.hasAttribute('disabled')) {
                        element.syncGetters();
                    }
                } else {
                    if (!this.hasAttribute('readonly')) {
                        this.syncView();
                    }
                }
            },
            'change': function () {
                var strQueryString = GS.getQueryString(), strColumn = (this.getAttribute('qs') || this.getAttribute('id'));
                
                if ((GS.qryGetVal(strQueryString, strColumn) || '') !== (this.control.value || '')) {
                    GS.pushQueryString(strColumn + '=' + encodeURIComponent(this.control.value));
                }
            }
        },
        accessors: {
            value: {
                // get value straight from the input
                get: function () {
                    if (this.control) {
                        return this.control.value;
                    } else {
                        if (this.hasAttribute('defer-insert')) {
                            return this.getAttribute('value');
                        } else {
                            return this.innerHTML;
                        }
                    }
                },

                // set the value of the input and set the value attribute
                set: function (strNewValue) {
                    var element = this;
                    if (element.hasAttribute('defer-insert')) {
                        element.setAttribute('value', strNewValue);
                        element.syncView();
                    } else {
                        if (element.control) {
                            if (element.control.value !== strNewValue) {
                                element.control.value = strNewValue;
                            }
                        } else {
                            element.innerHTML = strNewValue;
                        }
                        element.syncView();
                    }
                }
            }
        },
        methods: {
            focus: function () {
                var element = this;
                if (element.hasAttribute('defer-insert')) {
                    element.bolSelect = false;
                    focusFunction({ target: element });
                    //GS.triggerEvent(element, 'focus');
                } else {
                    if (this.control) {
                        this.control.focus();
                    }
                }
            },

            removeControl: function () {
                var element = this;
                if (element.control) {
                    element.setAttribute('tabindex', element.control.getAttribute('tabindex'));
                }
                if (element.control.value) {
                    element.innerHTML = element.control.value;
                    element.syncGetters();
                } else if (element.hasAttribute('placeholder')) {
                    element.innerHTML = '<span class="placeholder">' + element.getAttribute('placeholder') + '</span>';
                } else {
                    element.innerHTML = ''
                }
                element.control = false;
            },

            addControl: function () {
                var element = this;
                var arrPassThroughAttributes = [
                    'placeholder', 'name', 'maxlength', 'autocorrect',
                    'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                    'readonly', 'disabled'
                ];
                var i;
                var len;
                var elementValue = element.innerHTML;
                var elementWidth = element.offsetWidth;
                //console.log(element.innerHTML, element.children);
                if (element.children.length > 0) {
                    elementValue = '';
                }
                // if the gs-text element has a tabindex: save the tabindex and remove the attribute
                if (element.hasAttribute('tabindex')) {
                    element.savedTabIndex = element.getAttribute('tabindex');
                    element.removeAttribute('tabindex');
                }
                // add control input and save it to a variable for later use
                element.innerHTML = '';
                element.innerHTML = '<input class="control" gs-dynamic type="' + (element.getAttribute('type') || 'text') + '" />';
                element.control = element.children[0];
                if (element.hasAttribute('id')) {
                    element.control.setAttribute('id', element.getAttribute('id') + '_control');
                }
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }

                // bind event re-targeting functions
                element.control.removeEventListener('change', changeFunction);
                element.control.addEventListener('change', changeFunction);


                element.control.removeEventListener('blur', blurFunction);
                element.control.addEventListener('blur', blurFunction);

                element.removeEventListener(evt.mouseout, mouseoutFunction);
                element.addEventListener(evt.mouseout, mouseoutFunction);

                element.removeEventListener(evt.mouseout, mouseoverFunction);
                element.addEventListener(evt.mouseover, mouseoverFunction);
                // copy passthrough attributes to control
                i = 0;
                len = arrPassThroughAttributes.length;
                while (i < len) {
                    if (element.hasAttribute(arrPassThroughAttributes[i])) {
                        if (arrPassThroughAttributes[i] === 'disabled') {
                            element.control.setAttribute(
                                'readonly',
                                element.getAttribute(arrPassThroughAttributes[i]) || ''
                            );
                        } else {
                            element.control.setAttribute(
                                arrPassThroughAttributes[i],
                                element.getAttribute(arrPassThroughAttributes[i]) || ''
                            );
                        }
                    }
                    i += 1;
                }
                //console.log(elementValue);
                element.control.value = elementValue;
                element.value = elementValue;
                // if we saved a tabindex: apply the tabindex to the control
                if (element.savedTabIndex !== undefined && element.savedTabIndex !== null) {
                    element.control.setAttribute('tabindex', element.savedTabIndex);
                }
                //element.style.width = elementWidth - 7 + 'px';
              //console.log(element.style.width, elementWidth + 'px');
                element.syncView();
                element.control.focus();
                element.addEventListener('focus', focusFunction);
            },

            // adapt gs-input element to whatever control is in it and
            //      set the value of the control to the value attribute (if there is a value attribute) and
            //      resize the resize to text
            refresh: function () {
                var element = this;
                var arrPassThroughAttributes;
                var i;
                var len;

                element.innerHTML = '';
                element.appendChild(singleLineTemplate.cloneNode(true));
                if (element.oldTabIndex) {
                    xtag.query(element, '.control')[0].setAttribute('tabindex', element.oldTabIndex);
                }

                // set a variable with the control element for convenience and speed
                element.control = xtag.query(element, '.control')[0];
                if (element.hasAttribute('id')) {
                    element.control.setAttribute('id', element.getAttribute('id') + '_control');
                }
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }

                element.control.removeEventListener('change', changeFunction);
                element.control.addEventListener('change', changeFunction);

                element.control.removeEventListener('focus', focusFunction);
                element.control.addEventListener('focus', focusFunction);

                element.control.removeEventListener('blur', blurFunction);
                element.control.addEventListener('blur', blurFunction);

                element.control.removeEventListener(evt.mouseout, mouseoutFunction);
                element.control.addEventListener(evt.mouseout, mouseoutFunction);

                element.control.removeEventListener(evt.mouseout, mouseoverFunction);
                element.control.addEventListener(evt.mouseover, mouseoverFunction);

                // if there is a value already in the attributes of the element: set the control value
                if (element.hasAttribute('value')) {
                    element.control.value = element.getAttribute('value');
                }

                // copy passthrough attributes to control
                arrPassThroughAttributes = [
                    'placeholder', 'name', 'type', 'maxlength', 'autocorrect',
                    'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                    'readonly'
                ];
                for (i = 0, len = arrPassThroughAttributes.length; i < len; i += 1) {
                    if (element.hasAttribute(arrPassThroughAttributes[i])) {
                        element.control.setAttribute(arrPassThroughAttributes[i], element.getAttribute(arrPassThroughAttributes[i]) || '');
                    }
                }
            },

            syncView: function () {
                var element = this;
                if (element.hasAttribute('defer-insert')) {
                    if (element.control) {
                        if (element.getAttribute('value') !== element.control.value) {
                            element.setAttribute('value', element.control.value);
                        }
                    } else {
                        if (element.value) {
                            element.innerHTML = element.value;
                        } else if (element.hasAttribute('placeholder')) {
                            element.innerHTML = '<span class="placeholder">' + element.getAttribute('placeholder') + '</span>';
                        }
                    }
                    element.initalized = true;
                } else {
                    if (this.control) {
                        if (this.getAttribute('value') !== this.control.value) {
                            this.setAttribute('value', this.control.value);
                        }
                    } else {
                        this.innerHTML = this.control.value;
                    }
                }
            },

            syncGetters: function () {
                if (this.control) {
                    this.setAttribute('value', this.control.value);
                }
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    "use strict";

    registerDesignSnippet(
        '<gs-select>',
        '<gs-select>',
        (
            'gs-select>\n' +
            '    <option value="${0}">${1}</option>\n' +
            '</gs-select>'
        )
    );

    designRegisterElement('gs-select', '#controls_select');

    window.designElementProperty_GSSELECT = function () {
        addGSControlProps();
        addFocusEvents();
        addFlexProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var templateElement = document.createElement('template');
    var template;

    templateElement.innerHTML = '<select class="control" gs-dynamic></select>';
    template = templateElement.content;

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();

        GS.triggerEvent(event.target.parentNode, 'change');

        //return false;
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
        event.target.parentNode.classList.add('focus');
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'blur');
        event.target.parentNode.classList.remove('focus');
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseout);
        event.target.parentNode.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseover);
        event.target.parentNode.classList.add('hover');
    }


    //function createPushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');

    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function createPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.value = strQSValue;
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            var strValue = element.value, observer;

            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (strValue) {
                element.setAttribute('value', strValue);
                delete element.value;
            }

            // #############################################################
            // ##################### MUTATION OBSERVER #####################
            // #############################################################

            // create an observer instance
            observer = new MutationObserver(function(mutations) {
                var bolRefreshOptionList = true;

                // check each mutation: if only option and optgroup tags were added: refersh option tags in select
                mutations.forEach(function(mutation) {
                    var i, len;
                    
                    for (i = 0, len = mutation.addedNodes.length; i < len; i += 1) {
                        if (mutation.addedNodes[i].nodeName !== 'OPTION' && mutation.addedNodes[i].nodeName !== 'OPTGROUP') {
                            bolRefreshOptionList = false;
                        }
                    }
                });

                if (bolRefreshOptionList) {
                    element.refreshOptionList();
                }
            });

            // pass in the element node, as well as the observer options
            observer.observe(element, {childList: true});
        }
    }

    function findFor(element) {
        var forElem;
        //console.log(element, element.previousElementSibling)
        if (element.previousElementSibling && element.previousElementSibling.tagName.toUpperCase() == 'LABEL'
            && element.previousElementSibling.hasAttribute('for')
            && element.previousElementSibling.getAttribute('for') == element.getAttribute('id')
        ) {
            forElem = element.previousElementSibling;
        } else if (xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]').length > 0) {
            forElem = xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]')[0];
        }
        //console.log(forElem);
        if (forElem) {
            forElem.setAttribute('for', element.getAttribute('id') + '_control');
            if (element.control) {
                element.control.setAttribute('id', element.getAttribute('id') + '_control');
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }
            }
        }
        
        /*
            if (element.hasAttribute('id')) {
                findFor(element);
            }
        // please ensure that if the element has an id it is given an id
                if (element.hasAttribute('id')) {
                    element.control.setAttribute('id', element.getAttribute('id') + '_control');
                }
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }
        */
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (element.hasAttribute('tabindex')) {
                    element.oldTabIndex = element.getAttribute('tabindex');
                    element.removeAttribute('tabindex');
                }

                element.refreshOptionList();

                //element.control.removeEventListener('change', changeFunction);
                element.control.addEventListener('change', changeFunction);

                //element.control.removeEventListener('focus', focusFunction);
                element.control.addEventListener('focus', focusFunction);

                //element.control.removeEventListener('blur', blurFunction);
                element.control.addEventListener('blur', blurFunction);

                //element.control.removeEventListener(evt.mouseout, mouseoutFunction);
                element.control.addEventListener(evt.mouseout, mouseoutFunction);

                //element.control.removeEventListener(evt.mouseover, mouseoverFunction);
                element.control.addEventListener(evt.mouseover, mouseoverFunction);

                // set the value from the value attribute (if it exists)
                if (element.getAttribute('value')) {
                    element.value = element.getAttribute('value');
                }

                //handle query-string
                if (element.getAttribute('qs')) {
                    //var strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.value = strQSValue;
                    //}
                    createPushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                }
            }
            if (element.hasAttribute('id')) {
                findFor(element);
            }
        }
    }

    xtag.register('gs-select', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                // if disabled has changed, refresh
                } else if (strAttrName === 'disabled') {
                    this.refreshOptionList();

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value' && newValue !== oldValue) {
                        this.value = newValue;
                    }
                }
            }
        },
        events: {
            'keydown': function (event) {
                var intKeyCode = (event.keyCode || event.which);

                if (this.hasAttribute('readonly') &&
                        (
                            (
                                intKeyCode !== 9 && // if not tab and CMD, CTRL and SHFT are not down: prevent default
                                !event.metaKey &&
                                !event.ctrlKey &&
                                !event.shiftKey
                            ) ||
                            intKeyCode === 32 // if it's space: definitely prevent default
                        )) {
                    event.preventDefault();
                }
            },
            'keyup': function (event) {
                var intKeyCode = (event.keyCode || event.which);

                if (this.hasAttribute('readonly') &&
                        (
                            (
                                intKeyCode !== 9 && // if not tab and CMD, CTRL and SHFT are not down: prevent default
                                !event.metaKey &&
                                !event.ctrlKey &&
                                !event.shiftKey
                            ) ||
                            intKeyCode === 32 // if it's space: definitely prevent default
                        )) {
                    event.preventDefault();
                }
            },
            'mousedown': function (event) {
                if (this.hasAttribute('readonly')) {
                    if (evt.touchDevice === false) {
                        this.control.focus();
                    }
                    event.preventDefault();
                }
            },
            'mouseup': function (event) {
                if (this.hasAttribute('readonly')) {
                    event.preventDefault();
                }
            }
        },
        accessors: {
            value: {
                get: function () {
                    if (this.control) {
                        return this.control.value;
                    } else if (this.getAttribute('value')) {
                        return this.getAttribute('value');
                    }
                    return undefined;
                },

                set: function (newValue) {
                    if (this.getAttribute('value') !== newValue) {
                        this.setAttribute('value', newValue);
                    }
                    this.control.value = newValue;
                }
            },
            textValue: {
                get: function () {
                    return this.control.options[this.control.selectedIndex].text;
                },

                set: function (newValue) {
                    this.setAttribute('value', newValue);
                    this.control.value = newValue;
                }
            }
        },
        methods: {
            focus: function () {
                this.control.focus();
            },

            refreshOptionList: function () {
                var i, len, elementsToMove, oldvalue, arrChildren, controlElement;

                //console.log('refreshOptionList');

                // remove invalid elements from immediate children
                arrChildren = this.children;

                for (i = arrChildren.length - 1; i > -1; i -= 1) {
                    //console.log(arrChildren[i]);
                    if (arrChildren[i].nodeName !== 'OPTION' &&
                        arrChildren[i].nodeName !== 'OPTGROUP' &&
                        arrChildren[i].nodeName !== 'SELECT' &&
                        arrChildren[i].classList.contains('control')) {
                        this.removeChild(arrChildren[i]);
                    }
                }

                // if there is already a control
                controlElement = xtag.queryChildren(this, '.control')[0];

                if (controlElement) { //this.control && this.control.parentNode) {
                    // save the old value
                    oldvalue = controlElement.value;

                    // save the old control
                    this.oldcontrol = controlElement;

                    // remove the control class from the old control so that when
                    //      we select for the new control we dont get the old control
                    controlElement.classList.remove('control');
                }

                // append new control
                this.appendChild(template.cloneNode(true));

                // set a variable with the new control element for convenience and speed
                this.control = xtag.query(this, '.control')[0];
                if (this.hasAttribute('id')) {
                    this.control.setAttribute('id', this.getAttribute('id') + '_control');
                }
                if (this.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', this.getAttribute('aria-labelledby'));
                }
                if (this.hasAttribute('title')) {
                    this.control.setAttribute('title', this.getAttribute('title'));
                }
                if (this.hasAttribute('disabled')) {
                    this.control.setAttribute('disabled', this.getAttribute('disabled'));
                }

                // if there is an old control: get the options and optgroups out of it and move them to the new control
                if (this.oldcontrol) {
                    elementsToMove = xtag.queryChildren(this.oldcontrol, 'option, optgroup');

                    for (i = 0, len = elementsToMove.length; i < len; i += 1) {
                        elementsToMove[i].setAttribute('gs-hidden', '');

                        this.control.appendChild(elementsToMove[i]);
                    }
                }

                // fill the control with all of the option and optgroup tags that are direct descendents of the gs-select
                elementsToMove = xtag.queryChildren(this, 'option, optgroup');

                for (i = 0, len = elementsToMove.length; i < len; i += 1) {
                    this.control.appendChild(elementsToMove[i]);
                }

                // if there was an old control
                if (this.oldcontrol) {
                    // this if statement prevents an error when the gs-select shares and ID with another element
                    if (this.oldcontrol.parentNode === this) {
                        // remove the old control if it is currently a child of the select
                        this.removeChild(this.oldcontrol);
                    }

                    // set the oldcontrol variable to undefined so that the next time this function is run we dont get the old control
                    this.oldcontrol = undefined;

                    // set the value back to the old value
                    //console.log(this.getAttribute('value'));
                    this.control.value = this.getAttribute('value') || oldvalue;

                } else if (this.hasAttribute('value')) {
                    //alert(this.getAttribute('value'));
                    this.control.value = this.getAttribute('value');
                }

                if (this.oldTabIndex) {
                    this.control.setAttribute('tabindex', this.oldTabIndex);
                }
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, shimmed
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';
    addSnippet(
        '<gs-slide>',
        '<gs-slide>',
        (
            'gs-slide>\n' +
            '    <template for="${1:none}"></template>\n' +
            '    <template for="${2:detail}"></template>\n' +
            '</gs-slide>'
        )
    );

    /*
    TODO: there is no documentation
    designRegisterElement('gs-slide', '');
    */

    window.designElementProperty_GSSLIDE = function () {
        addText('V', 'Template', 'template');
        addText('O', 'Column In QS', 'qs');
        addText('O', 'Refresh On QS Columns', 'refresh-on-querystring-values');
        addCheck('O', 'Refresh On QS Change', 'refresh-on-querystring-change');
        addFlexContainerProps();
        addFlexProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    function subsafeTemplate(strTemplate) {
        var templateElement = document.createElement('template');
        var strID;
        var arrTemplates;
        var i;
        var len;
        var jsnTemplates;
        var strRet;
        var arrTemplateNames;

        templateElement.innerHTML = strTemplate;

        // temporarily remove templates. recursively go through templates whose parents do not have the source attribute
        i = 0;
        arrTemplates = xtag.query(templateElement.content, 'template');

        jsnTemplates = {};
        arrTemplateNames = [];

        while (arrTemplates.length > 0 && i < 100) {
            //console.log(arrTemplates[0]);
            //console.log(arrTemplates[0].parentNode);
            //console.log(arrTemplates[0].parentNode.hasAttribute('src'));

            // if the current template has a source parent: remove temporarily
            if (
                arrTemplates[0].parentNode &&
                arrTemplates[0].parentNode.hasAttribute &&
                (
                    arrTemplates[0].parentNode.hasAttribute('src') ||
                    arrTemplates[0].parentNode.hasAttribute('source')
                )
            ) {
                strID = 'UNIqUE_PLaCEhOLDER-' + GS.GUID() + '-UNiQUE_PLaCEhOLdER';
                jsnTemplates[strID] = arrTemplates[0].outerHTML;
                arrTemplates[0].outerHTML = strID;
                arrTemplateNames.push(strID);

            // else: add to the arrTemplates array
            } else if (arrTemplates[0].content) {
                arrTemplates.push.apply(arrTemplates, xtag.query(arrTemplates[0].content, 'template'));
            }

            // remove the current template from the arrTemplates array
            arrTemplates.splice(0, 1);

            i += 1;
        }

        strRet = doT.template(
            '{{##def.snippet:\n' +
                    '    {{ var qs = GS.qryToJSON(GS.getQueryString()); }} {{# def.template }}\n' +
                    '#}}\n' +
                    '{{#def.snippet}}',
            null,
            {"template": templateElement.innerHTML}
        )();

        i = 0;
        len = arrTemplateNames.length;
        //for (strID in jsnTemplates) {
        while (i < len) {
            // DO NOT DELETE THE REPLACE, it allows single dollar signs to be inside dot notation
            strRet = strRet.replace(
                new RegExp(arrTemplateNames[i], 'g'),
                jsnTemplates[arrTemplateNames[i]].replace(/\$/g, '$$$$')
            );
            i += 1;
        }

        return strRet;
    }

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var arrPopKeys;
        var currentValue;
        var bolRefresh = false;
        var strOperator;

        if (strQSCol && strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        }

        // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
        if (element.internal.bolQSFirstRun === true) {
            if (element.hasAttribute('refresh-on-querystring-values') || element.hasAttribute('qs')) {
                if (element.getAttribute('refresh-on-querystring-values')) {
                    arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                } else {
                    arrPopKeys = [];
                }

                if (strQSCol) {
                    GS.listAdd(arrPopKeys, strQSCol);
                }

                i = 0;
                len = arrPopKeys.length;
                //for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                while (i < len) {
                    currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);

                    if (element.popValues[arrPopKeys[i]] !== currentValue) {
                        bolRefresh = true;
                    }

                    element.popValues[arrPopKeys[i]] = currentValue;
                    i += 1;
                }

            } else if (element.hasAttribute('refresh-on-querystring-change')) {
                bolRefresh = true;
            } else if (element.hasAttribute('template') || element.hasAttribute('value')) {
                bolRefresh = true;
            }

            if (bolRefresh) {
                //console.log(currentValue);
                element.slide('right', currentValue, true);
            }
        } else {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                i = 0;
                len = arrPopKeys.length;
                //for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                while (i < len) {
                    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                    i += 1;
                }
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                // we can't reset this in case the element is added later
                if (!window.slideIdNum) {
                    window.slideIdNum = 0;
                }

                //must be for this element to prevent one element from clearing another
                //    this is cleared to prevent really long obsolete stylesheets
                var relatedStyleSheet = document.createElement('style');
                document.head.appendChild(relatedStyleSheet);
                element.relatedStyleSheet = relatedStyleSheet;


                element.internal = {};
                saveDefaultAttributes(element);

                // Get templates and define some variables
                var arrTemplate = xtag.queryChildren(element, 'template');
                var i;
                var len;
                var attr_i;
                var attr_len;
                var arrAttrNames;
                var arrAttrValues;
                var strAttrName;
                var template;

                element.attributesFromTemplate = [];
                element.templates = {};

                //for (i = 0, len = arrTemplate.length; i < len; i += 1) {
                i = 0;
                len = arrTemplate.length;
                while (i < len) {
                    if (i === 0) {
                        element.firstTemplate = arrTemplate[i].getAttribute('for') || arrTemplate[i].getAttribute('id');
                    }

                    arrAttrNames = [];
                    arrAttrValues = [];

                    attr_i = 0;
                    attr_len = arrTemplate[i].attributes.length;
                    //for (attr_i = 0, attr_len = arrTemplate[i].attributes.length; attr_i < attr_len; attr_i += 1) {
                    while (attr_i < attr_len) {
                        strAttrName = arrTemplate[i].attributes[attr_i].nodeName;

                        if (strAttrName !== 'for' && strAttrName !== 'id') {
                            arrAttrNames.push(strAttrName);
                            arrAttrValues.push(arrTemplate[i].attributes[attr_i].value);
                        }
                        attr_i += 1;
                    }

                    template = arrTemplate[i];
                    element.templates[template.getAttribute('for') || template.getAttribute('id')] = {
                        'content': template.innerHTML,
                        'arrAttrNames': arrAttrNames,
                        'arrAttrValues': arrAttrValues,
                        'templated': !(element.hasAttribute('static') || template.hasAttribute('static'))
                    };
                    if (!(element.hasAttribute('static') || template.hasAttribute('static')) &&
                            (
                        element.templates[template.getAttribute('for') || template.getAttribute('id')].content.indexOf('&gt;') > -1 ||
                        element.templates[template.getAttribute('for') || template.getAttribute('id')].content.indexOf('&lt;') > -1
                    )) {
                        console.warn('GS-SLIDE WARNING: &gt; or &lt; detected in "' + (template.getAttribute('for') || template.getAttribute('id')) + '" template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                    }

                    i += 1;
                }

                // Clear out the templates from the DOM
                element.innerHTML = '';

                element.arrQueryStringAttributes = [];
                element.popValues = {};

                if (
                    (
                        element.hasAttribute('template') &&
                        element.getAttribute('template').indexOf('{{') > -1
                    ) ||
                    element.hasAttribute('qs') ||
                    element.hasAttribute('refresh-on-querystring-values') ||
                    element.hasAttribute('refresh-on-querystring-change')
                ) {
                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate', function () {
                        pushReplacePopHandler(element);
                    });
                    window.addEventListener('replacestate', function () {
                        pushReplacePopHandler(element);
                    });
                    window.addEventListener('popstate', function () {
                        pushReplacePopHandler(element);
                    });
                }

                // element.refresh();
                // element.innerHTML = subsafeTemplate(arrTemplate[0].content);
                //console.log(subsafeTemplate(arrTemplate[0].content), arrTemplate[0]);
                element.slide('gs-slideStartFirstTemplate');
            }
        }
    }

    xtag.register('gs-slide', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(element);
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);

                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value') {
                        console.warn('gs-slide Warning: "value" attribute is not in use. Please use the "template" attribute instead.', element);
                    } else if (strAttrName === 'template' && element.inserted === true) {
                        element.slide('right', newValue);
                    }
                }
            }
        },
        events: {},
        accessors: {
            // cannot set the template with an accessor
            value: {
                get: function () {
                    var element = this;
                    console.warn('gs-slide Warning: \'.value\' accessor is deprecated. Please use the \'.template\' accessor to replace the \'.value\' accessor.', element);
                    return element.getAttribute('template');
                }
            },
            template: {
                get: function () {
                    return this.getAttribute('template');
                }
            },
            currentTemplate: {
                get: function () {
                    var templateName;
                    var strQueryString = GS.getQueryString();
                    var strQSAttribute = this.getAttribute('qs');
                    var strValueAttribute = this.getAttribute('template') || this.getAttribute('value');
                    if (strQSAttribute && GS.qryGetVal(strQueryString, strQSAttribute)) {
                        templateName = GS.qryGetVal(strQueryString, strQSAttribute);
                    } else if (strValueAttribute) {
                        templateName = GS.templateWithQuerystring(strValueAttribute);
                    }
                    return templateName;
                }
            }
        },
        methods: {
            'slide': function (direction, templateTo, bolqs) {
                var element = this;
                var strQueryString = GS.getQueryString();
                var strQSAttribute = element.getAttribute('qs');
                var strValueAttribute = templateTo;
                var templateName;
                var i;
                var len;
                var newHTML;
                var offsetCSS;
                var keyFrameCSS;
                var newPageID = 'slideCont' + window.slideIdNum;
                // window property to prevent duplicates
                window.slideIdNum++;

                if (direction !== 'gs-slideStartFirstTemplate' && !bolqs && (element.hasAttribute('refresh-on-querystring-change') || element.hasAttribute('refresh-on-querystring-values') || element.hasAttribute('qs'))) {
                    element.slide((direction || 'right'), templateTo, true);
                    console.warn('gs-slide Warning: \'Do not use element.slide on an element using querystring attributes, use GS.pushQueryString();\'');
                    return;
                }

                // if we've been given a name: use that
                if (templateTo) {
                    templateName = templateTo;
                // else: get a name
                } else {
                    if (strQSAttribute && GS.qryGetVal(strQueryString, strQSAttribute)) {
                        templateName = GS.qryGetVal(strQueryString, strQSAttribute);
                    } else if (strValueAttribute) {
                        templateName = GS.templateWithQuerystring(strValueAttribute);
                    }
                }

                templateName = templateName || element.firstTemplate;

                if (element.templates[templateName] && element.templates[templateName].content) {
                    // if there are values in element.attributesFromTemplate
                    if (element.attributesFromTemplate.length > 0) {
                        // loop through them
                        i = 0;
                        len = element.attributesFromTemplate.length;
                        //for (i = 0, len = element.attributesFromTemplate.length; i < len; i += 1) {
                        while (i < len) {
                            // if attribute was initallySet: set it back to initalvalue
                            if (element.attributesFromTemplate[i].initallySet) {
                                element.setAttribute(element.attributesFromTemplate[i].name, element.attributesFromTemplate[i].initalValue);

                            // else: remove it
                            } else {
                                element.removeAttribute(element.attributesFromTemplate[i].name);
                            }
                            i += 1;
                        }
                    }

                    // clear element.attributesFromTemplate
                    element.attributesFromTemplate = [];

                    // if there are values in element.templates[templateName].arrAttrNames
                    if (element.templates[templateName].arrAttrNames.length > 0) {
                        // loop through them
                        i = 0;
                        len = element.templates[templateName].arrAttrNames.length;
                        while (i < len) {
                            // add to element.attributesFromTemplate
                            element.attributesFromTemplate.push({
                                'name': element.templates[templateName].arrAttrNames[i],
                                'initallySet': element.hasAttribute(element.templates[templateName].arrAttrNames[i]),
                                'initalValue': element.getAttribute(element.templates[templateName].arrAttrNames[i])
                            });

                            // set attribute
                            element.setAttribute(element.templates[templateName].arrAttrNames[i], GS.templateWithQuerystring(element.templates[templateName].arrAttrValues[i]));
                            i += 1;
                        }
                    }

                    // if this isn't the first one
                    if (direction !== 'gs-slideStartFirstTemplate') {
                        // newhtml is added after the css is added
                        if (element.templates[templateName].templated) {
                            newHTML = '<div id="' + newPageID + '">' + subsafeTemplate(element.templates[templateName].content) + '</div>';
                        } else {
                            newHTML = '<div id="' + newPageID + '">' + element.templates[templateName].content + '</div>';
                        }

                        // create slide css
                        // keyFrameCSS is added at the end
                        offsetCSS = '#' + newPageID + ' {\n';
                        if (direction === 'left') {
                            offsetCSS += '    left: 0;\n';
                            keyFrameCSS = '@-webkit-keyframes slidein {\n' +
                                    '    0% { left: -100%; }\n' +
                                    '    100% { left: 0; }\n' +
                                    '}\n' +
                                    '@keyframes slidein {\n' +
                                    '    0% { left: -100%; }\n' +
                                    '    100% { left: 0; }\n' +
                                    '}\n';

                        } else if (direction === 'top') {
                            offsetCSS += '    top: -100%;\n';
                            keyFrameCSS = '@-webkit-keyframes slidein {\n' +
                                    '    0% { top: 0%; }\n' +
                                    '    100% { top: 0; }\n' +
                                    '}\n' +
                                    '@keyframes slidein {\n' +
                                    '    0% { top: -100%; }\n' +
                                    '    100% { top: 0; }\n' +
                                    '}\n';

                        } else if (direction === 'bottom') {
                            offsetCSS += '    top: 100%;\n';
                            keyFrameCSS = '@-webkit-keyframes slidein {\n' +
                                    '    0% { top: 100%; }\n' +
                                    '    100% { top: 0; }\n' +
                                    '}\n' +
                                    '@keyframes slidein {\n' +
                                    '    0% { top: 100%; }\n' +
                                    '    100% { top: 0; }\n' +
                                    '}\n';

                        //right should be the default
                        } else {
                            offsetCSS += '    left: 0;\n';
                            keyFrameCSS = '@-webkit-keyframes slidein {\n' +
                                    '    0% { left: 100%; }\n' +
                                    '    100% { left: 0; }\n' +
                                    '}\n' +
                                    '@keyframes slidein {\n' +
                                    '    0% { left: 100%; }\n' +
                                    '    100% { left: 0; }\n' +
                                    '}\n';
                        }

                        offsetCSS += '    -webkit-animation: slidein 1s forwards;\n' +
                                '    animation: slidein 1s forwards;\n' +
                                '}\n';
                        offsetCSS += keyFrameCSS;
                        element.relatedStyleSheet.innerHTML = offsetCSS;
                        element.innerHTML += newHTML;
                        //remove previous template
                        setTimeout(function () {
                            element.removeChild(element.children[0]);
                        }, 1000);
                    // if this is the first one
                    } else {
                        if (element.templates[templateName].templated) {
                            element.innerHTML = '<div id="' + newPageID + '">' + subsafeTemplate(element.templates[templateName].content); + '</div>'
                        } else {
                            element.innerHTML = '<div id="' + newPageID + '">' + element.templates[templateName].content; + '</div>'
                        }
                        GS.triggerEvent(element, 'templated');
                        element.templated_first = true;
                    }

                    // if template is not native: handle templates inside the slide
                    if (shimmed.HTMLTemplateElement) {
                        window.HTMLTemplateElement.bootstrap(element);
                    }
                  //console.log(templateName, newPageID);
                    GS.triggerEvent(element, 'templatechange', {'templateName': templateName});
                    GS.triggerEvent(element, 'template_change', {'templateName': templateName});
                } else {
                    element.innerHTML = '';
                }
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, shimmed
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    "use strict";
    addSnippet('<gs-static>', '<gs-static>', 'gs-static column="${1:name}"></gs-static>');
    addElement('gs-static', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/index.html#controls_static');

    window.designElementProperty_GSSTATIC = function () {
        addCheck('D', 'Formatted&nbsp;Text', 'pre');
        addText('D', 'Column', 'column');
        addText('D', 'Value', 'value');
        addCheck('V', 'Inline', 'inline');
        addCheck('V', 'Mini', 'mini');
        addFlexProps();
        addText('O', 'Column In QS', 'qs');
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    //function createPushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //
    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function createPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value && !element.hasAttribute('value')) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = null;
            }
        }
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                //var strQSValue;
                element.refresh();

                if (element.getAttribute('qs')) {
                    //var strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.value = strQSValue;
                    //}
                    createPushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                }
            }
        }
    }
    
    xtag.register('gs-static', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    this.refresh();
                }
            }
        },
        events: {},
        accessors: {
            value: {
                // get value straight from the input
                get: function () {
                    return this.getAttribute('value');
                },
                
                // set the value of the input and set the value attribute
                set: function (strNewValue) {
                    this.setAttribute('value', strNewValue);
                }
            }
        },
        methods: {
            refresh: function () {
                this.innerHTML = this.getAttribute('value');
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, shimmed
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';

    addSnippet(
        '<gs-sticky>',
        '<gs-sticky>',
        (
            'gs-sticky>\n' +
            '    <gs-sticky-inner>\n' +
            '        ${0}\n' +
            '    </gs-sticky-inner>\n' +
            '</gs-sticky>'
        )
    );

    addElement('gs-sticky', '#layout_sticky_header_footer');

    window.designElementProperty_GSSTICKY = function () {
        addSelect('V', 'Direction', 'direction', [
            {"val": "", "txt": "Up"},
            {"val": "down", "txt": "Down"}
        ]);
        addCheck('O', 'Always Stuck', 'stuck');
        addCheck('O', 'Touch Devices Allowed', 'touch-device-allowed');
        addFlexContainerProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    function stickHandler(element) {
        var bolTop = (element.getAttribute('direction') !== 'down'),
            intScrollPosition = document.body.scrollTop,
            jsnElementPositionData = GS.getElementPositionData(element),
            bolShouldBeStuck = (bolTop && jsnElementPositionData.intRoomAbove < 0) || (!bolTop && jsnElementPositionData.intRoomBelow < 0);
        
        if (bolShouldBeStuck && !element.hasAttribute('stuck')) {
            element.style.height = element.offsetHeight + 'px';
            element.setAttribute('stuck', '');
            
            //if (bolTop) {
            //    element.parentNode.style.paddingTop = element.offsetHeight + 'px';
            //} else {
            //    element.parentNode.style.paddingBottom = element.offsetHeight + 'px';
            //}
            
        } else if (!bolShouldBeStuck && element.hasAttribute('stuck')) {
            element.style.height = '';
            element.removeAttribute('stuck');
            //
            //if (bolTop) {
            //    element.parentNode.style.paddingTop = '';
            //} else {
            //    element.parentNode.style.paddingBottom = '';
            //}
        }
        
        //console.log(bolTop, intScrollPosition, jsnElementPositionData);
    }
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            if (!element.hasAttribute('role') && !GS.findParentTag(element, 'gs-dialog')) {
                if (element.getAttribute('direction') === 'down') {
                    element.setAttribute('role', 'contentinfo');
                } else {
                    element.setAttribute('role', 'banner');
                }
            }
        }
    }
    
    //
    function elementInserted(element) {
        var currentParent;
        
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                
                if (element.children.length > 1) {
                    throw 'gs-sticky Error: Too many children. gs-sticky elements must have one child and it must be a <gs-sticky-inner> element.';
                    
                } else if (element.children.length === 0) {
                    throw 'gs-sticky Error: No children. gs-sticky elements must have one child and it must be a <gs-sticky-inner> element.';
                    
                } else if (element.children[0].nodeName !== 'GS-STICKY-INNER') {
                    throw 'gs-sticky Error: Invalid child. gs-sticky elements must have one child and it must be a <gs-sticky-inner> element.';
                }
                
                element.parentNode.style.height = 'auto';
                
                if (element.hasAttribute('stuck')) {
                    //console.log(element.children[0].offsetHeight, element.getAttribute('direction'));
                    if (element.getAttribute('direction') !== 'down') {
                        element.parentNode.style.paddingTop = element.children[0].offsetHeight + 'px';
                    } else {
                        element.parentNode.style.paddingBottom = element.children[0].offsetHeight + 'px';
                    }
                }
                
                if (!element.hasAttribute('stuck') && (!evt.touchDevice || element.hasAttribute('touch-device-allowed'))) {
                    stickHandler(element);
                    currentParent = element.parentNode;
                    if (currentParent.nodeName !== 'BODY') {
                        console.warn('gs-sticky Warning: Element not immediate child of BODY. This element was designed for being an immediate child of the BODY, doing otherwise may give unexpected results.');
                    }
                    
                    window.addEventListener('resize', function () {
                        if (element.parentNode === currentParent) {
                            stickHandler(element);
                        }
                    });
                    
                    window.addEventListener('scroll', function () {
                        if (element.parentNode === currentParent) {
                            stickHandler(element);
                        }
                    });
                    
                    window.addEventListener('orientationchange', function () {
                        if (element.parentNode === currentParent) {
                            stickHandler(element);
                        }
                    });
                }
            }
        }
    }
    
    xtag.register('gs-sticky-inner', {});
    xtag.register('gs-sticky', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    
                }
            }
        },
        events: {},
        accessors: {},
        methods: {}
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, shimmed
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';
    addSnippet(
        '<gs-switch>',
        '<gs-switch>',
        (
            'gs-switch>\n' +
            '    <template for="${1:none}"></template>\n' +
            '    <template for="${2:detail}"></template>\n' +
            '</gs-switch>'
        )
    );

    addElement('gs-switch', '#layout_switch');

    window.designElementProperty_GSSWITCH = function () {
        addText('V', 'Template', 'template');
        addFlexContainerProps();
        addFlexProps();
        addText('O', 'Refresh On QS Columns', 'refresh-on-querystring-values');
        addCheck('O', 'Refresh On QS Change', 'refresh-on-querystring-change');
        addText('O', 'Column In QS', 'qs');
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    function subsafeTemplate(strTemplate) {
        var templateElement = document.createElement('template');
        var strID;
        var arrTemplates;
        var i;
        var len;
        var jsnTemplates;
        var strRet;
        var arrTemplateNames;

        templateElement.innerHTML = strTemplate;

        // temporarily remove templates. recursively go through templates whose parents do not have the source attribute
        i = 0;
        arrTemplates = xtag.query(templateElement.content, 'template');

        jsnTemplates = {};
        arrTemplateNames = [];

        while (arrTemplates.length > 0 && i < 100) {
            //console.log(arrTemplates[0]);
            //console.log(arrTemplates[0].parentNode);
            //console.log(arrTemplates[0].parentNode.hasAttribute('src'));

            // if the current template has a source parent: remove temporarily
            if (
                arrTemplates[0].parentNode &&
                arrTemplates[0].parentNode.hasAttribute &&
                (
                    arrTemplates[0].parentNode.hasAttribute('src') ||
                    arrTemplates[0].parentNode.hasAttribute('source')
                )
            ) {
                strID = 'UNIqUE_PLaCEhOLDER-' + GS.GUID() + '-UNiQUE_PLaCEhOLdER';
                jsnTemplates[strID] = arrTemplates[0].outerHTML;
                arrTemplates[0].outerHTML = strID;
                arrTemplateNames.push(strID);

            // else: add to the arrTemplates array
            } else if (arrTemplates[0].content) {
                arrTemplates.push.apply(arrTemplates, xtag.query(arrTemplates[0].content, 'template'));
            }

            // remove the current template from the arrTemplates array
            arrTemplates.splice(0, 1);

            i += 1;
        }

        strRet = doT.template(
            '{{##def.snippet:\n' +
                    '    {{ var qs = GS.qryToJSON(GS.getQueryString()); }} {{# def.template }}\n' +
                    '#}}\n' +
                    '{{#def.snippet}}',
            null,
            {"template": templateElement.innerHTML}
        )();

        i = 0;
        len = arrTemplateNames.length;
        //for (strID in jsnTemplates) {
        while (i < len) {
            // DO NOT DELETE THE REPLACE, it allows single dollar signs to be inside dot notation
            strRet = strRet.replace(
                new RegExp(arrTemplateNames[i], 'g'),
                jsnTemplates[arrTemplateNames[i]].replace(/\$/g, '$$$$')
            );
            i += 1;
        }

        return strRet;
    }

    //function pushReplacePopHandler(element) { //, eventName
    //    var i;
    //    var len;
    //    var arrPopKeys = [];
    //    var bolRefresh = false;
    //    var strQS = GS.getQueryString();
    //    var currentValue;
    //    var strQSCol = element.getAttribute('qs');

    //    //console.log(eventName);

    //    if (element.hasAttribute('refresh-on-querystring-values') || element.hasAttribute('qs')) {
    //        if (element.hasAttribute('refresh-on-querystring-values')) {
    //            arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
    //        }
    //        if (strQSCol && GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
    //            GS.listAdd(arrPopKeys, strQSCol);
    //        }

    //        //for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
    //        i = 0;
    //        len = arrPopKeys.length;
    //        while (i < len) {
    //            currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);

    //            if (element.popValues[arrPopKeys[i]] !== currentValue) {
    //                //console.log(arrPopKeys[i], element.popValues[arrPopKeys[i]], currentValue);
    //                bolRefresh = true;
    //            }

    //            element.popValues[arrPopKeys[i]] = currentValue;
    //            i += 1;
    //        }
    //    } else {
    //        bolRefresh = true;
    //    }

    //    if (bolRefresh) {
    //        element.refresh();
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var arrPopKeys;
        var currentValue;
        var bolRefresh = false;
        var strOperator;

        if (strQSCol && strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        }

        // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
        if (element.internal.bolQSFirstRun === true) {
            if (element.hasAttribute('refresh-on-querystring-values') || element.hasAttribute('qs')) {
                if (element.getAttribute('refresh-on-querystring-values')) {
                    arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                } else {
                    arrPopKeys = [];
                }

                if (strQSCol) {
                    GS.listAdd(arrPopKeys, strQSCol);
                }

                i = 0;
                len = arrPopKeys.length;
                //for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                while (i < len) {
                    currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);

                    if (element.popValues[arrPopKeys[i]] !== currentValue) {
                        bolRefresh = true;
                    }

                    element.popValues[arrPopKeys[i]] = currentValue;
                    i += 1;
                }
                
            } else if (element.hasAttribute('refresh-on-querystring-change')) {
                bolRefresh = true;
            } else if (element.hasAttribute('template') || element.hasAttribute('value')) {
                bolRefresh = true;
            }

            if (bolRefresh) {
                element.refresh();
            }
        } else {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                i = 0;
                len = arrPopKeys.length;
                //for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                while (i < len) {
                    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                    i += 1;
                }
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                // transfer 'value' attribute to 'template'
                if (element.hasAttribute('value')) {
                    element.setAttribute('template', element.getAttribute('value'));
                    console.warn('gs-switch Warning: "value" attribute is deprecated. Please use the "template" attribute to replace the "value" attribute.', element);
                }
                
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                // Get templates and define some variables
                var arrTemplate = xtag.queryChildren(element, 'template');
                var i;
                var len;
                var attr_i;
                var attr_len;
                var arrAttrNames;
                var arrAttrValues;
                var strAttrName;
                var root;
                var template;
                var arrPopKeys;
                var strQueryString;
                var strQSCol;

                element.attributesFromTemplate = [];
                element.templates = {};

                //for (i = 0, len = arrTemplate.length; i < len; i += 1) {
                i = 0;
                len = arrTemplate.length;
                while (i < len) {
                    if (i === 0) {
                        element.firstTemplate = arrTemplate[i].getAttribute('for') || arrTemplate[i].getAttribute('id');
                    }

                    arrAttrNames = [];
                    arrAttrValues = [];

                    attr_i = 0;
                    attr_len = arrTemplate[i].attributes.length;
                    //for (attr_i = 0, attr_len = arrTemplate[i].attributes.length; attr_i < attr_len; attr_i += 1) {
                    while (attr_i < attr_len) {
                        strAttrName = arrTemplate[i].attributes[attr_i].nodeName;

                        if (strAttrName !== 'for' && strAttrName !== 'id') {
                            arrAttrNames.push(strAttrName);
                            arrAttrValues.push(arrTemplate[i].attributes[attr_i].value);
                        }
                        attr_i += 1;
                    }

                    template = arrTemplate[i];
                    element.templates[template.getAttribute('for') || template.getAttribute('id')] = {
                        'content': template.innerHTML,
                        'arrAttrNames': arrAttrNames,
                        'arrAttrValues': arrAttrValues,
                        'templated': !(element.hasAttribute('static') || template.hasAttribute('static'))
                    };
                    if (!(element.hasAttribute('static') || template.hasAttribute('static')) && 
                        (
                            element.templates[template.getAttribute('for') || template.getAttribute('id')].content.indexOf('&gt;') > -1 ||
                            element.templates[template.getAttribute('for') || template.getAttribute('id')].content.indexOf('&lt;') > -1
                        )) {
                        console.warn('GS-SWITCH WARNING: &gt; or &lt; detected in "' + (template.getAttribute('for') || template.getAttribute('id')) + '" template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                    }

                    i += 1;
                }

                // Clear out the templates from the DOM
                element.innerHTML = '';

                element.arrQueryStringAttributes = [];
                element.popValues = {};

                if (
                    (
                        element.hasAttribute('template') &&
                        element.getAttribute('template').indexOf('{{') > -1
                    ) ||
                    element.hasAttribute('qs') ||
                    element.hasAttribute('refresh-on-querystring-values') ||
                    element.hasAttribute('refresh-on-querystring-change')
                ) {
                    //arrPopKeys = [];
                    //strQueryString = GS.getQueryString();
                    //strQSCol = element.getAttribute('qs');

                    //if (element.hasAttribute('refresh-on-querystring-values')) {
                    //    arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                    //}
                    //if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
                    //    GS.listAdd(arrPopKeys, strQSCol);
                    //}

                    //i = 0;
                    //len = arrPopKeys.length;
                    ////for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    //while (i < len) {
                    //    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQueryString, arrPopKeys[i]);
                    //    i += 1;
                    //}
                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate', function () {
                        pushReplacePopHandler(element);
                    });
                    window.addEventListener('replacestate', function () {
                        pushReplacePopHandler(element);
                    });
                    window.addEventListener('popstate', function () {
                        pushReplacePopHandler(element);
                    });
                }

                element.refresh();
            }
        }
    }

    xtag.register('gs-switch', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(element);
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);

                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value') { // && oldValue !== newValue
                        //element.refresh();
                        element.setAttribute('template', newValue);
                        console.warn('gs-switch Warning: "value" attribute is deprecated. Please use the "template" attribute to replace the "value" attribute.', element);

                    } else if (strAttrName === 'template' && element.inserted === true) {
                        element.refresh();
                    }
                }
            }
        },
        events: {},
        accessors: {
            value: {
                get: function () {
                    var element = this;
                    console.warn('gs-switch Warning: \'.value\' accessor is deprecated. Please use the \'.template\' accessor to replace the \'.value\' accessor.', element);
                    return element.getAttribute('template');
                },
                set: function (newValue) {
                    var element = this;
                    console.warn('gs-switch Warning: \'.value\' accessor is deprecated. Please use the \'.template\' accessor to replace the \'.value\' accessor.', element);
                    element.setAttribute('template', newValue);
                }
            },
            template: {
                get: function () {
                    return this.getAttribute('template');
                },
                set: function (newValue) {
                    this.setAttribute('template', newValue);
                }
            },
            currentTemplate: {
                get: function () {
                    var templateName;
                    var strQueryString = GS.getQueryString();
                    var strQSAttribute = this.getAttribute('qs');
                    var strValueAttribute = this.getAttribute('template') || this.getAttribute('value');
                    if (strQSAttribute && GS.qryGetVal(strQueryString, strQSAttribute)) {
                        templateName = GS.qryGetVal(strQueryString, strQSAttribute);
                    } else if (strValueAttribute) {
                        templateName = GS.templateWithQuerystring(strValueAttribute);
                    }
                    return templateName;
                },
                set: function (newValue) {
                    this.setAttribute('template', newValue);
                }
            }
        },
        methods: {
            refresh: function () {
                var element = this;
                var strQueryString = GS.getQueryString();
                var strQSAttribute = element.getAttribute('qs');
                var strValueAttribute = element.getAttribute('template') || element.getAttribute('value');
                var templateName;
                var i;
                var len;

                if (strQSAttribute && GS.qryGetVal(strQueryString, strQSAttribute)) {
                    templateName = GS.qryGetVal(strQueryString, strQSAttribute);
                } else if (strValueAttribute) {
                    templateName = GS.templateWithQuerystring(strValueAttribute);
                }

                templateName = templateName || element.firstTemplate;

                if (element.templates[templateName] && element.templates[templateName].content) {
                    // if there are values in element.attributesFromTemplate
                    if (element.attributesFromTemplate.length > 0) {
                        // loop through them
                        i = 0;
                        len = element.attributesFromTemplate.length;
                        //for (i = 0, len = element.attributesFromTemplate.length; i < len; i += 1) {
                        while (i < len) {
                            // if attribute was initallySet: set it back to initalvalue
                            if (element.attributesFromTemplate[i].initallySet) {
                                element.setAttribute(element.attributesFromTemplate[i].name, element.attributesFromTemplate[i].initalValue);

                            // else: remove it
                            } else {
                                element.removeAttribute(element.attributesFromTemplate[i].name);
                            }
                            i += 1;
                        }
                    }

                    // clear element.attributesFromTemplate
                    element.attributesFromTemplate = [];

                    // if there are values in element.templates[templateName].arrAttrNames
                    if (element.templates[templateName].arrAttrNames.length > 0) {
                        // loop through them
                        i = 0;
                        len = element.templates[templateName].arrAttrNames.length;
                        //for (i = 0, len = element.templates[templateName].arrAttrNames.length; i < len; i += 1) {
                        while (i < len) {
                            // add to element.attributesFromTemplate
                            element.attributesFromTemplate.push({
                                'name': element.templates[templateName].arrAttrNames[i],
                                'initallySet': element.hasAttribute(element.templates[templateName].arrAttrNames[i]),
                                'initalValue': element.getAttribute(element.templates[templateName].arrAttrNames[i])
                            });

                            // set attribute
                            element.setAttribute(element.templates[templateName].arrAttrNames[i], GS.templateWithQuerystring(this.templates[templateName].arrAttrValues[i]));
                            i += 1;
                        }
                    }

                    if (element.templates[templateName].templated) {
                        element.innerHTML = subsafeTemplate(element.templates[templateName].content);
                    } else {
                        element.innerHTML = element.templates[templateName].content;
                    }

                    // if template is not native: handle templates inside the switch
                    if (shimmed.HTMLTemplateElement) {
                        window.HTMLTemplateElement.bootstrap(element);
                    }
                    //console.trace('trace this');
                    GS.triggerEvent(element, 'templatechange', {'templateName': templateName});
                    GS.triggerEvent(element, 'template_change', {'templateName': templateName});
                } else {
                    element.innerHTML = '';
                }
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, addDataEvents, addDataAttributes
//jslint browser:true, maxlen:80, white:false, this:true

// # CODE INDEX:
//          (use "find" (CTRL-f or CMD-f) to skip to a section)
//          ("PRE-RENDER" refers to a section of functions that do not depend
//                  on the viewport being rendered AND dont use any render
//                  functions)
//          ("POST-RENDER" refers to a section of functions that either depend
//                  on the viewport being rendered OR use render functions)
//      # TOP  (this just brings you back this index)
//      # SNIPPET/DESIGN
//      # FUNCTION SHORTCUTS
//      # ELEMENT CONFIG
//      # GLOBAL ID SEQUENCE
//      # GLOBAL <STYLE></STYLE> ELEMENT SETUP
//      # SCROLLBAR WIDTH
//      # CELL DIMENSION DETECTOR
//      # EXTERIOR LIBRARIES
//          # GETPLAINTEXT
//      # PRE-RENDER UTILITY FUNCTIONS
//      # ELEMENT FUNCTIONS
//      # RENDER FUNCTIONS
//      # POST-RENDER UTILITY FUNCTIONS
//      # LOADER FUNCTIONS
//      # DATA FUNCTIONS
//      # COPY FUNCTIONS
//      # PASTE FUNCTIONS
//      # BUTTON FUNCTIONS
//      # EVENT FUNCTIONS
//          # QS EVENTS
//          # FOCUS EVENTS
//          # SCROLL EVENTS
//          # SELECTION EVENTS
//          # COLUMN/ROW RESIZE EVENTS
//          # COLUMN REORDER EVENTS
//          # UPDATE EVENTS
//          # INSERT EVENTS
//          # HUD EVENTS
//          # KEY EVENTS
//          # COPY EVENTS
//          # PASTE EVENTS
//          # CUT EVENTS
//          # CONTEXTMENU EVENTS
//          # COLUMN DROPDOWN EVENTS
//          # DEVELOPER EVENTS
//          # HIGH LEVEL BINDING
//      # XTAG DEFINITION
//      # ELEMENT LIFECYCLE
//      # ELEMENT ACCESSORS
//      # ELEMENT METHODS
//      # OLD NOTES

// for sections of code that need to be completed:
//      # NEED CODING


// ############################################################################
// ############################## SNIPPET/DESIGN ##############################
// ############################################################################

window.addEventListener('design-register-element', function () {
    'use strict';

    addSnippet(
        '<gs-table>',
        '<gs-table>',
        ml(function () {/*gs-table
    id="${1:tableid}"
    src="test.rtime_copy_datasheet"
    pk="id"
    lock="change_stamp"
    ord="id ASC"
    focus-on-load
    style="width: 100%; height: 100%;"
>
    <template for="top-hud">
        <gs-button
            onclick="document.getElementById('${1:tableid}').deleteSelected()"
            inline no-focus icononly icon="times"
        >&nbsp;</gs-button>
        <gs-button
            onclick="document.getElementById('${1:tableid}').openInsertDialog()"
            inline no-focus icononly icon="plus"
        >&nbsp;</gs-button>
        <gs-button
            onclick="document.getElementById('${1:tableid}').refresh()"
            inline no-focus icononly icon="refresh"
        >&nbsp;</gs-button>
        <gs-button
            onclick="document.getElementById('${1:tableid}').openPrefs(this)"
            inline no-focus icononly icon="sliders"
        >&nbsp;</gs-button>
        <gs-button
            onclick="document.getElementById('${1:tableid}').toFullscreen(this)"
            inline no-focus icononly icon="expand"
        >&nbsp;</gs-button>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        <gs-button
            onclick="document.getElementById('${1:tableid}').sort('asc')"
            inline no-focus iconleft icon="sort-alpha-asc"
        >Sort A to Z</gs-button>
        <gs-button
            onclick="document.getElementById('${1:tableid}').sort('desc')"
            inline no-focus iconleft icon="sort-alpha-desc"
        >Sort Z to A</gs-button>
        <gs-button
            onclick="document.getElementById('${1:tableid}').sort('clear')"
            inline no-focus iconleft icon="trash"
        >Clear Sort</gs-button>
        <gs-button
            onclick="document.getElementById('${1:tableid}').clearFilter()"
            inline no-focus iconleft icon="trash"
        >Clear Filter</gs-button>
    </template>
    <template for="bottom-hud">
        <gs-button
            onclick="document.getElementById('${1:tableid}').goToLine('first')"
            inline no-focus icononly icon="step-backward"
        >&nbsp;</gs-button>
        <gs-button
          onclick="document.getElementById('${1:tableid}').goToLine('previous')"
            inline no-focus icononly icon="caret-left"
        >&nbsp;</gs-button>
        <gs-current-record inline for="${1:tableid}"></gs-current-record>
        <gs-button
            onclick="document.getElementById('${1:tableid}').goToLine('next')"
            inline no-focus icononly icon="caret-right"
        >&nbsp;</gs-button>
        <gs-button
            onclick="document.getElementById('${1:tableid}').goToLine('last')"
            inline no-focus icononly icon="step-forward"
        >&nbsp;</gs-button>
        <gs-button
            onclick="document.getElementById('${1:tableid}').goToLine('insert')"
            inline no-focus icononly icon="plus"
        >&nbsp;</gs-button>
    </template>
    <template for="header-record">
        <gs-cell>${2}</gs-cell>
    </template>
    <template for="data-record">
        <gs-cell header="${2}">${3}</gs-cell>
    </template>
    <template for="copy">
        <gs-cell header="${2}">${3}</gs-cell>
    </template>
    <template for="insert-record">
        <gs-cell header="${2}"><input column="${3}" /></gs-cell>
    </template>
</gs-table>*/
        })
    );

    addElement('gs-table', '#record_table');

    // DEFINE PROPERTIES
    window.designElementProperty_GSTABLE = function () {
        addDataAttributes('select,insert,update,delete,parent-child');
        addText('D', 'Insert Source', 'insert-src');
        addText('D', 'Update Source', 'update-src');
        addText('D', 'Delete Source', 'delete-src');
        addText('D', 'Session Filter', 'session-filter');
        addDataEvents('select,insert,update,delete');
        addText('D', 'Null Display', 'null-string');
        addText('D', 'Null Set', 'null-set-string');
        addCheck('D', 'Suppress Select Error', 'suppress-select-error');
        addCheck('V', 'No Record Selector', 'no-record-selector');
        addCheck('V', 'No Resize Record', 'no-resize-record');
        addCheck('V', 'No Resize Column', 'no-resize-column');
        addCheck('V', 'No Column Reorder', 'no-column-reorder');
        addCheck('V', 'No Contextmenu', 'no-context-menu');
        addCheck('V', 'No Insert Scroll', 'no-insert-scroll');
        addCheck('V', 'No Column Dropdown', 'no-column-dropdown');
        addCheck('V', 'No Copy', 'no-copy');
        addCheck('V', 'Auto Column Widths', 'column-auto-resize');
        addCheck('V', 'Don\'t Force Selection', 'no-force-select');
        addText('V', 'Default Cell Height', 'default-cell-height');
        addText('V', 'Default Cell Width', 'default-cell-width');
        addSelect('O', 'Selection Mode', 'selection-mode', [
            {"val": "", "txt": "All (Default)"},
            {"val": "single-row", "txt": "Single Row"}
        ]);
        addSelect('O', 'Copy Header', 'copy-header', [
            {"val": "", "txt": ""},
            {"val": "never", "txt": "Never"},
            {"val": "always", "txt": "Always"},
            {"val": "selected", "txt": "If Selected"}
        ]);
        addSelect('O', 'Copy Selectors', 'copy-selectors', [
            {"val": "", "txt": ""},
            {"val": "never", "txt": "Never"},
            {"val": "always", "txt": "Always"},
            {"val": "selected", "txt": "If Selected"}
        ]);
        addText('O', 'Copy Quote Character', 'copy-quote-char');
        addText('O', 'Copy Escape Character', 'copy-escape-char');
        addSelect('O', 'Copy Quote When', 'copy-quote-when', [
            {"val": "", "txt": ""},
            {"val": "never", "txt": "Never"},
            {"val": "strings", "txt": "Strings"},
            {"val": "always", "txt": "Always"},
            {"val": "delimiter-in-content", "txt": "Delimiter in Content"}
        ]);
        addText('O', 'Copy Row Delimiter', 'copy-delimiter-record');
        addText('O', 'Copy Column Delimiter', 'copy-delimiter-cell');
        addText('O', 'Copy Null Cell', 'copy-null-cell');
        addText('O', 'Column in QS', 'qs');
        addText('O', 'Refresh On QS Columns', 'refresh-on-querystring-values');
        addCheck('O', 'Refresh On QS Change', 'refresh-on-querystring-change');
    };
});

window.addEventListener('load', function () {
    "use strict";
    var tables = document.getElementsByTagName('gs-table');
    var i = 0;
    var len = tables.length;

    i = 0;
    len = tables.length;
    while (i < len) {
        tables[i].render();
        i += 1;
    }
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
// ############################################################################
// ############################ FUNCTION SHORTCUTS ############################
// ############################################################################
    var tblQryKids = xtag.queryChildren;
    var tblQry = xtag.query;
    var tblElemByID = function (strID) {
        return document.getElementById(strID);
    };

// ############################################################################
// ############################## ELEMENT CONFIG ##############################
// ############################################################################

    var intDefaultRecordHeight = 27; // pixels
    var intDefaultColumnWidth = 75; // pixels

// ############################################################################
// ############################ GLOBAL ID SEQUENCE ############################
// ############################################################################

    var globalIDSeq = 0;

// ############################################################################
// ################### GLOBAL <STYLE></STYLE> ELEMENT SETUP ###################
// ############################################################################

    // we need to dynamically generate some CSS because of browser/OS
    //      differences, so here we create the global style element. This
    //      element may only have CSS appended to it at this global level, not
    //      after gs-table elements are instantiated.
    var globalStyleElement = document.createElement("style");
    globalStyleElement.setAttribute("id", "gs-table-style-container");
    document.head.appendChild(globalStyleElement);

// #############################################################################
// ############################## SCROLLBAR WIDTH ##############################
// #############################################################################

    // we need to handle scrollbar width dynamically because different operating
    //      systems have different scrollbar widths, this section deals with the
    //      scrollbar width for all gs-table elements at the same time.

    // return scrollbar width
    function getScrollBarWidth() {
        var container = document.createElement("div");
        var detector = document.createElement("div");
        var ret;

        document.body.appendChild(container);
        container.appendChild(detector);

        container.style.width = "100px";
        container.style.height = "100px";
        container.style.opacity = "0.2";
        container.style.overflow = "scroll";

        detector.style.display = "inline-block";
        detector.style.width = "10px";
        detector.style.height = "100%";
        //detector.style.background = "#F00";

        ret = 100 - detector.offsetHeight;
        document.body.removeChild(container);

        return ret;
    }

    // save scrollbar width to variable
    var intScrollbarWidth = getScrollBarWidth();

    // we need some CSS specifically to handle the scrollbar,
    //      this function returns that CSS
    function createGlobalScrollbarStyles() {
        var intScrollbarWidthPadded;

        // this variable creates 1px pixels of space in the green box in the
        //      bottom-right corner to make it look well sized and match up
        //      well with the borders around it.
        intScrollbarWidthPadded = (intScrollbarWidth + 1);

        // on an iPhone, scrollbars are hidden
        if (intScrollbarWidth === 0) {
            return 'gs-table > ' +
                    '        .table-root > ' +
                    '        .table-table-container > ' +
                    '        .table-data-container {\n' +
                    '    padding-bottom: 0px;\n' +
                    '    padding-right: 0px;\n' +
                    '}\n' +
                    // hide scrollbar containers
                    'gs-table > ' +
                    '        .table-root > ' +
                    '        .table-table-container > ' +
                    '        .table-v-scroll-bar-container {\n' +
                    '    width: 0px;\n' +
                    '    padding-bottom: 0px;\n' +
                    '    display: none;\n' +
                    '}\n' +
                    // hide scrollbar containers
                    'gs-table > ' +
                    '        .table-root > ' +
                    '        .table-table-container > ' +
                    '        .table-h-scroll-bar-container {\n' +
                    '    height: 0px;\n' +
                    '    padding-right: 0px;\n' +
                    '    display: none;\n' +
                    '}\n' +
                    // remove viewport border
                    'gs-table >\n' +
                    '        .table-root >\n' +
                    '        .table-table-container >\n' +
                    '        .table-data-container >\n' +
                    '        .table-data-viewport {\n' +
                    '    border-right: 0 none;\n' +
                    '    border-bottom: 0 none;\n' +
                    '}';
        }

        return 'gs-table > ' +
                '        .table-root > ' +
                '        .table-table-container > ' +
                '        .table-data-container {\n' +
                '    padding-bottom: ' + intScrollbarWidth + 'px;\n' +
                '    padding-right: ' + intScrollbarWidth + 'px;\n' +
                '}\n' +
                'gs-table > ' +
                '        .table-root > ' +
                '        .table-table-container > ' +
                '        .table-v-scroll-bar-container {\n' +
                '    width: ' + intScrollbarWidth + 'px;\n' +
                '    padding-bottom: ' + intScrollbarWidthPadded + 'px;\n' +
                '}\n' +
                'gs-table > ' +
                '        .table-root > ' +
                '        .table-table-container > ' +
                '        .table-h-scroll-bar-container {\n' +
                '    height: ' + intScrollbarWidth + 'px;\n' +
                '    padding-right: ' + intScrollbarWidthPadded + 'px;\n' +
                '}';
    }

    // append scrollbar-specific CSS to global style element
    globalStyleElement.innerHTML += createGlobalScrollbarStyles();

// #############################################################################
// ########################## CELL DIMENSION DETECTOR ##########################
// #############################################################################

    // we need to be able to detect the cell/border widths/heights dynamically
    //      so that the scrolling functionality can calculate true dimensions
    //      and so that records/columns (which may be dynamically resized) will
    //      have defaults
    function cellDimensionDetector(element) {
        var testDataCell = element.elems.testDataCell;
        var testHeader = element.elems.testHeader;
        var testInsert = element.elems.testInsert;
        var testRecordSelector = element.elems.testRecordSelector;

        // first, we'll look at data record/cell dimensions
        element.internalDisplay.columnBorderWidth = parseInt(
            (GS.getStyle(testDataCell, 'border-right-width') || '0'),
            10
        );
        element.internalDisplay.recordBorderHeight = parseInt(
            (GS.getStyle(testDataCell, 'border-bottom-width') || '0'),
            10
        );
        element.internalDisplay.defaultColumnWidth = parseInt(
            (GS.getStyle(testDataCell, 'width') || '0'),
            10
        );
        element.internalDisplay.defaultRecordHeight = parseInt(
            (
                element.getAttribute('default-cell-height') ||
                GS.getStyle(testDataCell, 'height') ||
                '0'
            ),
            10
        );

        // next, we'll look at header dimensions
        element.internalDisplay.headerBorderHeight = parseInt(
            (GS.getStyle(testHeader, 'border-bottom-width') || '0'),
            10
        );

        // next, we'll look at insert cell dimensions
        element.internalDisplay.insertRecordBorderHeight = parseInt(
            (GS.getStyle(testInsert, 'border-bottom-width') || '0'),
            10
        );

        // next, we'll look at record selector cell dimensions
        element.internalDisplay.recordSelectorBorderWidth = parseInt(
            (GS.getStyle(testRecordSelector, 'border-right-width') || '0'),
            10
        );
    }

    // we need to know if headers, record selectors or the insert record is
    //      being used. this is so that we can determine the amount of space
    //      to put on each side of the viewport for the data
    function visibilityDetector(element) {
        // we reset everything to visible here so that the code is shorter
        // (innocent until proven guilty)
        element.internalDisplay.headerVisible = true;
        element.internalDisplay.recordSelectorVisible = true;
        element.internalDisplay.insertRecordVisible = true;

        // we are checking to see if the header template is empty or just all
        //      whitespace, if it is: we're setting headers to visibility=false
        if (
            !element.internalTemplates.header ||
            !element.internalTemplates.header.trim()
        ) {
            element.internalDisplay.headerVisible = false;
        }

        // we are checking to see if the "no-record-selector" attribute is
        //      present, if it is: we're setting the record selectors to
        //      visibility=false
        if (element.hasAttribute('no-record-selector')) {
            element.internalDisplay.recordSelectorVisible = false;
        }

        // we are checking to see if the insert record template is empty or
        //      just all whitespace, if it is: we're setting the insert record
        //      to visibility=false
        if (
            !element.internalTemplates.originalInsertRecord ||
            !element.internalTemplates.originalInsertRecord.trim()
        ) {
            element.internalDisplay.insertRecordVisible = false;
        }
    }

    // we need to calculate the amount of space to put on each side of the
    //      viewport depending on what features are visible (header, record
    //      selectors, insert record). so, if the insert record is visible
    //      we need to tell everything else that that space is not usable for
    //      anything else
    function offsetDetector(element) {
        // we reset all of the offsets to zero because the way we calculate
        //      the offsets is that we increment the offset if something is
        //      visible (increment/decrement only, no resets after this point)
        element.internalScrollOffsets.top = 0;
        element.internalScrollOffsets.left = 0;
        element.internalScrollOffsets.bottom = 0;
        element.internalScrollOffsets.right = 0;

        // if the header is visible, we want to add the height of the header
        //      (plus it's border) to the top offset
        if (
            element.internalDisplay.headerVisible &&
            element.internalDisplay.headerStick === 'top'
        ) {
            element.internalScrollOffsets.top += (
                element.internalDisplay.headerHeight +
                element.internalDisplay.headerBorderHeight
            );
        }

        // if the record selectors are visible, we want to add the width of
        //      the record selectors (plus the border) to the left offset
        if (
            element.internalDisplay.recordSelectorVisible &&
            element.internalDisplay.selectorStick === 'left'
        ) {
            element.internalScrollOffsets.left += (
                element.internalDisplay.recordSelectorWidth +
                element.internalDisplay.recordSelectorBorderWidth
            );
        }

        // if the insert record is visible, we want to add the height of the
        //      record (plus it's border) to the bottom offset
        if (
            element.internalDisplay.insertRecordVisible &&
            element.internalDisplay.insertRecordStick === 'bottom'
        ) {
            element.internalScrollOffsets.bottom += (
                element.internalDisplay.insertRecordHeight +
                element.internalDisplay.insertRecordBorderHeight
            );
        }
    }

// #############################################################################
// ############################ EXTERIOR LIBRARIES #############################
// #############################################################################

// ############ GETPLAINTEXT #############

    // original name:     getPlainText()
    // original author:   Mike Wilcox
    // original site:     http://clubajax.org
    // original support:  http://groups.google.com/group/clubajax
    //
    //    DESCRIPTION:
    //        Returns a line-break, properly spaced, normalized plain text
    //        representation of multiple child nodes which can't be done via
    //        textContent or innerText because those two methods are vastly
    //        different, and even innerText works differently across browsers.

    /*
    ORIGINAL LICENSE FOR getPlainText():

    This is free and unencumbered software released into the public domain.

    Anyone is free to copy, modify, publish, use, compile, sell, or
    distribute this software, either in source code form or as a compiled
    binary, for any purpose, commercial or non-commercial, and by any
    means.

    In jurisdictions that recognize copyright laws, the author or authors
    of this software dedicate any and all copyright interest in the
    software to the public domain. We make this dedication for the benefit
    of the public at large and to the detriment of our heirs and
    successors. We intend this dedication to be an overt act of
    relinquishment in perpetuity of all present and future rights to this
    software under copyright law.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
    OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.
    */

    // This software has been modified from it's original form and thus,
    //      because the original authors of the software relinquished control
    //      to the individual user of the software, we (Workflow Products)
    //      hereby license this modified version of getPlainText() under the
    //      same license as the javascript you find getPlainText() included in.

    function getPlainText(node, bolConsumable) {
        var plainText = "";

        // used for testing/comparison:
        //return node.innerText || node.textContent;

        // clean up double line breaks and spaces
        function normalize(a) {
            if (!a) {
                return "";
            }
            return a.replace(/\ +/g, " ")
                .replace(/[\t]+/gm, "")
                .replace(/[\ ]+$/gm, "")
                .replace(/^[\ ]+/gm, "")
                .replace(/\n+/g, "\n")
                .replace(/\n+$/, "")
                .replace(/^\n+/, "")
                .replace(/\nNEWLINE\n/g, "\n\n")
                .replace(/NEWLINE\n/g, "\n\n"); // IE
        }

        // because we format the text ourselves, we want to get rid of empty
        //      text nodes, they'll just get in the way
        function removeWhiteSpace(node) {
            var ws_i;
            var ws_len;
            var ws_node;
            var ws = [];

            // recursively find whitespace nodes and push them to "ws" array
            function findWhite(node) {
                var i = 0;
                var len = node.childNodes.length;
                var n;

                while (i < len) {
                    n = node.childNodes[i];
                    if (
                        // if node is a text node
                        n.nodeType === 3 &&
                        // if node contains only whitespace
                        !(/[^\t\n\r\ ]/).test(n.nodeValue)
                    ) {
                        // add node to whitespace node list
                        ws.push(n);

                    // else if node contains other nodes:
                    } else if (n.hasChildNodes()) {
                        // search node for more whitespace child nodes
                        findWhite(n);
                    }
                    i += 1;
                }
            }

            // start recursive search
            findWhite(node);

            // remove nodes that are in the "ws" array
            ws_i = 0;
            ws_len = ws.length;
            while (ws_i < ws_len) {
                ws_node = ws[ws_i];
                ws_node.parentNode.removeChild(ws_node);

                ws_i += 1;
            }
        }

        // we want to get the value of the CSS "white-space" and "display"
        //      properties (because they affect how we build the text), so this
        //      function will return CSS properties for a node
        // also, some elements have implied CSS settings (like SCRIPT is
        //      "display: none;") so, this function handles tag-specific
        //      settings
        function sty(n, prop) {
            var s;
            var bolAssumeBlock;

            // if the .style property is available, just use that
            if (n.style[prop]) {
                return n.style[prop];
            }

            // coalesce through a couple different ways of retrieving CSS values
            s = (
                n.currentStyle ||
                window.getComputedStyle(n, null)
                // ^ used to be n.ownerDocument.defaultView
            );

            if (n.tagName === "SCRIPT") {
                return "none";
            }
            if (!s[prop]) {
                bolAssumeBlock = "LI,P,TR".indexOf(n.tagName);

                // if element is an element we assume block for, return block
                if (bolAssumeBlock) {
                    return "block";
                }
                // else return actual style setting
                return n.style[prop];
            }
            if (s[prop] === "block" && n.tagName === "TD") {
                return "feaux-inline";
            }
            return s[prop];
        }

        var blockTypeNodes = "table-row,block,list-item";
        function isBlock(n) {
            // display:block or something else
            var s = sty(n, "display") || "feaux-inline";
            if (blockTypeNodes.indexOf(s) > -1) {
                return true;
            }
            return false;
        }

        // loop recursively through the nodes and build up the text string
        function recurse(n) {
            var strCSSWhite = sty(n, "whiteSpace");
            var strCSSDisplay = sty(n, "display");
            var gap;
            var i;
            var len;
            var c;

            // Loop through all the child nodes
            // and collect the text, noting whether
            // spaces or line breaks are needed.
            if (strCSSWhite.indexOf('pre') !== -1) {
                plainText += n.innerHTML
                    .replace(/\t/g, " ")
                    .replace(/\n/g, " "); // to match IE
                return "";
            }

            if (strCSSDisplay === "none") {
                return "";
            }

            gap = (
                isBlock(n)
                    ? "\n"
                    : " "
            );

            plainText += gap;
            i = 0;
            len = n.childNodes.length;
            while (i < len) {
                c = n.childNodes[i];

                // if the node is a text node, append the value to the text
                if (c.nodeType === 3) {
                    plainText += c.nodeValue;
                }

                // if the node has children, loop through them
                if (c.childNodes.length) {
                    recurse(c);
                }

                i += 1;
            }

            plainText += gap;
            return plainText;
        }

        // we alter elements within the node that was sent, so clone the
        //      node if it's not consumable
        if (bolConsumable !== true) {
            node = node.cloneNode(true);
        }

        // Line breaks aren't picked up by textContent
        node.innerHTML = node.innerHTML.replace(/<br>/g, "\n"); //</br>

        // we don't care about line breaks after P tags right now
        //// Double line breaks after P tags are desired, but would get
        //// stripped by the final RegExp. Using placeholder text.
        //var paras = node.getElementsByTagName("p");
        //var i;
        //var len;
        //i = 0;
        //len = paras.length;
        //while (i < len) {
        //    paras[i].innerHTML += "NEWLINE";
        //    i += 1;
        //}

        removeWhiteSpace(node);

        // Make the call!
        return normalize(recurse(node));
    }


// #############################################################################
// ####################### PRE-RENDER UTILITY FUNCTIONS ########################
// #############################################################################

    // we need a function to prevent html injection
    function encodeHTML(text) {
        var encode = {
            "&": "&#38;",
            "<": "&#60;",
            ">": "&#62;",
            '"': "&#34;",
            "'": "&#39;",
            "/": "&#47;"
        };

        if (text) {
            return text.toString().replace(
                /&|<|>|"|'|\//g,
                function (letter) {
                    return encode[letter] || letter;
                }
            );
        }
        return text;
    }

    // commented out because we no longer put the styling on the cell
    //// because we need to be able to add styles to an element inside of a
    ////      template string, we have this function take a template (while it's
    ////      still a template element) and add a token to the "style" attribute
    ////      that can be easily replaced
    //function templateCellAddStyleToken(templateElement) {
    //    var arrCell = tblQry(templateElement.content, 'gs-cell');
    //    var i = 0;
    //    var len = arrCell.length;
    //    var strStyle;

    //    while (i < len) {
    //        strStyle = (arrCell[i].getAttribute('style') || '');
    //        strStyle = strStyle.trim();

    //        if (strStyle && strStyle[strStyle.length - 1] !== ';') {
    //            strStyle += ';';
    //        }

    //        arrCell[i].setAttribute(
    //            'style',
    //            '$$CSSREPLACETOKEN$$ ' + strStyle
    //        );

    //        i += 1;
    //    }
    //}

    // because we are using the gs-cell element for headers, data cells, insert
    //      cells, record selectors and the all selector: we need a way for the
    //      CSS to identify them differently, so this function takes a template
    //      element and adds a class to the gs-cell elements within it
    function templateCellAddClass(templateElement, strClass) {
        var arrCell = tblQry(templateElement.content, 'gs-cell');
        var i = 0;
        var len = arrCell.length;

        while (i < len) {
            arrCell[i].classList.add(strClass);
            i += 1;
        }
    }

    // because we need to be able to target cells by record number, this
    //      function takes a template and adds an attribute to each cell that'll
    //      contain the record number (zero-based) after doT.js
    function templateCellAddRowNumber(templateElement, strOverride) {
        var arrCell = tblQry(templateElement.content, 'gs-cell');
        var i = 0;
        var len = arrCell.length;

        while (i < len) {
            arrCell[i].setAttribute(
                'data-row-number',
                (strOverride || '{{! row_number - 1 }}')
            );
            i += 1;
        }
    }

    // because we need to be able to target cells by column number, this
    //      function takes a template and adds an attribute to each cell that'll
    //      contain the column number (zero-based)
    function templateCellAddColumnNumber(templateElement) {
        var arrCell = tblQry(templateElement.content, 'gs-cell');
        var i = 0;
        var len = arrCell.length;

        while (i < len) {
            arrCell[i].setAttribute('data-col-number', i);
            i += 1;
        }
    }

    // commented out because it has been superceded by the new
    //      "templateExtractVisibleCellRange" function
    //// because we only render what is visible on the screen, we use this
    ////      function to take a template string and extract only the columns
    ////      that will be visible
    //function templateExtractCellRange(strTemplate, fromColumn, toColumn) {
    //    var templateElement = document.createElement('template');
    //    templateElement.innerHTML = strTemplate;

    //    var arrCell = tblQry(templateElement.content, 'gs-cell');
    //    var i = fromColumn;
    //    var len = toColumn;
    //    var strCells = '';

    //    while (i < len) {
    //        strCells += arrCell[i].outerHTML;
    //        i += 1;
    //    }

    //    return strCells;
    //}

    // because we only render what is visible on the screen, we use this
    //      function to take a template string and extract only the columns that
    //      will be visible
    // since we've added the ability to hide columns, we need a template
    //      cell extractor that's aware of visibility.
    function templateExtractVisibleCellRange(
        element,
        strTemplate,
        fromColumn,
        toColumn
    ) {
        var jsnRange;

        // if no from and to column have been provided, extract whole visible
        //      range
        if (fromColumn === undefined || toColumn === undefined) {
            jsnRange = element.internalDisplay.currentRange;
            fromColumn = jsnRange.fromColumn;
            toColumn = jsnRange.toColumn;
        }

        var templateElement = document.createElement('template');
        templateElement.innerHTML = strTemplate;

        var arrCell = tblQry(templateElement.content, 'gs-cell');
        var i = fromColumn;
        var len = toColumn;
        var strCells = '';
        var arrColumnWidths = element.internalDisplay.columnWidths;

        while (i < len) {
            if (arrColumnWidths[i] > 0) {
                // who left this?
                // Next time say what was wrong and sign your name.
                // ~Michael

                //// no worky
                //if (
                //    (
                //        arrCell[i].style.width.indexOf('em') !== -1
                //            ? GS.emToPx(document.body, arrCell[i].style.width)
                //            : arrCell[i].style.width
                //    ) > arrColumnWidths[i]
                //) {
                //    element.internalDisplay.columnWidths[i] = (
                //        arrCell[i].style.width.indexOf('em') !== -1
                //            ? GS.emToPx(document.body, arrCell[i].style.width)
                //            : arrCell[i].style.width
                //    );
                //}

                strCells += arrCell[i].outerHTML;
            }
            i += 1;
        }

        return strCells;
    }


    // we need to be able to provide column headings when the user copies some
    //      data, so here we take a template element and we get the text of
    //      every cell and save it for that purpose
    function templateDetermineCopyHeaderList(element, templateElement) {
        var arrHeading = [];
        var arrCell = tblQry(templateElement.content, 'gs-cell');
        var i = 0;
        var len = arrCell.length;
        var bolHeaderFound = false;
        var strHeading;

        while (i < len) {
            strHeading = arrCell[i].getAttribute('header') || '';
            arrHeading.push(strHeading);


            // we want to warn if the copy template has no "header" attributes
            //      so, if one of the cells has a "header" attribute: we'll
            //      prevent the warning code by setting "bolHeaderFound"
            if (arrCell[i].hasAttribute('header')) {
                bolHeaderFound = true;
            }

            i += 1;
        }

        // if no "header" attributes were found (and the "copy-header"
        //      attribute doesn't equal "never"), we want to warn the developer
        //      that when a user copies: they wont have any headers because
        //      none were defined
        if (
            !bolHeaderFound &&
            element.getAttribute('copy-header') !== 'Never'
        ) {
            console.warn('GS-TABLE Warning: No headers found in "copy" ' +
                    'template. Please define headers for the copy by using ' +
                    'the "header" attribute on the gs-cell elements of the ' +
                    '"copy" template. If no headers are defined: when a ' +
                    'user copies they will not get any headers. To dismiss ' +
                    'this warning and prevent users from copying the ' +
                    'header: set the "copy-header" attribute to "never."');
        }

        element.internalClip.headerList = arrHeading;
    }

    // we need to know what data column is used for each column, so here we
    //      take the record template and find out what column is associated
    //      with what column
    function templateDetermineCopyColumnList(element, templateElement) {
        var arrColumn = [];
        var arrCell = tblQry(templateElement.content, 'gs-cell');
        var i = 0;
        var len = arrCell.length;

        //var strColumn;
        //var cell;
        //var strCell;
        //var columnElement;
        //var arrMatch;

        while (i < len) {
            arrColumn.push(arrCell[i].textContent);

            // ######################################## CAN THIS BE REMOVED?
            //// we clear out this variable so that if we don't find a column
            ////      name, we'll just add empty string to the column list
            //strColumn = '';

            //// we save the cell element to a variable for easy access
            //cell = arrCell[i];

            //// we'll look for:
            ////      "{{! rowSOMETHINGHERE }}" or "{{= rowSOMETHINGHERE }}" or
            ////      the first element with the "column" attribute
            ////      if we've found one a doT.js statement, we'll trim off the
            ////      braces, "!", "=" and "row" and we'll be left with either
            ////      "['columnname']" or ".columnname"
            ////      if we've found an element with the "column" attribute,
            ////      we'll use it straight as-is
            //columnElement = tblQry(cell, '[column]')[0];

            //if (cell.hasAttribute('copy-column')) {
            //    strColumn = cell.getAttribute('copy-column') || '';
            //} else if (columnElement) {
            //    strColumn = columnElement.getAttribute('column') || '';
            //}
            ////else {
            ////    strCell = cell.innerHTML;
            ////    arrMatch = strCell.match(/\{\{(!|=)\s*row.*\}\}/g);
            ////    if (arrMatch) {
            ////        strCell = arrMatch[0];
            ////        strCell = strCell
            ////                    // removes "{{="
            ////                    // removes "}}"
            ////                    // removes two columns matched together
            ////                    .substring(3, strCell.indexOf('}}'))
            ////                    // removes extra whitespace
            ////                    .trim();
            ////
            ////    } else {
            ////
            ////    }
            ////}
            //arrColumn.push(strColumn);
            i += 1;
        }

        element.internalClip.columnList = arrColumn;
    }

    // sometimes, we want to get a list of column names that are used in a
    //      template
    function templateGetColumnList(templateElement) {
        var arrColumn = [];
        var arrElement = tblQry(templateElement.content, '[column]');
        var i = 0;
        var len = arrElement.length;
        var strColumn;

        while (i < len) {
            strColumn = arrElement[i].getAttribute('column');

            // if there is a column name in the "column" attribute and the
            //      column isn't already in the list of columns we've found:
            //      add it to the array
            if (strColumn && arrColumn.indexOf(strColumn) === -1) {
                arrColumn.push(strColumn);
            }
            i += 1;
        }

        return arrColumn;
    }

    // the user needs to be able to set a custom websocket for this element,
    //      so this function will use an attribute to find out what socket to
    //      use (and it'll default to "GS.envSocket")
    function getSocket(element) {
        if (element.getAttribute('socket')) {
            return GS[element.getAttribute('socket')];
        }
        return GS.envSocket;
    }

    // we need to be able to replace all occurences of a dynamic string with
    //      another dynamic string, and because javascript's .replace()
    //      function only replaces the first occurence (unless you send a
    //      regex), we use this function which takes the string to replace and
    //      creates a regex from it (escaping all regex special characters)
    //      then uses javascript's .replace()
    function stringReplaceAll(str, find, replace) {
        return str.replace(
            new RegExp(
                find.replace(
                    /([\.\*\+\?\^\=\!\:\$\{\}\(\)\|\[\]\/\\])/g,
                    '\\$1'
                ),
                'g'
            ),
            replace
        );
    }

    // both render partial and render full need to know the visible range
    //      of cells so this function serves them both, it returns the
    //      from/to column/record numbers and the origin top/left point
    function getCurrentCellRange(element) {
        var scrollTop;
        var scrollLeft;
        var arrColumnWidths;
        //var arrColumnBorders;
        var arrRecordHeights;
        var columnBorderWidth;
        var recordBorderHeight;

        var fromColumn;
        var toColumn;
        var fromRecord;
        var toRecord;

        var i;
        var len;
        var intTemp;
        var intPrev;

        var intViewportWidth;
        var intViewportHeight;
        var intCellOriginLeft;
        var intRecordOriginTop;

        var bolRecordSelector;
        var bolInsertRecord;
        var bolHeaderRecord;
        var bolRenderAllColumns;

        // we need the viewport dimensions because we need to include the
        //      viewport when choosing what cells to show
        intViewportWidth = element.elems.dataViewport.clientWidth;
        intViewportHeight = element.elems.dataViewport.clientHeight;

        // save column widths and record heights for easy access
        arrColumnWidths = element.internalDisplay.columnWidths;
        arrRecordHeights = element.internalDisplay.recordHeights;

        // we needs the border dimensions to calculate true locations
        columnBorderWidth = element.internalDisplay.columnBorderWidth;
        recordBorderHeight = element.internalDisplay.recordBorderHeight;

        // save scroll location and dimensions for easy access
        scrollTop = element.internalScroll.top;
        scrollLeft = element.internalScroll.left;

        // the developer can choose to not render hidden columns, this limits
        //      some small bits of functionality (the only example I can think
        //      of is selecting all the columns and double clicking to resize.
        //      when some of the columns are not rendered, they don't get
        //      affected by the resize.). This choice affects scrolling
        //      calculations so we need to find out what the developer wants.
        bolRenderAllColumns = !element.hasAttribute('skip-hidden-columns');

        // commented out because we are now going to allow overscrolling,
        //      eventually, it's possible we'll make overscrolling an option
        //      if that happens, we'll want this code back
        //// if we are scrolled all the way to the bottom and there is scroll
        ////      room, we don't want to show the bottom border of the last
        ////      cells, so we'll move the scroll up by the border size
        //if (
        //    scrollTop === element.internalScroll.maxTop &&
        //    element.internalScroll.maxTop > 0
        //) {
        //    scrollTop -= recordBorderHeight;
        //}

        // remove some width and height from the viewport because some of it
        //      will be covered by the header, insert and selector cells
        intViewportHeight -= (
            element.internalScrollOffsets.top +
            element.internalScrollOffsets.bottom
        );
        intViewportWidth -= (
            element.internalScrollOffsets.left +
            element.internalScrollOffsets.right
        );

        i = 0;
        len = arrColumnWidths.length;
        intTemp = 0;
        intCellOriginLeft = 0;
        while (i < len) {
            // when the column width is zero, it's hidden, so don't factor
            //      it into the calculations
            if (arrColumnWidths[i] > 0) {
                intPrev = intTemp;
                intTemp += arrColumnWidths[i];
                intTemp += columnBorderWidth;
            }

            if (fromColumn === undefined && intTemp >= scrollLeft) {
                fromColumn = i;
                if (bolRenderAllColumns) {
                    intCellOriginLeft = -intPrev;
                } else {
                    intCellOriginLeft = (intCellOriginLeft - scrollLeft);
                }
            }
            if (
                toColumn === undefined &&
                intTemp > (scrollLeft + intViewportWidth)
            ) {
                toColumn = i;
                break;
            }
            if (fromColumn === undefined && bolRenderAllColumns) {
                intCellOriginLeft = intTemp;
            }
            i += 1;
        }
        fromColumn = Math.max(0, (fromColumn || 0));
        toColumn = (toColumn || i) + 1;

        intCellOriginLeft = intCellOriginLeft || 0;

        if (toColumn > arrColumnWidths.length) {
            toColumn = arrColumnWidths.length;
        }

        // At first, we forced hidden columns to not be rendered. Normally,
        //      we want all columns rendered, even if not every single one
        //      is visible. This allows us to commit operations on hidden
        //      columns. But, sometimes, speed is more important. So, we
        //      have an attribute to make it so that hidden columns are not
        //      rendered.
        if (bolRenderAllColumns) {
            fromColumn = 0;
            toColumn = arrColumnWidths.length;
        }

        //console.log(intCellOriginLeft);
        //console.log('columns: ', fromColumn, toColumn);

        // figure out start/end records
        i = 0;
        len = arrRecordHeights.length;
        intTemp = 0;
        intRecordOriginTop = 0;
        while (i < len) {
            intTemp += arrRecordHeights[i];
            intTemp += recordBorderHeight;

            if (fromRecord === undefined && intTemp >= scrollTop) {
                fromRecord = i;
                intRecordOriginTop = (intRecordOriginTop - scrollTop);
            }
            if (
                toRecord === undefined &&
                intTemp > (scrollTop + intViewportHeight)
            ) {
                toRecord = i;
                break;
            }
            if (fromRecord === undefined) {
                intRecordOriginTop = intTemp;
            }
            i += 1;
        }
        toRecord = ((toRecord || i) + 1);
        intRecordOriginTop = (intRecordOriginTop || 0);

        //console.log(
        //    toRecord,
        //    arrRecordHeights.length,
        //    element.internalDisplay.insertRecordVisible,
        //    element.internalDisplay.insertRecordStick,
        //    fromRecord
        //);

        bolInsertRecord = false;
        if (toRecord > arrRecordHeights.length) {
            bolInsertRecord = (
                element.internalDisplay.insertRecordVisible &&
                element.internalDisplay.insertRecordStick === null
            );

            if (
                element.internalDisplay.insertRecordVisible &&
                element.internalDisplay.insertRecordStick === null &&
                fromRecord === undefined
            ) {
                toRecord = (arrRecordHeights.length + 1);
                fromRecord = toRecord;
            } else {
                toRecord = arrRecordHeights.length;
            }
        }

        fromRecord = Math.max(0, (fromRecord || 0));

        // right now, the gs-table assumes that the header is always
        //      affixed to the top side of the viewport.
        bolHeaderRecord = element.internalDisplay.headerVisible;

        // right now, the gs-table assumes that the record selectors are
        //      always affixed to the left side of the viewport.
        bolRecordSelector = element.internalDisplay.recordSelectorVisible;

        // because we scroll by forcing the leftmost column to stick to the
        //      left side, there is a discrepancy between the scroll and what
        //      the user sees that the scroll is, we need a variable to store
        //      what the user sees for the scroll
        element.internalScroll.displayTop = (
            scrollTop + intRecordOriginTop
        );
        element.internalScroll.displayLeft = (
            scrollLeft + intCellOriginLeft
        );

        //console.log(
        //    element.internalScroll.displayTop,
        //    scrollTop,
        //    intRecordOriginTop
        //);
        //console.log(
        //    element.internalScroll.displayLeft,
        //    scrollLeft,
        //    intCellOriginLeft
        //);

        // offset the record/cell origins by the amount that the header cells
        //      and record selectors offset the viewport
        if (bolRenderAllColumns) {
            intCellOriginLeft += element.internalScrollOffsets.left;
        } else {
            intCellOriginLeft = element.internalScrollOffsets.left;
        }
        intRecordOriginTop = element.internalScrollOffsets.top;

        // commented out and replaced by the two lines above, these two lines
        //      make scrolling smooth, the two lines above make the scrolling
        //      resolve to the top of the top record and the left of the
        //      leftmost column
        //intCellOriginLeft += element.internalScrollOffsets.left;
        //intRecordOriginTop += element.internalScrollOffsets.top;

        //console.log('element: ', element);
        //console.log('intRecordOriginTop: ', intRecordOriginTop);
        //console.log('intCellOriginLeft: ', intCellOriginLeft);
        //console.log('fromRecord: ', fromRecord);
        //console.log('fromColumn: ', fromColumn);
        //console.log('toRecord: ', toRecord);
        //console.log('toColumn: ', toColumn);

        return {
            "originTop": intRecordOriginTop,
            "originLeft": intCellOriginLeft,

            "fromRecord": fromRecord,
            "fromColumn": fromColumn,
            "toRecord": toRecord,
            "toColumn": toColumn,

            "headerRecord": bolHeaderRecord,
            "recordSelector": bolRecordSelector,
            "insertRecord": bolInsertRecord
        };
    }

    // in the case of header->line relationships, we need to be able to
    //      silently add in values to form the header->line link, so, here
    //      we generate the values for the link
    function getInsertAddin(element) {
        var jsnRet = {};

        if (element.getAttribute('column') || element.getAttribute('qs')) {
            jsnRet.link_column = (
                element.getAttribute('child-column') ||
                element.getAttribute('column') ||
                element.getAttribute('qs')
            );
            jsnRet.link_value = element.value;
        }

        return jsnRet;
    }

    function delimitedStringToHTML(
        element,
        valueText,
        fieldDelimiter,
        recordDelimiter,
        quoteChar,
        decodeFunction
    ) {
        var i = 0;
        var len = valueText.length;
        var col_i;
        var col_len;

        var arrRecords = [];
        var arrRecord = [];

        var bolInQuote = false;
        var strCell = '';
        var strRecord;
        var strHTML = '';
        var strPreviousChar;
        var strChar;
        var strNullString;

        // we want the null string to be configurable, so we'll read the
        //      "null-string" attribute to get the null string
        // if the "null-string" attribute is present, use the contents
        //      or coalesce to empty string
        if (element.hasAttribute('null-string')) {
            strNullString = element.getAttribute('null-string') || '';

        // else, null string is left up to the encoding function
        } else {
            strNullString = undefined;
        }

        // sometimes, there is an extra delimiter at the beginning of the first
        //      record. if there is: skip over it.
        if (valueText[0] === recordDelimiter) {
            i += 1;
        }

        // make sure there is a recordDelimiter at the end
        if (valueText[len - 1] !== recordDelimiter) {
            valueText += recordDelimiter;
            len = valueText.length;
        }

        // looper
        while (i < len) {
            strChar = valueText[i];
            if (
                strChar === quoteChar &&
                bolInQuote === false &&
                (
                    strPreviousChar === fieldDelimiter ||
                    strPreviousChar === recordDelimiter ||
                    strPreviousChar === undefined
                )
            ) {
                bolInQuote = true;

            } else if (strChar === quoteChar && bolInQuote === true) {
                bolInQuote = false;

            } else if (strChar === fieldDelimiter && bolInQuote === false) {
                arrRecord.push(decodeFunction(strCell, strNullString));
                strCell = '';

            } else if (strChar === recordDelimiter && bolInQuote === false) {
                arrRecord.push(decodeFunction(strCell, strNullString));
                strCell = '';

                arrRecords.push(arrRecord);
                arrRecord = [];

            } else {
                strCell += strChar;
            }

            strPreviousChar = strChar;
            i += 1;
        }

        // data structure to html
        i = 0;
        len = arrRecords.length;
        while (i < len) {
            strRecord = '';
            col_i = 0;
            col_len = arrRecords[i].length;
            while (col_i < col_len) {
                strRecord += (
                    '<td>' +
                        encodeHTML(arrRecords[i][col_i]) +
                    '</td>'
                );
                col_i += 1;
            }

            strHTML += '<tr>' + strRecord + '</tr>';
            i += 1;
        }

        return '<table>' + strHTML + '</table>';
    }

    // sometimes we need to have the selection object, but we don't want it to
    //      change when the selection of the table changes (and vice versa). one
    //      occurance of this is when we are about to update the selection,
    //      we'll copy the selection so that we have a backup and then we'll
    //      update the selection and then we trigger a "before_selection" event.
    //      if the "before_selection" event get's prevented than we'll revert
    //      to a copy.
    function getSelectionCopy(element) {
        var jsnOriginal;
        var jsnCopy;
        var jsnRange;
        var i;
        var len;

        jsnOriginal = element.internalSelection;

        jsnCopy = {
            "ranges": [],
            "insertRecord": jsnOriginal.insertRecord
        };

        // hold on a minute there, why can we just use .slice(0) on the
        //      selection range array?
        // well, my young grasshopper, .slice(0) does work for copying arrays.
        //      however, our selection ranges are stored as JSON objects and
        //      JSON objects within an array will not be copied, the copy array
        //      and the original array will both reference the same JSON object
        //      in memory. so, if I copied the selection range array using
        //      .slice(0) and then altered one of the range objects, the
        //      original would show the same changes. so, using .slice(0) would
        //      make this function useless if you're trying to back up the
        //      selection ranges.
        i = 0;
        len = jsnOriginal.ranges.length;
        while (i < len) {
            jsnRange = jsnOriginal.ranges[i];

            jsnCopy.ranges.push({
                "start": {
                    "row": jsnRange.start.row,
                    "column": jsnRange.start.column
                },
                "end": {
                    "row": jsnRange.end.row,
                    "column": jsnRange.end.column
                }
            });
            i += 1;
        }

        return jsnCopy;
    }

    // sometimes, we need to get the value of a cell. this function returns a
    //      cell in it's unencoded state
    function getCell(
        element,
        strColumn,
        intRow,
        bolDecode,
        strNullStringOverride
    ) {
        var strRecord;
        var rec_i;
        var rec_len;
        var strChar;
        var strCell;
        var strNullString;

        var intCurrentColumn;
        var intTargetColumn;

        // we need to know the index of the target column
        intTargetColumn = (
            element.internalData.columnNames.indexOf(strColumn)
        );

        // we'll iterate through each char until we get the text for the cell
        //      at the correct index
        strRecord = element.internalData.records[intRow];
        intCurrentColumn = 0;
        strCell = '';
        rec_i = 0;
        rec_len = strRecord.length;
        while (rec_i < rec_len) {
            strChar = strRecord[rec_i];

            // if the current character is not a tab: add it to the current
            //      cell variable
            if (strChar !== '\t') {
                strCell += strChar;
            }

            // if the current character is a tab or we are at the end of the
            //      record: handle current cell
            if (
                strChar === '\t' ||
                rec_i === (rec_len - 1)
            ) {
                // advance column number
                intCurrentColumn += 1;

                // if we've reached the start of the column after the desired
                //      column, stop the loop
                if (intCurrentColumn === (intTargetColumn + 1)) {
                    break;
                }

                // clear cell variable
                strCell = '';
            }

            rec_i += 1;
        }

        //console.log('RECORD:', strRecord);
        //console.log('COLUMN:', strColumn);
        //console.log('CELL:', strCell);
        //console.log('NULLSTRING:', strNullString);
        //console.log(
        //    'DECODED:',
        //    GS.decodeFromTabDelimited(strCell, strNullString)
        //);

        if (bolDecode !== false) {
            // we want the null string to be configurable, so we'll read the
            //      "null-string" attribute to get the null string
            // if the "null-string" attribute is present, use the contents
            //      or coalesce to empty string
            if (strNullStringOverride !== undefined) {
                strNullString = strNullStringOverride;

            } else if (element.hasAttribute('null-string')) {
                strNullString = element.getAttribute('null-string') || '';

            // else, null string is left up to the encoding function
            } else {
                strNullString = undefined;
            }

            return GS.decodeFromTabDelimited(strCell, strNullString);
        }

        return strCell;
    }

    function getConnectedSelectedColumns(element, intStartColumn) {
        var arrCurrentColumns;
        var arrSelection;
        var i;

        // get selected column list
        arrSelection = (
            element.internalSelection.columns
        );

        // clear current columns array so that we can start fresh
        arrCurrentColumns = [];

        // loop forwards until we run into a column that is not
        //      selected, each sequential column that is in the
        //      selected column list will be added to the current
        //      list
        i = intStartColumn;
        while (i < 9999) {
            if (arrSelection.indexOf(i) > -1) {
                arrCurrentColumns.push(i);
            } else {
                break;
            }
            i += 1;
        }

        // loop backwards until we run into a column that is not
        //      selected, each sequential column that is in the
        //      selected column list will be added to the current
        //      list
        i = (intStartColumn - 1);
        while (i >= 0) {
            if (arrSelection.indexOf(i) > -1) {
                arrCurrentColumns.push(i);
            } else {
                break;
            }
            i -= 1;
        }

        // we need to sort the column number list. this is because
        //      of how we find all of the column numbers to reorder
        arrCurrentColumns.sort();

        // ask and you shall receive
        return arrCurrentColumns;
    }

    // in partial and full rerender, we need to set the button icons
    //      and the tooltips of the header cells
    function handleHeaderTemplateTokens(
        element,
        strTemplate,
        fromColumn,
        toColumn
    ) {
        var col_i;
        var col_len;
        var filter_i;
        var filter_len;

        var columnIndex;
        var strDataColumn;
        var strTitle;
        var strClass;

        var arrColumnWidths;
        var arrColumnOrders;
        var arrColumnFilters;

        //console.log('1***', strTemplate);

        // save the order lists for easy access
        arrColumnOrders = element.internalData.columnOrders;

        // save the filter lists for easy access
        arrColumnFilters = element.internalData.columnFilters;

        // save column widths for easy access
        arrColumnWidths = element.internalDisplay.columnWidths;

        col_i = fromColumn;
        col_len = toColumn;
        while (col_i < col_len) {
            // if the column is not hidden
            if (arrColumnWidths[col_i] > 0) {
                strDataColumn = (
                    element.internalDisplay.dataColumnName[
                        col_i
                    ]
                );

                columnIndex = (
                    element.internalData.columnNames.indexOf(
                        strDataColumn
                    )
                );

                strClass = '';
                if (arrColumnOrders[columnIndex] !== 'neutral') {
                    strClass += (
                        ' sort-' +
                        arrColumnOrders[columnIndex]
                    );
                }
                if (
                    arrColumnFilters[columnIndex] &&
                    arrColumnFilters[columnIndex].length > 0
                ) {
                    strClass += ' filtered';
                }
                strTemplate = strTemplate.replace(
                    '$$HDRBTNCLASS_' + strDataColumn + '$$',
                    strClass
                );

                // we need to calculate the title attribute for this
                //      header cell
                strTitle = '';

                if (arrColumnFilters[columnIndex]) {
                    filter_i = 0;
                    filter_len = arrColumnFilters[columnIndex].length;
                    while (filter_i < filter_len) {
                        strTitle += (
                            strTitle
                                ? ' '
                                : ''
                        );
                        strTitle += (
                            arrColumnFilters[columnIndex][filter_i].name
                        );

                        filter_i += 1;
                    }
                }

                // sort in title attribute
                if (arrColumnOrders[columnIndex] === 'desc') {
                    strTitle += (
                        strTitle
                            ? ' '
                            : ''
                    );
                    strTitle += 'sorted descending';

                } else if (arrColumnOrders[columnIndex] === 'asc') {
                    strTitle += (
                        strTitle
                            ? ' '
                            : ''
                    );
                    strTitle += 'sorted ascending';
                }

                // replace title token
                strTemplate = strTemplate.replace(
                    '$$HDR_TITLE_' + strDataColumn + '$$',
                    encodeHTML(strTitle)
                );
            }
            col_i += 1;
        }

        //console.log('2***', strTemplate);

        return strTemplate;
    }

    // in multiple places we need to turn a direction string into useful
    //      booleans and a resolved direction string
    function directionStringBreakdown(strDirectionString) {
        var bolTop;
        var bolLeft;
        var bolBottom;
        var bolRight;

        // prevent uppercase characters
        strDirectionString = strDirectionString.toLowerCase();

        // multiple scroll directions could be sent, we need to parse and
        //      resolve the value to something consistent
        bolTop = (strDirectionString.indexOf('top') !== -1);
        bolLeft = (strDirectionString.indexOf('left') !== -1);
        bolBottom = (strDirectionString.indexOf('bottom') !== -1);
        bolRight = (strDirectionString.indexOf('right') !== -1);

        // warn if two scroll directions are contradictory
        if (bolTop && bolBottom) {
            console.warn('GS-TABLE Warning: Contradictory parameter sent' +
                    ' to directionStringBreakdown.' +
                    ' "Down" direction will be cancelled.' +
                    ' Parameter Text: "' + strDirectionString + '"');
            bolBottom = false;
        }
        if (bolLeft && bolRight) {
            console.warn('GS-TABLE Warning: Contradictory parameter sent' +
                    ' to directionStringBreakdown.' +
                    ' the left and the right at the same time.' +
                    ' "Right" direction will be cancelled.' +
                    ' Parameter Text: "' + strDirectionString + '"');
            bolRight = false;
        }

        // build up consistent scroll direction string
        strDirectionString = '';
        if (bolTop) {
            strDirectionString += 'top';
        }
        if (bolLeft) {
            strDirectionString += 'left';
        }
        if (bolBottom) {
            strDirectionString += 'bottom';
        }
        if (bolRight) {
            strDirectionString += 'right';
        }

        return {
            "bolTop": bolTop,
            "bolLeft": bolLeft,
            "bolBottom": bolBottom,
            "bolRight": bolRight,
            "resolvedString": strDirectionString
        };
    }

    // there are multiple times where we need to find a specific HUD element.
    //      Any HUD element is allowed to be in either the top or bottom HUD
    //      bar. this function looks for elements by class because HUD elements
    //      are identified by classes. this function will check both the top and
    //      bottom HUD bars.
    // in the future, we want to allow multiple buttons with the same class (for
    //      example, the developer may want a refresh button at the top and at
    //      the bottom).
    // ### NEED CODING ###
    function findHudElement(element, strClass) {
        var hudElement;

        // first, we'll try to find it in the bottom HUD
        hudElement = tblQry(
            element.elems.bottomHudContainer,
            '.' + strClass
        )[0];

        // if we couldn't find the element in the bottom HUD,
        //      we'll try the top HUD
        if (!hudElement) {
            hudElement = tblQry(
                element.elems.topHudContainer,
                '.' + strClass
            )[0];
        }

        // return whatever we found
        return hudElement;
    }

    // in multiple places, we care what data columns selected
    function getSelectedDataColumns(element) {
        var arrSelectedColumns;
        var arrDataColumns;
        var i;
        var len;
        var index;

        // we need an array of the selected data columns
        arrSelectedColumns = (
            element.internalSelection.columns
        );
        arrDataColumns = [];
        i = 0;
        len = arrSelectedColumns.length;
        while (i < len) {
            index = arrSelectedColumns[i];
            if (element.internalDisplay.dataColumnName[index]) {
                arrDataColumns.push(
                    element.internalData.columnNames.indexOf(
                        element.internalDisplay.dataColumnName[index]
                    )
                );
            }

            i += 1;
        }

        return arrDataColumns;
    }

    // we want the proper event to bubble up when the hidden focus control is
    //      focused. in order to do this, we've moved that code into this
    //      function so that we don't have to repeat it
    function focusHiddenControl(element) {
        element.elems.hiddenFocusControl.focus();
        GS.triggerEvent(element.elems.hiddenFocusControl, 'focus');
    }


    // sometimes, we need to know what cell the mouse is over
    // returns JSON: {"row": row, "column": column}
    //      possible "column" values: NUMBER|"selector"
    //      possible "row"    values: NUMBER|"header"|"insert"
    function getCellFromMouseEvent(element, event) {
        var cell;
        var row;
        var column;

        // if we can't extract from cell
        var jsnMousePos;
        var jsnElementPos;
        var intMouseX;
        var intMouseY;
        var jsnRange;
        var arrColumnWidths;
        var arrRecordHeights;
        var i;
        var len;
        var intLeft;
        var intTop;
        var intColBorderWidth;
        var intRowBorderHeight;
        var intRowSelectorWidth;
        var intHeaderHeight;
        var bolHeader;
        var bolInsertRecord;
        var bolRecordSelector;

        // get cell element from mouse event
        cell = event.target;
        if (cell.nodeName !== 'GS-CELL') {
            cell = GS.findParentTag(cell, 'gs-cell');
        }

        // if we have a cell, get row/column number from it
        if (cell) {
            // the only cells that don't have a row number are header cells
            row = (cell.getAttribute('data-row-number') || 'header');

            // record selectors are [data-col]="selector",
            //      everything else is [data-col-number]="NUMBER"
            column = (
                cell.getAttribute('data-col') ||
                cell.getAttribute('data-col-number')
            );

            // return number if possible, else string
            if (!isNaN(row)) {
                row = parseInt(row, 10);
            }

            // return number if possible, else string
            if (!isNaN(column)) {
                column = parseInt(column, 10);
            }

        // if we don't have a cell, use the old method
        //      we take the mouse position and try to find the column/row
        //      POSSIBLY STILL GOING TO RETURN INCORRECTLY ON PAGE SCROLL
        //      after some testing, it seems that scrolling is only an issue if
        //      the browser doesn't have ".getBoundingClientRect" built in,
        //      which is used by GS.getElementOffset. If it isn't present,
        //      GS.getElementOffset polyfills with our own solution, which is
        //      likely inaccurate in some circumstances.
        } else {
            // gather display variables
            jsnRange = element.internalDisplay.currentRange;

            bolHeader = element.internalDisplay.headerVisible;
            bolInsertRecord = (
                element.internalDisplay.insertRecordVisible &&
                jsnRange.insertRecord
            );
            bolRecordSelector = element.internalDisplay.recordSelectorVisible;

            arrColumnWidths = element.internalDisplay.columnWidths;
            arrRecordHeights = element.internalDisplay.recordHeights;
            intColBorderWidth = element.internalDisplay.columnBorderWidth;
            intRowBorderHeight = element.internalDisplay.recordBorderHeight;
            intRowSelectorWidth = (
                bolRecordSelector
                    ? (
                        element.internalDisplay.recordSelectorWidth +
                        element.internalDisplay.recordSelectorBorderWidth
                    )
                    : 0
            );
            intHeaderHeight = (
                bolHeader
                    ? (
                        element.internalDisplay.headerHeight +
                        element.internalDisplay.headerBorderHeight
                    )
                    : 0
            );

            // we need the mouse position and the element position
            jsnMousePos = GS.mousePosition(event);
            jsnElementPos = GS.getElementOffset(
                element.elems.dataViewport
            );

            // we need the mouse X to be relative to the dataViewport
            intMouseX = (jsnMousePos.left - jsnElementPos.left);

            // we need the mouse Y to be relative to the dataViewport
            intMouseY = (jsnMousePos.top - jsnElementPos.top);

            // get column. careful, it could be the record selector

            // if record selector is visible and the mouse is above it
            if (bolRecordSelector && intMouseX <= intRowSelectorWidth) {
                column = 'selector';

            } else {
                intLeft = jsnRange.originLeft;//intRowSelectorWidth;
                i = jsnRange.fromColumn;
                len = jsnRange.toColumn;
                while (i < len) {
                    if (intMouseX >= intLeft) {
                        column = i;
                    } else {
                        break;
                    }

                    intLeft += arrColumnWidths[i];
                    intLeft += intColBorderWidth;
                    i += 1;
                }
            }

            // get record. careful, it could be the header or the insert record

            // if header is visible
            if (bolHeader && intMouseY <= intHeaderHeight) {
                row = 'header';

            } else {
                intTop = intHeaderHeight;
                i = jsnRange.fromRecord;
                len = jsnRange.toRecord;
                while (i < len) {
                    if (intMouseY >= intTop) {
                        row = i;
                    } else {
                        break;
                    }

                    intTop += arrRecordHeights[i];
                    intTop += intRowBorderHeight;
                    i += 1;
                }

                if (bolInsertRecord && intMouseY >= intTop) {
                    row = 'insert';
                }
            }
        }

        // default row/column to first row/column (LAST RESORT, AVOID)
        row = row || 0;
        column = column || 0;

        // return cell row and column
        return {"row": row, "column": column};


        // changed by Michael on 12/27/2021
        // this code prevented insert, selector, and header cells from being
        //      selected, because it "parseInt"ed all results
/*
        var cell = event.target;
        if (cell.tagName.toLowerCase() !== 'gs-cell') {
            cell = GS.findParentTag(event.target, 'gs-cell');
        }
        var row = cell.getAttribute('data-row-number');
        var column = (
            cell.getAttribute('data-col') === 'selector'
                ? -1
                : cell.getAttribute('data-col-number')
        );

        return {
            "row": parseInt(row, 10),
            "column": parseInt(column, 10)
        };
*/

        // changed on 2021-10-12 by Nunzio
        // This code breaks when the page is scrolled
/*
        var jsnMousePos;
        var jsnElementPos;
        var intMouseX;
        var intMouseY;
        var row;
        var column;
        var jsnRange;
        var arrColumnWidths;
        var arrRecordHeights;
        var i;
        var len;
        var intLeft;
        var intTop;
        var intColBorderWidth;
        var intRowBorderHeight;
        var intRowSelectorWidth;
        var intHeaderHeight;
        //var intInsertRecordHeight;
        var bolHeader;
        var bolInsertRecord;
        var bolRecordSelector;

        // gather display variables
        jsnRange = element.internalDisplay.currentRange;
        console.log(jsnRange);

        bolHeader = element.internalDisplay.headerVisible;
        bolInsertRecord = (
            element.internalDisplay.insertRecordVisible &&
            jsnRange.insertRecord
        );
        bolRecordSelector = element.internalDisplay.recordSelectorVisible;

        arrColumnWidths = element.internalDisplay.columnWidths;
        arrRecordHeights = element.internalDisplay.recordHeights;
        intColBorderWidth = element.internalDisplay.columnBorderWidth;
        intRowBorderHeight = element.internalDisplay.recordBorderHeight;
        intRowSelectorWidth = (
            bolRecordSelector
                ? (
                    element.internalDisplay.recordSelectorWidth +
                    element.internalDisplay.recordSelectorBorderWidth
                )
                : 0
        );
        intHeaderHeight = (
            bolHeader
                ? (
                    element.internalDisplay.headerHeight +
                    element.internalDisplay.headerBorderHeight
                )
                : 0
        );
        //intInsertRecordHeight = (
        //    bolInsertRecord
        //        ? (
        //            element.internalDisplay.insertRecordHeight +
        //            element.internalDisplay.insertRecordBorderWidth
        //        )
        //        : 0
        //);

        // we need the mouse position and the element position
        jsnMousePos = GS.mousePosition(event);
        jsnElementPos = GS.getElementOffset(
            element.elems.dataViewport
        );
        console.log(jsnMousePos, jsnElementPos);

        // we need the mouse X to be relative to the dataViewport
        intMouseX = (jsnMousePos.left - jsnElementPos.left);

        // we need the mouse Y to be relative to the dataViewport
        intMouseY = (jsnMousePos.top - jsnElementPos.top);
        console.log(intMouseX, intMouseY);

        // get column. careful, it could be the record selector

        // if record selector is visible and the mouse is above it
        if (bolRecordSelector && intMouseX <= intRowSelectorWidth) {
            column = 'selector';

        } else {
            intLeft = jsnRange.originLeft;//intRowSelectorWidth;
            i = jsnRange.fromColumn;
            len = jsnRange.toColumn;
            while (i < len) {
                if (intMouseX >= intLeft) {
                    column = i;
                } else {
                    break;
                }

                intLeft += arrColumnWidths[i];
                intLeft += intColBorderWidth;
                i += 1;
            }
        }

        // get record. careful, it could be the header or the insert record

        // if header is visible
        if (
            bolHeader &&
            intMouseY <= intHeaderHeight
        ) {
            row = 'header';

        } else {
            intTop = intHeaderHeight;
            i = jsnRange.fromRecord;
            len = jsnRange.toRecord;
            while (i < len) {
                if (intMouseY >= intTop) {
                    row = i;
                } else {
                    break;
                }

                intTop += arrRecordHeights[i];
                intTop += intRowBorderHeight;
                i += 1;
            }

            if (bolInsertRecord && intMouseY >= intTop) {
                row = 'insert';
            }
        }

        return {
            "row": row,
            "column": column
        };
*/
    }

    // we need a way to compare the selection ranges, this function turns a
    //      selection range array into a string
    function selectionArrayToString(arr) {
        var i;
        var len;
        var strString;
        var jsnRange;

        strString = '';
        i = 0;
        len = arr.length;
        while (i < len) {
            jsnRange = arr[i];
            strString += (
                (
                    jsnRange.negator
                        ? 't'
                        : 'f'
                ) +
                String(jsnRange.start.column) +
                String(jsnRange.start.row) +
                String(jsnRange.end.column) +
                String(jsnRange.end.row)
            );

            i += 1;
        }

        return strString;
    }

    // Thanks SO User "Cambium"!
    function roundToNearestMultiple(intNum, intDivisor) {
        if (intNum > 0) {
            return Math.ceil(intNum / intDivisor) * intDivisor;
        }
        if (intNum < 0) {
            return Math.floor(intNum / intDivisor) * intDivisor;
        }

        return intDivisor;
    }

    // we have some tables that have automatic column widths, here we run
    //      the calculations
    function calculateAutoColumns(element) {
        var i;
        var len;
        var intWidthPool;
        var intTotalWidth;

        // the way the auto resizing works is that header cells with a
        //      "width" style set get a static width, the items with a
        //      min-width get a ratio. The static items get their
        //      amount of the width "pool". After the static items get
        //      their fill, the ratioed items get the rest of the width
        //      in their proportion.

        // for automatic column widths, we need to know the ratios of the column
        //      widths. These ratios are in relation to each other. This way,
        //      when we resize all of the columns to fit the width of the
        //      viewport, we'll be able to keep them the same relative width.
        //      So, we need to calculate the total width of all the columns.
        intTotalWidth = 0;
        i = 0;
        len = element.internalDisplay.columnWidths.length;
        while (i < len) {
            if (
                (
                    element.internalDisplay.setMinColumnWidths[i] ||
                    (
                        !element.internalDisplay.setMinColumnWidths[i] &&
                        !element.internalDisplay.setColumnWidths[i]
                    )
                ) &&
                // prevent hidden columns from getting a ratio
                element.internalDisplay.columnWidths[i] !== 0
            ) {
                intTotalWidth += (
                    element.internalDisplay.setMinColumnWidths[i] ||
                    element.internalDisplay.columnWidths[i] ||
                    0
                );
            } else {
                intTotalWidth += 0;
            }

            i += 1;
        }

        // calculate column ratios. These can only changed by manually re-sizing
        //      the columns.
        i = 0;
        len = element.internalDisplay.columnWidths.length;
        while (i < len) {
            // only columns with ratios get automatically resized. Only
            //      columns with min-width set get a ratio. Unless,
            //      nothing set at all. In which case, we use our detected
            //      width.
            if (
                (
                    element.internalDisplay.setMinColumnWidths[i] ||
                    (
                        !element.internalDisplay.setMinColumnWidths[i] &&
                        !element.internalDisplay.setColumnWidths[i]
                    )
                ) &&
                // prevent hidden columns from getting a ratio
                element.internalDisplay.columnWidths[i] !== 0
            ) {
                element.internalDisplay.columnRatios[i] = (
                    (
                        (
                            element.internalDisplay.setMinColumnWidths[i] ||
                            element.internalDisplay.columnWidths[i]
                        ) /
                        intTotalWidth
                    ) * 100
                );
            } else {
                element.internalDisplay.columnRatios[i] = 0;
            }

            i += 1;
        }

        // ultimately, we're going to try to fit the columns into
        //      the viewport
        intWidthPool = (
            element.elems.dataViewport.clientWidth
        );

        // remove some width and height from the viewport because
        //      some of it will be covered by the header, insert
        //      and selector cells
        intWidthPool -= (
            element.internalScrollOffsets.left +
            element.internalScrollOffsets.right
        );

        // get static widths, subtract them from width pool
        i = 0;
        len = element.internalDisplay.setColumnWidths.length;
        while (i < len) {
            // if this column has a set column, remove it's width from the
            //      available pool
            if (element.internalDisplay.setColumnWidths[i]) {
                intWidthPool -= (
                    // using columnWidths here because the width
                    //      may have been adjusted
                    element.internalDisplay.columnWidths[i]
                );
            }
            i += 1;
        }

        // every column adds a little bit of extra width for the border,
        //      take that from the pool (except for the last border, the
        //      table knows to ignore that last border)
        intWidthPool -= (element.internalDisplay.columnWidths.length - 1);

        // calculate stretchy columns
        i = 0;
        len = element.internalDisplay.columnRatios.length;
        while (i < len) {
            if (element.internalDisplay.columnRatios[i]) {
                element.internalDisplay.columnWidths[i] = (
                    // don't get smaller than min column width
                    Math.max(
                        intWidthPool / (
                            100 / element.internalDisplay.columnRatios[i]
                        ),
                        (
                            element.internalDisplay.setMinColumnWidths[i] ||
                            // if nothing is set on a column, use the
                            //      calculated min
                            element.internalDisplay.minColumnWidths[i]
                        )
                    )
                );
            }
            i += 1;
        }
    }

    function clearInsertRetainedValues(element) {
        // we clear the retained values and columns here because
        //      if the user decides to override the insert with
        //      their own thing, we don't want to still be showing
        //      the old values.
        element.internalData.insertRecord = {};
        element.internalData.insertRecordRetainedColumns = [];

        // re-render so that the insert controls clear out in the DOM
        element.internalDisplay.fullRenderRequired = true;
        //renderLocation(element);
        //element.goToLine('last');
    }

    // we need to split object names into schema and object
    function splitObjectName(strObject) {
        var arrParts;

        // split "src" into "schema" and "object" attributes
        arrParts = strObject.split('.');

        // I don't know who added this. I don't inderstand why someone
        //      would put something like "biz.bar.foo" in the "src"
        //      attribute. That's the case that this code handles. If
        //      you added this code: PUT A COMMENT!!!! We have comments
        //      for a reason. Don't ruin this beautiful code. Only YOU
        //      can prevent spaghetti code.
        //  ~Michael
        // It appears to be a solution to quote idented object names
        //      that contain a period like this: test."test.asdf"
        //      The problem with this (other than being unclear) is that
        //      it wont work for schema names that contain a period.
        //      We need a better solution for this. Perhaps it's time to
        //      create a function that understands ident quoted names
        //      for real, using actual parsing.
        //  ~Also Michael
        if (arrParts[2]) {
            arrParts[1] = arrParts[1] + '.' + arrParts[2];
        }

        return {
            "schema": arrParts[0],
            "object": arrParts[1]
        };
    }


// #############################################################################
// ############################# ELEMENT FUNCTIONS #############################
// #############################################################################

    // this section deals with the generation of the gs-table's non-cell HTML

    // some attributes can't be used in their normal, dev-friendly format,
    //      this function translates those attributes to their final formats
    // some attributes need to be defaulted, even if they're not present
    function resolveElementAttributes(element) {
        var jsnParts;
        var strSrc;

        // GS-TABLE elements that are connected to Envelope need to have "pk"
        //      and "lock" attributes
        if (element.getAttribute('src')) {
            strSrc = GS.templateWithQuerystring(element.getAttribute('src'));

            // if arbituary query
            if (strSrc.replace(/\s*/gi, '').indexOf('(SELECT') === 0) {
                // save query as is
                element.setAttribute('select-query', strSrc);

            // else, it's just a table/view name
            } else {
                // split "src" into "schema" and "object" attributes
                jsnParts = splitObjectName(strSrc);

                // put the split sections of the object name into separate
                //      attributes
                element.setAttribute('select-schema', jsnParts.schema);
                element.setAttribute('select-object', jsnParts.object);

                element.setAttribute('insert-schema', jsnParts.schema);
                element.setAttribute('insert-object', jsnParts.object);

                element.setAttribute('update-schema', jsnParts.schema);
                element.setAttribute('update-object', jsnParts.object);

                element.setAttribute('delete-schema', jsnParts.schema);
                element.setAttribute('delete-object', jsnParts.object);
            }

            // "insert-src" should always be a table or a view
            if (element.getAttribute('insert-src')) {
                // split into "schema" and "object" attributes
                jsnParts = splitObjectName(element.getAttribute('insert-src'));

                element.setAttribute('insert-schema', jsnParts.schema);
                element.setAttribute('insert-object', jsnParts.object);
            }

            // "update-src" should always be a table or a view
            if (element.getAttribute('update-src')) {
                // split into "schema" and "object" attributes
                jsnParts = splitObjectName(element.getAttribute('update-src'));

                element.setAttribute('update-schema', jsnParts.schema);
                element.setAttribute('update-object', jsnParts.object);
            }

            // "delete-src" should always be a table or a view
            if (element.getAttribute('delete-src')) {
                // split into "schema" and "object" attributes
                jsnParts = splitObjectName(element.getAttribute('delete-src'));

                element.setAttribute('delete-schema', jsnParts.schema);
                element.setAttribute('delete-object', jsnParts.object);
            }

            // default insert, update, and delete
            if (jsnParts) {
                if (!element.hasAttribute('insert-schema')) {
                    element.setAttribute('insert-schema', jsnParts.schema);
                    element.setAttribute('insert-object', jsnParts.object);
                }
                if (!element.hasAttribute('update-schema')) {
                    element.setAttribute('update-schema', jsnParts.schema);
                    element.setAttribute('update-object', jsnParts.object);
                }
                if (!element.hasAttribute('delete-schema')) {
                    element.setAttribute('delete-schema', jsnParts.schema);
                    element.setAttribute('delete-object', jsnParts.object);
                }
            }

            // if we're missing insert details, warn the developer
            if (
                !element.hasAttribute('insert-schema') ||
                !element.hasAttribute('insert-object')
            ) {
                console.warn(
                    'GS-TABLE Warning: Cannot figure out what object to ' +
                    'insert to, please add an "insert-src" attribute with the' +
                    ' view that needs to receive the insert commands.'
                );
            }

            // if we're missing update details, warn the developer
            if (
                !element.hasAttribute('update-schema') ||
                !element.hasAttribute('update-object')
            ) {
                console.warn(
                    'GS-TABLE Warning: Cannot figure out what object to ' +
                    'update, please add an "update-src" attribute with the' +
                    ' view that needs to receive the update commands.'
                );
            }

            // if we're missing delete details, warn the developer
            if (
                !element.hasAttribute('delete-schema') ||
                !element.hasAttribute('delete-object')
            ) {
                console.warn(
                    'GS-TABLE Warning: Cannot figure out what object to ' +
                    'delete from, please add a "delete-src" attribute with' +
                    ' the view that needs to receive the delete commands.'
                );
            }

            // default "pk" and "lock" attributes
            element.setAttribute(
                'pk',
                (element.getAttribute('pk') || 'id')
            );
            element.setAttribute(
                'lock',
                (element.getAttribute('lock') || 'change_stamp')
            );
        }

        // default null string attribute
        element.setAttribute(
            'null-string',
            (
                element.getAttribute('null-string') ||
                ''
            )
        );
    }

    // replace element HTML with the new HTML
    function prepareElement(element) {
        var rootElement;
        var i;

        // all gs-table elements must have an ID attribute
        if (!element.getAttribute('id')) {
            // loop through IDs using the ID sequence until we get to one
            //      that isn't used
            globalIDSeq += 1; // global to the gs-table x-tag definition scope
            i = 0;
            while (
                i < 500 &&
                tblElemByID('table-dynamic-id-' + globalIDSeq)
            ) {
                globalIDSeq += 1;
                i += 1;
            }

            element.setAttribute('id', 'table-dynamic-id-' + globalIDSeq);

            // warn the developer
            console.warn('GS-TABLE Warning: All gs-table elements must have' +
                    ' an ID. Adding dynamic ID:' +
                    ' "table-dynamic-id-' + globalIDSeq + '". Do not use' +
                    ' this ID for anything. Do not use it for HTML, CSS or' +
                    ' JS or anything else as it can change between page' +
                    ' loads.');
        }

        // the root is created as a variable so that we can append it to the
        //      gs-table without destrying the templates because the next step
        //      of this element's initalization is the "siphon" (where we
        //      extract the info out of the templates)
        rootElement = document.createElement('div');
        rootElement.classList.add('table-root');
        element.appendChild(rootElement);

        // create standard gs-table html
        rootElement.innerHTML =
                // we need a container to hold the HUD, this container will be
                //      absolutely positioned to the top of the gs-table
                '<div class="table-hud-container hud-top"></div>' +
                // we need a container to hold the viewport container and the
                //      scrollbars
                '<div class="table-table-container">' +
                // we need a container for the viewport that will automatically
                //      size the viewport correctly
                '    <div class="table-data-container">' +
                // we need a viewport that will hide anything that doesn't fit
                //      and won't scroll. the scrolling will be handled by the
                //      renderer.
                '        <div class="table-data-viewport"></div>' +
                '    </div>' +
                '    <div class="table-v-scroll-bar-container">' +
                '        <div class="table-v-scroll-bar">' +
                '            <div class="table-scroll-causer"></div>' +
                '        </div>' +
                '    </div>' +
                '    <div class="table-h-scroll-bar-container">' +
                '        <div class="table-h-scroll-bar">' +
                '            <div class="table-scroll-causer"></div>' +
                '        </div>' +
                '    </div>' +
                '</div>' +
                // we need a textarea that is hidden so that we can intercept
                //      keyboard events even if none of the controls have been
                //      focused into. one case where this occurs is when you
                //      select a range of cells, when selecting a range you
                //      don't want one of the cells to be focused, and yet, you
                //      want to be able to press "delete" and delete the
                //      records.
                // we also need a dependable focus target for when we handle
                //      copy/paste events.
                // this control also need to be after the rest of the cells to
                //      make tabbing out of the gs-table easier to code. to tab
                //      out we'll just have to not prevent default
                '<textarea class="hidden-focus-control"' +
                '    value="text makes this textarea Firefox worthy">' +
                '</textarea>' +
                // we need a static container to hold our loader elements
                '<div class="table-loader-container"></div>' +
                // we need a place to hold an example of each type of cell so
                //      that we can read their style dynamically without causing
                //      a "Forced Reflow", this will be a speed benefit
                '<div class="table-cell-test-container">' +
                '    <gs-cell class="table-cell"></gs-cell>' +
                '    <gs-cell class="table-header"></gs-cell>' +
                '    <gs-cell class="table-insert"></gs-cell>' +
                '    <gs-cell class="table-record-selector"></gs-cell>' +
                '</div>' +
                // we need a container to hold the HUD, this container will be
                //      absolutely positioned to the bottom of the gs-table
                '<div class="table-hud-container hud-bottom"></div>' +
                // we need a style tag for dynamic CSS, MS Edge is slow when it
                //      comes to changing style attributes for a bunch of cells,
                //      we're going to try not using style attributes and
                //      instead using a dynamic CSS style element
                // if it doesn't speed up Edge we may still come up with a new
                //      use for it so keep it around
                '<style class="cell-position" style="display:none;"></style>' +
                // we need to know when the font size changes so that we can
                //      re-render. this element will always be 1em wide and 1em
                //      tall. when this element changes pixel size, we'll know
                //      that the font size has changed.
                '<div class="table-font-size-detector"></div>';

        // we want to easily/quickly be able to get elements without
        //      using selectors
        element.elems = {};

        element.elems.root = rootElement;

        element.elems.topHudContainer = element.elems.root.children[0];
        element.elems.tableViewport = element.elems.root.children[1];
        element.elems.hiddenFocusControl = element.elems.root.children[2];
        element.elems.loaderContainer = element.elems.root.children[3];
        element.elems.cellTestContainer = element.elems.root.children[4];
        element.elems.bottomHudContainer = element.elems.root.children[5];
        element.elems.cellPositionStyle = element.elems.root.children[6];
        element.elems.fontSizeDetector = element.elems.root.children[7];

        element.elems.dataContainer =
                element.elems.tableViewport.children[0];
        element.elems.yScrollContainer =
                element.elems.tableViewport.children[1];
        element.elems.xScrollContainer =
                element.elems.tableViewport.children[2];

        element.elems.dataViewport = element.elems.dataContainer.children[0];

        element.elems.yScrollBar = element.elems.yScrollContainer.children[0];
        element.elems.xScrollBar = element.elems.xScrollContainer.children[0];
        element.elems.yScrollBarCauser = element.elems.yScrollBar.children[0];
        element.elems.xScrollBarCauser = element.elems.xScrollBar.children[0];

        element.elems.testDataCell = (
            element.elems.cellTestContainer.children[0]
        );
        element.elems.testHeader = (
            element.elems.cellTestContainer.children[1]
        );
        element.elems.testInsert = (
            element.elems.cellTestContainer.children[2]
        );
        element.elems.testRecordSelector = (
            element.elems.cellTestContainer.children[3]
        );

        // because the resize handles aren't always in the DOM, we'll create
        //      them virtually and store them
        element.elems.handleColumn = document.createElement('div');
        element.elems.handleColumn.classList.add('resize-column-handle');
        element.elems.handleRecord = document.createElement('div');
        element.elems.handleRecord.classList.add('resize-record-handle');

        // because the reorder indicator isn't always in the DOM, we'll create
        //      it virtually and store them
        element.elems.handleReorder = document.createElement('div');
        element.elems.handleReorder.classList.add('reorder-column-handle');

        // sometimes, we want to open a dialog to a particular pixel instead
        //      of a particular element. so, we'll create an element what for
        //      putting it at a particular pixel an then just use the
        //      standard openDialogToElement function.
        element.elems.pixel = document.createElement('div');
        element.elems.pixel.classList.add('pixel-element');
        element.elems.root.appendChild(element.elems.pixel);

        // we want a place to look to for data
        element.internalData = {
            "records": [],
            "columnFilterStatuses": [],
            "columnFilters": [],
            "columnListFilters": [],
            "columnOrders": [],
            "columnNames": [],
            "columnTypes": [],
            "insertRecord": {},
            "insertRecordRetainedColumns": [],
            "bolFirstLoadFinished": false,
            "bolInserting": false
        };

        // we need to be able to make room for fixed objects when scrolling
        //      (like the fixed headers), so we'll define these properties
        //      so that we have a single place to look for them
        element.internalScrollOffsets = {
            "top": 0,
            "bottom": 0,
            "left": 0,
            "right": 0
        };

        // we need a place to store event functions because, to unbind a
        //      specific event javascript requires that you have the
        //      original function that was bound to that event
        element.internalEvents = {
            "forceCopy": false
        };

        // some events are triggered by something that the gs-table does,
        //      so event code needs to have a place to look to see if
        //      it's been cancelled for one execution
        element.internalEventCancelled = {
            "scrollbarY": false,
            "scrollbarX": false
        };

        // we need to manually store the scroll location somewhere because
        //      scrollbars can only cover so much area before breaking
        element.internalScroll = {
            "top": 0,
            "left": 0,
            "maxTop": 0,
            "maxLeft": 0,
            "displayTop": 0,
            "displayLeft": 0,
            "prevTop": 0,
            "prevLeft": 0
        };

        // we need to manually store timer IDs so that we can do throttling
        element.internalTimerIDs = {
            "scrollIntervalID": null,
            "visibilityIntervalID": null
        };

        // we need a place to store our templates, so we'll create an
        //      element.internalTemplates JSON object and store each
        //      template under a unique name
        element.internalTemplates = {
            "topHUD": "",
            "bottomHUD": "",
            "header": "",
            "originalRecord": "",
            "record": {},
            "insertRecord": "",
            "insertDialog": "",
            "updateDialog": ""
        };

        // we need a place to store cell dimensions and other display
        //      related info
        // anything in here set to "undefined" is set that way because the dev
        //      may set it to 0 or [] and we need to be able to tell that it
        //      hasn't been set yet
        element.internalDisplay = {
            "columnPlainTextNames": [],
            "dataColumnName": [],

            "columnWidths": [],
            "columnRatios": [],

            "setColumnWidths": [],
            "setMinColumnWidths": [],
            "setMaxColumnWidths": [],
            "minColumnWidths": [],
            "maxColumnWidth": 999,

            "recordHeights": [],
            "maxRecordHeight": 999,

            "columnHandles": [],
            "recordHandles": [],

            "currentRange": {},
            "prevRange": {},

            // not used yet, null will mean "doesn't stick".
            //      only "top", "bottom" and null allowed.
            "headerStick": "top",

            "headerVisible": false,
            "headerHeight": undefined,
            "headerBorderHeight": 0,

            // not used yet, null will mean "doesn't stick".
            //      only "left", "right" and null allowed.
            "selectorStick": "left",

            "recordSelectorVisible": false,
            "recordSelectorWidth": 0,
            "recordSelectorBorderWidth": 0,

            // only "top", "bottom" and null allowed.
            "insertRecordStick": null, //"bottom"

            "insertRecordVisible": false,
            "insertRecordHeight": undefined,
            "insertRecordBorderHeight": 0,

            "fullRenderRequired": true,

            "defaultColumnWidths": [],
            "defaultColumnWidth": 0,
            "defaultRecordHeight": 0,
            "defaultRecordSelectorWidth": 27,
            "defaultHeaderHeight": 27,
            "defaultInsertRecordHeight": 27,

            "focus": {
                "column": null,
                "row": null,
                "nodeName": null,
                "columnAttribute": null,
                "latest": null,
                "selectionRange": {}
            }
        };

        // we need to default the record selector width
        element.internalDisplay.recordSelectorWidth = (
            element.internalDisplay.defaultRecordSelectorWidth
        );

        // we need a place to store selection ranges
        element.internalSelection = {
            "ranges": [],
            "rangeCache": null,
            "insertRecord": false,
            "originRecord": null,
            "resolvedSelection": [],
            "columns": [],
            "rows": [],
            "currentlySelecting": false
        };

        // we need a place to store the parameters for copy
        element.internalClip = {
            "columnList": [],
            "headerList": []
        };

        // we need a place to store the web worker and it's
        //      associated data
        element.internalWorker = {
            "worker": "",
            "ready": false
        };

        // we need a place to store the loader data
        element.internalLoaders = {
            "loaderIDs": [],
            "loaderElements": []
        };

        // we need a place to store info for column resizing
        element.internalResize = {
            "currentlyResizing": false,
            "showThrottleID": null,
            "resizeStarted": false,
            "cellOriginX": 0,
            "cellOriginY": 0,

            "resizeColumn": false,
            "resizeRecord": false,

            "resizeColumnHandleIndex": 0,
            "resizeRecordHandleIndex": 0,

            "resizeColumnIndex": null,
            "resizeRecordIndex": null,

            "resizingRecordSelectors": false,
            "resizingHeader": false,
            "resizingInsert": false,

            "scrollOriginTop": null,
            "scrollOriginLeft": null,

            "lastX": 0,
            "lastY": 0,
            "lastWidth": 0,
            "lastHeight": 0
        };

        // we need a place to store info for column reorder
        element.internalReorder = {
            "currentlyReordering": false,
            "reorderStarted": false,
            "currentColumns": [],
            "dropLocation": 0,
            "scrollIntervalID": null,
            "scrollDirection": null,
            "scrolling": false,
            "originColumn": null
        };

        // we need a place to cache visibility information so that if we
        //      detect a change, we can trigger a re-render
        element.internalPollingCache = {
            "elementWidth": null,
            "elementHeight": null,
            "elementVisibility": null,
            "fontSize": null
        };

        // we want to know the cell dimensions so that we can make elements
        //      default and so that scrolling will reflect the correct
        //      dimensions, so we'll detect them here (and during scroll
        //      location renders)
        cellDimensionDetector(element);
    }

    // get a gs-table's templates and translate them for future templating
    function siphonElement(element) {
        var topHudTemplate;
        var bottomHudTemplate;
        var headerTemplate;
        var dataTemplate;
        var copyTemplate;
        var insertRWTemplate;
        var insertDialogTemplate;
        var updateDialogTemplate;
        var arrColumnCounts;

        var strHTML;
        var arrColumnPlainTextNames;
        var arrColumnDataNames;
        var arrColumnElements;
        var columnElement;
        var intColumnWidth;
        var intColumnMinWidth;
        var buttonElement;
        var i;
        var len;
        var strWidth;

        // get each template element and save them to each their own variable,
        //      for easy access
        topHudTemplate = tblQryKids(element, '[for="top-hud"]')[0];
        bottomHudTemplate = tblQryKids(element, '[for="bottom-hud"]')[0];
        headerTemplate = tblQryKids(element, '[for="header-record"]')[0];
        dataTemplate = tblQryKids(element, '[for="data-record"]')[0];
        copyTemplate = tblQryKids(element, '[for="copy"]')[0];
        insertRWTemplate = tblQryKids(element, '[for="insert-record"]')[0];
        insertDialogTemplate = tblQryKids(element, '[for="insert-dialog"]')[0];
        updateDialogTemplate = tblQryKids(element, '[for="update-dialog"]')[0];

        // remove all templates from the dom to prevent reflows
        if (topHudTemplate) {
            element.removeChild(topHudTemplate);
        }
        if (bottomHudTemplate) {
            element.removeChild(bottomHudTemplate);
        }
        if (headerTemplate) {
            element.removeChild(headerTemplate);
        }
        if (dataTemplate) {
            element.removeChild(dataTemplate);
        }
        if (copyTemplate) {
            element.removeChild(copyTemplate);
        }
        if (insertRWTemplate) {
            element.removeChild(insertRWTemplate);
        }
        if (insertDialogTemplate) {
            element.removeChild(insertDialogTemplate);
        }
        if (updateDialogTemplate) {
            element.removeChild(updateDialogTemplate);
        }

        if (
            topHudTemplate &&
            (
                topHudTemplate.innerHTML.indexOf('&gt;') > -1 ||
                topHudTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn(
                'GS-TABLE WARNING: &gt; or &lt; detected in ' +
                'top HUD template, this can have undesired ' +
                'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                'lt(x,y), or lte(x,y) to silence this warning.'
            );
        }
        if (
            bottomHudTemplate &&
            (
                bottomHudTemplate.innerHTML.indexOf('&gt;') > -1 ||
                bottomHudTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn(
                'GS-TABLE WARNING: &gt; or &lt; detected in ' +
                'bottom HUD template, this can have undesired ' +
                'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                'lt(x,y), or lte(x,y) to silence this warning.'
            );
        }
        if (
            headerTemplate &&
            (
                headerTemplate.innerHTML.indexOf('&gt;') > -1 ||
                headerTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn(
                'GS-TABLE WARNING: &gt; or &lt; detected in ' +
                'header record template, this can have undesired ' +
                'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                'lt(x,y), or lte(x,y) to silence this warning.'
            );
        }
        if (
            dataTemplate &&
            (
                dataTemplate.innerHTML.indexOf('&gt;') > -1 ||
                dataTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn(
                'GS-TABLE WARNING: &gt; or &lt; detected in ' +
                'data record template, this can have undesired ' +
                'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                'lt(x,y), or lte(x,y) to silence this warning.'
            );
        }
        if (
            copyTemplate &&
            (
                copyTemplate.innerHTML.indexOf('&gt;') > -1 ||
                copyTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn(
                'GS-TABLE WARNING: &gt; or &lt; detected in ' +
                'copy template, this can have undesired ' +
                'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                'lt(x,y), or lte(x,y) to silence this warning.'
            );
        }
        if (
            insertRWTemplate &&
            (
                insertRWTemplate.innerHTML.indexOf('&gt;') > -1 ||
                insertRWTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn(
                'GS-TABLE WARNING: &gt; or &lt; detected in ' +
                'insert record template, this can have undesired ' +
                'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                'lt(x,y), or lte(x,y) to silence this warning.'
            );
        }
        if (
            insertDialogTemplate &&
            (
                insertDialogTemplate.innerHTML.indexOf('&gt;') > -1 ||
                insertDialogTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn(
                'GS-TABLE WARNING: &gt; or &lt; detected in ' +
                'insert dialog template, this can have undesired ' +
                'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                'lt(x,y), or lte(x,y) to silence this warning.'
            );
        }
        if (
            updateDialogTemplate &&
            (
                updateDialogTemplate.innerHTML.indexOf('&gt;') > -1 ||
                updateDialogTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn(
                'GS-TABLE WARNING: &gt; or &lt; detected in ' +
                'update dialog template, this can have undesired ' +
                'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                'lt(x,y), or lte(x,y) to silence this warning.'
            );
        }

        // if there's no "data-record" template: error
        if (!dataTemplate) {
            throw 'GS-TABLE Error: no "data-record" template found. ' +
                    'The "data-record" must be a immediate child in ' +
                    'order to be found.';
        }

        // if there's no "data-record" template: warn
        if (!copyTemplate && !element.hasAttribute('no-copy')) {
            console.warn('GS-TABLE Warning: no "copy" template found. ' +
                    'The "copy" template enables copying a selection ' +
                    'from the gs-table. The "copy" template must be a ' +
                    'immediate child in order to be found.');
        }

        // check for column number differences. All record templates should
        //      have the same number of columns. Error intelligently.
        arrColumnCounts = [];

        if (headerTemplate && headerTemplate.innerHTML.trim()) {
            arrColumnCounts.push({
                "template": "header-record",
                "count": tblQry(headerTemplate.content, 'gs-cell').length
            });
        }
        if (insertRWTemplate && insertRWTemplate.innerHTML.trim()) {
            arrColumnCounts.push({
                "template": "insert-record",
                "count": tblQry(
                    insertRWTemplate.content,
                    'gs-cell'
                ).length
            });
        }
        if (copyTemplate && copyTemplate.innerHTML.trim()) {
            arrColumnCounts.push({
                "template": "copy",
                "count": tblQry(copyTemplate.content, 'gs-cell').length
            });
        }
        if (dataTemplate && dataTemplate.innerHTML.trim()) {
            arrColumnCounts.push({
                "template": "data-record",
                "count": tblQry(dataTemplate.content, 'gs-cell').length
            });
        }

        i = 0;
        len = arrColumnCounts.length;
        while (i < len) {
            if (i > 0) {
                if (arrColumnCounts[i].count !== arrColumnCounts[i - 1].count) {
                    throw (
                        'GS-TABLE Error: ' +
                        'Template "' + arrColumnCounts[i].template + '" ' +
                        'has ' + arrColumnCounts[i].count + ' cells, while "' +
                        arrColumnCounts[i - 1].template + '" template has ' +
                        arrColumnCounts[i - 1].count + ' cells. Templates ' +
                        'need to have the same number of cells.'
                    );
                }
            }

            i += 1;
        }

        // get column widths. We build all array width arrays here, because this
        //      code will reach into the first available template for the data.
        //      Other loops look at a particular template that may or may not be
        //      available. So, this will set the defaults and whatever it can
        //      get it's hands on, while later loops will get more accurate
        //      information if it's available.
        if (headerTemplate || dataTemplate || insertRWTemplate) {
            if (headerTemplate) {
                arrColumnElements = tblQry(headerTemplate.content, 'gs-cell');
            } else if (dataTemplate) {
                arrColumnElements = tblQry(dataTemplate.content, 'gs-cell');
            } else if (insertRWTemplate) {
                arrColumnElements = tblQry(insertRWTemplate.content, 'gs-cell');
            }

            intColumnWidth = (
                parseInt(element.getAttribute('default-cell-width'), 10) ||
                intDefaultColumnWidth
            );
            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                strWidth = arrColumnElements[i].style.width;

                element.internalDisplay.columnWidths.push(
                    (
                        arrColumnElements[i].style.width
                            ? GS.sizeToPx(element, strWidth)
                            : NaN
                    ) ||
                    intColumnWidth
                );

                // we need to be able to restore the column widths after the
                //      user resizes them, so this array contains the column
                //      widths and cannot be updated by column resizing
                element.internalDisplay.defaultColumnWidths.push(
                    (
                        arrColumnElements[i].style.width
                            ? GS.sizeToPx(element, strWidth)
                            : NaN
                    ) ||
                    intColumnWidth
                );

                // we need spaces available for column width ratios
                element.internalDisplay.columnRatios.push(null);

                // we want to retain the developer's declared width settings
                element.internalDisplay.setColumnWidths.push(
                    arrColumnElements[i].style.width
                        ? GS.sizeToPx(element, strWidth)
                        : NaN
                );
                element.internalDisplay.setMinColumnWidths.push(
                    (
                        arrColumnElements[i].style.minWidth
                            ? GS.sizeToPx(element, arrColumnElements[i].style.minWidth)
                            : NaN
                    )
                );
                element.internalDisplay.setMaxColumnWidths.push(
                    (
                        arrColumnElements[i].style.maxWidth
                            ? GS.sizeToPx(element, arrColumnElements[i].style.maxWidth)
                            : NaN
                    )
                );

                // fill the minimum column widths with the default. If there's a
                //      header template we'll reset any items based on content,
                //      later.
                element.internalDisplay.minColumnWidths.push(
                    element.internalDisplay.setMinColumnWidths[i] ||
                    intColumnWidth ||
                    0
                );

                // if there is a width, remove it. we do this because the width
                //      is added dynamically when the header is rendered. if
                //      someone resizes a cell, we need to set the width with
                //      the new value
                // we don't need width styles anymore
                arrColumnElements[i].style.minWidth = '';
                arrColumnElements[i].style.maxWidth = '';
                arrColumnElements[i].style.width = '';

                i += 1;
            }
        }

        // get header height
        if (headerTemplate) {
            arrColumnElements = tblQry(headerTemplate.content, 'gs-cell');
            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                // if we run into a column with a height defined, use that
                //      height for the header height and break out of the loop
                if (arrColumnElements[i].style.height) {
                    element.internalDisplay.headerHeight = (
                        parseInt(arrColumnElements[i].style.height, 10)
                    );
                }
                i += 1;
            }

            // default
            if (element.internalDisplay.headerHeight === undefined) {
                element.internalDisplay.headerHeight = (
                    element.internalDisplay.defaultHeaderHeight
                );
            }
        }

        // get insert record height
        if (insertRWTemplate) {
            arrColumnElements = tblQry(insertRWTemplate.content, 'gs-cell');
            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                // if we run into a column with a height defined, use that
                //      height for the header height and break out of the loop
                if (arrColumnElements[i].style.height) {
                    element.internalDisplay.insertRecordHeight = (
                        parseInt(arrColumnElements[i].style.height, 10)
                    );
                }
                i += 1;
            }

            // default to 27 pixels
            if (element.internalDisplay.insertRecordHeight === undefined) {
                element.internalDisplay.insertRecordHeight = (
                    element.internalDisplay.defaultInsertRecordHeight
                );
            }
        }

        // get plain text column names
        arrColumnPlainTextNames = [];

        // if there is a copy template and we still haven't found
        //      plain text column names
        if (
            copyTemplate && (
                arrColumnPlainTextNames.length === 0 ||
                arrColumnPlainTextNames.indexOf(null) !== -1
            )
        ) {
            arrColumnElements = tblQry(copyTemplate.content, 'gs-cell');
            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                if (!arrColumnPlainTextNames[i]) {
                    arrColumnPlainTextNames[i] = (
                        // if there's no header attribute, we'll set the
                        //      column name to null
                        arrColumnElements[i].getAttribute('header')
                    );
                }
                i += 1;
            }
        }

        // if there is a record template and we still haven't found
        //      plain text column names
        if (
            dataTemplate && (
                arrColumnPlainTextNames.length === 0 ||
                arrColumnPlainTextNames.indexOf(null) !== -1
            )
        ) {
            arrColumnElements = tblQry(dataTemplate.content, 'gs-cell');
            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                if (!arrColumnPlainTextNames[i]) {
                    arrColumnPlainTextNames[i] = (
                        // if there's no header attribute, we'll set the
                        //      column name to null
                        arrColumnElements[i].getAttribute('header')
                    );
                }
                i += 1;
            }
        }

        // if there is an insert record template and we still haven't
        //      found plain text column names
        if (
            insertRWTemplate && (
                arrColumnPlainTextNames.length === 0 ||
                arrColumnPlainTextNames.indexOf(null) !== -1
            )
        ) {
            arrColumnElements = tblQry(insertRWTemplate.content, 'gs-cell');
            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                if (!arrColumnPlainTextNames[i]) {
                    arrColumnPlainTextNames[i] = (
                        // if there's no header attribute, we'll set the
                        //      column name to null
                        arrColumnElements[i].getAttribute('header')
                    );
                }
                i += 1;
            }
        }

        // if there is a header template and we still haven't found
        //      plain text column names
        if (
            headerTemplate && (
                arrColumnPlainTextNames.length === 0 ||
                arrColumnPlainTextNames.indexOf(null) !== -1
            )
        ) {
            arrColumnElements = tblQry(headerTemplate.content, 'gs-cell');

            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                if (!arrColumnPlainTextNames[i]) {
                    arrColumnPlainTextNames[i] = (
                        // if there's no text, we'll set the
                        //      column name to null
                        arrColumnElements[i].textContent.trim() || null
                    );
                }
                i += 1;
            }
        }

        // store plain text column names for future use
        element.internalDisplay.columnPlainTextNames = arrColumnPlainTextNames;



        // we need to associate the display columns with their associated data
        //      columns
        arrColumnDataNames = [];

        // if there is an insert record template and we still haven't
        //      all of the found data column associations
        if (
            insertRWTemplate && (
                arrColumnDataNames.length === 0 ||
                arrColumnDataNames.indexOf(null) !== -1
            )
        ) {
            arrColumnElements = tblQry(insertRWTemplate.content, 'gs-cell');
            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                if (!arrColumnDataNames[i]) {
                    columnElement = tblQry(
                        arrColumnElements[i],
                        '[column]'
                    )[0];

                    if (columnElement) {
                        arrColumnDataNames[i] = (
                            // if there's no column attribute, we'll set the
                            //      column name to null
                            columnElement.getAttribute('column')
                        );
                    } else {
                        arrColumnDataNames[i] = null;
                    }
                }
                i += 1;
            }
        }

        // if there is an insert record template and we still haven't
        //      all of the found data column associations
        if (
            dataTemplate && (
                arrColumnDataNames.length === 0 ||
                arrColumnDataNames.indexOf(null) !== -1
            )
        ) {
            arrColumnElements = tblQry(dataTemplate.content, 'gs-cell');
            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                if (!arrColumnDataNames[i]) {
                    columnElement = tblQry(
                        arrColumnElements[i],
                        '[column]'
                    )[0];

                    if (columnElement) {
                        arrColumnDataNames[i] = (
                            // if there's no column attribute, we'll set the
                            //      column name to null
                            columnElement.getAttribute('column')
                        );
                    } else {
                        arrColumnDataNames[i] = null;
                    }
                }
                i += 1;
            }
        }

        // store our associations internally
        element.internalDisplay.dataColumnName = arrColumnDataNames;

        // if present, siphon "top-hud" template
        if (topHudTemplate) {
            element.internalTemplates.topHUD = topHudTemplate.innerHTML;
        }

        // if present, siphon "bottom-hud" template
        if (bottomHudTemplate) {
            element.internalTemplates.bottomHUD = bottomHudTemplate.innerHTML;
        }

        // the header template (if there is one) needs dropdown buttons for
        //      the column dropdown
        if (
            headerTemplate &&
            !element.hasAttribute('no-column-dropdown') &&
            !evt.touchDevice
        ) {
            // create the button element so we can clone it
            buttonElement = document.createElement('div');

            // loop through cells and append buttons
            arrColumnElements = tblQry(headerTemplate.content, 'gs-cell');
            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                // a column only get's a column button if there is a data
                //      column associated with that column
                if (arrColumnDataNames[i]) {
                    buttonElement.setAttribute(
                        'class',
                        'header-button ' +
                                '$$HDRBTNCLASS_' + arrColumnDataNames[i] + '$$'
                    );

                    arrColumnElements[i].classList.add('right-button');
                    //console.log(arrColumnElements[i]);
                    // arrColumnElements[i].setAttribute('alt');
                    arrColumnElements[i].appendChild(
                        buttonElement.cloneNode(true)
                    );
                }
                i += 1;
            }
        }

        // if a display column is associated with a data column, we want
        //      to have sort and filter related info in the tooltip
        if (headerTemplate) {
            // loop through header cells and add tokens to the title
            //      attributes
            arrColumnElements = tblQry(headerTemplate.content, 'gs-cell');
            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                // a column only get's a column button if there is a data
                //      column associated with that column
                if (arrColumnDataNames[i]) {
                    arrColumnElements[i].setAttribute(
                        'title',
                        '$$HDR_TITLE_' + arrColumnDataNames[i] + '$$'
                    );
                }
                i += 1;
            }
        }

        // if there is a header template, get column min widths
        if (headerTemplate) {
            arrColumnElements = tblQry(headerTemplate.content, 'gs-cell');
            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                // all of these values are tested in the test header
                //      element, this element is in a different location
                //      so the CSS that the user sets may not apply to
                //      it. we need to transition to a temporary cell
                //      element in the viewport
                // ### NEED CODING ###

                // get text width using test header element
                element.elems.testHeader.innerHTML = (
                    arrColumnElements[i].innerHTML
                );

                // if there's a min-width set on the gs-cell, we'll use it
                //      for the column resize min width
                intColumnMinWidth = (
                    element.internalDisplay.setMinColumnWidths[i]
                );

                intColumnWidth = (
                    //GS.getTextWidth(
                    //    element.elems.testHeader,
                    //    arrColumnElements[i].textContent,
                    //    true // preserve whitespace
                    //) +

                    element.elems.testHeader.offsetWidth +
                    // for some reason, a few pixels are missing
                    3
                );
                if (element.elems.testHeader.offsetWidth === 0) {
                    intColumnWidth = (
                        7 + GS.getTextWidth(
                            element.elems.testHeader,
                            arrColumnElements[i].textContent,
                            true // preserve whitespace
                        ) + 7 +
                        // for some reason, a few pixels are missing
                        3
                    );

                    element.elems.testHeader.style.width = (
                        intColumnWidth + 'px'
                    );
                }
                element.elems.testHeader.innerHTML = '';

                // if there is a data column associated and we don't have column
                //      filter/sort dropdowns turned off, we need to add the
                //      width of the header button
                if (
                    arrColumnDataNames[i] &&
                    !element.hasAttribute('no-column-dropdown')
                ) {
                    intColumnWidth += (
                        // em value is hard coded for now
                        GS.emToPx(element.elems.testHeader, 1.25)
                    );
                }

                element.internalDisplay.minColumnWidths[i] = (
                    intColumnMinWidth ||
                    intColumnWidth
                );

                if (
                    intColumnWidth &&
                    intColumnWidth >
                        element.internalDisplay.columnWidths[i]
                ) {
                    element.internalDisplay.columnWidths[i] = (
                        intColumnWidth
                    );
                }

                i += 1;
            }
        }

        // remove any styling css that might affect cell sizing
        if (dataTemplate) {
            arrColumnElements = tblQry(dataTemplate.content, 'gs-cell');
            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                // if there is a width, remove it. we do this because the width
                //      is added dynamically when the header is rendered. if
                //      someone resizes a cell, we need to set the width with
                //      the new value
                arrColumnElements[i].style.minWidth = '';
                arrColumnElements[i].style.maxWidth = '';
                arrColumnElements[i].style.width = '';
                i += 1;
            }
        }

        // if present, siphon "header-record" template
        if (headerTemplate) {
            // commented out because we no longer put the styling on the cell
            //// append a token to the end of the style attribute of each
            ////      gs-cell (so that we can dynamically add CSS definitions)
            //templateCellAddStyleToken(headerTemplate);

            // add a class of "table-header" to each gs-cell for styling
            templateCellAddClass(headerTemplate, 'table-header');

            // add column numbers to the header cells so that we can target
            //      these cells using column precision
            templateCellAddColumnNumber(headerTemplate);

            // save the template
            element.internalTemplates.header = (
                headerTemplate.innerHTML.trim()
            );

            //// remove the template element now that it's been siphoned
            //element.removeChild(headerTemplate);
        }

        // if present, siphon "data-record" template
        if (dataTemplate) {
            // commented out because we no longer put the styling on the cell
            //// append a token to the end of the style attribute of each
            ////      gs-cell (so that we can dynamically add CSS definitions)
            //templateCellAddStyleToken(dataTemplate);

            // add a class of "table-cell" to each gs-cell for styling
            templateCellAddClass(dataTemplate, 'table-cell');

            // add column numbers to the record cells so that we can target
            //      these cells using column precision
            templateCellAddColumnNumber(dataTemplate);

            // add a record number attribute on each of the cells so that we can
            //      target specific records for deletion, rerender, movement
            //      etc...
            templateCellAddRowNumber(dataTemplate);

            // save the template
            strHTML = GS.templateColumnToValue(
                dataTemplate.innerHTML.trim()
            );

            // let's save the original record template text so that we can
            //      modify it in the future
            element.internalTemplates.originalRecord = strHTML;

            // we're going run the record template through a function to
            //      turn all of the "column" attributes into "value" attributes
            //      with the proper templating
            element.internalTemplates.record = (
                GS.templateHideSubTemplates(strHTML, false)
            );

            //// remove the template element now that it's been siphoned
            //element.removeChild(dataTemplate);
        }

        // if present, siphon "copy" template
        if (copyTemplate) {
            // we want to save the copy template so that we'll always have
            //      access to it's original innerHTML (right now, only for
            //      debugging purposes)
            element.internalTemplates.copy = (
                copyTemplate.innerHTML
            );

            // determine the record copy columns from the "copy" template
            //      so that we can use them when we copy and we need to get data
            templateDetermineCopyColumnList(element, copyTemplate);

            // determine the copy headers from the "copy" template so
            //      that we can use them for when we copy and we need to use
            //      the headers
            templateDetermineCopyHeaderList(element, copyTemplate);

            //// remove the template element now that it's been siphoned
            //element.removeChild(copyTemplate);
        }

        // if present, siphon "insert-record" template
        if (insertRWTemplate) {
            // commented out because we no longer put the styling on the cell
            //// append a token to the end of the style attribute of each
            ////      gs-cell (so that we can dynamically add CSS definitions)
            //templateCellAddStyleToken(insertRWTemplate);

            // add a class of "table-insert" to each gs-cell for styling
            templateCellAddClass(insertRWTemplate, 'table-insert');

            // add column numbers to the insert cells so that we can target
            //      these cells using column precision
            templateCellAddColumnNumber(insertRWTemplate);

            // add row attributes so that the javascript can look at the cell
            //      and determine that it's an "insert" type cell
            templateCellAddRowNumber(insertRWTemplate, 'insert');

            // get HTML
            strHTML = insertRWTemplate.innerHTML.trim();

            // let's save the original record template text so that we can
            //      modify it in the future
            element.internalTemplates.originalInsertRecord = strHTML;

            // we're going run the record template through a function to prep it
            //      for templating (so we don't mess up inner templates, like
            //      comboboxes and such)
            element.internalTemplates.insertRecord = (
                GS.templateHideSubTemplates(strHTML, false)
            );

            //// remove the template element now that it's been siphoned
            //element.removeChild(insertRWTemplate);
        }

        // if present, siphon "insert-dialog" template
        if (insertDialogTemplate) {
            element.internalTemplates.insertDialog = (
                insertDialogTemplate.innerHTML.trim()
            );

            //// remove the template element now that it's been siphoned
            //element.removeChild(insertDialogTemplate);
        }

        // if present, siphon "update-dialog" template
        if (updateDialogTemplate) {
            // save the template
            strHTML = GS.templateColumnToValue(
                updateDialogTemplate.innerHTML.trim()
            );

            // let's save the original dialog template text so that we can
            //      modify it in the future
            element.internalTemplates.originalUpdateDialog = strHTML;

            // we're going run the dialog template through a function to
            //      turn all of the "column" attributes into "value" attributes
            //      with the proper templating
            element.internalTemplates.updateDialog = (
                GS.templateHideSubTemplates(strHTML, false)
            );

            //// remove the template element now that it's been siphoned
            //element.removeChild(updateDialogTemplate);
        }
    }

    // we need to use a web worker so that we can move processor expensive
    //      operations to another thread so that we dont freeze the UI
    function createWebWorker(element) {
        //var waitingFunction;
        //var handlerFunction;

        //// if no web worker support: throw error so that the developer knows
        ////      that the gs-table element requires web workers
        //if (window.Worker === undefined) {
        //    throw 'GS-TABLE Error: Web Workers are not supported by this ' +
        //            'browser. The GS-TABLE element requires the use of a ' +
        //            'Web Worker.';
        //}

        //// get web worker and store it
        //element.internalWorker.worker = new Worker('worker-gs-table.js');

        //// this function listens to the web worker after the web worker has
        ////      given the signal that it's ready
        //handlerFunction = function (event) {
        //    var jsnMessage = event.data;
        //    //console.log('handler received', jsnMessage);
        //};

        //// this function listens to the web worker until the worker gives the
        ////      signal that it's ready for use
        //waitingFunction = function (event) {
        //    var jsnMessage = event.data;
        //    //console.log('handler received', jsnMessage);

        //    if (jsnMessage.content === 'ready') {
                //// mark the worker as ready so that any code that can only run
                ////      while the worker is ready will now be able to run
                //element.internalWorker.ready = true;

                //// re-bind worker lister to the main listener code
                //element.internalWorker.worker.onmessage = handlerFunction;

        // run first select now that the worker is ready
        dataSELECT(element);

                ////console.log('worker ready');
        //    }
        //};

        ////element.internalWorker.worker.postMessage({"first": value});

        //// bind web worker message event so that we can begin using the worker
        //element.internalWorker.worker.onmessage = waitingFunction;
    }

// ############################################################################
// ############################## COPY FUNCTIONS ##############################
// ############################################################################

    // there are multiple places where we need to get the copy parameters, so
    //      we use this function so that we can have things like defaults and
    //      we don't need to update multiple sections of code to keep things in
    //      sync
    function getCopyParameters(element) {
        var headerMode;
        var selectorMode;
        var quoteChar;
        var escapeChar;
        var quoteMode;
        var recordDelimiter;
        var cellDelimiter;
        var nullString;
        var copyTypes;

        // we need the user to be able to override the copy parameters so that
        //      they can format the copy in the way they need
        // if the attribute is present for a parameter, fill the variable with
        //      the attribute (and default to empty string) else default to
        //      parameter default
        if (element.getAttribute('copy-header')) {
            headerMode = element.getAttribute('copy-header');
        } else {
            headerMode = 'never';
        }
        if (element.getAttribute('copy-selectors')) {
            selectorMode = element.getAttribute('copy-selectors');
        } else {
            selectorMode = 'never';
        }
        if (element.getAttribute('copy-quote-char')) {
            quoteChar = element.getAttribute('copy-quote-char');
        } else {
            quoteChar = '"';
        }
        if (element.getAttribute('copy-escape-char')) {
            escapeChar = element.getAttribute('copy-escape-char');
        } else {
            escapeChar = quoteChar;
        }
        if (element.getAttribute('copy-quote-when')) {
            quoteMode = element.getAttribute('copy-quote-when');
        } else {
            quoteMode = 'delimiter-in-content';
        }
        if (element.getAttribute('copy-delimiter-record')) {
            recordDelimiter =
                    element.getAttribute('copy-delimiter-record')
                .replace(/\{\{DOS_RETURN\}\}/gi, '\r\n')
                .replace(/\{\{MAC_RETURN\}\}/gi, '\r');
        } else {
            recordDelimiter = '\n';
        }
        if (element.getAttribute('copy-delimiter-cell')) {
            cellDelimiter = element.getAttribute('copy-delimiter-cell')
                .replace(/\{\{DOS_RETURN\}\}/gi, '\r\n')
                .replace(/\{\{MAC_RETURN\}\}/gi, '\r');
        } else {
            cellDelimiter = '\t';
        }
        if (element.getAttribute('copy-null-cell')) {
            nullString = element.getAttribute('copy-null-cell');
        } else {
            nullString = '';
        }
        if (element.getAttribute('copy-types')) {
            copyTypes = element.getAttribute('copy-types');
        } else {
            copyTypes = 'text,html';
        }

        // we need to return multiple variables but return only allows one
        //      return value, so we'll return in JSON
        return {
            "headerMode": headerMode,
            "selectorMode": selectorMode,
            "quoteChar": quoteChar,
            "escapeChar": escapeChar,
            "quoteMode": quoteMode,
            "recordDelimiter": recordDelimiter,
            "cellDelimiter": cellDelimiter,
            "nullString": nullString,
            "copyTypes": copyTypes
        };
    }

    // we need to know that we're working with valid copy attributes, so
    //      we use this function to throw an error if there is an invalid
    //      copy attribute
    // this function returns the copy parameters in JSON format if they
    //      are all valid
    function validateCopyParameters(element) {
        var jsnCopyParameters;

        // we need the user to be able to override the copy parameters so that
        //      they can format the copy in the way they need so here, we gather
        //      the copy parameters
        jsnCopyParameters = getCopyParameters(element);

        // we need to verify that the copy parameters are valid
        //console.log('headerMode:      ', jsnCopyParameters.headerMode);
        //console.log('selectorMode:    ', jsnCopyParameters.selectorMode);
        //console.log('quoteChar:       ', jsnCopyParameters.quoteChar);
        //console.log('escapeChar:      ', jsnCopyParameters.escapeChar);
        //console.log('quoteMode:       ', jsnCopyParameters.quoteMode);
        //console.log('recordDelimiter: ', jsnCopyParameters.recordDelimiter);
        //console.log('cellDelimiter:   ', jsnCopyParameters.cellDelimiter);
        //console.log('nullString:      ', jsnCopyParameters.nullString);

        //copy-header: always|never|selected
        if (
            !(/^(always|never|selected)$/gi)
                .test(jsnCopyParameters.headerMode)
        ) {
            throw 'GS-TABLE Error: Copy parameter "copy-header" invalid, ' +
                    'valid values are "always", "never" or "selected" ';
        }
        //copy-selectors: always|never|selected
        if (
            !(/^(always|never|selected)$/gi)
                .test(jsnCopyParameters.selectorMode)
        ) {
            throw 'GS-TABLE Error: Copy parameter "copy-selectors" invalid, ' +
                    'valid values are "always", "never" or "selected" ';
        }
        //copy-quote-when: never|strings|always|delimiter-in-content
        if (
            !(/^(never|strings|always|delimiter-in-content)$/gi)
                .test(jsnCopyParameters.quoteMode)
        ) {
            throw 'GS-TABLE Error: Copy parameter "copy-quote-when" invalid, ' +
                    'valid values are "never", "strings", "always" or ' +
                    '"delimiter-in-content".';
        }
        //copy-delimiter-record: not empty
        if (jsnCopyParameters.recordDelimiter.length === 0) {
            throw 'GS-TABLE Error: Copy parameter "copy-delimiter-record" ' +
                    'cannot be empty.';
        }
        //copy-delimiter-cell: not empty
        if (jsnCopyParameters.cellDelimiter.length === 0) {
            throw 'GS-TABLE Error: Copy parameter "copy-delimiter-cell" ' +
                    'cannot be empty.';
        }

        // this function gets the copy parameters on it's own, so if a function
        //      were to call this function, we wouldn't want to have to re-get
        //      the copy parameters in that function, so we return the copy
        //      parameters
        return jsnCopyParameters;
    }

    // we need to be able to override the clipbard for specific mime types on a
    //      copy event, this function accepts the copy event, the copy string
    //      and the mime type to override
    function handleClipboardData(event, strCopyString, strType) {
        var clipboardData = event.clipboardData || window.clipboardData;
        var strMime;

        if (!clipboardData) {
            return;
        }
        if (!clipboardData.setData) {
            return;
        }

        if (strType === 'text') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = 'Text';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/plain';
            }
        } else if (strType === 'html') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = '';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/html';
            }
        } else {
            throw 'handleClipboardData Error: Type "' + strType + '" not ' +
                    'recognized, recognized types are "text" and "html".';
        }

        if (strMime) {
            if (strCopyString && strMime) {
                return clipboardData.setData(strMime, strCopyString) !== false;
            } else {
                return clipboardData.getData(strMime);
            }
        }
    }

    function getCopyStrings(element) {
        var strTextCopyString;
        var strHTMLCopyString;
        var strHTMLRecordCopyString;
        var row_i;
        var row_len;
        var col_i;
        var col_len;
        var cell;
        var row;
        var cell_i;

        var jsnCopyParameters;
        var quoteChar;
        var escapeChar;
        var quoteMode;
        var selectorMode;
        var headerMode;
        var recordDelimiter;
        var cellDelimiter;
        var nullString;

        var arrColumns;
        var arrRows;
        var bolHeader;
        var bolSelector;
        var arrHeaders;
        var arrColumnTemplates;
        var arrColumnNames;
        var arrSelection;
        var intRow;
        var intCol;
        var intSel;

        var handleCell;
        var jsnQS;
        var jsnRow;
        var arrRow;
        var strRow;
        var strHeader;

        var arrSelectedStates = ['B', 'D', 'F', 'H', 'J', 'L'];

        var cell_len;
        var delim;

        // define the text copy string as empty string so that we can just
        //      append to it without causing an issue where "undefined" is
        //      at the beginning of the string
        strTextCopyString = '';

        // define the HTML copy string as a beginning table tag, so that
        //      we only have to append to the string
        strHTMLCopyString =
                '<' + 'style>' +
                'br { mso-data-placement:same-cell; } ' +
                'th, td { white-space: pre-wrap; }' +
                '<' + '/style>' +
                '<' + 'table border="0" cellpadding="0" cellspacing="0">';

        strHTMLRecordCopyString = '';

        // cache copy column template stringss for speed
        arrColumnTemplates = element.internalClip.columnList.slice(0);
        // convert the column template strings into dot.js functions for speed
        col_i = 0;
        col_len = arrColumnTemplates.length;
        while (col_i < col_len) {
            arrColumnTemplates[col_i] =
                    '{{ var qs = jo.qs' +
                    ', row = jo.row' +
                    ', arrRow = jo.arrRow' +
                    ', i = jo.i' +
                    ', len = jo.len; }}' +
                    arrColumnTemplates[col_i];

            arrColumnTemplates[col_i] = doT.template(
                arrColumnTemplates[col_i]
            );

            col_i += 1;
        }

        // we need the user to be able to override the copy parameters so that
        //      they can format the copy in the way they need so here, we gather
        //      the copy parameters
        jsnCopyParameters = getCopyParameters(element);
        quoteChar = jsnCopyParameters.quoteChar;
        escapeChar = jsnCopyParameters.escapeChar;
        quoteMode = jsnCopyParameters.quoteMode;
        selectorMode = jsnCopyParameters.selectorMode;
        headerMode = jsnCopyParameters.headerMode;
        recordDelimiter = jsnCopyParameters.recordDelimiter;
        cellDelimiter = jsnCopyParameters.cellDelimiter;
        nullString = jsnCopyParameters.nullString;

        // we dont want to recalculate the Query String JSON once for every
        //      cell, so here we calculate it once (in JSON format)
        jsnQS = GS.qryToJSON(GS.getQueryString());

        // bring copy variables in for easy access
        arrColumnNames = element.internalData.columnNames;
        arrSelection = element.internalSelection.resolvedSelection.slice(0);
        arrColumns = element.internalSelection.columns.slice(0);
        arrRows = element.internalSelection.rows.slice(0);
        arrHeaders = element.internalClip.headerList.slice(0);

        // if the header is selected, remove it from the list and save it
        //  in another location
        if (
            (
                headerMode === 'selected' &&
                arrRows[0] === 'header'
            ) ||
            (
                headerMode === 'always'
            )
        ) {
            bolHeader = true;
        }
        if (arrRows[0] === 'header') {
            arrRows.shift();
        }
        if (element.internalDisplay.headerVisible) {
            strHeader = arrSelection[0]; //.shift();
        }

        // if a selector is selected and we don't copy those, remove it from
        //      the list
        if (
            (
                selectorMode === 'selected' &&
                arrColumns[0] === 'selector'
            ) ||
            (
                selectorMode === 'always'
            )
        ) {
            bolSelector = true;
        }
        if (arrColumns[0] === 'selector') {
            arrColumns.shift();
        }

        // if the insert record is selected, remove it from the list
        if (arrRows[arrRows.length - 1] === 'insert') {
            arrRows.pop();
        }

        // convert the header template strings into dot.js functions for speed
        col_i = 0;
        col_len = arrHeaders.length;
        while (col_i < col_len) {
            arrHeaders[col_i] = doT.template(
                '{{ var qs = jo.qs; }}' +
                arrHeaders[col_i]
            );
            col_i += 1;
        }

        //console.log(
        //    arrColumns,
        //    arrRows
        //);

        // to handle different quoting policies, we define the "handleCell"
        //      function differently depending on the "quoteMode" variable
        // the "handleCell" function handles quoting, querystring template
        //      and row templating
        // defining the "handleCell" function conditionally is going to make
        //      the "handleCell" function faster because it doesn't have to
        //      recalculate the quote policy once fo reach cell
        //copy-quote-when: never|strings|always|delimiter-in-content
        if (quoteMode === 'never') {
            // no quoting,
            //      template cell with querystring and row
            //      append cell to strTextCopyString
            handleCell = function (cellTemplate, i, len, jsnRow, arrRow) {
                // template cell with querystring and row
                var strCell = cellTemplate({
                    'qs': jsnQS,
                    'row': jsnRow,
                    'arrRow': arrRow,
                    'i': i,
                    'len': len
                });

                // append cell to the HTML copy string
                strHTMLRecordCopyString +=
                        '<' + 'td rowspan="1" colspan="1">' +
                        strCell +
                        '</td>';

                // append cell to the text copy string
                strTextCopyString += strCell;
            };
        } else if (quoteMode === 'strings') {
            // string quoting,
            //      template cell with querystring and row
            //      if escapeChar !== quoteChar: double up every escapeChar
            //      put an escapeChar behind every quoteChar
            //      if NaN: wrap cell with quoteChar
            //      append cell to strTextCopyString
            handleCell = function (cellTemplate, i, len, jsnRow, arrRow) {
                // template cell with querystring and row
                var strCell = cellTemplate({
                    'qs': jsnQS,
                    'row': jsnRow,
                    'arrRow': arrRow,
                    'i': i,
                    'len': len
                });

                // before we do any quoting, we need to add the HTML to the
                //      HTML copy string
                strHTMLRecordCopyString +=
                        '<' + 'td rowspan="1" colspan="1">' +
                        strCell +
                        '</td>';

                // if escapeChar !== quoteChar: double up every escapeChar
                if (escapeChar !== quoteChar) {
                    strCell = stringReplaceAll(
                        strCell,
                        escapeChar,
                        escapeChar + escapeChar
                    );
                }

                // put an escapeChar behind every quoteChar
                strCell = stringReplaceAll(
                    strCell,
                    quoteChar,
                    escapeChar + quoteChar
                );

                // if NaN: wrap cell with quoteChar
                if (isNaN(strCell)) {
                    strCell = quoteChar + strCell + quoteChar;
                }

                // append cell to copy string
                strTextCopyString += strCell;
            };
        } else if (quoteMode === 'always') {
            // string quoting,
            //      template cell with querystring and row
            //      if escapeChar !== quoteChar: double up every escapeChar
            //      put an escapeChar behind every quoteChar
            //      wrap cell with quoteChar
            //      append cell to strTextCopyString
            handleCell = function (cellTemplate, i, len, jsnRow, arrRow) {
                // template cell with querystring and row
                var strCell = cellTemplate({
                    'qs': jsnQS,
                    'row': jsnRow,
                    'arrRow': arrRow,
                    'i': i,
                    'len': len
                });

                // before we do any quoting, we need to add the HTML to the
                //      HTML copy string
                strHTMLRecordCopyString +=
                        '<' + 'td rowspan="1" colspan="1">' +
                        strCell +
                        '</td>';

                // if escapeChar !== quoteChar: double up every escapeChar
                if (escapeChar !== quoteChar) {
                    strCell = stringReplaceAll(
                        strCell,
                        escapeChar,
                        escapeChar + escapeChar
                    );
                }

                // put an escapeChar behind every quoteChar
                strCell = stringReplaceAll(
                    strCell,
                    quoteChar,
                    escapeChar + quoteChar
                );

                // wrap cell with quoteChar
                strCell = quoteChar + strCell + quoteChar;

                // append cell to copy string
                strTextCopyString += strCell;
            };
        } else if (quoteMode === 'delimiter-in-content') {
            // string quoting,
            //      template cell with querystring and row
            //      if escapeChar !== quoteChar: double up every escapeChar
            //      if quoteChar inside cell
            //          put an escapeChar behind every quoteChar
            //          wrap cell with quoteChar
            //      append cell to strTextCopyString
            handleCell = function (cellTemplate, i, len, jsnRow, arrRow) {
                // template cell with querystring and row
                var strCell = cellTemplate({
                    'qs': jsnQS,
                    'row': jsnRow,
                    'arrRow': arrRow,
                    'i': i,
                    'len': len
                });

                // before we do any quoting, we need to add the HTML to the
                //      HTML copy string
                strHTMLRecordCopyString += (
                    '<' + 'td rowspan="1" colspan="1">' +
                    strCell +
                    '</td>'
                );

                // if escapeChar !== quoteChar: double up every escapeChar
                if (escapeChar !== quoteChar) {
                    strCell = stringReplaceAll(
                        strCell,
                        escapeChar,
                        escapeChar + escapeChar
                    );
                }

                // if quoteChar is inside cell
                if (strCell.indexOf(quoteChar) !== -1) {
                    // put an escapeChar behind every quoteChar
                    strCell = stringReplaceAll(
                        strCell,
                        quoteChar,
                        escapeChar + quoteChar
                    );

                    // wrap cell with quoteChar
                    strCell = quoteChar + strCell + quoteChar;
                }

                // append cell to copy string
                strTextCopyString += strCell;
            };
        }

        //console.log(
        //    bolHeader,
        //    bolSelector,
        //    strHeader,
        //    arrRows,
        //    arrColumns
        //);

        // if the header has selected cells, we need to build the header
        if (bolHeader && headerMode !== 'never') {
            // if there are selectors selected, because the header also
            //      has selected columns we need the all selector to fill
            //      in the space to the left of the header that's made
            //      when there are selectors present
            if (bolSelector && selectorMode !== 'never') {
                // if the "quoteMode" is "always": we need to add a pair
                //      of quotes where this extra cell is
                if (quoteMode === 'always') {
                    strTextCopyString += quoteChar + quoteChar;
                }

                // and finally, add the delimiter
                strTextCopyString += cellDelimiter;

                // add an empty cell to the HTML copy string to make room
                //      for the record selector column
                strHTMLRecordCopyString += (
                    '<td rowspan="1" colspan="1"></td>'
                );
            }

            //console.log(arrSelectedStates);
            //console.log(arrHeaders.slice(0));

            // loop to add the rest of the headers
            col_i = 0;
            col_len = arrColumns.length;
            while (col_i < col_len) {
                // we want to put a delimiter between each cell
                if (col_i > 0) {
                    strTextCopyString += cellDelimiter;
                }

                intSel = arrColumns[col_i];
                intCol = intSel;
                if (element.internalDisplay.recordSelectorVisible) {
                    intSel = (arrColumns[col_i] + 1);
                    intCol = (intSel - 1);
                }

                //console.log(
                //    col_i,
                //    intSel,
                //    intCol,
                //    strHeader[intSel],
                //    arrHeaders[intCol]
                //);

                // template, quote and append cell to copy string
                if (
                    headerMode === 'always' ||
                    arrSelectedStates.indexOf(strHeader[intSel]) > -1
                ) {
                    ////console.log(arrHeaders[intCol], 0, 0);
                    handleCell(arrHeaders[intCol], 0, 0);

                } else {
                    strHTMLRecordCopyString += (
                        '<' + 'td rowspan="1" colspan="1"></td>'
                    );

                    if (quoteMode === 'always') {
                        strTextCopyString += quoteChar + quoteChar;
                    }
                }

                col_i += 1;
            }

            // append record to HTML copy string, clear current record variable
            strHTMLCopyString += '<tr>' + strHTMLRecordCopyString + '</tr>';
            strHTMLRecordCopyString = '';

            // if there are records selected, we want to seperate the header
            //      and the first row using the record delimiter
            if (arrRows.length > 0) {
                strTextCopyString += recordDelimiter;
            }
        }

        // <br />
        //console.log(arrHeaders.slice(0));

        // we cache the number of columns because it doesn't change
        col_len = arrColumns.length;

        // we need to get the range
        row_i = 0;
        row_len = arrRows.length;

        // loop through the rows
        while (row_i < row_len) {
            intSel = arrRows[row_i];
            intRow = intSel;
            if (element.internalDisplay.headerVisible) {
                intSel = (arrRows[row_i] + 1);
                intRow = (intSel - 1);
            }

            // we need to know the selection status of this record
            row = arrSelection[intSel];

            // generate record JSON for template
            jsnRow = {};
            arrRow = [];
            strRow = element.internalData.records[intRow] + '\t';

            cell_i = 0;
            cell_len = 9999;
            while (cell_i < cell_len) {// remember, requires \t at
                                       //       the end of the record
                delim = strRow.indexOf('\t');
                cell = strRow.substring(0, delim);
                strRow = strRow.substring(delim + 1);

                //console.log(arrColumnNames[cell_i], cell);
                if (cell !== '' || strRow !== '') {
                    jsnRow[arrColumnNames[cell_i]] = (
                        GS.decodeFromTabDelimited(cell, nullString)
                    );
                    arrRow.push(jsnRow[arrColumnNames[cell_i]]);
                } else {
                    break;
                }

                cell_i += 1;
            }
            //console.log(jsnRow);
            //console.log(strRow);
            //console.log(arrRow);

            // version 1, broken: last cell has one char missing, replaced
            //      with faster solution
            //record_i = 0;
            //record_len = strRow.length;
            //cell_i = 0;
            //cell = "";
            //while (record_i < record_len) {
            //    char = strRow[record_i];

            //    if (char === "\t" || record_i === (record_len - 1)) {
            //        jsnRow[arrColumnNames[cell_i]] = (
            //            GS.decodeFromTabDelimited(cell, nullString)
            //        );

            //        cell = "";
            //        cell_i += 1;
            //    } else {
            //        cell += char;
            //    }
            //    record_i += 1;
            //}

            //console.log(
            //    row_i,
            //    intSel,
            //    intRow,
            //    strRow,
            //    jsnRow
            //);

            // if record selectors are allowed: add record number
            if (
                bolSelector &&
                (
                    selectorMode === 'always' ||
                    (
                        selectorMode === 'selected' &&
                        arrSelectedStates.indexOf(row[0]) > -1
                    )
                )
            ) {
                strTextCopyString += (intRow + 1);

                strHTMLRecordCopyString += (
                    '<td rowspan="1" colspan="1">' + (intRow + 1) + '</td>'
                );
            }

            // no matter if we copied the record selector or not,
            //      we need the delimiter if we are copying some
            //      selectors
            if (bolSelector && col_len > 0) {
                strTextCopyString += cellDelimiter;
            }

            col_i = 0;
            while (col_i < col_len) {
                // we want to put a delimiter between each cell
                if (col_i > 0) {
                    strTextCopyString += cellDelimiter;
                }

                intSel = arrColumns[col_i];
                intCol = intSel;
                if (element.internalDisplay.recordSelectorVisible) {
                    intSel = (arrColumns[col_i] + 1);
                    intCol = (intSel - 1);
                }

                //console.log(
                //    col_i,
                //    intSel,
                //    intCol,
                //    strHeader[intSel],
                //    arrHeaders[intCol]
                //);

                // template, quote and append cell to copy string
                if (arrSelectedStates.indexOf(row[intSel]) > -1) {
                    handleCell(
                        arrColumnTemplates[arrColumns[col_i]],
                        row_i,
                        row_len,
                        jsnRow,
                        arrRow
                    );

                } else {
                    strHTMLRecordCopyString += (
                        '<' + 'td rowspan="1" colspan="1"></td>'
                    );

                    if (quoteMode === 'always') {
                        strTextCopyString += quoteChar + quoteChar;
                    }
                }

                col_i += 1;
            }

            // append record to HTML copy string, clear current record variable
            strHTMLCopyString += '<tr>' + strHTMLRecordCopyString + '</tr>';
            strHTMLRecordCopyString = '';

            // add record delimiter (unless we're on the last record)
            if ((row_i + 1) < row_len) {
                strTextCopyString += recordDelimiter;
            }
            row_i += 1;
        }

        // add the ending table tag to the HTML copy string
        strHTMLCopyString += '</table>';

        // now we'll take our column and row arrays and convert them to a
        //      text MIME type copy string
        //console.log('arrColumns: ', arrColumns);
        //console.log('arrRows: ', arrRows);
        //console.log('arrSelection: ', arrSelection);
        //console.log('HTML:\n' + strHTMLCopyString);
        //console.log('TEXT:\n' + strTextCopyString);




//
//
//            // loop through columns and template
//            col_i = 0;
//            while (col_i < col_len) {
//                intCol = col_i;
//
//                // if record selectors are visible, we need to offset
//                //      where we look for the column select state
//                if (element.internalDisplay.recordSelectorVisible) {
//                    intCol = arrColumns[col_i] + 1;
//                }
//
//                // we want to put a delimiter between each cell NEEDS WORK
//                if (
//                    arrColumns[col_i - 1] !== 'selector' &&
//                    arrColumns[col_i - 1] !== undefined
//                ) {
//                    strTextCopyString += cellDelimiter;
//                }
//
//                // if this cell is selected: template, quote and
//                //      append cell to copy string
//                if (arrSelectedStates.indexOf(row[intCol]) > -1) {
//                    handleCell(
//                        arrColumnTemplates[arrColumns[col_i]],
//                        row_i,
//                        row_len,
//                        jsnRow
//                    );
//                }
//
//                col_i += 1;
//            }
//
//        //console.log(strTextCopyString);

        return {
            "text": strTextCopyString,
            "html": strHTMLCopyString
        };
    }

// ############################################################################
// ############################# RENDER FUNCTIONS #############################
// ############################################################################

    function updateHUD(element) {
        var arrDataColumns;
        var sortASCButton;
        var sortDESCButton;
        var sortClearButton;

        // disable/enable hud sorting buttons
        sortASCButton = findHudElement(element, 'button-sort-asc');
        sortDESCButton = findHudElement(element, 'button-sort-desc');
        sortClearButton = findHudElement(element, 'button-sort-clear');

        // we need an array of the selected data columns
        arrDataColumns = getSelectedDataColumns(element);

        //console.log(arrDataColumns);

        // if there are data columns selected, enable sort buttons
        if (arrDataColumns.length > 0) {
            if (sortASCButton) {
                sortASCButton.removeAttribute('disabled');
            }
            if (sortDESCButton) {
                sortDESCButton.removeAttribute('disabled');
            }
            if (sortClearButton) {
                sortClearButton.removeAttribute('disabled');
            }

        // else, no data columns selected, disable sort buttons
        } else {
            if (sortASCButton) {
                sortASCButton.setAttribute('disabled', '');
            }
            if (sortDESCButton) {
                sortDESCButton.setAttribute('disabled', '');
            }
            if (sortClearButton) {
                sortClearButton.setAttribute('disabled', '');
            }
        }
    }

    function renderSelection(element) {//<br />
        var bolHeaders;
        var bolSelectors;
        var bolInsert;
        var col_i;
        var col_len;
        var rec_i;
        var rec_len;
        var strRecord;
        var arrSelection;
        var range_i;
        var range_len;
        var range;
        var arrRanges;
        var arrColumnWidths;
        var rangeStartRow;
        var rangeStartColumn;
        var rangeEndRow;
        var rangeEndColumn;
        var intOriginRecord;
        var jsnSelectedToDeselected;
        var jsnDeselectedToSelected;
        var jsnTranslationMatrix;
        var intRecord;
        var intColumn;
        var intChar;
        var intHeaderIndex;
        var intSelectorIndex;
        var intInsertIndex;
        var jsnRange;
        var strCompareString;

        var arrElements;
        var i;
        var len;
        var cell;
        var strRow;
        var strCol;
        var intRow;
        var intCol;
        var arrSelectedStates;
        //var arrDeselectedStates;

        var arrColumns;
        var arrRows;
        var intMaxColumns;
        var arrSelectionRows;
        var arrSelectionCols;
        var pushValue;


        // GS.triggerEvent(element, 'selection_change');
        //console.time('selection total');

        // first, we should gather some helper variables.
        bolHeaders = (element.internalDisplay.headerVisible);
        bolSelectors = (!element.hasAttribute('no-record-selector'));
        bolInsert = (element.internalDisplay.insertRecordVisible);
        arrSelection = [];

        strCompareString = selectionArrayToString(
            element.internalSelection.ranges
        );

        // create the blank slate for the resolved selection
        //      Type:              Unselected:   Selected:
        //      HEADER CELL        A             B
        //      RECORD CELL        C             D
        //      INSERT CELL        E             F
        //      ALL SELECTOR       G             H
        //      RECORD SELECTOR    I             J
        //      INSERT SELECTOR    K             L
        arrSelectedStates = ['B', 'D', 'F', 'H', 'J', 'L'];
        //arrDeselectedStates = ['A', 'C', 'E', 'G', 'I', 'K'];

        if (strCompareString === element.internalSelection.rangeCache) {
            arrSelection = element.internalSelection.resolvedSelection;
            arrRanges = element.internalSelection.ranges;
            arrColumnWidths = element.internalDisplay.columnWidths;
            arrRows = element.internalSelection.rows;
            arrColumns = element.internalSelection.columns;

            arrSelectionRows = element.internalSelection.rows.slice(0);
            rec_i = 0;
            rec_len = arrSelectionRows.length;
            while (rec_i < rec_len) {
                if (arrSelectionRows[rec_i] === 'header') {
                    arrSelectionRows[rec_i] = 0;
                } else if (arrSelectionRows[rec_i] === 'insert') {
                    arrSelectionRows[rec_i] = arrSelection.length - 1;
                } else {
                    arrSelectionRows[rec_i] += 1;
                }
                rec_i += 1;
            }

            arrSelectionCols = element.internalSelection.columns.slice(0);
            col_i = 0;
            col_len = arrSelectionCols.length;
            while (col_i < col_len) {
                if (arrSelectionCols[col_i] === 'selector') {
                    arrSelectionCols[col_i] = 0;
                } else {
                    arrSelectionCols[col_i] += 1;
                }
                col_i += 1;
            }

            //if (
            //    arrSelection &&
            //    arrSelection[0] &&
            //    arrSelection[0][0] !== 'G'
            //) {
            //    console.trace(arrSelection);
            //}

        } else {
            element.internalSelection.rangeCache = strCompareString;

            col_len = element.internalDisplay.columnWidths.length;

            if (bolHeaders) {
                strRecord = '';
                if (bolSelectors) {
                    strRecord += 'G';
                }

                col_i = 0;
                while (col_i < col_len) {
                    strRecord += 'A';
                    col_i += 1;
                }
                arrSelection.push(strRecord);
            }

            strRecord = '';
            if (bolSelectors) {
                strRecord = 'I';
            }

            col_i = 0;
            while (col_i < col_len) {
                strRecord += 'C';
                col_i += 1;
            }

            rec_i = 0;
            rec_len = element.internalData.records.length;
            while (rec_i < rec_len) {
                arrSelection.push(strRecord);
                rec_i += 1;
            }

            if (bolInsert) {
                strRecord = '';
                if (bolSelectors) {
                    strRecord += 'K';
                }

                col_i = 0;
                while (col_i < col_len) {
                    strRecord += 'E';
                    col_i += 1;
                }
                arrSelection.push(strRecord);
            }

            ////console.log(arrSelection);

            // because of the vast array of column types, we'll (for simplicity
            //      and for brevity) use one of two matrices, a matrix that
            //      translates a selected cell to a deselected cell and one to
            //      do the opposite
            jsnSelectedToDeselected = {
                "A": "A",
                "B": "A",
                "C": "C",
                "D": "C",
                "E": "E",
                "F": "E",
                "G": "G",
                "H": "G",
                "I": "I",
                "J": "I",
                "K": "K",
                "L": "K"
            };
            jsnDeselectedToSelected = {
                "A": "B",
                "B": "B",
                "C": "D",
                "D": "D",
                "E": "F",
                "F": "F",
                "G": "H",
                "H": "H",
                "I": "J",
                "J": "J",
                "K": "L",
                "L": "L"
            };

            // because math is faster that string comparison, we need to convert
            //      the special values inside the ranges to numbers. but, we
            //      don't want to recalculate those numbers every time, so,
            //      we'll calculate them here and just reuse them
            intHeaderIndex = -1;
            intSelectorIndex = -1;
            intInsertIndex = (
                bolInsert
                    ? (arrSelection.length - 1)
                    : null
            );
            if (bolHeaders) {
                intInsertIndex -= 1;
            }

            //console.log(intInsertIndex);
            //console.time('selection resolve');

            // loop through each selection and flip the states of the
            //      affected cells
            arrRanges = element.internalSelection.ranges;
            arrColumnWidths = element.internalDisplay.columnWidths;
            range_i = 0;
            range_len = arrRanges.length;
            while (range_i < range_len) {
                range = arrRanges[range_i];

                // we want to copy the range element so that when we modify it
                //      we don't modify the original
                range = {
                    "start": {
                        "row": range.start.row,
                        "column": range.start.column
                    },
                    "end": {
                        "row": range.end.row,
                        "column": range.end.column
                    },
                    "negator": range.negator
                };

                //console.log(range);

                // gotta convert special values so that we can use math
                if (range.start.row === 'header') {
                    range.start.row = intHeaderIndex;
                } else if (range.start.row === 'insert') {
                    range.start.row = intInsertIndex;
                }
                if (range.end.row === 'header') {
                    range.end.row = intHeaderIndex;
                } else if (range.end.row === 'insert') {
                    range.end.row = intInsertIndex;
                }
                if (range.start.column === 'selector') {
                    range.start.column = intSelectorIndex;
                }
                if (range.end.column === 'selector') {
                    range.end.column = intSelectorIndex;
                }

                // because the end of the selection may be above and to the left
                //      of the start of the selection, we need to be sure that:
                //          the start row/column is the top-left
                //          the end row/column is the bottom-right
                rangeStartRow = Math.min(range.start.row, range.end.row);
                rangeEndRow = Math.max(range.start.row, range.end.row);
                rangeStartColumn = Math.min(
                    range.start.column,
                    range.end.column
                );
                rangeEndColumn = Math.max(range.start.column, range.end.column);

                // if this is the first selection, save the origin record
                //      number for future reference
                if (range_i === 0) {
                    intOriginRecord = rangeStartRow;

                    // the header can't be the origin record
                    if (intOriginRecord === -1) {
                        intOriginRecord += 1;
                    }

                    // save origin record internally
                    element.internalSelection.originRecord = intOriginRecord;
                }

                // if we are dealing with a non-negation selection, use the
                //      jsnDeselectedToSelected translation matrix
                if (range.negator === false) {
                    jsnTranslationMatrix = jsnDeselectedToSelected;

                // else, use the jsnSelectedToDeselected translation matrix
                } else {
                    jsnTranslationMatrix = jsnSelectedToDeselected;
                }

                rec_i = 0;
                rec_len = arrSelection.length;
                while (rec_i < rec_len) {
                    strRecord = arrSelection[rec_i];
                    intRecord = rec_i;

                    if (bolHeaders) {
                        intRecord -= 1;
                    }

                    // if the row is in range or all rows are in the range:
                    //      iterate through cells in the row
                    if (
                        (
                            intRecord >= rangeStartRow &&
                            intRecord <= rangeEndRow
                        ) ||
                        (
                            rangeStartRow === -1 &&
                            rangeEndRow === -1
                        )
                    ) {
                        col_i = 0;
                        col_len = strRecord.length;
                        while (col_i < col_len) {
                            intChar = col_i;
                            intColumn = col_i;

                            if (bolSelectors) {
                                intColumn = (col_i - 1);
                            }

                            // testing to see if th cell is in the current
                            //      selection range or that the whole record is
                            //      selected
                            if (
                                (
                                    (
                                        intColumn >= rangeStartColumn &&
                                        intColumn <= rangeEndColumn
                                    ) ||
                                    (
                                        rangeStartColumn === -1 &&
                                        rangeEndColumn === -1
                                    )
                                ) &&
                                // we don't want to copy hidden columns
                                (
                                    intColumn === null ||
                                    intColumn === -1 ||
                                    arrColumnWidths[intColumn] > 0
                                )
                            ) {
                                // set cell to "Y" because it is in the
                                //      selection range
                                strRecord = (
                                    strRecord.substr(0, intChar) +
                                    jsnTranslationMatrix[strRecord[intChar]] +
                                    strRecord.substr(intChar + 1)
                                );
                            }
                            col_i += 1;
                        }
                        arrSelection[rec_i] = strRecord;
                    }
                    rec_i += 1;
                }
                range_i += 1;
            }

            // now, we'll convert the array of rows to an array of record
            //      numbers that will be copied (arrRows)
            arrRows = [];
            arrSelectionRows = [];
            rec_i = 0;
            rec_len = arrSelection.length;
            while (rec_i < rec_len) {
                // if the row is selected, add it to the list
                if ((/[BDFHJL]/gi).test(arrSelection[rec_i])) {
                    if (bolHeaders && rec_i === 0) {
                        arrRows.push('header');

                    } else if (bolInsert && rec_i === (rec_len - 1)) {
                        arrRows.push('insert');

                    } else if (bolHeaders) {
                        arrRows.push(rec_i - 1);

                    } else {
                        arrRows.push(rec_i);
                    }
                    arrSelectionRows.push(rec_i);
                }
                rec_i += 1;
            }

            // we'll loop through every row that has a selected cell in it
            //      (arrRows) and for every "Y" we'll add the column number
            //      (if it's not already present) to our column array we'll
            //      break out of the loop if all columns are included
            arrColumns = [];
            arrSelectionCols = [];
            intMaxColumns = element.internalClip.columnList.length;
            rec_i = 0;
            rec_len = arrSelectionRows.length;
            while (rec_i < rec_len) {
                strRecord = arrSelection[arrSelectionRows[rec_i]];
                col_i = 0;
                col_len = strRecord.length;
                while (col_i < col_len) {
                    if (bolSelectors && col_i === 0) {
                        pushValue = ('selector');
                    } else if (bolSelectors) {
                        pushValue = (col_i - 1);
                    } else {
                        pushValue = col_i;
                    }

                    if (
                        arrSelectedStates.indexOf(strRecord[col_i]) !== -1 &&
                        arrColumns.indexOf(pushValue) === -1
                    ) {
                        arrColumns.push(pushValue);
                        arrSelectionCols.push(col_i);
                    }
                    col_i += 1;
                }

                if (arrColumns.length >= intMaxColumns) {
                    break;
                }
                rec_i += 1;
            }
        }

        //console.timeEnd('selection resolve');

        //var test = arrSelection.join('\n');
        //console.log(test.substring(test.length - 20));

        //console.time('selection render');

        // grab all visible cells
        arrElements = tblQry(element.elems.dataViewport, 'gs-cell');

        // deselect all visible cells
        i = 0;
        len = arrElements.length;
        while (i < len) {
            arrElements[i].removeAttribute('selected');
            arrElements[i].removeAttribute('origin-record');
            arrElements[i].removeAttribute('auto-selected');
            i += 1;
        }

        // select all visible cells that are marked as such in the
        //      resolved selection
        i = 0;
        len = arrElements.length;
        while (i < len) {
            cell = arrElements[i];
            strRow = (
                cell.getAttribute('data-row-number') ||
                '-1'
            );
            strCol = (
                cell.getAttribute('data-col-number') ||
                cell.getAttribute('data-col') ||
                '-1'
            );

            intRow = parseInt(strRow, 10);
            intCol = parseInt(strCol, 10);

            if (bolHeaders) {
                intRow += 1;
            }
            if (bolSelectors) {
                intCol += 1;
            }

            if (strRow === 'insert') {
                intRow = (arrSelection.length - 1);
            }

            if (strCol === 'selector') {
                intCol = 0;
            }

            // highlight origin record
            if (
                //(
                (
                    !bolHeaders &&
                    intRow === intOriginRecord
                ) ||
                (
                    bolHeaders &&
                    intRow === (intOriginRecord + 1)
                )
                //) &&
                //(
                //    !cell.classList.contains('table-insert-selector') &&
                //    !cell.classList.contains('table-record-selector')
                //)
            ) {
                arrElements[i].setAttribute('origin-record', '');
            }

            strRecord = arrSelection[intRow];
            if (strRecord) {
                if (arrSelectedStates.indexOf(strRecord[intCol]) > -1) {
                    cell.setAttribute('selected', '');

                // sometimes, the user selects some cells without selecting the
                //      record selectors and/or headers. in this case, we want
                //      to highlight the record selectors and headers of the
                //      selected range
                } else if (
                    (
                        (
                            cell.classList.contains('table-insert-selector') ||
                            cell.classList.contains('table-record-selector')
                        ) &&
                        (arrSelectionRows.indexOf(intRow) > -1)
                    ) ||
                    (
                        (
                            cell.classList.contains('table-all-selector') ||
                            cell.classList.contains('table-header')
                        ) &&
                        (arrSelectionCols.indexOf(intCol) > -1)
                    )
                ) {
                    cell.setAttribute('auto-selected', '');
                }
            }

            i += 1;
        }

        //console.timeEnd('selection render');

        // store selection variables internally for future reference
        element.internalSelection.resolvedSelection = arrSelection;
        element.internalSelection.rows = arrRows;
        element.internalSelection.columns = arrColumns;

        // you are not allowed to deselect everything, if you have, we'll
        //      select what we can and then re-render the selection
        if (arrRows.length === 0 || arrColumns.length === 0) {
            // if there is data and the current range is not already selecting
            //      the first cell, select the first cell
            //console.log(element.internalSelection.ranges);
            jsnRange = element.internalSelection.ranges[0];
            // console.log('ranges:', element.internalSelection.ranges.length);
            // console.log('rows:', element.internalSelection.rows);
            // console.log('columns:', element.internalSelection.columns);
            if (
                !element.hasAttribute('no-force-select') &&
                element.internalData.records.length > 0 && (
                    element.internalSelection.ranges &&
                    (
                        // element.internalSelection.ranges.length !== 1 ||
                        element.internalSelection.ranges.length !== 1 ||
                        jsnRange.start.row !== 0 ||
                        jsnRange.start.column !== 0 ||
                        jsnRange.end.row !== 0 ||
                        jsnRange.end.column !== 0 ||
                        jsnRange.negator !== false
                    )
                )
            ) {
                // if single row, we want to select the whole record at first
                if (element.getAttribute('selection-mode') === 'single-row') {
                    element.internalSelection.ranges = [
                        {
                            "start": {"row": 0, "column": "selector"},
                            "end": {"row": 0, "column": "selector"},
                            "negator": false
                        }
                    ];

                // if normal selection, select first cell
                } else {
                    element.internalSelection.ranges = [
                        {
                            "start": {"row": 0, "column": 0},
                            "end": {"row": 0, "column": 0},
                            "negator": false
                        }
                    ];
                }

                // if we are currently selecting with the mouse, stop the
                //      selection
                if (element.internalSelection.currentlySelecting) {
                    element.internalEvents.selectDragEnd();
                }

                // rerender the selection so that the user can see it
                renderSelection(element);

                // stop execution because we'll be re-running this function
                //      anyway
                return;
            }
        }

        //console.timeEnd('selection total');

        // update hud, because it uses the selection
        updateHUD(element);
    }

    //We had an issue where if the viewport was to small everything inside
    //  the viewport would break, this function removes everything inside
    //  the viewport so there's nothing inside there to break, Genius right?
    function renderEmpty(element) {
        element.elems.dataViewport.innerhtml = '';
    }

    function renderLocationFull(element) {
        //var arrColumnWidths;
        //var arrRecordHeights;
        //var columnBorderWidth;
        //var recordBorderHeight;
        var jsnRange;
        var fromColumn;
        var toColumn;
        var fromRecord;
        var toRecord;

        var i;
        var len;
        var col_i;
        var col_len;
        //var record_i;
        //var record_len;

        //var intCellLeft;
        //var intCellOriginLeft;
        //var intRecordTop;
        //var intRecordOriginTop;

        var arrColumnNames;
        var strHeaderTemplate;
        var strDataTemplate;
        var strInsertTemplate;

        var arrElements;
        var strColumn;
        var strValue;

        var strRecord;
        var arrRecord;
        var jsnRecord;
        var jsnQS;
        var intTotalRecords;
        var strNullString;
        //var strChar;
        var strCell;
        var strHTML;
        //var strCSS;
        var delim;

        //var intRecordSelectorBorderWidth;
        //var intInsertRecordBorderHeight;
        //var intHeaderBorderHeight;

        var bolOneCellSelected;
        var selectedCellControl;
        var textSelection;
        var textSelectionStart;
        var textSelectionEnd;

        //console.log(element.internalSelection.ranges.length, 1);
        //if (element.internalSelection.ranges.length === 1){
            //console.log(element.internalSelection.ranges[0].start.column);
            //console.log(element.internalSelection.ranges[0].end.column);
            //console.log(element.internalSelection.ranges[0].start.row);
            //console.log(element.internalSelection.ranges[0].end.row);
        //}

        // get the first range, we need to know if only one cell is selected
        jsnRange = element.internalSelection.ranges[0];
        bolOneCellSelected = (
            element.internalSelection.ranges.length === 1 &&
            jsnRange.start.column === jsnRange.end.column &&
            jsnRange.start.row === jsnRange.end.row
        );

        // if only one cell is selected, we want to save the text selection
        //      so that we can restore it. this is because this function
        //      destroys all cells so the text selection of any of those
        //      cells will be lost.
        if (bolOneCellSelected) {
            selectedCellControl = tblQry(
                element,
                (
                    'gs-cell' +
                        '[data-col-number="' + jsnRange.start.column + '"]' +
                        '[data-row-number="' + jsnRange.start.row + '"]' +
                        ' input'
                )
            )[0];
            textSelectionStart = 0;
            textSelectionEnd = 0;

            //console.log('one cell is selected, save text selection');

            if (selectedCellControl) {
                //console.log(
                //    selectedCellControl.selectionStart,
                //    selectedCellControl.selectionEnd
                //);
                //textSelectionStart = selectedCellControl.selectionStart;
                //textSelectionEnd = selectedCellControl.selectionEnd;

                textSelection = GS.getInputSelection(selectedCellControl);
                textSelectionStart = textSelection.start;
                textSelectionEnd = textSelection.end;

                //console.log(textSelection);
            }
        }


        // some code adds classes to the viewport. these need to be removed on
        //      a full re-render
        element.elems.dataViewport.setAttribute('class', 'table-data-viewport');

        //// save column widths and record heights for easy access
        //arrColumnWidths = element.internalDisplay.columnWidths;
        //arrRecordHeights = element.internalDisplay.recordHeights;

        // we needs the border dimensions to calculate true locations
        //columnBorderWidth = element.internalDisplay.columnBorderWidth;
        //recordBorderHeight = element.internalDisplay.recordBorderHeight;

        // save the column name array for quick and easy access
        arrColumnNames = element.internalData.columnNames;

        // we want the records to have access to the "qs" variable, so we'll
        //      save the query string JSON to a variable so that we only have
        //      to get it once
        jsnQS = GS.qryToJSON(GS.getQueryString());

        // we want the user to be able to have access to the total number of
        //      records in their template so we'll save it to a variable so
        //      that we don't need to recalculate
        intTotalRecords = element.internalData.records.length;

        // we want the null string to be configurable, so we'll read the
        //      "null-string" attribute to get the null string
        strNullString = element.getAttribute('null-string');

        // get visible range
        jsnRange = element.internalDisplay.currentRange;
        //intCellOriginLeft = jsnRange.originLeft;
        //intRecordOriginTop = jsnRange.originTop;
        fromColumn = jsnRange.fromColumn;
        toColumn = jsnRange.toColumn;
        fromRecord = jsnRange.fromRecord;
        toRecord = jsnRange.toRecord;

        //// we need to know the border sizes so that we can calculate cell
        ////      dimensions
        //intRecordSelectorBorderWidth = (
        //    element.internalDisplay.recordSelectorBorderWidth
        //);
        //intInsertRecordBorderHeight = (
        //    element.internalDisplay.insertRecordBorderHeight
        //);
        //intHeaderBorderHeight = (
        //    element.internalDisplay.headerBorderHeight
        //);

        //console.log('element: ', element);
        //console.log('jsnRange: ', jsnRange);
        //console.log('intCellOriginLeft: ', intCellOriginLeft);
        //console.log('intRecordOriginTop: ', intRecordOriginTop);
        //console.log('fromColumn: ', fromColumn);
        //console.log('toColumn: ', toColumn);
        //console.log('fromRecord: ', fromRecord);
        //console.log('toRecord: ', toRecord);

        // define strHTML as empty so that we can append to it without
        //      the 'undefinedTEXT THAT YOU APPENDED' issue
        strHTML = '';

        // we only want to template the columns that fall into the range of
        //      fromColumn->toColumn, so we'll stick the record template HTML
        //      into a template element, yank out the desired cells and
        //      that'll be the html we template with (and we'll repeat this
        //      process for the header and insert columns)
        if (element.internalTemplates.header.trim()) {
            strHeaderTemplate = templateExtractVisibleCellRange(
                element,
                element.internalTemplates.header,
                fromColumn,
                toColumn
            );
        }
        if (element.internalTemplates.record.templateHTML.trim()) {
            strDataTemplate = templateExtractVisibleCellRange(
                element,
                element.internalTemplates.record.templateHTML,
                fromColumn,
                toColumn
            );
        }
        if (
            element.internalTemplates.insertRecord.templateHTML &&
            element.internalTemplates.insertRecord.templateHTML.trim()
        ) {
            strInsertTemplate = templateExtractVisibleCellRange(
                element,
                element.internalTemplates.insertRecord.templateHTML,
                fromColumn,
                toColumn
            );
        }

        //console.log('strHeaderTemplate: ', strHeaderTemplate);
        //console.log('strDataTemplate:   ', strDataTemplate);
        //console.log('strInsertTemplate: ', strInsertTemplate);

        // if there is a record template: build cell elements (first so that
        //      they're below everything)
        if (strDataTemplate) {
            var templateFunc = doT.template(
                '{{ ' +
                    'var row_number = jo.index + 1;' +
                    'var qs = jo.qs;' +
                    'var row = jo.row;' +
                    'var arrRow = jo.arrRow;' +
                    'var i = jo.index;' +
                    'var len = jo.len;' +
                '}}' +
                strDataTemplate
            );

            //console.log(fromRecord, toRecord);
            i = fromRecord;
            len = toRecord;
            //intRecordTop = intRecordOriginTop;
            while (i < len) {
                // create cell array for this record
                strRecord = element.internalData.records[i] + '\t';
                arrRecord = [];
                col_i = 0;
                col_len = element.internalData.columnNames.length;//9999;
                while (col_i < col_len) {
                    delim = strRecord.indexOf('\t');
                    strCell = strRecord.substring(0, delim);
                    strRecord = strRecord.substring(delim + 1);

                    arrRecord.push(
                        GS.decodeFromTabDelimited(strCell, strNullString)
                    );

                    col_i += 1;
                }

                //record_i = 0;
                //record_len = strRecord.length;
                //strCell = "";
                //arrRecord = [];
                //while (record_i < record_len) {
                //    strChar = strRecord[record_i];

                //    if (strChar === "\t") {
                //        arrRecord.push(
                //            GS.decodeFromTabDelimited(strCell, strNullString)
                //        );
                //        strCell = "";
                //    } else {
                //        strCell += strChar;
                //    }
                //    record_i += 1;
                //}
                //arrRecord.push(strCell);

                // create record JSON from the cell array
                col_i = 0;
                col_len = arrRecord.length;
                jsnRecord = {};
                while (col_i < col_len) {
                    jsnRecord[arrColumnNames[col_i]] = arrRecord[col_i];
                    col_i += 1;
                }

                strRecord = strDataTemplate;

                // template with JSON
                strRecord = templateFunc({
                    'qs': jsnQS,
                    'row': jsnRecord,
                    'arrRow': arrRecord,
                    'index': i,
                    'len': intTotalRecords
                });
                //console.log(strRecord)
                //// replace the css tokens so the cells are in the right place
                //col_i = fromColumn;
                //col_len = toColumn;
                //intCellLeft = intCellOriginLeft;
                //while (col_i < col_len) {
                //    // if the column is not hidden
                //    if (arrColumnWidths[col_i] > 0) {
                //        //strCSS = (
                //        //    'top:' + intRecordTop + 'px;' +
                //        //    'left:' + intCellLeft + 'px;' +
                //        //    'width:' + (
                //        //        arrColumnWidths[col_i] +
                //        //        columnBorderWidth
                //        //    ) + 'px;' +
                //        //    'height:' + (
                //        //        arrRecordHeights[i] +
                //        //        recordBorderHeight
                //        //    ) + 'px;'
                //        //);
                //        strCSS = '';

                //        strRecord = strRecord.replace(
                //            '$$CSSREPLACETOKEN$$',
                //            strCSS
                //        );

                //        intCellLeft += arrColumnWidths[col_i];
                //        intCellLeft += columnBorderWidth;
                //    }
                //    col_i += 1;
                //}

                // append record to html
                strHTML += strRecord;

                //// increment record top so that the next record
                ////      shows below this one
                //intRecordTop += arrRecordHeights[i];
                //intRecordTop += recordBorderHeight;
                i += 1;
            }
        }

        // because we prevent templating into other element's templates (the
        //      ones with a "src" attribute) by "hiding" (by replacing them
        //      with a random token and storing the token-template relationship)
        //      them, we have to "show" them (by replacing the token with the
        //      original template strings) at this step
        strHTML = GS.templateShowSubTemplates(
            strHTML,
            element.internalTemplates.record
        );

        //// we need to use the dimensions of the header, record selectors and
        ////      the insert record, so we'll stick them in these variables for
        ////      easy access
        //var intHeaderHeight;
        //var intRecordSelectorWidth;
        //var intInsertRecordHeight;

        //intHeaderHeight = element.internalDisplay.headerHeight;
        //intRecordSelectorWidth = element.internalDisplay.recordSelectorWidth;
        //intInsertRecordHeight = element.internalDisplay.insertRecordHeight;

        // if there's a header: build column headings (second so that they're
        //      above cells)
        if (strHeaderTemplate) {
            strRecord = strHeaderTemplate;

            //col_i = fromColumn;
            //col_len = toColumn;
            //intCellLeft = intCellOriginLeft;
            //while (col_i < col_len) {
            //    // if the column is not hidden
            //    if (arrColumnWidths[col_i] > 0) {
            //        //strCSS = (
            //        //    'top:0;' +
            //        //    'left:' + intCellLeft + 'px;' +
            //        //    'width:' + (
            //        //        arrColumnWidths[col_i] +
            //        //        columnBorderWidth
            //        //    ) + 'px;' +
            //        //    'height:' + (
            //        //        intHeaderHeight +
            //        //        intHeaderBorderHeight
            //        //    ) + 'px;'
            //        //);
            //        strCSS = '';

            //        strRecord = strRecord.replace(
            //            '$$CSSREPLACETOKEN$$',
            //            strCSS
            //        );

            //        intCellLeft += arrColumnWidths[col_i];
            //        intCellLeft += columnBorderWidth;
            //    }
            //    col_i += 1;
            //}

            strRecord = handleHeaderTemplateTokens(
                element,
                strRecord,
                fromColumn,
                toColumn
            );

            strHTML += strRecord;
        }

        // because we prevent templating into other element's templates (the
        //      ones with a "src" attribute) by "hiding" (by replacing them
        //      with a random token and storing the token-template relationship)
        //      them, we have to "show" them (by replacing the token with the
        //      original template strings) at this step
        strHTML = GS.templateShowSubTemplates(
            strHTML,
            element.internalTemplates.record
        );

        // if there's a insert record: build it and append to HTML
        if (strInsertTemplate) {
            strRecord = strInsertTemplate;

            // template insert record with querystring
            strRecord = GS.templateWithQuerystring(strInsertTemplate);

            strRecord = GS.templateShowSubTemplates(
                strRecord,
                element.internalTemplates.insertRecord
            );

            //col_i = fromColumn;
            //col_len = toColumn;
            //intCellLeft = intCellOriginLeft;
            //while (col_i < col_len) {
            //    // if the column is not hidden
            //    if (arrColumnWidths[col_i] > 0) {
            //        //strCSS = (
            //        //    'top:' + intRecordTop + 'px;' +
            //        //    'left:' + intCellLeft + 'px;' +
            //        //    'width:' + (
            //        //        arrColumnWidths[col_i] +
            //        //        columnBorderWidth
            //        //    ) + 'px;' +
            //        //    'height:' + (
            //        //        intInsertRecordHeight +
            //        //        intInsertRecordBorderHeight
            //        //    ) + 'px;'
            //        //);
            //        strCSS = '';

            //        strRecord = strRecord.replace(
            //            '$$CSSREPLACETOKEN$$',
            //            strCSS
            //        );

            //        intCellLeft += arrColumnWidths[col_i];
            //        intCellLeft += columnBorderWidth;
            //    }
            //    col_i += 1;
            //}

            strHTML += strRecord;
        }

        // if record selectors haven't been disabled: build record selectors
        //      (third so that they're above cells)
        if (!element.hasAttribute('no-record-selector')) {
            if (element.getAttribute('update-dialog') === 'show') {
                i = fromRecord;
                len = toRecord;
                //intRecordTop = intRecordOriginTop;
                while (i < len) {
                    //strCSS = '';

                    strHTML += (
                        '<gs-cell class="table-record-selector multi-update" ' +
                        //'    style="' + strCSS + '" ' +
                        '    data-row-number="' + i + '" ' +
                        '    data-col="selector" ' +
                        '    title="Record #' + (i + 1) + '">' +
                        '    <div class="table-multi-update-button"></div>' +
                        '</gs-cell>'
                    );

                    //intRecordTop += arrRecordHeights[i];
                    //intRecordTop += recordBorderHeight;
                    i += 1;
                }
            } else {
                i = fromRecord;
                len = toRecord;
                //intRecordTop = intRecordOriginTop;
                while (i < len) {
                    //strCSS = (
                    //    'top:' + intRecordTop + 'px;' +
                    //    'left:0;' +
                    //    'width:' + (
                    //        intRecordSelectorWidth +
                    //        intRecordSelectorBorderWidth
                    //    ) + 'px;' +
                    //    'height:' + (
                    //        arrRecordHeights[i] +
                    //        recordBorderHeight
                    //    ) + 'px;'
                    //);

                    strHTML += (
                        '<gs-cell class="table-record-selector" ' +
                        //'    style="' + strCSS + '" ' +
                        '    data-row-number="' + i + '" ' +
                        '    data-col="selector" ' +
                        '    title="Record #' + (i + 1) + '">' +
                        (i + 1) +
                        '</gs-cell>'
                    );

                    //intRecordTop += arrRecordHeights[i];
                    //intRecordTop += recordBorderHeight;
                    i += 1;
                }
            }
        }

        // if there's an insert record and record selectors haven't been
        //      disabled: build top-left/select all cell (forth so that it's
        //      above record selectors)
        if (strInsertTemplate && !element.hasAttribute('no-record-selector')) {
            //strCSS = (
            //    'top:' + intRecordTop + 'px;' +
            //    'left:0;' +
            //    'width:' + (
            //        intRecordSelectorWidth +
            //        intRecordSelectorBorderWidth
            //    ) + 'px;' +
            //    'height:' + (
            //        intInsertRecordHeight +
            //        intInsertRecordBorderHeight
            //    ) + 'px;'// +
            //    //'line-height:' + (   <-- used with &gt;
            //    //    intInsertRecordHeight +
            //    //    intInsertRecordBorderHeight
            //    //) + 'px;'
            //);

            strHTML += (
                '<gs-cell class="table-insert-selector"' +
                    //' style="' + strCSS + '"' +
                    ' data-row-number="insert"' +
                    ' data-col="selector">*</gs-cell>' //&gt;
            );
        }

        // if there's a header and record selectors haven't been disabled: build
        //      top-left/select all cell (last so that it's above all)
        if (strHeaderTemplate && !element.hasAttribute('no-record-selector')) {
            //strCSS = (
            //    'top:0;' +
            //    'left:0;' +
            //    'width:' + (
            //        intRecordSelectorWidth +
            //        intRecordSelectorBorderWidth
            //    ) + 'px;' +
            //    'height:' + (
            //        intHeaderHeight +
            //        intHeaderBorderHeight
            //    ) + 'px;' +
            //    'line-height:' + (
            //        intHeaderHeight +
            //        intHeaderBorderHeight
            //    ) + 'px;'
            //);

            strHTML += (
                '<gs-cell class="table-all-selector"' +
                    //' style="' + strCSS + '"' +
                    ' data-col="selector">#</gs-cell>'
            );
        }

        // if there's no data, lets tell the user
        if (element.internalData.records.length === 0) {
            strHTML += '<div class="no-data-label">No Data</div>';
        }

        // we want to give the user some feedback about their scrolling position
        //      so, we'll add shadows on sides that have room to scroll in how
        //      this'll need to work is we'll need to add a shadow element at a
        //      z-index above cells but below record selectors, the all selector
        //      and header cells
        //// ### NEED CODING ###
        //strHTML += window.separate1js_html(element);

        // fill the data viewport with the rendered cells

        // version 1
        //element.elems.dataViewport.innerHTML = strHTML;

        // version 2
        //element.elems.dataContainer.removeChild(element.elems.dataViewport);
        //element.elems.dataViewport = '';
        //element.elems.dataViewport.innerHTML = strHTML;
        //element.elems.dataContainer.appendChild(
        //    element.elems.dataViewport
        //);

        // version 3
        element.elems.dataContainer.removeChild(element.elems.dataViewport);
        i = 0;
        len = element.elems.dataViewport.children.length;
        while (i < len) {
            element.elems.dataViewport.removeChild(
                element.elems.dataViewport.lastChild
            );
            i += 1;
        }
        element.elems.dataViewport.innerHTML = strHTML;
        element.elems.dataContainer.appendChild(
            element.elems.dataViewport
        );

        //// version 4
        //var newViewport = element.elems.dataViewport.cloneNode(false);

        //newViewport.innerHTML = strHTML;
        //element.elems.dataContainer.replaceChild(
        //    newViewport,
        //    element.elems.dataViewport
        //);


        //element.elems.dataViewport = newViewport;

        // fill insert columns with retained values
        arrElements = tblQry(
            element.elems.dataViewport,
            '.table-insert [column]'
        );
        col_i = 0;
        col_len = arrElements.length;
        while (col_i < col_len) {
            strColumn = arrElements[col_i].getAttribute('column');
            strValue = element.internalData.insertRecord[strColumn];

            // if a value was retained for the current column
            if (strValue) {
                // fill control with retained value
                arrElements[col_i].value = strValue;
            }
            col_i += 1;
        }

        // render cell selection
        renderSelection(element);

        // if there is only one cell control selected and there is a text
        //      selection that has been saved: restore the text selection
        //      in the new control
        if (
            selectedCellControl &&
            (
                textSelectionStart > 0 ||
                textSelectionEnd > 0
            )
        ) {
            jsnRange = element.internalSelection.ranges[0];

            if (jsnRange) {
                selectedCellControl = tblQry(
                    element,
                    (
                        'gs-cell' +
                        '[data-col-number="' + jsnRange.start.column + '"]' +
                        '[data-row-number="' + jsnRange.start.row + '"]' +
                        ' input'
                    )
                )[0];

                //console.log(selectedCellControl);

                if (selectedCellControl) {
                    //selectedCellControl.setSelectionRange(
                    //    textSelectionStart,
                    //    textSelectionEnd
                    //);
                    GS.setInputSelection(
                        selectedCellControl,
                        textSelectionStart,
                        textSelectionEnd
                    );
                }
            }
        }
    }

    // when you are scrolling, a lot of elements don't leave the screen. So,
    //      this function removes the elements that are no longer visible and
    //      then creates elements that are not visible based on the viewport.
    function renderLocationPartial(element) {
        //var arrColumnWidths;
        //var arrRecordHeights;
        //var columnBorderWidth;
        //var recordBorderHeight;
        //var intRecordSelectorBorderWidth;
        //var intInsertRecordBorderHeight;
        //var intHeaderBorderHeight;

        var strRow;
        var strCol;

        var jsnOldRange;
        var jsnRange;
        var fromColumn;
        var toColumn;
        var fromRecord;
        var toRecord;
        var bolInsertRecord;

        //var intCellOriginLeft;
        //var intRecordOriginTop;
        //var intCellLeft;
        //var intCellTop;

        var arrColumnNames;
        var jsnQS;
        var intTotalRecords;
        var strNullString;

        var intRowNumber;
        var intColNumber;

        //var arrColumnLeft;
        //var arrRecordTop;

        var arrElements;
        var strColumn;
        var strValue;

        var bolUp;
        var bolDown;
        var bolInsert;
        var bolLeft;
        var bolRight;

        var i;
        var len;
        var arrCell;
        var cell;
        var cell_i;
        var cell_len;
        var col_i;
        var col_len;
        //var row_i;
        //var row_len;

        var strDownTemplate;
        var strUpTemplate;
        var strInsertTemplate;
        var strLeftHeaderTemplate;
        var strLeftRecordTemplate;
        var strLeftInsertTemplate;
        var strRightHeaderTemplate;
        var strRightRecordTemplate;
        var strRightInsertTemplate;

        var strHTML;
        var cellElement;

        //// save column widths and record heights for easy access
        //arrColumnWidths = element.internalDisplay.columnWidths;
        //arrRecordHeights = element.internalDisplay.recordHeights;

        //// we needs the border dimensions to calculate true locations
        //columnBorderWidth = element.internalDisplay.columnBorderWidth;
        //recordBorderHeight = element.internalDisplay.recordBorderHeight;

        //// we need to know the border sizes so that we can calculate cell
        ////      dimensions
        //intRecordSelectorBorderWidth = (
        //    element.internalDisplay.recordSelectorBorderWidth
        //);
        //intInsertRecordBorderHeight = (
        //    element.internalDisplay.insertRecordBorderHeight
        //);
        //intHeaderBorderHeight = (
        //    element.internalDisplay.headerBorderHeight
        //);

        // save the column name array for quick and easy access
        arrColumnNames = element.internalData.columnNames;

        // we want the records to have access to the "qs" variable, so we'll
        //      save the query string JSON to a variable so that we only have
        //      to get it once
        jsnQS = GS.qryToJSON(GS.getQueryString());

        // we want the user to be able to have access to the total number of
        //      records in their template so we'll save it to a variable so
        //      that we don't need to recalculate
        intTotalRecords = element.internalData.records.length;

        // we want the null string to be configurable, so we'll read the
        //      "null-string" attribute to get the null string
        strNullString = element.getAttribute('null-string');

        //// we need to use the dimensions of the header, record selectors and
        ////      the insert record, so we'll stick them in these variables for
        ////      easy access
        //var intHeaderHeight;
        //var intRecordSelectorWidth;
        //var intInsertRecordHeight;

        //intHeaderHeight = element.internalDisplay.headerHeight;
        //intRecordSelectorWidth = element.internalDisplay.recordSelectorWidth;
        //intInsertRecordHeight = element.internalDisplay.insertRecordHeight;

        // get old visible range
        jsnOldRange = element.internalDisplay.prevRange;

        // get visible range
        jsnRange = element.internalDisplay.currentRange;
        //intCellOriginLeft = jsnRange.originLeft;
        //intRecordOriginTop = jsnRange.originTop;
        fromColumn = jsnRange.fromColumn;
        toColumn = jsnRange.toColumn;
        fromRecord = jsnRange.fromRecord;
        toRecord = jsnRange.toRecord;
        bolInsertRecord = jsnRange.insertRecord;

        // we create a record selector in multiple places, so to prevent code
        //      duplication, we'll use a function
        var createRecordSelector;

        // sometimes, the developer decide that record selectors are not what
        //      they want, in that case, don't create them
        if (element.hasAttribute('no-record-selector')) {
            createRecordSelector = function () {};
        } else {
            createRecordSelector = function (index) {
                cellElement = document.createElement('gs-cell');
                //cellElement.style.width = (
                //    (
                //        intRecordSelectorWidth +
                //        intRecordSelectorBorderWidth
                //    ) + 'px'
                //);
                //cellElement.style.height = (
                //    (
                //        arrRecordHeights[index] +
                //        recordBorderHeight
                //    ) + 'px'
                //);
                cellElement.classList.add('table-record-selector');
                cellElement.setAttribute('data-row-number', index);
                cellElement.setAttribute('data-col', 'selector');
                cellElement.setAttribute('title', 'Record #' + (index + 1));

                if (element.getAttribute('update-dialog') === 'show') {
                    cellElement.classList.add('multi-update');
                    cellElement.innerHTML = (
                        '<div class="table-multi-update-button"></div>'
                    );
                } else {
                    cellElement.textContent = (index + 1);
                }

                element.elems.dataViewport.appendChild(cellElement);
            };
        }

        // we create a record in multiple places, so to prevent code
        //      duplication, we'll use a function
        var createRecord = function (strTemplate, index) {
            var strRecord;
            var arrRecord;
            var jsnRecord;
            //var strCell;
            //var strChar;
            //var record_i;
            //var record_len;
            var strCell;
            var delim;
            var cel_i;
            var cel_len;

            // get text of the record data
            strRecord = element.internalData.records[index] + '\t';

            // create cell array for this record
            arrRecord = [];
            //console.log(element.internalData.columnNames.length);
            cel_i = 0;
            cel_len = element.internalData.columnNames.length;//9999;
            while (cel_i < cel_len) {
                delim = strRecord.indexOf('\t');
                strCell = strRecord.substring(0, delim);
                strRecord = strRecord.substring(delim + 1);

                //if (strCell !== '' || strRecord !== '') {
                arrRecord.push(
                    GS.decodeFromTabDelimited(strCell, strNullString)
                );
                //} else {
                //    break;
                //}

                cel_i += 1;
            }

            //record_i = 0;
            //record_len = strRecord.length;
            //strCell = "";
            //arrRecord = [];
            //while (record_i < record_len) {
            //    strChar = strRecord[record_i];

            //    if (strChar === "\t") {
            //        arrRecord.push(
            //            GS.decodeFromTabDelimited(strCell, strNullString)
            //        );
            //        strCell = "";
            //    } else {
            //        strCell += strChar;
            //    }
            //    record_i += 1;
            //}
            //arrRecord.push(strCell);

            // create record JSON from the cell array
            // the reason we want JSON is so that the template can easily
            //      reference things by column name
            col_i = 0;
            col_len = arrRecord.length;
            jsnRecord = {};
            while (col_i < col_len) {
                jsnRecord[arrColumnNames[col_i]] = arrRecord[col_i];
                col_i += 1;
            }

            // template with JSON - in the future, we need to change this to
            //      use the dot.js once for all the cells because templating
            //      each record individually is slow ### NEED CODING ###
            strRecord = (
                '{{' +
                    'var row_number = jo.index + 1;' +
                    'var qs = jo.qs;' +
                    'var row = jo.row;' +
                    'var arrRow = jo.arrRow;' +
                    'var i = jo.index;' +
                    'var len = jo.len;' +
                '}}' +
                strTemplate
            );

            strRecord = doT.template(strRecord)({
                'qs': jsnQS,
                'row': jsnRecord,
                'arrRow': arrRecord,
                'index': index,
                'len': intTotalRecords
            });

            //console.log(strRecord);

            // return record html
            return strRecord;
        };

        var createNonDataCells = function (strTemplate, jsnTemplate) {
            var strRecord;

            //// replace the css tokens so the cells are in the right place
            //strRecord = strTemplate.replace(/\$\$CSSREPLACETOKEN\$\$/gi, '');
            strRecord = strTemplate;

            // template with JSON - in the future, we need to change this to
            //      use the dot.js once for all the cells because templating
            //      each record individually is slow ### NEED CODING ###
            strRecord = '{{ var qs = jo.qs; }}' + strRecord;

            strRecord = doT.template(strRecord)({'qs': jsnQS});
            if (jsnTemplate) {
                strRecord = GS.templateShowSubTemplates(strRecord, jsnTemplate);
            }

            //console.log(strRecord);

            // return record html
            return strRecord;
        };


        // steps:
        //      remove all cells that are not in the current range
        //      create data cells
        //      create headers
        //      create record selectors
        //      create insert record cells
        //      calculate left and top values
        //      reposition all the cells to their correct locations



        // loop through the cells, if the current cell is not in the current
        //      viewport range, delete it
        var arrDoomed = [];
        arrCell = tblQryKids(
            element.elems.dataViewport,
            '[data-row-number], [data-col-number]'
        );
        cell_i = 0;
        cell_len = arrCell.length;
        while (cell_i < cell_len) {
            cell = arrCell[cell_i];
            strRow = cell.getAttribute('data-row-number');
            strCol = cell.getAttribute('data-col-number');
            intRowNumber = parseInt(strRow, 10);
            intColNumber = parseInt(strCol, 10);

            if (
                intColNumber < fromColumn ||
                intRowNumber < fromRecord ||
                // toColumn is the index of the column after the last visible
                //      column, hence the equal. This fixes the issue of the
                //      partial render not removing the last record
                //      occasionally while scrolling
                intColNumber >= toColumn ||
                // toRecord is the index of the record after the last visible
                //      record, hence the equal. This fixes the issue of the
                //      partial render not removing the last record
                //      occasionally while scrolling
                intRowNumber >= toRecord ||
                (
                    bolInsertRecord === false &&
                    strRow === 'insert'
                )
            ) {
                arrDoomed.push(arrCell[cell_i]);
                //element.elems.dataViewport.removeChild(arrCell[cell_i]);
            }

            cell_i += 1;
        }

        var deleteNext = function () {
            //element.elems.dataViewport.removeChild(arrDoomed.pop());
            //if (arrDoomed.length > 0) {
            //    requestAnimationFrame(deleteNext);
            //}

            cell_i = 0;
            cell_len = arrDoomed.length;
            while (cell_i < cell_len) {
                if (
                    arrDoomed[cell_i].parentNode === element.elems.dataViewport
                ) {
                    element.elems.dataViewport.removeChild(arrDoomed[cell_i]);
                }
                cell_i += 1;
            }
        };
        if (window.requestAnimationFrame) {
            window.requestAnimationFrame(deleteNext);
        } else {
            deleteNext();
        }

        // create data cells
        // create headers
        // create record selectors
        // create insert record cells

        // because you can scroll on the X and Y axis at the same time:
        //      we need to know what columns and what rows to create and in
        //      what directions
        // find out what directions to create cells in
        bolUp = (
            fromRecord < jsnOldRange.fromRecord
        );
        bolDown = (
            toRecord > jsnOldRange.toRecord
        );
        bolInsert = (
            bolInsertRecord === true &&
            bolInsertRecord !== jsnOldRange.insertRecord
        );
        bolLeft = (
            fromColumn < jsnOldRange.fromColumn
        );
        bolRight = (
            toColumn > jsnOldRange.toColumn
        );

        //console.log(jsnOldRange, jsnRange);
        //console.log(
        //    'Up: ' + bolUp,
        //    'Down: ' + bolDown,
        //    'Left: ' + bolLeft,
        //    'Right: ' + bolRight
        //);

        // if we need to create records, get a record template
        if (bolUp || bolDown) {
            // we only want to template the columns that fall into the range of
            //      fromColumn->toColumn, so we'll stick the record template
            //      HTML into a template element, yank out the desired cells and
            //      that'll be the html we template with
            if (element.internalTemplates.record.templateHTML.trim()) {
                strUpTemplate = templateExtractVisibleCellRange(
                    element,
                    element.internalTemplates.record.templateHTML,
                    fromColumn,
                    toColumn
                );

                //// replace the css tokens so that they don't interfere
                //strUpTemplate = (
                //    strUpTemplate
                //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                //);

                // for now, the down and up templates are exactly the same. we
                //      could use one variable for the down and up templates,
                //      but, in the future, there may be reason to separate
                //      them. so, I'm just going to copy the up template into
                //      the down template variable
                strDownTemplate = strUpTemplate;
            }

            //console.log(strDownTemplate, strUpTemplate);
        }

        // if we need columns on the left, get the template
        if (bolLeft) {
            // we only want to template the columns that fall into the range of
            //      fromColumn->toColumn, so we'll stick the record template
            //      HTML into a template element, yank out the desired cells and
            //      that'll be the html we template with (and we'll repeat this
            //      process for the header and insert columns)

            // header cells
            if (element.internalTemplates.header.trim()) {
                strLeftHeaderTemplate = templateExtractVisibleCellRange(
                    element,
                    element.internalTemplates.header,
                    jsnRange.fromColumn,
                    jsnOldRange.fromColumn
                );
                strLeftHeaderTemplate = handleHeaderTemplateTokens(
                    element,
                    strLeftHeaderTemplate,
                    jsnRange.fromColumn,
                    jsnOldRange.fromColumn
                );
                //// replace the css tokens so that they don't interfere
                //strLeftHeaderTemplate = (
                //    strLeftHeaderTemplate
                //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                //);
            }
            // record cells
            if (element.internalTemplates.record.templateHTML.trim()) {
                strLeftRecordTemplate = templateExtractVisibleCellRange(
                    element,
                    element.internalTemplates.record.templateHTML,
                    jsnRange.fromColumn,
                    jsnOldRange.fromColumn
                );
                //// replace the css tokens so that they don't interfere
                //strLeftRecordTemplate = (
                //    strLeftRecordTemplate
                //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                //);
            }
            // insert cells
            if (
                // if there is an insert template
                element.internalTemplates.insertRecord.templateHTML.trim() &&
                // if the insert record has already been added
                !bolInsert
            ) {
                strLeftInsertTemplate = templateExtractVisibleCellRange(
                    element,
                    element.internalTemplates.insertRecord.templateHTML,
                    jsnRange.fromColumn,
                    jsnOldRange.fromColumn
                );
                //// replace the css tokens so that they don't interfere
                //strLeftInsertTemplate = (
                //    strLeftInsertTemplate
                //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                //);
            }

            //console.log(
            //    strLeftHeaderTemplate,
            //    strLeftRecordTemplate,
            //    strLeftInsertTemplate
            //);
        }

        // if we need columns on the right, get the template
        if (bolRight) {
            // we only want to template the columns that fall into the range of
            //      fromColumn->toColumn, so we'll stick the record template
            //      HTML into a template element, yank out the desired cells and
            //      that'll be the html we template with (and we'll repeat this
            //      process for the header and insert columns)

            // header cells
            if (element.internalTemplates.header.trim()) {
                strRightHeaderTemplate = templateExtractVisibleCellRange(
                    element,
                    element.internalTemplates.header,
                    jsnOldRange.toColumn,
                    jsnRange.toColumn
                );
                strRightHeaderTemplate = handleHeaderTemplateTokens(
                    element,
                    strRightHeaderTemplate,
                    jsnOldRange.toColumn,
                    jsnRange.toColumn
                );
                //// replace the css tokens so that they don't interfere
                //strRightHeaderTemplate = (
                //    strRightHeaderTemplate
                //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                //);
            }
            // record cells
            if (element.internalTemplates.record.templateHTML.trim()) {
                strRightRecordTemplate = templateExtractVisibleCellRange(
                    element,
                    element.internalTemplates.record.templateHTML,
                    jsnOldRange.toColumn,
                    jsnRange.toColumn
                );
                //// replace the css tokens so that they don't interfere
                //strRightRecordTemplate = (
                //    strRightRecordTemplate
                //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                //);
            }
            // insert cells
            if (
                // if there is an insert template
                element.internalTemplates.insertRecord.templateHTML.trim() &&
                // if the insert record has already been added
                !bolInsert
            ) {
                strRightInsertTemplate = templateExtractVisibleCellRange(
                    element,
                    element.internalTemplates.insertRecord.templateHTML,
                    jsnOldRange.toColumn,
                    jsnRange.toColumn
                );
                //// replace the css tokens so that they don't interfere
                //strRightInsertTemplate = (
                //    strRightInsertTemplate
                //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                //);
            }

            //console.log(
            //    strRightHeaderTemplate,
            //    strRightRecordTemplate,
            //    strRightInsertTemplate
            //);
        }

        // define strHTML as empty so that we can append to it without
        //      the 'undefinedTEXT THAT YOU APPENDED' issue
        strHTML = '';

        // if we need to add cells above the old visible range
        if (bolUp) {
            i = jsnRange.fromRecord;
            len = jsnOldRange.fromRecord;
            while (i < len) {
                // record selector cell
                createRecordSelector(i);

                // record cells
                strHTML += createRecord(strUpTemplate, i);

                i += 1;
            }
        }

        // if we need to add cells below the old visible range
        if (bolDown) {
            i = jsnOldRange.toRecord;
            len = jsnRange.toRecord;
            while (i < len) {
                // record selector cell
                createRecordSelector(i);

                // record cells
                strHTML += createRecord(strDownTemplate, i);

                i += 1;
            }
        }

        // if we need to add the insert record=
        if (bolInsert) {
            strInsertTemplate = '';

            if (!element.hasAttribute('no-record-selector')) {
                strInsertTemplate += (
                    '<gs-cell ' +
                            'class="table-insert-selector"' +
                            ' data-row-number="insert"' +
                            ' data-col="selector">*' + //&gt;
                    '</gs-cell>'
                );
            }

            strInsertTemplate += (
                templateExtractVisibleCellRange(
                    element,
                    element.internalTemplates.insertRecord.templateHTML,
                    jsnRange.fromColumn,
                    jsnRange.toColumn
                )
            );

            //// replace the css tokens so that they don't interfere
            //strInsertTemplate = (
            //    strInsertTemplate
            //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
            //);

            strHTML += createNonDataCells(strInsertTemplate, element.internalTemplates.insertRecord);
        }

        // if we need to add cells to the left of the old visible range
        //      one thing to note is that the up and down templating takes
        //      care of the left and right columns for those records, this
        //      code takes care of the left columns for the existing records
        if (bolLeft) {
            // header cells
            if (strLeftHeaderTemplate) {
                strHTML += createNonDataCells(strLeftHeaderTemplate);
            }

            // record cells
            if (strLeftRecordTemplate) {
                // loop through records that overlap from the old visible
                //      range and the new visible range

                if (bolUp) {
                    i = jsnOldRange.fromRecord;
                    len = jsnRange.toRecord;
                } else if (bolDown) {
                    i = jsnRange.fromRecord;
                    len = jsnOldRange.toRecord;
                } else {
                    i = jsnRange.fromRecord;
                    len = jsnRange.toRecord;
                }

                while (i < len) {
                    strHTML += createRecord(strLeftRecordTemplate, i);

                    i += 1;
                }
            }

            // insert cells
            if (strLeftInsertTemplate) {
                strHTML += createNonDataCells(strLeftInsertTemplate, element.internalTemplates.insertRecord);
            }
        }

        // if we need to add cells to the right of the old visible range
        //      one thing to note is that the up and down templating takes
        //      care of the left and right columns for those records, this
        //      code takes care of the right columns for the existing records
        if (bolRight) {
            // header cells
            if (strRightHeaderTemplate) {
                strHTML += createNonDataCells(strRightHeaderTemplate);
            }

            // record cells
            if (strRightRecordTemplate) {
                // loop through records that overlap from the old visible
                //      range and the new visible range

                if (bolUp) {
                    i = jsnOldRange.fromRecord;
                    len = jsnRange.toRecord;
                } else if (bolDown) {
                    i = jsnRange.fromRecord;
                    len = jsnOldRange.toRecord;
                } else {
                    i = jsnRange.fromRecord;
                    len = jsnRange.toRecord;
                }

                while (i < len) {
                    strHTML += createRecord(strRightRecordTemplate, i);

                    i += 1;
                }
            }

            // insert cells
            if (strRightInsertTemplate) {
                strHTML += createNonDataCells(strRightInsertTemplate, element.internalTemplates.insertRecord);
            }
        }

        // because we prevent templating into other element's templates (the
        //      ones with a "src" attribute) by "hiding" (by replacing them
        //      with a random token and storing the token-template relationship)
        //      them, we have to "show" them (by replacing the token with the
        //      original template strings) at this step
        strHTML = GS.templateShowSubTemplates(
            strHTML,
            element.internalTemplates.record
        );

        //console.log(strHTML);

        // we want to append the html and have the elements to initialize
        //      while in the DOM, so we'll use the recently discovered and
        //      compatible element.insertAdjacentHTML

        // version 2
        //element.elems.dataContainer.removeChild(element.elems.dataViewport);
        //element.elems.dataViewport.insertAdjacentHTML('beforeend', strHTML);
        //element.elems.dataContainer.appendChild(element.elems.dataViewport);

        // version 3
        //var test = document.createElement('div');
        //test.innerHTML = strHTML;
        //element.elems.dataViewport.appendChild(test);

        if (document.createDocumentFragment) {
            // version 4
            var divElement = document.createElement('div');
            var transferFragment = document.createDocumentFragment();
            divElement.innerHTML = strHTML;

            i = 0;
            len = divElement.children.length;
            while (i < len) {
                transferFragment.appendChild(divElement.lastChild);
                i += 1;
            }

            element.elems.dataViewport.appendChild(transferFragment);
        } else {
            // version 1
            element.elems.dataViewport.insertAdjacentHTML('beforeend', strHTML);
        }



        //// calculate left and top values
        //intCellLeft = intCellOriginLeft;
        //arrColumnLeft = [];
        //col_i = fromColumn;
        //col_len = toColumn;
        //while (col_i < col_len) {
        //    arrColumnLeft.push(intCellLeft);

        //    // we don't want the border width of 0 width columns to affect
        //    //      positioning
        //    if (arrColumnWidths[col_i] > 0) {
        //        intCellLeft += arrColumnWidths[col_i];
        //        intCellLeft += columnBorderWidth;
        //    }
        //    col_i += 1;
        //}

        //intCellTop = intRecordOriginTop;
        //arrRecordTop = [];
        //row_i = fromRecord;
        //row_len = toRecord;
        //while (row_i < row_len) {
        //    arrRecordTop.push(intCellTop);

        //    intCellTop += arrRecordHeights[row_i];
        //    intCellTop += recordBorderHeight;
        //    row_i += 1;
        //}

        //// if the insert record is visible, add it's top
        //if (bolInsertRecord === true) {
        //    arrRecordTop.push(intCellTop);

        //    intCellTop += element.internalDisplay.insertRecordHeight;
        //    intCellTop += element.internalDisplay.insertRecordBorderHeight;
        //}

        //// reposition all the cells to their correct locations
        //arrCell = tblQryKids(
        //    element.elems.dataViewport,
        //    'gs-cell'
        //    //'[data-row-number], [data-col-number]'
        //    //      ^- this selector missed the insert and all selector cells
        //);
        //cell_i = 0;
        //cell_len = arrCell.length;
        //while (cell_i < cell_len) {
        //    cell = arrCell[cell_i];
        //    intRowNumber = parseInt(cell.getAttribute('data-row-number'), 10);
        //    intColNumber = parseInt(cell.getAttribute('data-col-number'), 10);

        //    // cell has a column number, set left. we can do this because (for
        //    //      example) header cells dont have a row attribute. the
        //    //      reason we do that is because those cells don't represent
        //    //      a row in the data.
        //    if (!isNaN(intColNumber)) {
        //        cell.style.left = (
        //            arrColumnLeft[intColNumber - fromColumn] + 'px'
        //        );
        //        cell.style.width = (
        //            (
        //                arrColumnWidths[intColNumber] +
        //                columnBorderWidth
        //            ) + 'px'
        //        );

        //    // right now, the only element that won't have a column number
        //    //      will be the record, insert and all selectors
        //    } else {
        //        cell.style.width = (
        //            intRecordSelectorWidth +
        //            intRecordSelectorBorderWidth
        //        ) + 'px';
        //    }

        //    // cell has a row number, set top. we can do this because (for
        //    //      example) header cells dont have a row attribute. the
        //    //      reason we do that is because those cells don't represent
        //    //      a row in the data.
        //    if (!isNaN(intRowNumber)) {
        //        cell.style.top = (
        //            arrRecordTop[intRowNumber - fromRecord] + 'px'
        //        );
        //        cell.style.height = (
        //            (
        //                arrRecordHeights[intRowNumber] +
        //                recordBorderHeight
        //            ) + 'px'
        //        );
        //        //cell.setAttribute(
        //        //    'style',
        //        //    (
        //        //        'top:' + (
        //        //            arrRecordTop[intRowNumber - fromRecord]
        //        //        ) + 'px;' +
        //        //        'height:' + (
        //        //            arrRecordHeights[intRowNumber] +
        //        //            recordBorderHeight
        //        //        ) + 'px;'
        //        //    )
        //        //);

        //    // if the cell is a header cell, set the height
        //    } else if (
        //        cell.classList.contains('table-header') ||
        //        cell.classList.contains('table-all-selector')
        //    ) {
        //        cell.style.height = (
        //            intHeaderHeight +
        //            intHeaderBorderHeight
        //        ) + 'px';
        //        //cell.setAttribute(
        //        //    'style',
        //        //    (
        //        //        'height:' + (
        //        //            intHeaderHeight +
        //        //            intHeaderBorderHeight
        //        //        ) + 'px;'
        //        //    )
        //        //);

        //    // if the cell is a insert cell, set the height
        //    } else if (
        //        cell.classList.contains('table-insert')
        //    ) {
        //        cell.style.top = (
        //            arrRecordTop[arrRecordTop.length - 1] + 'px'
        //        );
        //        cell.style.height = (
        //            intInsertRecordHeight +
        //            intInsertRecordBorderHeight
        //        ) + 'px';
        //        //cell.setAttribute(
        //        //    'style',
        //        //    (
        //        //        'top:' + (
        //        //            arrRecordTop[arrRecordTop.length - 1]
        //        //        ) + 'px;' +
        //        //        'height:' + (
        //        //            intInsertRecordHeight +
        //        //            intInsertRecordBorderHeight
        //        //        ) + 'px;'
        //        //    )
        //        //);

        //    // if the cell is the insert selector, set the height
        //    } else if (
        //        cell.classList.contains('table-insert-selector')
        //    ) {
        //        cell.style.top = (
        //            arrRecordTop[arrRecordTop.length - 1] + 'px'
        //        );
        //        cell.style.left = (0);
        //        cell.style.height = (
        //            intInsertRecordHeight +
        //            intInsertRecordBorderHeight
        //        ) + 'px';

        //        //cell.setAttribute(
        //        //    'style',
        //        //    (
        //        //        'top:' + (
        //        //            arrRecordTop[arrRecordTop.length - 1]
        //        //        ) + 'px;' +
        //        //        'left:0px;' +
        //        //        'height:' + (
        //        //            intInsertRecordHeight +
        //        //            intInsertRecordBorderHeight
        //        //        ) + 'px;'
        //        //    )
        //        //);
        //    }

        //    //if (cell.classList.contains('table-cell')) {
        //    //} else if (cell.classList.contains('table-all-selector')) {
        //    //} else if (cell.classList.contains('table-header')) {
        //    //} else if (cell.classList.contains('table-record-selector')) {
        //    //} else if (cell.classList.contains('table-insert')) {
        //    //} else if (cell.classList.contains('table-insert-selector')) {
        //    //}

        //    cell_i += 1;
        //}

        // fill insert columns with retained values
        arrElements = tblQry(
            element.elems.dataViewport,
            '.table-insert [column]'
        );
        col_i = 0;
        col_len = arrElements.length;
        while (col_i < col_len) {
            strColumn = arrElements[col_i].getAttribute('column');
            strValue = element.internalData.insertRecord[strColumn];

            // if a value was retained for the current column
            if (strValue) {
                // fill control with retained value
                arrElements[col_i].value = strValue;
            }
            col_i += 1;
        }

        // we want to give the user some feedback about their scrolling position
        //      so, we'll add shadows on sides that have room to scroll in how
        //      this'll need to work is we'll need to add a shadow element at a
        //      z-index above cells but below record selectors, the all selector
        //      and header cells
        //// ### NEED CODING ###
        //window.separate1js_elements(element);

        // render cell selection
        renderSelection(element);
    }

    function renderLocation(element) {
        var i;
        var len;

        var intMaximum;
        var intTraversed;
        var intExtremeSide;

        var intViewportWidth;
        var intViewportHeight;

        var jsnOldRange;
        var jsnRange;

        var focusElement;

        // get old visible range so that we can decide if it's economical to do
        //      a full re-render
        jsnOldRange = element.internalDisplay.currentRange;

        // get current visible range so that we can decide if it's economical
        //      to do a full re-render
        jsnRange = getCurrentCellRange(element);

        // save visible range to internal display so that it is cached. the
        //      reason to cache it is so that we can be able to rapidly
        //      retrieve it many times in a row.
        element.internalDisplay.currentRange = jsnRange;

        // the partial render need to know the previous visible range, so here
        //      we cache it
        element.internalDisplay.prevRange = jsnOldRange;

        // we dont want to force a layout by re-rendering the contents and then
        //      asking for the viewport height/width. so we'll make a
        //      convenience variable
        intViewportWidth = (
            element.elems.dataViewport.clientWidth
        );
        intViewportHeight = (
            element.elems.dataViewport.clientHeight
        );

        element.internalDisplay.focus.selectionRange = null;
        if (GS.findParentElement(document.activeElement, element) === element) {
            // we want to save the text selection of the current
            //      control before we do the render
            if (
                element.internalDisplay.focus.latest &&
                (
                    document.activeElement.nodeName === 'INPUT' ||
                    document.activeElement.nodeName === 'TEXTAREA'
                )
            ) {
                element.internalDisplay.focus.selectionRange = (
                    GS.getInputSelection(document.activeElement)
                );
            }
        }
        ////console.log(element.internalDisplay.focus.selectionRange);

        // we want to either do a full re-render or a partial re-render
        if (intViewportHeight < 3 || intViewportWidth < 3) {
            //console.log('Empty');
            renderEmpty(element);
        } else if (
            // if the internal display says we need to do a full re-render
            element.internalDisplay.fullRenderRequired === true ||

            // or if there is no previous cell range
            jsnOldRange.fromRecord === undefined ||

            // or if the current range has no overlap with the old range
            jsnRange.fromRecord > jsnOldRange.toRecord ||
            jsnRange.fromColumn > jsnOldRange.toColumn ||
            jsnRange.toRecord < jsnOldRange.fromRecord ||
            jsnRange.toColumn < jsnOldRange.fromColumn
        ) {
            //console.log('Full');
            renderLocationFull(element);
        } else {
            //console.log('Partial');
            renderLocationPartial(element);
        }

        // reset full render indicator
        element.internalDisplay.fullRenderRequired = false;

        // generate positioning CSS
        // clear old CSS
        element.elems.cellPositionStyle.innerHTML = '';

        var intCellLeft = 0;
        var intCellTop = 0;
        var intColumnWidth;

        var strNodeName;
        var arrColumnWidths = element.internalDisplay.columnWidths;
        var arrRecordHeights = element.internalDisplay.recordHeights;
        var columnBorderWidth = element.internalDisplay.columnBorderWidth;
        var recordBorderHeight = element.internalDisplay.recordBorderHeight;
        var strCSS = '';
        var strCell = (
            '#' + element.getAttribute('id') + ' .table-data-viewport gs-cell'
        );

        // calculate left and top values
        intCellLeft = jsnRange.originLeft;
        i = jsnRange.fromColumn;
        len = jsnRange.toColumn;
        while (i < len) {
            intColumnWidth = arrColumnWidths[i];

            // only add to CSS and increment left variable if column is not
            //      hidden
            if (intColumnWidth > 0) {
                strCSS += (
                    strCell + '[data-col-number="' + i + '"] {' +
                    'left:' + intCellLeft + 'px;' +
                    'width:' + (
                        intColumnWidth + columnBorderWidth
                    ) + 'px;' +
                    '}'
                );

                // we don't want the border width of 0 width columns to affect
                //      positioning
                intCellLeft += (intColumnWidth + columnBorderWidth);
            }
            i += 1;
        }

        intCellTop = jsnRange.originTop;
        i = jsnRange.fromRecord;
        len = jsnRange.toRecord;
        while (i < len) {
            strCSS += (
                strCell + '[data-row-number="' + i + '"] {' +
                'top:' + intCellTop + 'px;' +
                'height:' + (
                    arrRecordHeights[i] + recordBorderHeight
                ) + 'px;' +
                '}'
            );

            intCellTop += (arrRecordHeights[i] + recordBorderHeight);
            i += 1;
        }

        // if the insert record is visible, add it's top
        if (element.internalDisplay.insertRecordVisible) {
            strCSS += (
                strCell + '[data-row-number="insert"] {' +
                'top:' + intCellTop + 'px;' +
                'height:' + (
                    element.internalDisplay.insertRecordHeight +
                    element.internalDisplay.insertRecordBorderHeight
                ) + 'px;' +
                '}'
            );

            //intCellTop += element.internalDisplay.insertRecordHeight;
            //intCellTop += element.internalDisplay.insertRecordBorderHeight;
        }

        strCSS += (
            strCell + '[data-col="selector"] {' +
            'left:0px;' +
            'width:' + (
                element.internalDisplay.recordSelectorWidth +
                element.internalDisplay.recordSelectorBorderWidth
            ) + 'px;' +
            '}' +

            strCell + '.table-all-selector,' +
            strCell + '.table-header {' +
            'top:0px;' +
            'height:' + (
                element.internalDisplay.headerHeight +
                element.internalDisplay.headerBorderHeight
            ) + 'px;' +
            '}'
        );

        element.elems.cellPositionStyle.innerHTML = strCSS;


        // turn the visible range into two arrays of drag handle points, one for
        //      horizontal, one for vertical. This is used by the cell resize
        //      code so that it can tell where the cell resize handles are.

        // we need to clear out any old values in the handle lists
        element.internalDisplay.columnHandles = [];
        element.internalDisplay.recordHandles = [];

        // find out the maximum position for a column resize handle
        intMaximum = (
            (
                intViewportWidth -
                element.internalScrollOffsets.right
            ) +
            // allow room for handle that's right at the right edge, this is
            //      useful when a column is full width
            3
        );

        // add record selector to column handle list if it's visible, the reason
        //      it's first is because the cell resize code depends it being
        //      first if recordSelectorVisible is true
        if (element.internalDisplay.recordSelectorVisible === true) {
            element.internalDisplay.columnHandles.push(
                element.internalScrollOffsets.left
            );
        }

        // add displayed columns to column handle list
        intTraversed = jsnRange.originLeft;//0;
        i = jsnRange.fromColumn;
        len = jsnRange.toColumn;
        while (i < len) {
            // we want to add the right side of the column unless the right side
            //      is off of the viewport or is obscured by the right offset
            //      so, we'll put the right side into a variable and we'll build
            //      up a record width variable that we can use to determine if
            //      the right side would be too far
            if (element.internalDisplay.columnWidths[i] === 0) {
                intExtremeSide = 0;
            } else {
                intExtremeSide = (
                    element.internalDisplay.columnWidths[i] +
                    element.internalDisplay.columnBorderWidth
                );
            }

            //if (intTraversed <= 0 && intExtremeSide > 0) {
            //    intExtremeSide += jsnRange.originLeft;
            //}
            intTraversed += intExtremeSide;

            //console.log(
            //    intTraversed,
            //    element.internalScrollOffsets.left,
            //    intExtremeSide,
            //    jsnRange.originLeft
            //);

            if (intTraversed < intMaximum) {
                // if column is hidden, push null handle so that the array
                //      indexes still line up with the column numbers
                if (
                    intExtremeSide === 0 ||
                    intTraversed <= element.internalScrollOffsets.left
                ) {
                    element.internalDisplay.columnHandles.push(null);
                } else {
                    element.internalDisplay.columnHandles.push(intTraversed);
                }
            } else {
                break;
            }

            i += 1;
        }

        // now, we add the records to the record handle list

        // find out the maximum position for a record resize handle
        intMaximum = (
            intViewportHeight -
            element.internalScrollOffsets.bottom
        );

        // add header to record handle list if it's visible, the reason it's
        //      first is because the cell resize code depends it being first
        //      if headerVisible is true
        if (element.internalDisplay.headerVisible === true) {
            element.internalDisplay.recordHandles.push(
                element.internalScrollOffsets.top
            );
        }

        // add displayed records to record handle list
        intTraversed = 0;
        i = jsnRange.fromRecord;
        len = jsnRange.toRecord;
        while (i < len) {
            // we want to add the bottom side of the record unless the bottom
            //      side is off of the viewport or is obscured by the bottom
            //      offset so, we'll put the bottom side into a variable and
            //      we'll build up a record width variable that we can use to
            //      determine if the bottom side would be too far
            intExtremeSide = (
                element.internalDisplay.recordHeights[i]
            );

            if (intTraversed <= 0) {
                intExtremeSide += (
                    jsnRange.originTop
                );
            }
            intTraversed += intExtremeSide;

            if (intTraversed < intMaximum) {
                element.internalDisplay.recordHandles.push(intTraversed);
            } else {
                break;
            }

            // we wanted the cursor to appear a little higher
            intTraversed += element.internalDisplay.recordBorderHeight;

            i += 1;
        }

        // add the insert record to record handle list if it's visible, the
        //      reason it's last is because the cell resize code depends it
        //      being last if insertRecordVisible is true
        if (
            element.internalDisplay.insertRecordVisible === true &&
            jsnRange
        ) {
            element.internalDisplay.recordHandles.push(
                element.internalDisplay.insertRecordHeight +
                intTraversed
            );
        }

        // commented out because throttling scrolling makes scrolling choppy,
        //      other avenues of speed improvement will need to be attempted
        //// we needed to throttle the location rendering to increase speed
        ////      next, we want to look into only replacing elements that
        ////      need to be replaced as and just moving the rest (and if
        ////      that improves the speed enough, we can remove the throttling)
        //if (element.internalTimerIDs.renderLocation) {
        //    clearTimeout(element.internalTimerIDs.renderLocation);
        //}
        //element.internalTimerIDs.renderLocation = setTimeout(function() {
        //    renderLocationFull(element);
        //    element.internalTimerIDs.renderLocation = null;
        //}, 5);

        // we maintain the last focused control, if the last focused control
        //      is in the DOM, we want to focus it

        if (
            // this does two things for us:
            //      "latest" starts out null so this prevents us trying to
            //              focus when we haven't ever had the focus
            //      "latest" is false when the control has lost it's focus
            //              so this prevents wasting effort on trying to
            //              focus if the control is already focused
            element.internalDisplay.focus.latest === false &&

            // touch devices are jarring if you're not expecting focus,
            //      because they pop up the keyboard. So, don't
            //      automatically refocus if touch.
            !evt.touchDevice &&

            // we only want to try to re-focus if the cell is in the current
            //      range. in the future, we may end up adding the cell if
            //      it's not currently rendered.
            !isNaN(element.internalDisplay.focus.row) &&
            !isNaN(element.internalDisplay.focus.column) &&
            element.internalDisplay.focus.row >= jsnRange.fromRecord &&
            element.internalDisplay.focus.row <= jsnRange.toRecord &&
            element.internalDisplay.focus.column >= jsnRange.fromColumn &&
            element.internalDisplay.focus.column <= jsnRange.toColumn
        ) {
            strNodeName = (
                element.internalDisplay.focus.nodeName ||
                ''
            );
            focusElement = tblQry(
                element.elems.dataViewport,
                (
                    'gs-cell' +
                    '[data-col-number="' +
                        element.internalDisplay.focus.column +
                    '"]' +
                    '[data-row-number="' +
                        element.internalDisplay.focus.row +
                    '"] ' +
                    strNodeName.toLowerCase()
                )
            )[0];

            if (focusElement) {
                focusElement.focus();

                if (
                    element.internalDisplay.focus.selectionRange &&
                    (
                        focusElement.nodeName === 'INPUT' ||
                        focusElement.nodeName === 'TEXTAREA'
                    ) &&
                    focusElement.getAttribute('type') !== 'file'
                ) {
                    GS.setInputSelection(
                        focusElement,
                        element.internalDisplay.focus.selectionRange.start,
                        element.internalDisplay.focus.selectionRange.end
                    );
                }
            }
        }
    }

    // we need to be able to update the scrollbar location programatically
    function renderScrollLocation(element) {
        var intViewportWidth;
        var intViewportHeight;
        var virtualScrollHeight;
        var virtualScrollWidth;
        var virtualScrollTop;
        var virtualScrollLeft;
        var trueScrollHeight;
        var trueScrollWidth;
        var trueScrollTop;
        var trueScrollLeft;

        // we need the viewport dimensions because true scroll dimensions
        //      include the viewport height, which messes with the caluculations
        intViewportWidth = element.elems.dataViewport.clientWidth;
        intViewportHeight = element.elems.dataViewport.clientHeight;

        // we are saving the max scroll dimensions for ease of access
        virtualScrollHeight = element.internalScroll.maxTop;
        virtualScrollWidth = element.internalScroll.maxLeft;

        // we are saving the current scroll location for ease of access
        virtualScrollTop = element.internalScroll.top;
        virtualScrollLeft = element.internalScroll.left;

        // we need the actual scroll height of the scrollbars because we limit
        //      their height and that causes a difference we need to account for
        trueScrollWidth = element.elems.xScrollBar.scrollWidth;
        trueScrollHeight = element.elems.yScrollBar.scrollHeight;
        trueScrollWidth -= intViewportWidth;
        trueScrollHeight -= intViewportHeight;

        // we need to translate the virtual top/left into true top/left for the
        //      physical scrollbars
        // we can only translate if the scroll height or width is > 0 because if
        //      we translate a 0, we end up with division by 0
        // if we can't translate: default to 0

        trueScrollTop = 0;
        if (virtualScrollHeight > 0) {
            trueScrollTop = (
                virtualScrollTop / (
                    virtualScrollHeight / trueScrollHeight
                )
            );
        }

        trueScrollLeft = 0;
        if (virtualScrollWidth > 0) {
            trueScrollLeft = (
                virtualScrollLeft / (
                    virtualScrollWidth / trueScrollWidth
                )
            );
        }

        // we need to cancel the scrollbar events for one iteration because the
        //      scroll we're about to do causes scrollbar events to emit. the
        //      events then get to their bound functions well after the
        //      execution of this thread. this means that if we run this
        //      function and then set focus to a cell: the bound scroll
        //      functions would cause another re-render, which will cause
        //      focus to be lost. that's why we can't set these cancel to true
        //      and then quickly set them back to false, they must be set to
        //      false in the bound function.
        // there is a small issue with this method, after this function if, for
        //      example, the Y scrollbar is triggered but not the X scrollbar:
        //      the user may use the X scrollbar and the first time the user
        //      triggers the X scrollbar: the event will be ignored. however,
        //      I've tested on Google Chrome and I didn't notice the effects of
        //      this downside
        //element.internalEventCancelled.scrollbarY = true;
        //element.internalEventCancelled.scrollbarX = true;

        // we need to update the scroll location of the physical scrollbars so
        //      that the user can see where they are
        // to prevent sub-pixel math issues from causing a loop (by moving the
        //      scrollbar 1 pixel which causes a scroll event to take place
        //      which causes this function to run again (moving the scrollbar
        //      another pixel etc...)): if the difference between current true
        //      and new true is <=1 pixel then the scrollbar will not be updated
        //      (to fix this issue I tried disabling the event before the update
        //      and enabling it after the update, this did not work)
        if (
            Math.abs(element.elems.yScrollBar.scrollTop - trueScrollTop) >= 1
        ) {
            element.elems.yScrollBar.scrollTop = trueScrollTop;
        }
        if (
            Math.abs(element.elems.xScrollBar.scrollLeft - trueScrollLeft) >= 1
        ) {
            element.elems.xScrollBar.scrollLeft = trueScrollLeft;
        }

        // render cells
        //console.trace('renderScrollLocation');
        //console.log('virtualScrollTop:  ', virtualScrollTop);
        //console.log('virtualScrollLeft: ', virtualScrollLeft);
        //console.log('trueScrollTop:     ', trueScrollTop);
        //console.log('trueScrollLeft:    ', trueScrollLeft);
        renderLocation(element);
        //renderLocation(element);
    }

    // we need to be able to update the scrollbar depending on the content
    //      height/width
    function renderScrollDimensions(element) {
        var i;
        var len;
        var arrColumnWidths;
        var arrRecordHeights;
        var columnBorderWidth;
        var recordBorderHeight;
        var intViewportWidth;
        var intViewportHeight;
        var intMaxColumnWidth;
        var intMaxRecordHeight;

        var intTotalDataWidth;
        var intTotalDataHeight;
        var intOverscrollWidth;
        var intOverscrollHeight;
        var intNoOverscrollHeight;
        var intNoOverscrollWidth;

        // if the columns are automatically resized, calculate the widths here,
        //      so that we don't have to see a jarring unresized moment at the
        //      beginning of the table
        if (element.hasAttribute('column-auto-resize')) {
            calculateAutoColumns(element);
        }

        // we need to update the cell dimension numbers just in case some CSS
        //      has altered any of the dimensions
        cellDimensionDetector(element);

        // we need to update what features are visible (header, record
        //      selectors, insert record)
        visibilityDetector(element);

        // we need to update the scroll offsets so that we can make room for
        //      headers, insert records and record selectors in the viewport
        offsetDetector(element);

        // we're saving these to variables for quicker/easier access
        columnBorderWidth = element.internalDisplay.columnBorderWidth;
        recordBorderHeight = element.internalDisplay.recordBorderHeight;

        // we need to get column and record dimensions
        arrColumnWidths = element.internalDisplay.columnWidths;
        arrRecordHeights = element.internalDisplay.recordHeights;

        // we need to get the viewport dimensions
        intViewportWidth = element.elems.dataViewport.clientWidth;
        intViewportHeight = element.elems.dataViewport.clientHeight;

        // save max record height and column width
        intMaxColumnWidth = (
            intViewportWidth - (
                element.internalScrollOffsets.left +
                element.internalScrollOffsets.right
            )
        );

        // if we allow column resize, we need to make sure there's room for
        //      the mouse to get to the handle of the column. If there's no
        //      resize, maximum is basically the full viewport
        if (!element.hasAttribute('no-resize-column')) {
            intMaxColumnWidth -= (columnBorderWidth + 5);
        }

        intMaxRecordHeight = (
            intViewportHeight - (
                element.internalScrollOffsets.top +
                element.internalScrollOffsets.bottom +
                recordBorderHeight
            )
        );

        // if we allow record resize, we need to make sure there's room for
        //      the mouse to get to the handle of the record. If there's no
        //      resize, maximum is basically the full viewport
        if (!element.hasAttribute('no-resize-record')) {
            intMaxRecordHeight -= 5;
        }

        // store the max cell dimensions internally
        element.internalDisplay.maxColumnWidth = intMaxColumnWidth;
        element.internalDisplay.maxRecordHeight = intMaxRecordHeight;

        // we need to add up column widths (including custom ones)
        intTotalDataWidth = 0;
        intOverscrollWidth = 0;
        i = 0;
        len = arrColumnWidths.length;
        while (i < len) {
            // make sure no column is wider than max
            if (
                intMaxColumnWidth > 3 &&
                arrColumnWidths[i] > intMaxColumnWidth
            ) {
                arrColumnWidths[i] = intMaxColumnWidth;
            }

            // increment total data width
            intTotalDataWidth += arrColumnWidths[i];
            intTotalDataWidth += columnBorderWidth;

            // we want to increase overscroll width until the last record
            if (i < (len - 1)) {
                intOverscrollWidth = intTotalDataWidth;
            }

            i += 1;
        }

        // Automatic column resizing introduces sub pixels, which messes with JS
        //      math, resulting in a number like this: 978.000000001. In order
        //      to make the math work out properly, we remove that extra decimal
        //      here. Rounding at the source didn't work.
        intTotalDataWidth = Math.round(intTotalDataWidth);
        intOverscrollWidth = Math.round(intOverscrollWidth);

        // need one pixel to account for border pixel (no need to scroll if we'd
        //      just hide a border)
        intTotalDataWidth -= 1;
        intOverscrollWidth -= 1;

        // we need to add up record heights (including custom ones)
        intTotalDataHeight = 0;
        intOverscrollHeight = 0;
        i = 0;
        len = arrRecordHeights.length;
        while (i < len) {
            // make sure no record is taller than max
            if (
                intMaxRecordHeight > 3 &&
                arrRecordHeights[i] > intMaxRecordHeight
            ) {
                arrRecordHeights[i] = intMaxRecordHeight;
            }

            // increment total data height
            intTotalDataHeight += arrRecordHeights[i];
            intTotalDataHeight += recordBorderHeight;

            // we want to increase overscroll height until the last record
            if (
                (
                    element.internalDisplay.insertRecordVisible &&
                    element.internalDisplay.insertRecordStick === null &&
                    i === (len - 1)
                ) ||
                (
                    (
                        !element.internalDisplay.insertRecordVisible ||
                        element.internalDisplay.insertRecordStick !== null
                    ) &&
                    i < (len - 1)
                )
            ) {
                // catch overscroll height up to total height
                intOverscrollHeight = intTotalDataHeight;
            }
            i += 1;
        }

        //if (
        //    element.internalDisplay.insertRecordVisible &&
        //    element.internalDisplay.insertRecordStick === null
        //) {
        //    intTotalDataHeight += (
        //        element.internalDisplay.insertRecordHeight +
        //        element.internalDisplay.insertRecordBorderHeight
        //    );
        //}

        //console.log('columnBorderWidth:  ', columnBorderWidth);
        //console.log('recordBorderHeight: ', recordBorderHeight);
        //console.log('Height:         ', intHeight);
        //console.log('ViewportHeight: ', intViewportHeight);
        //console.log('Width:          ', intWidth);
        //console.log('ViewportWidth:  ', intViewportWidth);
        //console.log('offsetTop:      ', element.internalScrollOffsets.top);
        //console.log('offsetBottom:   ', element.internalScrollOffsets.bottom);
        //console.log('offsetLeft:     ', element.internalScrollOffsets.left);
        //console.log('offsetRight:    ', element.internalScrollOffsets.right);

        // add scroll offsets
        intTotalDataHeight += (
            element.internalScrollOffsets.top +
            element.internalScrollOffsets.bottom
        );
        // this makes extra scroll room when we don't need it for some reason.
        //      To get an example, make a gs-table with autoresize and make the
        //      columns take up the full width. A horizontal scrollbar will
        //      appear.
        //intTotalDataWidth += (
        //    element.internalScrollOffsets.left +
        //    element.internalScrollOffsets.right
        //);

        // save max scroll dimensions

        // we need to prevent vertical overscrolling if the
        //      "no-y-overscroll" attribute is present. the reason we can't
        //      just use the old maxTop value conditionally is because we
        //      make scrolling scroll by record, not pixel perfect. this
        //      means the last record will get cut off. so, in order to turn
        //      off overscrolling without this issue we need to calculate
        //      the amount to add to the maxTop in order to give enough room
        //      for the last record to clear the bottom of the viewport
        if (element.hasAttribute('no-y-overscroll')) {
            intNoOverscrollHeight = 0;
            i = 0;
            len = arrRecordHeights.length;
            while (i < len) {
                if (
                    (
                        intNoOverscrollHeight +
                        intViewportHeight
                    ) >= (
                        intTotalDataHeight +
                        element.internalScrollOffsets.top +
                        element.internalScrollOffsets.bottom
                    )
                ) {
                    break;
                }

                // increment total data width
                intNoOverscrollHeight += arrRecordHeights[i];
                intNoOverscrollHeight += recordBorderHeight;

                i += 1;
            }

            if (
                element.internalDisplay.insertRecordVisible &&
                element.internalDisplay.insertRecordStick === null
            ) {
                intNoOverscrollHeight += (
                    element.internalDisplay.insertRecordHeight +
                    element.internalDisplay.insertRecordBorderHeight
                );
            }

            element.internalScroll.maxTop = Math.max(
                0,
                intNoOverscrollHeight
            );

            //console.log('   intTotalDataHeight: ', intTotalDataHeight);
            //console.log('  intOverscrollHeight: ', intOverscrollHeight);
            //console.log('intNoOverscrollHeight: ', intNoOverscrollHeight);
            //console.log('    intViewportHeight: ', intViewportHeight);

        } else {
            element.internalScroll.maxTop = Math.max(0, intOverscrollHeight);
        }

        // we need to prevent horizontal overscrolling if the
        //      "no-x-overscroll" attribute is present. the reason we can't
        //      just use the old maxLeft value conditionally is because we
        //      make scrolling scroll by column, not pixel perfect. this
        //      means the last column will get cut off. so, in order to turn
        //      off overscrolling without this issue we need to calculate
        //      the amount to add to the maxLeft in order to give enough
        //      room for the last column to clear the right of the viewport
        if (element.hasAttribute('no-x-overscroll')) {
            intNoOverscrollWidth = 0;
            i = 0;
            len = arrColumnWidths.length;
            while (i < len) {
                if (
                    (
                        intNoOverscrollWidth +
                        intViewportWidth
                    ) >= (
                        intTotalDataWidth +
                        element.internalScrollOffsets.left +
                        element.internalScrollOffsets.right
                    )
                ) {
                    break;
                }

                // increment total data width
                intNoOverscrollWidth += arrColumnWidths[i];
                intNoOverscrollWidth += columnBorderWidth;

                i += 1;
            }

            element.internalScroll.maxLeft = Math.max(
                0,
                intNoOverscrollWidth
            );

            //console.log('   intTotalDataWidth: ', intTotalDataWidth);
            //console.log('  intOverscrollWidth: ', intOverscrollWidth);
            //console.log('intNoOverscrollWidth: ', intNoOverscrollWidth);
            //console.log('    intViewportWidth: ', intViewportWidth);
            //console.log('left:  ', element.internalScrollOffsets.left);
            //console.log('right: ', element.internalScrollOffsets.right);
            //console.log('widths:', element.internalDisplay.columnWidths);
            //console.log('border:', element.internalDisplay.columnBorderWidth);
        } else {
            element.internalScroll.maxLeft = Math.max(0, intOverscrollWidth);
        }

        //console.log('maxTop:   ', element.internalScroll.maxTop);
        //console.log('maxLeft:  ', element.internalScroll.maxLeft);

        // sometimes, you may scroll to the right then widen your gs-table, this
        //      can cause you to get out of bounds
        // if the current scroll location is outside the max dimentions, set
        //      the scroll to the max allowed
        if (element.internalScroll.top > element.internalScroll.maxTop) {
            element.internalScroll.top = element.internalScroll.maxTop;
        }
        if (element.internalScroll.left > element.internalScroll.maxLeft) {
            element.internalScroll.left = element.internalScroll.maxLeft;
        }

        // move scrollbar causer elements to create scrollbars
        element.elems.yScrollBarCauser.style.top = (
            // scrollbars only work for a certain range that's why the max
            //      is 100000
            Math.min(
                (
                    (
                        element.internalScroll.maxTop +
                        intViewportHeight
                    ) - 1 // <-- the causer is px tall, this counteracts that
                ),
                100000
            ) + "px"
        );
        element.elems.xScrollBarCauser.style.left = (
            // scrollbars only work for a certain range that's why the max
            //      is 100000
            Math.min(
                (
                    (
                        element.internalScroll.maxLeft +
                        intViewportWidth
                    ) - 1 // <-- the causer is px wide, this counteracts that
                ),
                100000
            ) + "px"
        );

        // render scroll location
        renderScrollLocation(element);
    }

    function renderHUD(element) {
        var oldTopHUDHeight;
        var newTopHUDHeight;
        var oldBottomHUDHeight;
        var newBottomHUDHeight;


        // save the current hud height so that we can compare it to after the
        //      changes have been made
        oldTopHUDHeight = element.elems.topHudContainer.offsetHeight;

        // if we have a hud template: add hud class that makes the hud element
        //      visible and populate the hud element
        if (element.internalTemplates.topHUD.trim()) {
            element.elems.root.classList.add('show-top-hud');
            element.elems.topHudContainer.innerHTML = (
                element.internalTemplates.topHUD
            );

            // save new HUD height to a variable for clarity
            newTopHUDHeight = (element.elems.topHudContainer.offsetHeight);

            // update padding to make room for the hud
            element.elems.root.style.paddingTop = newTopHUDHeight + 'px';

        // else, we have no template: make hud invisible and clear hud element
        } else {
            element.elems.root.classList.remove('show-top-hud');
            element.elems.topHudContainer.innerHTML = '';
            newTopHUDHeight = 0;
        }


        // save the current hud height so that we can compare it to after the
        //      changes have been made
        oldBottomHUDHeight = element.elems.bottomHudContainer.offsetHeight;

        // if we have a hud template: add hud class that makes the hud element
        //      visible and populate the hud element
        if (element.internalTemplates.bottomHUD.trim()) {
            element.elems.root.classList.add('show-bottom-hud');
            element.elems.bottomHudContainer.innerHTML = (
                element.internalTemplates.bottomHUD
            );

            // save new HUD height to a variable for clarity
            newBottomHUDHeight = element.elems.bottomHudContainer.offsetHeight;

            // update padding to make room for the hud
            element.elems.root.style.paddingBottom = newBottomHUDHeight + 'px';

        // else, we have no template: make hud invisible and clear hud element
        } else {
            element.elems.root.classList.remove('show-bottom-hud');
            element.elems.bottomHudContainer.innerHTML = '';
            newBottomHUDHeight = 0;
        }


        // if there is a difference in one of the HUD heights, we want to
        //      re-render the dataviewport because the HUD's height affects
        //      the viewport height
        if (
            oldTopHUDHeight !== newTopHUDHeight ||
            oldBottomHUDHeight !== newBottomHUDHeight
        ) {
            element.internalDisplay.fullRenderRequired = true;
            renderScrollDimensions(element);
        }
    }

    // sometimes, the user will resize the selected columns to their respective
    //      header widths. this function is a shortcut for that functionality.
    function resizeColumnsToHeader(element, arrColumnIndexes) {
        var i;
        var len;
        var intIndex;

        // loop through each selected column
        i = 0;
        len = arrColumnIndexes.length;
        while (i < len) {
            intIndex = arrColumnIndexes[i];

            // set the width the min width, which is the same as the header
            //      width
            element.internalDisplay.columnWidths[intIndex] = (
                element.internalDisplay.minColumnWidths[intIndex]
            );

            i += 1;
        }

        // re-render location
        renderLocation(element);
    }

    function resizeColumnsToContent(element, arrColumnIndexes) {
        //console.trace('resizeColumnsToContent', element, arrColumnIndexes);
        var i;
        var len;
        var elem_i;
        var elem_len;
        var intIndex;
        var arrElements;
        var controlElement;
        var intWidth;
        var jsnRange;

        var scopeElement;
        var controlText;
        var intTextWidth;

        var intColumnWidth;
        var intScopeElementWidth;

        // we only resize content that is rendered. to do that we need to
        //      know the current rendered range.
        jsnRange = element.internalDisplay.currentRange;

        // loop through each selected column
        i = 0;
        len = arrColumnIndexes.length;
        while (i < len) {
            intIndex = arrColumnIndexes[i];

            // we only pay attention to the content that has been rendered.
            //      so, only do anything if the current column is rendered.
            if (
                intIndex >= jsnRange.fromColumn &&
                intIndex <= jsnRange.toColumn
            ) {
                // start with the min width, any future width settings must be
                //      larger than this
                intWidth = element.internalDisplay.minColumnWidths[intIndex];

                // we need the old column width for a calculation
                intColumnWidth = element.internalDisplay.columnWidths[intIndex];

                // get the rendered cell elements for this column
                arrElements = tblQry(
                    element.elems.dataViewport,
                    'gs-cell.table-cell[data-col-number="' + intIndex + '"]'
                );

                // loop through every data cell for this column
                elem_i = 0;
                elem_len = arrElements.length;
                while (elem_i < elem_len) {
                    // the goal is the find text and an element. once we've
                    //      found both of those, we can use GS.getTextWidth
                    //      to determine the text width and if that's larger
                    //      than the current width, set the current width to
                    //      the text width.
                    // the question is how are we going to find the element
                    //      and it's text seein' as how we can put whatever
                    //      we want in a cell... we'll have four different
                    //      options and each cell will be in one of them.
                    //          option the 1st: input text and it's parent
                    //          option the 2nd: textarea text and it's parent
                    //          option the 3rd: select text and it's parent
                    //          option the 4th: textContent and the cell

                    controlElement = tblQry(
                        arrElements[elem_i],
                        'input, textarea, select'
                    )[0];

                    if (
                        controlElement &&
                        (
                            controlElement.nodeName === 'INPUT' ||
                            controlElement.nodeName === 'TEXTAREA' ||
                            controlElement.nodeName === 'SELECT'
                        )
                    ) {
                        scopeElement = controlElement.parentNode;
                        controlText = controlElement.value;

                    } else {
                        scopeElement = (
                            // this fixes label-wrapped cells
                            arrElements[elem_i].children[0] ||
                            arrElements[elem_i]
                        );
                        controlText = arrElements[elem_i].textContent;
                    }

                    // get text width using the scope element and the control
                    //      text
                    intTextWidth = GS.getTextWidth(
                        scopeElement,
                        controlText,
                        true // preserve whitespace
                    );

                    // there may be some padding between the scope element
                    //      and the cell element. so, we want to account for
                    //      that.
                    intScopeElementWidth = Math.ceil(
                        scopeElement.clientWidth - (
                            parseFloat(
                                GS.getStyle(scopeElement, 'padding-left')
                            ) +
                            parseFloat(
                                GS.getStyle(scopeElement, 'padding-right')
                            )
                        )
                    );

                    // add padding to text width
                    intTextWidth += (intColumnWidth - intScopeElementWidth);
                    // add an arbituary amount to deal with small imperfections
                    intTextWidth += 10;

                    // if the new text width is greater than the currently
                    //      proposed width, set the currently proposed width
                    //      to the new text width
                    if (intTextWidth > intWidth) {
                        intWidth = intTextWidth;
                    }

                    elem_i += 1;
                }

                // set the width
                element.internalDisplay.columnWidths[intIndex] = intWidth;
            }

            i += 1;
        }

        // re-render location
        renderLocation(element);
    }

// ############################################################################
// ############################# LOADER FUNCTIONS #############################
// ############################################################################

    // loaders are appended to the end of the loader list, this is not where
    //      they belong. so, this function takes a loader element (which has
    //      already been appended) and moves it to the top of the loader
    //      container element
    function moveLoaderToTop(/*element, loaderElement*/) {
        // ### NEED CODING ###
    }

    // because of the way the loader container works, we need to set a margin
    //      so that the loader becomes visible
    function adjustLoaderWidth(ignore, loaderElement) {//element
        var loaderContent;

        // get the wrapped content
        loaderContent = loaderElement.children[0];

        // set the marginLeft to counteract the width
        loaderContent.style.marginLeft = (
            '-' + (loaderContent.offsetWidth + 10) + 'px'
        );

        // old, required getTextWidth which is slow
        //var intWidth;

        //// we calculate the width and store it in a variable
        //intWidth = GS.getTextWidth(element, loaderElement.textContent);

        //// let's add a little padding
        //intWidth += 25;

        //// set loader width and a reverse margin so that it moves to the left
        ////      the same amount
        //loaderElement.style.width = intWidth + 'px';
        //loaderElement.style.marginLeft = '-' + intWidth + 'px';
    }

    function addLoader(element, strID, strContent) {
        var loaderElement;

        // create loader element
        loaderElement = document.createElement('div');
        loaderElement.classList.add('table-loader-wrapper');
        loaderElement.innerHTML = (
            '<div class="table-loader">' + strContent + '</div>'
        );

        // append loader element to loader container
        element.elems.loaderContainer.appendChild(loaderElement);

        // append new loader imformation to a place where we can retrieve it
        element.internalLoaders.loaderIDs.push(strID);
        element.internalLoaders.loaderElements.push(loaderElement);

        // adjust loader width so that it displays all on one line
        adjustLoaderWidth(element, loaderElement);

        // move loader to top
        moveLoaderToTop(element, loaderElement);

        //console.log('added loader', loaderElement);
    }

    function removeLoader(element, strID, strFinishedContent) {
        var loaderIndex;
        var loaderElement;
        var fadeOut;
        var removeFunction;

        // if we can't find the loaders, we're too early, exit function
        if (!element.internalLoaders.loaderIDs) {
            return false;
        }

        // get index of loader in loader array
        loaderIndex = element.internalLoaders.loaderIDs.indexOf(strID);

        // get loader element using index
        loaderElement = element.internalLoaders.loaderElements[loaderIndex];

        // remove loader from loader arrays immediately so that if another
        //      loader is removed with the same name, we won't remove the same
        //      one twice
        element.internalLoaders.loaderIDs.splice(loaderIndex, 1);
        element.internalLoaders.loaderElements.splice(loaderIndex, 1);

        // define a fade out function so that we only need to write the code
        //      once.
        fadeOut = function () {
            // add fade out class
            loaderElement.classList.add('table-fade-out');

            // we want to be able to remove this function to free the memory
            removeFunction = function () {
                // if the loader container is still in use
                if (
                    element.elems &&
                    element.elems.loaderContainer
                ) {
                    // remove the loader
                    element.elems.loaderContainer.removeChild(loaderElement);
                }

                // clear function to free up memory
                removeFunction = null;
            };

            // remove loader from loader container after fade out animation
            //      is complete
            setTimeout(removeFunction, 1000);

            // clear function to free up memory
            fadeOut = null;
        };

        // if there is strFinishedContent, we need to change the content then
        //      fade out
        if (strFinishedContent) {
            // switch content to loader content
            loaderElement.children[0].innerHTML = strFinishedContent;

            // adjust loader width so that it displays all on one line
            adjustLoaderWidth(element, loaderElement);

            // move loader to top
            moveLoaderToTop(element, loaderElement);

            // fade out after some time has passed to read the new content
            setTimeout(fadeOut, 1000);

        // else, just fade loader out
        } else {
            fadeOut();
        }
    }

// ############################################################################
// ############################## DATA FUNCTIONS ##############################
// ############################################################################

    function dataSELECTcallback(element) {
        var intDifference;
        var i;
        var len;
        var bolFirstLoad;

        // we need to know if this was the first load
        bolFirstLoad = (element.internalData.bolFirstLoadFinished === false);

        // we may need to add or remove some record heights
        intDifference = (
            element.internalDisplay.recordHeights.length -
                element.internalData.records.length
        );

        // sometimes a record disappears between selects, someone else might
        //      delete a record and then you refresh, in this case we need to
        //      remove a enough records heights to make up the difference
        if (intDifference > 0) {
            i = 0;
            len = intDifference;
            while (i < len) {
                element.internalDisplay.recordHeights.pop();
                i += 1;
            }

        // there's a possibility of a record being added without an accompanying
        //      record height, if that's happened we add enough record heights
        //      to make up the difference
        } else if (intDifference < 0) {
            i = 0;
            len = Math.abs(intDifference);
            while (i < len) {
                element.internalDisplay.recordHeights.push(
                    element.internalDisplay.defaultRecordHeight
                );
                i += 1;
            }
        }

        // make sure that everything knows the first load is over
        if (element.internalData.bolFirstLoadFinished === false) {
            element.internalData.bolFirstLoadFinished = true;
        }

        // re-render scroll location because adding records changes scroll
        //      heights, and so that we can show the new data
        element.internalDisplay.fullRenderRequired = true;
        renderScrollDimensions(element);

        // sometimes, developers want to have the gs-table select and focus
        //      after it first loads
        if (
            element.hasAttribute('focus-on-load') &&
            bolFirstLoad &&
            // if we are already focused, then ignore
            element.internalSelection.ranges.length === 0
        ) {
            // if there is data, select the first cell
            if (element.internalData.records.length > 0) {
                element.internalSelection.ranges = [
                    {
                        "start": {"row": 0, "column": "selector"},
                        "end": {"row": 0, "column": "selector"},
                        "negator": false
                    }
                ];

                focusIntoCell(
                    element,
                    0, // record
                    0  // column
                );

            // sometimes, there's no data to select, select the "all"
            //      selector if it's visible
            } else if (
                element.internalDisplay.recordSelectorVisible &&
                element.internalDisplay.headerVisible
            ) {
                element.internalSelection.ranges = [
                    {
                        "start": {
                            "row": "header",
                            "column": "selector"
                        },
                        "end": {
                            "row": "header",
                            "column": "selector"
                        },
                        "negator": false
                    }
                ];
            }

            renderSelection(element);
        }
        GS.triggerEvent(element, 'after_select');
        GS.triggerEvent(element, 'onafter_select');
        if (element.hasAttribute('onafter_select')) {
            new Function(
                element.getAttribute('onafter_select')
            ).apply(element);
        }
    }
    function dataINSERTcallback(element) {
        // clear retained values
        clearInsertRetainedValues(element);

        element.internalData.bolInserting = false;

        // re-render scroll location because adding records changes scroll
        //      heights, and so that we can show the new data
        element.internalDisplay.fullRenderRequired = true;
        renderScrollDimensions(element);

        // scroll to the bottom so that the user can see the newly created
        //      records without having to scroll
        // element.internalScroll.top = (
        //     element.internalScroll.maxTop - (
        //         element.elems.dataViewport.clientHeight - (
        //             element.internalScrollOffsets.top +
        //             element.internalScrollOffsets.bottom +
        //             element.internalDisplay.defaultRecordHeight
        //         )
        //     )
        // );
        if (!element.hasAttribute('no-insert-scroll')) {
            element.goToLine('last');
        }

        // re-render scroll location because we changed the scrollTop
        renderScrollLocation(element);
    }
    function dataUPDATEcallback(element) {
        // re-render location so that if changing the data resulted in
        //      calculated columns changing or some other unknown change
        //      occurs: the user will see the changes
        element.internalDisplay.fullRenderRequired = true;
        renderLocation(element);
        //console.log('In here!!');
    }
    function dataDELETEcallback(element) {
        // clear selection because the stuff that the user selected has
        //      now been deleted
        element.internalSelection.ranges = [];

        // re-render scroll location because removing records changes scroll
        //      heights
        element.internalDisplay.fullRenderRequired = true;
        renderScrollDimensions(element);
    }

    function getWhereClause(element) {
        var i;
        var len;
        var arrFilter;
        var strColumn;
        var filter_i;
        var filter_len;
        var strFilter;
        var jsnFilter;
        var strListWhere;

        var arrOldColumnNames;
        var arrOldColumnTypes;
        var arrOldColumnFilterStatuses;
        var arrOldColumnFilters;
        var arrOldColumnListFilters;

        var strWhere;
        // Code related to strWhereAddendum was added because the moron
        //      who wrote this code wasn't appending to strWhere,
        //      they were replacing it
        var strWhereAddendum;
        var strUserWhere;
        var strWhereColumn;

        // we need to include any where clauses added be the developer.
        //      this where clause is templated with the querystring.
        strWhere = GS.templateWithQuerystring(
            element.getAttribute('where') || '1=1'
        );

        // add in user filters, if any
        if (element.getAttribute('session-filter')) {
            // strWhere = '(' + element.getAttribute('session-filter') + ')';
            strWhereAddendum = (
                '(' + element.getAttribute('session-filter') + ')'
            );

            if (strWhereAddendum) {
                strWhere += (
                    strWhere
                        ? ' AND ' + strWhereAddendum
                        : '' + strWhereAddendum
                );
                strWhereAddendum = '';
            }
        }

        // add in a column or qs where, if any

        // we need to be able to handle header-line relationships, this code
        //      uses the "column", "qs" and "value" attributes to formulate
        //      a where clause
        if (
            element.getAttribute('value') &&
            (
                element.getAttribute('column') ||
                element.getAttribute('qs')
            )
        ) {
            strWhereColumn = (
                element.getAttribute('child-column') ||
                element.getAttribute('column') ||
                element.getAttribute('qs')
            );

            // if the value is not a number, we need to do a string
            //      comparison in the where clause.
            if (isNaN(element.value)) {
                strWhereAddendum = (
                    'CAST(' +
                    strWhereColumn + ' AS ' +
                    GS.database.type.text +
                    ') = ' +
                    'CAST(' +
                    '$WhereQUOTE$' + (element.value) + '$WhereQUOTE$ AS ' +
                    GS.database.type.text +
                    ')'
                );
                if (strWhereAddendum) {
                    strWhere += (
                        strWhere !== ''
                            ? ' AND (' + strWhereAddendum + ')'
                            : '' + strWhereAddendum
                    );
                }

            // if the value is a number, we can do simpler, number comparison
            } else {
                // strWhere = strWhereColumn + '=' + (element.value);
                strWhereAddendum = strWhereColumn + '=' + (element.value);
                if (strWhereAddendum) {
                    strWhere += (
                        strWhere !== ''
                            ? ' AND (' + strWhereAddendum + ')'
                            : '' + strWhereAddendum
                    );
                }
            }
        }

        arrOldColumnNames = element.internalData.columnNames;
        arrOldColumnTypes = element.internalData.columnTypes;
        arrOldColumnFilterStatuses = element.internalData.columnFilterStatuses;
        arrOldColumnFilters = element.internalData.columnFilters;
        arrOldColumnListFilters = element.internalData.columnListFilters;

        // we want the user to be able to filter a column, so here we'll look
        //      at what the user set for each column and prepend to the where
        //      clause
        strUserWhere = '';
        i = 0;
        len = arrOldColumnFilters.length;
        while (i < len) {
            arrFilter = arrOldColumnFilters[i];
            strColumn = arrOldColumnNames[i];

            // only filter if this column's filters haven't been toggled off
            if (arrOldColumnFilterStatuses[i] === 'on') {
                filter_i = 0;
                filter_len = arrFilter.length;
                while (filter_i < filter_len) {
                    strFilter = arrFilter[filter_i].text;
                    strUserWhere += (
                        strUserWhere
                            ? ' AND '
                            : ''
                    );

                    strUserWhere += strFilter;
                    filter_i += 1;
                }
            }

            i += 1;
        }

        //console.log('old filter:', arrOldColumnListFilters[0]);

        i = 0;
        len = arrOldColumnListFilters.length;
        while (i < len) {
            jsnFilter = arrOldColumnListFilters[i];
            strColumn = arrOldColumnNames[i];
            strListWhere = '';

            // only filter if this column's filters haven't been toggled off
            //      and there is a filter
            if (
                arrOldColumnFilterStatuses[i] === 'on' &&
                jsnFilter.type &&
                jsnFilter.values
                //jsnFilter.values.length > 0
                //  ^-- when nothing is chosen, we want nothing to match. this
                //      line was preventing the WHERE from being generated
            ) {
                if (jsnFilter.type === 'inclusion') {
                    filter_i = 0;
                    filter_len = jsnFilter.values.length;
                    while (filter_i < filter_len) {
                        strListWhere += (
                            strListWhere
                                ? ' OR '
                                : ''
                        );

                        strListWhere += (
                            strColumn +
                            ' = CAST($werequote$' +
                            jsnFilter.values[filter_i] +
                            '$werequote$ AS ' + arrOldColumnTypes[i] +
                            ')'
                        );
                        filter_i += 1;
                    }

                    //console.log(filter_i, filter_len);

                    if (filter_len === 0) {
                        strListWhere = '1=2';
                    }

                } else if (jsnFilter.type === 'exclusion') {
                    if (jsnFilter.values.length > 0) {
                        filter_i = 0;
                        filter_len = jsnFilter.values.length;
                        while (filter_i < filter_len) {
                            strListWhere += (
                                strListWhere
                                    ? ' AND '
                                    : ''
                            );

                            strListWhere += (
                                strColumn +
                                ' != CAST($werequote$' +
                                jsnFilter.values[filter_i] +
                                '$werequote$ AS ' + arrOldColumnTypes[i] +
                                ')'
                            );
                            filter_i += 1;
                        }
                    }
                }

                // if we are excluding nothing the blank code causes
                //      the where to just be "WHERE column is blank"
                if (
                    (
                        strListWhere &&
                        !(
                            jsnFilter.type === 'exclusion' &&
                            jsnFilter.values.length === 0
                        )
                    ) ||
                    jsnFilter.blanks === false
                ) {
                    // we need to handle blank values specially
                    if (strListWhere) {
                        strListWhere = '(' + strListWhere + ') ';
                    }

                    if (jsnFilter.blanks === true) {
                        if (strListWhere) {
                            strListWhere += ' OR';
                        }

                        strListWhere += (
                            ' NULLIF(' +
                                'CAST(' +
                                    strColumn + ' AS ' +
                                    GS.database.type.text +
                                '), \'\') IS NULL'
                        );
                    } else {
                        if (strListWhere) {
                            strListWhere += ' AND';
                        }

                        strListWhere += (
                            ' NULLIF(' +
                                'CAST(' +
                                    strColumn + ' AS ' +
                                    GS.database.type.text +
                                '), \'\') IS NOT NULL'
                        );
                    }

                    ////console.log(
                    //     jsnFilter,
                    //     strListWhere
                    // );

                    strUserWhere += (
                        strUserWhere
                            ? ' AND '
                            : ''
                    );
                    strUserWhere += '(' + strListWhere + ')';
                }
            }

            i += 1;
        }

        // if a where is defined by the dev, put it after our new where
        if (strUserWhere && strWhere) {
            strWhere = strUserWhere + ' AND (' + strWhere + ')';

        // if there is no where set by the developer, our new where will be
        //      the only one
        } else if (strUserWhere) {
            strWhere = strUserWhere;
        }

        return strWhere;
    }

    function databaseWSSELECT(element) {
        var socket;
        var strQuery;
        var strSchema;
        var strObject;
        var strWhere;
        var strOrd;
        var strLimit;
        var strOffset;
        var strReturn;
        var bolLoadNewRecordHeights;
        var intRecordHeight;

        var arrOldColumnNames;
        var arrOldColumnFilterStatuses;
        var arrOldColumnFilters;
        var arrOldColumnListFilters;
        var arrOldColumnOrders;
        var arrOldDisplayColumns;

        var i;
        var len;
        var strSort;
        var strColumn;
        var strUserOrd;
        var index;
        var arrCols;
        var arrRecords;
        var arrRecordHeights;
        var returnCallback;

        socket = getSocket(element);
        strQuery = GS.templateWithQuerystring(
            element.getAttribute('select-query') || ''
        );
        strSchema = GS.templateWithQuerystring(
            element.getAttribute('select-schema') || ''
        );
        strObject = GS.templateWithQuerystring(
            element.getAttribute('select-object') || ''
        );
        strWhere = getWhereClause(element);
        strOrd = GS.templateWithQuerystring(
            element.getAttribute('ord') || ''
        );
        strLimit = GS.templateWithQuerystring(
            element.getAttribute('limit') || ''
        );
        strOffset = GS.templateWithQuerystring(
            element.getAttribute('offset') || '0'
        );
        strReturn = '*';

        // limit column list
        if (element.getAttribute('cols')) {
            arrCols = GS.templateWithQuerystring(
                element.getAttribute('cols') || ''
            ).trim();
            arrCols = arrCols.split(/[\s]*,[\s]*/);
            strReturn = arrCols.join('\t');
        } else {
            strReturn = '*';
        }

        //// disabled, hide or not the pageinate buttons
        //if (strLimit === '') {
        //    element.pageLeftButton.setAttribute('hidden', '');
        //    element.pageRightButton.setAttribute('hidden', '');
        //} else if (strOffset === '' || strOffset === '0') {
        //    element.pageLeftButton.setAttribute('disabled', '');
        //}

        // if no records heights exist: we need to load record heights
        bolLoadNewRecordHeights =
                (element.internalDisplay.recordHeights.length === 0);

        // we need to create records with the default record height attached to
        //      them, so we'll use the "default-cell-height" attribute
        intRecordHeight = (
            parseInt(element.getAttribute('default-cell-height'), 10) ||
            intDefaultRecordHeight
        );

        // we need to make sure that no old data persists across select calls,
        //      so we'll clear out the internal data object
        element.internalData.records = [];

        // we need to re-link the new column list with the old column sorts,
        //      filters and filter statuses
        arrOldColumnNames = element.internalData.columnNames;
        arrOldColumnFilterStatuses = element.internalData.columnFilterStatuses;
        arrOldColumnFilters = element.internalData.columnFilters;
        arrOldColumnListFilters = element.internalData.columnListFilters;
        arrOldColumnOrders = element.internalData.columnOrders;
        arrOldDisplayColumns = element.internalDisplay.dataColumnName;

        // we want the user to be able to sort on a column, so here we'll look
        //      at what the user set for each column and prepend to the order
        //      by clause

        // we'll loop through the display column associations and see if any
        //      of those columns have been sorted
        strUserOrd = '';
        i = 0;
        len = arrOldDisplayColumns.length;
        while (i < len) {
            strColumn = arrOldDisplayColumns[i];

            if (strColumn) {
                index = arrOldColumnNames.indexOf(strColumn);
                strSort = arrOldColumnOrders[index];

                if (strSort === 'asc') {
                    strUserOrd += (
                        strUserOrd
                            ? ', '
                            : ''
                    );
                    strUserOrd += strColumn + ' ASC';

                } else if (strSort === 'desc') {
                    strUserOrd += (
                        strUserOrd
                            ? ', '
                            : ''
                    );
                    strUserOrd += strColumn + ' DESC';
                }
            }
            i += 1;
        }

        // if an order by is defined by the dev, put it after our new order by
        if (strUserOrd && strOrd) {
            strOrd = strUserOrd + ', ' + strOrd;

        // if there is no orderby set by the developer, our new order by will be
        //      the only one
        } else if (strUserOrd) {
            strOrd = strUserOrd;
        }

        //console.time('data load');

        // storing references to the arrays for faster access
        arrRecords = element.internalData.records;
        arrRecordHeights = element.internalDisplay.recordHeights;

        //console.log('before_select', element);
        GS.triggerEvent(element, 'before_select');
        GS.triggerEvent(element, 'onbefore_select');
        if (element.hasAttribute('onbefore_select')) {
            new Function(element.getAttribute('onbefore_select'))
                .apply(element);
        }

        // if the table element has been destroyed, we must stop execution
        if (!element.internalData.columnNames) {
            return;
        }

        // because we use both arbitrary and named selects, we want this
        //      callback to be a variable, so that we don't have to duplicate it
        returnCallback = function (data, error) {
            //var i;
            //var len;
            var col_i;
            var col_len;
            var strCol;
            //var index;
            var strRecord;
            var strMessage;
            //var strChar;

            // if the table element has been destroyed, we must stop execution
            if (!element.internalData.columnNames) {
                return;
            }

            if (!error) {
                // if this is the first callback, we need to save
                //      the column names and types and we need to
                //      re-link the filters, sorts and filter statuses
                //
                // this was below in the else, but requestSelectFromSocket
                //      will only callback once if there are no records
                //      - Nunzio 5/29/2017
                if (data.intCallback === 0) {
                    // clear old column arrays to make remove for any
                    //      changes to the column list
                    element.internalData.columnNames = [];
                    element.internalData.columnTypes = [];
                    element.internalData.columnFilterStatuses = [];
                    element.internalData.columnFilters = [];
                    element.internalData.columnListFilters = [];
                    element.internalData.columnOrders = [];

                    // future mike, you need to make is so that the
                    //      column name, filter and sort arrays are
                    //      retained across select calls.
                    // past mike, sounds good, I'll use the old column
                    //      list to get the old sorts filters, and
                    //      filter statuses
                    col_i = 0;
                    col_len = data.arrDecodedColumnNames.length;
                    while (col_i < col_len) {
                        strCol = data.arrDecodedColumnNames[col_i];
                        index = arrOldColumnNames.indexOf(strCol);

                        element.internalData.columnNames.push(
                            strCol
                        );
                        element.internalData.columnTypes.push(
                            data.arrDecodedColumnTypes[col_i]
                        );

                        // if we've got old values from the select,
                        //      bring them over to the new arrays
                        if (index > -1) {
                            element.internalData.columnFilterStatuses.push(
                                arrOldColumnFilterStatuses[index]
                            );
                            element.internalData.columnFilters.push(
                                arrOldColumnFilters[index]
                            );
                            element.internalData.columnListFilters.push(
                                arrOldColumnListFilters[index]
                            );
                            element.internalData.columnOrders.push(
                                arrOldColumnOrders[index]
                            );

                        // else, add empty sort, filter and filter
                        //      status
                        } else {
                            element.internalData
                                .columnFilterStatuses.push('on');
                            element.internalData.columnFilters.push([]);
                            element.internalData.columnListFilters.push({});
                            element.internalData.columnOrders.push('neutral');
                        }

                        col_i += 1;
                    }
                }

                // we need to remove the loader at some point, if we see
                //      the last message of the select: remove loader and
                //      render
                if (data.strMessage === 'TRANSACTION COMPLETED') {
                    //// required for v3 test#1
                    //element.internalData.records = (
                    //    arrRecords
                    //);
                    //element.internalDisplay.recordHeights = (
                    //    arrRecordHeights
                    //);

                    // back to non-test code
                    //console.timeEnd('data load');
                    //console.log(
                    //    'record count:',
                    //    element.internalData.records.length
                    //);
                    removeLoader(element, 'data-select', 'Data Loaded');
                    dataSELECTcallback(element);

                // we need to capture the records and columns and store
                //      them in the internal data
                } else {
                    if (
                        data.intCallback === 3 &&
                        element.internalData.bolFirstLoadFinished === false
                    ) {
                        //// required for v3 test#1
                        //element.internalData.records = (
                        //    arrRecords
                        //);
                        //element.internalDisplay.recordHeights = (
                        //    arrRecordHeights
                        //);

                        // re-render scroll location because adding records
                        //      changes scroll heights, and so that we can
                        //      show the new data
                        element.internalDisplay.fullRenderRequired = true;
                        renderScrollDimensions(element);
                    }

                    // we need to parse the TSV into records and push them
                    //      to the internalData "records" array
                    // now, we have an advantage in that Envelope Websocket
                    //      data is already encoded in the correct format
                    //      and all we have to is split on \n
                    // also, Envelope Websocket data always ends in \n so
                    //      the loop doesn't need to do anything special
                    //      to get the last record
                    strMessage = data.strMessage;
                    strRecord = '';

                    //// splitter test#1 v3, slower than v2
                    //var arrRecord = strMessage.split('\n');
                    //arrRecord.pop();
                    //arrRecords = arrRecords.concat(arrRecord);
                    //if (bolLoadNewRecordHeights) {
                    //    i = 0;
                    //    len = (
                    //        (arrRecords.length - arrRecordHeights.length) + 1
                    //    );
                    //    while (i < len) {
                    //        arrRecordHeights.push(intRecordHeight);
                    //        i += 1;
                    //    }
                    //}

                    // splitter v2, faster than v1 by 1 third
                    i = 0;
                    while (i < 15) {
                        index = strMessage.indexOf('\n');
                        strRecord = strMessage.substring(0, index);
                        strMessage = strMessage.substring(index + 1);

                        if (strRecord !== '' || strMessage !== '') {
                            arrRecords.push(strRecord);

                            if (bolLoadNewRecordHeights) {
                                arrRecordHeights.push(intRecordHeight);
                            }
                        } else {
                            break;
                        }

                        i += 1;
                    }

                    //// splitter v1, replaced because it was slow
                    //strMessage = data.strMessage;
                    //strRecord = '';
                    //i = 0;
                    //len = strMessage.length;
                    //while (i < len) {
                    //    strChar = strMessage[i];
                    //    if (strChar === '\n') {
                    //        element.internalData.records.push(strRecord);
                    //        if (bolLoadNewRecordHeights) {
                    //            element.internalDisplay
                    //                .recordHeights
                    //                .push(intRecordHeight);
                    //        }
                    //        strRecord = '';
                    //    } else {
                    //        strRecord += strChar;
                    //    }
                    //    i += 1;
                    //}
                }

            // we need to make sure that the user knows that the select
            //      failed and we need to prevent using any old select
            //      info, so we'll re-render, remove the loader and pop
            //      up an error
            } else {
                dataSELECTcallback(element);
                removeLoader(element, 'data-select', 'Data Failed To Load');
                if (!element.hasAttribute('suppress-select-error')) {
                    GS.webSocketErrorDialog(data);
                }
            }
        };

        // we need the user to know that the envelope is re-fetching data,
        //      so we'll put a loader on
        if (strQuery) {
            addLoader(element, 'data-select', 'Loading Data...');
            GS.requestArbitrarySelectFromSocket(
                socket,
                strQuery,
                strWhere,
                strOrd,
                strLimit,
                strOffset,
                returnCallback
            );
        } else {
            addLoader(element, 'data-select', 'Loading Data...');
            GS.requestSelectFromSocket(
                socket,
                strSchema,
                strObject,
                strReturn,
                strWhere,
                strOrd,
                strLimit,
                strOffset,
                returnCallback
            );
        }
    }
    function databaseWSINSERT(element, strMode, jsnInsert) {
        var rec_i;
        var rec_len;
        var col_i;
        var col_len;
        var strColumn;

        var strPostfix;
        var insertStep;
        var beforeEvent;

        var arrPK;
        var arrSeq;
        var strPK;
        var strSeq;
        var strInsertColumns;
        var strInsertData;

        var strSchema;
        var strObject;
        var strReturn;
        var strNullString;
        var intRecordHeight;

        // get schema and object attributes and get the return column list
        strSchema = GS.templateWithQuerystring(
            element.getAttribute('insert-schema') || ''
        );
        strObject = GS.templateWithQuerystring(
            element.getAttribute('insert-object') || ''
        );

        // the return column list must be defined the same as the column list
        //      that we store the data with, so we define strReturn using the
        //      column list
        strReturn = '';
        col_i = 0;
        col_len = element.internalData.columnNames.length;
        while (col_i < col_len) {
            strReturn += (
                strReturn
                    ? '\t'
                    : ''
            );
            strReturn += (
                element.internalData.columnNames[col_i].replace(/(\\)/g, '\\\\')
            );
            col_i += 1;
        }

        // we need to know if the developer has specified any special primary
        //      key columns and/or sequence columns
        strPK = GS.templateWithQuerystring(
            element.getAttribute('pk') || ''
        );
        strSeq = GS.templateWithQuerystring(
            element.getAttribute('seq') || ''
        );
        arrPK = strPK.split(/[\s]*,[\s]*/);
        arrSeq = strSeq.split(/[\s]*,[\s]*/);

        // we want the null string to be configurable, so we'll read the
        //      "null-string" attribute to get the null string
        // if the "null-string" attribute is present, use the contents
        //      or coalesce to empty string
        if (element.hasAttribute('null-string')) {
            strNullString = element.getAttribute('null-string') || '';

        // else, null string is left up to the encoding function
        } else {
            strNullString = undefined;
        }

        // we need to create records with the default record height attached to
        //      them, so we'll use the "default-cell-height" attribute
        intRecordHeight = (
            parseInt(element.getAttribute('default-cell-height'), 10) ||
            intDefaultRecordHeight
        );

        // there are three different ways to insert records:
        //      1) typing into the insert record
        //      2) filling insert dialog
        //      3) pasting into the insert record.
        //      types 1 and 2 are "single-record" inserts
        //      type 3 is a "multi-record" insert

        // "single-record"
        if (strMode === 'single-record') {
            // if there is an addin value and that column was not already in the
            //      insert, add the value to the insert
            if (
                jsnInsert.data.addin &&
                jsnInsert.data.addin.link_column &&
                jsnInsert.data.addin.link_value &&
                jsnInsert
                    .data
                    .columns
                    .indexOf(jsnInsert.data.addin.link_column) === -1
            ) {
                strColumn = jsnInsert.data.addin.link_column;

                jsnInsert.data.columns.push(
                    jsnInsert.data.addin.link_column
                );
                jsnInsert.data.values[strColumn] = (
                    jsnInsert.data.addin.link_value
                );
            }

            strInsertColumns = '';
            strInsertData = '';
            col_i = 0;
            col_len = jsnInsert.data.columns.length;
            while (col_i < col_len) {
                strColumn = (
                    jsnInsert.data.columns[col_i].replace(/(\\)/g, '\\\\')
                );

                strInsertColumns += (
                    strInsertColumns
                        ? '\t'
                        : ''
                );
                strInsertColumns += strColumn;

                strInsertData += (
                    strInsertData
                        ? '\t'
                        : ''
                );
                strInsertData += GS.encodeForTabDelimited(
                    (jsnInsert.data.values[strColumn] || 'NULL'),
                    strNullString
                );

                col_i += 1;
            }

            // append a return after the end of the insert data because
            //      the envelope expects it
            strInsertData += '\n';

        // "multi-record" assumes that:
        //      1) the data is a dump
        //      2) isn't stored anywhere
        //      3) only affects the currently selected insert record columns
        //              unless none are selected, in that case: all columns
        } else if (strMode === 'multi-record') {
            // if there is an addin value and that column was not already in the
            //      insert, add the value to the insert
            if (
                jsnInsert.data.addin &&
                jsnInsert.data.addin.link_column &&
                jsnInsert.data.addin.link_value &&
                jsnInsert
                    .data
                    .columns
                    .indexOf(jsnInsert.data.addin.link_column) === -1
            ) {
                strColumn = jsnInsert.data.addin.link_column;

                jsnInsert.data.columns.push(
                    jsnInsert.data.addin.link_column
                );

                rec_i = 0;
                rec_len = jsnInsert.data.values.length;
                while (rec_i < rec_len) {
                    jsnInsert.data.values[rec_i] += '\t';
                    jsnInsert.data.values[rec_i] += GS.encodeForTabDelimited(
                        jsnInsert.data.addin.link_value
                    );
                    rec_i += 1;
                }
            }
            //console.log(jsnInsert.data.columns, jsnInsert.data.addin);

            // build up insert column list
            strInsertColumns = '';
            col_i = 0;
            col_len = jsnInsert.data.columns.length;
            while (col_i < col_len) {
                strColumn = (
                    jsnInsert.data.columns[col_i].replace(/(\\)/g, '\\\\')
                );

                strInsertColumns += (
                    strInsertColumns
                        ? '\t'
                        : ''
                );
                strInsertColumns += strColumn;

                col_i += 1;
            }

            // build up insert payload by appending each record with a \n in
            //      front of it
            strInsertData = '';
            rec_i = 0;
            rec_len = jsnInsert.data.values.length;
            while (rec_i < rec_len) {
                strInsertData += jsnInsert.data.values[rec_i];
                strInsertData += '\n';
                rec_i += 1;
            }

            // no need to append a return after the end of the insert data
            //      because the loop that builds up the record list above
            //      already appends the \n to the end

        } else {
            throw 'GS-TABLE Error: Invalid insert type: "' + strMode + '".';
        }

        // regardless of insert mode, we need a list of columns that uniquely
        //      identifies a record
        col_i = 0;
        col_len = arrSeq.length;
        while (col_i < col_len) {
            if (jsnInsert.data.columns.indexOf(arrSeq[col_i]) !== -1) {
                arrSeq[col_i] = '';
            }
            col_i += 1;
        }

        strPK = '';
        col_i = 0;
        col_len = arrPK.length;
        while (col_i < col_len) {
            strPK += (
                strPK
                    ? '\t'
                    : ''
            );
            strPK += GS.encodeForTabDelimited(arrPK[col_i], strNullString);
            col_i += 1;
        }

        strSeq = '';
        col_i = 0;
        col_len = arrSeq.length;
        while (col_i < col_len) {
            strSeq += (
                col_i === 0
                    ? ''
                    : '\t'
            );
            if (jsnInsert.data.columns.indexOf(arrPK[col_i]) === -1) {
                strSeq += arrSeq[col_i] || '';
            }
            col_i += 1;
        }

        // combine columns and data for the websocket call
        strInsertData = strInsertColumns + '\n' + strInsertData;

        // trigger a "before_insert" event so that the page has a
        //      chance to cancel the update using event.preventDefault()
        beforeEvent = GS.triggerEvent(element, 'before_insert', {
            "schema": strSchema,
            "object": strObject,
            "insertMode": strMode,
            "insertData": jsnInsert.data
        });
        GS.triggerEvent(element, 'onbefore_insert');
        if (element.hasAttribute('onbefore_insert')) {
            new Function(element.getAttribute('onbefore_insert'))
                .apply(element);
        }

        // if the user prevents the default on the "before_update"
        //      event, prevent the execution of the following update code
        if (beforeEvent.defaultPrevented) {
            return;
        }

        // the insert step is defined as a sub function because if there
        //      are multiple records involved in this update, we want to open
        //      a dialog before we continue, else we want to immediately update
        insertStep = function () {
            var insertedRecords;

            // define "insertedRecords" as empty so that we can append to it
            //      without worrying about an "undefined" at the beginning of
            //      the string
            insertedRecords = '';

            // gotta let the user know that an insert is in progress
            addLoader(element, 'data-insert', 'Inserting Data...');
            //console.log(strSchema,
            //     strObject,
            //     strReturn,
            //     strPK,
            //     strSeq,
            //     strInsertData);
            // begin the websocket insert
            GS.requestInsertFromSocket(
                getSocket(element),
                strSchema,
                strObject,
                strReturn,
                strPK,
                strSeq,
                strInsertData,
                // transaction start callback
                function (data, error) {
                    // if the table element has been destroyed, stop execution
                    if (!element.internalData.columnNames) {
                        return;
                    }

                    // insert failed, remove loader and popup error dialog
                    if (error) {
                        removeLoader(element, 'data-insert', 'Insert Failed');
                        GS.webSocketErrorDialog(data);
                    }
                },

                // transaction ready for commit/rollback callback
                // "ignore" is a placeholder for "transID" and it tells JSLINT
                //      that it is an unused variable
                function (data, error, ignore, commit, rollback) {
                    if (!error) {
                        // insert made it through: commit the update
                        if (data === 'TRANSACTION COMPLETED') {
                            commit();

                        // else: we've just received a data packet containing
                        //      the inserted records as they appear in the
                        //      database
                        } else {
                            // save this data so that we can use it to update
                            //      the internal data if the insert makes it
                            //      through
                            insertedRecords += data;
                        }
                    // insert failed: popup an error and rollback
                    } else {
                        GS.webSocketErrorDialog(data);
                        rollback();
                    }
                },

                // transaction commit/rollback finished callback
                function (strAnswer, data, error) {
                    var arrRecords;
                    var i;
                    var len;

                    // if the table element has been destroyed, stop execution
                    if (!element.internalData.columnNames) {
                        return;
                    }

                    // the over-the-network part of the update has finished,
                    //      remove the loader now so that if there is an
                    //      execution error below, the loader wont be stuck
                    //      visible
                    removeLoader(
                        element,
                        'data-insert',
                        (
                            error
                                ? 'Insert Failed'
                                : 'Insert Successful'
                        )
                    );

                    if (!error) {
                        // insert was successfully commited: update internal
                        //      data and re-render
                        if (strAnswer === 'COMMIT') {
                            // refresh internal data by replace each internal
                            //      record that was affected with it's new
                            //      version
                            arrRecords = insertedRecords.split('\n');
                            i = 0;
                            len = arrRecords.length - 1; // the - 1 is because
                                                         //   of the extra \n at
                                                         //   the end of the
                                                         //   returned records
                            while (i < len) {
                                element.internalData
                                    .records.push(arrRecords[i]);
                                element.internalDisplay
                                    .recordHeights.push(intRecordHeight);
                                i += 1;
                            }

                            // standard after-insert behaviour
                            dataINSERTcallback(element);

                            // trigger an after insert event
                            GS.triggerEvent(element, 'after_insert', {
                                "insertMode": strMode,
                                "insertData": jsnInsert.data
                            });
                            GS.triggerEvent(element, 'onafter_insert');
                            if (element.hasAttribute('onafter_insert')) {
                                new Function(
                                    element.getAttribute('onafter_insert')
                                ).apply(element);
                            }
                        }
                    // insert failed: popup an error
                    } else {
                        GS.webSocketErrorDialog(data);
                    }
                }
            );
        };

        // we don't want to be able to insert of there's no insert data, so if
        //      we're doing a multi record insert with no records to insert OR
        //      any kind of insert with no columns: error
        if (
            (
                strMode !== 'single-record' &&
                jsnInsert.data.values.length === 0
            ) ||
            jsnInsert.data.columns.length === 0
        ) {
            GS.msgbox(
                'Nothing To Create',
                '<center>' +
                        'Please input data to create.' +
                        '</center>',
                ['Ok']
            );

        // sometimes, the insert has already been confirmed by the user. if it
        //      has, just carry on and insert
        } else if (jsnInsert.insertConfirmed === true) {
            insertStep();

        // else, we need to confirm with the user and then create the records
        } else {
            strPostfix = (
                (
                    strMode === 'single-record' ||
                    jsnInsert.data.values.length === 1
                )
                    ? 'this record'
                    : 'these records'
            );
            GS.msgbox(
                'Are you sure...',
                '<center>' +
                        'Are you sure you want to create ' + strPostfix + '?' +
                        '</center>',
                [
                    'No',
                    'Yes'
                ],
                function (strAnswer) {
                    if (strAnswer === 'Yes') {
                        insertStep();
                    }
                }
            );
        }
    }
    function databaseWSUPDATE(element, strMode, jsnUpdate) {
        var i;
        var len;
        var pk_i;
        var pk_len;
        var lock_i;
        var lock_len;
        var col_i;
        var col_len;

        var strPostfix;
        var beforeEvent;
        var updateStep;
        var jsnCurrentData;

        var strSchema;
        var strObject;
        var strReturn;
        var strHashColumns;
        var strRecord;
        var strUpdateData;

        var intUpdateColumnIndex;
        var arrPK;
        var arrLock;
        var startingIndex;
        var arrRecordIndexes;
        //var strTempRecord;

        var strRow;
        var jsnRow;
        var cell_i;
        var cell;
        var char;

        var strRoles;
        var strColumns;
        var arrColumnNames;
        var strHashString;
        var strTemp;
        var clearWarningFunction;

        // get schema and object attributes and get the return column list
        strSchema = GS.templateWithQuerystring(
            element.getAttribute('update-schema') || ''
        );
        strObject = GS.templateWithQuerystring(
            element.getAttribute('update-object') || ''
        );

        // the return column list must be defined the same as the column list
        //      that we store the data with, so we define strReturn using the
        //      column list
        strReturn = '';
        col_i = 0;
        col_len = element.internalData.columnNames.length;
        while (col_i < col_len) {
            strReturn += (
                strReturn
                    ? '\t'
                    : ''
            );
            strReturn += (
                element.internalData.columnNames[col_i].replace(/(\\)/g, '\\\\')
            );
            col_i += 1;
        }

        // save the column name array for speed and easy access
        arrColumnNames = element.internalData.columnNames;

        // if single cell update: we only need to gather the update info for
        //      one record
        if (strMode === 'single-cell') {
            jsnCurrentData = {
                "columnName": (
                    jsnUpdate.data.columnName.replace(/(\\)/g, '\\\\')
                ),
                "recordNumber": jsnUpdate.data.recordNumber,
                "oldValue": ""
            };
            strHashColumns = '';
            strUpdateData = '';
            startingIndex = '';

            // turn the updated column name into a column index so that we can
            //      fetch the old data from the data
            intUpdateColumnIndex = (
                element
                    .internalData
                    .columnNames
                    .indexOf(jsnUpdate.data.columnName)
            );

            // get the index of the record that will be updated
            startingIndex = jsnUpdate.data.recordNumber;

            // get the cell's old value so that when we emit before_update
            //      and after_update events we can provide the old data
            jsnCurrentData.oldValue = GS.decodeFromTabDelimited(
                element.internalData
                    .records[startingIndex]
                    .split('\t')[intUpdateColumnIndex]
            );

            // get primary key and lock column names into arrays so that we can
            //      use them for getting the PK and LOCK data and so that we
            //      can tell the websocket the names of the PK and LOCK columns
            if (element.getAttribute('pk')) {
                arrPK = (
                    GS.templateWithQuerystring(
                        element.getAttribute('pk') || ''
                    )
                ).split(/[\s]*,[\s]*/);
            } else {
                arrPK = [];
            }
            if (element.getAttribute('lock')) {
                arrLock = (
                    GS.templateWithQuerystring(
                        element.getAttribute('lock') || ''
                    )
                ).split(/[\s]*,[\s]*/);
            } else {
                arrLock = [];
            }

            //console.log('arrPK: ', arrPK);
            //console.log('arrLock: ', arrLock);

            // define "strHashColumns", "strRoles" and strColumns as empty so
            //      that we can append to them without worrying about an
            //      "undefined" appearing
            strHashColumns = '';
            strHashString = '';
            strRoles = '';
            strColumns = '';
            strUpdateData = '';

            // create record json so that we can easily get column values
            //      we need
            strRow = element.internalData.records[startingIndex];
            jsnRow = {};

            i = 0;
            len = strRow.length;
            cell_i = 0;
            cell = "";
            while (i < len) {
                char = strRow[i];

                if (char === "\t") {
                    jsnRow[arrColumnNames[cell_i]] =
                            GS.decodeFromTabDelimited(cell, '\\N');

                    cell = "";
                    cell_i += 1;
                } else {
                    cell += char;
                }
                i += 1;
            }
            jsnRow[arrColumnNames[cell_i]] =
                    GS.decodeFromTabDelimited(cell, '\\N');

            // build up column name/role list for websocket update headers
            //      using the PK columns and append pk values
            i = 0;
            len = arrPK.length;
            while (i < len) {
                strRoles += (
                    strRoles
                        ? '\t'
                        : ''
                );
                strRoles += 'pk';
                strColumns += (
                    strColumns
                        ? '\t'
                        : ''
                );
                strColumns += arrPK[i];
                strUpdateData += (
                    strUpdateData
                        ? '\t'
                        : ''
                );
                strUpdateData += jsnRow[arrPK[i]];
                i += 1;
            }

            // build up hash column name list for websocket update headers
            //      using the LOCK columns
            i = 0;
            len = arrLock.length;
            while (i < len) {
                strHashColumns += (
                    strHashColumns
                        ? '\t'
                        : ''
                );
                strHashColumns += arrLock[i];

                strHashString += (
                    strHashString
                        ? '\t'
                        : ''
                );
                strTemp = jsnRow[arrLock[i]];

                // the C encodes null values as empty string in the hash portion
                strHashString += (
                    strTemp === '\\N'
                        ? ''
                        : GS.encodeForTabDelimited(strTemp, '\\N')
                );
                i += 1;
            }

            if (strHashString) {
                strRoles += (
                    strRoles
                        ? '\t'
                        : ''
                );
                strRoles += 'hash';

                strColumns += (
                    strColumns
                        ? '\t'
                        : ''
                );
                strColumns += 'hash';

                strUpdateData += (
                    strUpdateData
                        ? '\t'
                        : ''
                );
                strUpdateData += GS.utfSafeMD5(strHashString).toString();
            }

            // build up column name/role list for websocket update headers
            //      using the update column
            strRoles += (
                strRoles
                    ? '\t'
                    : ''
            );
            strRoles += 'set';
            strColumns += (
                strColumns
                    ? '\t'
                    : ''
            );
            strColumns += jsnUpdate.data.columnName.replace(/(\\)/g, '\\\\');

            // append new value
            strUpdateData += (
                strUpdateData
                    ? '\t'
                    : ''
            );
            strUpdateData += GS.encodeForTabDelimited(jsnUpdate.data.newValue);

            // append an extra return to the end so just in case the C needs it
            strUpdateData += '\n';

            // prepend columns and roles
            strUpdateData = (
                strRoles + '\n' +
                strColumns + '\n' +
                strUpdateData
            );

            // add record index to the array
            arrRecordIndexes = [jsnUpdate.data.recordNumber];

        // else if multiple cell update: we have to gather the update info for
        //      a dynamic range of columns and rows
        } else if (strMode === 'cell-range') {
            // {
            //     "data": {
            //         "columns": arrColumns,
            //         "records": arrUpdateIndexes,
            //         "values": arrTranslated
            //     },
            //     "updateConfirmed": false
            // }
            jsnCurrentData = {
                "columns": "",
                "records": "",
                "oldValues": "",
                "newValues": ""
            };
            strHashColumns = '';
            strUpdateData = '';
            strColumns = '';
            strRoles = '';

            // we need to save the old data and the new data in jsnCurrentData
            //      so that when we trigger the "before_selection" event, the
            //      "before_selection" event will show all the data the
            //      developer could need about the update
            // ### NEED CODING ###

            // get primary key and lock column names into arrays so that we can
            //      use them for getting the PK and LOCK data and so that we
            //      can tell the websocket the names of the PK and LOCK columns
            if (element.getAttribute('pk')) {
                arrPK = (
                    GS.templateWithQuerystring(
                        element.getAttribute('pk') || ''
                    )
                ).split(/[\s]*,[\s]*/);
            } else {
                arrPK = [];
            }
            if (element.getAttribute('lock')) {
                arrLock = (
                    GS.templateWithQuerystring(
                        element.getAttribute('lock') || ''
                    )
                ).split(/[\s]*,[\s]*/);
            } else {
                arrLock = [];
            }

            // build up hash column list
            i = 0;
            len = arrLock.length;
            while (i < len) {
                strHashColumns += (
                    strHashColumns
                        ? '\t'
                        : ''
                );
                strHashColumns += arrLock[i];
                i += 1;
            }

            // add pk columns to the list of updated column names
            i = 0;
            len = arrPK.length;
            while (i < len) {
                strColumns += (
                    strColumns
                        ? '\t'
                        : ''
                );
                strColumns += arrPK[i];
                i += 1;
            }

            // build up column names
            i = 0;
            len = jsnUpdate.data.columns.length;
            while (i < len) {
                strColumns += (
                    strColumns
                        ? '\t'
                        : ''
                );
                strColumns += (
                    jsnUpdate.data.columns[i].replace(/(\\)/g, '\\\\')
                );
                i += 1;
            }

            // add the hash column to the list of column names
            strColumns += '\t';
            strColumns += 'hash';

            // build up column role list
            i = 0;
            len = arrPK.length;
            while (i < len) {
                strRoles += (
                    strRoles
                        ? '\tpk'
                        : 'pk'
                );
                i += 1;
            }
            i = 0;
            len = jsnUpdate.data.columns.length;
            while (i < len) {
                strRoles += (
                    strRoles
                        ? '\tset'
                        : 'set'
                );
                i += 1;
            }
            strRoles += '\t';
            strRoles += 'hash';

            // prepend pks to update records
            // append hashes to update records
            i = 0;
            len = jsnUpdate.data.records.length;
            while (i < len) {
                strRecord = '';

                // pk data
                pk_i = 0;
                pk_len = arrPK.length;
                while (pk_i < pk_len) {
                    strRecord += (
                        strRecord
                            ? '\t'
                            : ''
                    );
                    strRecord += getCell(
                        element,
                        arrPK[pk_i],
                        jsnUpdate.data.records[i],
                        false
                    );
                    pk_i += 1;
                }

                // new record data
                strRecord += (
                    strRecord
                        ? '\t'
                        : ''
                );
                strRecord += jsnUpdate.data.values[i];

                // hash data
                strHashString = '';
                lock_i = 0;
                lock_len = arrLock.length;
                while (lock_i < lock_len) {
                    strHashString += (
                        strHashString
                            ? '\t'
                            : ''
                    );
                    strTemp = getCell(
                        element,
                        arrLock[lock_i],
                        jsnUpdate.data.records[i],
                        false
                    );

                    // the C encodes null values as empty string
                    //      in the hash portion
                    strHashString += (
                        strTemp === '\\N'
                            ? ''
                            : GS.encodeForTabDelimited(strTemp, '\\N')
                    );
                    lock_i += 1;
                }

                strRecord += (
                    strRecord
                        ? '\t'
                        : ''
                );
                strRecord += GS.utfSafeMD5(strHashString).toString();

                // add record update to update data
                strUpdateData += strRecord;
                strUpdateData += '\n';

                //console.log('Record:', strRecord);
                i += 1;
            }

            // combine the data with the columns and roles
            strUpdateData = (
                strRoles + '\n' +
                strColumns + '\n' +
                strUpdateData
            );

            arrRecordIndexes = jsnUpdate.data.records;

            //console.log('hashcolumns: ', strHashColumns);
            //console.log('    columns: ', strColumns);
            //console.log('      roles: ', strRoles);
            //console.log('       data: ', jsnUpdate);

        // else: invalid update type: throw an error
        } else {
            throw 'GS-TABLE Error: Invalid update type. Update type "' +
                    strMode + '" is not valid, please use "single-cell" ' +
                    'or "cell-range".';
        }

        // trigger a "before_update" event so that the page has a
        //      chance to cancel the update using event.preventDefault()
        beforeEvent = GS.triggerEvent(element, 'before_update', {
            "schema": strSchema,
            "object": strObject,
            "updateMode": strMode,
            "oldData": jsnCurrentData,
            "newData": jsnUpdate.data
        });
        GS.triggerEvent(element, 'onbefore_update');
        if (element.hasAttribute('onbefore_update')) {
            new Function(
                element.getAttribute('onbefore_update')
            ).apply(element);
        }

        // if the user prevents the default on the "before_update"
        //      event, prevent the execution of the following update code
        if (beforeEvent.defaultPrevented) {
            return;
        }

        // the update step is defined as a sub function because if there
        //      are multiple cells involved in this update, we want to open
        //      a dialog before we continue, else we want to immediatly
        //      update
        updateStep = function () {
            var updatedRecords;

            // define "updatedRecords" as empty so that we can append to it
            //      without worrying about an "undefined" at the beginning of
            //      the string
            updatedRecords = '';

            // gotta let the user know that an update is in progress
            addLoader(element, 'data-update', 'Updating Data...');

            element.saveState = 'saving';
            if (element.saveTimeout) {
                clearTimeout(element.saveTimeout);
            }

            // wait five seconds to warn the user if the update is taking too
            //      long.
            element.saveTimeout = setTimeout(
                function () {
                    var arrParentElement;
                    var parentElement;
                    var warningElement;

                    // we need to know if we've already opened a warning like
                    //      this. So, we'll select for warnings that already
                    //      exist.
                    arrParentElement = tblQry(
                        element,
                        '.saving-warning-parent'
                    );

                    if (
                        // if we haven't saved and
                        element.saveState !== 'saved' &&
                        // there isn't already a warning
                        arrParentElement.length === 0
                    ) {
                        element.saveState = 'error';

                        parentElement = document.createElement('center');
                        parentElement.setAttribute(
                            'class',
                            'saving-warning-parent'
                        );

                        warningElement = document.createElement('div');
                        warningElement.setAttribute(
                            'class',
                            'saving-warning'
                        );

                        warningElement.innerHTML = (
                            'YOUR CHANGES ARE NOT SAVED<br />' +
                            'WE HAVEN\'T HEARD BACK FROM THE SERVER<br />' +
                            'EITHER THE SAVING IS SLOW OR THERE\'S AN ERROR'
                        );

                        parentElement.appendChild(warningElement);
                        element.insertBefore(
                            parentElement,
                            element.children[0]
                        );
                    }
                },
                //10         // Uncomment to test
                (5 * 1000) // Uncomment for live
            );

            clearWarningFunction = function () {
                var arrErrorElement;

                // gather warning elements
                arrErrorElement = tblQry(
                    element,
                    '.saving-warning-parent'
                );

                // if there is a warning element, remove it
                if (arrErrorElement.length > 0) {
                    element.removeChild(arrErrorElement[0]);
                }
            };

            // begin the websocket update
            GS.requestUpdateFromSocket(
                getSocket(element),
                strSchema,
                strObject,
                strReturn,
                strHashColumns,
                strUpdateData,
                // transaction start callback
                function (data, error) { //transID

                    // if the table element has been destroyed, stop execution
                    if (!element.internalData.columnNames) {
                        if (element.saveTimeout) {
                            clearTimeout(element.saveTimeout);
                        }
                        return;
                    }

                    // update failed: remove loader, popup an error
                    //      and reverse changes
                    if (error) {
                        if (element.saveTimeout) {
                            clearTimeout(element.saveTimeout);
                        }
                        element.saveState = 'error';

                        clearWarningFunction();
                        removeLoader(element, 'data-update', 'Change Failed');
                        GS.webSocketErrorDialog(data);

                        //console.log(
                        //    strSchema,
                        //    strObject,
                        //    strReturn,
                        //    strHashColumns,
                        //    strUpdateData
                        //);

                        // request fresh data
                        //getData(element);
                    }
                },
                // transaction ready for commit/rollback callback
                // "ignore" is a placeholder for "transID" and it tells JSLINT
                //      that it is an unused variable
                function (data, error, ignore, commit, rollback) {
                    if (!error) {
                        // update made it through: commit the update
                        if (data === 'TRANSACTION COMPLETED') {
                            if (element.saveTimeout) {
                                clearTimeout(element.saveTimeout);
                            }
                            element.saveState = 'saved';

                            clearWarningFunction();
                            commit();

                        // else: we've just received a data packet containing
                        //      the updated records current version
                        } else {
                            // save this data so that we can use it to update
                            //      the internal data if the update makes it
                            //      through
                            //  ,----- data already comes back with an extra \n
                            // v
                            //updatedRecords += (
                            //    updatedRecords
                            //        ? '\n'
                            //        : ''
                            //);
                            updatedRecords += data;
                            //console.log(updatedRecords, data);
                        }

                    // update failed: popup an error, rollback and
                    //      reverse change
                    } else {
                        if (element.saveTimeout) {
                            clearTimeout(element.saveTimeout);
                        }
                        element.saveState = 'error';

                        data.error_text = (
                            '\n\n' +
                            'Your unsaved value(s): ' +
                            strUpdateData.substring(
                                strUpdateData.indexOf('\n'),
                                strUpdateData.length
                            ) +
                            '\n\n' +
                            data.error_text
                        );

                        clearWarningFunction();
                        GS.webSocketErrorDialog(data);
                        rollback();
                        dataSELECT(element);

                        //renderScrollDimensions();
                        //getData(element);
                    }
                },
                // transaction commit/rollback finished callback
                function (strAnswer, data, error) {
                    var arrRecords;
                    //var i;
                    //var len;

                    // if the table element has been destroyed, stop execution
                    if (!element.internalData.columnNames) {
                        if (element.saveTimeout) {
                            clearTimeout(element.saveTimeout);
                        }
                        return;
                    }

                    // the over-the-network part of the update has finished,
                    //      remove the loader now so that if there is an
                    //      execution error below, the loader wont be stuck
                    //      visible
                    removeLoader(
                        element,
                        'data-update',
                        (
                            error
                                ? 'Change Failed'
                                : 'Change Saved'
                        )
                    );

                    if (!error) {
                        // update was successfully commited: update internal
                        //      data and re-render
                        if (strAnswer === 'COMMIT') {
                            if (element.saveTimeout) {
                                clearTimeout(element.saveTimeout);
                            }
                            element.saveState = 'saved';

                            clearWarningFunction();

                            // refresh internal data by replace each internal
                            //      record that was affected with it's new
                            //      version
                            arrRecords = updatedRecords.split('\n');
                            i = 0;
                            len = arrRecords.length - 1; // the - 1 is because
                                                         //   of the extra \n at
                                                         //   the end of the
                                                         //   returned records
                            while (i < len) {
                                element.internalData
                                    .records[arrRecordIndexes[i]] = (
                                        arrRecords[i]
                                    );
                                i += 1;
                            }

                            dataUPDATEcallback(element);

                            // trigger an after update event
                            GS.triggerEvent(element, 'after_update', {
                                "updateMode": strMode,
                                "oldData": jsnCurrentData,
                                "newData": jsnUpdate.data
                            });
                            GS.triggerEvent(element, 'onafter_update');
                            if (element.hasAttribute('onafter_update')) {
                                new Function(
                                    element.getAttribute('onafter_update')
                                ).apply(element);
                            }
                        // transaction was rolled back: reverse change
                        } else {
                            //getData(element);
                        }
                    // update failed: popup an error and reverse change
                    } else {
                        if (element.saveTimeout) {
                            clearTimeout(element.saveTimeout);
                        }
                        element.saveState = 'error';

                        clearWarningFunction();
                        GS.webSocketErrorDialog(data);

                        //getData(element);
                        //console.log(
                        //    strSchema,
                        //    strObject,
                        //    strReturn,
                        //    strHashColumns,
                        //    strUpdateData
                        //);
                    }
                }
            );
        };

        // if the update has been confirmed: carry on and update
        if (jsnUpdate.updateConfirmed === true) {
            updateStep();

        // else, we need to confirm the update
        } else {
            strPostfix = (
                (
                    !jsnUpdate.data.records ||
                    jsnUpdate.data.records.length === 1
                )
                    ? 'this record'
                    : 'these records'
            );
            GS.msgbox(
                'Are you sure...',
                '<center>' +
                        'Are you sure you want to update ' + strPostfix + '?' +
                        '</center>',
                [
                    'No',
                    'Yes'
                ],
                function (strAnswer) {
                    if (strAnswer === 'Yes') {
                        updateStep();
                    }
                }
            );
        }

        // commented out in favor of "updateConfirmed" logic
        //// if multiple cells will be updated: confirm update
        //if (strMode === 'cell-range') {
        //    GS.msgbox(
        //        'Are you sure...',
        //        '<center>' +
        //                'Are you sure you want to update these records?' +
        //                '</center>',
        //        [
        //            'No',
        //            'Yes'
        //        ],
        //        function (strAnswer) {
        //            if (strAnswer === 'Yes') {
        //                updateStep();
        //            }
        //        }
        //    );

        //// else if single cell: update immediately
        //} else if (strMode === 'single-cell') {
        //    updateStep();
        //}
    }
    function databaseWSDELETE(element, jsnDelete) {
        var i;
        var len;
        var col_i;
        var col_len;
        var strSchema;
        var strObject;
        var strPostfix;

        var beforeEvent;
        var deleteStep;

        var strPK;
        var strLock;
        var arrPK;
        var arrLock;

        var intIndex;
        var arrColumns;

        var strColumnNames;
        var strColumnRoles;
        var strHashColumns;
        var strRecordToHash;
        var strTemp;
        var strDeleteData;
        var strDeleteRecords;
        var arrDeleteRecord;
        var strRecord;

        var strNullString;

        // get schema and object attributes and get the return column list
        strSchema = GS.templateWithQuerystring(
            element.getAttribute('delete-schema') || ''
        );
        strObject = GS.templateWithQuerystring(
            element.getAttribute('delete-object') || ''
        );

        // we want the null string to be configurable, so we'll read the
        //      "null-string" attribute to get the null string
        // if the "null-string" attribute is present, use the contents
        //      or coalesce to empty string
        if (element.hasAttribute('null-string')) {
            strNullString = element.getAttribute('null-string') || '';

        // else, null string is left up to the encoding function
        } else {
            strNullString = undefined;
        }

        // create variables for websocket delete call

        // we need to know the primary key columns and the lock columns
        strPK = (element.getAttribute('pk') || '');
        strLock = (element.getAttribute('lock') || '');
        arrPK = strPK.split(/[\s]*,[\s]*/);
        arrLock = strLock.split(/[\s]*,[\s]*/);

        // when we start getting the data for the records we need to delete,
        //      we're going to need to be able to grab the correct columns by
        //      name, so we'll save the currently selected column list to a
        //      local variable for convenience
        arrColumns = element.internalData.columnNames;

        // initialize column name and column role variables so that we
        //      can append to them safely
        strColumnRoles = '';
        strColumnNames = '';

        // append pk columns and roles
        i = 0;
        len = arrPK.length;
        while (i < len) {
            strColumnNames += (
                strColumnNames
                    ? "\t"
                    : ""
            );
            strColumnNames += arrPK[i];
            strColumnRoles += (
                strColumnRoles
                    ? "\t"
                    : ""
            );
            strColumnRoles += "pk";
            i += 1;
        }

        // append column and role for the hash column
        strColumnNames += (
            strColumnNames
                ? "\t"
                : ""
        );
        strColumnNames += "hash";
        strColumnRoles += (
            strColumnRoles
                ? "\t"
                : ""
        );
        strColumnRoles += "hash";

        // build up hash column list
        strHashColumns = '';
        i = 0;
        len = arrLock.length;
        while (i < len) {
            strHashColumns += (
                strHashColumns
                    ? "\t"
                    : ""
            );
            strHashColumns += arrLock[i];
            i += 1;
        }

        // now that we have the metadata taken care of, gather up the records
        strDeleteRecords = '';
        i = 0;
        len = jsnDelete.recordIndexes.length;


        //// create cell array for this record
        //strRecord = element.internalData.records[i] + '\t';
        //arrDeleteRecord = [];
        //col_i = 0;
        //col_len = element.internalData.columnNames.length;//9999;
        //while (col_i < col_len) {
        //    delim = strRecord.indexOf('\t');
        //    strCell = strRecord.substring(0, delim);
        //    strRecord = strRecord.substring(delim + 1);

        //    arrDeleteRecord.push(
        //        GS.decodeFromTabDelimited(strCell, strNullString)
        //    );

        //    col_i += 1;
        //}


        while (i < len) {
            strRecord = '';
            arrDeleteRecord = element.internalData.records[
                jsnDelete.recordIndexes[i]
            ].split("\t");

            // get PK columns
            col_i = 0;
            col_len = arrPK.length;
            while (col_i < col_len) {
                // get column index for this current PK
                intIndex = arrColumns.indexOf(arrPK[col_i]);

                // append cell to current delete record
                strRecord += (
                    strRecord
                        ? "\t"
                        : ""
                );
                strRecord += GS.encodeForTabDelimited(
                    arrDeleteRecord[intIndex],
                    strNullString
                );

                col_i += 1;
            }

            // get hash columns
            strRecordToHash = "";
            col_i = 0;
            col_len = arrLock.length;
            while (col_i < col_len) {
                //// get column index for this current hash column
                //intIndex = arrColumns.indexOf(arrLock[col_i]);

                // append cell to current hash record
                strRecordToHash += (
                    strRecordToHash
                        ? "\t"
                        : ""
                );
                //strTemp = arrDeleteRecord[intIndex];
                strTemp = getCell(
                    element,
                    arrLock[col_i],
                    jsnDelete.recordIndexes[i],
                    false
                );

                // I saw this in the code I copied while making this:
                //      "I believe that this needs to
                //          use the null-string instead of 'NULL'"
                strRecordToHash += (
                    strTemp === "\\N"
                        ? ""
                        : strTemp
                );

                col_i += 1;
            }

            // append record to deleteData
            strDeleteRecords += strRecord;
            strDeleteRecords += (
                strRecord
                    ? '\t'
                    : ''
            );
            strDeleteRecords += GS.utfSafeMD5(strRecordToHash).toString();
            strDeleteRecords += '\n';

            i += 1;
        }

        // combine the metadata with the delete records
        strDeleteData = (
            strColumnRoles + '\n' +
            strColumnNames + '\n' +
            strDeleteRecords
        );

        // trigger a "before_update" event so that the page has a
        //      chance to cancel the update using event.preventDefault()
        beforeEvent = GS.triggerEvent(element, 'before_delete', {
            "schema": strSchema,
            "object": strObject,
            "recordIndexes": jsnDelete.recordIndexes,
            "deleteConfirmed": jsnDelete.deleteConfirmed,
            "strColumnRoles": strColumnRoles,
            "strColumnNames": strColumnNames,
            "strDeleteRecords": strDeleteRecords
        });
        GS.triggerEvent(element, 'onbefore_delete');
        if (element.hasAttribute('onbefore_delete')) {
            new Function(
                element.getAttribute('onbefore_delete')
            ).apply(element);
        }

        // if the user prevents the default on the "before_update"
        //      event, prevent the execution of the following update code
        if (beforeEvent.defaultPrevented) {
            return;
        }

        // the delete step is defined as a sub function because we only
        //      want to do the delete under certain circumstances
        deleteStep = function () {
            // gotta let the user know that an update is in progress
            addLoader(element, 'data-delete', 'Deleting Data...');

            // begin the websocket update
            GS.requestDeleteFromSocket(
                getSocket(element),
                strSchema,
                strObject,
                strHashColumns,
                strDeleteData,
                // transaction start callback
                function (data, error) { //transID
                    // if the table element has been destroyed, stop execution
                    if (!element.internalData.columnNames) {
                        return;
                    }

                    // delete failed: remove loader, popup an error
                    if (error) {
                        removeLoader(element, 'data-delete', 'Delete Failed');
                        GS.webSocketErrorDialog(data);
                    }
                },
                // transaction ready for commit/rollback callback
                // "ignore" is a placeholder for "transID" and it tells JSLINT
                //      that it is an unused variable
                function (data, error, ignore, commit, rollback) {
                    // if the table element has been destroyed, stop execution
                    if (!element.internalData.columnNames) {
                        rollback();
                        return;
                    }

                    if (!error) {
                        // delete made it through: commit the delete
                        if (data === 'TRANSACTION COMPLETED') {
                            commit();
                        }
                    // delete failed: popup an error, rollback
                    } else {
                        GS.webSocketErrorDialog(data);
                        rollback();
                    }
                },
                // transaction commit/rollback finished callback
                function (strAnswer, data, error) {
                    var arrRecords;
                    var arrRecordHeights;

                    // if the table element has been destroyed, stop execution
                    if (!element.internalData.columnNames) {
                        return;
                    }

                    // the over-the-network part of the delete has finished,
                    //      remove the loader now so that if there is an
                    //      execution error below, the loader wont be stuck
                    //      visible
                    removeLoader(
                        element,
                        'data-delete',
                        (
                            error
                                ? 'Delete Failed'
                                : 'Delete Successful'
                        )
                    );

                    if (!error) {
                        // delete was successfully commited: update internal
                        //      data and re-render
                        if (strAnswer === 'COMMIT') {
                            // now that the delete was successful, we'll
                            //      recreate the record and record height
                            //      arrays and skip the records at the indexes
                            //      that were deleted
                            // Some of you may be asking:
                            //      "why doesn't he just use .splice()?".
                            //      That, young grasshopper, is because through
                            //      my travels I've found .splice() to be
                            //      significantly slower than simply rebuilding
                            //      the array. This is what I do in Postage's
                            //      tree code.
                            arrRecords = [];
                            arrRecordHeights = [];

                            i = 0;
                            len = element.internalData.records.length;
                            while (i < len) {
                                if (jsnDelete.recordIndexes.indexOf(i) === -1) {
                                    arrRecords.push(
                                        element.internalData.records[i]
                                    );
                                    arrRecordHeights.push(
                                        element.internalDisplay.recordHeights[i]
                                    );
                                }
                                i += 1;
                            }

                            // set the internal record and record heights to
                            //      the newly pruned arrays
                            element
                                .internalData
                                .records = arrRecords;
                            element
                                .internalDisplay
                                .recordHeights = arrRecordHeights;

                            // standard after delete procedure
                            dataDELETEcallback(element);

                            // trigger an after delete event
                            GS.triggerEvent(element, 'after_delete', {
                                "schema": strSchema,
                                "object": strObject,
                                "recordIndexes": jsnDelete.recordIndexes,
                                "strColumnRoles": strColumnRoles,
                                "strColumnNames": strColumnNames,
                                "strDeleteRecords": strDeleteRecords
                            });
                            GS.triggerEvent(element, 'onafter_delete');
                            if (element.hasAttribute('onafter_delete')) {
                                new Function(
                                    element.getAttribute('onafter_delete')
                                ).apply(element);
                            }
                        }
                    // delete failed: popup an error
                    } else {
                        GS.webSocketErrorDialog(data);
                    }
                }
            );
        };

        // if no records have been sent to delete: error
        if (jsnDelete.recordIndexes.length === 0) {
            GS.msgbox(
                'No Records To Delete',
                '<center>' +
                        'Please choose a record to delete.' +
                        '</center>',
                ['Ok']
            );

        // else if the delete has been confirmed: carry on and delete
        } else if (jsnDelete.deleteConfirmed === true) {
            deleteStep();

        // else, we need to confirm the delete
        } else {
            strPostfix = (
                jsnDelete.recordIndexes.length === 1
                    ? 'this record'
                    : 'these records'
            );
            GS.msgbox(
                'Are you sure...',
                '<center>' +
                        'Are you sure you want to delete ' + strPostfix + '?' +
                        '</center>',
                [
                    'No',
                    'Yes'
                ],
                function (strAnswer) {
                    if (strAnswer === 'Yes') {
                        deleteStep();
                    }
                }
            );
        }
    }

    // sometimes, you dont want to save to the database, that's what these
    //      internal SELECT, INSERT, UPDATE and DELETE functions are for

    function internalSELECT(element) {
        var templateElement;
        var arrColumns;

        // on the first load, the GS-TABLE doesn't know what the column names
        //      are. so, here we'll scan the templates to come up with a column
        //      list
        if (element.internalData.columnNames.length === 0) {
            templateElement = document.createElement('template');

            // we'll check the insertDialog template for column names
            templateElement.innerHTML = element.internalTemplates.insertDialog;
            arrColumns = templateGetColumnList(templateElement);
            arrColumns.forEach(function (strColumn) {
                if (
                    element.internalData.columnNames.indexOf(strColumn) === -1
                ) {
                    element.internalData.columnNames.push(strColumn);
                    element.internalData.columnTypes.push('text');
                    element.internalData.columnFilterStatuses.push('on');
                    element.internalData.columnFilters.push([]);
                    element.internalData.columnListFilters.push({});
                    element.internalData.columnOrders.push('neutral');
                }
            });

            // we'll check the insertRecord template for column names
            templateElement.innerHTML = (
                element.internalTemplates.insertRecord.templateHTML
            );
            arrColumns = templateGetColumnList(templateElement);
            arrColumns.forEach(function (strColumn) {
                if (
                    element.internalData.columnNames.indexOf(strColumn) === -1
                ) {
                    element.internalData.columnNames.push(strColumn);
                    element.internalData.columnTypes.push('text');
                    element.internalData.columnFilterStatuses.push('on');
                    element.internalData.columnFilters.push([]);
                    element.internalData.columnListFilters.push({});
                    element.internalData.columnOrders.push('neutral');
                }
            });

            // we'll check the record template for column names
            templateElement.innerHTML = (
                element.internalTemplates.record.templateHTML
            );
            arrColumns = templateGetColumnList(templateElement);
            arrColumns.forEach(function (strColumn) {
                if (
                    element.internalData.columnNames.indexOf(strColumn) === -1
                ) {
                    element.internalData.columnNames.push(strColumn);
                    element.internalData.columnTypes.push('text');
                    element.internalData.columnFilterStatuses.push('on');
                    element.internalData.columnFilters.push([]);
                    element.internalData.columnListFilters.push({});
                    element.internalData.columnOrders.push('neutral');
                }
            });
        }

        // we need to re-render and all that jazz
        dataSELECTcallback(element);
    }

    function internalINSERT(element, strMode, jsnInsert) {
        var beforeEvent;
        var insertStep;
        var strPostfix;
        var strNullString;
        var intRecordHeight;
        var strRecord;
        var arrRecords;
        var arrRecord;
        var arrColumns;
        var strColumn;
        var strValue;
        var index;
        var i;
        var len;
        //var rec_i;
        //var rec_len;
        var col_i;
        var col_len;

        //console.log(element, strMode, jsnInsert); //multi-record

        // we want the null string to be configurable, so we'll read the
        //      "null-string" attribute to get the null string
        // if the "null-string" attribute is present, use the contents
        //      or coalesce to empty string
        if (element.hasAttribute('null-string')) {
            strNullString = element.getAttribute('null-string') || '';

        // else, null string is left up to the encoding function
        } else {
            strNullString = undefined;
        }

        // we need to create records with the default record height attached to
        //      them, so we'll use the "default-cell-height" attribute
        intRecordHeight = (
            parseInt(element.getAttribute('default-cell-height'), 10) ||
            intDefaultRecordHeight
        );

        // trigger a "before_insert" event so that the page has a
        //      chance to cancel the update using event.preventDefault()
        beforeEvent = GS.triggerEvent(element, 'before_insert', {
            "insertMode": strMode,
            "insertData": jsnInsert.data
        });
        GS.triggerEvent(element, 'onbefore_insert');
        if (element.hasAttribute('onbefore_insert')) {
            new Function(
                element.getAttribute('onbefore_insert')
            ).apply(element);
        }

        // if the user prevents the default on the "before_update"
        //      event, prevent the execution of the following update code
        if (beforeEvent.defaultPrevented) {
            return;
        }

        // sometimes, we need to call the insert only after a confirmation.
        //      other times, we insert immediately. separating the insert
        //      code into a sub-function allows us to call it at different
        //      times under different circumstances
        insertStep = function () {
            // gotta let the user know that an insert is in progress
            addLoader(element, 'data-insert', 'Inserting Data...');

            // if single record insert:
            if (strMode === "single-record") {
                /*
                jsnInsert = {
                    "data": {
                        "addin": {
                            "link_column": "columnname4",
                            "link_value": "value"
                        },
                        "columns": [
                            "columnname1",
                            "columnname2",
                            "columnname3"
                            ...
                        ],
                        "values": {
                            "columnname1": "value",
                            "columnname2": "value",
                            "columnname3": "value"
                            ...
                        }
                    },
                    "insertConfirmed": boolean
                }
                */

                // loop through internal column list, build up new record
                //      ignoring columns that don't exist and adding nulls
                //      for columns that exist but weren't filled in
                strRecord = "";
                arrColumns = element.internalData.columnNames;
                i = 0;
                len = arrColumns.length;
                while (i < len) {
                    strColumn = arrColumns[i];

                    // separate columns with tab characters
                    if (i > 0) {
                        strRecord += "\t";
                    }

                    // get value for column
                    strValue = jsnInsert.data.values[strColumn];

                    // if column is defined in insert values
                    if (strValue !== undefined) {
                        strRecord += GS.encodeForTabDelimited(
                            strValue,
                            strNullString
                        );

                    // if column is defined in addin values
                    } else if (jsnInsert.data.addin.link_column === strColumn) {
                        strRecord += GS.encodeForTabDelimited(
                            jsnInsert.data.addin.link_value,
                            strNullString
                        );

                    // else, null the cell
                    } else {
                        strRecord += '\\N';
                    }

                    i += 1;
                }

                // append record text and record height to internal variables
                element.internalData.records.push(strRecord);
                element.internalDisplay.recordHeights.push(intRecordHeight);

            // else if multi record insert:
            } else if (strMode === "multi-record") {
                /*
                jsnInsert = {
                    "data": {
                        "addin": {
                            "link_column": "columnname4",
                            "link_value": "value"
                        },
                        "columns": [
                            "columnname1",
                            "columnname2"
                            ...
                        ],
                        "values": [
                            "value1\tvalue1",
                            "value2\tvalue2",
                            "value3\tvalue3"
                            ...
                        ]
                    },
                    "insertConfirmed": boolean
                }
                */

                // loop through internal column list, build up new record
                //      ignoring columns that don't exist and adding nulls
                //      for columns that exist but weren't filled in
                arrRecords = [];
                arrColumns = element.internalData.columnNames;
                // ### NEED CODING ###
                i = 0;
                len = jsnInsert.data.values.length;
                while (i < len) {

                    // split record
                    strRecord = jsnInsert.data.values[i];
                    arrRecord = strRecord.split('\t');
                    //rec_i = 0;
                    //rec_len = strRecord.length;
                    //while (rec_i < rec_len) {
                    //    rec_i += 1;
                    //}

                    // create full records
                    strRecord = "";
                    col_i = 0;
                    col_len = arrColumns.length;
                    while (col_i < col_len) {
                        strColumn = arrColumns[col_i];
                        index = jsnInsert.data.columns.indexOf(strColumn);
                        strValue = arrRecord[index];

                        // separate columns with tab characters
                        if (col_i > 0) {
                            strRecord += "\t";
                        }

                        // get value for current column
                        if (strValue) {
                            strRecord += arrRecord[index];

                        // if column is defined in addin values
                        } else if (
                            jsnInsert.data.addin.link_column === strColumn
                        ) {
                            strRecord += GS.encodeForTabDelimited(
                                jsnInsert.data.addin.link_value,
                                strNullString
                            );

                        // else, null the cell
                        } else {
                            strRecord += '\\N';
                        }

                        col_i += 1;
                    }

                    // push new record to expanded record list
                    arrRecords.push(strRecord);

                    i += 1;
                }

                // append record text and record height to internal variables
                i = 0;
                len = arrRecords.length;
                while (i < len) {
                    element.internalData.records.push(arrRecords[i]);
                    element.internalDisplay.recordHeights.push(intRecordHeight);
                    i += 1;
                }
            }

            // we need to let the user know the insert is finished
            removeLoader(element, 'data-insert', 'New Record Saved');

            // standard after-insert behaviour
            dataINSERTcallback(element);

            // trigger an after insert event
            GS.triggerEvent(element, 'after_insert', {
                "insertMode": strMode,
                "insertData": jsnInsert.data
            });
            GS.triggerEvent(element, 'onafter_insert');
            if (element.hasAttribute('onafter_insert')) {
                new Function(
                    element.getAttribute('onafter_insert')
                ).apply(element);
            }
        };

        // we don't want to be able to insert of there's no insert data, so if
        //      we're doing a multi record insert with no records to insert OR
        //      any kind of insert with no columns: error
        if (
            (
                strMode !== 'single-record' &&
                jsnInsert.data.values.length === 0
            ) ||
            jsnInsert.data.columns.length === 0
        ) {
            GS.msgbox(
                'Nothing To Create',
                '<center>' +
                        'Please input data to create.' +
                        '</center>',
                ['Ok']
            );

        // sometimes, the insert has already been confirmed by the user. if it
        //      has, just carry on and insert
        } else if (jsnInsert.insertConfirmed === true) {
            insertStep();

        // else, we need to confirm with the user and then create the records
        } else {
            strPostfix = (
                (
                    strMode === 'single-record' ||
                    jsnInsert.data.values.length === 1
                )
                    ? 'this record'
                    : 'these records'
            );
            GS.msgbox(
                'Are you sure...',
                '<center>' +
                        'Are you sure you want to create ' + strPostfix + '?' +
                        '</center>',
                [
                    'No',
                    'Yes'
                ],
                function (strAnswer) {
                    if (strAnswer === 'Yes') {
                        insertStep();
                    }
                }
            );
        }
    }
    function internalUPDATE(element, strMode, jsnUpdate) {
        var i;
        var len;
        var row_i;
        var row_len;

        var strPostfix;
        var beforeEvent;
        var updateStep;
        var jsnCurrentData;

        var intUpdateColumnIndex;
        var arrUpdateColumnIndexes;
        var startingIndex;
        var arrUpdatePaste;

        var update_i;
        var cell_i;
        var cell;
        var char;

        var strOldRow;
        var strNewRow;
        var arrRecordIndexes;
        var arrRecordReplacements;

        //console.log(element, strMode, jsnUpdate);

        // we need to be able to have unupdatable columns
        // ### NEED CODING ###

        // we need to be able to use the data from a header-child relationship
        // ### NEED CODING ###

        // this function updates internal data and then re-renders. essentially,
        //      we'll be masking the new data over the old data.

        // if single cell update: we only need to gather the update info for
        //      one record
        if (strMode === 'single-cell') {
            jsnCurrentData = {
                "columnName": jsnUpdate.data.columnName,
                "recordNumber": jsnUpdate.data.recordNumber,
                "oldValue": ""
            };

            // turn the updated column name into a column index so that we can
            //      fetch the old data from the data
            intUpdateColumnIndex = (
                element
                    .internalData
                    .columnNames
                    .indexOf(jsnUpdate.data.columnName)
            );

            // get the index of the record that will be updated
            startingIndex = jsnUpdate.data.recordNumber;

            // get the old record and get the new record variable ready for
            //      masking
            strOldRow = element.internalData.records[startingIndex];
            strNewRow = '';

            // loop through each character of the record and begin masking
            i = 0;
            len = strOldRow.length;
            cell_i = 0;
            cell = "";
            while (i < len) {
                char = strOldRow[i];

                // if the cell end has been reached
                if (char === "\t" || i === (len - 1)) {
                    // we don't want to chop the last character off
                    if (i === (len - 1)) {
                        cell += char;
                    }

                    // if the cell number is the cell we want to replace,
                    //      insert new value instead of the old value
                    if (cell_i === intUpdateColumnIndex) {
                        strNewRow += GS.encodeForTabDelimited(
                            jsnUpdate.data.newValue
                        );

                        // save the old value for the developer in the
                        //      "before_update" and "after_update" events
                        jsnCurrentData.oldValue = cell;

                    // else, maintain old data
                    } else {
                        strNewRow += cell;
                    }

                    cell = "";
                    cell_i += 1;

                // else, keep building up the cell variable
                } else {
                    cell += char;
                }

                // we want to maintain the tab characters
                if (char === "\t") {
                    strNewRow += '\t';
                }

                i += 1;
            }

            // regardless of single or multi-record updates, we use the same
            //      code to make the change in the internal data. this code
            //      needs the record indexes of the update records and the new
            //      version of each of the records

            // add record index to the updated record list
            arrRecordIndexes = [startingIndex];

            // add new record to updated data array
            arrRecordReplacements = [strNewRow];

        // else if multiple cell update: we have to gather the update info for
        //      a dynamic range of columns and rows
        } else if (strMode === 'cell-range') {
            // {
            //     "data": {
            //         "columns": arrColumns,
            //         "records": arrUpdateIndexes,
            //         "values": arrTranslated
            //     },
            //     "updateConfirmed": false
            // }
            jsnCurrentData = {
                "columns": "",
                "records": "",
                "oldValues": "",
                "newValues": ""
            };

            // we need to save the old data and the new data in jsnCurrentData
            //      so that when we trigger the "before_selection" event, the
            //      "before_selection" event will show all the data the
            //      developer could need about the update
            // ### NEED CODING ###

            // we need to know the indexes of the columns we're updating
            arrUpdateColumnIndexes = [];
            i = 0;
            len = jsnUpdate.data.columns.length;
            while (i < len) {
                arrUpdateColumnIndexes.push(
                    element.internalData.columnNames
                        .indexOf(jsnUpdate.data.columns[i])
                );

                i += 1;
            }

            // loop through records and mask over old values for each
            i = 0;
            len = jsnUpdate.data.records.length;
            arrRecordReplacements = [];
            while (i < len) {
                // get the old record and get the new record variable ready for
                //      masking
                strOldRow = element.internalData.records[
                    jsnUpdate.data.records[i]
                ];
                strNewRow = '';
                arrUpdatePaste = jsnUpdate.data.values[i].split('\t');
                update_i = 0;

                // loop through each character of the record and begin masking
                row_i = 0;
                row_len = strOldRow.length;
                cell_i = 0;
                cell = "";
                while (row_i < row_len) {
                    char = strOldRow[row_i];

                    // if the cell end has been reached
                    if (char === "\t" || row_i === (row_len - 1)) {
                        // if the cell number is the cell we want to replace,
                        //      insert new value instead of the old value
                        if (arrUpdateColumnIndexes.indexOf(cell_i) > -1) {
                            strNewRow += arrUpdatePaste[update_i] || '\\N';
                            update_i += 1;

                        // else, maintain old data
                        } else {
                            strNewRow += cell;
                        }

                        cell = "";
                        cell_i += 1;

                    // else, keep building up the cell variable
                    } else {
                        cell += char;
                    }

                    // we want to maintain the tab characters
                    if (char === "\t") {
                        strNewRow += '\t';
                    }

                    row_i += 1;
                }

                //console.log(' strOldRow: ', strOldRow);
                //console.log(' strNewRow: ', strNewRow);

                arrRecordReplacements.push(strNewRow);

                i += 1;
            }

            arrRecordIndexes = jsnUpdate.data.records;

            //console.log('arrUpdateColumnIndexes: ', arrUpdateColumnIndexes);
            //console.log(' arrRecordReplacements: ', arrRecordReplacements);
            //console.log('      arrRecordIndexes: ', arrRecordIndexes);

        // else: invalid update type: throw an error
        } else {
            throw 'GS-TABLE Error: Invalid update type. Update type "' +
                    strMode + '" is not valid, please use "single-cell" ' +
                    'or "cell-range".';
        }

        // trigger a "before_update" event so that the page has a
        //      chance to cancel the update using event.preventDefault()
        beforeEvent = GS.triggerEvent(element, 'before_update', {
            "updateMode": strMode,
            "oldData": jsnCurrentData,
            "newData": jsnUpdate.data
        });
        GS.triggerEvent(element, 'onbefore_update');
        if (element.hasAttribute('onbefore_update')) {
            new Function(
                element.getAttribute('onbefore_update')
            ).apply(element);
        }

        // if the user prevents the default on the "before_update"
        //      event, prevent the execution of the following update code
        if (beforeEvent.defaultPrevented) {
            return;
        }

        // the update step is defined as a sub function because if there
        //      are multiple cells involved in this update, we want to open
        //      a dialog before we continue, else we want to immediatly
        //      update
        updateStep = function () {
            // gotta let the user know that an update is in progress
            addLoader(element, 'data-update', 'Updating Data...');

            // utilize the updated record and updated record index arrays to
            //      replace the old data with the new data
            i = 0;
            len = arrRecordIndexes.length;
            while (i < len) {
                element.internalData.records[
                    arrRecordIndexes[i]
                ] = (
                    arrRecordReplacements[i]
                );

                i += 1;
            }

            // re-render and do whatever standard after-update items need
            //      to be done
            dataUPDATEcallback(element);

            // trigger an after update event
            GS.triggerEvent(element, 'after_update', {
                "updateMode": strMode,
                "oldData": jsnCurrentData,
                "newData": jsnUpdate.data
            });
            GS.triggerEvent(element, 'onafter_update');
            if (element.hasAttribute('onafter_update')) {
                new Function(
                    element.getAttribute('onafter_update')
                ).apply(element);
            }

            // the update has finished, let the user know and remove the loader
            removeLoader(element, 'data-update', 'Change Saved');
        };

        // if the update has been confirmed: carry on and update
        if (jsnUpdate.updateConfirmed === true) {
            updateStep();

        // else, we need to confirm the update
        } else {
            strPostfix = (
                (
                    !jsnUpdate.data.records ||
                    jsnUpdate.data.records.length === 1
                )
                    ? 'this record'
                    : 'these records'
            );
            GS.msgbox(
                'Are you sure...',
                '<center>' +
                        'Are you sure you want to update ' + strPostfix + '?' +
                        '</center>',
                [
                    'No',
                    'Yes'
                ],
                function (strAnswer) {
                    if (strAnswer === 'Yes') {
                        updateStep();
                    }
                }
            );
        }
    }
    function internalDELETE(element, jsnDelete) {
        var strPostfix;

        var beforeEvent;
        var deleteStep;

        // trigger a "before_update" event so that the page has a
        //      chance to cancel the update using event.preventDefault()
        beforeEvent = GS.triggerEvent(element, 'before_delete', {
            "recordIndexes": jsnDelete.recordIndexes,
            "deleteConfirmed": jsnDelete.deleteConfirmed
        });
        GS.triggerEvent(element, 'onbefore_delete');
        if (element.hasAttribute('onbefore_delete')) {
            new Function(
                element.getAttribute('onbefore_delete')
            ).apply(element);
        }

        // if the user prevents the default on the "before_update"
        //      event, prevent the execution of the following update code
        if (beforeEvent.defaultPrevented) {
            return;
        }

        // the delete step is defined as a sub function because we only
        //      want to do the delete under certain circumstances
        deleteStep = function () {
            var arrRecords;
            var arrRecordHeights;
            var i;
            var len;

            // gotta let the user know that an update is in progress
            addLoader(element, 'data-delete', 'Deleting Data...');

            // now that the delete was confirmed, we'll
            //      recreate the record and record height
            //      arrays and skip the records at the indexes
            //      that were deleted
            // Some of you may be asking:
            //      "why doesn't he just use .splice()?".
            //      That, young grasshopper, is because through
            //      my travels I've found .splice() to be
            //      significantly slower than simply rebuilding
            //      the array. This is what I do in Postage's
            //      tree code.
            arrRecords = [];
            arrRecordHeights = [];

            i = 0;
            len = element.internalData.records.length;
            while (i < len) {
                if (jsnDelete.recordIndexes.indexOf(i) === -1) {
                    arrRecords.push(
                        element.internalData.records[i]
                    );
                    arrRecordHeights.push(
                        element.internalDisplay.recordHeights[i]
                    );
                }
                i += 1;
            }

            // set the internal record and record heights to
            //      the newly pruned arrays
            element.internalData.records = arrRecords;
            element.internalDisplay.recordHeights = arrRecordHeights;

            // gotta let the user know that we finished
            removeLoader(element, 'data-delete', 'Delete Successful');

            // standard after delete procedure
            dataDELETEcallback(element);

            // trigger an after delete event
            GS.triggerEvent(element, 'after_delete', {
                "recordIndexes": jsnDelete.recordIndexes
            });
            GS.triggerEvent(element, 'onafter_delete');
            if (element.hasAttribute('onafter_delete')) {
                new Function(
                    element.getAttribute('onafter_delete')
                ).apply(element);
            }
        };

        // if no records have been sent to delete: error
        if (jsnDelete.recordIndexes.length === 0) {
            GS.msgbox(
                'No Records To Delete',
                '<center>' +
                        'Please choose a record to delete.' +
                        '</center>',
                ['Ok']
            );

        // else if the delete has been confirmed: carry on and delete
        } else if (jsnDelete.deleteConfirmed === true) {
            deleteStep();

        // else, we need to confirm the delete
        } else {
            strPostfix = (
                jsnDelete.recordIndexes.length === 1
                    ? 'this record'
                    : 'these records'
            );
            GS.msgbox(
                'Are you sure...',
                '<center>' +
                        'Are you sure you want to delete ' + strPostfix + '?' +
                        '</center>',
                [
                    'No',
                    'Yes'
                ],
                function (strAnswer) {
                    if (strAnswer === 'Yes') {
                        deleteStep();
                    }
                }
            );
        }
    }



    function databaseWSSELECTcolumnUnique(
        element,
        uniqueFilterElement,
        valueListElement,
        strColumn
    ) {
        var socket = getSocket(element);
        var strQuery;
        var strSchema;
        var strObject;
        var strWhere;

        strQuery = GS.templateWithQuerystring(
            element.getAttribute('select-query') || ''
        );
        strSchema = GS.templateWithQuerystring(
            element.getAttribute('select-schema') || ''
        );
        strObject = GS.templateWithQuerystring(
            element.getAttribute('select-object') || ''
        );
        strWhere = element.getAttribute('where') || '1=1';
        // This way other filters apply to the current filter
        // TODO: Michael is this correct?
        // I think that the current filter that we are choosing should
        //      not be in this select

        var strSrc = (
            ml(function () {/*
                SELECT count(*) AS count
                     , COALESCE(
                            NULLIF(CAST("{{COLUMN}}" AS text), ''),
                            '(blanks)'
                       ) AS unique_value
                  FROM {{OBJECT}}
                  WHERE {{WHERE}}
              GROUP BY NULLIF(CAST("{{COLUMN}}" AS text), '')
              ORDER BY NULLIF(CAST("{{COLUMN}}" AS text), '') ASC NULLS FIRST
            */
            })
                .replace(/\{\{WHERE\}\}/gi, strWhere)
                .replace(/\{\{COLUMN\}\}/gi, strColumn)
                .replace(
                    /\{\{OBJECT\}\}/gi,
                    (strQuery || (strSchema + '.' + strObject))
                )
        );

        var bolUncheckedFound = false;
        var arrData;
        var jsnFilter;

        arrData = [
            '' // placeholder for "Select All" record
        ];
        jsnFilter = (
            element.internalData.columnListFilters[
                element.internalData.columnNames.indexOf(strColumn)
            ]
        );

        GS.requestArbitrarySelectFromSocket(
            socket,
            '(' + strSrc + ') unique_list',
            '',
            '',
            '',
            '',
            function (data, error) {
                var i;
                //var len;
                var tableElement;
                //var strCheck;
                var index;
                var strValue;
                //var strType;
                var strMessage = data.strMessage;
                var strRecord;
                //var arrRecords = [];
                var arrRecord = [];

                if (!error && data.strMessage === 'TRANSACTION COMPLETED') {
                    // we want the select all to only be checked if all
                    //      values are checked
                    if (bolUncheckedFound) {
                        arrData[0] = '0\t\tSelect All';
                    } else {
                        arrData[0] = '-1\t\tSelect All';
                    }

                    // we need to make the filter list container visible
                    uniqueFilterElement.removeAttribute('hidden');

                    valueListElement.addEventListener(
                        'initialized',
                        function () {
                            // we need to fill our new gs-table.
                            tableElement = valueListElement.children[0];

                            tableElement.internalData.records = arrData;
                            tableElement.internalData.columnNames = [
                                'active', 'count', 'value'
                            ];
                            tableElement.internalData.columnTypes = [
                                'text', 'text', 'text'
                            ];
                            tableElement.internalData.columnFilterStatuses = [
                                'on', 'on', 'on'
                            ];
                            tableElement.internalData.columnFilters = [
                                [], [], []
                            ];
                            tableElement.internalData.columnListFilters = [
                                {}, {}, {}
                            ];
                            tableElement.internalData.columnOrders = [
                                'neutral', 'neutral', 'neutral'
                            ];
                            tableElement.internalDisplay.columnWidths = [
                                27,
                                (valueListElement.clientWidth - 80),
                                49
                            ];

                            // refresh causes the record heights to be
                            //      calculated
                            tableElement.refresh();
                        }
                    );

                    // we need to create a gs-table to hold the unique list
                    //      because we need a local, updatable, wicked-fast
                    //      component to contain this potentially very long
                    //      list.
                    valueListElement.innerHTML = ml(function () {/*
    <gs-table style="width: 100%; height: 100%;"
                no-record-selector
                no-x-overscroll
                no-y-overscroll
                copy-header="always">
        <template for="data-record">
            <gs-cell>
                <label>
                    <gs-checkbox column="active" mini></gs-checkbox>
                </label>
            </gs-cell>
            <gs-cell>
                {{? row.value === 'Select All' || row.value === '(blanks)' }}
                    <span class="gs-table-text-grey">
                        {{! row.value }}
                    </span>
                {{??}}
                    <label>{{! row.value }}</label>
                {{?}}
            </gs-cell>
            <gs-cell>
                <center class="gs-table-text-grey">
                    {{! row.count }}
                </center>
            </gs-cell>
        </template>
        <template for="copy">
            <gs-cell header="Include?">{{? row.active==='-1' }}X{{?}}</gs-cell>
            <gs-cell header="Value">{{! row.value }} </gs-cell>
            <gs-cell header="Occurences">{{! row.count }}</gs-cell>
        </template>
    </gs-table>
                    */
                    });

                    tableElement.addEventListener(
                        'before_update',
                        function (event) {
                            var rec_i;
                            var rec_len;
                            var arrRecords;

                            // the only data change we make is to update the
                            //      checkbox. because of the limited nature of
                            //      the updates (0 to -1 and vice versa), we
                            //      can optimize two things: no need to encode
                            //      the update value and we're always replacing
                            //      everything before the first tab character.
                            var replaceValue = function (strRecord, strValue) {
                                return (
                                    strValue +
                                    strRecord.substring(
                                        strRecord.indexOf('\t')
                                    )
                                );
                            };

                            // when the user checks "Select All":
                            //      all checkboxes must be set to -1
                            if (
                                event.newData.columnName === 'active' &&
                                event.newData.recordNumber === 0 &&
                                event.newData.newValue === '-1'
                            ) {
                                //console.log('1***');
                                arrRecords = tableElement.internalData.records;
                                rec_i = 0;
                                rec_len = arrRecords.length;
                                while (rec_i < rec_len) {
                                    arrRecords[rec_i] = (
                                        replaceValue(arrRecords[rec_i], '-1')
                                    );
                                    rec_i += 1;
                                }

                            // when the user unchecks "Select All":
                            //      all checkboxes must be set to 0
                            } else if (
                                event.newData.columnName === 'active' &&
                                event.newData.recordNumber === 0 &&
                                event.newData.newValue === '0'
                            ) {
                                //console.log('2***');
                                arrRecords = tableElement.internalData.records;
                                rec_i = 0;
                                rec_len = arrRecords.length;
                                while (rec_i < rec_len) {
                                    arrRecords[rec_i] = (
                                        replaceValue(arrRecords[rec_i], '0')
                                    );
                                    rec_i += 1;
                                }

                            // when the user unchecks a checkbox:
                            //      the "Select All" checkbox must be set to 0
                            } else if (
                                event.newData.columnName === 'active' &&
                                event.newData.recordNumber > 0 &&
                                event.newData.newValue === '0'
                            ) {
                                //console.log('3***');
                                tableElement.internalData.records[0] = (
                                    replaceValue(
                                        tableElement.internalData.records[0],
                                        '0'
                                    )
                                );
                            }

                            //console.log(event);
                            //console.log(
                            //    'column: ' + event.newData.columnName,
                            //    'recordNumber: ' + event.newData.recordNumber,
                            //    'newValue: ' + event.newData.newValue
                            //);
                        }
                    );

                } else if (!error) {

                    i = 0;
                    while (i < 15) {
                        index = strMessage.indexOf('\n');
                        strRecord = strMessage.substring(0, index);
                        strMessage = strMessage.substring(index + 1);

                        // first load
                        if (strRecord !== '' || strMessage !== '') {
                            arrRecord = strRecord.split('\t');
                            strValue = arrRecord[1];

                            if (!jsnFilter || !jsnFilter.type) {
                                arrData.push('-1\t' + strRecord);

                            // nothing
                            } else if (
                                jsnFilter.type === 'inclusion' &&
                                jsnFilter.values.length === 0
                            ) {
                                if (
                                    jsnFilter.blanks &&
                                    strValue === '(blanks)'
                                ) {
                                    arrData.push('-1\t' + strRecord);

                                } else if (
                                    jsnFilter.blanks === false &&
                                    strValue === '(blanks)'
                                ) {
                                    arrData.push('0\t' + strRecord);
                                    bolUncheckedFound = true;

                                } else {
                                    arrData.push('0\t' + strRecord);
                                    bolUncheckedFound = true;
                                }

                            // everything
                            } else if (
                                jsnFilter.type === 'exclusion' &&
                                jsnFilter.values.length === 0
                            ) {
                                if (
                                    jsnFilter.blanks &&
                                    strValue === '(blanks)'
                                ) {
                                    arrData.push('-1\t' + strRecord);

                                } else if (
                                    jsnFilter.blanks === false &&
                                    strValue === '(blanks)'
                                ) {
                                    arrData.push('0\t' + strRecord);
                                    bolUncheckedFound = true;

                                } else {
                                    arrData.push('-1\t' + strRecord);
                                }

                            } else if (
                                jsnFilter &&
                                jsnFilter.type === 'inclusion'
                            ) {
                                if (
                                    jsnFilter.blanks &&
                                    strValue === '(blanks)'
                                ) {
                                    arrData.push('-1\t' + strRecord);

                                } else if (
                                    jsnFilter.blanks === false &&
                                    strValue === '(blanks)'
                                ) {
                                    arrData.push('0\t' + strRecord);
                                    bolUncheckedFound = true;

                                } else if (
                                    jsnFilter.values
                                        .indexOf(strValue) !== -1
                                ) {
                                    arrData.push('-1\t' + strRecord);

                                } else {
                                    arrData.push('0\t' + strRecord);
                                    bolUncheckedFound = true;
                                }

                            } else if (
                                jsnFilter &&
                                jsnFilter.type === 'exclusion'
                            ) {
                                if (
                                    jsnFilter.blanks &&
                                    strValue === '(blanks)'
                                ) {
                                    arrData.push('-1\t' + strRecord);

                                } else if (
                                    jsnFilter.blanks === false &&
                                    strValue === '(blanks)'
                                ) {
                                    arrData.push('0\t' + strRecord);
                                    bolUncheckedFound = true;

                                } else if (
                                    jsnFilter.values
                                        .indexOf(strValue) !== -1
                                ) {
                                    arrData.push('0\t' + strRecord);
                                    bolUncheckedFound = true;

                                } else {
                                    arrData.push('-1\t' + strRecord);
                                }
                            }
                        } else {
                            break;
                        }

                        i += 1;
                    }
                }
            }
        );
    }

    function internalSELECTcolumnUnique(
        //element,
        //uniqueFilterElement,
        //valueListElement,
        //strColumn
    ) {
        //
    }




    function dataSELECTcolumnUnique(
        element,
        uniqueFilterElement,
        valueListElement,
        strColumn
    ) {
        if (element.hasAttribute("src")) {
            databaseWSSELECTcolumnUnique(
                element,
                uniqueFilterElement,
                valueListElement,
                strColumn
            );
        } else {
            internalSELECTcolumnUnique(
                element,
                uniqueFilterElement,
                valueListElement,
                strColumn
            );
        }
    }
    function dataSELECT(element) {
        resolveElementAttributes(element);
        if (element.hasAttribute('src')) {
            databaseWSSELECT(element);
        } else {
            internalSELECT(element);
        }
    }
    function dataINSERT(element, strMode, jsnInsert) {
        var i;
        var len;
        var arrControls;
        var templateElement;
        var strColumn;
        var strValue;
        var arrRetained;
        var jsnInsertRecord;

        element.internalData.bolInserting = true;

        // because we allow the insert record to be templated, we need to
        //      extract the templated values and use them as defaults in the
        //      retained insert values
        if (
            element.internalTemplates.originalInsertRecord &&
            element.internalTemplates.originalInsertRecord.trim()
        ) {
            templateElement = document.createElement('template');
            templateElement.innerHTML = (
                GS.templateWithQuerystring(
                    element.internalTemplates.insertRecord.templateHTML
                )
            );
            arrControls = tblQry(templateElement.content, 'gs-cell [column]');
            arrRetained = element.internalData.insertRecordRetainedColumns;
            jsnInsertRecord = element.internalData.insertRecord;

            i = 0;
            len = arrControls.length;
            while (i < len) {
                strColumn = arrControls[i].getAttribute('column');
                strValue = arrControls[i].getAttribute('value');

                // if the column hasn't already been typed in by the user,
                //      add templated value to retained columns
                if (
                    strColumn &&
                    strValue &&
                    arrRetained.indexOf(strColumn) === -1
                ) {
                    arrRetained.push(strColumn);
                    jsnInsertRecord[strColumn] = strValue;
                }

                i += 1;
            }
        }

        if (element.hasAttribute('src')) {
            databaseWSINSERT(element, strMode, jsnInsert);
        } else {
            internalINSERT(element, strMode, jsnInsert);
        }
    }
    function dataUPDATE(element, strMode, jsnUpdate) {
        if (!element.hasAttribute('no-update')) {
            // because updates take time, we need to do this right before
            //      re-render - Nunzio on 2017-03-28
            // // we want to save the text selection of the current
            // //      control before we do the update
            // element.internalDisplay.focus.selectionRange = null;
            // if (
            //     element.internalDisplay.focus.latest &&
            //     (
            //         document.activeElement.nodeName === 'INPUT' ||
            //         document.activeElement.nodeName === 'TEXTAREA'
            //     )
            // ) {
            //     element.internalDisplay.focus.selectionRange = (
            //         GS.getInputSelection(document.activeElement)
            //     );
            // }

            if (element.hasAttribute("src")) {
                databaseWSUPDATE(element, strMode, jsnUpdate);
            } else {
                internalUPDATE(element, strMode, jsnUpdate);
            }
        }
    }
    function dataDELETE(element, jsnDeleteData) {
        if (element.hasAttribute("src")) {
            databaseWSDELETE(element, jsnDeleteData);
        } else {
            internalDELETE(element, jsnDeleteData);
        }
    }

// #############################################################################
// ####################### POST-RENDER UTILITY FUNCTIONS #######################
// #############################################################################

    function triggerRecordInsert(element) {
        dataINSERT(element, 'single-record', {
            "data": {
                "values": (element.internalData.insertRecord),
                "columns": (element.internalData.insertRecordRetainedColumns),
                "addin": getInsertAddin(element)
            },
            "insertConfirmed": true
        });

        // clear retained values
        clearInsertRetainedValues(element);
        renderLocation(element);
    }

    // sometimes you need to know what records are selected, this function
    //      returns the selected record numbers
    function getSelectedRecordIndexes(element) {
        var arrRows = element.internalSelection.rows.slice(0);

        if (arrRows[0] === 'header') {
            arrRows.shift();
        }
        if (arrRows[arrRows.length - 1] === 'insert') {
            arrRows.pop();
        }

        return arrRows;
    }

    // this function takes the cell which is the endpoint of the latest
    //      selection, focuses into it and selects all text of possible
    function focusIntoCell(
        element,
        record,
        column,
        iterationNumber
    ) {
        var jsnViewportRange;

        var cellElement;
        var focusElement;

        var strTag;
        var strValue;

        // default iterationNumber so that if this is the first run
        //      iterationNumber will contain 0
        if (iterationNumber === undefined) {
            iterationNumber = 0;
        }

        // if cell is in the rendered range:
        //      warn and stop execution
        jsnViewportRange = element.internalDisplay.currentRange;
        //console.trace(jsnViewportRange, record, column);
        if (
            // if we're not in the insert record:
            //      test if cell is within the current record and column range
            (
                !jsnViewportRange.insertRecord &&
                (
                    record < jsnViewportRange.fromRecord ||
                    record > jsnViewportRange.toRecord ||
                    column < jsnViewportRange.fromColumn ||
                    column > jsnViewportRange.toColumn
                )
            ) ||
            // if we're in the insert record (and the insert record is visible):
            //      test if cell is within the current column range
            (
                jsnViewportRange.insertRecord && (
                    column < jsnViewportRange.fromColumn ||
                    column > jsnViewportRange.toColumn
                )
            )
        ) {
            console.warn('GS-TABLE Warning: "focusIntoCell" was called to' +
                    ' focus into a cell that is not rendered. Stopping' +
                    ' execution of "focusIntoCell".');
            return;
        }

        // we need to be able to do an element query inside the target cell, so
        //      here we get the cell element
        if (record === 'insert' && jsnViewportRange.insertRecord) {
            cellElement = tblQry(
                element.elems.dataViewport,
                'gs-cell' +
                        '.table-insert' +
                        '[data-col-number="' + column + '"]'
            )[0];
        } else {
            cellElement = tblQry(
                element.elems.dataViewport,
                'gs-cell' +
                        '.table-cell' +
                        '[data-row-number="' + record + '"]' +
                        '[data-col-number="' + column + '"]'
            )[0];
        }
        //console.log(record, column);

        // if the cell was not found:
        //      warn
        //              because we checked and the cell is supposed to be in
        //                  the current viewport range
        //      re-render
        //              to put the element where it's supposed to be
        //      re-run this function
        //              because the re-render may cause the cell to go out of
        //                  range and therefore, we need to re-test
        //      stop execution
        //              because this function needs to run from the beginning
        if (!cellElement) {
            if (iterationNumber < 1) {
                // warn
                console.warn('GS-TABLE Warning: "focusIntoCell" was called to' +
                        ' focus into a cell that is not rendered. Stopping' +
                        ' execution of "focusIntoCell".');

                // re-render
                element.internalDisplay.fullRenderRequired = true;
                renderScrollDimensions(element);

                // re-run this function
                focusIntoCell(
                    element,
                    record,
                    column,
                    (iterationNumber + 1)
                );

            // infinite recursion detected, warn
            } else {
                // warn
                console.warn('GS-TABLE Warning: infinite loop detected' +
                        ' in "focusIntoCell". Stopping execution of' +
                        ' "focusIntoCell".');
            }

            // stop execution
            return;
        }

        // traverse into the cell and find first focusable element
        focusElement = tblQry(
            cellElement,
            'input, textarea, select, [tabindex]'
        )[0];
        //console.log(focusElement, cellElement);
        // if a focus element was found: focus into it
        if (focusElement) {
            focusElement.focus();

            // we want all the text selected, so if the focused element is an
            //      INPUT or TEXTAREA and it has a value: select all of the text
            strTag = focusElement.nodeName;
            strValue = (focusElement.value || '');
            if (
                (strTag === 'INPUT' || strTag === 'TEXTAREA') &&
                strValue.length > 0
            ) {
                GS.setInputSelection(focusElement, 0, strValue.length);
            }
        }
    }

    // sometimes we wan't a particular cell visible in the viewport, so this
    //      function moves the cell into view. if the cell is already in view,
    //      this function will just re-render the selection
    // strStickMode is a string that can contain one or more of these keywords:
    //          'top'
    //          'bottom'
    //          'left'
    //          'right'
    //      so, if you want the cell to be moved to the bottom-left
    //          you can send 'bottom-left' or 'bottomleft' or 'leftbottom' etc.
    //          however, you will get a warning if you send 'leftright' because
    //          those choices are contradictory
    function scrollCellIntoView(element, cellRecord, cellColumn, strStickMode) {
        var i;
        var len;

        var columnBorderWidth;
        var recordBorderHeight;
        var arrColumnWidths;
        var arrRecordHeights;

        var intCellWidth;
        var intCellHeight;
        var intCellTop;
        var intCellBottom;
        var intCellLeft;
        var intCellRight;

        var intViewportWidth;
        var intViewportHeight;
        var intViewportTop;
        var intViewportBottom;
        var intViewportLeft;
        var intViewportRight;

        var bolScrollMoved;

        var bolStickTop;
        var bolStickLeft;
        var bolStickBottom;
        var bolStickRight;

        // we're saving these to variables for quicker/easier access
        columnBorderWidth = element.internalDisplay.columnBorderWidth;
        recordBorderHeight = element.internalDisplay.recordBorderHeight;

        // we need to get column and record dimensions
        arrColumnWidths = element.internalDisplay.columnWidths;
        arrRecordHeights = element.internalDisplay.recordHeights;

        // we want shortcuts that turn strStickMode into boolean variables
        if (strStickMode) {
            bolStickTop = (strStickMode.indexOf('top') !== -1);
            bolStickLeft = (strStickMode.indexOf('left') !== -1);
            bolStickBottom = (strStickMode.indexOf('bottom') !== -1);
            bolStickRight = (strStickMode.indexOf('right') !== -1);

            // warn if two stick modes are contradictory
            if (bolStickTop && bolStickBottom) {
                console.warn('GS-TABLE Warning: Contradictory parameter sent' +
                        ' to scrollCellIntoView, you can\'t scroll a' +
                        ' cell to the top and the bottom of the viewport at' +
                        ' the same time. Stick to bottom will be cancelled.' +
                        ' Parameter Text: "' + strStickMode + '"');
                bolStickBottom = false;
            }
            if (bolStickLeft && bolStickRight) {
                console.warn('GS-TABLE Warning: Contradictory parameter sent' +
                        ' to scrollCellIntoView, you can\'t scroll a' +
                        ' cell to the left and the right of the viewport at' +
                        ' the same time. Stick to right will be cancelled.' +
                        ' Parameter Text: "' + strStickMode + '"');
                bolStickRight = false;
            }
        }

        // get location of the top, bottom, left and right of the record, we
        //      need these to calculate if we need to scroll to the cell

        // if the cell is in the header, we need to grab it's height from the
        //      internal display values
        if (cellRecord === 'header') {
            intCellHeight = element.internalDisplay.headerHeight;

        } else if (cellRecord === 'insert') {
            intCellHeight = element.internalDisplay.insertRecordHeight;

        // else, we can use the record height array
        } else {
            intCellHeight = arrRecordHeights[cellRecord];
        }

        // we want to get how far the record is from the top of the data, so
        //      if the record isn't the header,
        //          add up the record heights until the correct record
        //      else,
        //          default to 0
        intCellTop = 0;
        if (cellRecord === 'header') {
            intCellTop = 0;

        } else if (cellRecord === 'insert') {
            i = 0;
            len = arrRecordHeights.length;
            while (i < len) {
                intCellTop += arrRecordHeights[i];
                intCellTop += recordBorderHeight;
                i += 1;
            }

        } else {
            i = 0;
            len = cellRecord + 1;
            while (i < len) {
                intCellTop += arrRecordHeights[i];
                intCellTop += recordBorderHeight;
                i += 1;
            }
        }

        // if the cell is a record selector, we need to grab it's width from the
        //      internal display values
        if (cellColumn === 'selector') {
            intCellWidth = element.internalDisplay.recordSelectorWidth;

        // else, we can use the column width array
        } else {
            intCellWidth = arrColumnWidths[cellColumn];
        }

        // we want to get how far the column is from the left of the data, so
        //      if the column isn't the record selector,
        //          add up the column widths until the correct column
        //      else,
        //          default to 0
        intCellLeft = 0;
        if (cellColumn !== 'selector') {
            i = 0;
            len = cellColumn;
            while (i < len) {
                intCellLeft += arrColumnWidths[i];
                intCellLeft += columnBorderWidth;
                i += 1;
            }
        }

        // calculate the cell bottom and right
        intCellBottom = (intCellTop + intCellHeight);
        intCellRight = (intCellLeft + intCellWidth);

        // get location of the top, bottom, left and right boundery lines of the
        //      viewport, we need these to calculate if we need to scroll to the
        //      cell
        intViewportWidth = (
            element.elems.dataViewport.clientWidth - (
                element.internalScrollOffsets.left +
                element.internalScrollOffsets.right
            )
        );
        intViewportHeight = (
            element.elems.dataViewport.clientHeight - (
                element.internalScrollOffsets.top +
                element.internalScrollOffsets.bottom
            )
        );
        intViewportTop = (element.internalScroll.top);
        intViewportLeft = (element.internalScroll.left);
        intViewportBottom = (intViewportTop + intViewportHeight);
        intViewportRight = (intViewportLeft + intViewportWidth);

        // we need a variable to say if we needed to scroll the viewport
        bolScrollMoved = false;

        // if the top of the cell is not visible, scroll it into view
        if (
            intCellTop < intViewportTop ||
            bolStickTop
        ) {
            element.internalScroll.top = intCellTop;
            bolScrollMoved = true;

        // if the bottom of the cell is not visible, scroll it into view
        } else if (
            intCellBottom > intViewportBottom ||
            bolStickBottom
        ) {
            element.internalScroll.top = (
                intCellBottom - intViewportHeight
            );
            bolScrollMoved = true;
        }

        // if the left of the cell is not visible, scroll it into view
        if (
            intCellLeft < intViewportLeft ||
            bolStickLeft
        ) {
            element.internalScroll.left = intCellLeft;
            bolScrollMoved = true;

        // if the right of the cell is not visible, scroll it into view
        } else if (
            intCellRight > intViewportRight ||
            bolStickRight
        ) {
            element.internalScroll.left = (intCellRight - intViewportWidth);
            bolScrollMoved = true;
        }

        // sometimes, using stick mode will cause this function to scroll too
        //      far in order to maintain that stick. so, here we handle
        //      scrolling past the max.
        // why not handle this in the renderScrollLocation function you ask?
        //      if a function touches a shared variable, it should be self
        //          contained when it comes to validation because we don't want
        //          someone to create a new function and forget to validate the
        //          shared variables (and therefore, cause errors). so if you
        //          write a function which touches some shared variable and you
        //          notice an error, make the function clean up it's own mess.

        // prevent scrolling past the max left scroll
        if (element.internalScroll.left > element.internalScroll.maxLeft) {
            element.internalScroll.left = element.internalScroll.maxLeft;

        // prevent scrolling behind the min left scroll
        } else if (element.internalScroll.left < 0) {
            element.internalScroll.left = 0;
        }

        // prevent scrolling past the max top scroll
        if (element.internalScroll.top > element.internalScroll.maxTop) {
            element.internalScroll.top = element.internalScroll.maxTop;

        // prevent scrolling behind the min top scroll
        } else if (element.internalScroll.top < 0) {
            element.internalScroll.top = 0;
        }

        // if the scroll moved: render location
        if (bolScrollMoved) {
            // render location so the user can see the cell
            renderScrollLocation(element);

        // else, just rerender the selection
        } else {
            renderSelection(element);
        }
    }

    // sometimes the selection is moved out of view, this function will scroll
    //      the last selection range's endpoint into view and re-render the
    //      scroll location
    // if the selected cell is already in view, this function will just
    //      re-render the selection
    // strStickMode is a string that can contain one or more of these keywords:
    //          'top'
    //          'bottom'
    //          'left'
    //          'right'
    //      so, if you want the selected endpoint to stick to the bottom-left
    //          you can send 'bottom-left' or 'bottomleft' or 'leftbottom' etc.
    //          however, you will get a warning if you send 'leftright' because
    //          those choices are contradictory
    function scrollSelectionIntoView(element, strStickMode) {
        var jsnRange;
        var cellColumn;
        var cellRecord;

        // we need to the latest selection range so that we know what cell to
        //      scroll into view
        jsnRange = element.internalSelection.ranges[
            element.internalSelection.ranges.length - 1
        ];

        // if there is no selection, there is nothing to scroll to,
        //      so, warn the dev and stop this function from running
        if (!jsnRange) {
            console.warn(
                'GS-TABLE Warning: scrollSelectionIntoView was ' +
                'called when there was no selection to scroll into view.'
            );
            return;
        }

        // get the cell's column and record number so that we can pass it along
        cellRecord = (jsnRange.end.row);
        cellColumn = (jsnRange.end.column);

        // send the cell's location to the scrollCellIntoView function
        scrollCellIntoView(element, cellRecord, cellColumn, strStickMode);
    }

    // this function takes the cell which is the endpoint of the latest
    //      selection, focuses into it and selects all text of possible
    function focusIntoSelectedCell(element) {
        var jsnRange;
        var bolReWriteSelection;

        // we use the latest range a lot, let's save a shortcut
        jsnRange = element.internalSelection.ranges[
            element.internalSelection.ranges.length - 1
        ];
        //console.log(jsnRange);

        // if more than one selection: warn and move selection to endpoint of
        //      latest selection
        if (element.internalSelection.ranges.length > 1) {
            console.warn('GS-TABLE Warning: "focusIntoSelectedCell" called' +
                    ' when multiple selections were present. Now clearing all' +
                    ' selections and creating new selection at last' +
                    ' selection\'s endpoint.');
            // because this if block uses the same issue resolution as the
            //      "else if" block below, we'll just set a boolean variable and
            //      below this waterfall we'll add another if statement that
            //      handles this type of resolution
            bolReWriteSelection = true;

        // else if one selection that is more than one cell:
        //      warn and move selection to endpoint of latest selection
        } else if (
            jsnRange &&
            (
                jsnRange.start.column !== jsnRange.end.column ||
                jsnRange.start.row !== jsnRange.end.row
            )
        ) {
            console.warn('GS-TABLE Warning: "focusIntoSelectedCell" called' +
                    ' when the selection contained multiple cells. Now' +
                    ' clearing all selections and creating new selection at' +
                    ' last selection\'s endpoint.');
            // because this if block uses the same issue resolution as the
            //      "if" block above, we'll just set a boolean variable and
            //      below this waterfall we'll add another if statement that
            //      handles this type of resolution
            bolReWriteSelection = true;

        // else if no selections:
        //      warn, focus hiddenFocusControl so we can still listen to
        //      keypresses and stop execution
        } else if (!jsnRange) {
            console.warn('GS-TABLE Warning: "focusIntoSelectedCell" called' +
                    ' when there was no selection to focus into. Stopping' +
                    ' execution of "focusIntoSelectedCell".');

            focusHiddenControl(element);
            return;
        }

        // if there's more than one selection or the only selection contains
        //      multiple, the response is the same: change selection to only
        //      last cell of last selection range, so, instead of copying the
        //      code to resolve it into both cases in the waterfall, they set
        //      a boolean variable if this is what they need done.
        if (bolReWriteSelection) {
            // set the new list of selection ranges to the endpoint of the
            //      latest selection
            element.internalSelection.ranges = [
                {
                    "start": {
                        "row": jsnRange.end.row,
                        "column": jsnRange.end.column
                    },
                    "end": {
                        "row": jsnRange.end.row,
                        "column": jsnRange.end.column
                    },
                    "negator": false
                }
            ];

            // get the new selection range, this is a shortcut
            jsnRange = element.internalSelection.ranges[0];

            // re-render the selection because we've just changed it and
            //      the user needs to see the update
            renderSelection(element);
        }

        // pass the last selection's enpoint cell to focusIntoCell
        focusIntoCell(
            element,
            jsnRange.end.row,
            jsnRange.end.column
        );
    }

    // there are multiple places where we just want to delete the selected
    //      records. so, we'll make a function that handles all the error
    //      checking involved with using the selection to delete records
    function deleteSelectedRecords(element) {
        // if nothing is selected, open a dialog letting the user know that
        //      they need to choose something
        if (element.internalSelection.ranges.length === 0) {
            GS.msgbox(
                'No Records To Delete',
                '<center>' +
                        'Please choose a record to delete.' +
                        '</center>',
                ['Ok']
            );

        // else, everything is copacetic, let's initiate delete
        } else if (!element.hasAttribute('no-delete')) {
            dataDELETE(element, {
                "recordIndexes": getSelectedRecordIndexes(element),
                // we still need the user to confirm the delete
                "deleteConfirmed": false
            });
        }
    }

    // this function is used to stop the actions of the next function
    //      "dragScrollStart".
    function dragScrollEnd(element) {
        // we only want to run clearInterval if there is an interval to stop
        if (element.internalTimerIDs.scrollIntervalID !== null) {
            // stop scroll interval to stop the scrolling
            clearInterval(element.internalTimerIDs.scrollIntervalID);

            // clear scrolling ID to make it clear that that
            //      interval has been cancelled
            element.internalTimerIDs.scrollIntervalID = null;
        }

        // the rest of these commands are harmless even if the scroll was
        //      never started

        // clear scrolling direction because we've stopped
        //      scrolling
        element.internalScroll.dragScrollingDirection = null;

        // set scrolling status variable to false so that the
        //      element recognizes that scrolling is stopped
        element.internalScroll.dragScrolling = false;
    }

    // some actions use a dragging motion, this means that we need to be able
    //      to scroll the viewport if the mouse drags off of the gs-table's
    //      outer bounderies. there is more than one place where this behavior
    //      is desired. the first two that come to mind are column reordering
    //      and column resizing.
    // the way this function works is it kicks off an interval to scroll the
    //      viewport incrementally every iteration until the "dragScrollEnd"
    //      function is called
    // eventually, we'll probably add two parameters, one for vertical speed
    //      and one for horizontal speed. these parameters will need to
    //      default to a reasonable speed
    // ### NEED CODING ###
    function dragScrollStart(element, callback, strScrollDirection) {
        var jsnDirection;
        var bolScrollTop;
        var bolScrollLeft;
        var bolScrollBottom;
        var bolScrollRight;

        // set scrolling to true to prevent future mouse events
        //      from starting new scroll events
        element.internalScroll.dragScrolling = true;

        // parse direction string
        jsnDirection = directionStringBreakdown(strScrollDirection);

        // convenience variables
        bolScrollTop = jsnDirection.bolTop;
        bolScrollLeft = jsnDirection.bolLeft;
        bolScrollBottom = jsnDirection.bolBottom;
        bolScrollRight = jsnDirection.bolRight;

        // we need to be able to check of the direction string
        //      changed, so we'll save a copy to compare against
        strScrollDirection = jsnDirection.resolvedString;

        //console.log(
        //    'start',
        //    strScrollDirection,
        //    bolScrollTop,
        //    bolScrollLeft,
        //    bolScrollBottom,
        //    bolScrollRight
        //);

        // save the scroll direction internally so that other code can work
        //      appropriately for the scroll direction
        element.internalScroll.dragScrollingDirection = (
            strScrollDirection
        );

        // remember, we need to be able to scroll two directions at
        //      the same time

        // create scroll interval and save the interval ID so
        //      we can stop the interval later
        element.internalTimerIDs.scrollIntervalID = setInterval(
            function () {
                var newScrollingDirection;
                var intLeftScrollAmount;
                var intLeftScroll;
                var intLeftMax;
                var intTopScrollAmount;
                var intTopScroll;
                var intTopMax;

                // we need to know if the direction string was changed
                newScrollingDirection = (
                    element.internalScroll.dragScrollingDirection
                );

                // if the direction string was changed, recalculate
                //      the direction variables
                if (newScrollingDirection !== strScrollDirection) {
                    //console.log('SCROLL DIRECTION CHANGED');

                    jsnDirection = directionStringBreakdown(
                        newScrollingDirection
                    );

                    bolScrollTop = jsnDirection.bolTop;
                    bolScrollLeft = jsnDirection.bolLeft;
                    bolScrollBottom = jsnDirection.bolBottom;
                    bolScrollRight = jsnDirection.bolRight;

                    strScrollDirection = jsnDirection.resolvedString;

                    // save the scroll direction internally
                    element.internalScroll.dragScrollingDirection = (
                        strScrollDirection
                    );
                }

                // we want to adjust the speed of the scrolling
                //      depending on how far to the left or
                //      right the mouse is
                // ### NEED CODING ###
                if (bolScrollLeft || bolScrollRight) {
                    intLeftScrollAmount = 10;
                }
                if (bolScrollTop || bolScrollBottom) {
                    intTopScrollAmount = 10;
                }

                // we should also change to scrolling by column
                //      right now, the scrolling speed on the
                //      scrollbar is evenly paced but columns of
                //      different widths make the viewport
                //      scroll unevenly
                // ### NEED CODING ###

                // get current and max scroll for scroll
                //      direction
                if (bolScrollLeft || bolScrollRight) {
                    intLeftScroll = (element.internalScroll.left);
                    intLeftMax = (element.internalScroll.maxLeft);
                }
                if (bolScrollTop || bolScrollBottom) {
                    intTopScroll = (element.internalScroll.top);
                    intTopMax = (element.internalScroll.maxTop);
                }

                //console.log(
                //    strScrollDirection,
                //    bolScrollTop,
                //    bolScrollLeft,
                //    bolScrollBottom,
                //    bolScrollRight
                //);

                // if we are at the max of all directions that we
                //      are scrolling, stop scrolling interval
                // overscroll is handled in the else
                // underscroll is handled in the else
                if (
                    (
                        !bolScrollTop ||
                        intLeftScroll === 0
                    ) &&
                    (
                        !bolScrollLeft ||
                        intLeftScroll === 0
                    ) &&
                    (
                        !bolScrollBottom ||
                        intLeftScroll === intTopMax
                    ) &&
                    (
                        !bolScrollRight ||
                        intLeftScroll === intLeftMax
                    )
                ) {
                    //console.log('SCROLL STOPPED 1');
                    dragScrollEnd(element);

                } else if (
                    !bolScrollTop &&
                    !bolScrollLeft &&
                    !bolScrollBottom &&
                    !bolScrollRight
                ) {
                    //console.log('SCROLL STOPPED 2');
                    dragScrollEnd(element);

                // else, advance scroll in every direction we were
                //      told to
                } else {
                    if (bolScrollTop || bolScrollBottom) {
                        if (bolScrollTop) {
                            intTopScroll -= intTopScrollAmount;

                        } else if (bolScrollBottom) {
                            intTopScroll += intTopScrollAmount;
                        }

                        // prevent over/under scrolling

                        // prevent scrolling past the max
                        if (intTopScroll > intTopMax) {
                            intTopScroll = intTopMax;
                        }

                        // prevent scrolling behind the min
                        if (intTopScroll < 0) {
                            intTopScroll = 0;
                        }

                        // apply new scroll to correct direction
                        element.internalScroll.top = intTopScroll;
                    }

                    if (bolScrollLeft || bolScrollRight) {
                        if (bolScrollLeft) {
                            intLeftScroll -= intLeftScrollAmount;

                        } else if (bolScrollRight) {
                            intLeftScroll += intLeftScrollAmount;
                        }

                        // prevent scrolling past the max
                        if (intLeftScroll > intLeftMax) {
                            intLeftScroll = intLeftMax;
                        }

                        // prevent scrolling behind the min
                        if (intLeftScroll < 0) {
                            intLeftScroll = 0;
                        }

                        // apply new scroll to correct direction
                        element.internalScroll.left = intLeftScroll;
                    }

                    //console.log(
                    //    element.internalScroll.left,
                    //    element.internalScroll.top
                    //);

                    // render scroll
                    renderScrollLocation(element);

                    // the drag actions that use this function will sometimes
                    //      need to refresh something depending on the new
                    //      scroll position. the callback is for that purpose
                    if (callback) {
                        callback();
                    }
                }
            },
            50 // twentieth of a second refresh rate
        );
    }

// #############################################################################
// ############################## PASTE FUNCTIONS ##############################
// #############################################################################
    // when you paste for an insert, only some columns might be selected, this
    //      function takes the normalized paste data and trims out anything that
    //      would have been applied to an unseleted cell. after that, this
    //      function turns control over to the internal insert function
    function insertPasteString(element, arrPaste, intMaxPasteColumn) {
        var templateElement;
        var search_div;
        var enc_i;
        var enc_len;
        var enc_elems;
        var arr_encrypted_columns;
        var bol_encrypt = false;
        var encrypted_vars;
        var strSelection;
        var strOldRecord;
        var strNewRecord;
        var strCell;
        var strChar;

        var intStart;
        var intEnd;
        //var intMaxPasteColumn;
        var intMinPasteColumn;
        var intPastedColumn;
        var intOffsetColumn;
        var intColumn;

        var arrColumnElements;
        var arrColumns;

        var i;
        var len;
        var rec_i;
        var rec_len;

        // we need to know what columns of the insert record are selected
        strSelection = element.internalSelection.resolvedSelection[
            element.internalSelection.resolvedSelection.length - 1
        ];

        // if there is a record selector, remove that char from the selection
        //      string
        if (element.internalDisplay.recordSelectorVisible) {
            strSelection = strSelection.substring(1);
        }

        // the paste starts at the first selected cell
        intStart = strSelection.indexOf('F');
        intEnd = strSelection.lastIndexOf('F');

        // we want to paste the smaller of the selection or the available data,
        //      this is because we will not paste what we do not have and
        //      will not affect data that is not selected
        if ((intEnd - intStart) < intMaxPasteColumn) {
            intMaxPasteColumn = (intEnd - intStart);
        }

        intEnd = intStart + intMaxPasteColumn;

        // sometimes, an entire record is copied and pasted (including the
        //      record selector), we need to prevent this from being an
        //      issue
        if (element.internalSelection.columns[0] === 'selector') {
            intMinPasteColumn = 1;
        } else {
            intMinPasteColumn = 0;
        }

        //console.log('   intEnd:', intEnd);
        //console.log(' intStart:', intStart);
        //console.log('intMinCol:', intMinPasteColumn);
        //console.log('intMaxCol:', intMaxPasteColumn);

        // use the selected column list to filter the data of the paste
        i = 0;
        len = arrPaste.length;
        search_div = document.createElement('div');
        search_div.innerHTML = templateExtractVisibleCellRange(
            element,
            element.internalTemplates.insertRecord.templateHTML,
            intStart,
            (intEnd + 1)
            // the plus one is because the template extract function
            //      expects 0/1 to get the first column, not 0/0
        );
        if (search_div.innerHTML.indexOf('encrypted=') !== -1) {
            if (tblQry(search_div, 'gs-cell[encrypted]')) {
                enc_elems = tblQry(search_div, 'gs-cell[encrypted]');
                enc_i = 0;
                enc_len = enc_elems.length;
                arr_encrypted_columns = [];
                encrypted_vars = [];
                while (enc_i < enc_len) {
                    arr_encrypted_columns.push(
                        enc_elems[enc_i].getAttribute('data-col-number')
                    );
                    encrypted_vars.push(
                        enc_elems[enc_i].getAttribute('encrypted')
                    );
                    if (!window[encrypted_vars[enc_i]]) {
                        console.error(
                            'the encrypted password variable is not filled, ' +
                            'if a user pastes it will paste UNENCRYPTED ' +
                            'DATA. Please ensure all your variables are full ' +
                            'before allowing users to paste'
                        );
                        return;
                    }
                    enc_i += 1;
                }
                bol_encrypt = true;
            }
        }
        while (i < len) {
            strOldRecord = arrPaste[i];

            // null out any cells that would apply to an unselected column
            // remove any cells that go further than the last selected column
            intColumn = 0;
            intPastedColumn = 0;
            strNewRecord = '';
            strCell = '';
            rec_i = 0;
            rec_len = strOldRecord.length;
            while (rec_i < rec_len) {
                strChar = strOldRecord[rec_i];

                // if the current character is not a tab: add it to the current
                //      cell variable
                if (strChar !== '\t') {
                    strCell += strChar;
                }

                // if the current character is a tab or we are at the end of the
                //      record: handle current cell
                if (
                    strChar === '\t' ||
                    rec_i === (rec_len - 1)
                ) {
                    if (intColumn >= intMinPasteColumn) {
                        // if this isn't the first column: add a tab character
                        //      to separate the cells
                        if (intPastedColumn > 0) {
                            strNewRecord += '\t';
                        }

                        // if this column is selected: add cell to paste record
                        if (strSelection[intPastedColumn + intStart] === 'F') {
                            // strNewRecord += strCell;
                            intOffsetColumn = (intPastedColumn + intStart);

                            if (bol_encrypt) {
                                if (
                                    arr_encrypted_columns.indexOf(
                                        intOffsetColumn.toString()
                                    ) !== -1
                                ) {
                                    strNewRecord += CryptoJS.AES.encrypt(
                                        strCell,
                                        window[
                                            encrypted_vars[
                                                arr_encrypted_columns.indexOf(
                                                    intOffsetColumn.toString()
                                                )
                                            ]
                                        ]
                                    );
                                } else {
                                    strNewRecord += strCell;
                                }
                            } else {
                                strNewRecord += strCell;
                            }

                        // else, replace the current cell with NULL
                        } else {
                            strNewRecord += '\\N';
                        }

                        intPastedColumn += 1;

                        if (intPastedColumn > intMaxPasteColumn) {
                            break;
                        }
                    }

                    // clear cell variable and advance column number
                    strCell = '';
                    intColumn += 1;
                }

                // if this column is past the last column we can paste to:
                //      stop adding cells from this record and move to the
                //      next record
                if (
                    intColumn > (
                        (intEnd - intStart) + intMinPasteColumn
                    )
                ) {
                    break;
                }
                rec_i += 1;
            }

            // update the paste data with the new record
            arrPaste[i] = strNewRecord;
            i += 1;
        }

        //console.log(arrPaste);

        // we need to say what columns we are inserting to, so here we take the
        //      start and end column numbers and turn that into an array of
        //      column names for the insert

        templateElement = document.createElement('template');
        templateElement.innerHTML = templateExtractVisibleCellRange(
            element,
            element.internalTemplates.insertRecord.templateHTML,
            intStart,
            (intEnd + 1)
            // the plus one is because the template extract function
            //      expects 0/1 to get the first column, not 0/0
        );
        arrColumnElements = tblQry(
            templateElement.content,
            'gs-cell [column]'
        );
        arrColumns = [];
        i = 0;
        len = arrColumnElements.length;
        while (i < len) {
            arrColumns.push(arrColumnElements[i].getAttribute('column'));
            i += 1;
        }

        //console.log(
        //    intMinPasteColumn,
        //    intMaxPasteColumn,
        //    intStart,
        //    intEnd,
        //    //templateElement,
        //    //arrColumnElements,
        //    arrColumns
        //);

        // call the internal insert function, to be routed to the correct
        //      insert protocol
        dataINSERT(element, 'multi-record', {
            "data": {
                "values": arrPaste,
                "columns": arrColumns,
                "addin": getInsertAddin(element)
            },
            "insertConfirmed": false
        });
    }

    // when you paste for an update, only some cells might be selected, this
    //      function takes the normalized paste data and trims out anything that
    //      would have been applied to an unseleted cell. after that, this
    //      function turns control over to the internal update function
    function updatePasteString(element, arrPaste, intMaxPasteColumn) {
        var arrRecords;
        var arrColumns;
        var intStartColumn;
        var intEndColumn;
        var arrSelection;
        var strSelection;
        var arrUpdateIndexes = [];
        var arrTranslated = [];

        var paste_i;
        var update_i;
        var i;
        var len;
        var rec_i;
        var rec_len;

        var strOldRecord;
        var strNewRecord;
        var intColumn;
        var intMinPasteColumn;
        var strCell;
        var strChar;
        var intPasteColumn;
        var intColumnOffset;

        var templateElement;
        var arrInsertCellElements;
        var arrUpdateCellElements;
        var arrCellElements;
        var arrColumnElements;
        var arrColumnNames;

        var arrSelectedStates = ['B', 'D', 'F', 'H', 'J', 'L'];

        // save selection cache so that we can check if a particular cell is
        //      selected
        // take a copy of the resolved selction
        //      (fixes workflowproducts/postage#395)
        arrSelection = element.internalSelection.resolvedSelection.slice(0);

        // you can't paste into the header
        if (element.internalDisplay.headerVisible) {
            arrSelection.shift();
        }

        // you can't paste into the insert from here
        if (element.internalDisplay.insertRecordVisible) {
            arrSelection.pop();
        }

        // save the indexes of the records that we're going to paste over
        arrRecords = element.internalSelection.rows;

        // you can't paste into the header
        if (arrRecords[0] === 'header') {
            arrRecords.shift();
        }

        // you can't paste into the insert from here
        if (arrRecords[arrRecords.length - 1] === 'insert') {
            arrRecords.pop();
        }

        // save the indexes of the columns that we're going to paste over
        arrColumns = element.internalSelection.columns;

        // you can't paste into the record selector
        if (arrColumns[0] === 'selector') {
            arrColumns.shift();
        }

        // get the first selected row and column number
        intStartColumn = arrColumns[0];

        // get the last selected row and column number
        intEndColumn = arrColumns[arrColumns.length - 1];

        // we want to paste the smaller of the selection or the available data,
        //      this is because we will not paste what we do not have and
        //      will not affect data that is not selected
        if ((intEndColumn - intStartColumn) < intMaxPasteColumn) {
            intMaxPasteColumn = (intEndColumn - intStartColumn);
        }

        intEndColumn = (intStartColumn + intMaxPasteColumn);

        //console.log(intStartColumn, intEndColumn, intMaxPasteColumn);

        // we need to know the offset in the row selection string caused by
        //      the record selectors
        intColumnOffset = 0;
        if (element.internalDisplay.recordSelectorVisible) {
            intColumnOffset = 1;
        }

        // we need to know what columns we are updating, so here we take the
        //      start and end column numbers and turn that into an array of
        //      column names for the update
        templateElement = document.createElement('template');

        templateElement.innerHTML = (
            element.internalTemplates.insertRecord.templateHTML
        );
        arrInsertCellElements = tblQry(
            templateElement.content,
            'gs-cell'
        );

        templateElement.innerHTML = (
            element.internalTemplates.record.templateHTML
        );
        arrUpdateCellElements = tblQry(
            templateElement.content,
            'gs-cell'
        );

        if (arrInsertCellElements.length > 0) {
            arrCellElements = arrInsertCellElements;
        } else {
            arrCellElements = arrUpdateCellElements;
        }

        // if we have an insert record, get the column names from there
        arrColumnNames = [];
        i = 0;
        len = arrColumns.length;
        while (i < len) {
            //console.log('test 1 1', arrColumns[i]);
            //console.log('test 1 2', arrCellElements[arrColumns[i]]);

            arrColumnElements = tblQry(
                arrCellElements[arrColumns[i]],
                '[column]'
            );

            //console.log('test 1 3', arrColumnElements);

            if (arrColumnElements && arrColumnElements.length > 0) {
                arrColumnNames.push(
                    arrColumnElements[0].getAttribute('column')
                );

                //console.log(arrColumnNames.length, intMaxPasteColumn);
                if (arrColumnNames.length === (intMaxPasteColumn + 1)) {
                    break;
                }
            } else {
                arrColumns.splice(i, 1);
                i -= 1;
                len -= 1;
            }
            i += 1;
        }

        // loop through rows starting from start row
        paste_i = 0; // paste record index
        update_i = 0; // update record index
        len = arrPaste.length;

        // sometimes the paste is longer than the list of selected records, so
        //      if that's the case than we want to use the selection length
        if (len > arrRecords.length) {
            len = arrRecords.length;
        }

        // sometimes a header is selected, if it is, skip the first record
        if (element.internalSelection.rows[0] === 'header') {
            paste_i += 1;
        }

        // sometimes, an entire record is copied and pasted (including the
        //      record selector), we need to prevent this from being an
        //      issue
        if (element.internalSelection.columns[0] === 'selector') {
            intMinPasteColumn = 1;
        } else {
            intMinPasteColumn = 0;
        }

        while (update_i < len) {
            strOldRecord = arrPaste[paste_i];

            // we want the selection string for the current record
            strSelection = arrSelection[arrRecords[update_i]];

            // null out any cells that would apply to an unselected column
            // remove any cells that go further than the last selected column
            intColumn = 0;
            strNewRecord = '';
            strCell = '';
            intPasteColumn = 0;
            rec_i = 0;
            rec_len = strOldRecord.length;
            while (rec_i < rec_len) {
                strChar = strOldRecord[rec_i];

                // if the current character is not a tab: add it to the current
                //      cell variable
                if (strChar !== '\t') {
                    strCell += strChar;
                }

                // if the current character is a tab or we are at the end of the
                //      record: handle current cell
                if (
                    strChar === '\t' ||
                    rec_i === (rec_len - 1)
                ) {
                    if (intColumn >= intMinPasteColumn) {
                        // if this isn't the first column: add a tab character
                        //      to separate the cells
                        if (intPasteColumn > 0) {
                            strNewRecord += '\t';
                        }

                        // if this column is selected: add cell to paste record
                        if (
                            arrSelectedStates.indexOf(
                                strSelection[
                                    (
                                        arrColumns[intPasteColumn] +
                                        intColumnOffset
                                    )
                                ]
                            ) > -1
                        ) {
                            strNewRecord += strCell;

                        // else, replace the current cell with it's current
                        //      value
                        } else {
                            strNewRecord += getCell(
                                element,
                                arrColumnNames[intPasteColumn],
                                arrRecords[update_i],
                                false // not decoded
                            );
                        }
                        intPasteColumn += 1;

                        if (intPasteColumn > intMaxPasteColumn) {
                            break;
                        }
                    }

                    // clear cell variable and advance column number
                    strCell = '';
                    intColumn += 1;
                }

                // if this column is past the last column we can paste to:
                //      stop adding cells from this record and move to the
                //      next record
                if (
                    intColumn > (
                        (intEndColumn - intStartColumn) + intMinPasteColumn
                    )
                ) {
                    break;
                }
                rec_i += 1;
            }

            // add the new record to the translated record list
            arrUpdateIndexes.push(arrRecords[update_i]);
            arrTranslated.push(strNewRecord);
            paste_i += 1;
            update_i += 1;
        }

        //console.log('test1', arrColumns.length, arrColumns);
        //console.log('test2', arrColumnNames.length, arrColumnNames);
        //console.log('test3', arrUpdateIndexes.length, arrUpdateIndexes);
        //console.log('test4', arrTranslated.length, arrTranslated);

        // lets make the update
        dataUPDATE(element, 'cell-range', {
            "data": {
                "columns": arrColumnNames,
                "records": arrUpdateIndexes,
                "values": arrTranslated
            },
            "updateConfirmed": false
        });
    }

    // the goal of this function is to normalize the data from a paste. once
    //      that's done, this function will route the paste data to either the
    //      insert or update paste functions
    function usePasteString(element, strUnnormalizedPasteString) {
        var elementMaker = document.createElement('template');
        var tableElement;
        var tbodyElement;
        var arrRecord;
        var arrUpdateRecord;
        var arrInsertRecord;
        var arrCell;
        var strRecord;
        var strCell;
        var intMaxUpdateRecord;
        var arrSelectedRows;
        var arrColSpanCells;

        var rec_i;
        var rec_len;
        var col_i;
        var col_len;
        var i;
        var len;
        var insert_i;
        var insert_len;

        //console.log('Paste String:', strUnnormalizedPasteString);

        // because pasting a large amount of data takes time, add a
        //      loader to let the user know we've started, just in case
        addLoader(element, 'paste-parse', 'Parsing Pasted Data...');

        // sometimes there's a whole page that contains the table HTML inside it
        if (strUnnormalizedPasteString.substring(0, 6) === '<HTML>') {
            var extractorDiv = document.createElement('div');
            extractorDiv.innerHTML = strUnnormalizedPasteString;
            strUnnormalizedPasteString = (
                tblQry(extractorDiv, 'table')[0].outerHTML
            );
        }

        // if no HTML or no valid HTML: build HTML using plain text
        if (
            strUnnormalizedPasteString.indexOf('<' + 'table') === -1 &&
            strUnnormalizedPasteString.indexOf('<' + 'tr') === -1
        ) {
            strUnnormalizedPasteString = delimitedStringToHTML(
                element,
                strUnnormalizedPasteString,
                '\t',
                '\n',
                '"',
                GS.decodeFromTabDelimited
            );
        }

        // second, get record elements
        elementMaker.innerHTML = strUnnormalizedPasteString;

        // we don't want any header or footer records to be pasted
        tableElement = tblQry(elementMaker.content, 'table')[0];
        tbodyElement = tblQryKids(tableElement, 'tbody')[0];

        // In MS Excel, if a cell bleeds over into another cell and the next
        //      cell is empty, Excel will ignore the empty column and put a
        //      colspan on the cell that bleeds over.
        // So, it'll turn the record below
        //      COL1 | COL2 | COL3 | COL4
        //      test | test | test | test
        //      test | testtesttesttest | EMPTY | test  <- this record
        //      test | test | test | test
        //
        // into this
        //      (
        //          just the table portion of the paste string,
        //          indented and cleaned for clarity
        //      ):
        //        <table>
        //            <tr>
        //                <td>COL1</td>
        //                <td>COL2</td>
        //                <td>COL3</td>
        //                <td>COL4</td>
        //            </tr>
        //            <tr>
        //                <td>test</td>
        //                <td>test</td>
        //                <td>test</td>
        //                <td>test</td>
        //            </tr>
        //            <tr>
        //                <td>test</td>
        //                <td colspan="2">testtesttesttest</td>
        //                // NO EMPTY FIELD HERE!! We add an empty field here
        //                <td>test</td>
        //            </tr>
        //            <tr>
        //                <td>test</td>
        //                <td>test</td>
        //                <td>test</td>
        //                <td>test</td>
        //            </tr>
        //        </table>
        //
        // To solve this, we insert one cell for every cell that it covers
        arrColSpanCells = tblQry(tbodyElement, 'td[colspan]');

        if (arrColSpanCells.length > 0) {
            // loop through all cells that have a colspan
            i = 0;
            len = arrColSpanCells.length;
            while (i < len) {
                // for however many the colspan is (minus one), loop
                insert_i = 0;
                insert_len = arrColSpanCells[i].getAttribute('colspan') - 1;
                while (insert_i < insert_len) {
                    // insert cell after colspan cell
                    GS.insertElementAfter(
                        document.createElement('td'),
                        arrColSpanCells[i]
                    );

                    // remove the colspan because it's no longer accurate
                    arrColSpanCells[i].removeAttribute('colspan');

                    insert_i += 1;
                }

                i += 1;
            }
        }

        // if there's a TBODY, get records from within there
        if (tbodyElement) {
            arrRecord = tblQryKids(tbodyElement, 'tr');

        // else (no TBODY), get immediate children of table
        } else {
            arrRecord = tblQryKids(tableElement, 'tr');
        }

        // third, create an array of text records from the HTML, make
        //      sure to split the records up into insert and update records

        // we need to know how many of the records are for the update and
        //      how many are for the insert. to do this, we'll take the
        //      selection rows length, subtract one for 'insert' and/or
        //      'header' if their present.
        arrSelectedRows = element.internalSelection.rows;
        intMaxUpdateRecord = arrSelectedRows.length - 1;

        if (arrSelectedRows[intMaxUpdateRecord] === 'insert') {
            intMaxUpdateRecord -= 1;
        }
        if (arrSelectedRows[0] === 'header') {
            intMaxUpdateRecord -= 1;
        }

        //console.log(intMaxUpdateRecord);

        // begin the loop!
        arrUpdateRecord = [];
        arrInsertRecord = [];
        rec_i = 0;
        rec_len = arrRecord.length;
        col_len = arrRecord[0].children.length;
        while (rec_i < rec_len) {
            strRecord = '';
            arrCell = xtag.toArray(arrRecord[rec_i].children);
            col_i = 0;
            while (col_i < col_len) {
                strRecord += (
                    strRecord
                        ? '\t'
                        : ''
                );

                if (arrCell[col_i]) {
                    strCell = getPlainText(arrCell[col_i], true);

                    if (strCell && strCell.trim()) {
                        strRecord += GS.encodeForTabDelimited(strCell);
                    } else {
                        strRecord += '\\N';
                    }
                } else {
                    strRecord += '\\N';
                }

                col_i += 1;
            }

            // if we've normalized this record for update,
            //      stick it in the update array.
            if (rec_i <= intMaxUpdateRecord) {
                arrUpdateRecord.push(strRecord);

            // else, we've normalized this record for insert,
            //      stick it in the insert array.
            } else {
                arrInsertRecord.push(strRecord);
            }

            rec_i += 1;
        }

        //console.log('arrUpdateRecord:', arrUpdateRecord);
        //console.log('arrInsertRecord:', arrInsertRecord);

        // fourth, initiate insert and/or paste
        if (
            arrInsertRecord.length > 0 &&
            element.internalDisplay.insertRecordVisible &&
            arrSelectedRows[arrSelectedRows.length - 1] === 'insert'
        ) {
            insertPasteString(element, arrInsertRecord, (col_len - 1));
        }
        if (arrUpdateRecord.length > 0) {
            updatePasteString(element, arrUpdateRecord, (col_len - 1));
        }

        // remove pasting loader
        removeLoader(element, 'paste-parse', 'Paste Data Parsed');
    }

    // the goal of this function is to extract the data in a paste event. once
    //      that's done, this function will route the paste data to the
    //      function in charge of using a paste string.
    function usePasteEvent(element, event) {
        var clipboardData;
        var pastePlain;
        var pasteHTML;

        // we don't want to do any pasting if there is nothing selected
        if (
            element.internalSelection.columns.length === 0 &&
            element.internalSelection.rows.length === 0
        ) {
            addLoader(
                element,
                'paste-fail',
                'Can\'t paste, nothing selected...'
            );
            removeLoader(
                element,
                'paste-fail',
                'Can\'t paste, nothing selected...'
            );

        // else, there is something selected, initiate paste
        } else {
            // because pasting a large amount of data takes time, add a
            //      loader to let the user know we've started, just in case
            addLoader(element, 'paste-extract', 'Extracting Pasted Data...');

            // to handle IE differences without having to write a lot of code to
            //      handle IE vs non-IE, we'll have one variable for the
            //      clipboardData and it will either be from the event object
            //      (non-IE) or it will come from the window (IE), this will cut
            //      down on browser specific code
            clipboardData = (event.clipboardData || window.clipboardData);

            // first, extract the unnormalized text

            // this is the main difference for IE vs non-IE, in IE we only get
            //      the text MIME type (we don't even try for HTML), everywhere
            //      else we try to get HTML
            if (window.clipboardData) {
                pastePlain = clipboardData.getData('Text');
            } else {
                pasteHTML = clipboardData.getData('text/html');
                pastePlain = clipboardData.getData('Text');
            }

            // remove pasting loader
            removeLoader(element, 'paste-extract', 'Paste Data Extracted');

            //console.log('##########################################');
            //console.log('################## HTML ##################');
            //console.log('##########################################');
            //console.log('|' + pasteHTML + '|');

            //console.log('##########################################');
            //console.log('############### PLAIN TEXT ###############');
            //console.log('##########################################');
            //console.log('|' + pastePlain + '|');
            //console.log(pasteHTML || pastePlain);
            // send paste string to be utilized
            usePasteString(
                element,
                (pasteHTML || pastePlain)
            );
        }
    }

// #############################################################################
// ############################# BUTTON FUNCTIONS ##############################
// #############################################################################

    function openInsertDialog(element) {
        var strTemplate;
        var templateElement;
        var beforeEvent;

        // get the template string from internal storage
        strTemplate = element.internalTemplates.insertDialog;

        // we want a template element because that's what we're going to send to
        //      the dialog function
        templateElement = document.createElement("template");

        if (strTemplate.indexOf('<gs-page') > -1) {
            // fill template element
            templateElement.innerHTML = strTemplate;
        } else {
            // fill template element
            templateElement.innerHTML = ml(function () {/*
                <gs-page gs-dynamic>
                    <gs-header>
                        <center><h3>Create</h3></center>
                    </gs-header>
                    <gs-body padded>
                        {{HTML}}
                    </gs-body>
                    <gs-footer>
                        <gs-grid gutter>
                            <gs-block>
                                <gs-button dialogclose>Cancel</gs-button>
                            </gs-block>
                            <gs-block>
                                <gs-button dialogclose
                                           listen-for-return
                                           bg-primary>Create</gs-button>
                            </gs-block>
                        </gs-grid>
                    </gs-footer>
                </gs-page>
            */
            }).replace("{{HTML}}", strTemplate);
        }

        // send out a before insert dialog open event, so that the developer
        //      can cancel it
        beforeEvent = GS.triggerEvent(element, "before_insert_dialog_open");

        // if the user prevents the default on the "before_insert_dialog_open"
        //      event, prevent the execution of the insert dialog
        if (beforeEvent.defaultPrevented) {
            return;
        }

        // open the dialog
        GS.openDialog(
            templateElement,
            // after open callback
            function () {
                var dialog = this;
                var arrElements;
                var element_i;
                var element_len;
                var strColumn;
                var strValue;

                // if the user has started typing into the insert record and
                //      then clicked the insert button, show the values from
                //      the insert record
                arrElements = tblQry(dialog, '[column]');
                element_i = 0;
                element_len = arrElements.length;
                while (element_i < element_len) {
                    strColumn = arrElements[element_i].getAttribute('column');
                    strValue = element.internalData.insertRecord[strColumn];

                    // if a value was retained for the current column
                    if (strValue) {
                        // fill control with retained value
                        arrElements[element_i].value = strValue;
                    }
                    element_i += 1;
                }

                // trigger after insert dialog open so the dev can run code
                GS.triggerEvent(element, "after_insert_dialog_open", {
                    "relatedTarget": dialog
                });
            },
            // before close callback
            // ignore is the placeholder for "event", jslint ignores unused
            //      parameters that are named "ignore"
            function (ignore, strAnswer) {
                var dialog = this;
                var arrElements;
                var element_i;
                var element_len;
                var strColumn;
                var strValue;

                // we want the data that the user has put into the insert
                //      dialog to be put into internal storage, gather the
                //      values
                arrElements = tblQry(dialog, '[column]');
                element_i = 0;
                element_len = arrElements.length;
                while (element_i < element_len) {
                    strColumn = arrElements[element_i].getAttribute('column');
                    strValue = arrElements[element_i].value;

                    // we only want to retain the value if there's a value to
                    //      retain
                    if (strValue) {
                        // retain the value in the internalData
                        element.internalData.insertRecord[strColumn] = strValue;

                        // some insert fields may be changed twice before an
                        //      insert, so only add the column name to the
                        //      changed columns list if that column name isn't
                        //      already in the list
                        if (
                            element
                                .internalData
                                .insertRecordRetainedColumns
                                .indexOf(strColumn) === -1
                        ) {
                            element
                                .internalData
                                .insertRecordRetainedColumns
                                .push(strColumn);
                        }

                    // if the user clears out a field that was previously
                    //      retained, we want to remove that value from the
                    //      retained list
                    } else if (
                        !strValue &&
                        element
                            .internalData
                            .insertRecordRetainedColumns
                            .indexOf(strColumn) > -1
                    ) {
                        element
                            .internalData
                            .insertRecord[strColumn] = undefined;
                        element
                            .internalData
                            .insertRecordRetainedColumns
                            .splice(
                                element
                                    .internalData
                                    .insertRecordRetainedColumns
                                    .indexOf(strColumn)
                            );
                    }
                    element_i += 1;
                }

                // if the answer is to insert the record: do so
                if (strAnswer !== 'Cancel' || strAnswer === 'Create') {
                    dataINSERT(element, "single-record", {
                        "data": {
                            "values": (
                                element
                                    .internalData
                                    .insertRecord
                            ),
                            "columns": (
                                element
                                    .internalData
                                    .insertRecordRetainedColumns
                            ),
                            "addin": getInsertAddin(element)
                        },
                        "insertConfirmed": true
                    });

                    // the insert attempt has been made, so we clear out the
                    //      retained values
                    element.internalData.insertRecord = {};
                    element.internalData.insertRecordRetainedColumns = [];

                // else, re-render so that the internal storage is used to fill
                //      the insert controls
                } else {
                    // added by Nunzio on 2022-01-14
                    // if there is no insert record, clear out the internal
                    // storage, otherwise you get errors about unsaved changes
                    if (!element.internalTemplates.insertRecord) {
                        element.internalData.insertRecord = {};
                        element.internalData.insertRecordRetainedColumns = [];
                    }
                    element.internalDisplay.fullRenderRequired = true;
                    renderLocation(element);
                }
            }
        );
    }

    // after a column is hidden, there is no way to unhide it. we need a
    //      function that will open a dialog to give the user the option of
    //      showing or hiding any column
    function openColumnHideDialog(element, targetElement, callback) {
        var templateElement;
        var afterOpenCallback;
        var beforeCloseCallback;

        templateElement = document.createElement('template');
        templateElement.setAttribute('data-max-width', '15em');
        templateElement.setAttribute('no-background', '');
        templateElement.innerHTML = ml(function () {/*
            <gs-page gs-dynamic class="gs-table-contextmenu">
                <gs-header><h4>Unhide Columns</h4></gs-header>
                <gs-body class="gs-table-column-checklist-container" padded>
                </gs-body>
                <gs-footer>
                    <gs-grid gutter>
                        <gs-block>
                            <gs-button dialogclose>Cancel</gs-button>
                        </gs-block>
                        <gs-block>
                            <gs-button dialogclose bg-primary>Apply</gs-button>
                        </gs-block>
                    </gs-grid>
                </gs-footer>
            </gs-page>
        */
        });

        // because we open the dialog different ways depending on parameters,
        //      we'll put the callbacks in variables for convenience
        afterOpenCallback = function () {
            var dialog = this;
            var containerElement;
            var i;
            var len;
            var strHTML;
            var bolVisible;
            var arrColumnNames;
            var arrColumnWidths;

            // we want to know the column widths so that we can pre-check any
            //      hidden columns
            arrColumnWidths = element.internalDisplay.columnWidths;

            // we want to show the user column names that make sense.
            arrColumnNames = element.internalDisplay.columnPlainTextNames;

            // we want to fill the gs-body with the column list so that the
            //      user can check and uncheck columns
            containerElement = tblQry(
                dialog,
                '.gs-table-column-checklist-container'
            )[0];

            strHTML = '';
            i = 0;
            len = arrColumnWidths.length;
            while (i < len) {
                bolVisible = (arrColumnWidths[i] > 0);
                strHTML += (
                    '<gs-checkbox ' +
                    '        data-col-number="' + i + '"' +
                    '        value="' + bolVisible.toString() + '">&nbsp;' +
                        encodeHTML(arrColumnNames[i]) +
                    '</gs-checkbox>'
                );

                i += 1;
            }

            containerElement.innerHTML = strHTML;

            // we want the top gs-page to have corner rounding
            dialog.classList.add('gs-table-contextmenu');
        };

        // event parameter ignored
        beforeCloseCallback = function (ignore, strAnswer) {
            var dialog = this;
            var arrCheckbox;
            var arrColumnWidths;
            var arrDefaultColumnWidths;
            var i;
            var len;
            var colIndex;

            if (strAnswer !== 'Cancel') {
                // we want a shortcut to the column widths
                arrColumnWidths = (
                    element.internalDisplay.columnWidths
                );

                // we want a shortcut to the default column widths
                arrDefaultColumnWidths = (
                    element.internalDisplay.defaultColumnWidths
                );

                // loop through each checkbox and show or hide the columns
                //      depending on the checkbox value
                arrCheckbox = tblQry(dialog, 'gs-checkbox');
                i = 0;
                len = arrCheckbox.length;
                while (i < len) {
                    colIndex = parseInt(
                        arrCheckbox[i].getAttribute('data-col-number'),
                        10
                    );

                    if (
                        // if column is not hidden
                        arrColumnWidths[colIndex] > 0 &&
                        // and checkbox says to hide the column
                        arrCheckbox[i].value === 'false'
                    ) {
                        // hide the column
                        arrColumnWidths[colIndex] = 0;

                    } else if (
                        // if column is hidden
                        arrColumnWidths[colIndex] === 0 &&
                        // and checkbox says to show the column
                        arrCheckbox[i].value === 'true'
                    ) {
                        // restore the column to it's default width
                        arrColumnWidths[colIndex] = (
                            arrDefaultColumnWidths[colIndex]
                        );
                    }
                    i += 1;
                }

                // master, you updated arrColumnWidths but didn't update
                //      the internal storage!
                // that is correct, grasshopper, arrColumnWidths is a
                //      reference to the original array variable and
                //      therefore when we make changes to arrColumnWidths
                //      the changes will automatically be reflected in the
                //      internal storage.

                // partial re-render doesn't know how to insert columns
                //      into the middle of the viewport
                element.internalDisplay.fullRenderRequired = true;
                renderLocation(element);
            }

            if (callback) {
                callback(strAnswer);
            }
        };

        if (targetElement) {
            GS.openDialogToElement(
                targetElement,
                templateElement,
                'right',
                afterOpenCallback,
                beforeCloseCallback
            );
        } else {
            GS.openDialog(
                templateElement,
                afterOpenCallback,
                beforeCloseCallback
            );
        }
    }



    function openDataSettingsDialog(element, buttonElement) {
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-max-width', '20em');
        templateElement.setAttribute('no-background', '');
        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.innerHTML = ml(function () {/*
<gs-page class="gs-table-contextmenu">
    <gs-body class="gs-table-contextmenu" padded>
        <div class="context-menu-header">Show Rows:</div>
<table>
    <tbody>
        <tr>
            <td>From:</td>
            <td><gs-number class="pref-limit-from" mini></gs-number></td>
        </tr>
        <tr>
            <td>To:</td>
            <td><gs-number class="pref-limit-to" mini></gs-number></td>
        </tr>
    </tbody>
</table>
        <hr />
        <gs-grid gutter>
            <gs-block>
                <gs-button dialogclose>Cancel</gs-button>
            </gs-block>
            <gs-block>
                <gs-button dialogclose bg-primary>Apply</gs-button>
            </gs-block>
        </gs-grid>
    </gs-body>
</gs-page>
            */
        });

        // the control elements are found in the "after open" callback.
        //      the reason these variables are defined here is so that
        //      the "before close" callback has access to them for free.
        var limitFromControl;
        var limitToControl;

        GS.openDialogToElement(
            buttonElement,
            templateElement,
            'down',
            function () {
                var dialog = this;
                var intLimit;
                var intOffset;

                // we want the top gs-page to have corner rounding
                dialog.classList.add('gs-table-contextmenu');

                // find all of the control elements
                limitFromControl = tblQry(
                    dialog,
                    '.pref-limit-from'
                )[0];
                limitToControl = tblQry(
                    dialog,
                    '.pref-limit-to'
                )[0];

                intLimit = parseInt(
                    element.getAttribute('limit'),
                    10
                );
                intOffset = parseInt(
                    (element.getAttribute('offset') || '0'),
                    10
                );

                // set the values of all the controls
                limitFromControl.value = (intOffset + 1);
                limitToControl.value = (
                    (intLimit + intOffset) ||
                    element.internalData.records.length
                );
            },
            // event parameter is ignored
            function (ignore, strAnswer) {
                var intLimitFrom;
                var intLimitTo;
                var intLimit;

                var strOldLimit;
                var strOldOffset;

                if (strAnswer === 'Apply') {
                    // gather the control values
                    intLimitFrom = parseInt(
                        (limitFromControl.value || '0'),
                        10
                    ) - 1;
                    intLimitTo = parseInt(
                        (limitToControl.value || '0'),
                        10
                    );
                    intLimit = (intLimitTo - intLimitFrom);

                    // save the old limit and offset so that we can know
                    //      if the limit or offset changed
                    strOldLimit = element.getAttribute('limit');
                    strOldOffset = element.getAttribute('offset');

                    // only set the limit and offset attribute if we could
                    //      calculate them. else, remove them.
                    if (!isNaN(intLimit)) {
                        element.setAttribute('limit', intLimit);
                    } else {
                        element.removeAttribute('limit');
                    }
                    if (!isNaN(intLimitFrom)) {
                        element.setAttribute('offset', intLimitFrom);
                    } else {
                        element.removeAttribute('offset');
                    }

                    // if the limit or the offset changed, refresh the table
                    if (
                        element.getAttribute('limit') !== strOldLimit &&
                        element.getAttribute('offset') !== strOldOffset
                    ) {
                        dataSELECT(element);
                    }
                }
            }
        );
    }

    function openClipboardSettingsDialog(element, buttonElement) {
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-max-width', '20em');
        templateElement.setAttribute('no-background', '');
        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.innerHTML = ml(function () {/*
<gs-page class="gs-table-contextmenu">
    <gs-body class="gs-table-contextmenu" padded>
        <div class="context-menu-header">Paste Format:</div>
        <table>
            <tbody>
<tr>
    <td>Headers?</td>
    <td>
        <gs-select class="pref-copy-headers" mini>
            <option value="always">Always</option>
            <option value="never">Never</option>
            <option value="selected">Only when selected</option>
        </gs-select>
    </td>
</tr>
<tr>
    <td>Row Numbers?</td>
    <td>
        <gs-select class="pref-copy-selectors" mini>
            <option value="always">Always</option>
            <option value="never">Never</option>
            <option value="selected">Only when selected</option>
        </gs-select>
    </td>
</tr>
<tr>
    <td>Quote Character:</td>
    <td>
        <gs-select class="pref-quote-char" mini>
            <option value="\">Backslash (\)</option>
            <option value="/">Forward Slash (/)</option>
            <option value="|">Pipe (|)</option>
            <option value="&quot;">Double Quote (&quot;)</option>
            <option value="'">Single Quote (')</option>
        </gs-select>
    </td>
</tr>
<tr>
    <td>Escape Character:</td>
    <td>
        <gs-select class="pref-escape-char" mini>
            <option value="\">Backslash (\)</option>
            <option value="/">Forward Slash (/)</option>
            <option value="|">Pipe (|)</option>
            <option value="&quot;">Double Quote (&quot;)</option>
            <option value="'">Single Quote (')</option>
        </gs-select>
    </td>
</tr>
<tr>
    <td>Quote?</td>
    <td>
        <gs-select class="pref-copy-quote" mini>
            <option value="always">Always</option>
            <option value="never">Never</option>
            <option value="strings">Only on strings</option>
            <option value="delimiter-in-content">
                Cell contains separator
            </option>
        </gs-select>
    </td>
</tr>
<tr>
    <td>Record Separator:</td>
    <td>
        <gs-select class="pref-delimiter-record" mini>
            <option value="{{DOS_RETURN}}">DOS (\r\n)</option>
            <option value="{{MAC_RETURN}}">Mac (\r)</option>
            <option value="{{UNIX_RETURN}}">UNIX (\n)</option>
            <option value="|">Vertical Bar (|)</option>
            <option value=",">Comma (,)</option>
            <option value="{{TAB}}">Tab</option>
        </gs-select>
    </td>
</tr>
<tr>
    <td>Cell Separator:</td>
    <td>
        <gs-select class="pref-delimiter-cell" mini>
            <option value="{{DOS_RETURN}}">DOS (\r\n)</option>
            <option value="{{MAC_RETURN}}">Mac (\r)</option>
            <option value="{{UNIX_RETURN}}">UNIX (\n)</option>
            <option value="|">Vertical Bar (|)</option>
            <option value=",">Comma (,)</option>
            <option value="{{TAB}}">Tab</option>
        </gs-select>
    </td>
</tr>
<tr>
    <td>Empty values:</td>
    <td>
        <gs-select class="pref-null-value" mini>
            <option value="">(nothing)</option>
            <option value="NULL">"NULL"</option>
            <option value="null">"null"</option>
            <option value="EMPTY">"EMPTY"</option>
            <option value="empty">"empty"</option>
            <option value="Nothing">"Nothing"</option>
        </gs-select>
    </td>
</tr>
<tr>
    <td>Copy types:</td>
    <td>
        <gs-select class="pref-copy-types" mini>
            <option value="text">Text</option>
            <option value="html">HTML</option>
            <option value="text,html">Both</option>
        </gs-select>
    </td>
</tr>
            </tbody>
        </table>
        <hr />
        <gs-grid gutter>
            <gs-block>
                <gs-button dialogclose>Cancel</gs-button>
            </gs-block>
            <gs-block>
                <gs-button class="recopy-button" bg-primary>Recopy</gs-button>
            </gs-block>
        </gs-grid>
    </gs-body>
</gs-page>
            */
        })
            .replace(/\{\{UNIX_RETURN\}\}/gi, '\n')
            .replace(/\{\{TAB\}\}/gi, '\t');

        // the control elements are found in the "after open" callback.
        //      the reason these variables are defined here is so that
        //      the "before close" callback has access to them for free.
        var copyHeadersControl;
        var copySelectorsControl;
        var copyQuoteCharControl;
        var copyEscapeCharControl;
        var copyQuoteWhenControl;
        var copyCellDelimiterControl;
        var copyRecordDelimiterControl;
        var copyNullControl;
        var copyTypesControl;

        GS.openDialogToElement(
            buttonElement,
            templateElement,
            'down',
            function () {
                var dialog = this;
                var jsnCopy;

                // we want the top gs-page to have corner rounding
                dialog.classList.add('gs-table-contextmenu');

                // we need the current copy parameters
                jsnCopy = getCopyParameters(element);

                // find all of the control elements
                copyHeadersControl = tblQry(
                    dialog,
                    '.pref-copy-headers'
                )[0];
                copySelectorsControl = tblQry(
                    dialog,
                    '.pref-copy-selectors'
                )[0];
                copyQuoteCharControl = tblQry(
                    dialog,
                    '.pref-quote-char'
                )[0];
                copyEscapeCharControl = tblQry(
                    dialog,
                    '.pref-escape-char'
                )[0];
                copyQuoteWhenControl = tblQry(
                    dialog,
                    '.pref-copy-quote'
                )[0];
                copyCellDelimiterControl = tblQry(
                    dialog,
                    '.pref-delimiter-cell'
                )[0];
                copyRecordDelimiterControl = tblQry(
                    dialog,
                    '.pref-delimiter-record'
                )[0];
                copyNullControl = tblQry(
                    dialog,
                    '.pref-null-value'
                )[0];
                copyTypesControl = tblQry(
                    dialog,
                    '.pref-copy-types'
                )[0];

                copyHeadersControl.value = jsnCopy.headerMode;
                copySelectorsControl.value = jsnCopy.selectorMode;
                copyQuoteCharControl.value = jsnCopy.quoteChar;
                copyEscapeCharControl.value = jsnCopy.escapeChar;
                copyQuoteWhenControl.value = jsnCopy.quoteMode;
                copyCellDelimiterControl.value = jsnCopy.cellDelimiter;
                copyRecordDelimiterControl.value = jsnCopy.recordDelimiter;
                copyNullControl.value = jsnCopy.nullString;
                copyTypesControl.value = jsnCopy.copyTypes;

                tblQry(
                    dialog,
                    '.recopy-button'
                )[0].addEventListener('click', function () {
                    GS.closeDialog(dialog);

                    var strCopyHeaders;
                    var strCopySelectors;
                    var strQuoteChar;
                    var strEscapeChar;
                    var strQuoteMode;
                    var strCellDelimiter;
                    var strRecordDelimiter;
                    var strNullValue;
                    var strCopyTypes;

                    // gather the control values
                    strCopyHeaders = copyHeadersControl.value;
                    strCopySelectors = copySelectorsControl.value;
                    strQuoteChar = copyQuoteCharControl.value;
                    strEscapeChar = copyEscapeCharControl.value;
                    strQuoteMode = copyQuoteWhenControl.value;
                    strCellDelimiter = copyCellDelimiterControl.value;
                    strRecordDelimiter = copyRecordDelimiterControl.value;
                    strNullValue = copyNullControl.value;
                    strCopyTypes = copyTypesControl.value;

                    // save the copy settings
                    element.setAttribute('copy-header', strCopyHeaders);
                    element.setAttribute('copy-selectors', strCopySelectors);
                    element.setAttribute('copy-quote-char', strQuoteChar);
                    element.setAttribute('copy-escape-char', strEscapeChar);
                    element.setAttribute('copy-quote-when', strQuoteMode);
                    element.setAttribute(
                        'copy-delimiter-cell',
                        strCellDelimiter
                    );
                    element.setAttribute(
                        'copy-delimiter-record',
                        strRecordDelimiter
                    );
                    element.setAttribute('copy-null-cell', strNullValue);
                    element.setAttribute('copy-types', strCopyTypes);

                    element.internalEvents.forceCopy = true;
                    element.elems.hiddenFocusControl.focus();
                    document.execCommand('copy');
                });
            }
        );
    }

    // we want the user to have access to limit/offset and copy settings
    function openSettingsDialog(element, buttonElement) {
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-max-width', '15em');
        templateElement.setAttribute('no-background', '');
        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.innerHTML = ml(function () {/*
<gs-page class="gs-table-contextmenu">
    <gs-body class="gs-table-contextmenu" padded>
        <gs-button dialogclose iconleft remove-bottom
            icon="database"
            class="button-column-width">Data Settings</gs-button>
        <gs-button dialogclose iconleft remove-top
            icon="clipboard"
            class="button-column-width">Clipboard Settings</gs-button>
    </gs-body>
</gs-page>
            */
        });

        GS.openDialogToElement(
            buttonElement,
            templateElement,
            'down',
            function () {
                var dialog = this;

                // we want the top gs-page to have corner rounding
                dialog.classList.add('gs-table-contextmenu');
            },
            // event parameter is ignored
            function (ignore, strAnswer) {
                //var targetElement;
                //var targetButton;

                //// when you close the dialog by clicking on the
                ////      overlay, there is no event.
                //if (event && event.target) {
                //    targetElement = event.target;
                //}

                //// when you close the dialog by clicking on the
                ////      overlay, there is no target.
                //if (targetElement) {
                //    // we may need to position a second dialog to a
                //    //      button, so here we get the button that
                //    //      was clicked.
                //    if (targetElement.nodeName === 'GS-BUTTON') {
                //        targetButton = targetElement;
                //    } else {
                //        targetButton = GS.findParentTag(
                //            targetElement,
                //            'gs-button'
                //        );
                //    }
                //}

                if (strAnswer === 'Data Settings') {
                    openDataSettingsDialog(element, buttonElement);
                } else if (strAnswer === 'Clipboard Settings') {
                    openClipboardSettingsDialog(element, buttonElement);
                }
            }
        );

//
//Display:
//    no-record-selector (boolean)
//    header template (boolean)
//    insert record template (boolean)
//    column hide/show
//    theme (wait, we need to write some themes)
//
//Scrolling:
//    no-x-overscroll (boolean)
//    no-y-overscroll (boolean)
//

    }

// #############################################################################
// ############################## EVENT FUNCTIONS ##############################
// #############################################################################

    // ############# QS EVENTS #############

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var jsnAttr;

        // we need a place to store the attributes
        element.internalData.defaultAttributes = {};

        // loop through attributes and store them in the internal
        //      defaultAttributes object
        i = 0;
        len = element.attributes.length;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internalData.defaultAttributes[jsnAttr.nodeName] = (
                jsnAttr.value ||
                ''
            );

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var arrPopKeys;
        var currentValue;
        var bolRefresh;
        var strOperator;
        var jsnDefaultAttr;

        if (strQSCol) {
            jsnDefaultAttr = element.internalData.defaultAttributes;

            if (strQSCol.indexOf('=') !== -1) {
                arrAttrParts = strQSCol.split(',');
                i = 0;
                len = arrAttrParts.length;
                while (i < len) {
                    strQSCol = arrAttrParts[i];

                    if (strQSCol.indexOf('!=') !== -1) {
                        strOperator = '!=';
                        arrQSParts = strQSCol.split('!=');
                    } else {
                        strOperator = '=';
                        arrQSParts = strQSCol.split('=');
                    }

                    strQSCol = arrQSParts[0];
                    strQSAttr = arrQSParts[1] || arrQSParts[0];

                    // if the key is not present or we've got the negator:
                    //      go to the attribute's default or remove it
                    if (strOperator === '!=') {
                        // if the key is not present: add the attribute
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            element.setAttribute(strQSAttr, '');
                        // else: remove the attribute
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    } else {
                        // if the key is not present:
                        //      go to the attribute's default or remove it
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            if (jsnDefaultAttr[strQSAttr] !== undefined) {
                                element.setAttribute(
                                    strQSAttr,
                                    (jsnDefaultAttr[strQSAttr] || '')
                                );
                            } else {
                                element.removeAttribute(strQSAttr);
                            }
                        // else: set attribute to exact text from QS
                        } else {
                            element.setAttribute(strQSAttr, (
                                GS.qryGetVal(strQS, strQSCol) ||
                                jsnDefaultAttr[strQSAttr] ||
                                ''
                            ));
                        }
                    }
                    i += 1;
                }
            } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                strQSValue = GS.qryGetVal(strQS, strQSCol);

                if (element.internalData.bolQSFirstRun !== true) {
                    if (strQSValue !== '' || !element.getAttribute('value')) {
                        element.setAttribute('value', strQSValue);
                    }
                } else {
                    element.value = strQSValue;
                }
            }
        }

        // handle
        //      "refresh-on-querystring-values" and
        //      "refresh-on-querystring-change" attributes
        if (element.internalData.bolQSFirstRun === true) {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = (
                    element.getAttribute('refresh-on-querystring-values')
                        .split(/\s*,\s*/gim)
                );

                i = 0;
                len = arrPopKeys.length;
                while (i < len) {
                    currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);

                    if (element.popValues[arrPopKeys[i]] !== currentValue) {
                        bolRefresh = true;
                    }

                    element.popValues[arrPopKeys[i]] = currentValue;
                    i += 1;
                }

            } else if (element.hasAttribute('refresh-on-querystring-change')) {
                bolRefresh = true;
            }

            if (bolRefresh && element.hasAttribute('src')) {
                element.refresh();

            } else if (bolRefresh && !element.hasAttribute('src')) {
                console.warn(
                    'gs-table Warning: ' +
                            'element has "refresh-on-querystring-values" or ' +
                            '"refresh-on-querystring-change", but no "src".',
                    element
                );
            }
        } else {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = (
                    element.getAttribute('refresh-on-querystring-values')
                        .split(/\s*,\s*/gim)
                );

                i = 0;
                len = arrPopKeys.length;
                while (i < len) {
                    element.popValues[arrPopKeys[i]] = (
                        GS.qryGetVal(strQS, arrPopKeys[i])
                    );
                    i += 1;
                }
            }
        }

        element.internalData.bolQSFirstRun = true;
    }

    function bindQuerystringEvents(element) {
        if (
            element.getAttribute('qs') ||
            element.getAttribute('refresh-on-querystring-values') ||
            element.hasAttribute('refresh-on-querystring-change')
        ) {
            element.popValues = {};

            pushReplacePopHandler(element);
            window.addEventListener('pushstate', function () {
                pushReplacePopHandler(element);
            });
            window.addEventListener('replacestate', function () {
                pushReplacePopHandler(element);
            });
            window.addEventListener('popstate', function () {
                pushReplacePopHandler(element);
            });
        }
    }

    // ############# FOCUS EVENTS #############
    function unbindFocus(element) {
        element.removeEventListener(
            evt.mousedown,
            element.internalEvents.focusMouseDown
        );

        element.elems.dataViewport.removeEventListener(
            'focus',
            element.internalEvents.focusInViewport,
            true
        );
        window.removeEventListener(
            'focus',
            element.internalEvents.focusTracker
        );
        element.removeEventListener(
            'focus',
            element.internalEvents.focusTracker,
            true
        );
        window.removeEventListener(
            'blur',
            element.internalEvents.focusTracker
        );
        window.removeEventListener(
            'focusout',
            element.internalEvents.focusTracker
        );
    }
    function bindFocus(element) {
        element.internalEvents.focusMouseDown = function (event) {
            var blurEventFunction;
            var target = event.target;
            var parentCell;
            // when you put a control into a label, if you click on the label:
            //      it focuses the control. sometimes, people use a label
            //      element simply for the padding. we don't want this focus
            //      behaviour if people just want the label for the padding, so
            //      if the target is a label: prevent default
            parentCell = GS.findParentTag(target, 'gs-cell');
            if (
                parentCell &&
                parentCell.nodeName === 'GS-CELL' &&
                target.nodeName === 'LABEL' &&
                parentCell.children.length === 1 &&
                parentCell.children[0].nodeName === 'LABEL'
            ) {
                event.preventDefault();
                event.stopPropagation();
            }

            // if no focusable control was moused on: focus
            //      hiddenFocusControl
            if (!GS.isElementFocusable(target) && !evt.touchDevice) {
                focusHiddenControl(element);

                //console.log('FOCUS:', document.activeElement);
                //setTimeout(function () {
                //    //console.log('FOCUS:', document.activeElement);
                //}, 1000);

                // some time after this mousedown event finishes, the
                //      hidden focus control gets "blur"ed, so we bind it
                //      to refocus after the "blur" event (only once though,
                //      we don't want the page to get stuck refocusing the
                //      hidden focus control)
                blurEventFunction = function () {
                    // this function isn't reachable by the top level unbind,
                    //      so we need to make sure that it's cabable of
                    //      knowing not to do anything with the element has
                    //      been destroyed.
                    if (element.elems.root) {
                        focusHiddenControl(element);
                        element.elems.hiddenFocusControl.removeEventListener(
                            'blur',
                            blurEventFunction
                        );
                    }
                };
                element.elems.hiddenFocusControl.addEventListener(
                    'blur',
                    blurEventFunction
                );
            }
        };

        element.addEventListener(
            evt.mousedown,
            element.internalEvents.focusMouseDown
        );

        // sometimes the user will click on a control to deselect one cell
        //      out of multiple selected cells. this causes the focus to be
        //      inside a non-selected cell
        element.internalEvents.focusInViewport = function () {
            var active = document.activeElement;
            var parentCell = GS.findParentTag(active, 'gs-cell');
            var parentTable;
            var cell_row;
            var cell_col;
            var jsnRange;

            // if the focused element is inside a GS-CELL element
            if (parentCell && parentCell.nodeName === 'GS-CELL') {
                // if the GS-CELL is not selected
                if (!parentCell.hasAttribute('selected')) {
                    // focus hidden control
                    // focusHiddenControl(element);

                    // select the cell
                    parentTable = GS.findParentTag(active, 'gs-table');
                    if (parentTable && parentTable.nodeName === 'GS-TABLE') {
                        cell_row = parentCell.getAttribute('data-row-number');
                        cell_col = parentCell.getAttribute('data-col-number');

                        if (cell_row === 'insert') {
                            cell_row = parentTable.internalData.records.length;
                        } else {
                            cell_row = parseInt(cell_row, 10);
                        }

                        jsnRange = {
                            "start": {
                                "row": cell_row,
                                "column": cell_col
                            },
                            "end": {
                                "row": cell_row,
                                "column": cell_col
                            },
                            "negator": false
                        };

                        parentTable.internalSelection.ranges = [jsnRange];
                        renderSelection(parentTable);
                        active = document.activeElement;
                        //active.focus; // what is this?
                    }
                }
            }
        };

        element.elems.dataViewport.addEventListener(
            'focus',
            element.internalEvents.focusInViewport,
            true
        );

        // we want to style the table depending on wheather or not the
        //      focus is inside the gs-table
        element.internalEvents.focusTracker = function () {//event
            var active = document.activeElement;
            var parentTable = GS.findParentElement(active, element);
            var parentCell;
            var parentColumn;
            var controlElement;

            element.internalDisplay.focus.latest = false;

            if (
                parentTable &&
                parentTable.nodeName === 'GS-TABLE'
            ) {
                element.classList.add('focus-in');
                element.classList.remove('focus-out');

                parentCell = GS.findParentTag(active, 'gs-cell');
                parentColumn = GS.findParentElement(active, '[column]');

                if (!parentColumn || parentColumn.nodeName === 'HTML') {
                    parentColumn = active;
                }

                // the render function needs to know what element is
                //      focused so that it can maintain that focus
                if (parentCell) {
                    element.internalDisplay.focus.column = (
                        parseInt(
                            (
                                parentCell.getAttribute('data-col-number') ||
                                parentCell.getAttribute('data-col') ||
                                ''
                            ),
                            10
                        )
                    );
                    element.internalDisplay.focus.row = (
                        parseInt(
                            (
                                parentCell.getAttribute('data-row-number') ||
                                ''
                            ),
                            10
                        )
                    );
                    element.internalDisplay.focus.columnAttribute = (
                        parentColumn.getAttribute('column')
                    );

                    controlElement = (
                        active.classList.contains('control')
                            ? active.parentNode
                            : active
                    );

                    element.internalDisplay.focus.nodeName = (
                        controlElement.nodeName
                    );
                    if (
                        active.nodeName === 'INPUT' ||
                        active.nodeName === 'TEXTAREA'
                    ) {
                        element.internalDisplay.focus.selectionRange = (
                            GS.getInputSelection(active)
                        );
                    }
                    element.internalDisplay.focus.latest = true;
                }
            } else {
                element.classList.add('focus-out');
                element.classList.remove('focus-in');
                element.internalDisplay.focus.latest = false;
            }
        };

        window.addEventListener(
            'focus',
            element.internalEvents.focusTracker
        );
        element.addEventListener(
            'focus',
            element.internalEvents.focusTracker,
            true
        );
        window.addEventListener(
            'blur',
            element.internalEvents.focusTracker
        );
        window.addEventListener(
            'focusout',
            element.internalEvents.focusTracker
        );
    }

    // ############# SCROLL EVENTS #############
    function unbindScroll(element) {
        // because touch devices don't have scrollbars, we use a different set
        //      of code for scrolling
        if (evt.touchDevice) {
            element.elems.dataViewport.removeEventListener(
                evt.mousedown,
                element.internalEvents.scrollDragStartFunction
            );
        } else {
            // I tried "mousewheel", "MozMousePixelScroll" and "DOMMouseScroll"
            element.removeEventListener(
                'wheel',
                element.internalEvents.scrollWheelFunction
            );
        }

        window.removeEventListener(
            'resize',
            element.internalEvents.scrollResizeFunction
        );
        element.elems.yScrollBar.removeEventListener(
            'scroll',
            element.internalEvents.scrollBarYFunction
        );
        element.elems.xScrollBar.removeEventListener(
            'scroll',
            element.internalEvents.scrollBarXFunction
        );
    }
    function bindScroll(element) {
        // we need to manually move the scrollbar on a scroll event and then we
        //      need to rerender the cells

        // because touch devices don't have scrollbars, we use a different set
        //      of code for scrolling
        if (evt.touchDevice) {
            var intStartMouseLeft;
            var intStartMouseTop;
            var intStartScrollLeft;
            var intStartScrollTop;
            var intCurrentMouseLeft;
            var intCurrentMouseTop;
            var intCurrentScrollLeft;
            var intCurrentScrollTop;
            var dragStarted;

            element.internalEvents.scrollDragStartFunction = function (event) {
                var jsnMousePos = GS.mousePosition(event);
                dragStarted = false;
                intStartMouseLeft = jsnMousePos.left;
                intStartMouseTop = jsnMousePos.top;
                intStartScrollLeft = element.internalScroll.left;
                intStartScrollTop = element.internalScroll.top;

                // this prevents the scroll from leaving the gs-table and
                //      attempting to scroll the body, it was originally
                //      commentted out with no note. Added the if statement
                //      because it was preventing focus.
                if (
                    event.target.nodeName !== 'INPUT' &&
                    event.target.nodeName !== 'textarea'
                ) {
                    event.preventDefault();
                    //event.stopPropagation();
                }

                document.body.addEventListener(
                    evt.mousemove,
                    element.internalEvents.scrollDragMoveFunction
                );
                document.body.addEventListener(
                    evt.mouseup,
                    element.internalEvents.scrollDragEndFunction
                );
            };

            // on a phone you might want to click without scrolling a
            //      little bit, so we set here a minimum threshold of
            //      distance to before allowing scrolling
            var leftPlay = 10;
            var topPlay = 10;
            element.internalEvents.scrollDragMoveFunction = function (event) {
                var jsnMousePos;
                if (event.which === 0 && !evt.touchDevice) {
                    event.preventDefault();
                    event.stopPropagation();
                    element.internalEvents.scrollDragEndFunction();

                } else {
                    jsnMousePos = GS.mousePosition(event);
                    intCurrentMouseLeft = jsnMousePos.left;
                    intCurrentMouseTop = jsnMousePos.top;
                    intCurrentScrollLeft = element.internalScroll.left;
                    intCurrentScrollTop = element.internalScroll.top;

                    if (
                        dragStarted === false &&
                        (
                            Math.abs(
                                intCurrentMouseLeft - intStartMouseLeft
                            ) > leftPlay ||
                            Math.abs(
                                intCurrentMouseTop - intStartMouseTop
                            ) > topPlay
                        )
                    ) {
                        dragStarted = true;
                    }

                    if (dragStarted) {
                        event.preventDefault();
                        event.stopPropagation();

                        // we need to save the current top/left so that the
                        //      rerender function knows what direction we're
                        //      scrolling
                        element.internalScroll.prevTop =
                                element.internalScroll.top;
                        element.internalScroll.prevLeft =
                                element.internalScroll.left;

                        // scroll the difference
                        element.internalScroll.left -=
                                (intCurrentMouseLeft - intStartMouseLeft) +
                                (intCurrentScrollLeft - intStartScrollLeft);
                        element.internalScroll.top -=
                                (intCurrentMouseTop - intStartMouseTop) +
                                (intCurrentScrollTop - intStartScrollTop);

                        // we need to round the scroll so that we don't run into
                        //      type issues
                        element.internalScroll.top =
                                Math.round(element.internalScroll.top);
                        element.internalScroll.left =
                                Math.round(element.internalScroll.left);

                        // we need to prevent overscrolling
                        element.internalScroll.top = Math.min(
                            element.internalScroll.maxTop,
                            element.internalScroll.top
                        );
                        element.internalScroll.left = Math.min(
                            element.internalScroll.maxLeft,
                            element.internalScroll.left
                        );

                        // we need to prevent underscrolling
                        element.internalScroll.top = Math.max(
                            0,
                            element.internalScroll.top
                        );
                        element.internalScroll.left = Math.max(
                            0,
                            element.internalScroll.left
                        );

                        renderScrollLocation(element);
                    }
                }
            };

            element.internalEvents.scrollDragEndFunction = function () {
                // elastic scrolling
                //console.log('elastic scrolling');
                //renderScrollLocation(element);

                // unbind mousemove and mouseup
                document.body.removeEventListener(
                    evt.mousemove,
                    element.internalEvents.scrollDragMoveFunction
                );
                document.body.removeEventListener(
                    evt.mouseup,
                    element.internalEvents.scrollDragEndFunction
                );
            };

            element.elems.dataViewport.addEventListener(
                evt.mousedown,
                element.internalEvents.scrollDragStartFunction
            );
        // desktop scrolling
        } else {
            element.internalEvents.scrollWheelFunction = function (event) {
                var originalTop;
                var originalLeft;
                var jsnScroll;
                var intDeltaY;
                var intDeltaX;
                var intRecordHeight;
                var intViewportHeight;

                // helper variable to help shorten the code
                jsnScroll = element.internalScroll;

                // when using the logitech smooth scrolling
                // addon there are extra scroll events
                // - Nunzio on 2021-09-21
                if (event.deltaX === undefined || event.deltaY === undefined) {
                    return;
                }

                // we don't want to intercept overscrolling
                if (
                    // if we're at the top and we're scrolling up
                    (
                        jsnScroll.top === 0 &&
                        event.deltaY < 0
                    ) ||
                    // or we're at the bottom and we're scrolling down
                    (
                        jsnScroll.top === jsnScroll.maxTop &&
                        event.deltaY > 0
                    ) ||
                    // or we're at the left and we're scrolling left
                    (
                        jsnScroll.left === 0 &&
                        event.deltaX < 0
                    ) ||
                    // or we're at the right and we're scrolling right
                    (
                        jsnScroll.left === jsnScroll.maxLeft &&
                        event.deltaX > 0
                    )
                ) {
                    // stop execution
                    return;
                }

                // we need to prevent firefox from scrolling the window, Chrome
                //      automatically stops the scroll from bubbling up at this
                //      point
                event.preventDefault();

                // shortcut for viewport height
                intViewportHeight = (
                    element.elems.dataViewport.clientHeight - (
                        element.internalDisplay.headerBorderHeight +
                        element.internalDisplay.headerHeight
                    )
                );

                // we need to save the original top and left so that we can have
                //      the element rerender only if the scroll actually changed
                originalTop = jsnScroll.top;
                originalLeft = jsnScroll.left;

                // we used to do smooth scrolling, this is the code you would
                //      use for that, it increments the scroll by the delta
                //      amount
                //// we need to increment the scroll with the event deltas
                ////      because calculating our own deltas is too much
                ////      trouble right now
                //intDeltaY = event.deltaY;
                //intDeltaX = event.deltaX;

                // because we scroll by the record, we need to find out the
                //      direction of the scroll and then round to nearest record
                //      in that direction
                intDeltaY = Math.round(event.deltaY);
                intDeltaX = Math.round(event.deltaX);

                // We don't want to scroll more than the height of the viewport
                //intViewportHeight

                if (Math.abs(intDeltaY) > intViewportHeight) {
                    if (intDeltaY < 0) {
                        intDeltaY = -(intViewportHeight / 2);
                    } else {
                        intDeltaY = (intViewportHeight / 2);
                    }
                }

                intRecordHeight = (
                    (
                        element.internalDisplay.recordHeights[0] ||
                        element.internalDisplay.defaultRecordHeight
                    ) +
                    element.internalDisplay.recordBorderHeight
                );

                //var intTestOldScrollTop = jsnScroll.top;
                //var intTestSecondScrollTop;

                // up / down
                if (intDeltaY !== 0) {
                    jsnScroll.top = roundToNearestMultiple(
                        jsnScroll.top,
                        intRecordHeight
                    );
                    //intTestSecondScrollTop = jsnScroll.top;
                    jsnScroll.top += roundToNearestMultiple(
                        intDeltaY,
                        intRecordHeight
                    );
                }
                //jsnScroll.top += intDeltaY;

                // left / right
                if (intDeltaX !== 0) {
                    jsnScroll.left += intDeltaX;
                }

                //console.log(
                //    intTestOldScrollTop,
                //    intTestSecondScrollTop,
                //    jsnScroll.top
                //);

                // we need to save the current top/left so that the rerender
                //      function knows what direction we're scrolling
                jsnScroll.prevTop = jsnScroll.top;
                jsnScroll.prevLeft = jsnScroll.left;

                // we need to round the scroll so that we don't run into
                //      type issues
                jsnScroll.top = Math.round(jsnScroll.top);
                jsnScroll.left = Math.round(jsnScroll.left);

                // we need to prevent overscrolling
                element.internalScroll.top = Math.min(
                    jsnScroll.maxTop,
                    jsnScroll.top
                );
                element.internalScroll.left = Math.min(
                    jsnScroll.maxLeft,
                    jsnScroll.left
                );

                // we need to prevent underscrolling
                jsnScroll.top = Math.max(0, jsnScroll.top);
                jsnScroll.left = Math.max(0, jsnScroll.left);

                // we only need to rerender if the scroll actually changed
                //console.log('wheel');
                //console.log('internalTop:   ', element.internalScroll.top);
                //console.log('originalTop:   ', originalTop);
                //console.log('internalLeft:  ', element.internalScroll.left);
                //console.log('originalLeft:  ', originalLeft);
                if (
                    (jsnScroll.top !== originalTop) ||
                    (jsnScroll.left !== originalLeft)
                ) {
                    renderScrollLocation(element);
                }
            };
            // I tried "mousewheel", "MozMousePixelScroll" and "DOMMouseScroll"
            element.addEventListener(
                'wheel',
                element.internalEvents.scrollWheelFunction
            );
        }

        // we need to update the scrollbar dimensions if the window is resized
        element.internalEvents.scrollResizeFunction = function () {
            renderScrollDimensions(element);
        };
        window.addEventListener(
            'resize',
            element.internalEvents.scrollResizeFunction
        );

        // we need to update the scrollbar location from true scrollbar
        //      location to virtual scrollbar location
        element.internalEvents.scrollBarYFunction = function () {
            var intViewportHeight;
            var virtualScrollHeight;
            var trueScrollHeight;
            var trueScrollTop;

            var newVirtualScrollTop;

            // sometimes, the gs-table triggeres a scrollbar event, so here we
            //      check to make sure the scrollbarY event has not been
            //      cancelled
            if (!element.internalEventCancelled.scrollbarY) {
                // we need the viewport dimensions because true scroll
                //      dimensions include the viewport height, which
                //      messes with the caluculations
                intViewportHeight = (
                    element.elems.dataViewport.clientHeight
                );

                // we are saving the max scroll dimensions for ease of access
                virtualScrollHeight = element.internalScroll.maxTop;

                // we need the actual scroll height of the scrollbars because
                //      we limit their height and that causes a difference we
                //      need to account for
                trueScrollHeight = element.elems.yScrollBar.scrollHeight;
                trueScrollHeight -= intViewportHeight;

                // we are saving the current true scroll location for ease
                //      of access
                trueScrollTop = element.elems.yScrollBar.scrollTop;

                // get new rounded scroll
                newVirtualScrollTop = (
                    trueScrollTop * (
                        virtualScrollHeight / trueScrollHeight
                    )
                );

                // we need to translate the true top into virtual top for the
                //      virtual scroll and save to internal location
                // if this event gets triggered while the scrollbar doesn't have
                //      any room, trueScrollHeight will be 0 which means that
                //      (virtualScrollHeight / trueScrollHeight)
                //      would result in NaN (because of the division by 0),
                //      so, coalesce top to 0
                element.internalScroll.top = (newVirtualScrollTop || 0);

                // we need to round the scroll so that we don't run into
                //      any type issues
                element.internalScroll.top =
                        Math.round(element.internalScroll.top);

                // we need to prevent overscrolling
                element.internalScroll.top = Math.min(
                    element.internalScroll.maxTop,
                    element.internalScroll.top
                );

                // we need to prevent underscrolling
                element.internalScroll.top = Math.max(
                    0,
                    element.internalScroll.top
                );

                // render scroll location
                renderScrollLocation(element);
            }

            // if the scrollbarY was cancelled, we no longer want it to be
            //      cancelled. so, reset it to false
            element.internalEventCancelled.scrollbarY = false;
        };
        element.elems.yScrollBar.addEventListener(
            'scroll',
            element.internalEvents.scrollBarYFunction
        );

        // we need to update the scrollbar location from true scrollbar
        //      location to virtual scrollbar location
        element.internalEvents.scrollBarXFunction = function () {
            //console.log('scrollBarXFunction');
            var intViewportWidth;
            var virtualScrollWidth;
            var trueScrollWidth;
            var trueScrollLeft;

            // sometimes, the gs-table triggeres a scrollbar event, so here we
            //      check to make sure the scrollbarX event has not been
            //      cancelled
            //console.log(element.internalEventCancelled.scrollbarX);
            if (!element.internalEventCancelled.scrollbarX) {
                // we need the viewport dimensions because true scroll
                //      dimensions include the viewport width, which messes
                //      with the caluculations
                intViewportWidth = element.elems.dataViewport.clientWidth;

                // we are saving the max scroll dimensions for ease of access
                virtualScrollWidth = element.internalScroll.maxLeft;

                // we need the actual scroll width of the scrollbars because
                //      we limit their width and that causes a difference we
                //      need to account for
                trueScrollWidth = element.elems.xScrollBar.scrollWidth;
                trueScrollWidth -= intViewportWidth;

                // we are saving the current true scroll location for ease
                //      of access
                trueScrollLeft = element.elems.xScrollBar.scrollLeft;

                // we need to translate the true left into virtual left for the
                //      virtual scroll and save to internal location
                element.internalScroll.left = (
                    trueScrollLeft * (
                        virtualScrollWidth / trueScrollWidth
                    )
                );

                // if this event gets triggered while the scrollbar doesn't have
                //      any room, trueScrollWidth will be 0 which means that
                //      (virtualScrollWidth / trueScrollWidth)
                //      would result in NaN (because of the division by 0),
                //      so, coalesce left to 0
                element.internalScroll.left = (
                    element.internalScroll.left || 0
                );

                // we need to round the scroll so that we don't run into
                //      any type issues
                element.internalScroll.left =
                        Math.round(element.internalScroll.left);

                // we need to prevent overscrolling
                element.internalScroll.left = Math.min(
                    element.internalScroll.maxLeft,
                    element.internalScroll.left
                );

                // we need to prevent underscrolling
                element.internalScroll.left = Math.max(
                    0,
                    element.internalScroll.left
                );

                // render scroll location
                renderScrollLocation(element);
            }

            // if the scrollbarX was cancelled, we no longer want it to be
            //      cancelled. so, reset it to false
            element.internalEventCancelled.scrollbarX = false;
        };
        element.elems.xScrollBar.addEventListener(
            'scroll',
            element.internalEvents.scrollBarXFunction
        );
    }

    // ############# SELECTION EVENTS #############
    function unbindSelection(element) {
        if (evt.touchDevice) {
            // ### NEED CODING ###
        } else {
            element.elems.dataContainer.removeEventListener(
                evt.mousedown,
                element.internalEvents.selectDragStart
            );
            document.body.removeEventListener(
                evt.mousemove,
                element.internalEvents.selectDragMove
            );
            document.body.removeEventListener(
                evt.mouseup,
                element.internalEvents.selectDragEnd
            );
        }
    }
    function bindSelection(element) {
        // #####################################################################
        // ############### SELECTION MODIFICATIONS of 2017-04-13 ###############
        // ##################### THIS HAST BEEN COMPLETED! #####################
        // #####################################################################
        //
        // hear ye! we'll be making some real changes to the selection
        //      functionality. this happened because towards the beginning of
        //      this project I made a some bad choices regarding selection and
        //      the insert record.
        //
        //      The bad choices stemmed from not checking the functionality of
        //      other capable datagrids designed by people who know what they're
        //      doing.
        //
        //      Dont panic, I'll e'splain.
        //
        //      Bad choice #1 was to make the insert record stick to the bottom
        //      of the viewport. While this seemed like a good idea because
        //      whenever you want to insert the insert record is right there,
        //      this makes it so that selection of data and/or the insert record
        //      needs to be mutually exclusive or else the selection will appear
        //      non-contiguous in some areas and give the idea that the
        //      selection ends prematurely in other areas.
        //
        //      Bad choice #2 was to make the internal representation of the
        //      selection not resolve the entire selection, instead, it resolves
        //      the data cell selections and has some other, awkward places to
        //      look for other selections. This approach also made it so that if
        //      you only had record selectors selected, some areas of the code
        //      wouldn't be able to tell because no data cells were selected.
        //
        //      To remedy choice #1, I had to modify the getCurrentCellRange
        //      function to make it determine if the insert record would be
        //      visible. After that, I made the full render and the partial
        //      render functions handle the visiblity. This remedied choice #1.
        //
        //      To remedy choice #2, I'm going to replace the -1 values in
        //      the selection range JSON and add some new values. Start and
        //      end points that are on a data cell will still use numbers.
        //      Here is the list of non-number values that will be able to
        //      be used:
        //          for rows:
        //              'header'
        //              'insert'
        //          for columns:
        //              'selector'
        //      For example, selection for a range that starts with the all
        //      selector and ends in the fifth column of the sixth row will
        //      look like this:
        //          {
        //              "start": {
        //                  "row": "header",
        //                  "column": "selector"
        //              },
        //              "end": {
        //                  "row": 5,   // zero-based
        //                  "column": 4 // zero-based
        //              },
        //              "negator": false
        //          }
        //
        //      In the resolved selection, we need to be able to determine
        //      the type of cell as well as it's selection using only one
        //      character. So, we'll use two letters per type, one for
        //      selected and one for unselected. Here are the various types
        //      and their characters:
        //          Type:              Unselected:   Selected:
        //          HEADER CELL        A             B
        //          RECORD CELL        C             D
        //          INSERT CELL        E             F
        //          ALL SELECTOR       G             H
        //          RECORD SELECTOR    I             J
        //          INSERT SELECTOR    K             L
        //
        //      Using our previous example of selection inside a table with
        //      eight records, eight columns, a header and an insert record.
        //      The resolved selection for internal lookup would look like
        //      this:
        //          [
        //              "HBBBBBAAA", // header
        //              "JDDDDDCCC", // data
        //              "JDDDDDCCC", // data
        //              "JDDDDDCCC", // data
        //              "JDDDDDCCC", // data
        //              "JDDDDDCCC", // data
        //              "JDDDDDCCC", // data
        //              "ICCCCCCCC", // data
        //              "ICCCCCCCC", // data
        //              "KEEEEEEEE"  // insert
        //          ]
        //
        //      Just like before, we'll include these:
        //          an array of columns that contain at lease one selected cell
        //              new values to be included:
        //                  'selector'
        //          an array of records that contain at lease one selected cell
        //              new values to be included:
        //                  'header'
        //                  'insert'
        //          the origin record number
        //
        //      Alright, we know what's wrong and what we want to end up with,
        //      how are we going to get they-ah from he-ah?
        //          1) We need to tag any sections of code that utilizes the old
        //                  selection format. The tag will be "OL' SELECTION"
        //          DONE
        //
        //          2) We need to comment out the selection renderer.
        //          DONE
        //
        //          3) We need the mouse events to generate the new format for
        //                  selection range JSON.
        //          DONE
        //
        //          4) We need to generate the new format of resolved
        //                  selection in the selection renderer.
        //          DONE
        //
        //          5) We need to loop through the visible cells and use
        //                  the resolved selection to style all of the
        //                  appropriate cells.
        //          DONE
        //
        //          6) We need to update any behaviour that utilizes the old
        //                  selection format.
        //          DONE
        //
        //          7) We need to make it so that if a paste is divided between
        //                  the insert record and some data records, we need to
        //                  do an update and an insert from that paste.
        //          DONE
        //
        //          8) We need to pat ourselves on the back about 4 times and
        //                  then slap ourselves on the face 4 times for having
        //                  screwed this up in the first place.
        //
        //          9) We need to pat ourselves on the back 4 more times for
        //                  having so thouroughly planned this recovery.
        //
        //          10) Finally, we need to inform papa of our success.
        //
        //          11) We should prolly stop referring to ourselves as two
        //                  seperate beings... My... precious...
        //
        //      This sub-document was authored by Michael.
        //
        // #####################################################################
        // ############### SELECTION MODIFICATIONS of 2017-04-13 ###############
        // ##################### THIS HAST BEEN COMPLETED! #####################
        // #####################################################################
        var strSelectionMode = element.getAttribute('selection-mode');
        var jsnStartCell;
        var jsnCurrentCell;
        var intStartScrollTop;
        var intStartScrollLeft;

        // touch devices default to single row. in the future, when we add more
        //      modes, we'll need to make sure that we only allow touch devices
        //      to use a selection mode that is compatible with touch. For the
        //      time being, we only have single-row for touch.
        if (evt.touchDevice) {
            strSelectionMode = 'single-row';
        }

        // touch devices have a different way to select, so here we bind the
        //      touch-friendly version of cell selection. The way this selection
        //      mode will work is the mouse/touch start and end on the same
        //      record, we'll select the whole record. Additionally, this mode
        //      can be turned on with an attribute. Sometimes, we want record
        //      only selection. This will make the gs-table upwind of being used
        //      as a listbox, combobox, or any other record selection element.
        if (strSelectionMode === 'single-row') {
            element.internalEvents.selectRowStart = function (event) {
                // find out the cell location based on the mouse event
                jsnStartCell = getCellFromMouseEvent(element, event);
                console.log(jsnStartCell);
                jsnCurrentCell = jsnStartCell;
                intStartScrollTop = element.internalScroll.displayTop;
                intStartScrollLeft = element.internalScroll.displayLeft;

                // we add the mouseup event to the body because
                //      if you're dragging and you mousemove off
                //      of the element: we wan't to continue the selection,
                //      and if you mouseup off of the element, we still want
                //      to register that as a mouseup/end of selection
                if (event.which === 1 || evt.touchDevice) {
                    document.body.addEventListener(
                        evt.mousemove,
                        element.internalEvents.selectDragMove
                    );

                    // TODO: firefox doesn't work with this and overflow
                    //      (event.target remains the origin cell)
                    document.body.addEventListener(
                        evt.mouseup,
                        element.internalEvents.selectDragEnd
                    );

                // if the cell was right-clicked, we don't want to listen
                //      to mouse drag. in fact, in order to have the
                //      selection recalculate the selection cache in time
                //      for the context menu we need to end the selection
                //      now.
                } else {
                    element.internalEvents.selectDragEnd();
                }
            };

            element.internalEvents.selectDragMove = function (event) {
                // find out the cell location based on the mouse event
                jsnCurrentCell = getCellFromMouseEvent(element, event);
            };

            element.internalEvents.selectDragEnd = function () {
                var newRange;

                // selecting the header automatically selects everything below
                //      it, so we're not going to allow header selection.
                if (jsnCurrentCell.row !== 'header') {
                    // create new range object
                    newRange = {
                        "start": {"row": 0, "column": "selector"},
                        "end": {"row": 0, "column": "selector"},
                        "negator": false
                    };

                    // replace the range start with the discovered location, and
                    //      make the end the same as the start, because we only
                    //      allow one row in this mode
                    newRange.start.row = jsnCurrentCell.row;
                    newRange.end.row = newRange.start.row;
                }

                if (
                    jsnStartCell.row === jsnCurrentCell.row &&
                    jsnStartCell.column === jsnCurrentCell.column &&
                    intStartScrollTop === element.internalScroll.displayTop &&
                    intStartScrollLeft === element.internalScroll.displayLeft &&
                    newRange
                ) {
                    // row selection only allows one row at a time, so we
                    //      override all ranges every time.
                    element.internalSelection.ranges = [newRange];

                    // update the DOM, we're ready to see the new selection
                    renderSelection(element);
                    GS.triggerEvent(element, 'selection_change');
                }

                // unbind mousemove and mouseup
                document.body.removeEventListener(
                    evt.mousemove,
                    element.internalEvents.selectDragMove
                );
                document.body.removeEventListener(
                    evt.mouseup,
                    element.internalEvents.selectDragEnd
                );
            };

            element.elems.dataContainer.addEventListener(
                evt.mousedown,
                element.internalEvents.selectRowStart
            );

        // on a desktop, the default selection mode is cell-by-cell. We create a
        //      selection range that treats the start and end cells as the two
        //      opposing corners of the range.
        } else {// alias for this mode is "all"
            // we save a copy of the current ranges so that if the
            //      before_selection event gets prevented, we can revert the
            //      selection
            var selectionRangesCopy;

            // we may be altering the only selection range or the last range
            //      if a long list of ranges, so here we store what index in
            //      the selection range array we are editing
            var intCurrentSelectionIndex;

            element.internalEvents.selectDragStart = function (event) {
                var cell;
                var jsnRange;
                var newRange;
                var jsnLocation;

                element.bolFocusHiddenTextarea = false;

                // we need the cell that received the mousedown so that we
                //      can get it's row/column numbers (and of the case of
                //      adding a selection, wheather of not it's already
                //      selected)
                cell = GS.findParentElement(event.target, 'gs-cell');

                if (
                    cell &&
                    // if we found a cell
                    cell.nodeName === 'GS-CELL' &&
                    // and we're not resizing a cell or record right now
                    element.internalResize.currentlyResizing === false &&
                    // and we're not reordering columns right now
                    element.internalReorder.currentlyReordering === false &&
                    // and the user used the left mouse button
                    // or the user right-clicked on a non-selected cell
                    (
                        event.which === 1 ||
                        !cell.hasAttribute('selected')
                    )
                ) {
                    // we need to let the other code know that we are currently
                    //      selecting
                    element.internalSelection.currentlySelecting = true;

                    // we define newRange here so that we can see the structure
                    //      and so that we can modify/use it
                    newRange = {
                        "start": {"row": 0, "column": 0},
                        "end": {"row": 0, "column": 0},
                        "negator": false
                    };

                    // save a copy of the current selection range so that we can
                    //      revert back to it if we need to
                    selectionRangesCopy = JSON.parse(
                        JSON.stringify(
                            element.internalSelection.ranges
                        )
                    );

                    // find out the cell location based on the mouse event
                    jsnLocation = getCellFromMouseEvent(element, event);

                    // replace the range start with the discovered location
                    newRange.start.row = jsnLocation.row;
                    newRange.start.column = jsnLocation.column;

                    // the end is the same as the start because we are only on
                    //      the first cell of the selection
                    newRange.end.row = newRange.start.row;
                    newRange.end.column = newRange.start.column;

                    //console.log('shiftKey : ', event.shiftKey);
                    //console.log('metaKey  : ', event.metaKey);
                    //console.log('ctrlKey  : ', event.ctrlKey);

                    // if the selection starts with no shift, CMD or CTRL
                    //      keys down: we clear all of the previous selections
                    //      and start with an new selection
                    if (!event.shiftKey && !event.metaKey && !event.ctrlKey) {
                        // clear all the old ranges and add the new range
                        element.internalSelection.ranges = [newRange];
                        // GS.triggerEvent(element, 'selection_change');
                        // because our new selection is the first in the list,
                        //      the current selection index is 0
                        intCurrentSelectionIndex = 0;
                    } else {
                        // if the shift key is down (and the previous selection
                        //      was not negator selection), we need override the
                        //      previous selection's endpoint, so we'll just set
                        //      the intCurrentSelectionIndex to the index of the
                        //      latest selection
                        if (event.shiftKey) {
                            intCurrentSelectionIndex = (
                                element.internalSelection.ranges.length - 1
                            );

                            // if the previous selection was not a negator
                            if (
                                element.internalSelection
                                    .ranges[intCurrentSelectionIndex]
                                    .negator === false
                            ) {
                                // we reset the endpoint of the latest range so
                                //      that the re-render that's coming up
                                //      shows the user that they've changed
                                //      their selection
                                element.internalSelection
                                    .ranges[intCurrentSelectionIndex]
                                    .end.row = newRange.start.row;
                                element.internalSelection
                                    .ranges[intCurrentSelectionIndex]
                                    .end.column = newRange.start.column;

                            // if the previous selection was a negator
                            //      selection, just add a new selection range
                            } else {
                                // add the new range to the end of the selection
                                //      range list
                                element.internalSelection.ranges.push(newRange);

                                // because we added our new selection to the end
                                //      of the selection range list, we need to
                                //      set the intCurrentSelectionIndex to end
                                //      end of the list
                                intCurrentSelectionIndex = (
                                    element.internalSelection.ranges.length - 1
                                );
                            }

                            // if the first selection range covers more than one
                            //      cell, focus the hidden textarea
                            jsnRange = element.internalSelection.ranges[0];
                            if (
                                jsnRange.start.row !== jsnRange.end.row ||
                                jsnRange.start.column !== jsnRange.end.column
                            ) {
                                //console.log('Focus, grasshopper');
                                element.bolFocusHiddenTextarea = true;
                            }

                        // else if the CMD of CTRL key is down, we create a new
                        //      selection and append it to the end
                        } else if (event.metaKey || event.ctrlKey) {
                            // if the new selection started on an already
                            //      selected cell, this selection becomes a
                            //      negator range (meaning that every cell in
                            //      it's range gets unselected)
                            if (cell.hasAttribute('selected')) {
                                newRange.negator = true;
                            }

                            // add the new range to the end of the selection
                            //      range list
                            element.internalSelection.ranges.push(newRange);

                            // because we added our new selection to the end of
                            //      the selection range list, we need to set the
                            //      intCurrentSelectionIndex to end end of the
                            //      list
                            intCurrentSelectionIndex = (
                                element.internalSelection.ranges.length - 1
                            );
                        }
                    }

                    // we re-render the selection because it has just been
                    //      changed
                    renderSelection(element);
                    GS.triggerEvent(element, 'selection_change');

                    // we add mousemove and mouseup events to the body because
                    //      if you're dragging to select and you mousemove off
                    //      of the element: we wan't to continue the selection,
                    //      and if you mouseup off of the element, we still want
                    //      to register that as a mouseup/end of selection
                    if (event.which === 1) {
                        document.body.addEventListener(
                            evt.mousemove,
                            element.internalEvents.selectDragMove
                        );
                        // TODO: firefox doesn't work with this and overflow
                        //      (event.target remains the origin cell)
                        document.body.addEventListener(
                            evt.mouseup,
                            element.internalEvents.selectDragEnd
                        );

                    // if the cell was right-clicked, we don't want to listen
                    //      to mouse drag. in fact, in order to have the
                    //      selection recalculate the selection cache in time
                    //      for the context menu we need to end the selection
                    //      now.
                    } else {
                        element.internalEvents.selectDragEnd();
                    }
                }
            };

            element.internalEvents.selectDragMove = function (event) {
                var intOldEndRow;
                var intOldEndCol;
                var currentRange;
                var jsnCurrentSelection;
                var focusedElement;
                var parentTable;

                focusedElement = document.activeElement;
                parentTable = GS.findParentTag(focusedElement, 'gs-table');
                jsnCurrentSelection = GS.getInputSelection(focusedElement);

                // if mouse is moving but no mouse button is down: finalize
                //      selection, unbind selectDragMove and unbind
                //      selectDragEnd
                if (event.which === 0 && !evt.touchDevice) {
                    element.internalEvents.selectDragEnd();

                // if selecting text, prevent selection
                } else if (
                    (jsnCurrentSelection.end - jsnCurrentSelection.start) !== 0
                ) {
                    element.internalEvents.selectDragEnd();

                } else {
                    // find out the cell location based on the mouse event
                    var jsnLocation = getCellFromMouseEvent(element, event);

                    // get current selection range for easy access
                    currentRange = (
                        element.internalSelection
                            .ranges[intCurrentSelectionIndex]
                    );

                    if (currentRange.start.column === 'selector') {
                        jsnLocation.column = 'selector';
                    }

                    // save old row and column so that we can later check if
                    //      a change was actually made (that way we only
                    //      re-render if the selection has changed)
                    intOldEndRow = currentRange.end.row;
                    intOldEndCol = currentRange.end.column;

                    currentRange.end.row = jsnLocation.row;
                    currentRange.end.column = jsnLocation.column;

                    // prevent text selection if selection is more than one cell
                    if (
                        currentRange.start.row !== currentRange.end.row ||
                        currentRange.start.column !== currentRange.end.column
                    ) {
                        event.preventDefault();
                        event.stopPropagation();
                    }

                    // focus hidden focus control is not focused
                    //      and
                    //      if the selection just became
                    //          multiple cells with this selection (if selection
                    //          is more than one cell and previous endpoint was
                    //          the same as the starting point)
                    //      or
                    //      if the currently focused element is not a child
                    //          of this gs-table element
                    if (
                        focusedElement !== element.elems.hiddenFocusControl &&
                        (
                            // if the current range encompasses more than one
                            //      cell
                            (
                                (
                                    currentRange.start.row !==
                                            currentRange.end.row ||
                                    currentRange.start.column !==
                                            currentRange.end.column
                                ) &&
                                (
                                    currentRange.start.row === intOldEndRow &&
                                    currentRange.start.column === intOldEndCol
                                )
                            ) ||
                            // if the selection is not inside the gs-table
                            parentTable !== element ||
                            // if there is more than one selection
                            element.internalSelection.ranges.length > 1
                        )
                    ) {
                        focusHiddenControl(element);
                    }

                    // re-render selection if selection ranges have been changed
                    if (
                        currentRange.end.row !== intOldEndRow ||
                        currentRange.end.column !== intOldEndCol
                    ) {
                        renderSelection(element);
                        GS.triggerEvent(element, 'selection_change');
                    }
                }
            };
            element.internalEvents.selectDragEnd = function (/*event*/) {
                var beforeEvent;

                // trigger a "before_selection" event so that the page has a
                //      chance to cancel the selection
                beforeEvent = GS.triggerEvent(element, 'before_selection');

                // if the user prevents the default on the "before_selection"
                //      event, revert selection ranges to what they were before
                //      the latest selection started (and revert wheather or not
                //      the selection is in the insert record)
                if (beforeEvent.defaultPrevented) {
                    element.internalSelection.ranges = selectionRangesCopy;
                }

                // final re-render of the selection so that the selection is
                //      up to date
                renderSelection(element);

                // if the "before_selection" event is not prevented, we trigger
                //      "after_selection" so that the page can run code after a
                //      selection has been made
                if (beforeEvent.defaultPrevented) {
                    GS.triggerEvent(element, 'after_selection');
                }

                // unbind mousemove and mouseup
                document.body.removeEventListener(
                    evt.mousemove,
                    element.internalEvents.selectDragMove
                );
                document.body.removeEventListener(
                    evt.mouseup,
                    element.internalEvents.selectDragEnd
                );

                // we need to let the other code know that we are no longer
                //      selecting
                element.internalSelection.currentlySelecting = false;

                if (element.bolFocusHiddenTextarea) {
                    focusHiddenControl(element);
                }
            };

            element.elems.dataContainer.addEventListener(
                evt.mousedown,
                element.internalEvents.selectDragStart
            );
        }
    }

    // ############# COLUMN/ROW RESIZE EVENTS #############
    function unbindCellResize(element) {
        if (!evt.touchDevice) {
            element.elems.dataViewport.removeEventListener(
                evt.mousemove,
                element.internalEvents.cellResizeStarter
            );

            element.elems.handleColumn.removeEventListener(
                evt.mousedown,
                element.internalEvents.cellResizeDragStart
            );
            element.elems.handleRecord.removeEventListener(
                evt.mousedown,
                element.internalEvents.cellResizeDragStart
            );

            element.elems.handleColumn.removeEventListener(
                'dblclick',
                element.internalEvents.cellResizeToDefault
            );
            element.elems.handleRecord.removeEventListener(
                'dblclick',
                element.internalEvents.cellResizeToDefault
            );

            window.removeEventListener(
                'resize',
                element.internalEvents.columnAutoResize
            );
        }
    }
    function bindCellResize(element) {
        var showHandles;
        var setLineToMouse;

        // if we are not on a touch device
        if (!evt.touchDevice) {
            // we don't want to show the handles immediately, that'll mean
            //      that if the user moves the mouse across the viewport,
            //      there'll be resize handles popping up and disappearing
            //      rapidly. this effect would look bad and be distracting.
            //      to fix this, we'll throttle the function that detects if
            //      a handle should be show, but not the code that removes
            //      the handle.
            // ### NEED CODING ###
            showHandles = function (event) {
                if (element.internalResize.showThrottleID !== null) {
                    clearTimeout(element.internalResize.showThrottleID);
                    element.internalResize.showThrottleID = null;
                }

                element.internalResize.showThrottleID = setTimeout(
                    function () {
                        var intPreviousPoint;
                        var jsnElementPos;
                        var jsnMousePos;
                        var intMouseX;
                        var intMouseY;
                        var intPoint;
                        var i;
                        var len;

                        // the table might be taken out of the DOM before this
                        //      code is run (in which case, there's nothing to
                        //      do), so let's check
                        if (!element.elems.dataViewport) {
                            return false;
                        }

                        jsnElementPos = GS.getElementOffset(
                            element.elems.dataViewport
                        );
                        jsnMousePos = GS.mousePosition(event);

                        // we need the mouse X to be relative to the
                        //      dataViewport
                        intMouseX = (jsnMousePos.left - jsnElementPos.left);

                        // we need the mouse Y to be relative to the
                        //      dataViewport
                        intMouseY = (jsnMousePos.top - jsnElementPos.top);

                        // see if the mouse collides with a column drag handle
                        //      point
                        element.internalResize.resizeColumn = false;
                        if (
                            element.internalDisplay.recordSelectorVisible &&
                            intMouseY <= (
                                element.internalDisplay.headerHeight
                            )
                        ) {
                            i = 0;
                            len = element.internalDisplay.columnHandles.length;
                            while (i < len) {
                                intPoint = (
                                    element.internalDisplay.columnHandles[i]
                                );

                                // sometimes a column will be hidden, hidden
                                //      columns have null for their handle
                                if (intPoint !== null) {
                                    if (Math.abs(intMouseX - intPoint) <= 5) {
                                        // we need to know what column we are
                                        //      resizing, so here we save the
                                        //      index of the column that we
                                        //      found
                                        element.internalResize
                                            .resizeColumnHandleIndex = i;

                                        // because we found a column to resize,
                                        //      set the resizeColumn in internal
                                        //      storage to true so that the drag
                                        //      code knows that it's going to
                                        //      resize in the X axis
                                        element.internalResize.resizeColumn = (
                                            true
                                        );

                                        // we need to be able to prevent the
                                        //      user from resizing a cell to
                                        //      negative dimensions, so here we
                                        //      decide the origin X (the cell
                                        //      resize code uses, this origin
                                        //      to stop the user)
                                        // if there is a previous handle point,
                                        //      use, that as the origin X
                                        if (intPreviousPoint !== undefined) {
                                            element.internalResize
                                                .cellOriginX = (
                                                    intPreviousPoint
                                                );
                                        // else, 0 is the origin X
                                        } else {
                                            element.internalResize
                                                .cellOriginX = 0;
                                        }

                                        // we want the minimum width to be 1
                                        element.internalResize.cellOriginX += 1;

                                        break;
                                    }
                                    if (intPoint > intMouseX) {
                                        break;
                                    }

                                    intPreviousPoint = intPoint;
                                }
                                i += 1;
                            }
                        }

                        // see if the mouse collides with a record drag handle
                        //      point
                        element.internalResize.resizeRecord = false;
                        if (
                            element.internalDisplay.headerVisible &&
                            intMouseX <= (
                                element.internalDisplay.recordSelectorWidth
                            )
                        ) {
                            i = 0;
                            len = element.internalDisplay.recordHandles.length;
                            while (i < len) {
                                intPoint = (
                                    element.internalDisplay.recordHandles[i]
                                );

                                if (Math.abs(intMouseY - intPoint) <= 5) {
                                    // we need to know what record we are
                                    //      resizing, so here we save the
                                    //      index of the record that we found
                                    element.internalResize
                                        .resizeRecordHandleIndex = i;

                                    // because we found a record to resize, set
                                    //      the resizeRecord in internal storage
                                    //      to true so that the drag code knows
                                    //      that it's going to resize in the Y
                                    //      axis
                                    element.internalResize.resizeRecord = true;

                                    // we need to be able to prevent the user
                                    //      from resizing a cell to negative
                                    //      dimensions, so here we decide the
                                    //      origin Y (the cell resize code uses
                                    //      this origin to stop the user)

                                    // if we found the insert record, origin is
                                    //      0
                                    if (
                                        i === (len - 1) &&
                                        element.internalDisplay
                                            .insertRecordVisible
                                    ) {
                                        element.internalResize.cellOriginY = (
                                            0
                                        );

                                    // if there is a previous handle point, use
                                    //      that as the origin Y
                                    } else if (i > 0) {
                                        element.internalResize.cellOriginY = (
                                            element.internalDisplay
                                                .recordHandles[i - 1]
                                        );

                                    // else, 0 is the origin Y
                                    } else {
                                        element.internalResize.cellOriginY = 0;
                                    }

                                    // we want the minimum height to be 1
                                    element.internalResize.cellOriginY += 1;

                                    break;
                                }
                                if (intPoint > intMouseY) {
                                    break;
                                }
                                i += 1;
                            }
                        }

                        //console.log(
                        //    element.internalResize.resizeRecordHandleIndex
                        //);

                        // append any handles that aren't already in the DOM

                        // if the mouse is over a column handle point, add the
                        //      column resize handle
                        if (
                            element.internalResize.resizeColumn &&
                            element.elems.handleColumn.parentNode !==
                                element.elems.dataViewport &&
                            !element.hasAttribute('no-resize-column')
                        ) {
                            // append handle element to the viewport
                            element.elems.dataViewport
                                .appendChild(element.elems.handleColumn);
                        }

                        // if the mouse is over a record handle point, add the
                        //      record resize handle
                        if (
                            element.internalResize.resizeRecord &&
                            element.elems.handleRecord.parentNode !==
                                element.elems.dataViewport &&
                            !element.hasAttribute('no-resize-record')
                        ) {
                            // append handle element to the viewport
                            element.elems.dataViewport
                                .appendChild(element.elems.handleRecord);
                        }

                        // move column handle to correct position
                        if (element.internalResize.resizeColumn) {
                            // move handle to correct position depending on the
                            //      column that was matched
                            element.elems.handleColumn.style.left = (
                                element.internalDisplay.columnHandles[
                                    element.internalResize
                                        .resizeColumnHandleIndex
                                ]
                            ) + 'px';
                        }

                        // move record handle to correct position
                        if (element.internalResize.resizeRecord) {
                            // move handle to correct position depending on the
                            //      record that was matched
                            element.elems.handleRecord.style.top = (
                                element.internalDisplay.recordHandles[
                                    element.internalResize
                                        .resizeRecordHandleIndex
                                ]
                            ) + 'px';
                        }



                        // if the mouse is over a column and record handle point
                        if (
                            element.internalResize.resizeColumn &&
                            element.internalResize.resizeRecord &&
                            !element.hasAttribute('no-resize-column') &&
                            !element.hasAttribute('no-resize-record')
                        ) {
                            // add a four-way arrow cursor
                            element.elems.dataViewport
                                .classList.add('table-cursor-all-resize');

                        // else if the mouse is over a column handle point
                        } else if (
                            element.internalResize.resizeColumn &&
                            !element.hasAttribute('no-resize-column')
                        ) {
                            // add a two-way horizontal arrow cursor
                            element.elems.dataViewport
                                .classList.add('table-cursor-col-resize');

                        // else if the mouse is over a record handle point
                        } else if (
                            element.internalResize.resizeRecord &&
                            !element.hasAttribute('no-resize-record')
                        ) {
                            // add a two-way vertical arrow cursor
                            element.elems.dataViewport
                                .classList.add('table-cursor-row-resize');
                        }

                        //console.log('X:' + intMouseX, 'Y:' + intMouseY);

                        element.internalResize.showThrottleID = null;
                    },
                    20  // 2 hundredths of a second, this is to prevent a really
                        //      quick selection from accidentally becoming a
                        //      resize because the user unintentionally hovered
                        //      over the resize area
                );
            };

            // we don't want a whole lot of elements for our drag handles, so
            //      instead we'll detect if the mouse is in the correct spot for
            //      a drag, if it is then we'll insert a drag element (so that
            //      we can change the cursor). This also makes it so that we can
            //      do a different cursor for column resizing, row resizing and
            //      column/row resizing.
            // when mouse is 1 or less away pixels away from a cell and/or
            //      record border: insert drag element
            element.internalEvents.cellResizeStarter = function (event) {
                var strUserAgent = window.navigator.userAgent;

                // this code only needs to run when the mouse is up. we don't
                //      want to be calculating this every mousemove during a
                //      cell selection
                // we also don't want to run this code if we are currently
                //      resizing cells already
                // we also don't want to run this code if we are currently
                //      reordering columns
                if (
                    (
                        (
                            (
                                strUserAgent.indexOf("Edge") > -1 ||
                                strUserAgent.indexOf("Firefox") > -1
                            ) &&
                            event.which === 1
                        ) ||
                        (
                            (
                                strUserAgent.indexOf("Edge") === -1 ||
                                strUserAgent.indexOf("Firefox") > -1
                            ) &&
                            event.which === 0
                        )
                    ) &&
                    element.internalResize.currentlyResizing !== true &&
                    element.internalResize.currentlyReordering !== true
                ) {
                    // remove the column handle
                    if (
                        element.elems.handleColumn.parentNode ===
                            element.elems.dataViewport
                    ) {
                        element.elems.dataViewport
                            .removeChild(element.elems.handleColumn);
                    }

                    // remove the record handle
                    if (
                        element.elems.handleRecord.parentNode ===
                            element.elems.dataViewport
                    ) {
                        element.elems.dataViewport
                            .removeChild(element.elems.handleRecord);
                    }

                    // clear any classes that affect the cursor (that were
                    //      placed there by the cell resize code)
                    element.elems.dataViewport
                        .classList.remove('table-cursor-all-resize');
                    element.elems.dataViewport
                        .classList.remove('table-cursor-col-resize');
                    element.elems.dataViewport
                        .classList.remove('table-cursor-row-resize');

                    // show any handles we're over (THROTTLED FUNCTION)
                    showHandles(event);
                } else {
                    // cancel throttled execution of showHandles
                    if (element.internalResize.showThrottleID !== null) {
                        clearTimeout(element.internalResize.showThrottleID);
                        element.internalResize.showThrottleID = null;
                    }
                }
            };

            element.elems.dataViewport.addEventListener(
                evt.mousemove,
                element.internalEvents.cellResizeStarter
            );

            // when dragging, just show a line where you'll resize to, instead
            //      of changing the size and re-rendering multiple times in a
            //      row
            element.internalEvents.cellResizeDragStart = function () {
                var recordSelectorVisible;
                var headerVisible;
                //var insertRecordVisible;
                var intColumnHandle;
                var intRecordHandle;

                // we need to let everything know that we are resizing cells,
                //      this is used to prevent cell selection during cell
                //      resize
                element.internalResize.currentlyResizing = true;

                // there are some things in the drag end code that we only want
                //      to run if the mouse has moved (and therefore started
                //      resizing), so here we default the resizeStarted to false
                //      and after mousemove it'll be set to true
                element.internalResize.resizeStarted = false;

                // we need to know the record/column indexes at this stage and
                //      store them internally

                // reset column and row index variables
                element.internalResize.resizeColumnIndex = null;
                element.internalResize.resizeRecordIndex = null;
                element.internalResize.resizingRecordSelectors = false;
                element.internalResize.resizingHeader = false;
                element.internalResize.resizingInsert = false;

                // to get the record/column indexes, we need to know what's
                //      visible
                recordSelectorVisible = (
                    element.internalDisplay.recordSelectorVisible
                );
                headerVisible = (
                    element.internalDisplay.headerVisible
                );
                //insertRecordVisible = (
                //    element.internalDisplay.insertRecordVisible
                //);

                // if we're resizing a column, get column index or type
                if (element.internalResize.resizeColumn) {
                    // to get the record/column indexes, we need to know what
                    //      handles we're using
                    intColumnHandle = (
                        element.internalResize.resizeColumnHandleIndex
                    );

                    // if the column handle was the first one and the record
                    //      selector is visible, we need to update the record
                    //      selector width
                    if (
                        intColumnHandle === 0 &&
                        recordSelectorVisible === true
                    ) {
                        element.internalResize.resizingRecordSelectors = true;

                    // else, we are updating a column width
                    } else {
                        element.internalResize.resizeColumnIndex = (
                            // to get the column number, start with the handle
                            //      index
                            intColumnHandle +
                            // the handle index is relative to the visible
                            //      column range, so add the fromColumn of the
                            //      current range
                            element.internalDisplay.currentRange.fromColumn
                        ) - (
                            // if the record selector is visible, the column
                            //      handle index is going to be offset by one
                            //      because there is a handle to resize the
                            //      record selectors
                            recordSelectorVisible
                                ? 1
                                : 0
                        );
                    }
                }

                // if we're resizing a record, get record index or type
                if (element.internalResize.resizeRecord) {
                    // to get the record/column indexes, we need to know what
                    //      handles we're using
                    intRecordHandle = (
                        element.internalResize.resizeRecordHandleIndex
                    );

                    // if the record handle was the first one and the header
                    //      is visible, we need to update the header height
                    if (intRecordHandle === 0 && headerVisible === true) {
                        element.internalResize.resizingHeader = true;
                    }
                    //// if the record handle was the last one and the insert
                    ////      record is visible, we need to update the insert
                    ////      record height
                    //} else if (
                    //    intRecordHandle === (
                    //        element.internalDisplay.recordHandles.length - 1
                    //    ) &&
                    //    insertRecordVisible === true
                    //) {
                    //    element.internalResize.resizingInsert = true;
                    //
                    //} else {
                    //    element.internalResize.resizeRecordIndex = (
                    //        // to get the record number, start with the handle
                    //        //      index
                    //        intRecordHandle +
                    //        // the handle index is relative to the visible
                    //        //      record range, so add the fromRecord of the
                    //        //      current range
                    //        element.internalDisplay.currentRange.fromRecord
                    //    ) - (
                    //        // if the header is visible, the column
                    //        //      handle index is going to be offset by one
                    //        //      because there is a handle to resize the
                    //        //      header
                    //        headerVisible
                    //            ? 1
                    //            : 0
                    //    );
                    //}
                }

                // save original scroll location so that if the viewport is
                //      scrolled during a resize, we can do an accurate resize
                element.internalResize.scrollOriginTop = (
                    element.internalScroll.displayTop
                );
                element.internalResize.scrollOriginLeft = (
                    element.internalScroll.displayLeft
                );

                // we need to bind the mousemove and mouseup functionality to
                //      the body so that we can still use the mouse events even
                //      if the mouse is no longer over the gs-table
                document.body.addEventListener(
                    evt.mousemove,
                    element.internalEvents.cellResizeDragMove
                );
                document.body.addEventListener(
                    evt.mouseup,
                    element.internalEvents.cellResizeDragEnd
                );
            };

            // there are multiple places where we want to update the position of
            //      the resize lines
            setLineToMouse = function (event) {
                var jsnMousePos;
                var jsnElementPos;
                var intMouseX;
                var intMouseY;
                var viewportWidth;
                var viewportHeight;
                var cellOriginX;
                var cellOriginY;
                var intMaxAllColWidth;
                var intMaxRowHeight;
                var intMinColWidth;

                var intOriginScrollTop;
                var intOriginScrollLeft;
                var intCurrentScrollTop;
                var intCurrentScrollLeft;

                var intNewWidth;
                var intNewHeight;
                var intNewX;
                var intNewY;

                var intTopBoundery;

                // we need to know the origin and current scroll location in
                //      order to accurately place the resize handle
                intOriginScrollTop = (element.internalResize.scrollOriginTop);
                intOriginScrollLeft = (element.internalResize.scrollOriginLeft);
                intCurrentScrollTop = (element.internalScroll.displayTop);
                intCurrentScrollLeft = (element.internalScroll.displayLeft);

                // we need the mouse position and the element position
                jsnMousePos = GS.mousePosition(event);
                jsnElementPos = GS.getElementOffset(
                    element.elems.dataViewport
                );

                // we need to show the user where they'll be resizing to.
                //      so, move the column resize handle to where the
                //      mouse is.
                if (element.internalResize.resizeColumn) {
                    // because we've started the resize, we want the column
                    //      handle to become visible. we'll add the "active"
                    //      class.
                    element.elems.handleColumn.classList.add('active');

                    // we need the mouse X to be relative to the dataViewport
                    intMouseX = (jsnMousePos.left - jsnElementPos.left);

                    // we need to know the maximum column width
                    intMaxAllColWidth = (
                        element.internalDisplay.maxColumnWidth
                    );

                    // we need to know the minimum column width
                    intMinColWidth = (
                        element.internalDisplay.minColumnWidths[
                            element.internalResize.resizeColumnIndex
                        ]
                    );

                    // we need to know the original X of the column we're
                    //      resizing
                    cellOriginX = element.internalResize.cellOriginX;

                    // we need to know the viewport width
                    viewportWidth = element.elems.dataViewport.clientWidth;

                    // we need to calculate the distance from the original X
                    //      to the new X and then move the new X to an
                    //      appropriate location

                    // we need a width variable separate from the mouse, this'll
                    //      contain the new width and will be adjusted to
                    //      prevent width issues
                    intNewWidth = (
                        // the new true X
                        (intMouseX + intCurrentScrollLeft) -
                        // subtracted by the old true X
                        (cellOriginX + intOriginScrollLeft)
                    );

                    // prevent width from going negative the user can't see
                    //      it and shouldn't be able to resize to it
                    if (intNewWidth < 0) {
                        intNewWidth = 0;
                    }

                    // prevent width from going past the max width of the
                    //      viewport the scrolling always keeps the column
                    //      left to the left side of the viewport, so we
                    //      dont want to make the column bigger than the
                    //      viewport
                    if (intNewWidth > (viewportWidth - 10)) {
                        intNewWidth = (viewportWidth - 10);
                    }

                    // prevent column from going wider than max column width
                    if (intNewWidth > intMaxAllColWidth) {
                        intNewWidth = intMaxAllColWidth;
                    }

                    // prevent column from being thinner than 10px
                    if (intNewWidth < 10) {
                        intNewWidth = 10;
                    }

                    // prevent column from being thinner minimum column width
                    if (intNewWidth < intMinColWidth) {
                        intNewWidth = intMinColWidth;
                    }

                    // determine new handle X from new width
                    intNewX = (
                        // the new right side
                        (
                            cellOriginX +
                            intOriginScrollLeft +
                            intNewWidth
                        ) -
                        // subtracted by the new scrollLeft
                        (
                            intCurrentScrollLeft
                        )
                    );

                    // refresh handle location
                    element.elems.handleColumn.style.left = (intNewX) + 'px';

                    // save the last X so that the mouseup code doesn't need
                    //      to figure that out
                    element.internalResize.lastX = intNewX;

                    // save the last width so that we don't have to recalculate
                    //      it when the user let's go of the mouse
                    element.internalResize.lastWidth = intNewWidth;
                }

                // we need to show the user where they'll be resizing to.
                //      so, move the record resize handle to where the
                //      mouse is.
                if (element.internalResize.resizeRecord) {
                    // because we've started the resize, we want the record
                    //      handle to become visible. we'll add the "active"
                    //      class.
                    element.elems.handleRecord.classList.add('active');

                    // we need the mouse Y to be relative to the dataViewport
                    intMouseY = (jsnMousePos.top - jsnElementPos.top);

                    // we need to know the maximum record height
                    intMaxRowHeight = (
                        element.internalDisplay.maxRecordHeight
                    );

                    // we need to know the original Y of the record we're
                    //      resizing
                    cellOriginY = element.internalResize.cellOriginY;

                    // we need to know the viewport height
                    viewportHeight = element.elems.dataViewport.clientHeight;

                    // we need to calculate the distance from the original Y
                    //      to the new Y and then move the new Y to an
                    //      appropriate location

                    // we need a height variable separate from the mouse,
                    //      this'll contain the new height and will be
                    //      adjusted to prevent height issues
                    if (element.internalResize.resizingInsert) {
                        intNewHeight = (
                            viewportHeight -
                            intMouseY
                        );

                    } else {
                        intNewHeight = (
                            // the new true Y
                            (intMouseY + intCurrentScrollTop) -
                            // subtracted by the old true Y
                            (cellOriginY + intOriginScrollTop)
                        );
                    }

                    // prevent Y from going past 0,0 on the viewport
                    // the user can't see it and shouldn't be resize to it
                    if (intNewHeight < 0) {
                        intNewHeight = 0;
                    }

                    // prevent Y from going past the max Y of the viewport
                    // the user can't see it and shouldn't be resize to it
                    intTopBoundery = (
                        viewportHeight - (
                            element.internalScrollOffsets.top + 10
                        )
                    );

                    if (intNewHeight > intTopBoundery) {
                        intNewHeight = intTopBoundery;
                    }

                    // if we're not resizing the insert record
                    // prevent record from going taller than max record height
                    if (
                        !element.internalResize.resizingInsert &&
                        intNewHeight > intMaxRowHeight
                    ) {
                        intNewHeight = intMaxRowHeight;
                    }

                    // the user can't resize a record to less than 10px height
                    if (intNewHeight < 10) {
                        intNewHeight = 10;
                    }

                    // determine new handle Y from new height
                    if (element.internalResize.resizingInsert) {
                        intNewY = (
                            viewportHeight -
                            intNewHeight
                        );

                    } else {
                        intNewY = (
                            // the new right side
                            (
                                cellOriginY +
                                intOriginScrollTop +
                                intNewHeight
                            ) -
                            // subtracted by the new scrollLeft
                            (
                                intCurrentScrollTop
                            )
                        );
                    }

                    element.elems.handleRecord.style.top = (intNewY) + 'px';

                    // save the last Y so that the mouseup code doesn't need
                    //      to figure that out
                    element.internalResize.lastY = intNewY;

                    // save the last height so that we don't have to recalculate
                    //      it when the user let's go of the mouse
                    element.internalResize.lastHeight = intNewHeight;
                }
            };

            element.internalEvents.cellResizeDragMove = function (event) {
                var jsnMousePos;
                var jsnElementPos;
                var bolScrollTop;
                var bolScrollLeft;
                var bolScrollRight;
                var bolScrollBottom;
                //var intViewportWidth;
                //var intViewportHeight;
                var colIndex;
                var rowIndex;
                var jsnRange;
                var strScrollDirection;

                // if the mouse moves off of the screen and then is moused up,
                //      we wont know it. so, if the mouse is up (and we're not
                //      on a touch device): preventDefault, stopPropagation and
                //      end the drag session
                if (event.which === 0 && !evt.touchDevice) {
                    event.preventDefault();
                    event.stopPropagation();
                    element.internalEvents.cellResizeDragEnd();

                } else {
                    // the resize has started, update resizeStarted to true so
                    //      that the drag end code knows that a change will be
                    //      made
                    element.internalResize.resizeStarted = true;

                    // we need to know the mouse position and the position of
                    //      the gs-table so that we can do calculations relative
                    //      to the gs-table element
                    jsnMousePos = GS.mousePosition(event);
                    jsnElementPos = GS.getElementOffset(
                        element.elems.dataViewport
                    );

                    //// convenience variables
                    //intViewportWidth = element.elems.dataViewport.clientWidth;
                    //intViewportHeight = (
                    //    element.elems.dataViewport.clientHeight
                    //);

                    // we need to know the column and/or row
                    //      number we are resizing from
                    colIndex = element.internalResize.resizeColumnIndex;
                    rowIndex = element.internalResize.resizeRecordIndex;

                    // we need to know the current visible range of cells
                    jsnRange = (
                        element.internalDisplay.currentRange
                    );

                    // find out what directions to scroll
                    bolScrollTop = (
                        jsnMousePos.top < (
                            // the mouse position is relative to the window
                            //      so we need to account for the left
                            //      offset of the gs-table element
                            jsnElementPos.top +
                            // anything we stick to the left cannot be ordered
                            //      to, so start scrolling at the right side of
                            //      the left offset
                            element.internalScrollOffsets.top
                        )
                    );
                    bolScrollLeft = (
                        jsnMousePos.left < (
                            // the mouse position is relative to the window
                            //      so we need to account for the left
                            //      offset of the gs-table element
                            jsnElementPos.left +
                            // anything we stick to the left cannot be ordered
                            //      to, so start scrolling at the right side of
                            //      the left offset
                            element.internalScrollOffsets.left
                        )
                    );
                    bolScrollRight = (
                        jsnMousePos.left > (
                            (
                                // the mouse position is relative to the window
                                //      so we need to account for the left
                                //      offset of the gs-table element
                                jsnElementPos.left +
                                // we want the right side so we need to take
                                //      into account the width of the gs-table
                                element.elems.dataViewport.clientWidth
                            ) -
                            // anything we stick to the right cannot be ordered
                            //      to, so start scrolling at the beginning of
                            //      the right offset
                            element.internalScrollOffsets.right
                        )
                    );
                    bolScrollBottom = (
                        jsnMousePos.top > (
                            (
                                // the mouse position is relative to the window
                                //      so we need to account for the top
                                //      offset of the gs-table element
                                jsnElementPos.top +
                                // we want the bottom side so we need to take
                                //      into account the height of the gs-table
                                element.elems.dataViewport.clientHeight
                            ) -
                            // anything we stick to the bottom cannot be resized
                            //      past, so start scrolling at the beginning of
                            //      the bottom offset
                            element.internalScrollOffsets.bottom
                        )
                    );

                    // you can't scroll vertically when you're not
                    //      resizing a record
                    if (!element.internalResize.resizeRecord) {
                        bolScrollTop = false;
                        bolScrollBottom = false;
                    }

                    // you can't scroll horizontally when you're not
                    //      resizing a column
                    if (!element.internalResize.resizeColumn) {
                        bolScrollLeft = false;
                        bolScrollRight = false;
                    }

                    // you can't scroll horizontally when you're
                    //      resizing the record selectors
                    if (element.internalResize.resizingRecordSelectors) {
                        bolScrollLeft = false;
                        bolScrollRight = false;
                    }

                    // you can't scroll vertically when you're
                    //      resizing the header or the insert record
                    if (
                        element.internalResize.resizingHeader ||
                        element.internalResize.resizingInsert
                    ) {
                        bolScrollTop = false;
                        bolScrollBottom = false;
                    }

                    // if we are scrolling up and the initial
                    //      record is the last visible record
                    //      (or second last)
                    if (
                        bolScrollTop &&
                        rowIndex === jsnRange.toRecord
                    ) {
                        bolScrollTop = false;
                    }

                    // if we're scrolling left and the initial
                    //      column is the last visible column
                    if (
                        bolScrollLeft &&
                        colIndex === jsnRange.toColumn
                    ) {
                        bolScrollLeft = false;
                    }

                    // if we're scrolling down and the initial
                    //      record is the first visible record
                    if (
                        bolScrollBottom &&
                        rowIndex === jsnRange.fromRecord
                    ) {
                        bolScrollBottom = false;
                    }

                    // if we're scrolling to the right and the
                    //      initial column is the first visible
                    //      column
                    if (
                        bolScrollRight &&
                        colIndex === jsnRange.fromColumn
                    ) {
                        bolScrollRight = false;
                    }

                    //console.log(
                    //    'X:' + jsnMousePos.left,
                    //    'Y:' + jsnMousePos.top,
                    //    bolScrollTop,
                    //    bolScrollLeft,
                    //    bolScrollRight,
                    //    bolScrollBottom
                    //);

                    // if the mouse is to the side of the viewport and scrolling
                    //      hasn't been started already: we want to start
                    //      scrolling on a timer
                    if (
                        (
                            bolScrollTop ||
                            bolScrollLeft ||
                            bolScrollRight ||
                            bolScrollBottom
                        ) &&
                        !element.internalScroll.dragScrolling
                    ) {
                        // start scroll
                        dragScrollStart(
                            element,
                            // drag move callback
                            function () {
                                var bolOldScrollTop;
                                var bolOldScrollLeft;
                                var bolOldScrollBottom;
                                var bolOldScrollRight;

                                // the scroll direction could be changed
                                //      anytime, we need to make sure we're
                                //      up to date
                                strScrollDirection = (
                                    element.internalScroll
                                        .dragScrollingDirection
                                );
                                bolScrollTop = (
                                    strScrollDirection.indexOf('top') !== -1
                                );
                                bolScrollLeft = (
                                    strScrollDirection.indexOf('left') !== -1
                                );
                                bolScrollBottom = (
                                    strScrollDirection.indexOf('bottom') !== -1
                                );
                                bolScrollRight = (
                                    strScrollDirection.indexOf('right') !== -1
                                );

                                // we want to know if a scroll direction was
                                //      changed, so we'll save the old scroll
                                //      booleans
                                bolOldScrollTop = bolScrollTop;
                                bolOldScrollLeft = bolScrollLeft;
                                bolOldScrollBottom = bolScrollBottom;
                                bolOldScrollRight = bolScrollRight;

                                // we need the user to see where the column or
                                //      row will be resized to
                                setLineToMouse(event);

                                // we need to know the current visible range
                                //      of cells
                                jsnRange = (
                                    element.internalDisplay.currentRange
                                );

                                //console.log(
                                //    bolScrollTop,
                                //    rowIndex,
                                //    jsnRange.toRecord
                                //);
                                //console.log(
                                //    bolScrollLeft,
                                //    colIndex,
                                //    jsnRange.toColumn
                                //);
                                //console.log(
                                //    bolScrollBottom,
                                //    rowIndex,
                                //    jsnRange.fromRecord
                                //);
                                //console.log(
                                //    bolScrollRight,
                                //    colIndex,
                                //    jsnRange.fromColumn
                                //);

                                // if we are scrolling up and the initial
                                //      record is the last visible record
                                //      (or second last)
                                if (
                                    bolScrollTop &&
                                    rowIndex === jsnRange.toRecord
                                ) {
                                    bolScrollTop = false;
                                }

                                // if we're scrolling left and the initial
                                //      column is the last visible column
                                if (
                                    bolScrollLeft &&
                                    colIndex === jsnRange.toColumn
                                ) {
                                    bolScrollLeft = false;
                                }

                                // if we're scrolling down and the initial
                                //      record is the first visible record
                                if (
                                    bolScrollBottom &&
                                    rowIndex === jsnRange.fromRecord
                                ) {
                                    bolScrollBottom = false;
                                }

                                // if we're scrolling to the right and the
                                //      initial column is the first visible
                                //      column
                                if (
                                    bolScrollRight &&
                                    colIndex === jsnRange.fromColumn
                                ) {
                                    bolScrollRight = false;
                                }

                               //console.log(
                               //    'bolScrollTop: ' + bolScrollTop
                               //);
                               //console.log(
                               //    'bolScrollLeft: ' + bolScrollLeft
                               //);
                               //console.log(
                               //    'bolScrollBottom: ' + bolScrollBottom
                               //);
                               //console.log(
                               //    'bolScrollRight: ' + bolScrollRight
                               //);

                                // if a scroll direction was stopped
                                if (
                                    bolScrollTop !== bolOldScrollTop ||
                                    bolScrollLeft !== bolOldScrollLeft ||
                                    bolScrollBottom !== bolOldScrollBottom ||
                                    bolScrollRight !== bolOldScrollRight
                                ) {
                                    // if there are any scroll directions left,
                                    //      restart scrolling in that direction
                                    if (
                                        bolScrollTop ||
                                        bolScrollLeft ||
                                        bolScrollRight ||
                                        bolScrollBottom
                                    ) {
                                        // reset scrolling direction
                                        element.internalScroll
                                            .dragScrollingDirection = (
                                                (
                                                    bolScrollTop
                                                        ? 'top'
                                                        : ''
                                                ) +
                                                (
                                                    bolScrollLeft
                                                        ? 'left'
                                                        : ''
                                                ) +
                                                (
                                                    bolScrollRight
                                                        ? 'right'
                                                        : ''
                                                ) +
                                                (
                                                    bolScrollBottom
                                                        ? 'bottom'
                                                        : ''
                                                )
                                            );
                                    } else {
                                        //console.log('RESIZE SCROLL STOPPED');
                                        dragScrollEnd(element);
                                    }
                                }

                                //element.internalResize.lastY
                                //element.internalResize.lastX
                                //element.internalResize.lastWidth
                                //element.internalResize.lastHeight
                                //dragScrollEnd(element);
                            },
                            (
                                (
                                    bolScrollTop
                                        ? 'top'
                                        : ''
                                ) +
                                (
                                    bolScrollLeft
                                        ? 'left'
                                        : ''
                                ) +
                                (
                                    bolScrollRight
                                        ? 'right'
                                        : ''
                                ) +
                                (
                                    bolScrollBottom
                                        ? 'bottom'
                                        : ''
                                )
                            )
                        );

                    // else if the scrolling has started and there are
                    //      directions we want to scroll
                    } else if (
                        element.internalScroll.dragScrolling &&
                        (
                            bolScrollTop ||
                            bolScrollLeft ||
                            bolScrollRight ||
                            bolScrollBottom
                        )
                    ) {
                        strScrollDirection = (
                            element.internalScroll.dragScrollingDirection
                        );

                        // if there is a direction that we want to scroll but
                        //      aren't scrolling right now, we need to add that
                        //      direction to the scroll direction
                        if (
                            bolScrollTop &&
                            strScrollDirection.indexOf('top') === -1
                        ) {
                            strScrollDirection += 'top';
                        }
                        if (
                            bolScrollLeft &&
                            strScrollDirection.indexOf('left') === -1
                        ) {
                            strScrollDirection += 'left';
                        }
                        if (
                            bolScrollRight &&
                            strScrollDirection.indexOf('right') === -1
                        ) {
                            strScrollDirection += 'right';
                        }
                        if (
                            bolScrollBottom &&
                            strScrollDirection.indexOf('bottom') === -1
                        ) {
                            strScrollDirection += 'bottom';
                        }

                        //console.log(
                        //    '1***',
                        //    strScrollDirection,
                        //    element.internalScroll.dragScrollingDirection
                        //);

                        // if we added a scroll direction, update the internal
                        //      storage
                        if (
                            strScrollDirection !==
                                element.internalScroll.dragScrollingDirection
                        ) {
                            //console.log(
                            //    '2***',
                            //    strScrollDirection,
                            //    element.internalScroll.dragScrollingDirection
                            //);
                            element.internalScroll.dragScrollingDirection = (
                                strScrollDirection
                            );
                        }

                        //console.log(
                        //    '3***',
                        //    strScrollDirection,
                        //    element.internalScroll.dragScrollingDirection
                        //);

                    // else if the mouse is NOT to the side of the viewport and
                    //      the scrolling has been started: we want to stop
                    //      scrolling
                    } else if (
                        !bolScrollTop &&
                        !bolScrollLeft &&
                        !bolScrollRight &&
                        !bolScrollBottom &&
                        element.internalScroll.dragScrolling
                    ) {
                        // stop scroll
                        dragScrollEnd(element);
                    }

                    // we need the user to see where the column or row will be
                    //      resized to
                    setLineToMouse(event);
                }
            };

            element.internalEvents.cellResizeDragEnd = function () {
                var intNew;
                var intIndex;
                var i;
                var len;
                var arrRecordHeights;
                var jsnDis;
                var resizeCols = [];
                var selectedBroken = false;

                if (element.internalSelection.rows[0] === 'header') {
                    if (element.internalSelection.ranges.length > 0) {
                        var jsnFirstRange = (
                            element.internalSelection.ranges[0]
                        );
                        var intSelectionLength;
                        var strStartColumn = jsnFirstRange.start.column;
                        var strEndColumn = jsnFirstRange.end.column;
                        var intStartColumn = parseInt(
                            (
                                strStartColumn === 'selector'
                                    ? 0
                                    : strStartColumn
                            ),
                            10
                        );
                        var intEndColumn = parseInt(
                            (
                                strEndColumn === 'selector'
                                    ? 0
                                    : strEndColumn
                            ),
                            10
                        );

                        if (jsnFirstRange.start.row === 'header') {
                            if (
                                strStartColumn === 'selector' &&
                                strEndColumn === 'selector'
                            ) {
                                intSelectionLength = (
                                    element.internalSelection.columns.length - 2
                                );
                            } else if (intStartColumn > intEndColumn) {
                                selectedBroken = true;
                                intSelectionLength = (
                                    (intStartColumn + 1) - intEndColumn
                                );
                            } else {
                                selectedBroken = false;
                                intSelectionLength = (
                                    (intEndColumn + 1) - intStartColumn
                                );
                            }
                            if (intSelectionLength === 0) {
                                intSelectionLength = 1;
                            }

                            i = 0;
                            while (i < intSelectionLength) {
                                if (selectedBroken) {
                                    resizeCols.push(i + intEndColumn);
                                } else {
                                    resizeCols.push(i + intStartColumn);
                                }

                                i += 1;
                            }
                        }
                    }
                }
                // nunzio commented this out on 2017-08-21
                //      because it was causing the datasheet
                //      to resize the selected columns even
                //      though the resized column was not selected
                //resizeCols.push(element.internalResize.resizeColumnIndex);
                //console.log(resizeCols);

                // if scrolling is running, stop it because we are done with
                //      the mouse part of the resize action
                if (element.internalScroll.dragScrolling) {
                    dragScrollEnd(element);
                }

                // because we've ended the resize, we want the column
                //      handle to become invisible. we'll remove the
                //      "active" class.
                element.elems.handleColumn.classList.remove('active');

                // because we've ended the resize, we want the record
                //      handle to become invisible. we'll remove the
                //      "active" class.
                element.elems.handleRecord.classList.remove('active');

                // if the column resize handle exists and was moved:
                //      apply column resize
                if (
                    element.internalResize.resizeColumn &&
                    element.internalResize.resizeStarted
                ) {
                    // calculate the new width based on the origin X and the
                    //      last X the mouse was at
                    intNew = (element.internalResize.lastWidth);

                    // if we're resizing the record selector column
                    if (element.internalResize.resizingRecordSelectors) {
                        element.internalDisplay.recordSelectorWidth = intNew;

                    // else, we are updating a column width
                    } else {
                        // get the index of the column that was resized
                        intIndex = (
                            element.internalResize.resizeColumnIndex
                        );

                        // we need to know the selected columns so that we can
                        //      check to see if the resized column was selected
                    //// arrSelectedColumns = element.internalSelection.columns;
                        //// arrSelectedColumns = (
                        ////     arrSelectedColumns.slice(
                        ////         arrSelectedColumns[0] === 'selector'
                        ////             ? 1
                        ////             : 0
                        ////     )
                        //// );

                        // convenience variable
                        jsnDis = (element.internalDisplay);

                        // if the column we resized was selected, resize any
                        //      columns that are selected and connected to it
                        if (resizeCols.indexOf(intIndex) > -1) {
                            i = 0;
                            len = resizeCols.length;
                            while (i < len) {
                                jsnDis.columnWidths[resizeCols[i]] = intNew;

                                // if the table has automatic column widths, we
                                //      need to set these so that the calculator
                                //      will know to treat this column as a
                                //      statically set column now.
                                jsnDis.setColumnWidths[resizeCols[i]] = intNew;
                                jsnDis.setMinColumnWidths[resizeCols[i]] = null;
                                jsnDis.columnRatios[resizeCols[i]] = null;

                                i += 1;
                            }
                        } else {
                            // set new width
                            jsnDis.columnWidths[intIndex] = intNew;

                            // if the table has automatic column widths, we need
                            //      to set these so that the calculator will
                            //      know to treat this column as a statically
                            //      set column now.
                            jsnDis.setColumnWidths[intIndex] = intNew;
                            jsnDis.setMinColumnWidths[intIndex] = null;
                            jsnDis.columnRatios[intIndex] = null;
                        }
                    }
                }

                // if the record resize handle exists and was moved:
                //      apply record resize
                if (
                    element.internalResize.resizeRecord &&
                    element.internalResize.resizeStarted
                ) {
                    // calculate the new height based on the origin Y and the
                    //      last Y the mouse was at
                    intNew = (element.internalResize.lastHeight);

                    // if we're resizing the header
                    if (element.internalResize.resizingHeader) {
                        element.internalDisplay.headerHeight = intNew;

                    //// if we're resizing the insert record
                    //} else if (element.internalResize.resizingInsert) {
                    //    element.internalDisplay.insertRecordHeight = intNew;

                    // else, resizing a regular row
                    } else {
                        // resize all records
                        arrRecordHeights = (
                            element.internalDisplay.recordHeights
                        );
                        i = 0;
                        len = arrRecordHeights.length;
                        while (i < len) {
                            arrRecordHeights[i] = intNew;
                            i += 1;
                        }

                        if (element.internalDisplay.insertRecordVisible) {
                            element.internalDisplay.insertRecordHeight = intNew;
                        }
                    }
                }

                // if a handle drag occured:
                if (element.internalResize.resizeStarted) {
                    // re-render so that the user can see the cells in their
                    //      new sizes
                    // we re-render the scroll dimensions because the cell
                    //      resize might affect the scroll width or height
                    renderScrollDimensions(element);
                }

                // we need to let everything know that we are no longer
                //      resizing cells
                element.internalResize.currentlyResizing = false;

                // unbind mousemove and mouseup
                document.body.removeEventListener(
                    evt.mousemove,
                    element.internalEvents.cellResizeDragMove
                );
                document.body.removeEventListener(
                    evt.mouseup,
                    element.internalEvents.cellResizeDragEnd
                );
            };

            // bind the same drag start to the record and column elements so
            //      that if either one is mousedown'ed on, the cell resize
            //      starts
            if (!element.hasAttribute('no-resize-column')) {
                element.elems.handleColumn.addEventListener(
                    evt.mousedown,
                    element.internalEvents.cellResizeDragStart
                );
            }
            if (!element.hasAttribute('no-resize-record')) {
                element.elems.handleRecord.addEventListener(
                    evt.mousedown,
                    element.internalEvents.cellResizeDragStart
                );
            }

            // we want to resize the selected records/columns back to their
            //      default sizes if the handle is double-clicked
            element.internalEvents.cellResizeToDefault = function () {
                //var intIndex;
                var intNew;
                var i;
                var len;
                var arrRecordHeights;
                var arrSelectedColumns;
                //var arrColumnWidths;
                //var arrColumns;

                // we need to be able to resize all selected records/columns,
                //      if the handle you double click touches a selected
                //      cell: resize all selected cells to default
                // ### NEED CODING ###

                // if the column resize handle exists: apply column resize
                if (element.internalResize.resizeColumn) {
                    // if the column handle was the first one and the record
                    //      selector is visible, we need to update the record
                    //      selector width
                    if (element.internalResize.resizingRecordSelectors) {
                        element.internalDisplay.recordSelectorWidth = (
                            element.internalDisplay.defaultRecordSelectorWidth
                        );

                    // else, we are updating a column width
                    } else {
                        //// get the index of the column that was resized
                        //intIndex = (
                        //    element.internalResize.resizeColumnIndex
                        //);

                        // we need to know the selected columns so that we can
                        //      check to see if the resized column was selected
                        // convenience variable
                        arrSelectedColumns = element.internalSelection.columns;
                        arrSelectedColumns = (
                            arrSelectedColumns.slice(
                                arrSelectedColumns[0] === 'selector'
                                    ? 1
                                    : 0
                            )
                        );

                        var colsToResize = [];
                        var selectedBroken = false;
                        var jsnFirstRange;
                        var strStartColumn;
                        var strEndColumn;
                        var intStartColumn;
                        var intEndColumn;
                        var intSelectionLength;

                        if (element.internalSelection.rows[0] === 'header') {
                            if (
                                element.internalSelection.ranges.length > 0
                            ) {
                                jsnFirstRange = (
                                    element.internalSelection.ranges[0]
                                );
                                strStartColumn = jsnFirstRange.start.column;
                                strEndColumn = jsnFirstRange.end.column;
                                intStartColumn = (
                                    parseInt(
                                        (
                                            strStartColumn === 'selector'
                                                ? 0
                                                : strStartColumn
                                        ),
                                        10
                                    )
                                );
                                intEndColumn = (
                                    parseInt(
                                        (
                                            strEndColumn === 'selector'
                                                ? 0
                                                : strEndColumn
                                        ),
                                        10
                                    )
                                );

                                if (jsnFirstRange.start.row === 'header') {
                                    if (
                                        strStartColumn === 'selector' &&
                                        strEndColumn === 'selector'
                                    ) {
                                        intSelectionLength = (
                                            element.internalSelection
                                                .columns
                                                .length - 2
                                        );
                                    } else if (intStartColumn > intEndColumn) {
                                        selectedBroken = true;
                                        intSelectionLength = (
                                            (intStartColumn + 1) - intEndColumn
                                        );
                                    } else {
                                        selectedBroken = false;
                                        intSelectionLength = (
                                            (intEndColumn + 1) - intStartColumn
                                        );
                                    }
                                    if (intSelectionLength === 0) {
                                        intSelectionLength = 1;
                                    }

                                    i = 0;
                                    while (i < intSelectionLength) {
                                        if (selectedBroken) {
                                            colsToResize.push(
                                                i + intEndColumn
                                            );
                                        } else {
                                            colsToResize.push(
                                                i + intStartColumn
                                            );
                                        }

                                        i += 1;
                                    }
                                }
                            }
                        }
                        // commented by nunzio on 2017-08-21
                        //      Same reason as in cellResizeDragEnd
                        //colsToResize.push(
                        //    element.internalResize.resizeColumnIndex
                        //);

                        //console.log(colsToResize);
                        if (colsToResize.indexOf(
                            element.internalResize.resizeColumnIndex
                        ) > 0) {
                            resizeColumnsToContent(element, colsToResize);
                        } else {
                            resizeColumnsToContent(element, [
                                element.internalResize.resizeColumnIndex
                            ]);
                        }

                        //// convenience variable
                        //arrColumnWidths = (
                        //    element.internalDisplay.columnWidths
                        //);

                        //// if the column we resized was seleced, resize any
                        ////      columns that are selected and connected to it
                        //if (arrSelectedColumns.indexOf(intIndex) > -1) {
                        //    arrColumns = (
                        //        getConnectedSelectedColumns(element, intIndex)
                        //    );

                        //    i = 0;
                        //    len = arrColumns.length;
                        //    while (i < len) {
                        //        arrColumnWidths[arrColumns[i]] = (
                        //            element.internalDisplay
                        //                .defaultColumnWidths[arrColumns[i]]
                        //        );
                        //        i += 1;
                        //    }
                        //} else {
                        //    // set new width
                        //    arrColumnWidths[intIndex] = (
                        //        element.internalDisplay
                        //            .defaultColumnWidths[intIndex]
                        //    );
                        //}
                    }
                }

                // if the record resize handle exists: apply record resize
                if (element.internalResize.resizeRecord) {
                    // if we double-clicked the header
                    if (element.internalResize.resizingHeader) {
                        element.internalDisplay.headerHeight = (
                            element.internalDisplay.defaultHeaderHeight
                        );

                    //// if we double-clicked the insert record
                    //} else if (element.internalResize.resizingInsert) {
                    //    element.internalDisplay.insertRecordHeight = (
                    //        element.internalDisplay.defaultInsertRecordHeight
                    //    );

                    } else {
                        // resize all records
                        intNew = (
                            element.internalDisplay.defaultRecordHeight
                        );
                        arrRecordHeights = (
                            element.internalDisplay.recordHeights
                        );
                        i = 0;
                        len = arrRecordHeights.length;
                        while (i < len) {
                            arrRecordHeights[i] = intNew;
                            i += 1;
                        }

                        if (element.internalDisplay.insertRecordVisible) {
                            element.internalDisplay.insertRecordHeight = (
                                element.internalDisplay
                                    .defaultInsertRecordHeight
                            );
                        }
                    }
                }

                // remove the handles from the viewport because a partial render
                //      doesn't remove them
                if (element.internalResize.resizeColumn) {
                    element.elems.dataViewport.removeChild(
                        element.elems.handleColumn
                    );
                }
                if (element.internalResize.resizeRecord) {
                    element.elems.dataViewport.removeChild(
                        element.elems.handleRecord
                    );
                }

                // re-render so that the user can see the cells in their new
                //      sizes
                // we re-render the scroll dimensions because the cell resize
                //      might affect the scroll width or height
                renderScrollDimensions(element);
            };

            // bind the same resize to default to the record and column handles
            //      so that if either one is double-clicked on, the cell resize
            //      is triggered
            if (!element.hasAttribute('no-resize-column')) {
                element.elems.handleColumn.addEventListener(
                    'dblclick',
                    element.internalEvents.cellResizeToDefault
                );
            }
            if (!element.hasAttribute('no-resize-record')) {
                element.elems.handleRecord.addEventListener(
                    'dblclick',
                    element.internalEvents.cellResizeToDefault
                );
            }
        }

        element.internalEvents.columnAutoResize = function () {
            renderScrollDimensions(element);
        };

        // If we're doing automatic column resize, we're going to want to
        //      recalculate the column widths on every gs-table resize.
        if (element.hasAttribute('column-auto-resize')) {
            window.addEventListener(
                'resize',
                element.internalEvents.columnAutoResize
            );
        }
    }

    // ############# COLUMN REORDER EVENTS #############
    function unbindColumnReorder(element) {
        if (!evt.touchDevice) {
            element.elems.dataViewport.removeEventListener(
                'mousedown',
                element.internalEvents.columnReorderDragStart
            );
        }
    }
    function bindColumnReorder(element) {
        var setLineToMouse;

        if (!evt.touchDevice) {
            // we want to take the mouse position and add a line to the closest
            //      column line, we do this on mousedown and on mousemove, so
            //      we'll create a function to handle that
            setLineToMouse = function (event) {
                var jsnMousePos;
                var jsnElementPos;
                var arrColumnHandles;
                var intMouse;
                var intPrevHandle;
                var intCurrentHandle;
                var intPrevIndex;
                var intCurrentIndex;
                var intHandleIndex;
                var intInsertionIndex;
                var i;
                var len;

                // we need the mouse position
                jsnMousePos = GS.mousePosition(event);

                // we need the element position because the mouse position is
                //      not relative to element
                jsnElementPos = GS.getElementOffset(
                    element.elems.dataViewport
                );

                // we need the locations where a column can be moved to
                arrColumnHandles = (
                    element.internalDisplay.columnHandles
                );

                // we need the mouse left position relative to the gs-table
                intMouse = (
                    jsnMousePos.left - jsnElementPos.left
                );

                // we need to find the correct insertion points
                if (
                    element.internalScroll.dragScrolling &&
                    element.internalScroll.dragScrollingDirection === 'left'
                ) {
                    // get first non-null handle
                    i = 0;
                    len = arrColumnHandles.length;
                    while (i < len) {
                        if (arrColumnHandles[i] !== null) {
                            intHandleIndex = i;
                            break;
                        }
                        i += 1;
                    }

                } else if (
                    element.internalScroll.dragScrolling &&
                    element.internalScroll.dragScrollingDirection === 'left'
                ) {
                    // get last non-null handle
                    i = (arrColumnHandles.length - 1);
                    while (i >= 0) {
                        if (arrColumnHandles[i] !== null) {
                            intHandleIndex = i;
                            break;
                        }
                        i -= 1;
                    }

                } else {
                    // we need to find out what handle the mouse is closest to
                    //      BEWARE, hidden columns have null as their handle.
                    //      we need to work around null column handles
                    intPrevHandle = null;
                    intCurrentHandle = null;
                    intPrevIndex = null;
                    intCurrentIndex = null;
                    intHandleIndex = null;
                    i = 0;
                    len = arrColumnHandles.length;
                    while (i < len) {
                        if (arrColumnHandles[i] !== null) {
                            intCurrentHandle = arrColumnHandles[i];
                            intCurrentIndex = i;
                        }

                        if (
                            intPrevHandle !== null &&
                            intCurrentHandle !== null
                        ) {
                            if (
                                intMouse >= intPrevHandle &&
                                intMouse <= intCurrentHandle
                            ) {
                                if (
                                    // if the mouse is closer to the right
                                    (intCurrentHandle - intMouse) <
                                        (intMouse - intPrevHandle)
                                ) {
                                    intHandleIndex = intCurrentIndex;

                                // else, the handle is the left handle
                                } else {
                                    intHandleIndex = intPrevIndex;
                                }
                            } else if (i === (len - 1)) {
                                if (intMouse >= intCurrentHandle) {
                                    intHandleIndex = intCurrentIndex;
                                } else {
                                    intHandleIndex = intPrevIndex;
                                }
                            }
                        } else if (
                            intCurrentHandle !== null &&
                            intMouse <= intCurrentHandle
                        ) {
                            intHandleIndex = intCurrentIndex;
                        }

                        if (intHandleIndex !== null) {
                            break;
                        }

                        if (intCurrentHandle !== null) {
                            intPrevHandle = intCurrentHandle;
                            intPrevIndex = intCurrentIndex;
                        }

                        i += 1;
                    }
                }

                // the handle list only contains the visible column
                //      list so, we have to add the first visible
                //      column's number to the handle index
                intInsertionIndex = (
                    intHandleIndex +
                    element.internalDisplay.currentRange.fromColumn
                );

                // sometimes, this function will be called while the reorder
                //      indicator is not in the DOM, if it isn't, append it to
                //      the dataViewport
                if (
                    element.elems.handleReorder.parentNode !==
                        element.elems.dataViewport
                ) {
                    element.elems.dataViewport.appendChild(
                        element.elems.handleReorder
                    );
                }

                // we need to update the position of the line
                element.elems.handleReorder.style.left = (
                    (
                        arrColumnHandles[intHandleIndex]
                    ) + 'px'
                );

                // we need to keep track of the drop location
                element.internalReorder.dropLocation = intInsertionIndex;
            };

            // when dragging, just show a line where you'll resize to, instead
            //      of changing the size and re-rendering multiple times in a
            //      row
            element.internalEvents.columnReorderDragStart = function (event) {
                var target;
                var parentCell;
                var intColNumber;
                var arrCurrentColumns;

                // we only want to reorder if the drag originates from a header
                //      cell that is selected
                target = event.target;
                if (parentCell && parentCell.nodeName !== 'GS-CELL') {
                    parentCell = GS.findParentElement(target, 'gs-cell');
                } else {
                    parentCell = target;
                }

                if (
                    parentCell &&
                    parentCell.nodeName === 'GS-CELL' &&
                    parentCell.classList.contains('table-header') &&
                    parentCell.hasAttribute('selected') &&
                    // only reorder when the left mouse button is down
                    event.which === 1
                ) {
                    // we need to let everything know that we are reordering,
                    //      this is used to prevent cell selection during column
                    //      reorder
                    element.internalReorder.currentlyReordering = true;

                    // there are some things in the drag end code that we only
                    //      want to run if the mouse has moved (and therefore
                    //      started reordering), so here we default the
                    //      reorderStarted to false and after mousemove it'll
                    //      be set to true
                    element.internalReorder.reorderStarted = false;

                    // we need to know what columns we're dragging, so we'll
                    //      take the column number and grab any column numbers
                    //      that are contiguous

                    // get number of the column we selected
                    intColNumber = parseInt(
                        parentCell.getAttribute('data-col-number'),
                        10
                    );
                    //console.log('column', intColNumber);

                    // clear current columns array so that we can start fresh
                    arrCurrentColumns = (
                        getConnectedSelectedColumns(element, intColNumber)
                    );

                    //console.log(arrSelection, arrCurrentColumns);

                    // we want the drag move and drag end functions to know what
                    //      columns are being reordered, so we'll save the array
                    //      to the internal storage
                    element.internalReorder.currentColumns = arrCurrentColumns;

                    // we want to know what column was the column that the user
                    //      initiated the drag on
                    element.internalReorder.originColumn = intColNumber;

                    // we want to know if a drop location was chosen, so we'll
                    //      clear out the old drop location and that way all
                    //      we'll have to do is test for null
                    element.internalReorder.dropLocation = null;

                    // sometimes, the user has other columns selected, let's
                    //      reset the selection to be the columns the user is
                    //      reordering
                    element.internalSelection.ranges = [
                        {
                            "start": {
                                "row": "header",
                                "column": arrCurrentColumns[0]
                            },
                            "end": {
                                "row": "header",
                                "column": arrCurrentColumns[
                                    arrCurrentColumns.length - 1
                                ]
                            },
                            "negator": false
                        }
                    ];

                    // re-render the select to show the user the change
                    renderSelection(element);

                    // we need the user to see where the column will be dropped
                    setLineToMouse(event);

                    // we need to bind the mousemove and mouseup functionality
                    //      to the body so that we can still use the mouse
                    //      events even if the mouse is no longer over the
                    //      gs-table
                    document.body.addEventListener(
                        evt.mousemove,
                        element.internalEvents.columnReorderDragMove
                    );
                    document.body.addEventListener(
                        evt.mouseup,
                        element.internalEvents.columnReorderDragEnd
                    );
                }
            };

            element.internalEvents.columnReorderDragMove = function (event) {
                var jsnMousePos;
                var jsnElementPos;
                var bolScrollLeft;
                var bolScrollRight;

                // if the mouse moves off of the screen and then is moused up,
                //      we wont know it. so, if the mouse is up (and we're not
                //      on a touch device): preventDefault, stopPropagation and
                //      end the drag session
                if (event.which === 0 && !evt.touchDevice) {
                    event.preventDefault();
                    event.stopPropagation();
                    element.internalEvents.columnReorderDragEnd();

                } else {
                    // the resize has started, update resizeStarted to true so
                    //      that the drag end code knows that a change will be
                    //      made
                    element.internalReorder.reorderStarted = true;

                    // we need to know the mouse position and the position of
                    //      the gs-table so that we can do calculations relative
                    //      to the gs-table element
                    jsnMousePos = GS.mousePosition(event);
                    jsnElementPos = GS.getElementOffset(
                        element.elems.dataViewport
                    );

                    // find out what directions to scroll
                    bolScrollLeft = (
                        jsnMousePos.left < (
                            // the mouse position is relative to the window
                            //      so we need to account for the left
                            //      offset of the gs-table element
                            jsnElementPos.left +
                            // anything we stick to the left cannot be ordered
                            //      to, so start scrolling at the right side of
                            //      the left offset
                            element.internalScrollOffsets.left
                        )
                    );
                    bolScrollRight = (
                        jsnMousePos.left > (
                            (
                                // the mouse position is relative to the window
                                //      so we need to account for the left
                                //      offset of the gs-table element
                                jsnElementPos.left +
                                // we want the right side so we need to take
                                //      into account the width of the gs-table
                                element.elems.dataViewport.clientWidth
                            ) -
                            // anything we stick to the right cannot be ordered
                            //      to, so start scrolling at the beginning of
                            //      the right offset
                            element.internalScrollOffsets.right
                        )
                    );

                    //console.log(
                    //    'X:' + intMouseX,
                    //    bolScrollLeft,
                    //    bolScrollRight
                    //);

                    // if the mouse is to the side of the viewport and scrolling
                    //      hasn't been started already: we want to start
                    //      scrolling on a timer
                    if (
                        (bolScrollLeft || bolScrollRight) &&
                        !element.internalScroll.dragScrolling
                    ) {
                        // start scroll
                        dragScrollStart(
                            element,
                            // drag move callback
                            function () {
                                // we need the user to see where the
                                //      column will be dropped
                                setLineToMouse(event);
                            },
                            (
                                bolScrollLeft
                                    ? 'left'
                                    : 'right'
                            )
                        );

                    // else if the mouse is NOT to the side of the viewport and
                    //      the scrolling has been started: we want to stop
                    //      scrolling
                    } else if (
                        !bolScrollLeft &&
                        !bolScrollRight &&
                        element.internalScroll.dragScrolling
                    ) {
                        // stop scroll
                        dragScrollEnd(element);
                    }

                    // we need the user to see where the column will be dropped
                    setLineToMouse(event);
                }
            };

            element.internalEvents.columnReorderDragEnd = function () {
                var arrOrderCols;
                var intDropIndex;
                var headerTemplate;
                var recordTemplate;
                var insertTemplate;
                var arrOldHeaderTemplate;
                var arrOldRecordTemplate;
                var arrOldInsertTemplate;
                var arrOldPlainText;
                var arrOldDataCol;
                var arrOldColWidths;
                var arrOldDefaultColWidths;
                var arrOldCopyHeaders;
                var arrOldCopyCol;
                var strNewHeaderTemplate;
                var strNewRecordTemplate;
                var strNewInsertTemplate;
                var arrNewPlainText;
                var arrNewDataCol;
                var arrNewColWidths;
                var arrNewDefaultColWidths;
                var arrNewCopyHeaders;
                var arrNewCopyCol;

                var i;
                var len;
                var intSeqIndex;
                var unmovedColumns;
                var pullIndex;

                var index;
                var strSort;
                var strColumn;
                var strOldSortOrder;
                var strNewSortOrder;

                // when reordering columns, we put a line into the viewport to
                //      indicate where the columns will be put. so, we need to
                //      remove the line
                if (
                    element.elems.handleReorder.parentNode ===
                        element.elems.dataViewport
                ) {
                    element.elems.dataViewport.removeChild(
                        element.elems.handleReorder
                    );
                }

                // if scrolling is running, stop it because we are done with
                //      the mouse part of the reorder action
                if (element.internalScroll.dragScrolling) {
                    dragScrollEnd(element);
                }

                // save drop index to a variable for convenience
                intDropIndex = (
                    element.internalReorder.dropLocation
                );

                // we need to know what columns we are moving to the
                //      drop index
                arrOrderCols = (
                    element.internalReorder.currentColumns
                );

                // if the user clicks instead of dragging, we'll select the
                //      column
                if (!element.internalReorder.reorderStarted) {
                    element.internalSelection.ranges = [
                        {
                            "start": {
                                // reorder functionality assumes the presence of
                                //      headers
                                "row": "header",
                                "column": element.internalReorder.originColumn
                            },
                            "end": {
                                // reorder functionality assumes the presence of
                                //      headers
                                "row": "header",
                                "column": element.internalReorder.originColumn
                            },
                            "negator": false
                        }
                    ];
                    renderSelection(element);
                }

                //console.log(
                //    'should we reorder?',
                //    element.internalReorder.reorderStarted,
                //    intDropIndex,
                //    arrOrderCols,
                //    arrOrderCols.length,
                //    element.internalDisplay.columnWidths.length
                //);
                if (
                    // if a drag occurred
                    element.internalReorder.reorderStarted &&
                    // and the drop index is not null, undefined or NaN
                    intDropIndex !== null &&
                    intDropIndex !== undefined &&
                    !isNaN(intDropIndex) &&
                    // and there are columns to order
                    arrOrderCols.length > 0 &&
                    // and the drop index is not past the max
                    intDropIndex <= (
                        element.internalDisplay.columnWidths.length
                    ) &&
                    // and the drop index is not at any of the indexes
                    //      the order columns are located at
                    arrOrderCols.indexOf(intDropIndex) === -1 &&
                    // and the drop index is not at the right side of
                    //      the last column in the order column list
                    arrOrderCols.indexOf(intDropIndex - 1) === -1
                ) {
                    // gotta reorder the templates, widths, and everything
                    //      else that we store about display columns

                    // here's the list of items to sort:
                    //      element.internalTemplates
                    //          header               <- element template
                    //          record               <- element template
                    //          insertRecord         <- element template
                    //      element.internalDisplay
                    //          columnPlainTextNames <- array
                    //          dataColumnName       <- array
                    //          columnWidths         <- array
                    //          defaultColumnWidths  <- array
                    //      element.internalClip
                    //          headerList           <- array
                    //          columnList           <- array


                    // we need to reorder the templates, in order to do
                    //      this we'll need access to their elements. the
                    //      templates are stored as strings and so we must
                    //      create template elements to put the content in
                    // put the template HTML into the template elements so
                    //      that we have access to the elements

                    if (element.internalTemplates.header) {
                        headerTemplate = document.createElement('template');
                        headerTemplate.innerHTML = (
                            element.internalTemplates.header
                        );
                        arrOldHeaderTemplate = (
                            tblQry(headerTemplate.content, 'gs-cell')
                        );
                    }

                    if (element.internalTemplates.originalRecord) {
                        recordTemplate = document.createElement('template');
                        recordTemplate.innerHTML = (
                            element.internalTemplates.originalRecord
                        );
                        arrOldRecordTemplate = (
                            tblQry(recordTemplate.content, 'gs-cell')
                        );
                    }

                    if (element.internalTemplates.originalInsertRecord) {
                        insertTemplate = document.createElement('template');
                        insertTemplate.innerHTML = (
                            element.internalTemplates.originalInsertRecord
                        );
                        arrOldInsertTemplate = (
                            tblQry(insertTemplate.content, 'gs-cell')
                        );
                    }

                    // gather column arrays for easy access
                    arrOldPlainText = (
                        element.internalDisplay.columnPlainTextNames
                    );
                    arrOldDataCol = (
                        element.internalDisplay.dataColumnName
                    );
                    arrOldColWidths = (
                        element.internalDisplay.columnWidths
                    );
                    arrOldDefaultColWidths = (
                        element.internalDisplay.defaultColumnWidths
                    );

                    if (
                        element.internalClip.headerList &&
                        element.internalClip.headerList.length > 0
                    ) {
                        arrOldCopyHeaders = (
                            element.internalClip.headerList
                        );
                    }

                    if (
                        element.internalClip.columnList &&
                        element.internalClip.columnList.length > 0
                    ) {
                        arrOldCopyCol = (
                            element.internalClip.columnList
                        );
                    }

                    // create new arrays to hold the sorted lists
                    strNewHeaderTemplate = '';
                    strNewRecordTemplate = '';
                    strNewInsertTemplate = '';
                    arrNewPlainText = [];
                    arrNewDataCol = [];
                    arrNewColWidths = [];
                    arrNewDefaultColWidths = [];
                    arrNewCopyHeaders = [];
                    arrNewCopyCol = [];

                    // now begins the sort

                    // because all of the display column arrays must be the same
                    //      length, we can use one loop for all of the arrays

                    // we're going to loop through the column arrays and build
                    //      up the new, sorted arrays/strings

                    //console.log('##########################################');
                    //console.log('##########################################');
                    //console.log('##########################################');
                    //console.log('old header:    ', arrOldHeaderTemplate);
                    //console.log('old record:    ', arrOldRecordTemplate);
                    //console.log('old insert:    ', arrOldInsertTemplate);
                    //console.log('old plainTXT:  ', arrOldPlainText);
                    //console.log('old dataName:  ', arrOldDataCol);
                    //console.log('old width:     ', arrOldColWidths);
                    //console.log('old def width: ', arrOldDefaultColWidths);
                    //console.log('##########################################');
                    //console.log('##########################################');
                    //console.log('##########################################');

                    // we need a sequential number that is not tied to "i"
                    intSeqIndex = 0;

                    // we need a consumable column list so that we'll know we've
                    //      moved everything once the column list is empty
                    unmovedColumns = arrOrderCols.slice(0);

                    i = 0;
                    len = arrOldColWidths.length;
                    while (i < len) {
                        // because we are sorting by appending elements from
                        //      various points in the old array to the end of
                        //      the new arrays/strings, we need to determine
                        //      what index we are pulling from the old arrays.
                        //      this index will not be sequential like "i" will
                        //      be.
                        // there are two possibilities:
                        //      we sort the columns to the left
                        //      we sort the columns to the right
                        // in the case of a left sort:
                        //      we need to be sequential until we reach the drop
                        //      index, in which case we need to read the indexes
                        //      of the arrOrderCols array sequentially and then
                        //      we go back to where we left off until we reach
                        //      the first arrOrderCols value, in which case we
                        //      need to jump to the column after the last column
                        //      in arrOrderCols and continue until we reach the
                        //      end
                        // in the case of a right sort:
                        //      we need to be sequential until we reach the
                        //      first column in arrOrderCols, in which case we
                        //      skip to the column after the last column in
                        //      arrOrderCols and continue from there until we
                        //      reach the drop index, in which case we need to
                        //      read the indexes of the arrOrderCols array
                        //      sequentially and then we go back to where we
                        //      left off until we reach the end

                        //console.log(
                        //    '1***',
                        //    intSeqIndex,
                        //    intDropIndex,
                        //    unmovedColumns,
                        //    arrOrderCols
                        //);
                        // if we have reached the drop index and there
                        //      are order columns left
                        if (
                            intSeqIndex === intDropIndex &&
                            unmovedColumns.length > 0
                        ) {
                            //console.log('2.1*');
                            // grab and remove first order column index
                            pullIndex = unmovedColumns.shift();

                        // if we have reached the first column of
                        //      arrOrderCols
                        } else if (intSeqIndex === arrOrderCols[0]) {
                            //console.log('2.2*');
                            intSeqIndex += (arrOrderCols.length);
                            pullIndex = intSeqIndex;
                            intSeqIndex += 1;

                        // else, continue through column list
                        } else {
                            //console.log('2.3*');
                            pullIndex = intSeqIndex;
                            intSeqIndex += 1;
                        }
                        //console.log('3***', pullIndex);

                        // make the append to the new arrays/strings
                        if (arrOldHeaderTemplate) {
                            strNewHeaderTemplate += (
                                arrOldHeaderTemplate[pullIndex].outerHTML
                            );
                        }
                        if (arrOldRecordTemplate) {
                            strNewRecordTemplate += (
                                arrOldRecordTemplate[pullIndex].outerHTML
                            );
                        }
                        if (arrOldInsertTemplate) {
                            strNewInsertTemplate += (
                                arrOldInsertTemplate[pullIndex].outerHTML
                            );
                        }
                        arrNewPlainText.push(
                            arrOldPlainText[pullIndex]
                        );
                        arrNewDataCol.push(
                            arrOldDataCol[pullIndex]
                        );
                        arrNewColWidths.push(
                            arrOldColWidths[pullIndex]
                        );
                        arrNewDefaultColWidths.push(
                            arrOldDefaultColWidths[pullIndex]
                        );
                        arrNewCopyHeaders.push(
                            arrOldCopyHeaders[pullIndex]
                        );
                        arrNewCopyCol.push(
                            arrOldCopyCol[pullIndex]
                        );

                        i += 1;
                    }

                    // there's a lot of stuff that has to happen, so we need a
                    //      lot of logging
                    //console.log('##########################################');
                    //console.log('##########################################');
                    //console.log('##########################################');
                    //console.log(
                    //    'reorder columns:',
                    //    arrOrderCols
                    //);
                    //console.log(
                    //    'to location:',
                    //    intDropIndex,
                    //    '(resolved location: ' + intResolvedDropIndex + ')'
                    //);
                    //console.log('##########################################');
                    //console.log('##########################################');
                    //console.log('##########################################');
                    //console.log('old header:    ', arrOldHeaderTemplate);
                    //console.log('new header:    ', strNewHeaderTemplate);

                    //console.log('old record:    ', arrOldRecordTemplate);
                    //console.log('new record:    ', strNewRecordTemplate);

                    //console.log('old insert:    ', arrOldInsertTemplate);
                    //console.log('new insert:    ', strNewInsertTemplate);

                    //console.log('old plainTXT:  ', arrOldPlainText);
                    //console.log('new plainTXT:  ', arrNewPlainText);

                    //console.log('old dataName:  ', arrOldDataCol);
                    //console.log('new dataName:  ', arrNewDataCol);

                    //console.log('old width:     ', arrOldColWidths);
                    //console.log('new width:     ', arrNewColWidths);

                    //console.log('old def width: ', arrOldDefaultColWidths);
                    //console.log('new def width: ', arrNewDefaultColWidths);
                    //console.log('##########################################');
                    //console.log('##########################################');
                    //console.log('##########################################');

                    // we need to update the column numbers inside the templates
                    //      to account for the sort, the column numbers are
                    //      important for partial re-render
                    if (arrOldHeaderTemplate) {
                        headerTemplate.innerHTML = strNewHeaderTemplate;
                        templateCellAddColumnNumber(headerTemplate);
                        strNewHeaderTemplate = headerTemplate.innerHTML;

                        // save the new header template so that the render
                        //      function uses it
                        element.internalTemplates.header = (
                            strNewHeaderTemplate
                        );
                    }

                    if (arrOldRecordTemplate) {
                        recordTemplate.innerHTML = strNewRecordTemplate;
                        templateCellAddColumnNumber(recordTemplate);
                        strNewRecordTemplate = recordTemplate.innerHTML;

                        // let's save the original record template text so
                        //      that we can modify it in the future
                        element.internalTemplates.originalRecord = (
                            strNewRecordTemplate
                        );

                        // save the new record template so that the render
                        //      function uses it
                        // we're going run the record template through a
                        //      function to turn all of the "column"
                        //      attributes into "value" attributes with
                        //      the proper templating
                        element.internalTemplates.record = (
                            GS.templateHideSubTemplates(
                                strNewRecordTemplate,
                                false // not a TR element
                            )
                        );
                    }

                    if (arrOldInsertTemplate) {
                        insertTemplate.innerHTML = strNewInsertTemplate;
                        templateCellAddColumnNumber(insertTemplate);
                        strNewInsertTemplate = insertTemplate.innerHTML;

                        // let's save the original insert record template text
                        //      so that we can modify it in the future
                        element.internalTemplates.originalInsertRecord = (
                            strNewInsertTemplate
                        );

                        // save the new record template so that the render
                        //      function uses it
                        // we're going run the record template through a
                        //      function to turn all of the "column"
                        //      attributes into "value" attributes with
                        //      the proper templating
                        element.internalTemplates.InsertRecord = (
                            GS.templateHideSubTemplates(
                                strNewInsertTemplate,
                                false // not a TR element
                            )
                        );
                    }

                    // save column arrays to internal storage
                    element.internalDisplay.columnPlainTextNames = (
                        arrNewPlainText
                    );
                    element.internalDisplay.dataColumnName = (
                        arrNewDataCol
                    );
                    element.internalDisplay.columnWidths = (
                        arrNewColWidths
                    );
                    element.internalDisplay.defaultColumnWidths = (
                        arrNewDefaultColWidths
                    );
                    if (arrOldCopyHeaders) {
                        element.internalClip.headerList = (
                            arrNewCopyHeaders
                        );
                    }
                    if (arrOldCopyCol) {
                        element.internalClip.columnList = (
                            arrNewCopyCol
                        );
                    }

                    // adjust selection to new column locations
                    // ### NEED CODING ###
                    // temp, clear select
                    element.internalSelection.ranges = [];

                    // sometimes, the user has sorted some columns. in this
                    //      case, we need to refresh the table

                    // here, we construct two strings representing the old
                    //      and new sort column orders, that way we can compare
                    //      them and refresh of they are different
                    strOldSortOrder = '';
                    strNewSortOrder = '';
                    i = 0;
                    len = arrOldDataCol.length;
                    while (i < len) {
                        if (arrOldDataCol[i]) {
                            strColumn = arrOldDataCol[i];

                            index = (
                                element.internalData.columnNames.indexOf(
                                    strColumn
                                )
                            );

                            strSort = element.internalData.columnOrders[index];

                            if (index > -1 && strSort !== 'neutral') {
                                strOldSortOrder += strColumn;
                            }
                        }
                        if (arrNewDataCol[i]) {
                            strColumn = arrNewDataCol[i];

                            index = (
                                element.internalData.columnNames.indexOf(
                                    strColumn
                                )
                            );

                            strSort = element.internalData.columnOrders[index];

                            if (index > -1 && strSort !== 'neutral') {
                                strNewSortOrder += strColumn;
                            }
                        }
                        i += 1;
                    }

                    //console.log(
                    //    '"' + strOldSortOrder + '"',
                    //    '"' + strNewSortOrder + '"'
                    //);

                    if (strOldSortOrder !== strNewSortOrder) {
                        dataSELECT(element);

                    // else, we can just re-render
                    } else {
                        // re-render so that the user can see the cells in their
                        //      new order
                        element.internalDisplay.fullRenderRequired = true;
                        renderScrollDimensions(element);
                    }
                }

                // we need to let everything know that we are no longer
                //      reordering columns
                element.internalReorder.currentlyReordering = false;

                // unbind mousemove and mouseup
                document.body.removeEventListener(
                    evt.mousemove,
                    element.internalEvents.columnReorderDragMove
                );
                document.body.removeEventListener(
                    evt.mouseup,
                    element.internalEvents.columnReorderDragEnd
                );
            };

            // bind the same drag start to the record and column elements so
            //      that if either one is mousedown'ed on, the cell resize
            //      starts
            if (!element.hasAttribute('no-column-reorder')) {
                element.elems.dataViewport.addEventListener(
                    'mousedown',
                    element.internalEvents.columnReorderDragStart
                );
            }
        }
    }

    // ############# UPDATE EVENTS #############
    function unbindUpdate(element) {
        element.removeEventListener(
            'change',
            element.internalEvents.cellUpdate
        );

        element.elems.dataViewport.removeEventListener(
            'click',
            element.internalEvents.updateDialog
        );
    }
    function bindUpdate(element) {
        element.internalEvents.cellUpdate = function (event) {
            var target;
            var columnElement;
            var cellElement;
            var newValue;
            var strColumn;
            var intRecord;

            // get event target and put it in a variable for clarity
            target = event.target;

            // we need the element (possibly a parent of "target") that has a
            //      "column" attribute so that we can get the name of the
            //      column that needs to be updated (if the "target" is the
            //      element with the "column" attribute: "findParentElement"
            //      will simply return the "target" as the result)
            columnElement = GS.findParentElement(target, '[column]');

            // we need the gs-cell parent so that we can verify that the change
            //      emanated from an updatable cell
            cellElement = GS.findParentElement(columnElement, 'gs-cell');

            // verify that this "columnElement" is an actual child of this
            //      gs-table and that it's an updatable cell and not an insert
            //      cell
            if (
                GS.findParentElement(columnElement, 'gs-table') === element &&
                cellElement.classList.contains('table-cell')
            ) {
                // if we found a "column" element, we'll try to find a value and
                //      then attempt an update call
                if (columnElement) {
                    // if the "columnElement" has a "value" accessor we'll use
                    //      that to get the value
                    if (
                        columnElement.value !== null &&
                        columnElement.value !== undefined
                    ) {
                        // changed on 2022-06-11 by Nunzio
                        // this is the behaviour of Microsoft Access, and Cross expected it
                        newValue = columnElement.value === '' ? '\\N' : columnElement.value;
                        // newValue = columnElement.value;

                    // else if the "target" has a "value" accessor we'll use
                    //      that to get the value
                    } else if (
                        target.value !== null &&
                        target.value !== undefined
                    ) {
                        // changed on 2022-06-11 by Nunzio
                        // this is the behaviour of Microsoft Access, and Cross expected it
                        newValue = target.value === '' ? '\\N' : target.value;
                        // newValue = target.value;

                    // else if the "columnElement" has a "checked" accessor
                    //      we'll use that to get the value
                    } else if (
                        columnElement.checked !== null &&
                        columnElement.checked !== undefined
                    ) {
                        newValue = columnElement.checked;

                    // else if the "target" has a "checked" accessor we'll use
                    //      that to get the value
                    } else if (
                        target.checked !== null &&
                        target.checked !== undefined
                    ) {
                        newValue = target.checked;

                    // else: throw an error for the developer
                    } else {
                        throw 'GS-TABLE Error: Found an element with a ' +
                                '"column" attribute, but could not find a ' +
                                'value. Please make sure that when a ' +
                                '"change" event is fired either the event ' +
                                'target or the "column" element has a ' +
                                '"value" or "checked" accessor.';
                    }

                    // get parent column name and record number and
                    //      store them in variables for clarity
                    strColumn = columnElement.getAttribute('column');
                    intRecord = parseInt(
                        cellElement.getAttribute('data-row-number'),
                        10
                    );

                    //console.log('column value:', columnElement.value);
                    //console.log('target value:', target.value);
                    //console.log('column checked:', columnElement.checked);
                    //console.log('target checked:', target.checked);
                    //console.log('strColumn:', strColumn);
                    //console.log('intRecord:', intRecord);
                    //console.log('newValue:', newValue);

                    // call the update function
                    dataUPDATE(element, 'single-cell', {
                        "data": {
                            "columnName": strColumn,
                            "recordNumber": intRecord,
                            "newValue": newValue
                        },
                        "updateConfirmed": true
                    });
                }
            }
        };

        element.addEventListener(
            'change',
            element.internalEvents.cellUpdate
        );

        // sometimes, the user needs to be able to update multiple columns
        //      at once. or they just want to see the record in a more
        //      focused way, with more room. so, we open the update dialog
        //      when an update dialog button is clicked.
        element.internalEvents.updateDialog = function (event) {
            //console.log(event);
            var target = event.target;
            var arrCol;
            var intRow;
            var strRow;
            var arrRow;
            var jsnRow;
            var i;
            var len;
            var strNullString;
            var templateFunc;
            var strHTML;
            var templateElement;

            if (target.classList.contains('table-multi-update-button')) {
                // we want the null string to be configurable, so we'll read the
                //      "null-string" attribute to get the null string
                // if the "null-string" attribute is present, use the contents
                //      or coalesce to empty string
                if (element.hasAttribute('null-string')) {
                    strNullString = element.getAttribute('null-string') || '';

                // else, null string is left up to the encoding function
                } else {
                    strNullString = undefined;
                }

                // we need to know the column names
                arrCol = element.internalData.columnNames;

                // we need to get the record
                intRow = parseInt(
                    target.parentNode.getAttribute('data-row-number'),
                    10
                );

                strRow = element.internalData.records[intRow];

                // convert the record to our normal "row" and "arrRow"
                // decode values in the column array and build up the json
                arrRow = strRow.split('\t');
                jsnRow = {};
                i = 0;
                len = arrCol.length;
                while (i < len) {
                    arrRow[i] = (
                        GS.decodeFromTabDelimited(
                            arrRow[i],
                            strNullString
                        )
                    );
                    jsnRow[arrCol[i]] = arrRow[i];

                    i += 1;
                }

                //console.log('intRow:', intRow);
                //console.log('strRow:', strRow);
                //console.log('arrRow:', arrRow);
                //console.log('jsnRow:', jsnRow);

                // template the updateDialog with the record
                templateFunc = doT.template(
                    '{{ ' +
                        'var row_number = jo.index + 1;' +
                        'var qs = jo.qs;' +
                        'var row = jo.row;' +
                        'var arrRow = jo.arrRow;' +
                        'var i = jo.index;' +
                        'var len = jo.len;' +
                    '}}' +
                    element.internalTemplates.updateDialog.templateHTML
                );

                // template with JSON
                strHTML = templateFunc({
                    'qs': GS.qryToJSON(GS.getQueryString()),
                    'row': jsnRow,
                    'arrRow': arrRow,
                    'index': intRow,
                    'len': element.internalData.records.length
                });

                // because we prevent templating into other element's
                //      templates (the ones with a "src" attribute) by
                //      "hiding" (by replacing them with a random token
                //      and storing the token-template relationship)
                //      them, we have to "show" them (by replacing the
                //      token with the original template strings) at
                //      this step
                strHTML = GS.templateShowSubTemplates(
                    strHTML,
                    element.internalTemplates.updateDialog
                );

                // generate dialog
                templateElement = document.createElement('template');

                templateElement.innerHTML = ml(function () {/*
<gs-page>
    <gs-header>
        <center><h3>Update</h3></center>
    </gs-header>
    <gs-body padded>
        {{HTML}}
    </gs-body>
    <gs-footer>
        <gs-grid gutter>
            <gs-block>
                <gs-button dialogclose>Cancel</gs-button>
            </gs-block>
            <gs-block>
                <gs-button id="gs-table-update-record" bg-primary>
                    Save
                </gs-button>
            </gs-block>
        </gs-grid>
    </gs-footer>
</gs-page>*/
                }).replace(/\{\{HTML\}\}/gi, strHTML);

                // open the dialog
                GS.openDialog(templateElement, function () {
                    var dialog = this;
                    var saveButtonClick;
                    var afterUpdateFunc;

                    saveButtonClick = function () {
                        var arrElement;
                        var elem_i;
                        var elem_len;
                        var elem;
                        var arrColumns;
                        var arrValues;
                        var parentSRCElement;
                        var strOldValue;
                        var strNewValue;

                        // when the save button is clicked, we need to check
                        //      every field to find out what changes have been
                        //      made
                        arrElement = tblQry(dialog, '[column]');
                        arrColumns = [];
                        arrValues = [];
                        elem_i = 0;
                        elem_len = arrElement.length;
                        while (elem_i < elem_len) {
                            elem = arrElement[elem_i];

                            parentSRCElement = GS.findParentElement(
                                elem,
                                '[src]'
                            );

                            if (
                                !parentSRCElement ||
                                parentSRCElement.nodeName === 'HTML' ||
                                parentSRCElement.nodeName === 'BODY'
                            ) {
                                strOldValue = jsnRow[
                                    elem.getAttribute('column')
                                ];
                                strNewValue = elem.value;

                                if (strNewValue !== strOldValue) {
                                    arrColumns.push(
                                        elem.getAttribute('column')
                                    );
                                    arrValues.push(
                                        GS.encodeForTabDelimited(
                                            strNewValue,
                                            strNullString
                                        )
                                    );
                                }
                            }

                            elem_i += 1;
                        }

                        if (arrColumns.length > 0) {
                            afterUpdateFunc = function () {
                                GS.closeDialog(dialog, 'Ok');
                                element.removeEventListener(
                                    'after_update',
                                    afterUpdateFunc
                                );
                            };

                            element.addEventListener(
                                'after_update',
                                afterUpdateFunc
                            );

                            dataUPDATE(element, 'cell-range', {
                                "data": {
                                    "columns": arrColumns,
                                    "records": [intRow],
                                    "values": [arrValues.join('\t')]
                                },
                                "updateConfirmed": false
                            });
                        }
                    };

                    tblElemByID('gs-table-update-record')
                        .addEventListener('click', saveButtonClick);
                });
            }
        };

        element.elems.dataViewport.addEventListener(
            'click',
            element.internalEvents.updateDialog
        );
    }

    // ############# INSERT EVENTS #############
    function unbindInsert(element) {
        element.elems.dataViewport.removeEventListener(
            'keydown',
            element.internalEvents.insertRecordReturn
        );
        element.elems.dataViewport.removeEventListener(
            'change',
            element.internalEvents.insertRecordValueRetain,
            true
        );
        element.elems.dataViewport.removeEventListener(
            'keyup',
            element.internalEvents.insertRecordValueRetain
        );
    }
    function bindInsert(element) {
        // we only want to insert a new record if the user presses "return"
        element.internalEvents.insertRecordReturn = function (event) {
            var parentCell = GS.findParentTag(event.target, 'gs-cell');
            var keyCode = (event.keyCode || event.which);

            // we only want return to insert if the return occured inside
            //      an insert cell
            if (
                parentCell.classList.contains('table-insert') &&
                keyCode === 13
            ) {
                triggerRecordInsert(element);
                // don't trigger an insert, fire a blur instead
                // clearSelection stops it from reverting the focus
                element.clearSelection();
                focusHiddenControl(element);
            }
        };
        // COMMENTED 12/18/2021
        //element.internalEvents.insertRecordBlur = function (event) {
        //    // who put this timeout in here, and why? - Michael
        //    setTimeout(
        //        function () {
        //            var parentCell =GS.findParentTag(event.target, 'gs-cell');
        //            var newParentCell = GS.findParentTag(
        //                document.activeElement,
        //                'gs-cell'
        //            );
        //            var totalValues;
        //            var insertElements;
        //            var i;
        //            var len;

        //            // element.internalEvents.insertRecordValueRetain(event);

        //            // we only want return to insert if the return occured
        //            //      inside an insert cell
        //            if (
        //                parentCell &&
        //                (
        //                    (
        //                      parentCell.classList.contains('table-insert') &&
        //                        !newParentCell
        //                    ) ||
        //                    (
        //                      parentCell.classList.contains('table-insert') &&
        //                        !newParentCell
        //                            .classList.contains('table-insert')
        //                    )
        //                )
        //            ) {
        //                totalValues = false;
        //              insertElements = tblQry(element, '.table-insert input');

        //                i = 0;
        //                len = insertElements.length;
        //                while (i < len) {
        //                    totalValues += insertElements[i].value;
        //                    i += 1;
        //                }

        //                if (totalValues && totalValues !== 'false') {
        //                    element.internalEvents
        //                        .insertRecordValueRetain(event);
        //                    triggerRecordInsert(element);
        //                }
        //            }
        //        },
        //        1
        //    );

        //};

        element.elems.dataViewport.addEventListener(
            'keydown',
            element.internalEvents.insertRecordReturn
        );
        // COMMENTED 12/18/2021, the standard we follow doesn't use blur to
        //      insert, it's only on "return". Leaving it here for future
        //      reference. Also, the code was buggy to boot, so removing this
        //      will make the insert record more stable.
        //element.elems.dataViewport.addEventListener(
        //    'blur',
        //    element.internalEvents.insertRecordBlur,
        //    true
        //);

        // we want to be able to fill in some insert cells, scroll away,
        //      scroll back, and not lose the values that have been typed in
        // this event code saves the value of the target internally so that
        //      when we re-template the insert record on scroll, we can get
        //      the values back
        element.internalEvents.insertRecordValueRetain = function (event) {
            if (event.type === 'keyup' && event.keyCode === 13) {
                return;
            }
            var target = event.target;
            var parentCell = GS.findParentTag(target, 'gs-cell');
            var parentColumn = GS.findParentElement(target, '[column]');

            if (!parentColumn) {
                return;
            }
            var strColumn = parentColumn.getAttribute('column');

            // this was commented out because it was grabbing the value
            // of the input wich means that for encrypted texts the
            // insert value was unencrypted. replacement below
            // var strValue = target.value;
            var strValue = parentColumn.value;
            // we only want to retain the values of insert cells, so only do so
            //      if the parent cell has the insert cell class and has a
            //      [column=""] defined
            if (
                parentCell.classList.contains('table-insert') &&
                strColumn
            ) {
                if (strValue) {
                    // retain the value in the internalData
                    element.internalData.insertRecord[strColumn] = strValue;

                    // some insert fields may be changed twice before an insert,
                    //      so only add the column name to the changed columns
                    //      list if that column name isn't already in the list
                    if (
                        element
                            .internalData
                            .insertRecordRetainedColumns
                            .indexOf(strColumn) === -1
                    ) {
                        element
                            .internalData
                            .insertRecordRetainedColumns
                            .push(strColumn);
                    }
                // if the user clears out a field that was previously
                //      retained, we want to remove that value from the
                //      retained list
                } else if (
                    !strValue &&
                    element
                        .internalData
                        .insertRecordRetainedColumns
                        .indexOf(strColumn) > -1
                ) {
                    element
                        .internalData
                        .insertRecord[strColumn] = undefined;
                    element
                        .internalData
                        .insertRecordRetainedColumns
                        .splice(
                            element
                                .internalData
                                .insertRecordRetainedColumns
                                .indexOf(strColumn)
                        );
                }
            }
        };
        // this was getting run every time you inserted causing it
        // to save the last edited value
        // DECOMMENTED 12/14/2021 - I've made the insert function clear the
        //      retained values before and after insert in order to get the
        //      immediate clear, and prevent the last "change" value from
        //      sticking.
        //      The only weakness of this approach is if a user is able to start
        //      typing before the insert is complete, we're prolly gonna clear
        //      it out. However, I'm willing to take that risk for now and see
        //      what happens. If we run into this issue for real, we will find
        //      some way to determine what values to clear.
        element.elems.dataViewport.addEventListener(
            'change',
            element.internalEvents.insertRecordValueRetain,
            true
        );
        element.elems.dataViewport.addEventListener(
            'keyup',
            element.internalEvents.insertRecordValueRetain
        );
    }

    // ############# HUD EVENTS #############
    function unbindHUD() { //element

    }
    function bindHUD() { //element

    }

    // ############# KEY EVENTS #############
    function unbindKey(element) {
        if (!evt.touchDevice) {
            element.removeEventListener(
                'keydown',
                element.internalEvents.keyDown
            );
        }
    }
    function bindKey(element) {
        element.internalEvents.keyDown = function (event) {
            var keyCode = (event.keyCode || event.which);
            var bolCMDorCTRL = (event.ctrlKey || event.metaKey);
            var bolShift = (event.shiftKey);
            var active = document.activeElement;
            var activeValue = document.activeElement.value;

            var jsnRange;
            var intOldRecord;
            var intOldColumn;
            var intNewRecord;
            var intNewColumn;

            var intMaxColumn;
            var intMaxRecord;
            var intMinColumn;
            var intMinRecord;

            var jsnCursorPos;
            var intCursorPos;
            var bolFullSelection;
            var bolCursorAtFirst;
            var bolCursorAtTop;
            var bolCursorAtLast;
            var bolCursorAtBottom;

            var bolMaintainSelection;
            var bolMoveSelectedToTop;
            var intSpaceToTraverse;
            var intHeight;
            var i;
            var len;

            var beforeEvent;
            var selectionCopy;

            // if the keydown took place inside the hidden focus control
            if (active === element.elems.hiddenFocusControl) {
                if (
                    keyCode === 8 || // backspace
                    keyCode === 46   // forward delete
                ) {
                    deleteSelectedRecords(element);

                // if you hit return in the hidden focus control, select all
                //      text inside the control that is the origin field of the
                //      latest selection
                } else if (keyCode === 13) {
                    focusIntoSelectedCell(element);

                // if you hit CMD/CTRL-A, select all
                } else if (bolCMDorCTRL && keyCode === 65) {
                    // we need functions to give the top-right and bottom-left
                    //      corners, this use case would be simplified and would
                    //      work no matter how musch data or header/selector and
                    //      would help fix a couple other unreliable areas in
                    //      this element
                    // ### NEED CODING ###
                    len = element.internalData.records.length;
                    element.internalSelection.ranges = [
                        {
                            "start": {
                                "row": (
                                    element.internalDisplay.headerVisible
                                        ? 'header'
                                        : 0
                                ),
                                "column": (
                                    element.internalDisplay
                                        .recordSelectorVisible
                                            ? 'selector'
                                            : 0
                                )
                            },
                            "end": {
                                "row": (
                                    len > 0
                                        ? (len - 1)
                                        : 'header'
                                ),
                                "column": (
                                    element.internalDisplay
                                        .columnWidths.length - 1
                                )
                            },
                            "negator": false
                        }
                    ];
                    renderSelection(element);
                }
            }

            // these keys will be listened for if the focus is in a control or
            //      in the hidden focus control. all of these keys will be
            //      overridden no matter the target. if you have a control that
            //      uses one of these keys or key combos and you don't want the
            //      gs-table to intercept it: stop propagation and/or prevent
            //      default when you hear the event inside your element
            if (
                (
                    keyCode === 38 ||
                    keyCode === 39 ||
                    keyCode === 40 ||
                    keyCode === 37 ||
                    keyCode === 33 ||
                    keyCode === 34 ||
                    keyCode === 36 ||
                    keyCode === 35 ||
                    keyCode === 9
                ) &&
                !event.defaultPrevented
            ) {
                // if the focused element is an input or textarea, get the text
                //      selection so that we can calculate if an arrow key
                //      escapes the field
                if (
                    (
                        active.nodeName === 'INPUT' ||
                        active.nodeName === 'TEXTAREA'
                    ) &&
                    active !== element.elems.hiddenFocusControl
                ) {
                    jsnCursorPos = GS.getInputSelection(active);

                // else, assume full selection. this can happen if the focused
                //      field is (for example) a checkbox
                } else {
                    jsnCursorPos = {
                        'start': 0,
                        'end': activeValue.length
                    };
                }

                // shortcut variable for wheather or not all the text is
                //      selected
                bolFullSelection = (
                    jsnCursorPos.start === 0 &&
                    jsnCursorPos.end === activeValue.length
                );

                // if we don't have a full selection and the selection is one
                //      character position, create some shortcut variables so
                //      that we know if the cursor is at a particular extreme.
                if (
                    jsnCursorPos &&
                    !bolFullSelection &&
                    jsnCursorPos.start === jsnCursorPos.end
                ) {
                    intCursorPos = jsnCursorPos.start;
                    bolCursorAtFirst = (
                        intCursorPos === 0
                    );
                    bolCursorAtTop = (
                        (
                            intCursorPos < (
                                activeValue.indexOf('\n') === -1
                                    ? activeValue.length + 1
                                    : activeValue.indexOf('\n') + 1
                            )
                        ) ||
                        (
                            intCursorPos === 0
                        )
                    );
                    bolCursorAtLast = (
                        intCursorPos === activeValue.length
                    );
                    bolCursorAtBottom = (
                        intCursorPos > activeValue.lastIndexOf('\n')
                    );
                }

                // save the latest selection range's endpoint
                jsnRange = element.internalSelection.ranges[
                    element.internalSelection.ranges.length - 1
                ];

                // if there is a selection range, save it's endpoint
                if (jsnRange) {
                    intOldRecord = jsnRange.end.row;
                    intOldColumn = jsnRange.end.column;

                    if (intOldRecord === 'header') {
                        intOldRecord = -1;
                    } else if (intOldRecord === 'insert') {
                        intOldRecord = element.internalData.records.length;
                    }

                    if (intOldColumn === 'selector') {
                        intOldColumn = -1;
                    }

                // else, assume the endpoint is the first cell
                // this occurs when you tab into a gs-table that has no
                //      focusable fields and press a navigation key
                } else {
                    intOldRecord = 0;
                    intOldColumn = 0;
                }

                // determine max column and max record and save as a shortcut
                intMaxColumn = (
                    // commented because the record selection is -1, not 0,
                    //      this means that the max column stays the same
                    //      regardless of record selectors or not.
                    //element.internalDisplay.recordSelectorVisible
                    //    ? element.internalDisplay.columnWidths.length
                    //    :
                    element.internalDisplay.columnWidths.length - 1
                );
                intMaxRecord = (
                    element.internalDisplay.insertRecordVisible
                        ? element.internalData.records.length
                        : element.internalData.records.length - 1
                );

                // determine min column and min record and save as a shortcut
                intMinColumn = (
                    element.internalDisplay.recordSelectorVisible
                        ? -1
                        : 0
                );
                intMinRecord = (
                    element.internalDisplay.headerVisible
                        ? -1
                        : 0
                );

                // here we waterfall to determine the new selection row and
                //      column. you can't arrow from records to insert record
                //      except under a special case (no shift, no command,
                //      arrow down from last record)
                // -1 in intNewRecord means header record
                // -1 in intNewColumn means record selector column


                // "home" -- first cell of record
                if (keyCode === 36) {
                    // after moving the selection into a single cell, the
                    //      text selection is overridden because of the
                    //      keyup event. so, here we preventDefault and
                    //      stopPropagation to prevent the keyup from
                    //      occuring.
                    event.preventDefault();
                    event.stopPropagation();

                    // go to first cell
                    intNewRecord = intOldRecord;
                    intNewColumn = intMinColumn;

                // "end" -- last cell of record
                } else if (keyCode === 35) {
                    // after moving the selection into a single cell, the
                    //      text selection is overridden because of the
                    //      keyup event. so, here we preventDefault and
                    //      stopPropagation to prevent the keyup from
                    //      occuring.
                    event.preventDefault();
                    event.stopPropagation();

                    intNewRecord = intOldRecord;
                    intNewColumn = intMaxColumn;

                // "up arrow"
                } else if (keyCode === 38) {
                    if (bolFullSelection || bolCursorAtTop) {
                        // after moving the selection into a single cell, the
                        //      text selection is overridden because of the
                        //      keyup event. so, here we preventDefault and
                        //      stopPropagation to prevent the keyup from
                        //      occuring.
                        event.preventDefault();
                        event.stopPropagation();

                        // if CMD or CTRL is held down: move to extreme
                        if (bolCMDorCTRL) {
                            intNewRecord = intMinRecord;
                            intNewColumn = intOldColumn;

                        // else, move to next immediate cell
                        } else if (intOldRecord > intMinRecord) {
                            intNewRecord = (intOldRecord - 1);
                            intNewColumn = intOldColumn;
                        }
                    }

                // "right arrow"
                } else if (keyCode === 39) {
                    if (bolFullSelection || bolCursorAtLast) {
                        // after moving the selection into a single cell, the
                        //      text selection is overridden because of the
                        //      keyup event. so, here we preventDefault and
                        //      stopPropagation to prevent the keyup from
                        //      occuring.
                        event.preventDefault();
                        event.stopPropagation();

                        // if CMD or CTRL is held down: move to extreme
                        if (bolCMDorCTRL) {
                            intNewRecord = intOldRecord;
                            intNewColumn = intMaxColumn;

                        // else if we are at the right-most cell of the record
                        //      and we are not at the bottom-most record:
                        //      move to next record, first cell
                        } else if (
                            intOldColumn === intMaxColumn &&
                            intOldRecord < intMaxRecord
                        ) {
                            intNewRecord = (intOldRecord + 1);
                            intNewColumn = intMinColumn;

                        // else, move to next immediate cell
                        } else if (intOldColumn < intMaxColumn) {
                            intNewRecord = intOldRecord;
                            intNewColumn = (intOldColumn + 1);
                        }
                    }

                // "down arrow"
                } else if (keyCode === 40) {
                    if (bolFullSelection || bolCursorAtBottom) {
                        // after moving the selection into a single cell, the
                        //      text selection is overridden because of the
                        //      keyup event. so, here we preventDefault and
                        //      stopPropagation to prevent the keyup from
                        //      occuring.
                        event.preventDefault();
                        event.stopPropagation();
                        // if CMD or CTRL is held down: move to extreme
                        if (bolCMDorCTRL) {
                            intNewRecord = intMaxRecord;
                            intNewColumn = intOldColumn;

                        // else if, is at the end move to next immediate cell
                        } else if (
                            intOldRecord < intMaxRecord &&
                            bolCursorAtLast
                        ) {
                            intNewRecord = (intOldRecord + 1);
                            intNewColumn = intOldColumn;
                        // else, move to extreme of cell
                        } else {
                            GS.setInputSelection(
                                active,
                                jsnCursorPos.start,
                                activeValue.length
                            );
                        }
                    }

                // "left arrow"
                } else if (keyCode === 37) {
                    if (bolFullSelection || bolCursorAtFirst) {
                        // after moving the selection into a single cell, the
                        //      text selection is overridden because of the
                        //      keyup event. so, here we preventDefault and
                        //      stopPropagation to prevent the keyup from
                        //      occuring.
                        event.preventDefault();
                        event.stopPropagation();

                        // if CMD or CTRL is held down: move to extreme
                        if (bolCMDorCTRL) {
                            intNewRecord = intOldRecord;
                            intNewColumn = intMinColumn;

                        // else if we are at the left-most cell of the record
                        //      and we are not at the top-most record:
                        //      move to previous record, last cell
                        } else if (
                            intOldColumn === intMinColumn &&
                            intOldRecord > intMinRecord
                        ) {
                            intNewRecord = (intOldRecord - 1);
                            intNewColumn = intMaxColumn;

                        // else, move to next immediate cell
                        } else if (intOldColumn > intMinColumn) {
                            intNewRecord = intOldRecord;
                            intNewColumn = (intOldColumn - 1);
                        }
                    }

                // "page up"
                } else if (keyCode === 33) {
                    // after moving the selection into a single cell, the
                    //      text selection is overridden because of the
                    //      keyup event. so, here we preventDefault and
                    //      stopPropagation to prevent the keyup from
                    //      occuring.
                    event.preventDefault();
                    event.stopPropagation();

                    // move to a cell approx one page up
                    intSpaceToTraverse = (
                        element.elems.dataViewport.clientHeight - (
                            element.internalScrollOffsets.top +
                            element.internalScrollOffsets.bottom
                        )
                    );
                    i = (
                        element.internalDisplay.currentRange.fromRecord
                        //intOldRecord
                    );
                    while (i >= -1) {
                        intHeight = (
                            element.internalDisplay.recordHeights[i]
                        );

                        intSpaceToTraverse -= intHeight;

                        // if we've run into the header (of the first
                        //      record), select the highest we can
                        if (i === intMinRecord) {
                            intNewRecord = i;
                            break;
                        }
                        // if we've found a record a page up, select the
                        //      record that is partially hidden by scroll
                        if (intSpaceToTraverse < 0) {
                            intNewRecord = i;
                            break;
                        }
                        i -= 1;
                    }

                    // if we found a record: choose a column
                    if (intNewRecord !== undefined) {
                        // if shift is held down, maintain the old column
                        if (bolShift) {
                            intNewColumn = intOldColumn;

                        // else, select the whole record by choosing the
                        //      record selector (or select first cell)
                        } else {
                            intNewColumn = intMinColumn;
                        }
                    }

                    // we want page up/down to scroll the selected record to the
                    //      top of the viewport, so here we set a boolean
                    //      variable to tell the code below (which is where the
                    //      selection and scrolling happens) to scroll the
                    //      selected cell to the top
                    bolMoveSelectedToTop = true;

                // "page down"
                } else if (keyCode === 34) {
                    // after moving the selection into a single cell, the
                    //      text selection is overridden because of the
                    //      keyup event. so, here we preventDefault and
                    //      stopPropagation to prevent the keyup from
                    //      occuring.
                    event.preventDefault();
                    event.stopPropagation();

                    // move to a cell approx one page down
                    intSpaceToTraverse = (
                        element.elems.dataViewport.clientHeight - (
                            element.internalScrollOffsets.top +
                            element.internalScrollOffsets.bottom
                        )
                    );

                    i = (
                        element.internalDisplay.currentRange.fromRecord
                        //intOldRecord
                    );
                    len = (intMaxRecord + 1);
                    while (i < len) {
                        if (i === -1) {
                            intHeight = (
                                element.internalDisplay.headerHeight
                            );
                        } else {
                            intHeight = (
                                element.internalDisplay.recordHeights[i]
                            );
                        }

                        intSpaceToTraverse -= intHeight;

                        // if we've reached the bottom, select the last record
                        if (i === intMaxRecord) {
                            intNewRecord = i;
                            break;
                        }
                        // if we've found a record a page down, select the
                        //      record that is partially hidden by scroll
                        if (intSpaceToTraverse < 0) {
                            intNewRecord = i - 1;
                            break;
                        }
                        i += 1;
                    }

                    // if we found a record: choose a column
                    if (intNewRecord !== undefined) {
                        // if shift is held down, maintain the old column
                        if (bolShift) {
                            intNewColumn = intOldColumn;

                        // else, select the whole record by choosing the
                        //      record selector
                        } else {
                            intNewColumn = intMinColumn;
                        }
                    }

                    // we want page up/down to scroll the selected record to the
                    //      top of the viewport, so here we set a boolean
                    //      variable to tell the code below (which is where the
                    //      selection and scrolling happens) to scroll the
                    //      selected cell to the top
                    bolMoveSelectedToTop = true;

                // "tab" next cell in reading order
                } else if (keyCode === 9) {
                    // we need to be able to handle shift-tab because some users
                    //      know how to use shift-tab and would expect it from
                    //      any key-navigable interface
                    if (bolShift) {
                        // we need to be able to tab out of the gs-table if the
                        //      user presses tab while the first cell is the
                        //      selection anchor that we are moving from
                        // So, if the anchor point is at the first cell: do
                        //      nothing, this means that the event won't be
                        //      prevented and therefore will do what the browser
                        //      naturally want's it to do
                        // else, we want to move the selection to the previous
                        //      field in reading order
                        if (
                            intOldRecord !== intMinColumn ||
                            intOldColumn !== intMinRecord
                        ) {
                            // after moving the selection into a single cell,
                            //      the text selection is overridden because of
                            //      the keyup event. so, here we preventDefault
                            //      and stopPropagation to prevent the keyup
                            //      from occuring.
                            event.preventDefault();
                            event.stopPropagation();

                            // if we are at the min column:
                            //      go to the max column and the previous record
                            if (intOldColumn === intMinColumn) {
                                intNewRecord = (intOldRecord - 1);
                                intNewColumn = intMaxColumn;

                            // else, go to previous column
                            } else {
                                intNewRecord = intOldRecord;
                                intNewColumn = intOldColumn - 1;
                            }
                        }

                    // we need to handle standard tab as well
                    } else {
                        // we need to be able to tab out of the gs-table if the
                        //      user presses tab while the last cell is the
                        //      selection anchor that we are moving from
                        // So, if the anchor point is at the last cell: do
                        //      nothing, this means that the event won't be
                        //      prevented and therefore will do what the browser
                        //      naturally want's it to do
                        // else, we want to move the selection to the previous
                        //      field in reading order
                        if (
                            intOldRecord !== intMaxColumn ||
                            intOldColumn !== intMaxRecord
                        ) {
                            // after moving the selection into a single cell,
                            //      the text selection is overridden because of
                            //      the keyup event. so, here we preventDefault
                            //      and stopPropagation to prevent the keyup
                            //      from occuring.
                            event.preventDefault();
                            event.stopPropagation();

                            // if we are at the max column:
                            //      go to the min column and the next record
                            if (intOldColumn === intMaxColumn) {
                                intNewRecord = (intOldRecord + 1);
                                intNewColumn = intMinColumn;

                            // else, go to next column
                            } else {
                                intNewRecord = intOldRecord;
                                intNewColumn = intOldColumn + 1;
                            }
                        }
                    }
                }

                // if we found a place to put the selection anchor point
                if (intNewRecord !== undefined && intNewColumn !== undefined) {
                    //console.log('intOldRecord:', intOldRecord);
                    //console.log('intOldColumn:', intOldColumn);
                    //console.log('intNewRecord:', intNewRecord);
                    //console.log('intNewColumn:', intNewColumn);
                    //console.log('intMinRecord:', intMinRecord);
                    //console.log('intMinColumn:', intMinColumn);
                    //console.log('intMaxRecord:', intMaxRecord);
                    //console.log('intMaxColumn:', intMaxColumn);

                    // we don't want to stay focused on the original control
                    focusHiddenControl(element);

                    // we're going to do multiple if statements that test if the
                    //      previous selections will be maintained, so here
                    //      we'll save a shortcut variable
                    bolMaintainSelection = (
                        // shift is down
                        bolShift &&
                        // there is an old selection
                        jsnRange &&
                        // the key wasn't tab
                        keyCode !== 9
                    );

                    // if the user cancels the selection, we need to be able
                    //      to go back to the previous selection. so, here
                    //      we save a backup
                    selectionCopy = getSelectionCopy(element);

                    // when the before_selection event is triggered, we want the
                    //      gs-table to have the current selection available.
                    //      so we'll make the changes to the selection and then
                    //      trigger before_selection.

                    // convert the new record and column to special values
                    //      (if needed)

                    var intHeaderIndex;
                    var intSelectorIndex;
                    var intInsertIndex;
                    var newRecord;
                    var newColumn;

                    intHeaderIndex = -1;
                    intSelectorIndex = -1;
                    intInsertIndex = (element.internalData.records.length);

                    if (intNewRecord === intHeaderIndex) {
                        newRecord = 'header';
                    } else if (intNewRecord === intInsertIndex) {
                        newRecord = 'insert';
                    } else {
                        newRecord = intNewRecord;
                    }

                    //console.log(
                    //    newRecord,
                    //    intNewRecord,
                    //    intHeaderIndex,
                    //    intInsertIndex
                    //);

                    if (intNewColumn === intSelectorIndex) {
                        newColumn = 'selector';
                    } else {
                        newColumn = intNewColumn;
                    }

                    // if we're going to maintain selections
                    if (bolMaintainSelection) {
                        // maintain old selections and modify the most
                        //      recent one's endpoint
                        jsnRange.end.row = newRecord;
                        jsnRange.end.column = newColumn;

                    // else, set selection to only that cell
                    } else {
                        jsnRange = {
                            "start": {
                                "row": newRecord,
                                "column": newColumn
                            },
                            "end": {
                                "row": newRecord,
                                "column": newColumn
                            },
                            "negator": false
                        };
                        element.internalSelection.ranges = [jsnRange];
                    }

                    // trigger a "before_selection" event so that the page has a
                    //      chance to cancel the selection
                    beforeEvent = GS.triggerEvent(element, 'before_selection');

                    // if the user prevents the default on the
                    //      "before_selection" event, revert selection ranges
                    //      to what they were before the latest selection
                    //      started (and revert wheather or not the selection
                    //      is in the insert record)
                    if (beforeEvent.defaultPrevented) {
                        element.internalSelection.ranges = (
                            selectionCopy.ranges
                        );
                        return;
                    }

                    // if the before_selection event wasn't cancelled, we run
                    //      this code below

                    // sometimes, the focus is lost. so, focus the
                    //      hiddenFocusControl so that we can always listen for
                    //      keypresses
                    focusHiddenControl(element);
                    // sometimes we want to move the selected endpoint to the
                    //      top of the viewport, if that's what we want, send
                    //      the 'top' mode into the scrollSelectionIntoView
                    //      function
                    if (bolMoveSelectedToTop) {
                        // scroll selection into view and re-render
                        scrollSelectionIntoView(element, 'top');

                    } else {
                        // scroll selection into view and re-render
                        scrollSelectionIntoView(element);
                    }

                    // if we're not going to maintain old selections (which
                    //      also means that only one cell will be selected)
                    //      and we're not selecting a header or record selector
                    if (
                        !bolMaintainSelection &&
                        intNewRecord > -1 &&
                        intNewColumn > -1
                    ) {
                        // we want the user to be able to start typing and fill
                        //      the cell, so focus into the cell and select all
                        //      text if possible
                        focusIntoSelectedCell(element);
                    }

                    // if the "before_selection" event is not prevented, we
                    //      trigger "after_selection" so that the page can run
                    //      code after a selection has been made
                    if (beforeEvent.defaultPrevented) {
                        GS.triggerEvent(element, 'after_selection');
                    }
                }
            }
        };

        if (!evt.touchDevice) {
            element.addEventListener(
                'keydown',
                element.internalEvents.keyDown
            );
        }
    }

    // ############# COPY EVENTS #############
    function unbindCopy(element) {
        element.removeEventListener(
            'copy',
            element.internalEvents.copySelection
        );
    }
    function bindCopy(element) {
        element.internalEvents.copySelection = function (event) {
            // if there is copy columns
            if (element.internalClip.columnList.length > 0) {
                var jsnCopyString;
                var focusedElement;
                var strCopyType;
                var arrCopyType;
                var i;
                var len;
                var beforeCopyEvent;

                strCopyType = (
                    element.getAttribute('copy-types') ||
                    'text,html'
                );
                arrCopyType = strCopyType.split(',');

                beforeCopyEvent = GS.triggerEvent(element, 'before_copy', {
                    forceCopy: element.internalEvents.forceCopy
                });

                element.internalEvents.forceCopy = false;

                i = 0;
                len = arrCopyType.length;
                while (i < len) {
                    arrCopyType[i] = arrCopyType[i].toLowerCase();
                    i += 1;
                }

                if (beforeCopyEvent.defaultPrevented) {
                    event.preventDefault(event);

                } else {
                    // save the currently focused element for easy/quick access
                    focusedElement = document.activeElement;

                    // if the focus is on the hidden focus control of if the
                    //      text selection of the currently focused element is
                    //      not selecting multiple characters
                    if (
                        focusedElement.classList
                            .contains('hidden-focus-control') ||
                            (
                                focusedElement.selectionStart ===
                                focusedElement.selectionEnd
                            )
                    ) {
                        console.time('copy');

                        // because copying a large amount of data takes time,
                        //      add a loader to let the user know we're copying,
                        //      just in case
                        addLoader(element, 'copy-loader', 'Copying Data...');

                        // focus the hidden focus control and select all of it's
                        //      text so that Firefox will allow us to override
                        //      the clipboard
                        focusedElement = element.elems.hiddenFocusControl;
                        focusedElement.focus();

                        GS.setInputSelection(
                            focusedElement,
                            0,
                            focusedElement.value.length
                        );

                        // we want to override the text and HTML mime type
                        //      clipboards, so we get the copy text for both
                        //      types
                        jsnCopyString = getCopyStrings(element);

                        // override clipboard (prevent event default if we are
                        //      successful)
                        if (
                            arrCopyType.indexOf('text') > -1 &&
                            handleClipboardData(
                                event,
                                jsnCopyString.text,
                                'text'
                            )
                        ) {
                            event.preventDefault(event);
                        }
                        if (
                            arrCopyType.indexOf('html') > -1 &&
                            handleClipboardData(
                                event,
                                jsnCopyString.html,
                                'html'
                            )
                        ) {
                            event.preventDefault(event);
                        }

                        // remove copying loader
                        removeLoader(element, 'copy-loader', 'Data Copied');

                        console.timeEnd('copy');
                    }
                }
            } else {
                addLoader(element, 'copy-loader', 'Unable to Copy');
                removeLoader(element, 'copy-loader', 'Unable to Copy');
            }
        };

        if (!evt.touchDevice && !element.hasAttribute('no-copy')) {
            element.addEventListener(
                'copy',
                element.internalEvents.copySelection
            );
        }
    }

    // ############# PASTE EVENTS #############
    function unbindPaste(element) {
        if (!evt.touchDevice) {
            element.removeEventListener(
                'paste',
                element.internalEvents.pasteSelection
            );
        }
    }
    function bindPaste(element) {
        element.internalEvents.pasteSelection = function (event) {
            // we dont want to interfere with pasting inside a cell, so only
            //      use this paste event if the focused element is the
            //      hiddenFocusControl
            if (document.activeElement === element.elems.hiddenFocusControl) {
                // prevent default so that the hiddenFocusControl's value
                //      doesn't get overridden by the paste
                event.preventDefault();
                usePasteEvent(element, event);
            }
        };

        if (!evt.touchDevice) {
            element.addEventListener(
                'paste',
                element.internalEvents.pasteSelection
            );
        }
    }

    // ############# CUT EVENTS #############
    function unbindCut(element) {
        if (!evt.touchDevice) {
            element.removeEventListener(
                'cut',
                element.internalEvents.cutSelection
            );
        }
    }
    function bindCut(element) {
        element.internalEvents.cutSelection = function () {
            // we dont want to interfere with cutting inside a cell, so only
            //      use this cut event if the focused element is the
            //      hiddenFocusControl
            if (document.activeElement === element.elems.hiddenFocusControl) {
                // prevent default so that the hiddenFocusControl's value
                //      doesn't get overridden by the paste
                event.preventDefault();

                // let the user know that we don't support cut
                addLoader(element, 'cut-warn', 'Cut is not supported');
                removeLoader(element, 'cut-warn', 'Cut is not supported');
            }
        };

        if (!evt.touchDevice) {
            element.addEventListener(
                'cut',
                element.internalEvents.cutSelection
            );
        }
    }

    // ############# CONTEXTMENU EVENTS #############
    function unbindContextMenu(element) {
        element.elems.dataViewport.removeEventListener(
            'contextmenu',
            element.internalEvents.columnContextMenu
        );
    }
    function bindContextMenu(element) {
        element.internalEvents.columnContextMenu = function (event) {
            var target = event.target;
            var parentCell = GS.findParentTag(target, 'gs-cell');

            var templateElement;
            var strCellType;
            var bolRange;
            var arrDataColumns;
            var arrSelectedColumns;
            var bolFilterUnique;
            var bolFilterSelection;
            var bolColumnWidths;
            var bolHideAndShow;
            var bolSort;

            var intRecord;
            var intColumn;
            var strDataValue;
            var strControlValue;
            var strColumn;
            var columnElement;
            var focusElement;
            var jsnSelection;
            var strSelection;

            var i;
            var len;
            //var index;
            var strHTML;

            // there are multiple different contextmenus
            //      one for header cells
            //          column hide/show
            //          column sort
            //          unique list filter
            //      one for data cells
            //          column hide/show
            //          column sort
            //          selection filter
            //      one for calculated cells
            //          column hide/show
            //      one for insert cells
            //          column hide/show
            //          column sort
            //
            // overall, there are a few modules that we need to toggle
            //      unique list filter
            //      selection filter
            //      column hide/show
            //      column sort
            //
            // if your selection spans between the header and data:
            //      column hide/show
            //      column sort
            //
            // if your selection is a range containing data cells
            //      column hide/show
            //      column sort
            //
            // if your selection is a range with only calculated cells
            //      column hide/show

            // get parent gs-cell element
            parentCell = target;
            if (target.nodeName !== 'GS-CELL') {
                parentCell = GS.findParentTag(target, 'gs-cell');
            }

            // if the right-clicked cell is a data cell, header
            //      cell or insert cell
            if (
                parentCell &&
                parentCell.nodeName === 'GS-CELL' &&
                (
                    parentCell.classList.contains('table-cell') ||
                    parentCell.classList.contains('table-header') ||
                    parentCell.classList.contains('table-insert')
                )
            ) {
                // we need to find out what type of cell we right-clicked on
                if (parentCell.classList.contains('table-cell')) {
                    strCellType = 'data';

                } else if (parentCell.classList.contains('table-header')) {
                    strCellType = 'header';

                } else if (parentCell.classList.contains('table-insert')) {
                    strCellType = 'insert';
                }

                // we need to know the selected column list
                arrSelectedColumns = (
                    element.internalSelection.columns
                );
                if (arrSelectedColumns[0] === 'selector') {
                    arrSelectedColumns.shift();
                }

                // we need to know if more than one cell is selected
                bolRange = (
                    arrSelectedColumns.length > 1 ||
                    element.internalSelection.rows.length > 1
                );

                // we need to know the data columns within the selected range
                arrDataColumns = getSelectedDataColumns(element);

                // if we have one data cell selected and it is associated
                //      with a data column, we need to know the value of the
                //      cell
                if (
                    strCellType === 'data' &&
                    !bolRange &&
                    arrDataColumns.length === 1
                ) {
                    // we need to know the record number
                    intRecord = parseInt(
                        parentCell.getAttribute('data-row-number'),
                        10
                    );

                    // we need to know what record we're working with
                    intColumn = parseInt(
                        parentCell.getAttribute('data-col-number'),
                        10
                    );

                    // now that we associate display columns and their data
                    //      columns, we can get the value even if there's no
                    //      columnElement, but we do need a column number
                    strColumn = (
                        element.internalDisplay.dataColumnName[intColumn]
                    );

                    // we need to extract the cell value from the data
                    strDataValue = getCell(
                        element,
                        strColumn,
                        intRecord,
                        // cell value should be decoded from tab delimited
                        true,
                        // we need to know if we're dealing with NULL
                        'gsTAbleINTERNALNULLSTRING'
                    );

                    // we wan't to get the text selection of current cell,
                    //      so we need the column element
                    columnElement = tblQry(parentCell, '[column]')[0];

                    // we can't get the text selection if there's no column
                    //      element or there's no value
                    if (
                        columnElement &&
                        strDataValue !== 'gsTAbleINTERNALNULLSTRING'
                    ) {
                        // we need to get the input or textarea (if there
                        //      is one) that'll contain the text selection
                        // sometimes, the developer will use an input or
                        //      textarea element as the column element, in
                        //      that case the column element is the focus
                        //      element
                        if (
                            // if the column element is an input[type="text"]
                            (
                                columnElement.nodeName === 'INPUT' &&
                                columnElement.getAttribute('type') === 'text'
                            ) ||
                            // or if the column element is a textarea
                            columnElement.nodeName === 'TEXTAREA'
                        ) {
                            focusElement = columnElement;

                        // else, we need to search inside the column element
                        //      for the focus element
                        } else {
                            focusElement = tblQry(
                                columnElement,
                                'input[type="text"], textarea'
                            )[0];
                        }

                        // if strValue matches columnElement's value, use
                        //      the text selection (if availible) of the
                        //      columnElement's control and substring the
                        //      strValue
                        if (
                            focusElement &&
                            focusElement.value === strDataValue
                        ) {
                            strControlValue = focusElement.value;
                            jsnSelection = GS.getInputSelection(focusElement);

                            strSelection = strControlValue.substring(
                                jsnSelection.start,
                                jsnSelection.end
                            );
                        }
                    }
                }

                // innocent until proven guilty
                bolFilterUnique = true;
                bolFilterSelection = true;
                bolColumnWidths = true;
                bolHideAndShow = true;
                bolSort = true;

                // no unique value filter list
                if (
                    //// if the cell is not a header cell
                    //strCellType !== 'header' ||
                    //// or isn't the only column selected
                    //arrSelectedColumns.length !== 1 ||
                    //// or isn't a data column
                    //arrDataColumns.length !== 1
                    true // <-- filter unique is for the column dropdown
                ) {
                    bolFilterUnique = false;
                }

                // no filter by selection
                if (
                    // if the cell is not a data cell
                    strCellType !== 'data' ||
                    // or multiple cells are selected
                    bolRange ||
                    // or isn't the only column selected
                    arrSelectedColumns.length !== 1 ||
                    // or isn't a data column
                    arrDataColumns.length !== 1
                ) {
                    bolFilterSelection = false;
                }

                // right now, we always want the option of column widths
                if (false) {
                    bolColumnWidths = false;
                }

                // right now, we always want the option of show and hide
                if (false) {
                    bolHideAndShow = false;
                }

                // if there are no data columns in the current selection, we
                //      want no sorting options
                if (arrDataColumns.length === 0) {
                    bolSort = false;
                }

                // helps to debug
                //console.log('arrSelectedColumns: ', arrSelectedColumns);
                //console.log('arrDataColumns: ', arrDataColumns);
                //console.log('bolFilterUnique: ', bolFilterUnique);
                //console.log('bolFilterSelection: ', bolFilterSelection);
                //console.log('bolHideAndShow: ', bolHideAndShow);
                //console.log('bolSort: ', bolSort);

                // assemble the HTML
                strHTML = '';

                if (bolSort) {
                    strHTML += (
                        strHTML
                            ? '<hr />'
                            : ''
                    );
                    strHTML += (
                        '<div class="context-menu-header">Sorting:</div>' +
                        '<div class="context-menu-indent">' +
                        '    <gs-button dialogclose remove-bottom' +
                        '                iconleft icon="sort-alpha-asc"' +
                        '                class="button-sort-asc">' +
                        '        Sort A to Z' +
                        '    </gs-button>' +
                        '    <gs-button dialogclose remove-all' +
                        '                iconleft icon="sort-alpha-desc"' +
                        '                class="button-sort-desc">' +
                        '        Sort Z to A' +
                        '    </gs-button>' +
                        '    <gs-button dialogclose remove-top' +
                        '                iconleft icon="trash-o"' +
                        '                class="button-sort-clear">' +
                        '        Clear Sort' +
                        '    </gs-button>' +
                        '</div>'
                    );
                }

                if (bolHideAndShow) {
                    strHTML += (
                        strHTML
                            ? '<hr />'
                            : ''
                    );
                    strHTML += (
                        '<div class="context-menu-header">' +
                        'Hide/Unhide Columns:' +
                        '</div>' +
                        '<div class="context-menu-indent">' +
                        '    <gs-button dialogclose remove-bottom' +
                        '                iconleft icon="eye-slash"' +
                        '                class="button-column-hide">' +
                        '        Hide Column(s)' +
                        '    </gs-button>' +
                        '    <gs-button dialogclose remove-top' +
                        '                iconleft icon="eye"' +
                        '                class="button-column-unhide">' +
                        '        Unhide Columns' +
                        '    </gs-button>' +
                        '</div>'
                    );
                }

                // ### NEED CODING ###
                if (bolColumnWidths) {
                    strHTML += (
                        strHTML
                            ? '<hr />'
                            : ''
                    );
                    strHTML += (
                        '<div class="context-menu-header">Column Width:</div>' +
                        '<div class="context-menu-indent">' +
                        '    <gs-button dialogclose remove-bottom' +
                        '                iconleft icon="text-width"' +
                        '                class="button-column-width">' +
                        '        Fit To Header' +
                        '    </gs-button>' +
                        '    <gs-button dialogclose remove-top' +
                        '                iconleft icon="text-width"' +
                        '                class="button-column-width">' +
                        '        Fit To Content' +
                        '    </gs-button>' +
                        '</div>'
                    );
                }

                if (bolFilterSelection) {
                    strHTML += (
                        strHTML
                            ? '<hr />'
                            : ''
                    );
                    strHTML += (
                        '<div class="context-menu-header">Filtering:</div>' +
                        '<div class="context-menu-indent">' +
                        '    <gs-button dialogclose remove-bottom' +
                        '                iconleft icon="filter"' +
                        '                class="button-filter-include">' +
                        '        Filter By Selection' +
                        '    </gs-button>' +
                        '    <gs-button dialogclose remove-all' +
                        '                iconleft icon="filter"' +
                        '                class="button-filter-exclude">' +
                        '        Filter Excluding Selection' +
                        '    </gs-button>' +
                        '    <gs-button dialogclose remove-all' +
                        '                iconleft icon="search"' +
                        '                class="button-filter-text">' +
                        '        Text Filters' +
                        '    </gs-button>' +
                        '    <gs-button dialogclose remove-all' +
                        '                iconleft icon="toggle-off"' +
                        '                class="button-filter-toggle">' +
                        '        Toggle Filters' +
                        '    </gs-button>' +
                        '    <gs-button dialogclose remove-top' +
                        '                iconleft icon="trash-o"' +
                        '                class="button-filter-clear">' +
                        '        Clear Filters' +
                        '    </gs-button>' +
                        '</div>'
                    );
                }

                // ### NEED CODING ###
                if (bolFilterUnique) {
                    strHTML += (
                        strHTML
                            ? '<hr />'
                            : ''
                    );
                    strHTML += '<div class="gs-table-unique-value-list"></div>';
                }

                // create dialog template
                templateElement = document.createElement('template');
                templateElement.setAttribute('data-max-width', '15em');
                templateElement.setAttribute('data-overlay-close', 'true');
                templateElement.setAttribute('no-focus-lock', 'true');
                templateElement.setAttribute('no-background', '');
                templateElement.innerHTML = (
                    '<gs-page gs-dynamic class="gs-table-contextmenu">' +
                    '    <gs-body padded>' +
                    '        ' + strHTML +
                    '    </gs-body>' +
                    '</gs-page>'
                );

                // if we're going to open the dialog, we need to prevent
                //      the OS contextmenu
                event.preventDefault();

                // we want the context menu to be placed at a particular
                //      X/Y, so we'll stick a temporary element in to
                //      position to
                var jsnMousePos = GS.mousePosition(event);
                var jsnElementPos = GS.getElementOffset(
                    element.elems.root
                );

                element.elems.pixel.style.left = (
                    (
                        (
                            jsnMousePos.left -
                            jsnElementPos.left
                        ) +
                        (
                            GS.emToPx(document.body, 15) /
                            2
                        )
                    ) +
                    'px'
                );
                element.elems.pixel.style.top = (
                    (
                        jsnMousePos.top -
                        jsnElementPos.top
                    ) +
                    'px'
                );
                element.elems.pixel.style.bottom = '';
                element.elems.pixel.style.right = '';
                // element.elems.dataViewport.appendChild(
                //     element.elems.pixel
                // );

                // open dialog
                GS.openDialogToElement(
                    element.elems.pixel,
                    templateElement,
                    'down',
                    function () {
                        var dialog = this;
                        var filterToggleButton;
                        var strStatus;

                        // we want the top gs-page to have corner rounding
                        dialog.classList.add('gs-table-contextmenu');

                        // we want the "toggle filter" button to reflect
                        //      the current status of the column filter
                        //      on/off
                        if (bolFilterSelection) {
                            filterToggleButton = tblQry(
                                dialog,
                                '.button-filter-toggle'
                            )[0];

                            strStatus = (
                                element.internalData
                                    .columnFilterStatuses[arrDataColumns[0]]
                            );

                            if (strStatus === 'on') {
                                filterToggleButton.textContent = (
                                    'Toggle Filters Off'
                                );
                                filterToggleButton.setAttribute(
                                    'icon',
                                    'toggle-on'
                                );
                            } else {
                                filterToggleButton.textContent = (
                                    'Toggle Filters On'
                                );
                                filterToggleButton.setAttribute(
                                    'icon',
                                    'toggle-off'
                                );
                            }
                        }
                    },
                    function (event, strAnswer) {
                        var dialog = this;
                        var targetElement;
                        var buttonElement;

                        var strWhere;
                        var strValue;

                        var strNewSort;

                        var col_i;
                        var col_len;

                        // when you close the dialog by clicking on the
                        //      overlay, there is no event.
                        if (event && event.target) {
                            targetElement = event.target;
                        }

                        // when you close the dialog by clicking on the
                        //      overlay, there is no target.
                        if (targetElement) {
                            // we may need to position a second dialog to a
                            //      button, so here we get the button that
                            //      was clicked.
                            if (targetElement.nodeName === 'GS-BUTTON') {
                                buttonElement = targetElement;
                            } else {
                                buttonElement = GS.findParentTag(
                                    targetElement,
                                    'gs-button'
                                );
                            }
                        }


                        // there's extra whitespace around the answer
                        strAnswer = strAnswer.trim();


                        if (
                            strAnswer === 'Sort A to Z' ||
                            strAnswer === 'Sort Z to A' ||
                            strAnswer === 'Clear Sort'
                        ) {
                            if (strAnswer === 'Sort A to Z') {
                                strNewSort = 'asc';
                            } else if (strAnswer === 'Sort Z to A') {
                                strNewSort = 'desc';
                            } else if (strAnswer === 'Clear Sort') {
                                strNewSort = 'neutral';
                            }

                            col_i = 0;
                            col_len = arrDataColumns.length;
                            while (col_i < col_len) {
                                element.internalData.columnOrders[
                                    arrDataColumns[col_i]
                                ] = strNewSort;

                                col_i += 1;
                            }

                            dataSELECT(element);

                        } else if (strAnswer === 'Fit To Header') {
                            resizeColumnsToHeader(element, arrSelectedColumns);

                        } else if (strAnswer === 'Fit To Content') {
                            var colsToResize = [];
                            if (
                                element.internalSelection.rows[0] === 'header'
                            ) {
                                var jsnFirstRange = (
                                    element.internalSelection.ranges[0]
                                );
                                var intSelectionLength;
                                if (
                                    jsnFirstRange &&
                                    jsnFirstRange.start.row === 'header'
                                ) {
                                    intSelectionLength = (
                                        jsnFirstRange.end.column -
                                        jsnFirstRange.start.column + 1
                                    );

                                    i = 0;
                                    while (i < intSelectionLength) {
                                        colsToResize.push(
                                            i + jsnFirstRange.start.column
                                        );

                                        i += 1;
                                    }
                                }

                            } else {
                                //no headers selected: resize the column
                                //  that was clicked
                                colsToResize = arrSelectedColumns;
                            }
                            resizeColumnsToContent(element, arrSelectedColumns);

                        } else if (strAnswer === 'Hide Column(s)') {
                            i = 0;
                            len = arrSelectedColumns.length;
                            while (i < len) {
                                // we don't want to hide the record selector
                                if (arrSelectedColumns[i] >= 0) {
                                    // hide the column by making it zero
                                    //      width
                                    element.internalDisplay.columnWidths[
                                        arrSelectedColumns[i]
                                    ] = 0;
                                }

                                i += 1;
                            }

                            // partial re-render might not know how to
                            //      remove columns in the middle of the
                            //      viewport
                            element.internalDisplay.fullRenderRequired = true;
                            renderLocation(element);

                        } else if (strAnswer === 'Unhide Columns') {
                            openColumnHideDialog(
                                element,
                                buttonElement,
                                // before dialog close callback
                                function (strAnswer) {
                                    // if the unhide dialog wasn't cancelled,
                                    //      close the contextmenu
                                    if (strAnswer !== 'Cancel') {
                                        GS.closeDialog(dialog, 'Force');
                                    }
                                }
                            );
                            event.preventDefault();

                        } else if (strAnswer === 'Filter By Selection') {
                            strValue = (strSelection || strDataValue);

                            // sometimes the user want's to filter for nulls
                            if (strValue === 'gsTAbleINTERNALNULLSTRING') {
                                strWhere = (strColumn + ' IS NULL');
                            } else {
                                strWhere = (
                                    'CAST(' +
                                        strColumn + ' AS ' +
                                        GS.database.type.text +
                                    ') = $$' + strValue + '$$'
                                );
                            }

                            element.internalData
                                .columnFilters[arrDataColumns[0]].push(
                                    {
                                        "text": strWhere,
                                        "name": 'equals "' + strValue + '"'
                                    }
                                );

                            dataSELECT(element);

                        } else if (
                            strAnswer === 'Filter Excluding Selection'
                        ) {
                            strValue = (strSelection || strDataValue);

                            // sometimes the user want's to filter out nulls
                            if (strValue === 'gsTAbleINTERNALNULLSTRING') {
                                strWhere = (strColumn + ' IS NOT NULL');
                            } else {
                                strWhere = (
                                    'CAST(' +
                                        strColumn + ' AS ' +
                                        GS.database.type.text +
                                    ') != $$' + strValue + '$$'
                                );
                            }

                            element.internalData
                                .columnFilters[arrDataColumns[0]].push(
                                    {
                                        "text": strWhere,
                                        "name": "doesn't equal " +
                                                "\"" + strValue + "\""
                                    }
                                );

                            dataSELECT(element);

                        } else if (strAnswer === 'Text Filters') {
                            strValue = (strSelection || strDataValue);

                            element.internalEvents.textFilterContextMenu(
                                buttonElement,
                                arrDataColumns[0],
                                strColumn,
                                strValue,
                                // before dialog close callback
                                function (strAnswer) {
                                    // if the unhide dialog wasn't cancelled,
                                    //      close the contextmenu
                                    if (strAnswer !== 'Cancel') {
                                        GS.closeDialog(dialog, 'Force');
                                    }
                                }
                            );

                            event.preventDefault();

                        } else if (strAnswer === 'Toggle Filters On') {
                            element.internalData.columnFilterStatuses[
                                arrDataColumns[0]
                            ] = (
                                'on'
                            );

                            dataSELECT(element);

                        } else if (strAnswer === 'Toggle Filters Off') {
                            element.internalData.columnFilterStatuses[
                                arrDataColumns[0]
                            ] = (
                                'off'
                            );

                            dataSELECT(element);

                        } else if (strAnswer === 'Clear Filters') {
                            element.internalData.columnFilters[
                                arrDataColumns[0]
                            ] = [];
                            element.internalData.columnListFilters[
                                arrDataColumns[0]
                            ] = {};

                            dataSELECT(element);
                        }

                        // we're done with the pixel element
                        // if (element.elems.pixel.parentNode ===
                        //      element.elems.dataViewport) {
                        //     element.elems.dataViewport.removeChild(
                        //         element.elems.pixel
                        //     );
                        // }
                    }
                );
            }
        };

        element.internalEvents.textFilterContextMenu = function (
            buttonElement,
            columnIndex,
            strColumn,
            strValue,
            callback
        ) {
            var templateElement;

            // we want a function specifically for contextmenus,
            //      however, currently we dont have one so we'll
            //      use the GS.openDialogToElement function
            templateElement = document.createElement('template');
            templateElement.setAttribute('data-max-width', '17em');
            templateElement.setAttribute('no-background', '');
            templateElement.setAttribute('data-overlay-close', 'true');
            templateElement.innerHTML = ml(function () {/*
                <gs-page gs-dynamic class="gs-table-contextmenu">
                    <gs-body padded>
                        <center>
                            <i>Check each filter you want to apply.</i><br />
                            <i>
                                Matching values must pass every<br />
                                filter you choose.
                            </i>
                        </center>
                        <table>
                            <tbody>
                                <tr class="fltr-row fltr-eq">
                                    <td>
                                        <gs-checkbox remove-all mini>
                                            &nbsp;Equals</gs-checkbox>
                                    </td>
                                    <td><gs-text mini></gs-text></td>
                                </tr>
                                <tr class="fltr-row fltrn-eq">
                                    <td>
                                        <gs-checkbox remove-all mini>
                                            &nbsp;Doesn't Equal</gs-checkbox>
                                    </td>
                                    <td><gs-text mini></gs-text></td>
                                </tr>
                                <tr class="fltr-row fltr-contain">
                                    <td>
                                        <gs-checkbox remove-all mini>
                                            &nbsp;Contains</gs-checkbox>
                                    </td>
                                    <td><gs-text mini></gs-text></td>
                                </tr>
                                <tr class="fltr-row fltrn-contain">
                                    <td>
                                        <gs-checkbox remove-all mini>
                                            &nbsp;Doesn't Contain</gs-checkbox>
                                    </td>
                                    <td><gs-text mini></gs-text></td>
                                </tr>
                                <tr class="fltr-row fltr-starts">
                                    <td>
                                        <gs-checkbox remove-all mini>
                                            &nbsp;Starts With</gs-checkbox>
                                    </td>
                                    <td><gs-text mini></gs-text></td>
                                </tr>
                                <tr class="fltr-row fltr-ends">
                                    <td>
                                        <gs-checkbox remove-all mini>
                                            &nbsp;Ends With</gs-checkbox>
                                    </td>
                                    <td><gs-text mini></gs-text></td>
                                </tr>
                            </tbody>
                        </table>

                        <!--
                        <gs-checkbox remove-bottom>
                            &nbsp;Equals
                        </gs-checkbox>
                        <gs-checkbox remove-all>
                            &nbsp;Doesn't Equal
                        </gs-checkbox>
                        <gs-checkbox remove-all>
                            &nbsp;Contains
                        </gs-checkbox>
                        <gs-checkbox remove-all>
                            &nbsp;Doesn't Contain
                        </gs-checkbox>
                        <gs-checkbox remove-all>
                            &nbsp;Starts With
                        </gs-checkbox>
                        <gs-checkbox remove-top>
                            &nbsp;Ends With
                        </gs-checkbox>
                        -->
                    </gs-body>
                    <gs-footer>
                        <gs-grid gutter>
                            <gs-block>
                                <gs-button dialogclose>
                                    Cancel
                                </gs-button>
                            </gs-block>
                            <gs-block>
                                <gs-button dialogclose bg-primary>
                                    Apply
                                </gs-button>
                            </gs-block>
                        </gs-grid>
                    </gs-footer>
                </gs-page>
            */
            });

            GS.openDialogToElement(
                buttonElement,
                templateElement,
                'right',
                function () {
                    var dialog = this;
                    var arrElements;
                    var i;
                    var len;

                    // we want save the user a little time, so we'll pre-fill
                    //      the filter value text control
                    arrElements = tblQry(dialog, '.fltr-row gs-text');
                    i = 0;
                    len = arrElements.length;
                    while (i < len) {
                        arrElements[i].value = strValue;

                        i += 1;
                    }

                    //fltr-row fltr-eq
                    //fltr-row fltr-not-eq
                    //fltr-row fltr-contain
                    //fltr-row fltr-not-contain
                    //fltr-row fltr-starts
                    //fltr-row fltr-ends
                },
                // event parameter ignored
                function (ignore, strAnswer) {
                    var dialog = this;
                    var arrRows;
                    var rowClass;
                    var checkElement;
                    var valueElement;
                    var strWhere;
                    var strName;
                    var strWhereValue;
                    var i;
                    var len;

                    // there's extra whitespace around the answer
                    strAnswer = strAnswer.trim();

                    if (strAnswer === 'Apply') {
                        arrRows = tblQry(dialog, '.fltr-row');
                        i = 0;
                        len = arrRows.length;
                        while (i < len) {
                            checkElement = (
                                arrRows[i].children[0].children[0]
                            );
                            valueElement = (
                                arrRows[i].children[1].children[0]
                            );
                            strWhereValue = valueElement.value;

                            // try to save some room in the code,
                            //      shortcut variable
                            rowClass = arrRows[i].classList;

                            strWhere = '';
                            if (checkElement.value === 'true') {
                                if (rowClass.contains('fltr-eq')) {
                                    strWhere = 'CAST(' +
                                            strColumn + ' AS ' +
                                            GS.database.type.text +
                                            ') ' +
                                            '= $$' + strWhereValue + '$$';
                                    strName = 'equals "' + strWhereValue + '"';

                                } else if (rowClass.contains('fltrn-eq')) {
                                    strWhere = 'CAST(' +
                                            strColumn + ' AS ' +
                                            GS.database.type.text +
                                            ') ' +
                                            '!= $$' + strWhereValue + '$$';
                                    strName = 'doesn\'t equal ' +
                                            '"' + strWhereValue + '"';

                                } else if (rowClass.contains('fltr-contain')) {
                                    strWhere = 'CAST(' +
                                            strColumn + ' AS ' +
                                            GS.database.type.text +
                                            ') ' +
                                            'LIKE $$%' + strWhereValue + '%$$';
                                    strName = 'contains ' +
                                            '"' + strWhereValue + '"';

                                } else if (rowClass.contains('fltrn-contain')) {
                                    strWhere = 'CAST(' +
                                            strColumn + ' AS ' +
                                            GS.database.type.text +
                                            ') ' +
                                            'NOT LIKE ' +
                                            '$$%' + strWhereValue + '%$$';
                                    strName = 'doesn\'t ' +
                                            '"' + strWhereValue + '"';

                                } else if (rowClass.contains('fltr-starts')) {
                                    strWhere = 'CAST(' +
                                            strColumn + ' AS ' +
                                            GS.database.type.text +
                                            ') ' +
                                            'LIKE $$' + strWhereValue + '%$$';
                                    strName = 'starts with ' +
                                            '"' + strWhereValue + '"';

                                } else if (rowClass.contains('fltr-ends')) {
                                    strWhere = 'CAST(' +
                                            strColumn + ' AS ' +
                                            GS.database.type.text +
                                            ') ' +
                                            'LIKE $$%' + strWhereValue + '$$';
                                    strName = 'ends ' +
                                            '"' + strWhereValue + '"';
                                }
                            }

                            // if we create a where clause
                            if (strWhere) {
                                element
                                    .internalData
                                    .columnFilters[columnIndex]
                                    .push(
                                        {"text": strWhere, "name": strName}
                                    );
                            }

                            i += 1;
                        }

                        dataSELECT(element);
                    }

                    if (callback) {
                        callback(strAnswer);
                    }
                }
            );
        };

        element.internalEvents.advancedFilterContextMenu = function (
            //parentCell,
            //buttonElement,
            //strAnswer,
            //columnIndex,
            //strColumn,
            //strValue
        ) {
            // version 2
            // ### NEED CODING ### (VERSION 2)
        };

        if (!element.hasAttribute('no-context-menu')) {
            element.elems.dataViewport.addEventListener(
                'contextmenu',
                element.internalEvents.columnContextMenu
            );
        }
    }

    // ############# COLUMN DROPDOWN EVENTS #############
    function unbindColumnDropdown(element) {
        element.removeEventListener(
            'click',
            element.internalEvents.columnDropDown
        );
    }
    function bindColumnDropdown(element) {
        element.internalEvents.columnDropDown = function (event) {
            var target = event.target;
            var parentCell;
            var templateElement;
            var columnNumber;
            var strColumn;
            var columnIndex;
            var strHTML;
            var jsnMousePos;
            var jsnElementPos;
            var intMouseX;
            var intMouseY;

            if (target.classList.contains('header-button')) {
                // we need the mouse position and the element position
                jsnMousePos = GS.mousePosition(event);
                jsnElementPos = GS.getElementOffset(
                    element.elems.root
                );

                // we need the mouse X to be relative to the root element
                intMouseX = (jsnMousePos.left - jsnElementPos.left);

                // we need the mouse Y to be relative to the root element
                intMouseY = (jsnMousePos.top - jsnElementPos.top);

                // move the pixel element to where the mouse is so that we can
                //      position the dialog to it
                element.elems.pixel.style.left = (intMouseX + 'px');
                element.elems.pixel.style.top = (intMouseY + 'px');

                // we need the parent cell to get the display column number
                parentCell = GS.findParentTag(target, 'gs-cell');

                // we need the display column number to get the data column name
                columnNumber = (
                    parseInt(
                        parentCell.getAttribute('data-col-number'),
                        10
                    )
                );

                // we need to know what data column we're dealing with so that
                //      we can get the data column index
                strColumn = (
                    element.internalDisplay.dataColumnName[columnNumber]
                );

                // we need to know what data column index we're dealing with
                //      so that we can apply the sorts and filters
                columnIndex = (
                    element.internalData.columnNames.indexOf(strColumn)
                );

                // build up menu html
                strHTML = '';

                //
                strHTML += (
                    '<gs-button dialogclose remove-bottom' +
                    '            iconleft icon="sort-alpha-asc"' +
                    '            class="button-sort-asc">' +
                    '    Sort A to Z' +
                    '</gs-button>'
                );

                strHTML += (
                    '<gs-button dialogclose remove-all' +
                    '            iconleft icon="sort-alpha-desc"' +
                    '            class="button-sort-desc">' +
                    '    Sort Z to A' +
                    '</gs-button>'
                );

                strHTML += (
                    '<gs-button dialogclose remove-top' +
                    '            iconleft icon="trash-o"' +
                    '            class="button-sort-clear">' +
                    '    Clear Sort' +
                    '</gs-button>'
                );

                strHTML += (
                    '<div class="gs-table-unique-filter-container" hidden>' +
                    '    <hr />' +
                    '    <small><i>Filter By Selection:</i></small>' +
                    '    <div class="gs-table-unique-value-list"></div>' +
                    '    <div class="gs-table-unique-value-list-toolbar">' +
                    (
                        '<gs-button dialogclose remove-right ' +
                                    'inline>Cancel</gs-button>' +
                        '<gs-button dialogclose remove-left ' +
                                    'inline bg-primary>Ok</gs-button>'
                    ) +
                    '    </div>' +
                    '</div>'
                );

                strHTML += '<hr />';

                strHTML += (
                    '<gs-button dialogclose' +
                    '            iconleft icon="trash-o"' +
                    '            class="button-sort-clear">' +
                    '    Clear Filters' +
                    '</gs-button>'
                );

                templateElement = document.createElement('template');
                templateElement.setAttribute('data-max-width', '17em');
                templateElement.setAttribute('data-overlay-close', 'true');
                templateElement.setAttribute('no-background', '');
                templateElement.innerHTML = (
                    '<gs-page gs-dynamic class="gs-table-contextmenu">' +
                    '    <gs-body padded>' +
                    '        ' + strHTML +
                    '    </gs-body>' +
                    '</gs-page>'
                );

                // open the dialog
                GS.openDialogToElement(
                    element.elems.pixel,
                    // element.elems.pixel replaced target.parentNode because
                    //      when the dataviewport rerendered, the element we
                    //      were positioning to disappeared. so, we'll use the
                    //      pixel because we can count on that.
                    templateElement,
                    'down',
                    function () {
                        var dialog = this;

                        var uniqueFilterElement = tblQry(
                            dialog,
                            '.gs-table-unique-filter-container'
                        )[0];
                        var valueListElement = tblQry(
                            dialog,
                            '.gs-table-unique-value-list'
                        )[0];

                        // we want users to be able to choose from a list
                        //      of unique values for the column they chose
                        if (
                            uniqueFilterElement &&
                            valueListElement
                        ) {
                            // we need to get the unique value list
                            dataSELECTcolumnUnique(
                                element,
                                uniqueFilterElement,
                                valueListElement,
                                strColumn
                            );
                        }
                    },
                    // event variable ignored
                    function (ignore, strAnswer) {
                        var dialog = this;
                        var tableElement;
                        var valueListElement = tblQry(
                            dialog,
                            '.gs-table-unique-value-list'
                        )[0];
                        var arrRecords;
                        var arrIncluded;
                        var arrExcluded;
                        var strValue;
                        var bolBlanks;
                        var i;
                        var len;

                        // there is extra whitespace on the answer
                        strAnswer = strAnswer.trim();

                        // if there is a unique value filter list
                        tableElement = valueListElement.children[0];
                        if (
                            tableElement &&
                            tableElement.nodeName === 'GS-TABLE'
                        ) {
                            // if the user chose to commit their choices for
                            //      the table filter
                            if (strAnswer === 'Ok') {
                                // if there are any checked/unchecked values, we
                                //      need to save the changes
                                // because the filter list can get long, we want
                                //      to make sure we create the smallest
                                //      where clause possible. to do this,
                                //      if there are fewer checked items:
                                //          column = checked items
                                //      else (there are fewer unchecked items):
                                //          column != unchecked items
                                // chances are, the user will only include or
                                //      exclude a small number of items, there
                                //      could be a speed problem if the user
                                //      goes and unchecks ~half of the items in
                                //      a column with thousands of unique
                                //      values. but if the user does that,
                                //      there is something wrong with the
                                //      user's workflow, give the poor person
                                //      a search screen for cryin' out loud.
                                arrRecords = tableElement.internalData.records;
                                arrIncluded = [];
                                arrExcluded = [];
                                i = 1; // we want to skip over the "Select All"
                                       //      record
                                len = arrRecords.length;
                                while (i < len) {
                                    strValue = (
                                        arrRecords[i].substring(
                                            arrRecords[i]
                                                .lastIndexOf('\t') + 1
                                        )
                                    );

                                    // we treat the blanks value different
                                    if (strValue === '(blanks)') {
                                        bolBlanks = (arrRecords[i][0] === '-');

                                    } else {
                                        // if this record is unchecked
                                        if (arrRecords[i][0] === '0') {
                                            arrExcluded.push(strValue);

                                        // else, this record is checked
                                        } else {
                                            arrIncluded.push(strValue);
                                        }
                                    }

                                    i += 1;
                                }

                                // default the column filter object to an empty
                                //      state
                                if (
                                    !element.internalData
                                        .columnListFilters[columnIndex]
                                ) {
                                    element.internalData.columnListFilters[
                                        columnIndex
                                    ] = {};
                                }

                                // if inclusion would result in a smaller where
                                if (arrIncluded.length < arrExcluded.length) {
                                    element.internalData.columnListFilters[
                                        columnIndex
                                    ].type = 'inclusion';

                                    element.internalData.columnListFilters[
                                        columnIndex
                                    ].values = (
                                        arrIncluded
                                    );

                                // else, use exclusion where clause
                                } else if (arrExcluded.length > 0) {
                                    element.internalData.columnListFilters[
                                        columnIndex
                                    ].type = 'exclusion';

                                    element.internalData.columnListFilters[
                                        columnIndex
                                    ].values = (
                                        arrExcluded
                                    );
                                } else {
                                    element.internalData.columnListFilters[
                                        columnIndex
                                    ].type = 'exclusion';

                                    element.internalData.columnListFilters[
                                        columnIndex
                                    ].values = (
                                        []
                                    );
                                }

                                element.internalData
                                    .columnListFilters[columnIndex]
                                    .blanks = (bolBlanks || false);

                                // we don't want to delay Garbage Collection,
                                //      empty out the arrays and any unused
                                //      data will become like so much digital
                                //      nothingness.
                                arrRecords = [];
                                arrExcluded = [];
                                arrIncluded = [];

                                // get the new data
                                dataSELECT(element);
                            }

                            // after this callback, the dialog is closed. this
                            //      causes a window resize event. we don't want
                            //      the window event from affecting the table
                            //      after it's been removed from the DOM. so,
                            //      we destroy the element before the gs-table
                            //      is removed.
                            tableElement.destroy();
                        }

                        // waterfall to commit changes
                        if (strAnswer === 'Sort A to Z') {
                            element.internalData
                                .columnOrders[columnIndex] = 'asc';
                            dataSELECT(element);

                        } else if (strAnswer === 'Sort Z to A') {
                            element.internalData
                                .columnOrders[columnIndex] = 'desc';
                            dataSELECT(element);

                        } else if (strAnswer === 'Clear Sort') {
                            element.internalData
                                .columnOrders[columnIndex] = 'neutral';
                            dataSELECT(element);

                        } else if (strAnswer === 'Clear Filters') {
                            element.internalData
                                .columnFilters[columnIndex] = [];
                            element.internalData
                                .columnListFilters[columnIndex] = {};
                            dataSELECT(element);
                        }
                    }
                );
            }
        };

        element.addEventListener(
            'click',
            element.internalEvents.columnDropDown
        );
    }

    // ############# DEVELOPER EVENTS #############
    function unbindDeveloper(element) {
        element.removeEventListener(
            evt.mousedown,
            element.internalEvents.developerMouseDown
        );
    }
    function bindDeveloper(element) {
        element.internalEvents.developerMouseDown = function (event) {
            var bolCMDorCTRL = (event.ctrlKey || event.metaKey);
            var bolShift = (event.shiftKey);
            var strHTML;
            var arrAttr;
            var jsnAttr;
            var i;
            var len;

            if (bolCMDorCTRL && bolShift) {
                event.preventDefault();
                event.stopPropagation();

                strHTML = '';
                arrAttr = element.attributes;
                i = 0;
                len = arrAttr.length;
                while (i < len) {
                    jsnAttr = arrAttr[i];

                    strHTML += (
                        '<b>Attribute "' + encodeHTML(jsnAttr.name) + '":</b>' +
                        '<pre>' + encodeHTML(jsnAttr.value) + '</pre>'
                    );

                    i += 1;
                }

                GS.msgbox('Developer Info', strHTML, ['Ok']);
            }
        };

        element.addEventListener(
            evt.mousedown,
            element.internalEvents.developerMouseDown
        );
    }

    // ############# VISIBILITY POLLING #############
    function unbindVisibilityPolling(element) {
        clearInterval(element.internalTimerIDs.visibilityIntervalID);
    }
    function bindVisibilityPolling(element) {
        element.internalTimerIDs.visibilityIntervalID = setInterval(
            function () {
                var jsnCache;
                var intWidth;
                var intHeight;
                var intFontSize;

                jsnCache = element.internalPollingCache;
                intWidth = element.clientWidth;
                intHeight = element.clientHeight;
                intFontSize = element.elems.fontSizeDetector.clientWidth;

                if (
                    jsnCache.elementWidth !== intWidth ||
                    jsnCache.elementHeight !== intHeight ||
                    jsnCache.fontSize !== intFontSize
                ) {
                    renderScrollDimensions(element);
                    GS.triggerEvent(
                        window,
                        'resize',
                        {"gs": {"source": "gs-table"}}
                    );
                }

                jsnCache.elementWidth = intWidth;
                jsnCache.elementHeight = intHeight;
                jsnCache.fontSize = intFontSize;
            },
            75
        );
    }


    // ############# HIGH LEVEL BINDING #############
    function unbindElement(element) {
        unbindFocus(element);
        unbindScroll(element);
        unbindSelection(element);
        unbindCellResize(element);
        unbindColumnReorder(element);
        unbindUpdate(element);
        unbindInsert(element);
        unbindKey(element);
        unbindHUD(element);
        unbindCopy(element);
        unbindPaste(element);
        unbindContextMenu(element);
        unbindColumnDropdown(element);
        unbindCut(element);
        unbindDeveloper(element);
        unbindVisibilityPolling(element);
    }
    function bindElement(element) {
        bindFocus(element);
        bindScroll(element);
        bindSelection(element);
        bindCellResize(element);
        bindColumnReorder(element);
        bindUpdate(element);
        bindInsert(element);
        bindKey(element);
        bindHUD(element);
        bindCopy(element);
        bindPaste(element);
        bindContextMenu(element);
        bindColumnDropdown(element);
        bindCut(element);
        bindDeveloper(element);
        bindVisibilityPolling(element);
    }

// #############################################################################
// ############################## XTAG DEFINITION ##############################
// #############################################################################

    function elementInserted(element) {
        // if "created"/"inserted" are not suspended: run inserted code
        if (
            !element.hasAttribute('suspend-created') &&
            !element.hasAttribute('suspend-inserted')
        ) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                resolveElementAttributes(element);
                prepareElement(element);
                saveDefaultAttributes(element);
                bindQuerystringEvents(element);
                siphonElement(element);
                renderHUD(element);
                bindElement(element);

                GS.addBeforeUnloadEvent(function () {
                    var arrRetainedColumns = (
                        element
                            .internalData
                            .insertRecordRetainedColumns
                    );
                    if (
                        arrRetainedColumns &&
                        arrRetainedColumns.length > 0 &&
                        document.body.contains(element)
                    ) {
                        return 'There is data in the insert record.';
                    }
                });
                createWebWorker(element);
                //dataSELECT(element);
                GS.triggerEvent(element, 'initialized');
            }
        }
    }

    xtag.register('gs-table', {

// #############################################################################
// ############################# ELEMENT LIFECYCLE #############################
// #############################################################################

        lifecycle: {
            'created': function () {},

            'inserted': function () {
                elementInserted(this);
            },

            'removed': function () {
                this.destroy();
            },

            'attributeChanged': function (strAttrName) {//, oldValue, newValue
                var element = this;

                // if suspend attribute: run inserted event
                if (
                    strAttrName === 'suspend-created' ||
                    strAttrName === 'suspend-inserted'
                ) {
                    elementInserted(element);

                // if the element is not suspended: handle attribute changes
                } else if (
                    !element.hasAttribute('suspend-created') &&
                    !element.hasAttribute('suspend-inserted')
                ) {
                    if (strAttrName === 'value' && element.root) {
                        element.refresh();
                    }
                }
            }
        },

// #############################################################################
// ############################# ELEMENT ACCESSORS #############################
// #############################################################################

        accessors: {
            'selection': {
                'get': function () {
                    return this.internalSelection.ranges;
                }
            },
            'selectedColumns': {
                'get': function () {
                    return this.internalSelection.columns;
                }
            },
            'selectedRecords': {
                'get': function () {
                    return this.internalSelection.rows;
                }
            },
            'data': {
                'get': function () {
                    return {
                        "columns": this.internalData.columnNames,
                        "types": this.internalData.columnTypes,
                        "records": this.internalData.records
                    };
                }
            },
            'value': {
                'get': function () {
                    return this.getAttribute('value');
                },
                'set': function (newValue) {
                    this.setAttribute('value', newValue);
                }
            }
        },

// #############################################################################
// ############################## ELEMENT METHODS ##############################
// #############################################################################

        methods: {
            'destroy': function () {
                var element = this;

                // sometimes, the element is destroyed before it's initialized
                // sometimes, the gs-table gets destroyed multiple times.
                //      we don't want to cause any errors when this happens.
                if (element.elems && element.elems.dataViewport) {
                    // prevent the element from recieving any events
                    unbindElement(element);

                    // destroy the web worker, if there is one
                    if (element.internalWorker.worker) {
                        element.internalWorker.worker.terminate();
                    }

                    // this is the fastest way to destroy all of the data
                    element.internalData = {};
                    element.internalScrollOffsets = {};
                    element.internalEvents = {};
                    element.internalEventCancelled = {};
                    element.internalScroll = {};
                    element.internalTimerIDs = {};
                    element.internalTemplates = {};
                    element.internalDisplay = {};
                    element.internalSelection = {};
                    element.internalClip = {};
                    element.internalWorker = {};
                    element.internalLoaders = {};
                    element.internalResize = {};
                    element.internalReorder = {};

                    // destroy element store
                    element.elems = {};

                    // empty innerHTML
                    element.innerHTML = '';
                }
            },
            'refresh': function () {
                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                dataSELECT(this);
            },
            'triggerRecordInsert': function () {
                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                triggerRecordInsert(this);
            },
            'selectData': function () {
                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                dataSELECT(this);
            },
            'insertData': function (strMode, jsnInsert) {
                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                dataINSERT(this, strMode, jsnInsert);
            },
            'updateData': function (strMode, jsnUpdate) {
                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                dataUPDATE(this, strMode, jsnUpdate);
            },
            'deleteData': function (jsnDeleteData) {
                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                dataDELETE(this, jsnDeleteData);
            },
            'render': function () {
                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                if (
                    !this.hasAttribute('suspend-created') &&
                    !this.hasAttribute('suspend-inserted')
                ) {
                    this.internalDisplay.fullRenderRequired = true;
                    renderScrollDimensions(this);
                    renderHUD(this);
                }
            },
            'toggleFullContainer': function (container, target) {
                var element = this;
                var containerElement;

                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                containerElement = tblElemByID(container);

                if (element.classList.contains('absolute')) {
                    GS.triggerEvent(element, 'closeFullContainer');
                    element.classList.remove('absolute');
                    containerElement.classList.remove('relative');
                    target.setAttribute('icon', 'expand');
                } else {
                    GS.triggerEvent(element, 'openFullContainer');
                    element.classList.add('absolute');
                    containerElement.classList.add('relative');
                    target.setAttribute('icon', 'compress');
                }

                renderScrollDimensions(element);
            },
            'openFullContainer': function (container, target) {
                var element = this;
                var containerElement;

                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                containerElement = tblElemByID(container);

                if (!element.classList.contains('absolute')) {
                    GS.triggerEvent(element, 'openFullContainer');
                    element.classList.add('absolute');
                    containerElement.classList.add('relative');
                    target.setAttribute('icon', 'compress');
                }

                renderScrollDimensions(element);
            },
            'closeFullContainer': function (container, target) {
                var element = this;
                var containerElement;

                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                containerElement = tblElemByID(container);

                if (element.classList.contains('absolute')) {
                    GS.triggerEvent(element, 'closeFullContainer');
                    element.classList.remove('absolute');
                    containerElement.classList.remove('relative');
                    target.setAttribute('icon', 'expand');
                }

                renderScrollDimensions(element);
            },
            //'scrollToColumn': function (columnNumber) {
            //},
            //'scrollToRow': function (rowNumber) {
            //},
            //'scrollToCell': function (rowNumber, columnNumber) {
            //},
            'deleteSelected': function () {
                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                deleteSelectedRecords(this);
            },
            'clearFilter': function () {
                var filter_i;
                var filter_len;

                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                filter_i = 0;
                filter_len = this.internalData.columnFilters.length;
                while (filter_i < filter_len) {
                    this.internalData.columnFilters[filter_i] = [];
                    this.internalData.columnListFilters[filter_i] = {};

                    filter_i += 1;
                }

                // refresh the table
                dataSELECT(this);
            },
            'toggleFullscreen': function (target) {
                var element = this;

                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                // using a class like this doesn't work on iOS (other things
                //      z-index over it), we need to move the element to the
                //      last element in the body and then apply the class.
                // ### NEED CODING ###
                if (element.classList.contains('table-fullscreen')) {
                    GS.triggerEvent(element, 'closeFullScreen');
                    element.classList.remove('table-fullscreen');

                    if (target.getAttribute('icon') === 'close') {
                        target.setAttribute('icon', 'arrows-alt');
                    }
                } else {
                    GS.triggerEvent(element, 'openFullscreen');
                    element.classList.add('table-fullscreen');

                    if (target.getAttribute('icon') === 'arrows-alt') {
                        target.setAttribute('icon', 'close');
                    }
                }
                renderScrollDimensions(element);
            },
            'openFullscreen': function (target) {
                var element = this;

                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                if (!element.classList.contains('table-fullscreen')) {
                    GS.triggerEvent(element, 'openFullscreen');
                    element.classList.add('table-fullscreen');
                    if (target.getAttribute('icon') === 'arrows-alt') {
                        target.setAttribute('icon', 'close');
                    }
                }
                renderScrollDimensions(element);
            },
            'closeFullscreen': function (target) {
                var element = this;

                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                if (element.classList.contains('table-fullscreen')) {
                    GS.triggerEvent(element, 'closeFullScreen');
                    element.classList.remove('table-fullscreen');

                    if (target.getAttribute('icon') === 'close') {
                        target.setAttribute('icon', 'arrows-alt');
                    }
                }
                renderScrollDimensions(element);
            },
            'openPrefs': function (target) {
                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                openSettingsDialog(this, target);
            },
            'sort': function (action) {
                var strNewSort;

                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                if (action === 'asc') {
                    strNewSort = 'asc';
                } else if (action === 'desc') {
                    strNewSort = 'desc';
                } else if (action === 'clear') {
                    strNewSort = 'neutral';
                } else {
                    strNewSort = 'neutral';
                }

                // we need the column orderby array
                var arrColumnOrders = (
                    this.internalData.columnOrders
                );

                // loop through each selected data column and set the orderby
                var arrDataColumns = getSelectedDataColumns(this);
                var i = 0;
                var len = arrDataColumns.length;
                while (i < len) {
                    arrColumnOrders[
                        arrDataColumns[i]
                    ] = strNewSort;

                    i += 1;
                }

                // refresh the table
                dataSELECT(this);
            },
            'openInsertDialog': function () {
                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                openInsertDialog(this);
            },
            'goToLine': function (action) {
                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                var intCurrentRecord = (
                    this.internalSelection.originRecord || 0
                );
                var intMaxRecord = (
                    this.internalData.records.length - 1
                );
                var minColumn = (
                    this.internalDisplay.recordSelectorVisible
                        ? "selector"
                        : 0
                );

                if (action === 'insert') {
                    scrollCellIntoView(this, 'insert', '0', 'top');
                } else {
                    // set current record based on which button was clicked
                    if (action === 'first') {
                        intCurrentRecord = 0;
                    } else if (action === 'previous') {
                        intCurrentRecord -= 1;
                    } else if (action === 'next') {
                        intCurrentRecord += 1;
                    } else if (action === 'plusten') {
                        intCurrentRecord += 10;
                    } else if (action === 'minusten') {
                        intCurrentRecord -= 10;
                    } else if (action === 'last') {
                        intCurrentRecord = intMaxRecord;
                    } else if (typeof action === 'number') {
                        intCurrentRecord = action - 1;
                    } else {
                        intCurrentRecord = parseInt(action, 10) - 1;
                    }

                    //if the new record is past the last record:
                    //      go to last record
                    if (intCurrentRecord > intMaxRecord) {
                        intCurrentRecord = intMaxRecord;
                    }

                    // if the new record is a negative number:
                    //      go to first record
                    if (intCurrentRecord < 0) {
                        intCurrentRecord = 0;
                    }

                    // if there are no records, clear new record
                    if (intMaxRecord === -1) {
                        intCurrentRecord = undefined;
                    }

                    // override all current ranges to select the new record
                    if (intCurrentRecord !== undefined) {
                        this.internalSelection.ranges = [
                            {
                                "start": {
                                    "row": intCurrentRecord,
                                    "column": minColumn
                                },
                                "end": {
                                    "row": intCurrentRecord,
                                    "column": minColumn
                                },
                                "negator": false
                            }
                        ];
                    } else {
                        this.internalSelection.ranges = [];
                    }
                    // render selection and scroll into view
                    renderSelection(this);
                    scrollSelectionIntoView(this, 'top');
                }
            },
            'clearSelection': function () {
                var element = this;

                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                // empty selection array
                element.internalSelection.ranges = [];

                // re-render selection
                renderSelection(element);
            },
            'renderSelection': function () {
                var element = this;

                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                // re-render selection
                renderSelection(element);
            },
            'addSelectionRange': function (
                fromRow,
                fromColumn,
                toRow,
                toColumn,
                bolNegate
            ) {
                var element = this;

                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                // bolNegate must be true or false, default to false
                if (
                    bolNegate === undefined ||
                    typeof bolNegate !== 'boolean'
                ) {
                    bolNegate = false;
                }

                // create range JSON and append to selections
                element.internalSelection.ranges.push({
                    "start": {
                        "row": fromRow,
                        "column": fromColumn
                    },
                    "end": {
                        "row": toRow,
                        "column": toColumn
                    },
                    "negator": false
                });

                // re-render selection
                renderSelection(element);
            },
            'getCopyStrings': function () {
                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                return getCopyStrings(this);
            },
            'updateDialog': function (event) {
                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                this.internalEvents.updateDialog(event);
            },
            // need to refactor hide/show column, too much duplicated code
            // ### NEED CODING ###
            'hideColumn': function (indexOrName) {
                var element = this;
                var columnIndex = null;
                var i;
                var len;
                var arrDataCols;
                var arrColNames;

                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                // if we have a number, we can use that as the index
                if (
                    typeof indexOrName === 'number' ||
                    !isNaN(parseInt(indexOrName, 10))
                ) {
                    columnIndex = parseInt(indexOrName, 10);

                // if the given value is a string, we need to find the column
                //      index based on that name
                } else if (typeof indexOrName === 'string') {
                    arrDataCols = element.internalDisplay.dataColumnName;
                    arrColNames = element.internalDisplay.columnPlainTextNames;
                    i = 0;
                    len = arrDataCols.length;
                    while (i < len) {
                        if (
                            arrDataCols[i] === indexOrName ||
                            arrColNames[i] === indexOrName
                        ) {
                            columnIndex = i;
                            break;
                        }

                        i += 1;
                    }

                    // if we didn't find the column, error
                    if (columnIndex === null) {
                        throw 'GS-TABLE Error: hideColumn method error. ' +
                                'Unable to find a column with the name "' +
                                indexOrName + '". We only check the text ' +
                                'from the header and the [column] attribute ' +
                                'from inside the row cells.';
                    }

                // else, error
                } else {
                    throw 'GS-TABLE Error: hideColumn method error. The ' +
                            'first parameter must be a column index or a ' +
                            'column name';
                }

                // set width to zero to hide
                element.internalDisplay.columnWidths[columnIndex] = 0;

                // render
                element.internalDisplay.fullRenderRequired = true;
                renderScrollDimensions(element);
                //renderLocation(element);
            },
            'showColumn': function (indexOrName) {
                var element = this;
                var columnIndex = null;
                var i;
                var len;
                var arrDataCols;
                var arrColNames;

                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                // if we have a number, we can use that as the index
                if (
                    typeof indexOrName === 'number' ||
                    !isNaN(parseInt(indexOrName, 10))
                ) {
                    columnIndex = parseInt(indexOrName, 10);

                // if the given value is a string, we need to find the column
                //      index based on that name
                } else if (typeof indexOrName === 'string') {
                    arrDataCols = element.internalDisplay.dataColumnName;
                    arrColNames = element.internalDisplay.columnPlainTextNames;
                    i = 0;
                    len = arrDataCols.length;
                    while (i < len) {
                        if (
                            arrDataCols[i] === indexOrName ||
                            arrColNames[i] === indexOrName
                        ) {
                            columnIndex = i;
                            break;
                        }

                        i += 1;
                    }

                    // if we didn't find the column, error
                    if (columnIndex === null) {
                        throw 'GS-TABLE Error: showColumn method error. ' +
                                'Unable to find a column with the name "' +
                                indexOrName + '". We only check the text ' +
                                'from the header and the [column] attribute ' +
                                'from inside the row cells.';
                    }

                // else, error
                } else {
                    throw 'GS-TABLE Error: showColumn method error. The ' +
                            'first parameter must be a column index or a ' +
                            'column name';
                }

                // set width to zero to hide
                element.internalDisplay.columnWidths[columnIndex] = (
                    element.internalDisplay.defaultColumnWidths[columnIndex]
                );

                // render
                element.internalDisplay.fullRenderRequired = true;
                renderScrollDimensions(element);
                //renderLocation(element);
            },
            'paste': function (strPasteString) {
                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                usePasteString(this, strPasteString);
            },
            'resizeAllColumns': function () {
                var element = this;
                var arrIndexes = [];
                var i;
                var len;

                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                i = 0;
                len = element.internalDisplay.columnPlainTextNames.length;
                while (i < len) {
                    arrIndexes.push(i);
                    i += 1;
                }

                resizeColumnsToContent(element, arrIndexes);
            },
            'addFilter': function (filterColumn, filterType, filterValue) {
                var element = this;
                var columnIndex;
                var strWhere;
                var strName;

                // if the table element has been destroyed, stop execution
                if (!this.internalData || !this.internalData.columnNames) {
                    return;
                }

                // filterType must be one of these values: (defaults to equals)
                //      'contains', 'notcontains',
                //      'starts', 'notstarts',
                //      'ends', 'notends',
                //      'equals', 'notequals',
                //      'greaterthan', 'notgreaterthan',
                //      'lessthan', 'notlessthan'
                if (
                    !(/^(contains|starts|ends)$/gi).test(filterType) &&
                    !(/^(equals|greaterthan|lessthan)$/gi).test(filterType) &&
                    !(/^(notcontains|notstarts|notends)$/gi).test(filterType) &&
                    !(/^(notequals|notgreaterthan)$/gi).test(filterType) &&
                    !(/^(notlessthan)$/gi).test(filterType)
                ) {
                    throw 'GS-TABLE Error: invalid filter type given to ' +
                            'ELEMENT.addFilter(filterColumn, filterType, ' +
                            'filterValue). Given filter type was ' +
                            '"' + filterType + '", must be "contains", ' +
                            '"starts", "ends", "equals", "greaterthan", ' +
                            '"lessthan", "notcontains", "notstarts", ' +
                            '"notends", "notequals", "notgreaterthan" ' +
                            'or "notlessthan".';
                }

                // we want to use the filterType in an if statement, let's
                //      lowercase it to make comparisons easier
                filterType = filterType.toLowerCase();

                // filterValue must not be empty: error if nothing provided
                if (filterValue === undefined) {
                    throw 'GS-TABLE Error: no filter value given to ' +
                            'ELEMENT.addFilter(filterColumn, filterType, ' +
                            'filterValue)';
                }

                // if value provided: cast to JS string to prevent type issues
                filterValue = filterValue.toString();

                // equals (TEXT)
                if (filterType === 'equals') {
                    strWhere = 'CAST(' +
                            filterColumn + ' AS ' +
                            GS.database.type.text +
                            ') ' +
                            '= $$' + filterValue + '$$';
                    strName = 'equals' +
                            ' "' + filterValue + '"';

                // not equals (TEXT)
                } else if (filterType === 'notequals') {
                    strWhere = 'CAST(' +
                            filterColumn + ' AS ' +
                            GS.database.type.text +
                            ') ' +
                            '!= $$' + filterValue + '$$';
                    strName = 'doesn\'t equal' +
                            ' "' + filterValue + '"';

                // contains (TEXT)
                } else if (filterType === 'contains') {
                    strWhere = 'CAST(' +
                            filterColumn + ' AS ' +
                            GS.database.type.text +
                            ') ' +
                            'LIKE $$%' + filterValue + '%$$';
                    strName = 'contains' +
                            ' "' + filterValue + '"';

                // doesn't contain (TEXT)
                } else if (filterType === 'notcontains') {
                    strWhere = 'CAST(' +
                            filterColumn + ' AS ' +
                            GS.database.type.text +
                            ') ' +
                            'NOT LIKE ' +
                            '$$%' + filterValue + '%$$';
                    strName = 'doesn\'t contain' +
                            ' "' + filterValue + '"';

                // starts with (TEXT)
                } else if (filterType === 'starts') {
                    strWhere = 'CAST(' +
                            filterColumn + ' AS ' +
                            GS.database.type.text +
                            ') ' +
                            'LIKE $$' + filterValue + '%$$';
                    strName = 'starts with' +
                            ' "' + filterValue + '"';

                // doesn't start with (TEXT)
                } else if (filterType === 'notstarts') {
                    strWhere = 'CAST(' +
                            filterColumn + ' AS ' +
                            GS.database.type.text +
                            ') ' +
                            'NOT LIKE $$' + filterValue + '%$$';
                    strName = '' +
                            ' "' + filterValue + '"';

                // ends with (TEXT)
                } else if (filterType === 'ends') {
                    strWhere = 'CAST(' +
                            filterColumn + ' AS ' +
                            GS.database.type.text +
                            ') ' +
                            'LIKE $$%' + filterValue + '$$';
                    strName = 'ends with' +
                            ' "' + filterValue + '"';

                // doesn't end with (TEXT)
                } else if (filterType === 'notends') {
                    strWhere = 'CAST(' +
                            filterColumn + ' AS ' +
                            GS.database.type.text +
                            ') ' +
                            'NOT LIKE $$%' + filterValue + '$$';
                    strName = 'doesn\'t end with' +
                            ' "' + filterValue + '"';

                // greaterthan (INTEGER/NUMERIC)
                } else if (filterType === 'greaterthan') {
                    strWhere = (
                        filterColumn + ' > ' + filterValue
                    );
                    strName = 'greater than' +
                            ' "' + filterValue + '"';

                // not greaterthan (INTEGER/NUMERIC)
                } else if (filterType === 'notgreaterthan') {
                    strWhere = (
                        filterColumn + ' <= ' + filterValue
                    );
                    strName = 'not greater than' +
                            ' "' + filterValue + '"';

                // lessthan (INTEGER/NUMERIC)
                } else if (filterType === 'lessthan') {
                    strWhere = (
                        filterColumn + ' < ' + filterValue
                    );
                    strName = 'less than' +
                            ' "' + filterValue + '"';

                // not lessthan (INTEGER/NUMERIC)
                } else if (filterType === 'notlessthan') {
                    strWhere = (
                        filterColumn + ' >= ' + filterValue
                    );
                    strName = 'not less than' +
                            ' "' + filterValue + '"';
                }

                // turn the updated column name into a column index so that
                //      we can fetch the old data from the data
                columnIndex = (
                    element.internalData.columnNames.indexOf(filterColumn)
                );

                // if we were able to create a where, push it to the filter
                //      list
                if (strWhere) {
                    element.internalData
                        .columnFilters[columnIndex].push(
                            {
                                "text": strWhere,
                                "name": strName
                            }
                        );

                    // master, why didn't you refresh the table after a where
                    //      was created?
                    // young grasshopper, you must think of the developer who
                    //      will use this table, what if he were to add three
                    //      filters, one right after the other? in order to
                    //      prevent speed issues we must make him refresh the
                    //      table.

                // else, warn about invalid where
                } else {
                    console.warn('GS-TABLE Warning: Unable to create where' +
                            'clause.\n' +
                            'Here are the parameters that failed:\n' +
                            '\tfilterColumn:   "' + filterColumn + '"\n' +
                            '\tfilterType:     "' + filterType + '"\n' +
                            '\tfilterValue:    "' + filterValue + '"');
                }
            }
        }
    });
});


// #############################################################################
// ################################# OLD NOTES #################################
// #############################################################################

/*
new datasheet
    select, insert, update,
        delete, copy, paste and selection events (prevent default)
    programatic select, insert, update,
        delete, copy, paste and selection (events marked as programatic)

    fixed headers/record selectors
    ace scrolling
    insert record

    data source is not required (column list is required if no data source)

    header, record, insert record templating (dot.js)

    placeholder for null values
    value to set value as null

    headers, record selectors, insert record are all optional

    copy settings (
        headers always|never|whenselected
        record selectors always|never|whenselected
        quote char
        quote when never|strings|always
        record delim char
        cell delim char
        null value string
    )
    no more table element

    selection is stored as ranges
    backwards compatible attributes (transfer to new names and warn)


element name:
    <gs-table></gs-table>

helper elements:
    <gs-cell></gs-cell>

attributes:
    pk
    lock
    seq
    cols (required if no src)
    src
    where
    session-filter (where clause that can be overridden by the user)
    ord
    limit
    offset
    column
    child-column
    qs
    refresh-on-querystring-values
    refresh-on-querystring-change

    reflow-at (future)
    scroll-past-bottom
        (allows you to scroll until only the bottom record is seen)
    scroll-to-bottom (scrolls all the way down on initial load)
    no-insert-scroll (disables scrolling all the way down after insert)
    expand-to-content

    no-hudpaginate
    no-hudrefresh
    no-huddelete
    no-filter

    suspend-created
    suspend-inserted

    no-header
    no-record-selector
    no-selection

    null-string (defaults to "")
    null-set-string (defaults to null-string attribute)

    no-resize-column
    no-resize-record

    default-cell-height (pixels, defaults if not present)
    default-cell-width (pixels, defaults if not present)

    socket (name of a property stored on the GS object, needs to be a socket)

    copy-header           always|never|selected
    copy-selectors        always|never|selected
    copy-quote-char       text
    copy-escape-char      text
    copy-quote-when       never|strings|always|delimiter-in-content
    copy-delimiter-record text
    copy-delimiter-cell   text
    copy-null-cell        text

templates: (all are dot.js templated before use)
    for="hud" (snippet contains default
                    insert/update/delete/refresh/filter/paginate elements)
    for="header-record"
        <gs-cell>HEADERTEXT</gs-cell>
    for="data-record"
        <gs-cell header="HEADERTEXT">
            <gs-text mini column="COLUMNNAME"></gs-text>
        </gs-cell>
    for="insert-record"
        <gs-cell header="HEADERTEXT" target="COLUMNNAME"></gs-cell>
    for="insert-dialog"

accessors:
    selection (contains JS array of selection ranges)
    data (contains TSV of all data)
    value (value attribute)

events:
    before_select (contains TSV of selection under "records" key)
    before_insert (contains TSV of insert under "records" key)
    before_update (contains TSV of old/new under "records" key ("old", "new"))
    before_delete (contains TSV of delete under "records" key)
    before_selection (contains TSV of selection ranges under "selection" key)

    after_select (contains TSV of selection under "records" key)
    after_insert (contains TSV of insert under "records" key)
    after_update (contains TSV of old/new under "records" key ("old", "new"))
    after_delete (contains TSV of delete under "records" key)
    after_selection (contains TSV of selection ranges under "selection" key)

    insert_dialog_open (event.relatedTarget = insert dialog)
    before_copy (preventDefault will prevent copy)
    copy
    paste

methods:
    refresh
    render
    scrollToIndex(cell_number, record_number)
    clearSelection()
    addSelectionRange(
        fromCell_number,
        fromRecord_number,
        toCell_number,
        toRecord_number,
        bolNegate (default false)
    )
    getCopyString(
        strMimeType text|html
    )
    paste(paste_string)
    filter(
        filterColumn,
        filterType contains|starts|ends|equals|greaterthan|lessthan,
        showIfMatch true|false,
        filterValue
    )
    selectData
    insertData
    updateData
    deleteData

click behavior:
    if click results in focused input/textarea
            and start/end locations are in the same place:
        select all control contents
    if not no-filter and click results in focused control: filter popup tooltip

mousedown-drag:
    if shift:
        move latest selection range's endpoint
    if no shift:
        clear all selections
        start new selection
    if command/control:
        start new selection
        if selection started on an already selected cell:
            selection is a negator selection

selection behavior:
    if selection origin and end is on a record selector:
        select entire records
    if selection origin and end is on a header selector:
        select entire columns
    if selection origin starts and ends on the top-left selector:
        select all cells
    if selection endpoint is off-screen:
        scroll it to middle

focus behavior:
    cell/record focus location is saved
        (if cell is visible after a render, focus into it)
        (removed on blur)
    on selection with no focused control: focus hidden control
    on mousedown inside the element (on unfocusable element):
        focus hidden control
    on blur after cell change: cause update
    on focus of single cell: set selection to focused cell

copy behavior:
    never copy insert record
    on copy event and hidden focus control is focused:
        copy to html mime type (using applicable copy attributes)
        copy to text mime type (using applicable copy attributes)
    if a record is not selected: no space is made for it in the copy
    if a column is not selected: no space is made for it in the copy

key behavior:
    arrowing around selects the cell, doesn't focus the control
    return on selection focuses selection origin cell control
    "delete"/"forward delete" when no control is focused causes record delete
    on return after cell change: cause update

    if arrow:
        if shift:
            "selection" means selection end of latest selection range
        if no shift:
            clear all selection ranges
            "selection" means selection origin/end of new selection range

        if all contents selected because of arrow
            or
        if cursor is at boundary in the direction of the arrow:
            if there is a cell in the direction of the arrow:
                move selection in direction of arrow
            else:
                if right at last cell of record: first cell of next record
                if right at last cell of table: first cell of table
                if left at first cell of record: last cell of previous record
                if left at first cell of table: last cell of table
                if up at first cell of column: previous column of bottom record
                if down at last cell of column: next column of first record

scrollbar behavior:
    whenever the record count is changed: the scrollbar is rerendered
    the scrollbar has a maximum range, stop growing around this height
    if scrollbar is past max height, you'll need to translate the top
        into (1px of scroll height will = >1px of motion)
    after scroll: rerender location
    phone scroll: no scrollbar, needs elastic motion
    scroll render:
        if scrollTop is >0     header shadow
        if scrollLeft is >0    record selector shadow
        if scrollBottom is >0  insert record shadow
        if scrollRight is >0   right side shadow

loader behavior:
    when enabled: a small spinner shows at the top-right of the data area

delete behavior:
    always asks if you're sure
    after success:
        remove record from internal data,
        render current location,
        clear selection range if it's now out of bounds
    during delete: enable element loader
    after delete is initiated: record is no longer clickable

insert behavior:
    asks if you're sure only when inserting multiple records (using paste)
    after success:
        append new data to the end of internal data,
        scroll to bottom,
        render current location,
        clear selection range
    during insert: enable element loader

update behavior:
    asks if you're sure only when updating multiple records (using paste)
    after success:
        update whole record in internal data,
        render current location,
        clear selection range
    during update: enable element loader
    if an update is caused while another update is still resolving: add to queue

select behavior:
    first load: if scroll-to-bottom: scroll to reveal bottom record
    reload: always returns to previous scroll/focus/textselection situation
    during load: enable element loader
*/
//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, shimmed
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    "use strict";
    addSnippet('<gs-text>', '<gs-text>', 'gs-text column="${1:name}"></gs-text>');
    addSnippet(
        '<gs-text> With Label',
        '<gs-text>',
        (
            'label for="${1:text-insert-account-name}">${2:Account Name}:</label>\n' +
            '<gs-text id="${1:date-insert-account-name}" column="${3:account_name}"></gs-text>'
        )
    );
    addElement('gs-text', '#controls_text');

    window.designElementProperty_GSTEXT = function (selectedElement) {
        addGSControlProps();
        addText('V', 'Placeholder', 'placeholder');
        addText('D', 'Encrypted', 'encrypted');
        addText('D', 'Max-length', 'max-length');
        addCheck('V', 'Disable Max-length auto-tab', 'no-auto-tab', 'true');
        addAutocompleteProps();
        addCheck('V', 'Show Caps Lock', 'show-caps', 'false');
        addFocusEvents();
        addFlexProps();
        addText('O', 'Column In QS', 'qs');
    };
});
// function getCaps() {
//     var event = document.createEvent("KeyboardEvent");
//   //console.log(event, event.getModifierState('CapsLock'));
//     var caps = event.getModifierState && event.getModifierState( 'CapsLock' );
//     window.caps = caps;
//   //console.log(window.caps);
// }

window.addEventListener('keydown', function (event) {
    window.caps = event.getModifierState && event.getModifierState( 'CapsLock' );
    //console.log(caps);
});

window.addEventListener('try-password', function (event) {
    var elemsToRetry = xtag.query(document, 'gs-text[encrypted="' + event.keyVariable + '"], gs-memo[encrypted="' + event.keyVariable + '"]');
  //console.log(elemsToRetry);
    var i = 0, len = elemsToRetry.length;
    while (i < len) {
        elemsToRetry[i].syncView();
        i++;
    }
});


document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();
        event.target.parentNode.syncGetters();//iphone sometimes doesn't do a key like with time wheels

        GS.triggerEvent(event.target.parentNode, 'change');

        return false;
    }

    function focusNextElement() {
        //add all elements we want to include in our selection
        var focussableElements = 'a:not([disabled]), button:not([disabled]), input:not([disabled]), gs-button:not([disabled])';
        if (document.activeElement) {
            var focussable = Array.prototype.filter.call(document.querySelectorAll(focussableElements),
            function (element) {
                //check for visibility while always include the current activeElement 
                return element.offsetWidth > 0 || element.offsetHeight > 0 || element === document.activeElement
            });
            var index = focussable.indexOf(document.activeElement);
            if(index > -1) {
               var nextElement = focussable[index + 1] || focussable[0];
               nextElement.focus();
            }                    
        }
    }

    function checkMaxLength(event) {
        var element = event.target;
        if (element.classList.contains('control')) {
            element = GS.findParentTag(element, 'gs-text');
        }
        element.syncGetters();
        if (element.hasAttribute('max-length') && element.value.length >= element.getAttribute('max-length')) {
            if (element.value.length > element.getAttribute('max-length')) {
                element.value = element.value.substring(0,element.getAttribute('max-length'));
            }
            if (!element.hasAttribute('no-auto-tab') && element.control.hasAttribute('tabindex') && xtag.query(document, '[tabindex="' + (parseInt(element.control.getAttribute('tabindex'), 10) + 1) + '"]').length > 0) {
                xtag.query(document, '[tabindex="' + (parseInt(element.control.getAttribute('tabindex'), 10) + 1) + '"]')[0].focus();
            // find next focusable element
            } else if (!element.hasAttribute('no-auto-tab')) {
                focusNextElement();
            }
        }
    }

    function keydownFunction(event) {
        var element = event.target;
        if (element.classList.contains('control')) {
            element = GS.findParentTag(element, 'gs-text');
        }
        element.syncGetters();
        if (!element.hasAttribute('defer-insert')) {
            element.value = element.getAttribute('value');
        } else {
            element.value = CryptoJS.AES.encrypt(element.control.value, (window[element.getAttribute('encrypted')] || ''));
        }
    }
    
    function CapsLock(event) {
        var element = event.target;
        if (element.classList.contains('control')) {
            element = GS.findParentTag(element, 'gs-text');
        }
        var temp_caps = event.getModifierState && event.getModifierState( 'CapsLock' );
        //console.log(temp_caps);
        if (temp_caps) {
            element.classList.add('caps');
        } else {
            if (element.classList.contains('caps')) {
                element.classList.remove('caps');
            }
        }
    }

    function focusFunction(event) {
        // getCaps();
        //console.log(window.caps);
        var element = event.target;
        if (element.classList.contains('focus')) {
            return;
        }
        if (element.hasAttribute('defer-insert')) {
            if (focus_event.target.classList.contains('control')) {
                element = element.parentNode.parentNode;
            }
            element.removeEventListener('focus', focusFunction);
            element.classList.add('focus');
            element.addControl();
            if (element.control.value && element.control.value.length > 0) {
                if (element.bolSelect) {
                    element.control.setSelectionRange(0, element.control.value.length);
                } else {
                    element.control.setSelectionRange(element.control.value.length, element.control.value.length);
                }
            }
            element.bolSelect = true;
        } else {
            element = element.parentNode;
            GS.triggerEvent(event.target.parentNode, 'focus');
            event.target.parentNode.classList.add('focus');
        }
        if (element.hasAttribute('encrypted') && element.control) {
            element.control.addEventListener('keydown', keydownFunction);
        }
        if (window.caps) {
            element.classList.add('caps');
        }
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        var element = event.target.parentNode;
        GS.triggerEvent(event.target.parentNode, 'blur');
        event.target.parentNode.classList.remove('focus');
        if (event.target.parentNode.hasAttribute('defer-insert')) {
            event.target.parentNode.removeControl();
        }
        if (element.hasAttribute('encrypted')) {
            event.target.removeEventListener('keydown', keydownFunction);
        }
        //remove icon
        if (element.classList.contains('caps')) {
            element.classList.remove('caps');
        }
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseout);
        event.target.parentNode.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseover);
        event.target.parentNode.classList.add('hover');
    }

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function createPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.value = strQSValue;
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = null;
            }
        }
    }

    function findFor(element) {
        var forElem;
        //console.log(element, element.previousElementSibling)
        if (element.previousElementSibling && element.previousElementSibling.tagName.toUpperCase() == 'LABEL'
            && element.previousElementSibling.hasAttribute('for')
            && element.previousElementSibling.getAttribute('for') == element.getAttribute('id')
        ) {
            forElem = element.previousElementSibling;
        } else if (xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]').length > 0) {
            forElem = xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]')[0];
        }
        //console.log(forElem);
        if (forElem) {
            forElem.setAttribute('for', element.getAttribute('id') + '_control');
            if (element.control) {
                element.control.setAttribute('id', element.getAttribute('id') + '_control');
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }
            }
        }
        
        /*
            if (element.hasAttribute('id')) {
                findFor(element);
            }
        // please ensure that if the element has an id it is given an id
                if (element.hasAttribute('id')) {
                    element.control.setAttribute('id', element.getAttribute('id') + '_control');
                }
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }
        */
    }

    function elementInserted(element) {
        if (element.hasAttribute('encrypted') && !window[element.getAttribute('encrypted')] && !window['getting' + element.getAttribute('encrypted')]) {
            window['getting' + element.getAttribute('encrypted')] = true;
            GS.triggerEvent(element, 'password-error', {'reason': 'no', 'keyVariable': element.getAttribute('encrypted')});
        }
        if (element.hasAttribute('defer-insert')) {
            // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
            if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                // if this is the first time inserted has been run: continue
                if (!element.inserted) {
                    element.inserted = true;
                    element.internal = {};
                    saveDefaultAttributes(element);
    
                    if (!element.hasAttribute('tabindex')) {
                        element.setAttribute('tabindex', '0');
                    }
                    element.bolSelect = true;

                    if (element.getAttribute('value')) {
                        if (element.hasAttribute('encrypted') && window[element.getAttribute('encrypted')]) {
                            element.innerHTML = CryptoJS.AES.decrypt(element.getAttribute('value'), (window[element.getAttribute('encrypted')] || '')).toString(CryptoJS.enc.Utf8);
                            element.syncGetters();
                        } else {
                            element.innerHTML = element.getAttribute('value');
                            element.syncGetters();
                        }
                    } else if (element.hasAttribute('placeholder')) {
                        element.innerHTML = '<span class="placeholder">' + element.getAttribute('placeholder') + '</span>';
                    }
    
                    element.addEventListener('keydown', CapsLock);
                    element.addEventListener('focus', focusFunction);
                    element.addEventListener('keyup', checkMaxLength);
                    if (evt.touchDevice) {
                        element.addEventListener(evt.click, focusFunction);
                        element.addEventListener(evt.mousedown, function (event) {
                            //alert(event.touches[0].clientX);
                            element.startX = event.touches[0].clientX;
                            element.startY = event.touches[0].clientY;
                            element.addEventListener('touchmove', function (event) {
                                //alert(event.touches[0].clientX);
                                element.lastX = event.touches[0].clientX;
                                element.lastY = event.touches[0].clientY;
                                
                            });
                        });
                        element.addEventListener(evt.mouseup, function (event) {
                            var element = event.target;
                            //alert(element.outerHTML);
                            //alert(element.startX + ' : ' + element.lastX + ' : ' + element.startY + ' : ' + element.lastY);
                            if (element.lastX && element.lastY &&
                                (parseInt(element.lastX, 10) > (parseInt(element.startX, 10) + 10) ||
                                parseInt(element.lastX, 10) < (parseInt(element.startX, 10) - 10) ||
                                parseInt(element.lastY, 10) > (parseInt(element.startY, 10) + 10) ||
                                parseInt(element.lastY, 10) < (parseInt(element.startY, 10) - 10))
                            ) {
                            } else {
                                focusFunction(event);
                            }
                            
                            /*//if event.target is the control
                            if (event.target.tagName === 'GS-TEXT') {
                                var element = event.target;
                                //alert(event.target.outerHTML);
                                //focus it
                                focusFunction(event);
                                //if we focused it prevent click event from happening
                                if (document.activeElement == element.control) {
                                    event.stopImmediatePropagation();
                                    event.stopPropagation();
                                    event.preventDefault();
                                }
                                //else the click event happens trying again
                            }*/
                        });
                    }
                    // bind/handle query string
                    if (element.getAttribute('qs')) {
                        createPushReplacePopHandler(element);
                        window.addEventListener('pushstate', function () {
                            createPushReplacePopHandler(element);
                        });
                        window.addEventListener('replacestate', function () {
                            createPushReplacePopHandler(element);
                        });
                        window.addEventListener('popstate', function () {
                            createPushReplacePopHandler(element);
                        });
                    }
                }
            }
        } else {
            // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
            if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                // if this is the first time inserted has been run: continue
                if (!element.inserted) {
                    element.inserted = true;
                    element.internal = {};
                    saveDefaultAttributes(element);
    
                    //var strQSValue;
    
                    // handle control
                    element.handleContents();
    
                    // fill control
                    element.syncView();
    
                    // bind/handle query string
                    if (element.getAttribute('qs')) {
                        //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
    
                        //if (strQSValue !== '' || !element.getAttribute('value')) {
                        //    element.value = strQSValue;
                        //}
                        createPushReplacePopHandler(element);
                        window.addEventListener('pushstate', function () {
                            createPushReplacePopHandler(element);
                        });
                        window.addEventListener('replacestate', function () {
                            createPushReplacePopHandler(element);
                        });
                        window.addEventListener('popstate', function () {
                            createPushReplacePopHandler(element);
                        });
                    }
    
                    // if this element is empty when it is inserted: initalize
                    if (element.innerHTML.trim() === '') {
                        // handle control
                        element.handleContents();
    
                        // fill control
                        element.syncView();
                    }
                }
            }
        }
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            if (element.hasAttribute('id')) {
                //console.log('running');
                findFor(element);
            }
        }
    }

    xtag.register('gs-text', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;
                if (element.hasAttribute('defer-insert')) {
                    if (element.control) {
                        // if "suspend-created" has been removed: run created and inserted code
                        if (strAttrName === 'suspend-created' && newValue === null) {
                            elementCreated(element);
                            elementInserted(element);
    
                        // if "suspend-inserted" has been removed: run inserted code
                        } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                            elementInserted(element);
    
                        } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                            var currentValue;
    
                            if (strAttrName === 'disabled' || strAttrName === 'readonly') {
                            } else if (strAttrName === 'value' && element.initalized) {
                                if (element.hasAttribute('encrypted')) {
                                    currentValue = CryptoJS.AES.encrypt(element.control.value, (window[element.getAttribute('encrypted')] || ''));
                                } else {
                                    currentValue = element.control.value;
                                }
    
                                // if there is a difference between the new value in the
                                //      attribute and the valued in the front end: refresh the front end
                                newValue = this.hasAttribute('uppercase') ? newValue.toUpperCase() : newValue;
                                currentValue = this.hasAttribute('uppercase') ? currentValue.toUpperCase() : currentValue;
                                if (newValue !== currentValue) {
                                    element.syncView();
                                }
                            }
                            var arrPassThroughAttributes = [
                                    'placeholder', 'name', 'maxlength', 'autocorrect',
                                    'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                                    'readonly', 'disabled'
                                ];
                            if (element.hasAttribute(strAttrName) && arrPassThroughAttributes.indexOf(strAttrName) !== -1) {
                                element.control.setAttribute(strAttrName, newValue);
                            }
                            if (!element.hasAttribute(strAttrName) && element.control.hasAttribute(strAttrName) && arrPassThroughAttributes.indexOf(strAttrName) !== -1) {
                                element.control.removeAttribute(strAttrName);
                            }
                        }
                    }
                } else {
                    // if "suspend-created" has been removed: run created and inserted code
                    if (strAttrName === 'suspend-created' && newValue === null) {
                        elementCreated(element);
                        elementInserted(element);
    
                    // if "suspend-inserted" has been removed: run inserted code
                    } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                        elementInserted(element);
    
                    } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                        var currentValue;
    
                        if (strAttrName === 'disabled' || strAttrName === 'readonly') {
                            // handle control
                            element.handleContents();
    
                            // fill control
                            element.syncView();
    
                        } else if (strAttrName === 'value' && element.initalized) {
                            //if (element.hasAttribute('disabled')) {
                            //    currentValue = element.innerHTML;
                            //} else {
                                if (element.hasAttribute('encrypted')) {
                                    currentValue = CryptoJS.AES.encrypt(element.control.value, (window[element.getAttribute('encrypted')] || ''));
                                } else {
                                    currentValue = element.control.value;
                                }
                            //}
    
                            // if there is a difference between the new value in the
                            //      attribute and the valued in the front end: refresh the front end
                            newValue = this.hasAttribute('uppercase') ? newValue.toUpperCase() : newValue;
                            currentValue = this.hasAttribute('uppercase') ? currentValue.toUpperCase() : currentValue;
                            if (newValue !== currentValue) {
                                element.syncView();
                            }
                        }
                        var arrPassThroughAttributes = [
                                'placeholder', 'name', 'maxlength', 'autocorrect',
                                'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                                'readonly', 'disabled'
                            ];
                        if (element.control) {
                            if (element.hasAttribute(strAttrName) && arrPassThroughAttributes.indexOf(strAttrName) !== -1) {
                                element.control.setAttribute(strAttrName, newValue);
                            }
                            if (!element.hasAttribute(strAttrName) && element.control.hasAttribute(strAttrName) && arrPassThroughAttributes.indexOf(strAttrName) !== -1) {
                                element.control.removeAttribute(strAttrName);
                            }
                        }
                    }
                }
            }
        },
        events: {
            // on keydown and keyup sync the value attribute and the control value
            'keydown': function (event) {
                var element = this;
                if (!element.hasAttribute('readonly') && !element.hasAttribute('disabled')) {
                    element.syncGetters();
                }
            },
            'keyup': function () {
                var element = this;
                if (!element.hasAttribute('readonly') && !element.hasAttribute('disabled')) {
                    element.syncGetters();
                }
            }
        },
        accessors: {
            value: {
                // get value straight from the input
                // I (Nunzio) changed this on 2022-02-26
                // when it was all usint the attribute it was inconsistently not working in onchange event attributes
                // see below getter for full discussion with Michael
                get: function () {
                    if (this.hasAttribute('encrypted')) {
                        return this.getAttribute('value');
                    } else {
                        return this.control.value;
                    }
            //         var element = this;
            //         if (this.hasAttribute('defer-insert')) {
			         //   if (this.hasAttribute('encrypted')) {            
            //                 // return CryptoJS.AES.decrypt(this.getAttribute('value'), (window[element.getAttribute('encrypted')] || '')).toString(CryptoJS.enc.Utf8);
            //                 return this.getAttribute('value');
            //             } else {
            //                 return this.getAttribute('value');
            //             }
            //         } else {
            //             return this.getAttribute('value');
            //         }
                },
                // Nunzio: gs-text keyup ".value" is inconsistent
                // Nunzio: one page it worked as expected
                // Nunzio: another one it didn't get the new value
                // Nunzio: .control.value worked
                // Michael: interesting, what are the different circumstances?
                // Michael: attributes / containers
                // Nunzio: the one that didn't work was in a gs-switch but I don't think that should do anything
                // Nunzio: attributes were identical
                // Nunzio: I suspect it's because the value accessor reads the attribute instead of the control value
                // Nunzio: *********getter code***********
                // Nunzio: why is that?
                // Michael: wouldn't be surprised if that was because of some Firefox issue where the polyfill too time to get to the point where the element was sufficiently instantiated.
                // Michael: In dialogs, firefox has issues instantiating in time
                // Nunzio: firefox isn't polyfilled anymore (except my shim to get the old api to work)
                // Michael: interesting, might be a non-issue at this point.
                // Michael: If you decide to switch it, make sure to comment out the old way and leave a summary of our discussion, date, and your name
                // Nunzio: I'll add it to the list but I'm not dealing with it right now
                // Michael: k


                // set the value of the input and set the value attribute
                set: function (strNewValue) {
                    if (this.hasAttribute('defer-insert')) {
                        if (this.hasAttribute('encrypted')) {
                            if (CryptoJS.AES.decrypt(this.hasAttribute('uppercase') ? strNewValue.toUpperCase() : strNewValue, (window[this.getAttribute('encrypted')] || '')).toString(CryptoJS.enc.Utf8) === '') {
                                this.setAttribute('value', CryptoJS.AES.encrypt(this.hasAttribute('uppercase') ? strNewValue.toUpperCase() : strNewValue, (window[this.getAttribute('encrypted')] || '')));
                            } else {
                                this.setAttribute('value', this.hasAttribute('uppercase') ? strNewValue.toUpperCase() : strNewValue);
                            }
                        } else {
                            this.setAttribute('value', this.hasAttribute('uppercase') ? strNewValue.toUpperCase() : strNewValue);
                            this.syncView();
                        }
                    } else {
                        this.setAttribute('value', this.hasAttribute('uppercase') ? strNewValue.toUpperCase() : strNewValue);
                        this.syncView();
                    }
                }
            }
        },
        methods: {
            focus: function () {
                var element = this;
                if (element.hasAttribute('defer-insert')) {
                    element.bolSelect = false;
                    focusFunction({ target: element });
                    //GS.triggerEvent(element, 'focus');
                } else {
                    var element = this;
                    if (element.control) {
                        element.control.focus();
                    }
                }
            },

            handleContents: function () {
                var element = this;
                var arrPassThroughAttributes = [
                        'placeholder', 'name', 'maxlength', 'autocorrect',
                        'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                        'readonly', 'disabled'
                    ];
                var i;
                var len;

                // if the gs-text element has a tabindex: save the tabindex and remove the attribute
                if (element.hasAttribute('tabindex')) {
                    element.savedTabIndex = element.getAttribute('tabindex');
                    element.removeAttribute('tabindex');
                }

                // if the gs-text doesn't have a disabled attribute: use an input element
                // if (!element.hasAttribute('disabled')) {
                    // add control input and save it to a variable for later use
                    if (element.hasAttribute('show-caps')) {
                        if (element.hasAttribute('type')) {
                            element.setAttribute('input-type', element.getAttribute('type'));
                            element.removeAttribute('type');
                        }
                    }
                    element.innerHTML = '<input class="control" gs-dynamic type="' + ((element.getAttribute('input-type') || element.getAttribute('type')) || 'text') + '" />';
                    element.control = element.children[0];
                    if (element.hasAttribute('id')) {
                        element.control.setAttribute('id', element.getAttribute('id') + '_control');
                    }
                    if (element.hasAttribute('aria-labelledby')) {
                        element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                    }
                    if (element.hasAttribute('aria-label')) {
                        element.control.setAttribute('aria-label', element.getAttribute('aria-label'));
                    }
                    if (element.hasAttribute('title')) {
                        element.control.setAttribute('title', element.getAttribute('title'));
                    }

                    // bind event re-targeting functions
                    element.control.removeEventListener('keydown', CapsLock);
                    element.control.addEventListener('keydown', CapsLock);

                    element.control.removeEventListener('change', changeFunction);
                    element.control.addEventListener('change', changeFunction);

                    element.control.removeEventListener('focus', focusFunction);
                    element.control.addEventListener('focus', focusFunction);
                    
                    element.removeEventListener('keyup', checkMaxLength);
                    element.addEventListener('keyup', checkMaxLength);

                    element.control.removeEventListener('blur', blurFunction);
                    element.control.addEventListener('blur', blurFunction);

                    element.control.removeEventListener(evt.mouseout, mouseoutFunction);
                    element.control.addEventListener(evt.mouseout, mouseoutFunction);
                    
                    element.control.removeEventListener(evt.mouseover, mouseoverFunction);
                    element.control.addEventListener(evt.mouseover, mouseoverFunction);
                    
                    // copy passthrough attributes to control
                    i = 0;
                    len = arrPassThroughAttributes.length;
                    while (i < len) {
                        if (element.hasAttribute(arrPassThroughAttributes[i])) {
                            if (arrPassThroughAttributes[i] === 'disabled') {
                                element.control.setAttribute(
                                    'readonly',
                                    element.getAttribute(arrPassThroughAttributes[i]) || ''
                                );
                            } else {
                                element.control.setAttribute(
                                    arrPassThroughAttributes[i],
                                    element.getAttribute(arrPassThroughAttributes[i]) || ''
                                );
                            }
                        }
                        i += 1;
                    }

                    // if we saved a tabindex: apply the tabindex to the control
                    if (element.savedTabIndex !== undefined && element.savedTabIndex !== null) {
                        element.control.setAttribute('tabindex', element.savedTabIndex);
                    }

                // else if the gs-text is disabled: clear the control variable and empty the gs-text
                // } else {
                //     element.control = undefined;
                //     element.innerHTML = '';
                // }
            },

            removeControl: function () {
                var element = this;
                if (element.control) {
                    element.setAttribute('tabindex', element.control.getAttribute('tabindex'));
                }
                if (element.control.value) {
                    if (element.hasAttribute('encrypted')) {
                        if (element.hasAttribute('defer-insert')) {
                            element.innerHTML = element.control.value;
                        } else {
                            element.innerHTML = element.control.value;
                            element.syncGetters();
                        }
                    } else {
                        element.innerHTML = element.control.value;
                        element.syncGetters();
                    }
                } else if (element.hasAttribute('placeholder')) {
                    element.innerHTML = '<span class="placeholder">' + element.getAttribute('placeholder') + '</span>';
                } else {
                    element.innerHTML = ''
                }
                element.control = false;
            },

            addControl: function () {
                var element = this;
                var arrPassThroughAttributes = [
                    'placeholder', 'name', 'maxlength', 'autocorrect',
                    'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                    'readonly', 'disabled'
                ];
                var i;
                var len;
                var elementValue = element.innerHTML;
                var elementWidth = element.offsetWidth;
                if (element.children.length > 0) {
                    elementValue = '';
                }
                // if the gs-text element has a tabindex: save the tabindex and remove the attribute
                if (element.hasAttribute('tabindex')) {
                    element.savedTabIndex = element.getAttribute('tabindex');
                    element.removeAttribute('tabindex');
                }
                // add control input and save it to a variable for later use
                element.innerHTML = '';
                element.innerHTML = '<input class="control" gs-dynamic type="' + (element.getAttribute('type') || 'text') + '" />';
                element.control = element.children[0];
                if (element.hasAttribute('id')) {
                    element.control.setAttribute('id', element.getAttribute('id') + '_control');
                }
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }

                // bind event re-targeting functions
                element.control.removeEventListener('change', changeFunction);
                element.control.addEventListener('change', changeFunction);


                element.control.removeEventListener('blur', blurFunction);

                element.removeEventListener(evt.mouseout, mouseoutFunction);
                element.addEventListener(evt.mouseout, mouseoutFunction);

                element.removeEventListener(evt.mouseout, mouseoverFunction);
                element.addEventListener(evt.mouseover, mouseoverFunction);
                // copy passthrough attributes to control
                i = 0;
                len = arrPassThroughAttributes.length;
                while (i < len) {
                    if (element.hasAttribute(arrPassThroughAttributes[i])) {
                        if (arrPassThroughAttributes[i] === 'disabled') {
                            element.control.setAttribute(
                                'readonly',
                                element.getAttribute(arrPassThroughAttributes[i]) || ''
                            );
                        } else {
                            element.control.setAttribute(
                                arrPassThroughAttributes[i],
                                element.getAttribute(arrPassThroughAttributes[i]) || ''
                            );
                        }
                    }
                    i += 1;
                }

                element.control.value = elementValue;
                element.value = elementValue;
                // if we saved a tabindex: apply the tabindex to the control
                if (element.savedTabIndex !== undefined && element.savedTabIndex !== null) {
                    element.control.setAttribute('tabindex', element.savedTabIndex);
                }

                element.syncView();
                element.control.focus();
                element.addEventListener('focus', focusFunction);
                element.control.addEventListener('blur', blurFunction);
            },

            syncView: function () {
                var element = this;
                if (element.hasAttribute('defer-insert')) {
                    if (element.control) {
                        if (element.hasAttribute('encrypted')) {
                            var bytes = CryptoJS.AES.decrypt(element.getAttribute('value'), (window[element.getAttribute('encrypted')] || ''));
                            var plaintext = bytes.toString(CryptoJS.enc.Utf8) || '';
                            if (window[element.getAttribute('encrypted')] && plaintext == '' && element.control.value) {
                                GS.triggerEvent(element, 'password-error', {'reason': 'bad', 'keyVariable': element.getAttribute('encrypted')});
                            }
                            element.control.value = plaintext || '';
                        } else {
                            element.control.value = element.getAttribute('value');
                        }
                    } else {
                        if (element.value) {
                            if (element.hasAttribute('encrypted')) {
                                var bytes = CryptoJS.AES.decrypt(element.value, (window[element.getAttribute('encrypted')] || ''));
                                var plaintext = bytes.toString(CryptoJS.enc.Utf8) || '';
                                if (window[element.getAttribute('encrypted')] && plaintext == '' && element.control.value) {
                                    GS.triggerEvent(element, 'password-error', {'reason': 'bad', 'keyVariable': element.getAttribute('encrypted')});
                                }
                                element.innerHTML = plaintext;
                            } else {
                                element.innerHTML = element.value;
                            }
                        } else if (element.hasAttribute('placeholder')) {
                            element.innerHTML = '<span class="placeholder">' + element.getAttribute('placeholder') + '</span>';
                        }
                    }
                    element.initalized = true;
                } else {
                    var element = this;
                    //if (element.hasAttribute('disabled')) {
                    //    element.textContent = element.getAttribute('value') || element.getAttribute('placeholder');
                    //} else {
                        if (element.hasAttribute('encrypted')) {
                            if (!window[element.getAttribute('encrypted')] || !element.getAttribute('value')) {
                                
                            } else {
                                var bytes = CryptoJS.AES.decrypt(element.getAttribute('value'), (window[element.getAttribute('encrypted')] || ''));
                                var plaintext = bytes.toString(CryptoJS.enc.Utf8) || '';
                            if (window[element.getAttribute('encrypted')] && plaintext == '' && element.control.value) {
                                    GS.triggerEvent(element, 'password-error', {'reason': 'bad', 'keyVariable': element.getAttribute('encrypted')});
                                }
                            }
                            element.control.value = plaintext || '';
                        } else {
                            element.control.value = element.getAttribute('value') || '';
                        }
                    //}
                    element.initalized = true;
                }
                
            },

            syncGetters: function () {
                var element = this;
                if (element.hasAttribute('defer-insert')) {
                    if (element.control) {
                        if (element.hasAttribute('encrypted')) {
                            element.control.setAttribute('value', CryptoJS.AES.encrypt(element.hasAttribute('uppercase') ? element.control.value.toUpperCase() : element.control.value, (window[element.getAttribute('encrypted')] || '')));
                        } else {
                            element.setAttribute('value', element.hasAttribute('uppercase') ? element.control.value.toUpperCase() : element.control.value);
                        }
                    }
                } else {
                    if (element.hasAttribute('encrypted')) {
                        element.setAttribute('value', CryptoJS.AES.encrypt(element.hasAttribute('uppercase') ? element.control.value.toUpperCase() : element.control.value, (window[element.getAttribute('encrypted')] || '')));
                    } else {
                        element.setAttribute('value', element.hasAttribute('uppercase') ? element.control.value.toUpperCase() : element.control.value);
                    }
                }
                
            }
        }
    });
});
//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, shimmed
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    "use strict";
    addSnippet('<gs-time>', '<gs-time>', 'gs-time column="${1:name}"></gs-time>');
    addSnippet(
        '<gs-time> With Label',
        '<gs-time>',
        (
            'label for="${1:time-insert-start_time}">${2:Start Time}:</label>\n' +
            '<gs-time id="${1:time-insert-start_time}" column="${3:start_time}"></gs-time>'
        )
    );

    /*
    TODO: there is no documentation
    addElement('gs-time', '');
    */

    window.designElementProperty_GSTIME = function(selectedElement) {
        addGSControlProps();
        addText('V', 'Placeholder', 'placeholder');
        addCheck('V', 'Time Picker', 'no-picker');
        addCheck('D', 'Non-Empty', 'non-empty');
        addCheck('V', 'Now Button', 'no-now-button');
        addSelect('V', 'Display Format', 'format', [
            {"val": "", "txt": "Regular (1:30 PM)"},
            {"val": "military", "txt": "Military (13:30)"}
        ]);
        addSelect('D', 'Output Format', 'output-format', [
            {"val": "", "txt": "Regular (1:30 PM)"},
            {"val": "military", "txt": "Military (13:30)"}
        ]);
        addAutocompleteProps();
        addFocusEvents();
        addFlexProps();
        addText('O', 'Column In QS', 'qs');
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var currentErrorControl;

    window.addEventListener('focus', function (event) {
        if (currentErrorControl && event.target !== currentErrorControl.control) {
            currentErrorControl.control.focus();
            if (currentErrorControl.control) {
                GS.setInputSelection(currentErrorControl.control, 0, currentErrorControl.control.value.length);
            }
        }

        if (currentErrorControl && currentErrorControl.control && currentErrorControl.control.value) {
            currentErrorControl = '';
        }
    });

    //x attributes:
    //x      placeholder:   copy to control element
    //x      disabled:      copy to control element
    //x      tabindex:      move to control element
    //x      qs:            fill value from querystring, update value as querystring changes
    //x      non-empty:     prevent leaving the field if value is empty, console warn if value starts as empty
    //x      format:        affects value translation when filling control
    //x      no-now-button: affects dropdown html and "n" key
    //x      value:         affects control value
    //x      no-picker:     affects innerHTML because it removes the picker button

    //x accessors:
    //x      value:     returns text value
    //x      dateValue: returns value as a date object
    //x      state:     returns text representation of state: "open" or "closed"

    //x methods:
    //x      open:   opens popup
    //x      close:  closes popup
    //x      toggle: toggles open and closed methods

    //x events:
    //x      picker button click: runs "toggle" method
    //x      control keydown:
    //x          up arrow:    next minute
    //x          down arrow:  previous minute
    //x          left arrow:  previous minute
    //x          right arrow: next minute
    //x          "c":         clear (if allowed)
    //x          "n":         now (if allowed)

    //x dropdown behaviours:
    //x      if from control to bottom is too small and from control to top is too small: dialog
    //x      else if window width < 400px: dialog
    //x      else if window height < 550px: dialog
    //x      else:
    //x          if from control to bottom has enough room: popup below
    //x          else: popup above

    // #####################################################################################
    // ################################## EVENT RETARGETING ################################
    // #####################################################################################

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();

        event.target.parentNode.setAttribute('value', event.target.value);
        //console.log('this is a test', event.target);
        handleChange(event.target.parentNode);
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
        event.target.parentNode.classList.add('focus');
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'blur');
        event.target.parentNode.classList.remove('focus');
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseout);
        event.target.parentNode.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseover);
        event.target.parentNode.classList.add('hover');
    }


    // #####################################################################################
    // ####################################### CONTROL #####################################
    // #####################################################################################

    function refreshControl(element) {
        var i, len, arrPassThroughAttributes, strHTML;

        // clear out HTML
        element.innerHTML = '';

        // clear out element variables
        element.control = '';
        element.button = '';

        // if we are not disabled:
        if (!element.hasAttribute('disabled')) {
            // build HTML
            strHTML = '<input class="control" gs-dynamic type="text" />';
            if (!element.hasAttribute('no-picker')) {
                strHTML += '<gs-button class="time-picker-button" gs-dynamic inline icononly icon="clock-o" no-focus>Open Time Picker</gs-button>';
            }

            // set control HTML
            element.innerHTML = strHTML;

            // fill element variables
            element.control = element.children[0];
            if (element.hasAttribute('id')) {
                element.control.setAttribute('id', element.getAttribute('id') + '_control');
            }
            if (element.hasAttribute('aria-labelledby')) {
                element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
            }
            if (element.hasAttribute('title')) {
                element.control.setAttribute('title', element.getAttribute('title'));
            }
            element.button = element.children[1];

            // handle passthrough attributes
            arrPassThroughAttributes = [
                'placeholder', 'name', 'maxlength', 'autocorrect',
                'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                'readonly'
            ];

            i = 0;
            len = arrPassThroughAttributes.length;
            while (i < len) {
                if (element.hasAttribute(arrPassThroughAttributes[i])) {
                    element.control.setAttribute(
                        arrPassThroughAttributes[i],
                        element.getAttribute(arrPassThroughAttributes[i]) || ''
                    );
                }
                i += 1;
            }

            // move tabindex
            if (element.hasAttribute('tabindex')) {
                element.oldTabIndex = element.getAttribute('tabindex');
                element.removeAttribute('tabindex');
            }

            if (element.oldTabIndex) {
                element.control.tabIndex = element.oldTabIndex;
            }

            // bind control retargeting
            element.control.removeEventListener('change', changeFunction);
            element.control.addEventListener('change', changeFunction);

            element.control.removeEventListener('focus', focusFunction);
            element.control.addEventListener('focus', focusFunction);

            element.control.removeEventListener('blur', blurFunction);
            element.control.addEventListener('blur', blurFunction);

            element.control.removeEventListener(evt.mouseout, mouseoutFunction);
            element.control.addEventListener(evt.mouseout, mouseoutFunction);

            element.control.removeEventListener(evt.mouseover, mouseoverFunction);
            element.control.addEventListener(evt.mouseover, mouseoverFunction);
        }

        // display value
        setValueDisplay(element, element.getAttribute('value'));
    }

    function handleChange(element) {
        element.close();
        if (handleNonEmpty(element) && element.lastChangeValue !== element.getAttribute('value')) {
            GS.triggerEvent(element, 'change');
            element.lastChangeValue = element.getAttribute('value');
        }
    }

    function handleNonEmpty(element) {
        var bolAllClear = true;

        if (element.hasAttribute('non-empty') && !element.getAttribute('value')) {
            bolAllClear = false;
            currentErrorControl = element;
            alert('Error: Invalid Time. Please input a time.');
            element.open();
        }

        return bolAllClear;
    }


    // #####################################################################################
    // ######################################## VALUE ######################################
    // #####################################################################################

    // translate inputed value to a format that is allowed. no seconds as of yet, defaults to AM
    function translateValue(strFormat, newValue) {
        var translatedValue;
        var valueDate;
        var strHour;
        var strMinute;
        var strPeriod;
        var arrParts;
        var intHours;

        // coalesce value
        newValue = newValue || '';
        //console.log('newValue >' + newValue + '<');

        // if value is a string: parse
        if (typeof newValue === 'string') {
            // input types:
            //      "1530"          => "15:30"
            //      "0330"          => "03:30"
            //      "3:30"          => "3:30"
            //      "3:30PM"        => "3:30 PM" (all cases/variations of PM/AM) ('a', 'p', 'am', 'pm', 'Am', 'Pm', 'AM', 'PM')
            //      "330"           => "3:30"
            //      "3"             => "3:00"
            //      "12"            => "12:00"
            //      "12PM"          => "12:00 PM" (all cases/variations of PM/AM) ('a', 'p', 'am', 'pm', 'Am', 'Pm', 'AM', 'PM')
            //      "12:30:12 PM"   => "12:30 PM" (no seconds as of yet)
            //      "123012"        => "12:30" (no seconds as of yet)

            // extract period
            strPeriod = (newValue.match(/pm|am|a|p/gi) || [''])[0].toLowerCase();
            newValue  = newValue.replace(/[^0-9:]/gi, '');

            //console.log('before strPeriod>' + strPeriod + '<');
            if (strPeriod) {
                strPeriod = (strPeriod[0] === 'a' ? 'AM' : 'PM');
            }
            //console.log('after strPeriod>' + strPeriod + '<');

            if (newValue) {
                // if there are colon(s): split on colons
                if ((/:/).test(newValue)) {
                    arrParts = newValue.split(':');

                    strHour = arrParts[0];
                    strMinute = GS.leftPad(arrParts[1], '0', 2);

                    // if hour is greater than 12: subtract 12 and set period to PM
                    if (parseInt(strHour, 10) > 12) {
                        strHour = parseInt(strHour, 10) - 12;
                        strPeriod = 'PM';
                        //console.log('set strPeriod to PM');
                    }

                // else (if there are just numbers)
                } else {
                    newValue = newValue.substring(0, 4);

                    // if the new value is 3 or 4 characters long: last 2 are minute and the rest is hour
                    if (newValue.length >= 3) {
                        strMinute = newValue.substring(newValue.length - 2);
                        strHour = newValue.substring(0, newValue.length - 2);

                        // if hour is greater than 12: subtract 12 and set period to PM
                        if (parseInt(strHour, 10) > 12) {
                            strHour = parseInt(strHour, 10) - 12;
                            strPeriod = 'PM';
                            //console.log('set strPeriod to PM');
                        }

                    // else:
                    } else {
                        newValue = parseInt(newValue, 10);

                        // if (format is military AND number > 24) OR (format isn't military AND number > 12): newValue is minute
                        if ((strFormat === 'military') && newValue > 24 || (strFormat !== 'military') && newValue > 12) {
                            strHour = '12';
                            strMinute = String(newValue);
                        } else {
                            strHour = String(newValue);
                            strMinute = '00';
                        }
                    }
                }
            }

            if (strHour && strMinute) {
                if (!strPeriod) {
                    //console.log('strHour>' + strHour + '<');
                    //console.log('parseInt(strHour, 10)>' + parseInt(strHour, 10) + '<');
                    if (parseInt(strHour, 10) >= 12) {
                    //if (parseInt(strHour, 10) < 6 || parseInt(strHour, 10) === 12) {//Who did this? -Joseph
                        strPeriod = 'PM';
                        //console.log('set strPeriod to PM');
                    } else {
                        strPeriod = 'AM';
                        //console.log('set strPeriod to AM');
                    }
                }
                valueDate = new Date('1/1/1111 ' + strHour + ':' + strMinute + ' ' + strPeriod);
            }
        // else: just copy date object
        } else {
            valueDate = new Date(newValue);
        }

        //console.log(strHour, strMinute, strPeriod);

        // if we have enough data to make a value
        if (valueDate) {
            // output types:
            //      regular time:  "3:30 PM"
            //      military time: "15:30"

            if (strFormat === 'military') {
                translatedValue = GS.leftPad(valueDate.getHours(), '0', 2) + ':' +
                                  GS.leftPad(valueDate.getMinutes(), '0', 2);
            } else {
                intHours = valueDate.getHours();

                if (intHours >= 12) {
                    intHours = intHours - 12;
                }
                if (intHours === 0) {
                    intHours = 12;
                }

                translatedValue = intHours + ':' +
                                  GS.leftPad(valueDate.getMinutes(), '0', 2) + ' ' +
                                  (valueDate.getHours() >= 12 ? 'PM' : 'AM');
            }
        } else {
            translatedValue = '';
        }

        return translatedValue;
    }

    function setValueDisplay(element, newValue) {
        var translatedOutputValue = translateValue((element.getAttribute('output-format') === 'military' ? 'military' : 'regular'), newValue);
        var translatedDisplayValue = translateValue((element.getAttribute('format') === 'military' ? 'military' : 'regular'), newValue);

        element.setAttribute('value', translatedOutputValue);

        if (!element.hasAttribute('disabled')) {
            element.control.value = translatedDisplayValue;
        } else {
            element.textContent = translatedDisplayValue || element.getAttribute('placeholder') || '';
        }

        if (element.innerState === 'open') {
            refreshPickerValue(element);
        }
    }

    function refreshPickerValue(element) {
        var arrElements;
        var strTranslatedValue;
        var dteTranslatedValue;
        var i;
        var len;
        var intHours;

        if (element.innerState === 'open') {
            strTranslatedValue = translateValue((element.getAttribute('format') === 'military' ? 'military' : 'regular'), element.getAttribute('value'));
            dteTranslatedValue = new Date('1/1/1111 ' + strTranslatedValue);

            element.pickerModalControlElement.setAttribute('value', strTranslatedValue);

            arrElements = xtag.query(element.pickerContainerElement, '.selected');

            i = 0;
            len = arrElements.length;
            while (i < len) {
                arrElements[i].classList.remove('selected');
                i += 1;
            }


            intHours = dteTranslatedValue.getHours();

            if (intHours >= 12) {
                intHours = intHours - 12;
            }
            if (intHours === 0) {
                intHours = 12;
            }

            xtag.query(element.pickerContainerElement,
                '.clock-hour[data-value="' + intHours + '"]')[0].classList.add('selected');
            xtag.query(element.pickerContainerElement,
                '.clock-minute[data-value="' + (Math.floor(dteTranslatedValue.getMinutes() / 5) * 5) + '"]')[0].classList.add('selected');
            xtag.query(element.pickerContainerElement,
                '.clock-period-switch.' + (dteTranslatedValue.getHours() >= 12 ? 'pm' : 'am'))[0].classList.add('selected');
        }
    }


    // #####################################################################################
    // ##################################### QUERYSTRING ###################################
    // #####################################################################################

    function handleQS(element) {
        var strQSValue;

        if (!element.qsEventFunction) {
            element.qsEventFunction = function () {
                pushReplacePopHandler(element);
            };
        }

        window.removeEventListener('pushstate',    element.qsEventFunction);
        window.removeEventListener('replacestate', element.qsEventFunction);
        window.removeEventListener('popstate',     element.qsEventFunction);

        // handle "qs" attribute
        if (element.getAttribute('qs')) {
            //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));

            //if (strQSValue !== '' || !element.getAttribute('value')) {
            //    element.setAttribute('value', strQSValue);
            //}
            pushReplacePopHandler(element);
            window.addEventListener('pushstate',    element.qsEventFunction);
            window.addEventListener('replacestate', element.qsEventFunction);
            window.addEventListener('popstate',     element.qsEventFunction);
        }
    }


    //function pushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString();
    //    var strQSCol = element.getAttribute('qs');

    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.setAttribute('value', GS.qryGetVal(strQueryString, strQSCol));
    //    }
    //}

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }


    // #####################################################################################
    // ###################################### LIFECYCLE ####################################
    // #####################################################################################

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value) {
                element.setAttribute('value', element.value);
                delete element.value;
            }
        }
    }

    function findFor(element) {
        var forElem;
        //console.log(element, element.previousElementSibling)
        if (element.previousElementSibling && element.previousElementSibling.tagName.toUpperCase() == 'LABEL'
            && element.previousElementSibling.hasAttribute('for')
            && element.previousElementSibling.getAttribute('for') == element.getAttribute('id')
        ) {
            forElem = element.previousElementSibling;
        } else if (xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]').length > 0) {
            forElem = xtag.query(document, 'label[for="' + element.getAttribute('id') + '"]')[0];
        }
        //console.log(forElem);
        if (forElem) {
            forElem.setAttribute('for', element.getAttribute('id') + '_control');
            if (element.control) {
                element.control.setAttribute('id', element.getAttribute('id') + '_control');
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }
            }
        }
        
        /*
            if (element.hasAttribute('id')) {
                findFor(element);
            }
        // please ensure that if the element has an id it is given an id
                if (element.hasAttribute('id')) {
                    element.control.setAttribute('id', element.getAttribute('id') + '_control');
                }
                if (element.hasAttribute('aria-labelledby')) {
                    element.control.setAttribute('aria-labelledby', element.getAttribute('aria-labelledby'));
                }
                if (element.hasAttribute('title')) {
                    element.control.setAttribute('title', element.getAttribute('title'));
                }
        */
    }

    //
    function elementInserted(element) {
        console.warn('GS-TIME WARNING: this element is deprecated, please use the gs-datetime instead.');
        var now;
        var strQSValue;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.innerState = 'closed';
                element.internal = {};
                saveDefaultAttributes(element);

                // if value attribute = now: set value attribute to the current time
                if (element.getAttribute('value') === 'now') {
                    now = new Date();

                    if (now.getHours() > 12) {
                        now = GS.leftPad(now.getHours() - 12, '0', 2) + ':' + GS.leftPad(now.getMinutes(), '0', 2) + ' PM';
                    } else {
                        now = GS.leftPad(now.getHours(), '0', 2) + ':' + GS.leftPad(now.getMinutes(), '0', 2) + ' AM';
                    }

                    element.setAttribute('value', now);
                }

                element.inserted = true;

                refreshControl(element);

                if (element.getAttribute('qs')) {
                    handleQS(element);
                }

                element.lastChangeValue = element.getAttribute('value');

                if (element.hasAttribute('non-empty') && !element.getAttribute('value')) {
                    console.warn('gs-time Warning: No value provided on "non-empty" gs-time control. Defaulting to "12:00 PM". Please provide a default value.');
                    element.setAttribute('value', '12:00 PM');
                }
            }
            if (element.hasAttribute('id')) {
                findFor(element);
            }
        }
    }


    // ######################################################################################
    // ##################################### REGISTRATION ###################################
    // ######################################################################################

    xtag.register('gs-time', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(element);
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);

                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'placeholder' ||
                        strAttrName === 'disabled' ||
                        strAttrName === 'format' ||
                        strAttrName === 'no-picker' ||
                        strAttrName === 'tabindex') {
                        refreshControl(element);

                    } else if (strAttrName === 'qs') {
                        handleQS(element);

                    } else if (strAttrName === 'value' && element.inserted) {// && this.control
                        setValueDisplay(element, newValue);
                    }
                }
            }
        },
        events: {
            'click': function (event) {
                var element = this;
                if (event.target === element.button) {
                    element.toggle();
                }
            },
            'keydown:': function (event) {
                var element = this;
                var intKeyCode = (event.keyCode || event.which);
                var newControlValue;

                if (!element.hasAttribute('no-keys') && !element.hasAttribute('readonly')) {
                    if (element.getAttribute('value') && (intKeyCode === 38 || intKeyCode === 39 || intKeyCode === 40 || intKeyCode === 37)) {
                        newControlValue = new Date('1/1/1111 ' + element.getAttribute('value'));
                        event.preventDefault();
                        event.stopPropagation();

                        // up arrow:    next minute
                        // right arrow: next minute
                        if (intKeyCode === 38 || intKeyCode === 39) {
                            newControlValue = newControlValue.setMinutes(newControlValue.getMinutes() + 1);

                        // down arrow: previous minute
                        // left arrow: previous minute
                        } else if (intKeyCode === 40 || intKeyCode === 37) {
                            newControlValue = newControlValue.setMinutes(newControlValue.getMinutes() - 1);
                        }
                    }

                    // "c": clear (if allowed)
                    if (intKeyCode === 67 && !event.ctrlKey && !event.metaKey && !element.hasAttribute('non-empty')) {
                        newControlValue = '';
                        event.preventDefault();
                        event.stopPropagation();

                    // "n": now (if allowed)
                    } else if (intKeyCode === 78 && !event.ctrlKey && !event.metaKey && !element.hasAttribute('no-now-button')) {
                        newControlValue = new Date();
                        event.preventDefault();
                        event.stopPropagation();
                    }

                    if (newControlValue !== undefined) {
                        setValueDisplay(element, newControlValue);
                        GS.setInputSelection(element.control, 0, element.control.value.length);
                    }

                    if (intKeyCode === 13) {
                        handleNonEmpty(element);
                    }
                }
            },
            'focusout': function (event) {
                var element = this;
                if (element.innerState === 'open') {
                    element.close();
                } else {
                    handleChange(element);
                }
            }
        },
        accessors: {
            value: {
                get: function () {
                    // return this.getAttribute('value');
                    if (!this.getAttribute('value') || this.getAttribute('value').trim() === '') {
                        return 'NULL';
                    } else {
                        return this.getAttribute('value');
                    }
                },
                set: function (newValue) {
                    this.setAttribute('value', newValue);
                }
            },
            dateValue: {
                get: function () {
                    return new Date('1/1/1111 ' + this.getAttribute('value'));
                },
                set: function (newValue) {
                    setValueDisplay(this, newValue);
                }
            },
            state: {
                get: function () {
                    return this.innerState;
                },
                set: function (newValue) {
                    var element = this;
                    if (newValue === 'open') {
                        element.open();
                    } else {
                        element.close();
                    }
                }
            }
        },
        methods: {
            focus: function () {
                this.control.focus();
            },

            open: function () {
                var element = this;
                var pickerContainerElement;
                var overlayElement;
                var pickerElement;
                var handleLook;
                var strHTML;

                if (element.innerState === 'closed') {
                    element.innerState = 'open';
                    element.lastClosedValue = element.getAttribute('value');

                    // if we are not on a touch device: focus control
                    if (!evt.touchDevice) {
                        element.control.focus();
                        GS.setInputSelection(element.control, 0, element.control.value.length);

                    } else {
                        //this.control.focus()
                        //this.control.blur();
                    }

                    // create picker elements
                    pickerContainerElement = document.createElement('div');
                    pickerContainerElement.classList.add('gs-time-time-picker-container');

                    overlayElement = document.createElement('div');
                    overlayElement.classList.add('gs-time-time-picker-overlay');

                    pickerElement = document.createElement('div');
                    pickerElement.classList.add('gs-time-time-picker');

                    // save picker container
                    element.pickerContainerElement = pickerContainerElement;

                    // append picker elements
                    pickerContainerElement.appendChild(overlayElement);
                    pickerContainerElement.appendChild(pickerElement);

                    document.body.appendChild(pickerContainerElement);

                    // fill picker popup
                    strHTML = ml(function () {/*
                        <div class="time-modal-control-container" flex-horizontal>
                            <gs-text class="time-modal-control" flex></gs-text>
                            <gs-button class="modal-done">Done</gs-button>
                        </div>
                        <div class="time-inner-container">
                            <div class="time-top-toolbar">
                                <div flex-horizontal align-bottom>
                                    <gs-button class="decrement-time" icononly icon="arrow-left"></gs-button>
                                    <div flex></div>
                                    <gs-button class="increment-time" icononly icon="arrow-right"></gs-button>
                                </div>
                            </div>
                            <div class="gs-time-clock-container" prevent-text-selection>
                                <div class="gs-time-bezel">
                                    <div class="clock-face-layer layer-1">
                                        <div class="clock-line" style="top: 0%;"><div class="clock-button clock-hour" data-value="12"><span class="content">12</span></div></div><div class="clock-line" style="top: 5.9%;"><div class="clock-split" style="width: 45.25%;
left: 4.5%;"><div class="clock-button clock-hour" data-value="11"><span class="content">11</span></div></div><div class="clock-split" style="width: 45.25%;
left: 46.75%;"><div class="clock-button clock-hour" data-value="1">&nbsp;<span class="content">1</span></div></div></div><div class="clock-line" style="top: 22.5%;"><div class="clock-split" style="width: 22%;
left: 0%;"><div class="clock-button clock-hour" data-value="10"><span class="content">10</span></div></div><div class="clock-split" style="width: 22%;
left: 78%;"><div class="clock-button clock-hour" data-value="2">&nbsp;<span class="content">2</span></div></div></div><div class="clock-line" style="top: 45.3%;"><div class="clock-split" style="width: 14%;
left: 0%;"><div class="clock-button clock-hour" data-value="9"><span class="content">9</span>&nbsp;</div></div><div class="clock-split" style="width: 14%;
left: 86%;"><div class="clock-button clock-hour" data-value="3">&nbsp;<span class="content">3</span></div></div></div><div class="clock-line" style="top: 67.8%;"><div class="clock-split" style="width: 22%;
left: 0%;"><div class="clock-button clock-hour" data-value="8"><span class="content">8</span>&nbsp;</div></div><div class="clock-split" style="width: 22%;
left: 78%"><div class="clock-button clock-hour" data-value="4">&nbsp;<span class="content">4</span></div></div></div><div class="clock-line" style="top: 83.5%;"><div class="clock-split" style="width: 45.25%;
left: 4.5%;"><div class="clock-button clock-hour" data-value="7"><span class="content">7</span>&nbsp;</div></div><div class="clock-split" style="width: 45.25%;
left: 46.75%;"><div class="clock-button clock-hour" data-value="5">&nbsp;<span class="content">5</span></div></div></div><div class="clock-line" style="top: 90%;"><div class="clock-button clock-hour" data-value="6"><span class="content">6</span></div></div>
                                    </div>
                                    <div class="clock-face-layer layer-2">
                                        <div class="clock-line" style="top: 0%;"><div class="clock-button clock-minute" data-value="0"><span class="content">00</span></div></div>
                                        <div class="clock-line" style="top: 5.9%;"><div class="clock-split" style="width: 45.25%;
left: 4.5%;"><div class="clock-button clock-minute" data-value="55"><span class="content">55</span></div></div><div class="clock-split" style="width: 45.25%;
left: 49.75%;"><div class="clock-button clock-minute" data-value="5"><span class="content">05</span></div></div></div>
                                        <div class="clock-line" style="top: 22.5%;"><div class="clock-split" style="width: 22%;
left: 0%;"><div class="clock-button clock-minute" data-value="50"><span class="content">50</span></div></div><div class="clock-split" style="width: 22%;
left: 78%;"><div class="clock-button clock-minute" data-value="10"><span class="content">10</span></div></div></div>
                                        <div class="clock-line" style="top: 45.3%;"><div class="clock-split" style="width: 16%;
left: 0%;"><div class="clock-button clock-minute" data-value="45"><span class="content">45</span></div></div><div class="clock-split" style="width: 16%;
left: 84%;"><div class="clock-button clock-minute" data-value="15"><span class="content">15</span></div></div></div>
                                        <div class="clock-line" style="top: 67.8%;"><div class="clock-split" style="width: 22%;
left: 0%;"><div class="clock-button clock-minute" data-value="40"><span class="content">40</span></div></div><div class="clock-split" style="width: 22%;
left: 78%;"><div class="clock-button clock-minute" data-value="20"><span class="content">20</span></div></div></div>
                                        <div class="clock-line" style="top: 83.5%;"><div class="clock-split" style="width: 45.25%;
left: 4.5%;"><div class="clock-button clock-minute" data-value="35"><span class="content">35</span></div></div><div class="clock-split" style="width: 45.25%;
left: 49.75%;"><div class="clock-button clock-minute" data-value="25"><span class="content">25</span></div></div></div>
                                        <div class="clock-line" style="top: 90%;"><div class="clock-button clock-minute" data-value="30"><span class="content">30</span></div></div>
                                        <div class="clock-center"><div class="clock-period-switch am"><span class="content">AM</span></div><div class="clock-period-switch pm"><span class="content">PM</span></div></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    */});

                    strHTML += '<div class="time-bottom-toolbar">' +
                                    '<div flex-horizontal align-top>';

                    if (!element.hasAttribute('no-now-button')) {
                        strHTML += '<gs-button class="now-time">Now</gs-button>';
                    }

                    strHTML += '<gs-button class="done" flex>Done</gs-button>';

                    if (!element.hasAttribute('non-empty')) {
                        strHTML += '<gs-button class="clear-time">Clear</gs-button>';
                    }

                    strHTML +=      '</div>' +
                                '</div>';

                    pickerElement.innerHTML = strHTML;

                    // save picker control
                    element.pickerModalControlElement = xtag.query(pickerContainerElement, '.time-modal-control')[0];

                    // set picker value
                    refreshPickerValue(element);

                    // bind picker control change
                    element.pickerModalControlElement.addEventListener('change', function (event) {
                        setValueDisplay(element, this.value);
                    });

                    // bind picker control keydown
                    element.pickerModalControlElement.addEventListener('keydown', function (event) {
                        if ((event.keyCode || event.which) === 13) {
                            element.close();
                        }
                    });

                    // bind picker click
                    pickerElement.addEventListener('mousedown', function (event) {
                        if (!evt.touchDevice) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    });

                    //console.log('0***', pickerElement);
                    pickerElement.addEventListener('click', function (event) {
                        var target = event.target, arrElements, i, len, newValue;

                        //console.log('1***', newValue);

                        if (target.classList.contains('content')) {
                            target = target.parentNode;
                        }

                        if (target.classList.contains('clock-button') || target.classList.contains('clock-period-switch')) {
                            if (target.classList.contains('clock-hour')) {
                                arrElements = xtag.query(pickerElement, '.clock-hour');
                            }
                            if (target.classList.contains('clock-minute')) {
                                arrElements = xtag.query(pickerElement, '.clock-minute');
                            }
                            if (target.classList.contains('clock-period-switch')) {
                                arrElements = xtag.query(pickerElement, '.clock-period-switch');
                            }

                            for (i = 0, len = arrElements.length; i < len; i += 1) {
                                arrElements[i].classList.remove('selected');
                            }

                            target.classList.add('selected');

                            arrElements = xtag.query(pickerElement, '.selected');
                            if (arrElements.length === 3) {
                                newValue = arrElements[0].textContent + ':' +
                                           arrElements[1].textContent + ' ' +
                                           arrElements[2].textContent;
                            }
                        }

                        if (target.classList.contains('increment-time') && element.getAttribute('value')) {
                            newValue = new Date('1/1/1111 ' + element.getAttribute('value'));
                            newValue = newValue.setMinutes(newValue.getMinutes() + 1);
                        } else if (target.classList.contains('decrement-time') && element.getAttribute('value')) {
                            newValue = new Date('1/1/1111 ' + element.getAttribute('value'));
                            newValue = newValue.setMinutes(newValue.getMinutes() - 1);
                        } else if (target.classList.contains('now-time')) {
                            newValue = new Date();
                        } else if (target.classList.contains('clear-time')) {
                            newValue = '';
                        } else if (target.classList.contains('modal-done') || target.classList.contains('done')) {
                            element.close();
                        }

                        //console.log('2***', newValue);
                        if (newValue !== undefined) {
                            setValueDisplay(element, newValue);
                            //console.log('3***', element, element.getAttribute('value'), element.value);

                            if (!evt.touchDevice) {
                                GS.setInputSelection(element.control, 0, element.control.value.length);
                            }
                        }
                    });

                    // handle/bind positioning and look
                    handleLook = function () {
                        var positionData, intPopupHeight, intPopupWidth;

                        if (pickerContainerElement.parentNode !== document.body) {
                            window.removeEventListener('resize', handleLook);
                            window.removeEventListener('orientationchange', handleLook);
                            return;
                        }

                        // clear current styles
                        pickerElement.style.top = '';
                        pickerElement.style.left = '';
                        pickerElement.style.marginTop = '';
                        pickerContainerElement.classList.remove('modal');

                        // get position/size data
                        positionData = GS.getElementPositionData(element);
                        intPopupHeight = pickerElement.offsetHeight;
                        intPopupWidth = pickerElement.offsetWidth;

                        // if from control to bottom is too small and from control to top is too small
                        //      OR window width < 400px: dialog
                        //      OR window height < 550px: dialog
                        if ((positionData.intRoomAbove < intPopupHeight && positionData.intRoomBelow < intPopupHeight) ||
                            window.innerWidth < 400 ||
                            window.innerHeight < 550) {
                            // dialog mode
                            pickerElement.style.marginTop = '1em';
                            pickerContainerElement.classList.add('modal');

                        } else {
                            // if from control to bottom has enough room: popup below
                            if (positionData.intRoomBelow > intPopupHeight) {
                                pickerElement.style.top  = (positionData.objElementOffset.top + positionData.intElementHeight) + 'px';

                            // else: popup above
                            } else {
                                pickerElement.style.top  = (positionData.objElementOffset.top - intPopupHeight) + 'px';
                            }

                            pickerElement.style.left =
                                ((positionData.objElementOffset.left + positionData.intElementWidth) - intPopupWidth) + 'px';
                        }
                    };

                    handleLook();

                    window.addEventListener('resize', handleLook);
                    window.addEventListener('orientationchange', handleLook);
                }
            },

            close: function () {
                var element = this;

                if (element.innerState === 'open') {
                    element.innerState = 'closed';
                    //console.trace('closed', element.pickerContainerElement);
                    if (element.pickerContainerElement) {
                        document.body.removeChild(element.pickerContainerElement);
                        element.pickerContainerElement = '';
                    }

                    if (element.getAttribute('value') !== element.lastClosedValue) {
                        handleChange(element);
                    } else if (!element.getAttribute('value')) {
                        handleNonEmpty(element);
                    }
                }
            },

            toggle: function () {
                if (this.innerState === 'open') {
                    this.close();
                } else {
                    this.open();
                }
            }
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, shimmed
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    'use strict';

    addSnippet(
        '<gs-timestamp>',
        '<gs-timestamp>',
        'gs-timestamp date-format="${0:isodate}" time-format=${1}></gs-timestamp>'
    );

    /*
    TODO: there is no documentation
    designRegisterElement('gs-timestamp', '');
    */

    window.designElementProperty_GSTIMESTAMP = function () {
        addGSControlProps();
        addText('V', 'Date Placeholder', 'date-placeholder');
        addText('V', 'Time Placeholder', 'time-placeholder');
        addCheck('V', 'Date Picker', 'no-date-picker');
        addSelect('V', 'Date Display Format', 'date-format', [
            {"val": "", "txt": "Default (01/01/2015)"},
            {"val": "shortdate", "txt": "Shortdate (1/1/15)"},
            {"val": "mediumdate", "txt": "Mediumdate (Jan 1, 2015)"},
            {"val": "longdate", "txt": "Longdate (January 1, 2015)"},
            {"val": "fulldate", "txt": "Fulldate (Thursday, January 1, 2015)"},
            {"val": "isodate", "txt": "Isodate (2015-01-01)"},
            {"val": "isodatetime", "txt": "Isodatetime (2015-01-01T00:00:00)"}
        ]);
        addCheck('V', 'Time Picker', 'no-time-picker');
        addSelect('V', 'Time Display Format', 'time-format', [
            {"val": "", "txt": "Regular (1:30 PM)"},
            {"val": "military", "txt": "Military (13:30)"}
        ]);
        addCheck('D', 'Time Non-Empty', 'time-non-empty');
        addCheck('V', 'Time Now Button', 'time-no-now-button');
        addText('O', 'Date Tabindex', 'date-tabindex');
        addText('O', 'Time Tabindex', 'time-tabindex');
        addAutocompleteProps();
        addFocusEvents();
        addFlexProps();
        addText('O', 'Column In QS', 'qs');
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol && strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (strQSCol && GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // for a given element, copy the control values with the value attribute
    function syncView(element) {
        var strDateValue = element.dateControl.value + ' ' + (element.timeControl.value === 'NULL' ? '00:00' : element.timeControl.value);
        var dateValue = new Date(strDateValue);
        var newValue = dateValue.getFullYear() + '-' + (dateValue.getMonth() + 1) + '-' + dateValue.getDate() + ' ' + dateValue.getHours() + ':' + dateValue.getMinutes();
        
        //console.log(element.dateControl.value);
        //console.log(element.timeControl.value === 'NULL' ? '00:00' : element.timeControl.value);
        //console.log(strDateValue);
        //console.log(dateValue);
        //console.log(newValue);
        
        element.setAttribute('value', newValue);
    }
    
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
        event.target.parentNode.classList.add('focus');
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'blur');
        event.target.parentNode.classList.remove('focus');
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseout);
        event.target.parentNode.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseover);
        event.target.parentNode.classList.add('hover');
    }
    
    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value && new Date(element.value).getTime()) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = undefined;
                //element.value = null;
            }
        }
    }
    
    function elementInserted(element) {
        var dateValue = '';
        var timeValue = '';
        
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);
                
                if (element.hasAttribute('value')) {
                    var arrValue = element.getAttribute('value').split(' ');
                    dateValue = new Date(arrValue[0] + ' 00:00:00');    // adding an empty time causes the date to not be iso format
                                                                        // this makes the browser choose the local timezone instead of GMT
                    timeValue = arrValue[1];
                }
                
                element.dateControl = document.createElement('gs-date');
                element.timeControl = document.createElement('gs-time');
                
                var arrPassthrough = ['mini', 'autocorrect', 'autocapitalize', 'autocomplete', 'spellcheck', 'disabled', 'readonly'];
                var arrDatePassthrough = ['date-placeholder', 'no-date-picker', 'date-format', 'date-tabindex'];
                var arrTimePassthrough = ['time-placeholder', 'no-time-picker', 'time-format', 'time-non-empty', 'time-no-now-button', 'time-tabindex'];
                var i;
                var len;
                
                for (i = 0, len = arrPassthrough.length; i < len; i += 1) {
                    if (element.hasAttribute(arrPassthrough[i])) {
                        element.dateControl.setAttribute(arrPassthrough[i], '');
                        element.timeControl.setAttribute(arrPassthrough[i], '');
                    }
                }
                for (i = 0, len = arrDatePassthrough.length; i < len; i += 1) {
                    if (element.hasAttribute(arrDatePassthrough[i])) {
                        element.dateControl.setAttribute(arrDatePassthrough[i].replace(/date\-/g, ''), element.getAttribute(arrDatePassthrough[i]) || '');
                    }
                }
                for (i = 0, len = arrTimePassthrough.length; i < len; i += 1) {
                    if (element.hasAttribute(arrTimePassthrough[i])) {
                        element.timeControl.setAttribute(arrTimePassthrough[i].replace(/time\-/g, ''), element.getAttribute(arrTimePassthrough[i]) || '');
                    }
                }
                
                element.dateControl.value = dateValue;
                element.timeControl.value = timeValue;
                
                element.dateControl.setAttribute('flex', '');
                element.timeControl.setAttribute('flex', '');
                
                element.dateControl.setAttribute('gs-dynamic', '');
                element.timeControl.setAttribute('gs-dynamic', '');
                
                element.dateControl.addEventListener('focus', focusFunction);
                element.timeControl.addEventListener('focus', focusFunction);

                element.dateControl.addEventListener('blur', blurFunction);
                element.timeControl.addEventListener('blur', blurFunction);

                element.dateControl.addEventListener(evt.mouseout, mouseoutFunction);
                element.timeControl.addEventListener(evt.mouseout, mouseoutFunction);
                
                element.dateControl.addEventListener(evt.mouseover, mouseoverFunction);
                element.timeControl.addEventListener(evt.mouseover, mouseoverFunction);
                
                element.dateControl.addEventListener('change', function (event) {
                    syncView(element);
                    event.stopPropagation();
                    GS.triggerEvent(element, 'change');
                });
                element.timeControl.addEventListener('change', function (event) {
                    syncView(element);
                    event.stopPropagation();
                    GS.triggerEvent(element, 'change');
                });
                
                //console.log(element.dateControl);
                //console.log(element.timeControl);
                
                element.appendChild(element.dateControl);
                element.appendChild(element.timeControl);
                
                //console.log(element.children);
                
                pushReplacePopHandler(element);
                window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
            }
        }
    }
    
    xtag.register('gs-timestamp', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            
            inserted: function () {
                elementInserted(this);
            },
            
            attributeChanged: function (strAttrName, oldValue, newValue) {
                var dateValue = '';
                var timeValue = '';
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);
                    
                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                    
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value') {
                        if (newValue !== null) {
                            var arrValue = newValue.split(' ');
                            dateValue = new Date(arrValue[0]);
                            timeValue = arrValue[1];
                            
                            this.dateControl.value = dateValue;
                            this.timeControl.value = timeValue;
                        } else {
                            this.dateControl.value = null;
                            this.timeControl.value = null;
                        }
                    }
                }
            }
        },
        events: {},
        accessors: {
            value: {
                get: function () {
                    return this.getAttribute('value');
                },
                
                set: function (newValue) {
                    this.setAttribute('value', newValue);
                }
            }
        },
        methods: {
        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps, addFocusEvents, addBasicThemingProps
//jslint browser:true, white:false, this:true
//, maxlen:80

window.addEventListener('design-register-element', function () {
    "use strict";
    addSnippet(
        '<gs-toggle>',
        '<gs-toggle>',
        'gs-toggle column="${1}">${2}</gs-toggle>'
    );

    addElement('gs-toggle', '#controls_buttons_toggle');

    window.designElementProperty_GSTOGGLE = function () {
        addGSControlProps();
        addCheck('O', 'No Focus', 'no-focus');
        addCheck('V', 'Inline', 'inline');
        addCheck('V', 'Jumbo', 'jumbo');
        //addText('O', 'Hot Key', 'key');
        //addCheck('O', 'No Modifier For Hot Key', 'no-modifier-key');
        addFocusEvents();
        addText('O', 'Column In QS', 'qs');
        addIconProps();
        addBasicThemingProps();
        addCornerRoundProps();
        addFlexProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            if (!element.hasAttribute('role')) {
                element.setAttribute('role', 'button');
                element.setAttribute('aria-pressed', '');
            }
        }
    }

    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (!evt.touchDevice) {
                    element.addEventListener('focus', function () {
                        element.classList.add('focus');
                    });

                    element.addEventListener('blur', function () {
                        element.classList.remove('focus');
                    });

                    element.addEventListener(evt.mousedown, function () {
                        element.classList.add('down');
                    });

                    element.addEventListener(evt.mouseout, function () {
                        element.classList.remove('down');
                        element.classList.remove('hover');
                    });

                    element.addEventListener(evt.mouseover, function () {
                        element.classList.remove('down');
                        element.classList.add('hover');
                    });

                    element.addEventListener('keydown', function (event) {
                        if (
                            !element.hasAttribute('disabled') &&
                            !element.classList.contains('down') &&
                            (event.keyCode === 13 || event.keyCode === 32)
                        ) {
                            element.classList.add('down');
                        }
                    });

                    element.addEventListener('keyup', function (event) {
                        // if we are not disabled and we pressed return (13) or space (32): trigger click
                        if (
                            !element.hasAttribute('disabled') &&
                            element.classList.contains('down') &&
                            (event.keyCode === 13 || event.keyCode === 32)
                        ) {
                            GS.triggerEvent(element, 'click');
                        }
                    });
                }

                // add a tabindex to allow focus
                if (!element.hasAttribute('tabindex')) {
                    element.tabIndex = 0;
                }

                if (typeof element.getAttribute('value') === 'string') {
                    if (element.getAttribute('value') === 'true' || element.getAttribute('value') === '-1') {
                        element.setAttribute('selected', '');

                        element.setAttribute('aria-pressed', 'true');
                    } else {
                        element.setAttribute('aria-pressed', 'false');
                    }
                } else {
                    element.setAttribute('aria-pressed', 'false');
                }

                // handle "qs" attribute
                if (element.getAttribute('qs')) {
                    //var strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.value = strQSValue;
                    //}
                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate', function () {
                        pushReplacePopHandler(element);
                    });
                    window.addEventListener('replacestate', function () {
                        pushReplacePopHandler(element);
                    });
                    window.addEventListener('popstate', function () {
                        pushReplacePopHandler(element);
                    });
                }
            }
        }
    }

    xtag.register('gs-toggle', {
        lifecycle: {
            created: function () {
                // if the value was set before the "created" lifecycle code runs: set attribute
                //      (discovered when trying to set a value of a date control in the after_open of a dialog)
                //      ("delete" keyword added because of firefox)
                if (this.value) {
                    this.setAttribute('value', this.value);
                    delete this.value;
                    //this.value = null;
                }

                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, ignore, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // attribute code
                }
            }
        },
        events: {
            'click': function () {
                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    this.classList.remove('down');

                    if (this.hasAttribute('selected')) {
                        this.removeAttribute('selected');

                        if (this.getAttribute('value') === 'true') {
                            this.setAttribute('value', 'false');
                        } else if (this.getAttribute('value') === '-1') {
                            this.setAttribute('value', '0');
                        }

                        this.setAttribute('aria-pressed', 'false');

                    } else {
                        this.setAttribute('selected', '');

                        if (this.getAttribute('value') === 'false') {
                            this.setAttribute('value', 'true');
                        } else if (this.getAttribute('value') === '0') {
                            this.setAttribute('value', '-1');
                        }

                        this.setAttribute('aria-pressed', 'true');
                    }

                    xtag.fireEvent(this, 'change', {
                        bubbles: true,
                        cancelable: true
                    });
                }
            }
        },
        accessors: {
            'value': {
                'get': function () {
                    // I don't know if the Boolean return is important, so for now, we'll put in a patch
                    if (this.hasAttribute('attrvalue')) {
                        return this.getAttribute('value');
                    }

                    return this.hasAttribute('selected'); //this.classList.contains('down');
                },

                'set': function (newValue) {
                    if (newValue === true || newValue === 'true') {
                        this.setAttribute('selected', '');
                        this.setAttribute('aria-pressed', 'true');
                    } else {
                        this.removeAttribute('selected');
                        this.setAttribute('aria-pressed', 'false');
                    }
                }
            },

            'textValue': {
                'get': function () {
                    return (
                        this.hasAttribute('selected')
                            ? 'YES'
                            : 'NO'
                    );
                },

                'set': function (newValue) {
                    if (newValue === true || newValue === 'true' || newValue === 'YES') {
                        this.setAttribute('selected', '');
                        this.setAttribute('aria-pressed', 'true');
                    } else {
                        this.removeAttribute('selected');
                        this.setAttribute('aria-pressed', 'false');
                    }
                }
            }
        },
        methods: {

        }
    });
});//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps
//global addAttributeSwitcherProp
//jslint browser:true, white:false, this:true
//not yet: maxlen:80

//begintooltipjs
window.addEventListener('design-register-element', function () {
    "use strict";
    addSnippet(
        '<gs-tooltip>',
        '<gs-tooltip>',
        'gs-tooltip column="${1:name}"></gs-tooltip>'
    );

    /*
    TODO: there is no documentation
    designRegisterElement('gs-tooltip', '#tooltip');
    */

    window.designElementProperty_GSTOOLTIP = function () {
        addText('V', 'Tip', 'tip');
        addAttributeSwitcherProp('V', 'Position', [
            {"val": "", "txt": "Default"},
            {"val": "left", "txt": "Left"},
            {"val": "right", "txt": "Right"},
            {"val": "top", "txt": "Top"},
            {"val": "bottom", "txt": "Bottom"}
        ]);
        addFlexContainerProps();
        addFlexProps();
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';


    function tooltipPos(forElement, tooltipElement, hidden) {
        var styleSheet;

        if (!document.getElementById('tooltip_cascading_style_sheet_with_a_long_id_that_will_never_be_used_in_the_wild')) {
            styleSheet = document.createElement('style');
            styleSheet.setAttribute('id', 'tooltip_cascading_style_sheet_with_a_long_id_that_will_never_be_used_in_the_wild');
            document.getElementsByTagName('head')[0].appendChild(styleSheet);
        } else {
            styleSheet = document.getElementById('tooltip_cascading_style_sheet_with_a_long_id_that_will_never_be_used_in_the_wild');
        }
        styleSheet.innerHTML = '';
        var jsnPositionData = GS.getElementPositionData(forElement);
        var arrTests;
        var strResolvedDirection;
        var element = tooltipElement.control;
        var pageWidth = document.body.getBoundingClientRect().width;
        element.classList.add('firsthover');

        // order of tests depending on direction
        if (element.hasAttribute('top')) {
            arrTests = ['top', 'bottom', 'left', 'right'];
        } else if (element.hasAttribute('bottom')) {
            arrTests = ['bottom', 'top', 'left', 'right'];
        } else if (element.hasAttribute('left')) {
            arrTests = ['left', 'right', 'bottom', 'top'];
        } else {// right
            arrTests = ['right', 'left', 'bottom', 'top'];
        }

        //check if there's room in each direction
        var i = 0;
        var len = arrTests.length;
        while (i < len) {
            //there is 10px of space in between the elements including the triangle
            if (
                (arrTests[i] === 'top' && (element.offsetHeight + 10) <= jsnPositionData.intRoomAbove) ||
                (arrTests[i] === 'bottom' && (element.offsetHeight + 10) <= jsnPositionData.intRoomBelow) ||
                (arrTests[i] === 'left' && (element.offsetWidth + 10) <= jsnPositionData.intRoomLeft) ||
                (arrTests[i] === 'right' && (element.offsetWidth + 10) <= jsnPositionData.intRoomRight)
            ) {
                strResolvedDirection = arrTests[i];
                break;
            }
            i += 1;
        }
        //we always default to right, this way you can scroll to the right on a phone
        //    you can't scroll to the left if it overflows
        if (!strResolvedDirection) {
            strResolvedDirection = 'right';
        }
        //we save the original attribute so as not to change the testing order
        //    all uses of the "left" etc. atttributes use the styleas attribute
        element.setAttribute('styleas', strResolvedDirection);
        //zero these out since we rely on it later
        element.style.left = 0;
        element.style.top = 0;
        element.style.maxWidth = '250px';

        //if the element is in a different place then the tooltip we need to use the getBoundingClientRect left/top to position the tootip


        if (strResolvedDirection === 'left') {
            element.style.left = ((forElement.getBoundingClientRect().left - element.getBoundingClientRect().left) - parseInt(element.offsetWidth, 10)) - 10 + 'px';
            element.style.top = forElement.getBoundingClientRect().top - element.getBoundingClientRect().top + 'px';


        } else if (strResolvedDirection === 'top') {
            element.style.left = (((forElement.getBoundingClientRect().width / 2) - (element.getBoundingClientRect().width / 2)) + (forElement.getBoundingClientRect().left - element.getBoundingClientRect().left)) + 'px';
            if ((element.getBoundingClientRect().left + element.offsetWidth) > pageWidth && (element.offsetWidth < pageWidth)) {
                styleSheet.innerHTML = '.tooltiptext::after { left: calc(50% + ' + (element.getBoundingClientRect().left - (pageWidth - element.offsetWidth)) + 'px) !important; }';
                element.style.left = (parseFloat(element.style.left, 10) - (element.getBoundingClientRect().left - (pageWidth - element.offsetWidth))) + 'px';
            }
            element.style.top = forElement.getBoundingClientRect().top - (element.getBoundingClientRect().top + element.offsetHeight + forElement.offsetHeight) + 10 + 'px';


        } else if (strResolvedDirection === 'bottom') {
            element.style.top = (forElement.offsetHeight) + 10 + forElement.getBoundingClientRect().top - element.getBoundingClientRect().top + 'px';
            element.style.left = (((forElement.getBoundingClientRect().width / 2) - (element.getBoundingClientRect().width / 2)) + (forElement.getBoundingClientRect().left - element.getBoundingClientRect().left)) + 'px';
            if ((element.getBoundingClientRect().left + element.offsetWidth) > pageWidth && (element.offsetWidth < pageWidth)) {
                styleSheet.innerHTML = '.tooltiptext::after { left: calc(50% + ' + (element.getBoundingClientRect().left - (pageWidth - element.offsetWidth)) + 'px) !important; }';
                element.style.left = (parseFloat(element.style.left, 10) - (element.getBoundingClientRect().left - (pageWidth - element.offsetWidth))) + 'px';
            }

        } else {// right
            element.style.left = (forElement.getBoundingClientRect().left + parseInt(forElement.offsetWidth, 10) + 10) - element.getBoundingClientRect().left + 'px';
            element.style.top = forElement.getBoundingClientRect().top - element.getBoundingClientRect().top + 'px';
        }
        //make element visible
        if (!hidden) {
            element.classList.add('hover');
        } else {
            element.classList.remove('firsthover');
        }
    }

    function toolTipBodyClickEvent(element) {
        //hover makes the element visible
        element.control.classList.remove('firsthover');
        element.control.classList.remove('hover');
    }

    function toolTipClickEvent(forElement, tooltipElement) {
        //prevent event bubbling to body
        event.preventDefault();
        event.stopPropagation();
        //remove all open tooltips
        if (xtag.query(document.body, '.tooltiptext.hover').length > 0) {
            var i = 0;
            var len = xtag.query(document.body, '.tooltiptext.hover').length;
            while (i < len) {
                xtag.query(document.body, '.tooltiptext.hover')[i].classList.remove('firsthover');
                xtag.query(document.body, '.tooltiptext.hover')[i].classList.remove('hover');
                i += 1;
            }
        }
        //position tooltips
        tooltipPos(forElement, tooltipElement);
        tooltipElement.toolTipBodyClickEvent = function () {
            toolTipBodyClickEvent(tooltipElement);
        };
        document.body.addEventListener('click', tooltipElement.toolTipBodyClickEvent);
    }

    function toolTipMouseOverEvent(forElement, tooltipElement) {
        //setting the position of the element
        tooltipPos(forElement, tooltipElement);
    }

    function toolTipMouseOutEvent(ignore, tooltipElement) { //forElement
        tooltipElement.control.classList.remove('firsthover');
        tooltipElement.control.classList.remove('hover');
    }

    function toolTipResizeEvent(forElement, tooltipElement) {
        //nothing should happen if it's not open
        var bolRun = (tooltipElement.control.classList.contains('hover'));

        if (bolRun) {
            tooltipPos(forElement, tooltipElement);
        } else {
            // tooltipPos(forElement, tooltipElement, true);
        }
    }

    function initTooltip(forElement, tooltipElement) {
        // tooltipPos(forElement, tooltipElement, true);
        //we use element.function so we can pass the vars without doing it anon, this way we can removeEventListener later
        tooltipElement.toolTipResizeEvent = function () {
            toolTipResizeEvent(forElement, tooltipElement);
        };
        tooltipElement.toolTipMouseOverEvent = function () {
            toolTipMouseOverEvent(forElement, tooltipElement);
        };
        tooltipElement.toolTipMouseOutEvent = function () {
            toolTipMouseOutEvent(forElement, tooltipElement);
        };
        tooltipElement.toolTipClickEvent = function () {
            toolTipClickEvent(forElement, tooltipElement);
        };
        window.addEventListener('resize', tooltipElement.toolTipResizeEvent);
        forElement.addEventListener('mouseover', tooltipElement.toolTipMouseOverEvent);
        forElement.addEventListener('mouseout', tooltipElement.toolTipMouseOutEvent);
        forElement.addEventListener('click', tooltipElement.toolTipClickEvent);
    }

    function deInitTooltip(forElement, tooltipElement) {
        //in case the for changes we need to be able to reset the element it's targeting
        window.removeEventListener('resize', tooltipElement.toolTipResizeEvent);
        forElement.removeEventListener('mouseover', tooltipElement.toolTipMouseOverEvent);
        forElement.removeEventListener('mouseout', tooltipElement.toolTipMouseOutEvent);
        forElement.removeEventListener('click', tooltipElement.toolTipClickEvent);
        document.body.removeEventListener('click', tooltipElement.toolTipBodyClickEvent);
    }

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.value || '');

            i += 1;
        }
    }

    function getForElement(element, callback) {
        var forElement;
        if (element.hasAttribute('for')) {//if for attribute, use that
            forElement = document.getElementById(element.getAttribute('for'));
        } else if (element.hasAttribute('tip') && element.children.length > 1) {//if tip attribute, use second element if there (we already added span)
            forElement = element.children[1];
        } else {//get next element
            if (element.nextElementSibling && element.nextElementSibling.tagName.toUpperCase() !== 'gs-tooltip') {
                forElement = element.nextElementSibling;
            }
        }
        if (forElement) {
            element.forElement = forElement;
            callback(forElement, element);
        } else {
            element.forElement = false;
            console.warn('"gs-tooltip" Not attached to element.');
        }
    }

    function elementInserted(element) {
        var newFirstElement;
        var newFirstElementCont;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                element.refresh();
                //set innerHTML of newFirstElement
                if (element.hasAttribute('tip')) {//if there is tip attribute we use that
                    newFirstElement = document.createElement('span');
                    newFirstElement.innerHTML = element.getAttribute('tip');
                } else {//else use the element innerHTML
                    newFirstElement = document.createElement('span');
                    newFirstElement.innerHTML = element.innerHTML;
                }

                //shared code: copying over attributes to newFirstElement
                if (element.hasAttribute('left')) {
                    newFirstElement.setAttribute('left', '');
                } else if (element.hasAttribute('top')) {
                    newFirstElement.setAttribute('top', '');
                } else if (element.hasAttribute('bottom')) {
                    newFirstElement.setAttribute('bottom', '');
                } else {//right
                    newFirstElement.setAttribute('right', '');
                }

                //add newFirstElement to element
                if (element.hasAttribute('tip')) {//if there is tip attribute we have to add container for positioning
                    newFirstElementCont = document.createElement('div');
                    newFirstElementCont.classList.add('tooltipcont');
                    newFirstElementCont.appendChild(newFirstElement);
                    element.insertBefore(newFirstElementCont, element.firstChild);
                    element.control = element.children[0].children[0];
                } else {//else we empty and add
                    element.innerHTML = '';
                    element.appendChild(newFirstElement);
                    element.control = element.children[0];
                }

                element.control.classList.add('tooltiptext');
                //get forElement
                //initalize tooltips
                getForElement(element, initTooltip);
            }
        }
    }

    xtag.register('gs-tooltip', {
        lifecycle: {
            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, ignore, newValue) {//oldValue
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    this.refresh();
                }
                //if you change the for then it wont work
                if (strAttrName === 'for') {
                    //the element might not have found a forElement, if it hasn't we don't want to deinit
                    if (this.forElement) {
                        //de-initalize so that it doesn't open for both forElements
                        deInitTooltip(this.forElement, this);
                        //reinit
                        getForElement(this, initTooltip);
                    } else {
                        //init
                        getForElement(this, initTooltip);
                    }
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            refresh: function () {
                //also reset the for? not adding this right now.


                //reset attribute in case it changed
                if (this.control) {
                    this.control.removeAttribute('left');
                    this.control.removeAttribute('top');
                    this.control.removeAttribute('bottom');
                    this.control.removeAttribute('right');

                    if (this.hasAttribute('left')) {
                        this.control.setAttribute('left', '');
                    } else if (this.hasAttribute('top')) {
                        this.control.setAttribute('top', '');
                    } else if (this.hasAttribute('bottom')) {
                        this.control.setAttribute('bottom', '');
                    } else {//right
                        this.control.setAttribute('right', '');
                    }
                }
            }
        }
    });
});
//endtooltipjs//global window, GS, ml, xtag, evt, ace, doT, CryptoJS, encodeHTML, Worker
//global addSnippet, addElement, addFlexProps, addCheck, addText, addSelect
//global addControlProps, addFlexContainerProps, addProp
//global addAttributeSwitcherProp, addGSControlProps, addCornerRoundProps
//global addIconProps
//jslint browser:true, maxlen:80, white:false, this:true

// # CODE INDEX:          <- (use "find" (CTRL-f or CMD-f) to skip to a section)
//      # TOP             <- (this just brings you back this index)
//      # ELEMENT DOCUMENTATION
//      # NOTES/IDEAS
//      # SNIPPET/DESIGN
//      # UTILITY FUNCTIONS
//      # ELEMENT FUNCTIONS
//      # RENDER FUNCTIONS
//      # EVENT FUNCTIONS
//          # WINDOW EVENTS
//          # RESIZE EVENTS
//          # DEVELOPER EVENTS
//          # HIGH LEVEL BINDING
//      # XTAG DEFINITION
//      # ELEMENT LIFECYCLE
//      # ELEMENT ACCESSORS
//      # ELEMENT METHODS
//      # PANE DECLARATION
//
// For code that needs to be completed:
//      # NEED CODING



// ############################################################################
// ########################## ELEMENT DOCUMENTATION ###########################
// ############################################################################


// ############################################################################
// ############################### NOTES/IDEAS ################################
// ############################################################################


// ############################################################################
// ############################## SNIPPET/DESIGN ##############################
// ############################################################################


document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var defaultColWidth = 50;

// ############################################################################
// ############################ UTILITY FUNCTIONS #############################
// ############################################################################

    // we need to be able to execute event attributes (like onafter_select)
    //      while being able to reference the combobox as "this" in the code.
    function evalInContext(element, strJS) {
        var execFunc = function () {
            return eval(strJS);
        };

        execFunc.call(element);
    }

    // we want to standardize event triggering in this element.
    function triggerEvent(element, strEvent) {
        GS.triggerEvent(element, strEvent);
        GS.triggerEvent(element, 'on' + strEvent);
        if (
            element.hasAttribute('on' + strEvent) &&
            // onfocus and onblur attributes are handled automatically by the
            //      browser
            strEvent !== 'focus' &&
            strEvent !== 'blur'
        ) {
            evalInContext(element, element.getAttribute('on' + strEvent));
        }
    }

    // we need a function that can take PX/EM units and convert them to numeric
    //      pixels. this is because we run off of pixels.
    function unitToPX(element, strUnit) {
        // if we need to convert em to px
        if (strUnit.toLowerCase().indexOf('em') > -1) {
            return GS.emToPx(element, strUnit);
        }

        return parseInt(strUnit, 10);
    }


// #############################################################################
// ############################# ELEMENT FUNCTIONS #############################
// #############################################################################

    // create internal structures and inner elements that persist through the
    //      whole lifetime of the element
    function prepareElement(element) {
        // we need a place to store elements so that we don't keep destroying
        //      and recreating elements
        element.elems = {};

        // we need a place to store event functions because, to unbind a
        //      specific event javascript requires that you have the
        //      original function that was bound to that event
        element.internalEvents = {};

        // this is where we store the variables pertaining to drag and drop
        //      resize of columns.
        element.internalResize = {
            "currentlyResizing": false
        };

        // resizing needs a one pixel line to show the users where they're
        //     going to stop resizing if they let the mouse go
        element.elems.resizeHelper = document.createElement('div');
        element.elems.resizeHelper.classList.add('pane-resize-helper');
    }

// #############################################################################
// ############################# RENDER FUNCTIONS ##############################
// #############################################################################

    // recalculate and reset column widths
    function render(element) {
        var i;
        var len;
        var intWidthPool;
        var arrPanes = element.panes;
        var intTotalWidth;
        var intLeft;
        var lastVisible;
        var pane;

        // we need to gather the developer's width settings
        i = 0;
        len = arrPanes.length;
        while (i < len) {
            pane = arrPanes[i];

            if (!pane.internalDisplay) {
                pane.internalDisplay = {
                    "setActColWidths": null,
                    "setMinColWidths": null,
                    "setMaxColWidths": null,
                    "ratioWidths": null,
                    "colWidths": null,
                    "colRatios": null
                };

                // we want to retain the developer's declared width settings
                pane.internalDisplay.setActColWidths = (
                    unitToPX(element, pane.style.width)
                );
                pane.internalDisplay.setMinColWidths = (
                    unitToPX(element, pane.style.minWidth)
                );
                pane.internalDisplay.setMaxColWidths = (
                    unitToPX(element, pane.style.maxWidth)
                );

                // we don't want the css settings to mess with us down the line.
                //      now that we have them saved, we need to clear them.
                pane.style.width = '';
                pane.style.minWidth = '';
                pane.style.maxWidth = '';
            }

            i += 1;
        }

        // the way the auto resizing works is that columns with a
        //      "width" style set get a static width, the items with a
        //      min-width get a ratio. The static items get their
        //      amount of the width "pool". After the static items get
        //      their fill, the ratioed items get the rest of the width
        //      in their proportion.

        // ultimately, we're going to try to fit the columns into
        //      the viewport
        intWidthPool = (element.clientWidth);

        // let's gather the most up-to-date info on the columns
        intTotalWidth = 0;
        i = 0;
        len = arrPanes.length;
        while (i < len) {
            pane = arrPanes[i];

            // "ratioWidths" is used not only to determine the proportions of
            //      the columns, but if it's filled for a particular column,
            //      that means that it's a stretchy column and that it's
            //      visible.
            pane.internalDisplay.ratioWidths = null;

            // clear all other state variables we calculate in this render
            //      function
            pane.internalDisplay.colRatios = null;
            pane.internalDisplay.colWidths = null;

            // we only need to look at non-hidden columns
            if (!arrPanes[i].hasAttribute('hidden')) {
                // if this column has a set width, remove it's width from the
                //      available pool and don't set it's "ratioWidths"
                if (pane.internalDisplay.setActColWidths) {
                    intWidthPool -= pane.internalDisplay.setActColWidths;

                // get this column's width so that we can calculate it's
                //      stretched width
                } else {
                    pane.internalDisplay.ratioWidths = (
                        pane.internalDisplay.setMinColWidths ||
                        defaultColWidth
                    );

                    // in order to calculate the ratios, we need to know the
                    //      combined width of the stretchy column min-widths
                    intTotalWidth += (
                        pane.internalDisplay.ratioWidths
                    );
                }
            }
            i += 1;
        }

        // calculate column widths
        intLeft = 0;
        i = 0;
        len = arrPanes.length;
        while (i < len) {
            pane = arrPanes[i];

            // if this column is stretchy
            if (pane.internalDisplay.ratioWidths) {
                // we need to know how big the stretchable columns are in
                //      relation to each other so that we can stretch them in
                //      proportion
                pane.internalDisplay.colRatios = (
                    (
                        (pane.internalDisplay.ratioWidths) /
                        intTotalWidth
                    ) * 100
                );

                // now that we have the ratio calculated, let's apply it and
                //      determine the final width
                pane.internalDisplay.colWidths = (
                    // don't get smaller than min column width
                    Math.max(
                        intWidthPool / (
                            100 / pane.internalDisplay.colRatios
                        ),
                        (pane.internalDisplay.setMinColWidths || 0)
                    )
                );

            // else, this column is static
            } else {
                pane.internalDisplay.colWidths = (
                    pane.internalDisplay.setActColWidths
                );
            }

            // clear pane state
            pane.classList.remove('last');
            pane.style.width = '';
            pane.style.left = '';

            // we only want to apply width/left to visible panes
            if (!pane.hasAttribute('hidden')) {
                // set left/width according to the latest calculations
                pane.style.width = (pane.internalDisplay.colWidths + 'px');
                pane.style.left = (intLeft + 'px');

                // increment the current left position
                intLeft += pane.internalDisplay.colWidths;

                // we want to reference the last visible pane after this loop
                lastVisible = pane;
            }

            i += 1;
        }

        // we always want to strip the right-side border off of the last
        //      visible pane
        lastVisible.classList.add('last');
    }


// #############################################################################
// ############################## EVENT FUNCTIONS ##############################
// #############################################################################

    // ############# WINDOW EVENTS #############
    function unbindWindow(element) {
        element.removeEventListener(
            'resize',
            element.internalEvents.windowResize
        );
    }
    function bindWindow(element) {
        element.internalEvents.windowResize = function () {
            render(element);
        };

        window.addEventListener(
            'resize',
            element.internalEvents.windowResize
        );
    }

    // ############# RESIZE EVENTS #############
    function unbindResize(element) {
        element.removeEventListener(
            'mousemove',
            element.internalEvents.resizeHandleHover
        );
        element.removeEventListener(
            evt.mousedown,
            element.internalEvents.resizeDragStart
        );
        document.body.removeEventListener(
            evt.mousemove,
            element.internalEvents.resizeDragMove
        );
        document.body.removeEventListener(
            evt.mouseup,
            element.internalEvents.resizeDragEnd
        );
    }
    function bindResize(element) {
        element.internalEvents.resizeHandleHover = function (event) {
            var jsnElementPos;
            var jsnMousePos;
            var intMouseX;
            var i;
            var len;
            var intLeft;
            var arrPanes;
            var pane;
            var resizePane;

            // no need to check if we're at a border if we're already resizing.
            if (element.internalResize.currentlyResizing !== true) {
                // we want the mouse position and the position of the element
                //      itself
                jsnElementPos = GS.getElementOffset(element);
                jsnMousePos = GS.mousePosition(event);

                // we need the mouse Y to be relative to the element
                intMouseX = (jsnMousePos.left - jsnElementPos.left);

                // loop through each visible pane and see if the mouse is within
                //      2px of a column border
                arrPanes = element.panes;
                intLeft = 0;
                i = 0;
                len = arrPanes.length;
                while (i < len) {
                    pane = arrPanes[i];

                    if (
                        !pane.hasAttribute('hidden') &&
                        !pane.classList.contains('last')
                    ) {
                        // we don't care about the left side of the first pane,
                        //      so the each loop checks the right side of the
                        //      pane.
                        intLeft += pane.clientWidth;

                        // if mouse is within a pixel of the border, that's the
                        //      one we want to resize, break out
                        if (
                            intMouseX >= (intLeft - 1) &&
                            intMouseX <= (intLeft + 1)
                        ) {
                            resizePane = pane;
                            break;
                        }
                    }

                    // if we've passed the mouse position, just break out of
                    //      loop. no sense in extra cycles
                    if (intLeft > intMouseX) {
                        break;
                    }

                    i += 1;
                }

                if (resizePane) {
                    element.classList.add('horizontal-resize-cursor');
                    element.internalResize.resizePane = resizePane;
                } else {
                    element.classList.remove('horizontal-resize-cursor');
                }
            }
        };

        element.addEventListener(
            'mousemove',
            element.internalEvents.resizeHandleHover
        );

        element.internalEvents.resizeDragEnd = function () {
            // we need to let everything know that we are no longer
            //      resizing cells
            element.internalResize.currentlyResizing = false;

            // remove cursor
            element.classList.remove('horizontal-resize-cursor');

            // remove helper
            element.removeChild(element.elems.resizeHelper);

            // unbind mousemove and mouseup
            document.body.removeEventListener(
                evt.mousemove,
                element.internalEvents.resizeDragMove
            );
            document.body.removeEventListener(
                evt.mouseup,
                element.internalEvents.resizeDragEnd
            );
        };

        element.internalEvents.resizeDragMove = function (event) {
            var jsnElementPos;
            var jsnMousePos;
            var intMouseLeft;
            var intPaneLeft;
            var intNewWidth;
            var intOldWidth;
            var resizePane;
            var difference;
            var i;
            var len;
            var arrPanes;
            var pane;
            var intStretchyPanes;

            // if the mouse moves off of the screen and then is moused up,
            //      we wont know it. so, if the mouse is up (and we're not
            //      on a touch device): preventDefault, stopPropagation and
            //      end the drag session
            if (event.which === 0 && !evt.touchDevice) {
                event.preventDefault();
                event.stopPropagation();
                element.internalEvents.resizeDragEnd();

            // we're still activly resize, update resize helper
            } else {
                // we want the mouse position and the position of the element
                //      itself
                jsnElementPos = GS.getElementOffset(element);
                jsnMousePos = GS.mousePosition(event);

                // we need the mouse Y to be relative to the element
                intMouseLeft = (jsnMousePos.left - jsnElementPos.left);

                // reposition helper line
                element.elems.resizeHelper.style.left = intMouseLeft + 'px';

                // resize pane in question
                resizePane = element.internalResize.resizePane;
                intPaneLeft = parseInt(resizePane.style.left, 10) || 0;
                intNewWidth = (intMouseLeft - intPaneLeft);

                // if static column, basic resize
                if (resizePane.internalDisplay.setActColWidths) {
                    resizePane.internalDisplay.setActColWidths = intNewWidth;

                // if stretchy column, resize so that the line will be where
                //      the user dropped it, despite the fact that the other
                //      stretchy columns will need to resize.
                } else {
                    intOldWidth = resizePane.internalDisplay.colWidths;
                    difference = (intNewWidth / intOldWidth);

                    // split difference between all stretchy columns to left,
                    //      if you don't do this, it acts wierd
                    arrPanes = element.panes;
                    intStretchyPanes = 0;
                    i = 0;
                    len = arrPanes.length;
                    while (i < len) {
                        pane = arrPanes[i];

                        if (!pane.internalDisplay.setActColWidths) {
                            intStretchyPanes += 1;
                        }
                        if (pane === resizePane) {
                            break;
                        }
                        i += 1;
                    }

                    // if we're dealing with more than one stretchy column, we
                    //      must distrute the difference SOIUZ NERUSHIMYJ
                    if (intStretchyPanes > 1) {
                        difference = (
                            difference + ((1 - difference) / intStretchyPanes)
                        );
                    }

                    // apply difference
                    i = 0;
                    len = arrPanes.length;
                    while (i < len) {
                        pane = arrPanes[i];

                        if (!pane.internalDisplay.setActColWidths) {
                            pane.internalDisplay.setMinColWidths = (
                                pane.internalDisplay.setMinColWidths *
                                (difference)
                            );
                        }
                        if (pane === resizePane) {
                            break;
                        }
                        i += 1;
                    }
                }

                // cause re-render
                render(element);
            }
        };

        element.internalEvents.resizeDragStart = function (event) {
            if (element.classList.contains('horizontal-resize-cursor')) {
                // we want to prevent text selection
                event.preventDefault();
                event.stopPropagation();

                // we need to let everything know that we are resizing cells,
                //      this is used to prevent cell selection during cell
                //      resize
                element.internalResize.currentlyResizing = true;

                // users need feedback for drag and drop. We're opting for
                //      showing a line
                element.appendChild(element.elems.resizeHelper);

                // update position of resize helper
                element.internalEvents.resizeDragMove(event);

                // we need to bind the mousemove and mouseup functionality to
                //      the body so that we can still use the mouse events even
                //      if the mouse is no longer over the gs-table
                document.body.addEventListener(
                    evt.mousemove,
                    element.internalEvents.resizeDragMove
                );
                document.body.addEventListener(
                    evt.mouseup,
                    element.internalEvents.resizeDragEnd
                );
            }
        };
        element.addEventListener(
            evt.mousedown,
            element.internalEvents.resizeDragStart
        );
    }

    // ############# DEVELOPER EVENTS #############
    function unbindDeveloper(element) {
        element.removeEventListener(
            evt.mousedown,
            element.internalEvents.developerMouseDown
        );
    }
    function bindDeveloper(element) {
        element.internalEvents.developerMouseDown = function (event) {
            var bolCMDorCTRL = (event.ctrlKey || event.metaKey);
            var bolShift = (event.shiftKey);
            var strHTML;
            var arrAttr;
            var jsnAttr;
            var i;
            var len;

            if (bolCMDorCTRL && bolShift) {
                event.preventDefault();
                event.stopPropagation();

                strHTML = '';
                arrAttr = element.attributes;
                i = 0;
                len = arrAttr.length;
                while (i < len) {
                    jsnAttr = arrAttr[i];

                    strHTML += (
                        '<b>Attribute "' + encodeHTML(jsnAttr.name) + '":</b>' +
                        '<pre>' + encodeHTML(jsnAttr.value) + '</pre>'
                    );

                    i += 1;
                }

                GS.msgbox('Developer Info', strHTML, ['Ok']);
            }
        };

        element.addEventListener(
            evt.mousedown,
            element.internalEvents.developerMouseDown
        );
    }


    // ############# HIGH LEVEL BINDING #############
    function unbindElement(element) {
        unbindWindow(element);
        unbindResize(element);
        unbindDeveloper(element);
    }
    function bindElement(element) {
        bindWindow(element);
        bindResize(element);
        bindDeveloper(element);
    }


// #############################################################################
// ############################## XTAG DEFINITION ##############################
// #############################################################################

    function elementInserted(element) {
        if (
            // if "created"/"inserted" are not suspended: continue
            !element.hasAttribute('suspend-created') &&
            !element.hasAttribute('suspend-inserted') &&
            // if this is the first time inserted has been run: continue
            !element.inserted
        ) {
            element.inserted = true;

            prepareElement(element);
            bindElement(element);
            render(element);
        }
    }

    xtag.register('gs-window', {

// #############################################################################
// ############################# ELEMENT LIFECYCLE #############################
// #############################################################################

        lifecycle: {
            'inserted': function () {
                elementInserted(this);
            },

            // we want to make sure we don't leave any loose ends
            'removed': function () {
                unbindElement(this);
            },

            'attributeChanged': function (attr) {//, oldValue, newValue
                console.log('test');
                if (attr === 'suspend-created' || attr === 'suspend-inserted') {
                    elementInserted(this);
                }
            }
        },

// #############################################################################
// ############################# ELEMENT ACCESSORS #############################
// #############################################################################

        accessors: {
            'panes': {
                'get': function () {
                    return xtag.queryChildren(this, 'gs-pane');
                }
            }
        },

// #############################################################################
// ############################## ELEMENT METHODS ##############################
// #############################################################################

        methods: {
            // we want to be able to programatically show/hide panes
            'show': function (pane) {
                if (typeof pane === 'string') {
                    pane = xtag.queryChildren(this, pane)[0];
                }
                pane.removeAttribute('hidden');
                render(this);
            },

            // we want to be able to programatically show/hide panes
            'hide': function (pane) {
                if (typeof pane === 'string') {
                    pane = xtag.queryChildren(this, pane)[0];
                }
                pane.setAttribute('hidden', '');
                render(this);
            },

            // we want to be able to programatically show/hide panes
            'remove': function (pane) {
                if (typeof pane === 'string') {
                    pane = xtag.queryChildren(this, pane)[0];
                }
                this.removeChild(pane);
                render(this);
            },

            // we want to be able to programatically show/hide panes
            'add': function (pane) {
                if (typeof pane === 'string') {
                    pane = GS.stringToElement(pane);
                }
                this.appendChild(pane);
                render(this);
            },

            // we want to be able to programatically cause a re-render, this is
            //      useful in case the developer takes matters into their own
            //      hands and starts messing with panes directly
            'render': function () {
                render(this);
            }
        }
    });

// #############################################################################
// ############################## PANE DECLARATION #############################
// #############################################################################

    xtag.register('gs-pane', {
        lifecycle: {
            // if the developer changes the hidden state directly, notify the
            //      parent pane (if there is one)
            'attributeChanged': function (strAttrName) {
                // ### NEED CODING ### - doesn't seem to run
                console.log('sdf');
                if (strAttrName === 'hidden') {
                    if (this.parentNode.nodeName === 'GS-WINDOW') {
                        this.parentNode.render();
                    }
                }
            }
        },
        observedAttributes: ['hidden']
    });
});

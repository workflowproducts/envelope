//jslint white:true
/**

    ######## BEFORE UPDATING DATA-HANDLING CODE OR USING THE COALESCE OPERATOR: ######## ~michael
    don't use the pipe-pipe "||" coalesce operator when handling data because if a zero comes to the coalesce (and it is a number 0 and not a string "0") it will be evaluated as false and thus coalesce to the next operand. Whenever you use this operator: be careful of what will be evaluated.

    To see this in action run this in your console:

    console.log( true      || 'test' );  // logs:  true  (expected)
    console.log( false     || 'test' );  // logs: 'test' (expected)

    console.log( null      || 'test' );  // logs: 'test' (expected)
    console.log( undefined || 'test' );  // logs: 'test' (expected)

    console.log( '1'       || 'test' );  // logs: '1'    (expected)
    console.log(  1        || 'test' );  // logs:  1     (expected)
    console.log( '0'       || 'test' );  // logs: '0'    (expected)
    console.log(  0        || 'test' );  // logs: 'test' (OH NO!!)

    here is another demonstration:

    console.log( Boolean(true)      );
    console.log( Boolean(false)     );
    console.log( Boolean(null)      );
    console.log( Boolean(undefined) );
    console.log( Boolean('1')       );
    console.log( Boolean( 1)        );
    console.log( Boolean('0')       );
    console.log( Boolean( 0)        ); // zero evaluates to false


    ######## BEFORE UPDATING FASTCLICK: ######## ~michael
    fastclick (around line 254) has some code added (by michael) to add a feature to fastclick, bring this code to any new version

    it also has (around line 123) some code added to an if statement added by joseph:
        if (deviceIsAndroid || deviceIsIOS) {
    as opposed to:
        if (deviceIsAndroid) {


    ######## BEFORE UPDATING X-TAGS: ######## ~michael and nunzio
    nunzio: the below warning now seems to be outdated
    nunzio: you have to delete '"function"==typeof define&&define.amd?define(X):"undefined"!=typeof module&&module.exports?module.exports=X:' from xtags for electron
    make sure you include the polyfills and make sure that there isn't still a duplicated block of code in the source, if there is remove it, here is how to find out:

    do a find in textedit for: "scope.upgradeDocumentTree = nop;" (excluding the quotes of course)
    AND var IMPORT_LINK_TYPE = scope.IMPORT_LINK_TYPE

    remove the whole block of code surrounding the second match (it might be the first match but I think it is the second match)


    ######## ELEMENT REGISTRATION: ######## ~michael
    When registering a custom element:
        1) register it after the "DOMContentLoaded" event has fired. Doing this prevents an issue that we ran into where in some cases (I believe when greyspots.js is cached and you are on yosemite is one case) some elements would be cut off and would disappear.
        2) Use the "methods" for public functions only, private functions should be kept in the "DOMContentLoaded" function. By keeping the functions in there it makes it so that the code for that element is the only code that can run those functions and it prevents these functions for cluttering public namespaces.
        3) Use "'use strict';" from the beginning. If you don't start out with it you might introduce strict mode errors that you don't even know about. Then one day you might decide to put "'use strict';" in there and errors you didn't know about will appear. Some errors might appear when you first move it over and some errors might be disvovered by your users because you didn't test every little feature of the element.

    An example:

    document.addEventListener('DOMContentLoaded', function () {
        'use strict';

        // ### private functions go here ###
        function foobar() {
            // do stuff to "element" here (gs-new-element is the only element that can run this function)
        }

        xtag.register('gs-new-element', {
            lifecycle: {
                'created': function () {

                }
            },
            events: {},
            accessors: {},
            methods: {
                // ### public functions go here ###
            }
        });
    });

    ######## PSEUDO ELEMENT WARNING: ######## ~michael
    In firefox I ran into an issue where the undo history of controls in a gs-form (with the attribute "save-while-typing") was being erased. Turns out the issue was caused by a CSS pseudo-element. I was using a pseudo-element for a little box attached to the form to tell the user if the form was waiting to save or saving. By changing the pseudo-element to a real element that I add and remove with Javascript the issue was fixed.

    If you want to use a pseudo-element: make sure it doesn't affect the undo history of elements that are children of the element that the pseudo-element is attached to. This issue could have been fixed by now.



    ######## TEMPLATE SHIM: ######## ~michael
    The template polyfill has been changed, DO NOT UPDATE. It is for old browsers, and old browsers don't change so there is should be no need for the polyfill to change.

*//**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

// minimal template polyfill
if (typeof HTMLTemplateElement === 'undefined') {
  (function() {

    var TEMPLATE_TAG = 'template';

    var contentDoc = document.implementation.createHTMLDocument('template');

    /**
      Provides a minimal shim for the <template> element.
    */
    HTMLTemplateElement = function() {};
    HTMLTemplateElement.prototype = Object.create(HTMLElement.prototype);

    /**
      The `decorate` method moves element children to the template's `content`.
      NOTE: there is no support for dynamically adding elements to templates.
    */
    HTMLTemplateElement.decorate = function(template) {
        if (!template.content) {
            template.content = template.ownerDocument.createDocumentFragment();
        }
        var child;
        while (child = template.firstChild) {
            template.content.appendChild(child);
        }

        if (!template.content.children) {
            Object.defineProperty(template.content, 'children', {
                get: function() {
                    'use strict';
                    var arrChildren = [], i, len, childNodes = this.childNodes;

                    for (i = 0, len = childNodes.length; i < len; i += 1) {
                        if (childNodes[i].nodeType !== 3) {
                            arrChildren.push(childNodes[i]);
                        }
                    }

                    return arrChildren;
                },
                configurable: true
            });
        }

        //HTMLTemplateElement.bootstrap(template.content);

        //console.log(template.content);

        // add innerHTML to template
        Object.defineProperty(template, 'innerHTML', {
            get: function() {
                var o = '', fragment = this.content.cloneNode(true);//,
                    //templates = xtag.toArray(fragment.querySelectorAll(TEMPLATE_TAG)), i, l;

                //for (i = 0, l = templates.length; i < l; i += 1) {
                //    templates[i].outerHTML = templates[i].outerHTML;
                //    console.log(templates[i].outerHTML);
                //}

                for (var e = fragment.firstChild; e; e = e.nextSibling) {
                    o += e.outerHTML || escapeData(e.data);
                }

                //console.log(o);

                return o;
            },
            set: function(text) {
                contentDoc.body.innerHTML = text;

                while (this.content.firstChild) {
                    this.content.removeChild(this.content.firstChild);
                }
                while (contentDoc.body.firstChild) {
                    this.content.appendChild(contentDoc.body.firstChild);
                }
                //HTMLTemplateElement.bootstrap(this.content);
            },
            configurable: true
            //writable: true
        });

        // add outerHTML to template
        Object.defineProperty(template, 'outerHTML', {
            get: function () {
                var openTagText, arrAttr, i, len, innerHTML = this.innerHTML;

                arrAttr = this.attributes;

                for (i = 0, len = arrAttr.length, openTagText = '<template'; i < len; i += 1) { // >
                    openTagText += ' ' + arrAttr[i].nodeName + '="' + encodeHTML(arrAttr[i].value) + '"';
                }

                return openTagText + '>' + innerHTML + '</template>';
            },
            configurable: true
            //writable: true
        });
    };

    /**
      The `bootstrap` method is called automatically and "fixes" all
      <template> elements in the document referenced by the `doc` argument.
    */
    HTMLTemplateElement.bootstrap = function(doc) {
        var templates = doc.querySelectorAll(TEMPLATE_TAG), i, l, t;

        for (i = 0, l = templates.length, t; (i < l) && (t = templates[i]); i += 1) {
            if (!GS.findParentTag(t, 'template') && GS.findParentTag(t, 'html')) {
                HTMLTemplateElement.decorate(t);
            }
        }
    };

    // auto-bootstrapping for main document
    window.addEventListener('DOMContentLoaded', function() {
      HTMLTemplateElement.bootstrap(document);
    });

    // Patch document.createElement to ensure newly created templates have content
    var createElement = document.createElement;
    document.createElement = function() {
      'use strict';
      var el = createElement.apply(document, arguments);
      if (el.localName == 'template') {
        HTMLTemplateElement.decorate(el);
      }
      return el;
    };

    var escapeDataRegExp = /[&\u00A0<>]/g;

    function escapeReplace(c) {
      switch (c) {
        case '&':
          return '&amp;';
        case '<':
          return '&lt;';
        case '>':
          return '&gt;';
        case '\u00A0':
          return '&nbsp;';
      }
    }

    function escapeData(s) {
      return s.replace(escapeDataRegExp, escapeReplace);
    }
  })();
}(function(){function e(e){if(this._element=e,e.className!=this._classCache){if(this._classCache=e.className,!this._classCache)return;var t,n=this._classCache.replace(/^\s+|\s+$/g,"").split(/\s+/);for(t=0;n.length>t;t++)a.call(this,n[t])}}function t(e,t){e.className=t.join(" ")}function n(e,t,n){Object.defineProperty?Object.defineProperty(e,t,{get:n}):e.__defineGetter__(t,n)}if(!(window.Element===void 0||"classList"in document.documentElement)){var r=Array.prototype,o=r.indexOf,i=r.slice,a=r.push,s=r.splice,c=r.join;e.prototype={add:function(e){this.contains(e)||(a.call(this,e),t(this._element,i.call(this,0)))},contains:function(e){return-1!==o.call(this,e)},item:function(e){return this[e]||null},remove:function(e){var n=o.call(this,e);-1!==n&&(s.call(this,n,1),t(this._element,i.call(this,0)))},toString:function(){return c.call(this," ")},toggle:function(e){-1===o.call(this,e)?this.add(e):this.remove(e)}},window.DOMTokenList=e,n(Element.prototype,"classList",function(){return new e(this)})}})(),function(){window.WebComponents=window.WebComponents||{flags:{}};var e="webcomponents-lite.js",t=document.querySelector('script[src*="'+e+'"]'),n={};if(!n.noOpts){if(location.search.slice(1).split("&").forEach(function(e){var t,r=e.split("=");r[0]&&(t=r[0].match(/wc-(.+)/))&&(n[t[1]]=r[1]||!0)}),t)for(var r,o=0;r=t.attributes[o];o++)"src"!==r.name&&(n[r.name]=r.value||!0);if(n.log&&n.log.split){var i=n.log.split(",");n.log={},i.forEach(function(e){n.log[e]=!0})}else n.log={}}n.register&&(window.CustomElements=window.CustomElements||{flags:{}},window.CustomElements.flags.register=n.register),WebComponents.flags=n}(),function(e){"use strict";function t(e){return void 0!==h[e]}function n(){s.call(this),this._isInvalid=!0}function r(e){return""==e&&n.call(this),e.toLowerCase()}function o(e){var t=e.charCodeAt(0);return t>32&&127>t&&-1==[34,35,60,62,63,96].indexOf(t)?e:encodeURIComponent(e)}function i(e){var t=e.charCodeAt(0);return t>32&&127>t&&-1==[34,35,60,62,96].indexOf(t)?e:encodeURIComponent(e)}function a(e,a,s){function c(e){y.push(e)}var u=a||"scheme start",l=0,d="",b=!1,g=!1,y=[];e:for(;(e[l-1]!=f||0==l)&&!this._isInvalid;){var w=e[l];switch(u){case"scheme start":if(!w||!m.test(w)){if(a){c("Invalid scheme.");break e}d="",u="no scheme";continue}d+=w.toLowerCase(),u="scheme";break;case"scheme":if(w&&v.test(w))d+=w.toLowerCase();else{if(":"!=w){if(a){if(f==w)break e;c("Code point not allowed in scheme: "+w);break e}d="",l=0,u="no scheme";continue}if(this._scheme=d,d="",a)break e;t(this._scheme)&&(this._isRelative=!0),u="file"==this._scheme?"relative":this._isRelative&&s&&s._scheme==this._scheme?"relative or authority":this._isRelative?"authority first slash":"scheme data"}break;case"scheme data":"?"==w?(this._query="?",u="query"):"#"==w?(this._fragment="#",u="fragment"):f!=w&&"	"!=w&&"\n"!=w&&"\r"!=w&&(this._schemeData+=o(w));break;case"no scheme":if(s&&t(s._scheme)){u="relative";continue}c("Missing scheme."),n.call(this);break;case"relative or authority":if("/"!=w||"/"!=e[l+1]){c("Expected /, got: "+w),u="relative";continue}u="authority ignore slashes";break;case"relative":if(this._isRelative=!0,"file"!=this._scheme&&(this._scheme=s._scheme),f==w){this._host=s._host,this._port=s._port,this._path=s._path.slice(),this._query=s._query,this._username=s._username,this._password=s._password;break e}if("/"==w||"\\"==w)"\\"==w&&c("\\ is an invalid code point."),u="relative slash";else if("?"==w)this._host=s._host,this._port=s._port,this._path=s._path.slice(),this._query="?",this._username=s._username,this._password=s._password,u="query";else{if("#"!=w){var _=e[l+1],E=e[l+2];("file"!=this._scheme||!m.test(w)||":"!=_&&"|"!=_||f!=E&&"/"!=E&&"\\"!=E&&"?"!=E&&"#"!=E)&&(this._host=s._host,this._port=s._port,this._username=s._username,this._password=s._password,this._path=s._path.slice(),this._path.pop()),u="relative path";continue}this._host=s._host,this._port=s._port,this._path=s._path.slice(),this._query=s._query,this._fragment="#",this._username=s._username,this._password=s._password,u="fragment"}break;case"relative slash":if("/"!=w&&"\\"!=w){"file"!=this._scheme&&(this._host=s._host,this._port=s._port,this._username=s._username,this._password=s._password),u="relative path";continue}"\\"==w&&c("\\ is an invalid code point."),u="file"==this._scheme?"file host":"authority ignore slashes";break;case"authority first slash":if("/"!=w){c("Expected '/', got: "+w),u="authority ignore slashes";continue}u="authority second slash";break;case"authority second slash":if(u="authority ignore slashes","/"!=w){c("Expected '/', got: "+w);continue}break;case"authority ignore slashes":if("/"!=w&&"\\"!=w){u="authority";continue}c("Expected authority, got: "+w);break;case"authority":if("@"==w){b&&(c("@ already seen."),d+="%40"),b=!0;for(var T=0;d.length>T;T++){var C=d[T];if("	"!=C&&"\n"!=C&&"\r"!=C)if(":"!=C||null!==this._password){var M=o(C);null!==this._password?this._password+=M:this._username+=M}else this._password="";else c("Invalid whitespace in authority.")}d=""}else{if(f==w||"/"==w||"\\"==w||"?"==w||"#"==w){l-=d.length,d="",u="host";continue}d+=w}break;case"file host":if(f==w||"/"==w||"\\"==w||"?"==w||"#"==w){2!=d.length||!m.test(d[0])||":"!=d[1]&&"|"!=d[1]?0==d.length?u="relative path start":(this._host=r.call(this,d),d="",u="relative path start"):u="relative path";continue}"	"==w||"\n"==w||"\r"==w?c("Invalid whitespace in file host."):d+=w;break;case"host":case"hostname":if(":"!=w||g){if(f==w||"/"==w||"\\"==w||"?"==w||"#"==w){if(this._host=r.call(this,d),d="",u="relative path start",a)break e;continue}"	"!=w&&"\n"!=w&&"\r"!=w?("["==w?g=!0:"]"==w&&(g=!1),d+=w):c("Invalid code point in host/hostname: "+w)}else if(this._host=r.call(this,d),d="",u="port","hostname"==a)break e;break;case"port":if(/[0-9]/.test(w))d+=w;else{if(f==w||"/"==w||"\\"==w||"?"==w||"#"==w||a){if(""!=d){var L=parseInt(d,10);L!=h[this._scheme]&&(this._port=L+""),d=""}if(a)break e;u="relative path start";continue}"	"==w||"\n"==w||"\r"==w?c("Invalid code point in port: "+w):n.call(this)}break;case"relative path start":if("\\"==w&&c("'\\' not allowed in path."),u="relative path","/"!=w&&"\\"!=w)continue;break;case"relative path":if(f!=w&&"/"!=w&&"\\"!=w&&(a||"?"!=w&&"#"!=w))"	"!=w&&"\n"!=w&&"\r"!=w&&(d+=o(w));else{"\\"==w&&c("\\ not allowed in relative path.");var O;(O=p[d.toLowerCase()])&&(d=O),".."==d?(this._path.pop(),"/"!=w&&"\\"!=w&&this._path.push("")):"."==d&&"/"!=w&&"\\"!=w?this._path.push(""):"."!=d&&("file"==this._scheme&&0==this._path.length&&2==d.length&&m.test(d[0])&&"|"==d[1]&&(d=d[0]+":"),this._path.push(d)),d="","?"==w?(this._query="?",u="query"):"#"==w&&(this._fragment="#",u="fragment")}break;case"query":a||"#"!=w?f!=w&&"	"!=w&&"\n"!=w&&"\r"!=w&&(this._query+=i(w)):(this._fragment="#",u="fragment");break;case"fragment":f!=w&&"	"!=w&&"\n"!=w&&"\r"!=w&&(this._fragment+=w)}l++}}function s(){this._scheme="",this._schemeData="",this._username="",this._password=null,this._host="",this._port="",this._path=[],this._query="",this._fragment="",this._isInvalid=!1,this._isRelative=!1}function c(e,t){void 0===t||t instanceof c||(t=new c(t+"")),this._url=e,s.call(this);var n=e.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g,"");a.call(this,n,null,t)}var u=!1;if(!e.forceJURL)try{var l=new URL("b","http://a");l.pathname="c%20d",u="http://a/c%20d"===l.href}catch(d){}if(!u){var h=Object.create(null);h.ftp=21,h.file=0,h.gopher=70,h.http=80,h.https=443,h.ws=80,h.wss=443;var p=Object.create(null);p["%2e"]=".",p[".%2e"]="..",p["%2e."]="..",p["%2e%2e"]="..";var f=void 0,m=/[a-zA-Z]/,v=/[a-zA-Z0-9\+\-\.]/;c.prototype={toString:function(){return this.href},get href(){if(this._isInvalid)return this._url;var e="";return(""!=this._username||null!=this._password)&&(e=this._username+(null!=this._password?":"+this._password:"")+"@"),this.protocol+(this._isRelative?"//"+e+this.host:"")+this.pathname+this._query+this._fragment},set href(e){s.call(this),a.call(this,e)},get protocol(){return this._scheme+":"},set protocol(e){this._isInvalid||a.call(this,e+":","scheme start")},get host(){return this._isInvalid?"":this._port?this._host+":"+this._port:this._host},set host(e){!this._isInvalid&&this._isRelative&&a.call(this,e,"host")},get hostname(){return this._host},set hostname(e){!this._isInvalid&&this._isRelative&&a.call(this,e,"hostname")},get port(){return this._port},set port(e){!this._isInvalid&&this._isRelative&&a.call(this,e,"port")},get pathname(){return this._isInvalid?"":this._isRelative?"/"+this._path.join("/"):this._schemeData},set pathname(e){!this._isInvalid&&this._isRelative&&(this._path=[],a.call(this,e,"relative path start"))},get search(){return this._isInvalid||!this._query||"?"==this._query?"":this._query},set search(e){!this._isInvalid&&this._isRelative&&(this._query="?","?"==e[0]&&(e=e.slice(1)),a.call(this,e,"query"))},get hash(){return this._isInvalid||!this._fragment||"#"==this._fragment?"":this._fragment},set hash(e){this._isInvalid||(this._fragment="#","#"==e[0]&&(e=e.slice(1)),a.call(this,e,"fragment"))},get origin(){var e;if(this._isInvalid||!this._scheme)return"";switch(this._scheme){case"data":case"file":case"javascript":case"mailto":return"null"}return e=this.host,e?this._scheme+"://"+e:""}};var b=e.URL;b&&(c.createObjectURL=function(){return b.createObjectURL.apply(b,arguments)},c.revokeObjectURL=function(e){b.revokeObjectURL(e)}),e.URL=c}}(self),"undefined"==typeof WeakMap&&function(){var e=Object.defineProperty,t=Date.now()%1e9,n=function(){this.name="__st"+(1e9*Math.random()>>>0)+(t++ +"__")};n.prototype={set:function(t,n){var r=t[this.name];return r&&r[0]===t?r[1]=n:e(t,this.name,{value:[t,n],writable:!0}),this},get:function(e){var t;return(t=e[this.name])&&t[0]===e?t[1]:void 0},"delete":function(e){var t=e[this.name];return t&&t[0]===e?(t[0]=t[1]=void 0,!0):!1},has:function(e){var t=e[this.name];return t?t[0]===e:!1}},window.WeakMap=n}(),function(e){function t(e){w.push(e),y||(y=!0,m(r))}function n(e){return window.ShadowDOMPolyfill&&window.ShadowDOMPolyfill.wrapIfNeeded(e)||e}function r(){y=!1;var e=w;w=[],e.sort(function(e,t){return e.uid_-t.uid_});var t=!1;e.forEach(function(e){var n=e.takeRecords();o(e),n.length&&(e.callback_(n,e),t=!0)}),t&&r()}function o(e){e.nodes_.forEach(function(t){var n=v.get(t);n&&n.forEach(function(t){t.observer===e&&t.removeTransientObservers()})})}function i(e,t){for(var n=e;n;n=n.parentNode){var r=v.get(n);if(r)for(var o=0;r.length>o;o++){var i=r[o],a=i.options;if(n===e||a.subtree){var s=t(a);s&&i.enqueue(s)}}}}function a(e){this.callback_=e,this.nodes_=[],this.records_=[],this.uid_=++_}function s(e,t){this.type=e,this.target=t,this.addedNodes=[],this.removedNodes=[],this.previousSibling=null,this.nextSibling=null,this.attributeName=null,this.attributeNamespace=null,this.oldValue=null}function c(e){var t=new s(e.type,e.target);return t.addedNodes=e.addedNodes.slice(),t.removedNodes=e.removedNodes.slice(),t.previousSibling=e.previousSibling,t.nextSibling=e.nextSibling,t.attributeName=e.attributeName,t.attributeNamespace=e.attributeNamespace,t.oldValue=e.oldValue,t}function u(e,t){return E=new s(e,t)}function l(e){return T?T:(T=c(E),T.oldValue=e,T)}function d(){E=T=void 0}function h(e){return e===T||e===E}function p(e,t){return e===t?e:T&&h(e)?T:null}function f(e,t,n){this.observer=e,this.target=t,this.options=n,this.transientObservedNodes=[]}if(!e.JsMutationObserver){var m,v=new WeakMap;if(/Trident|Edge/.test(navigator.userAgent))m=setTimeout;else if(window.setImmediate)m=window.setImmediate;else{var b=[],g=Math.random()+"";window.addEventListener("message",function(e){if(e.data===g){var t=b;b=[],t.forEach(function(e){e()})}}),m=function(e){b.push(e),window.postMessage(g,"*")}}var y=!1,w=[],_=0;a.prototype={observe:function(e,t){if(e=n(e),!t.childList&&!t.attributes&&!t.characterData||t.attributeOldValue&&!t.attributes||t.attributeFilter&&t.attributeFilter.length&&!t.attributes||t.characterDataOldValue&&!t.characterData)throw new SyntaxError;var r=v.get(e);r||v.set(e,r=[]);for(var o,i=0;r.length>i;i++)if(r[i].observer===this){o=r[i],o.removeListeners(),o.options=t;break}o||(o=new f(this,e,t),r.push(o),this.nodes_.push(e)),o.addListeners()},disconnect:function(){this.nodes_.forEach(function(e){for(var t=v.get(e),n=0;t.length>n;n++){var r=t[n];if(r.observer===this){r.removeListeners(),t.splice(n,1);break}}},this),this.records_=[]},takeRecords:function(){var e=this.records_;return this.records_=[],e}};var E,T;f.prototype={enqueue:function(e){var n=this.observer.records_,r=n.length;if(n.length>0){var o=n[r-1],i=p(o,e);if(i)return n[r-1]=i,void 0}else t(this.observer);n[r]=e},addListeners:function(){this.addListeners_(this.target)},addListeners_:function(e){var t=this.options;t.attributes&&e.addEventListener("DOMAttrModified",this,!0),t.characterData&&e.addEventListener("DOMCharacterDataModified",this,!0),t.childList&&e.addEventListener("DOMNodeInserted",this,!0),(t.childList||t.subtree)&&e.addEventListener("DOMNodeRemoved",this,!0)},removeListeners:function(){this.removeListeners_(this.target)},removeListeners_:function(e){var t=this.options;t.attributes&&e.removeEventListener("DOMAttrModified",this,!0),t.characterData&&e.removeEventListener("DOMCharacterDataModified",this,!0),t.childList&&e.removeEventListener("DOMNodeInserted",this,!0),(t.childList||t.subtree)&&e.removeEventListener("DOMNodeRemoved",this,!0)},addTransientObserver:function(e){if(e!==this.target){this.addListeners_(e),this.transientObservedNodes.push(e);var t=v.get(e);t||v.set(e,t=[]),t.push(this)}},removeTransientObservers:function(){var e=this.transientObservedNodes;this.transientObservedNodes=[],e.forEach(function(e){this.removeListeners_(e);for(var t=v.get(e),n=0;t.length>n;n++)if(t[n]===this){t.splice(n,1);break}},this)},handleEvent:function(e){switch(e.stopImmediatePropagation(),e.type){case"DOMAttrModified":var t=e.attrName,n=e.relatedNode.namespaceURI,r=e.target,o=new u("attributes",r);o.attributeName=t,o.attributeNamespace=n;var a=e.attrChange===MutationEvent.ADDITION?null:e.prevValue;i(r,function(e){return!e.attributes||e.attributeFilter&&e.attributeFilter.length&&-1===e.attributeFilter.indexOf(t)&&-1===e.attributeFilter.indexOf(n)?void 0:e.attributeOldValue?l(a):o});break;case"DOMCharacterDataModified":var r=e.target,o=u("characterData",r),a=e.prevValue;i(r,function(e){return e.characterData?e.characterDataOldValue?l(a):o:void 0});break;case"DOMNodeRemoved":this.addTransientObserver(e.target);case"DOMNodeInserted":var s,c,h=e.target;"DOMNodeInserted"===e.type?(s=[h],c=[]):(s=[],c=[h]);var p=h.previousSibling,f=h.nextSibling,o=u("childList",e.target.parentNode);o.addedNodes=s,o.removedNodes=c,o.previousSibling=p,o.nextSibling=f,i(e.relatedNode,function(e){return e.childList?o:void 0})}d()}},e.JsMutationObserver=a,e.MutationObserver||(e.MutationObserver=a,a._isPolyfilled=!0)}}(self),"undefined"==typeof HTMLTemplateElement&&function(){function e(e){switch(e){case"&":return"&amp;";case"<":return"&lt;";case">":return"&gt;";case" ":return"&nbsp;"}}function t(t){return t.replace(a,e)}var n="template",r=document.implementation.createHTMLDocument("template"),o=!0;HTMLTemplateElement=function(){},HTMLTemplateElement.prototype=Object.create(HTMLElement.prototype),HTMLTemplateElement.decorate=function(e){if(!e.content){e.content=r.createDocumentFragment();for(var n;n=e.firstChild;)e.content.appendChild(n);if(o)try{Object.defineProperty(e,"innerHTML",{get:function(){for(var e="",n=this.content.firstChild;n;n=n.nextSibling)e+=n.outerHTML||t(n.data);return e},set:function(e){for(r.body.innerHTML=e,HTMLTemplateElement.bootstrap(r);this.content.firstChild;)this.content.removeChild(this.content.firstChild);for(;r.body.firstChild;)this.content.appendChild(r.body.firstChild)},configurable:!0})}catch(i){o=!1}HTMLTemplateElement.bootstrap(e.content)}},HTMLTemplateElement.bootstrap=function(e){for(var t,r=e.querySelectorAll(n),o=0,i=r.length;i>o&&(t=r[o]);o++)HTMLTemplateElement.decorate(t)},document.addEventListener("DOMContentLoaded",function(){HTMLTemplateElement.bootstrap(document)});var i=document.createElement;document.createElement=function(){"use strict";var e=i.apply(document,arguments);return"template"==e.localName&&HTMLTemplateElement.decorate(e),e};var a=/[&\u00A0<>]/g}(),function(){"use strict";if(!window.performance){var e=Date.now();window.performance={now:function(){return Date.now()-e}}}window.requestAnimationFrame||(window.requestAnimationFrame=function(){var e=window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame;return e?function(t){return e(function(){t(performance.now())})}:function(e){return window.setTimeout(e,1e3/60)}}()),window.cancelAnimationFrame||(window.cancelAnimationFrame=function(){return window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||function(e){clearTimeout(e)}}());var t=function(){var e=document.createEvent("Event");return e.initEvent("foo",!0,!0),e.preventDefault(),e.defaultPrevented}();if(!t){var n=Event.prototype.preventDefault;Event.prototype.preventDefault=function(){this.cancelable&&(n.call(this),Object.defineProperty(this,"defaultPrevented",{get:function(){return!0},configurable:!0}))}}var r=/Trident/.test(navigator.userAgent);if((!window.CustomEvent||r&&"function"!=typeof window.CustomEvent)&&(window.CustomEvent=function(e,t){t=t||{};var n=document.createEvent("CustomEvent");return n.initCustomEvent(e,Boolean(t.bubbles),Boolean(t.cancelable),t.detail),n},window.CustomEvent.prototype=window.Event.prototype),!window.Event||r&&"function"!=typeof window.Event){var o=window.Event;window.Event=function(e,t){t=t||{};var n=document.createEvent("Event");return n.initEvent(e,Boolean(t.bubbles),Boolean(t.cancelable)),n},window.Event.prototype=o.prototype}}(window.WebComponents),window.HTMLImports=window.HTMLImports||{flags:{}},function(e){function t(e,t){t=t||f,r(function(){i(e,t)},t)}function n(e){return"complete"===e.readyState||e.readyState===b}function r(e,t){if(n(t))e&&e();else{var o=function(){("complete"===t.readyState||t.readyState===b)&&(t.removeEventListener(g,o),r(e,t))};t.addEventListener(g,o)}}function o(e){e.target.__loaded=!0}function i(e,t){function n(){c==u&&e&&e({allImports:s,loadedImports:l,errorImports:d})}function r(e){o(e),l.push(this),c++,n()}function i(){d.push(this),c++,n()}var s=t.querySelectorAll("link[rel=import]"),c=0,u=s.length,l=[],d=[];if(u)for(var h,p=0;u>p&&(h=s[p]);p++)a(h)?(l.push(this),c++,n()):(h.addEventListener("load",r),h.addEventListener("error",i));else n()}function a(e){return d?e.__loaded||e.import&&"loading"!==e.import.readyState:e.__importParsed}function s(e){for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)c(t)&&u(t)}function c(e){return"link"===e.localName&&"import"===e.rel}function u(e){var t=e.import;t?o({target:e}):(e.addEventListener("load",o),e.addEventListener("error",o))}var l="import",d=Boolean(l in document.createElement("link")),h=Boolean(window.ShadowDOMPolyfill),p=function(e){return h?window.ShadowDOMPolyfill.wrapIfNeeded(e):e},f=p(document),m={get:function(){var e=window.HTMLImports.currentScript||document.currentScript||("complete"!==document.readyState?document.scripts[document.scripts.length-1]:null);return p(e)},configurable:!0};Object.defineProperty(document,"_currentScript",m),Object.defineProperty(f,"_currentScript",m);var v=/Trident/.test(navigator.userAgent),b=v?"complete":"interactive",g="readystatechange";d&&(new MutationObserver(function(e){for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)t.addedNodes&&s(t.addedNodes)}).observe(document.head,{childList:!0}),function(){if("loading"===document.readyState)for(var e,t=document.querySelectorAll("link[rel=import]"),n=0,r=t.length;r>n&&(e=t[n]);n++)u(e)}()),t(function(e){window.HTMLImports.ready=!0,window.HTMLImports.readyTime=(new Date).getTime();var t=f.createEvent("CustomEvent");t.initCustomEvent("HTMLImportsLoaded",!0,!0,e),f.dispatchEvent(t)}),e.IMPORT_LINK_TYPE=l,e.useNative=d,e.rootDocument=f,e.whenReady=t,e.isIE=v}(window.HTMLImports),function(e){var t=[],n=function(e){t.push(e)},r=function(){t.forEach(function(t){t(e)})};e.addModule=n,e.initializeModules=r}(window.HTMLImports),window.HTMLImports.addModule(function(e){var t=/(url\()([^)]*)(\))/g,n=/(@import[\s]+(?!url\())([^;]*)(;)/g,r={resolveUrlsInStyle:function(e,t){var n=e.ownerDocument,r=n.createElement("a");return e.textContent=this.resolveUrlsInCssText(e.textContent,t,r),e},resolveUrlsInCssText:function(e,r,o){var i=this.replaceUrls(e,o,r,t);return i=this.replaceUrls(i,o,r,n)},replaceUrls:function(e,t,n,r){return e.replace(r,function(e,r,o,i){var a=o.replace(/["']/g,"");return n&&(a=new URL(a,n).href),t.href=a,a=t.href,r+"'"+a+"'"+i})}};e.path=r}),window.HTMLImports.addModule(function(e){var t={async:!0,ok:function(e){return e.status>=200&&300>e.status||304===e.status||0===e.status},load:function(n,r,o){var i=new XMLHttpRequest;return(e.flags.debug||e.flags.bust)&&(n+="?"+Math.random()),i.open("GET",n,t.async),i.addEventListener("readystatechange",function(e){if(4===i.readyState){var n=null;try{var a=i.getResponseHeader("Location");a&&(n="/"===a.substr(0,1)?location.origin+a:a)}catch(e){console.error(e.message)}r.call(o,!t.ok(i)&&i,i.response||i.responseText,n)}}),i.send(),i},loadDocument:function(e,t,n){this.load(e,t,n).responseType="document"}};e.xhr=t}),window.HTMLImports.addModule(function(e){var t=e.xhr,n=e.flags,r=function(e,t){this.cache={},this.onload=e,this.oncomplete=t,this.inflight=0,this.pending={}};r.prototype={addNodes:function(e){this.inflight+=e.length;for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)this.require(t);this.checkDone()},addNode:function(e){this.inflight++,this.require(e),this.checkDone()},require:function(e){var t=e.src||e.href;e.__nodeUrl=t,this.dedupe(t,e)||this.fetch(t,e)},dedupe:function(e,t){return this.pending[e]?(this.pending[e].push(t),!0):this.cache[e]?(this.onload(e,t,this.cache[e]),this.tail(),!0):(this.pending[e]=[t],!1)},fetch:function(e,r){if(n.load&&console.log("fetch",e,r),e)if(e.match(/^data:/)){var o=e.split(","),i=o[0],a=o[1];a=i.indexOf(";base64")>-1?atob(a):decodeURIComponent(a),setTimeout(function(){this.receive(e,r,null,a)}.bind(this),0)}else{var s=function(t,n,o){this.receive(e,r,t,n,o)}.bind(this);t.load(e,s)}else setTimeout(function(){this.receive(e,r,{error:"href must be specified"},null)}.bind(this),0)},receive:function(e,t,n,r,o){this.cache[e]=r;for(var i,a=this.pending[e],s=0,c=a.length;c>s&&(i=a[s]);s++)this.onload(e,i,r,n,o),this.tail();this.pending[e]=null},tail:function(){--this.inflight,this.checkDone()},checkDone:function(){this.inflight||this.oncomplete()}},e.Loader=r}),window.HTMLImports.addModule(function(e){var t=function(e){this.addCallback=e,this.mo=new MutationObserver(this.handler.bind(this))};t.prototype={handler:function(e){for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)"childList"===t.type&&t.addedNodes.length&&this.addedNodes(t.addedNodes)},addedNodes:function(e){this.addCallback&&this.addCallback(e);for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)t.children&&t.children.length&&this.addedNodes(t.children)},observe:function(e){this.mo.observe(e,{childList:!0,subtree:!0})}},e.Observer=t}),window.HTMLImports.addModule(function(e){function t(e){return"link"===e.localName&&e.rel===l}function n(e){var t=r(e);return"data:text/javascript;charset=utf-8,"+encodeURIComponent(t)}function r(e){return e.textContent+o(e)}function o(e){var t=e.ownerDocument;t.__importedScripts=t.__importedScripts||0;var n=e.ownerDocument.baseURI,r=t.__importedScripts?"-"+t.__importedScripts:"";return t.__importedScripts++,"\n//# sourceURL="+n+r+".js\n"}function i(e){var t=e.ownerDocument.createElement("style");return t.textContent=e.textContent,a.resolveUrlsInStyle(t),t}var a=e.path,s=e.rootDocument,c=e.flags,u=e.isIE,l=e.IMPORT_LINK_TYPE,d="link[rel="+l+"]",h={documentSelectors:d,importsSelectors:[d,"link[rel=stylesheet]:not([type])","style:not([type])","script:not([type])",'script[type="application/javascript"]','script[type="text/javascript"]'].join(","),map:{link:"parseLink",script:"parseScript",style:"parseStyle"},dynamicElements:[],parseNext:function(){var e=this.nextToParse();e&&this.parse(e)},parse:function(e){if(this.isParsed(e))return c.parse&&console.log("[%s] is already parsed",e.localName),void 0;var t=this[this.map[e.localName]];t&&(this.markParsing(e),t.call(this,e))},parseDynamic:function(e,t){this.dynamicElements.push(e),t||this.parseNext()},markParsing:function(e){c.parse&&console.log("parsing",e),this.parsingElement=e},markParsingComplete:function(e){e.__importParsed=!0,this.markDynamicParsingComplete(e),e.__importElement&&(e.__importElement.__importParsed=!0,this.markDynamicParsingComplete(e.__importElement)),this.parsingElement=null,c.parse&&console.log("completed",e)},markDynamicParsingComplete:function(e){var t=this.dynamicElements.indexOf(e);t>=0&&this.dynamicElements.splice(t,1)},parseImport:function(e){if(e.import=e.__doc,window.HTMLImports.__importsParsingHook&&window.HTMLImports.__importsParsingHook(e),e.import&&(e.import.__importParsed=!0),this.markParsingComplete(e),e.__resource&&!e.__error?e.dispatchEvent(new CustomEvent("load",{bubbles:!1})):e.dispatchEvent(new CustomEvent("error",{bubbles:!1})),e.__pending)for(var t;e.__pending.length;)t=e.__pending.shift(),t&&t({target:e});this.parseNext()},parseLink:function(e){t(e)?this.parseImport(e):(e.href=e.href,this.parseGeneric(e))},parseStyle:function(e){var t=e;e=i(e),t.__appliedElement=e,e.__importElement=t,this.parseGeneric(e)},parseGeneric:function(e){this.trackElement(e),this.addElementToDocument(e)},rootImportForElement:function(e){for(var t=e;t.ownerDocument.__importLink;)t=t.ownerDocument.__importLink;return t},addElementToDocument:function(e){var t=this.rootImportForElement(e.__importElement||e);t.parentNode.insertBefore(e,t)},trackElement:function(e,t){var n=this,r=function(o){e.removeEventListener("load",r),e.removeEventListener("error",r),t&&t(o),n.markParsingComplete(e),n.parseNext()};if(e.addEventListener("load",r),e.addEventListener("error",r),u&&"style"===e.localName){var o=!1;if(-1==e.textContent.indexOf("@import"))o=!0;else if(e.sheet){o=!0;for(var i,a=e.sheet.cssRules,s=a?a.length:0,c=0;s>c&&(i=a[c]);c++)i.type===CSSRule.IMPORT_RULE&&(o=o&&Boolean(i.styleSheet))}o&&setTimeout(function(){e.dispatchEvent(new CustomEvent("load",{bubbles:!1}))})}},parseScript:function(t){var r=document.createElement("script");r.__importElement=t,r.src=t.src?t.src:n(t),e.currentScript=t,this.trackElement(r,function(){r.parentNode&&r.parentNode.removeChild(r),e.currentScript=null}),this.addElementToDocument(r)},nextToParse:function(){return this._mayParse=[],!this.parsingElement&&(this.nextToParseInDoc(s)||this.nextToParseDynamic())},nextToParseInDoc:function(e,n){if(e&&0>this._mayParse.indexOf(e)){this._mayParse.push(e);for(var r,o=e.querySelectorAll(this.parseSelectorsForNode(e)),i=0,a=o.length;a>i&&(r=o[i]);i++)if(!this.isParsed(r))return this.hasResource(r)?t(r)?this.nextToParseInDoc(r.__doc,r):r:void 0}return n},nextToParseDynamic:function(){return this.dynamicElements[0]},parseSelectorsForNode:function(e){var t=e.ownerDocument||e;return t===s?this.documentSelectors:this.importsSelectors},isParsed:function(e){return e.__importParsed},needsDynamicParsing:function(e){return this.dynamicElements.indexOf(e)>=0},hasResource:function(e){return t(e)&&void 0===e.__doc?!1:!0}};e.parser=h,e.IMPORT_SELECTOR=d}),window.HTMLImports.addModule(function(e){function t(e){return n(e,a)}function n(e,t){return"link"===e.localName&&e.getAttribute("rel")===t}function r(e){return!!Object.getOwnPropertyDescriptor(e,"baseURI")}function o(e,t){var n=document.implementation.createHTMLDocument(a);n._URL=t;var o=n.createElement("base");o.setAttribute("href",t),n.baseURI||r(n)||Object.defineProperty(n,"baseURI",{value:t});var i=n.createElement("meta");return i.setAttribute("charset","utf-8"),n.head.appendChild(i),n.head.appendChild(o),n.body.innerHTML=e,window.HTMLTemplateElement&&HTMLTemplateElement.bootstrap&&HTMLTemplateElement.bootstrap(n),n}var i=e.flags,a=e.IMPORT_LINK_TYPE,s=e.IMPORT_SELECTOR,c=e.rootDocument,u=e.Loader,l=e.Observer,d=e.parser,h={documents:{},documentPreloadSelectors:s,importsPreloadSelectors:[s].join(","),loadNode:function(e){p.addNode(e)},loadSubtree:function(e){var t=this.marshalNodes(e);p.addNodes(t)},marshalNodes:function(e){return e.querySelectorAll(this.loadSelectorsForNode(e))},loadSelectorsForNode:function(e){var t=e.ownerDocument||e;return t===c?this.documentPreloadSelectors:this.importsPreloadSelectors},loaded:function(e,n,r,a,s){if(i.load&&console.log("loaded",e,n),n.__resource=r,n.__error=a,t(n)){var c=this.documents[e];void 0===c&&(c=a?null:o(r,s||e),c&&(c.__importLink=n,this.bootDocument(c)),this.documents[e]=c),n.__doc=c}d.parseNext()},bootDocument:function(e){this.loadSubtree(e),this.observer.observe(e),d.parseNext()},loadedAll:function(){d.parseNext()}},p=new u(h.loaded.bind(h),h.loadedAll.bind(h));if(h.observer=new l,!document.baseURI){var f={get:function(){var e=document.querySelector("base");return e?e.href:window.location.href},configurable:!0};Object.defineProperty(document,"baseURI",f),Object.defineProperty(c,"baseURI",f)}e.importer=h,e.importLoader=p}),window.HTMLImports.addModule(function(e){var t=e.parser,n=e.importer,r={added:function(e){for(var r,o,i,a,s=0,c=e.length;c>s&&(a=e[s]);s++)r||(r=a.ownerDocument,o=t.isParsed(r)),i=this.shouldLoadNode(a),i&&n.loadNode(a),this.shouldParseNode(a)&&o&&t.parseDynamic(a,i)},shouldLoadNode:function(e){return 1===e.nodeType&&o.call(e,n.loadSelectorsForNode(e))},shouldParseNode:function(e){return 1===e.nodeType&&o.call(e,t.parseSelectorsForNode(e))}};n.observer.addCallback=r.added.bind(r);var o=HTMLElement.prototype.matches||HTMLElement.prototype.matchesSelector||HTMLElement.prototype.webkitMatchesSelector||HTMLElement.prototype.mozMatchesSelector||HTMLElement.prototype.msMatchesSelector}),function(e){function t(){window.HTMLImports.importer.bootDocument(r)}var n=e.initializeModules;if(e.isIE,!e.useNative){n();var r=e.rootDocument;"complete"===document.readyState||"interactive"===document.readyState&&!window.attachEvent?t():document.addEventListener("DOMContentLoaded",t)}}(window.HTMLImports),window.CustomElements=window.CustomElements||{flags:{}},function(e){var t=e.flags,n=[],r=function(e){n.push(e)},o=function(){n.forEach(function(t){t(e)})};e.addModule=r,e.initializeModules=o,e.hasNative=Boolean(document.registerElement),e.isIE=/Trident/.test(navigator.userAgent),e.useNative=!t.register&&e.hasNative&&!window.ShadowDOMPolyfill&&(!window.HTMLImports||window.HTMLImports.useNative)}(window.CustomElements),window.CustomElements.addModule(function(e){function t(e,t){n(e,function(e){return t(e)?!0:(r(e,t),void 0)}),r(e,t)}function n(e,t,r){var o=e.firstElementChild;if(!o)for(o=e.firstChild;o&&o.nodeType!==Node.ELEMENT_NODE;)o=o.nextSibling;for(;o;)t(o,r)!==!0&&n(o,t,r),o=o.nextElementSibling;return null}function r(e,n){for(var r=e.shadowRoot;r;)t(r,n),r=r.olderShadowRoot}function o(e,t){i(e,t,[])}function i(e,t,n){if(e=window.wrap(e),!(n.indexOf(e)>=0)){n.push(e);for(var r,o=e.querySelectorAll("link[rel="+a+"]"),s=0,c=o.length;c>s&&(r=o[s]);s++)r.import&&i(r.import,t,n);t(e)}}var a=window.HTMLImports?window.HTMLImports.IMPORT_LINK_TYPE:"none";e.forDocumentTree=o,e.forSubtree=t}),window.CustomElements.addModule(function(e){function t(e,t){return n(e,t)||r(e,t)}function n(t,n){return e.upgrade(t,n)?!0:(n&&a(t),void 0)}function r(e,t){y(e,function(e){return n(e,t)?!0:void 0})}function o(e){T.push(e),E||(E=!0,setTimeout(i))}function i(){E=!1;for(var e,t=T,n=0,r=t.length;r>n&&(e=t[n]);n++)e();T=[]}function a(e){_?o(function(){s(e)}):s(e)}function s(e){e.__upgraded__&&!e.__attached&&(e.__attached=!0,e.attachedCallback&&e.attachedCallback())}function c(e){u(e),y(e,function(e){u(e)})}function u(e){_?o(function(){l(e)}):l(e)}function l(e){e.__upgraded__&&e.__attached&&(e.__attached=!1,e.detachedCallback&&e.detachedCallback())}function d(e){for(var t=e,n=window.wrap(document);t;){if(t==n)return!0;t=t.parentNode||t.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&t.host}}function h(e){if(e.shadowRoot&&!e.shadowRoot.__watched){g.dom&&console.log("watching shadow-root for: ",e.localName);
for(var t=e.shadowRoot;t;)m(t),t=t.olderShadowRoot}}function p(e,n){if(g.dom){var r=n[0];if(r&&"childList"===r.type&&r.addedNodes&&r.addedNodes){for(var o=r.addedNodes[0];o&&o!==document&&!o.host;)o=o.parentNode;var i=o&&(o.URL||o._URL||o.host&&o.host.localName)||"";i=i.split("/?").shift().split("/").pop()}console.group("mutations (%d) [%s]",n.length,i||"")}var a=d(e);n.forEach(function(e){"childList"===e.type&&(C(e.addedNodes,function(e){e.localName&&t(e,a)}),C(e.removedNodes,function(e){e.localName&&c(e)}))}),g.dom&&console.groupEnd()}function f(e){for(e=window.wrap(e),e||(e=window.wrap(document));e.parentNode;)e=e.parentNode;var t=e.__observer;t&&(p(e,t.takeRecords()),i())}function m(e){if(!e.__observer){var t=new MutationObserver(p.bind(this,e));t.observe(e,{childList:!0,subtree:!0}),e.__observer=t}}function v(e){e=window.wrap(e),g.dom&&console.group("upgradeDocument: ",e.baseURI.split("/").pop());var n=e===window.wrap(document);t(e,n),m(e),g.dom&&console.groupEnd()}function b(e){w(e,v)}var g=e.flags,y=e.forSubtree,w=e.forDocumentTree,_=window.MutationObserver._isPolyfilled&&g["throttle-attached"];e.hasPolyfillMutations=_,e.hasThrottledAttached=_;var E=!1,T=[],C=Array.prototype.forEach.call.bind(Array.prototype.forEach),M=Element.prototype.createShadowRoot;M&&(Element.prototype.createShadowRoot=function(){var e=M.call(this);return window.CustomElements.watchShadow(this),e}),e.watchShadow=h,e.upgradeDocumentTree=b,e.upgradeDocument=v,e.upgradeSubtree=r,e.upgradeAll=t,e.attached=a,e.takeRecords=f}),window.CustomElements.addModule(function(e){function t(t,r){if("template"===t.localName&&window.HTMLTemplateElement&&HTMLTemplateElement.decorate&&HTMLTemplateElement.decorate(t),!t.__upgraded__&&t.nodeType===Node.ELEMENT_NODE){var o=t.getAttribute("is"),i=e.getRegisteredDefinition(t.localName)||e.getRegisteredDefinition(o);if(i&&(o&&i.tag==t.localName||!o&&!i.extends))return n(t,i,r)}}function n(t,n,o){return a.upgrade&&console.group("upgrade:",t.localName),n.is&&t.setAttribute("is",n.is),r(t,n),t.__upgraded__=!0,i(t),o&&e.attached(t),e.upgradeSubtree(t,o),a.upgrade&&console.groupEnd(),t}function r(e,t){Object.__proto__?e.__proto__=t.prototype:(o(e,t.prototype,t.native),e.__proto__=t.prototype)}function o(e,t,n){for(var r={},o=t;o!==n&&o!==HTMLElement.prototype;){for(var i,a=Object.getOwnPropertyNames(o),s=0;i=a[s];s++)r[i]||(Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(o,i)),r[i]=1);o=Object.getPrototypeOf(o)}}function i(e){e.createdCallback&&e.createdCallback()}var a=e.flags;e.upgrade=t,e.upgradeWithDefinition=n,e.implementPrototype=r}),window.CustomElements.addModule(function(e){function t(t,r){var c=r||{};if(!t)throw Error("document.registerElement: first argument `name` must not be empty");if(0>t.indexOf("-"))throw Error("document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '"+(t+"")+"'.");if(o(t))throw Error("Failed to execute 'registerElement' on 'Document': Registration failed for type '"+(t+"")+"'. The type name is invalid.");if(u(t))throw Error("DuplicateDefinitionError: a type with name '"+(t+"")+"' is already registered");return c.prototype||(c.prototype=Object.create(HTMLElement.prototype)),c.__name=t.toLowerCase(),c.lifecycle=c.lifecycle||{},c.ancestry=i(c.extends),a(c),s(c),n(c.prototype),l(c.__name,c),c.ctor=d(c),c.ctor.prototype=c.prototype,c.prototype.constructor=c.ctor,e.ready&&b(document),c.ctor}function n(e){if(!e.setAttribute._polyfilled){var t=e.setAttribute;e.setAttribute=function(e,n){r.call(this,e,n,t)};var n=e.removeAttribute;e.removeAttribute=function(e){r.call(this,e,null,n)},e.setAttribute._polyfilled=!0}}function r(e,t,n){e=e.toLowerCase();var r=this.getAttribute(e);n.apply(this,arguments);var o=this.getAttribute(e);this.attributeChangedCallback&&o!==r&&this.attributeChangedCallback(e,r,o)}function o(e){for(var t=0;E.length>t;t++)if(e===E[t])return!0}function i(e){var t=u(e);return t?i(t.extends).concat([t]):[]}function a(e){for(var t,n=e.extends,r=0;t=e.ancestry[r];r++)n=t.is&&t.tag;e.tag=n||e.__name,n&&(e.is=e.__name)}function s(e){if(!Object.__proto__){var t=HTMLElement.prototype;if(e.is){var n=document.createElement(e.tag);t=Object.getPrototypeOf(n)}for(var r,o=e.prototype,i=!1;o;)o==t&&(i=!0),r=Object.getPrototypeOf(o),r&&(o.__proto__=r),o=r;i||console.warn(e.tag+" prototype not found in prototype chain for "+e.is),e.native=t}}function c(e){return y(M(e.tag),e)}function u(e){return e?T[e.toLowerCase()]:void 0}function l(e,t){T[e]=t}function d(e){return function(){return c(e)}}function h(e,t,n){return e===C?p(t,n):L(e,t)}function p(e,t){e&&(e=e.toLowerCase()),t&&(t=t.toLowerCase());var n=u(t||e);if(n){if(e==n.tag&&t==n.is)return new n.ctor;if(!t&&!n.is)return new n.ctor}var r;return t?(r=p(e),r.setAttribute("is",t),r):(r=M(e),e.indexOf("-")>=0&&w(r,HTMLElement),r)}function f(e,t){var n=e[t];e[t]=function(){var e=n.apply(this,arguments);return g(e),e}}var m,v=e.isIE,b=e.upgradeDocumentTree,g=e.upgradeAll,y=e.upgradeWithDefinition,w=e.implementPrototype,_=e.useNative,E=["annotation-xml","color-profile","font-face","font-face-src","font-face-uri","font-face-format","font-face-name","missing-glyph"],T={},C="http://www.w3.org/1999/xhtml",M=document.createElement.bind(document),L=document.createElementNS.bind(document);m=Object.__proto__||_?function(e,t){return e instanceof t}:function(e,t){if(e instanceof t)return!0;for(var n=e;n;){if(n===t.prototype)return!0;n=n.__proto__}return!1},f(Node.prototype,"cloneNode"),f(document,"importNode"),v&&function(){var e=document.importNode;document.importNode=function(){var t=e.apply(document,arguments);if(t.nodeType==t.DOCUMENT_FRAGMENT_NODE){var n=document.createDocumentFragment();return n.appendChild(t),n}return t}}(),document.registerElement=t,document.createElement=p,document.createElementNS=h,e.registry=T,e.instanceof=m,e.reservedTagList=E,e.getRegisteredDefinition=u,document.register=document.registerElement}),function(e){function t(){i(window.wrap(document)),window.CustomElements.ready=!0;var e=window.requestAnimationFrame||function(e){setTimeout(e,16)};e(function(){setTimeout(function(){window.CustomElements.readyTime=Date.now(),window.HTMLImports&&(window.CustomElements.elapsed=window.CustomElements.readyTime-window.HTMLImports.readyTime),document.dispatchEvent(new CustomEvent("WebComponentsReady",{bubbles:!0}))})})}var n=e.useNative,r=e.initializeModules;if(e.isIE,n){var o=function(){};e.watchShadow=o,e.upgrade=o,e.upgradeAll=o,e.upgradeDocumentTree=o,e.upgradeSubtree=o,e.takeRecords=o,e.instanceof=function(e,t){return e instanceof t}}else r();var i=e.upgradeDocumentTree,a=e.upgradeDocument;if(window.wrap||(window.ShadowDOMPolyfill?(window.wrap=window.ShadowDOMPolyfill.wrapIfNeeded,window.unwrap=window.ShadowDOMPolyfill.unwrapIfNeeded):window.wrap=window.unwrap=function(e){return e}),window.HTMLImports&&(window.HTMLImports.__importsParsingHook=function(e){e.import&&a(wrap(e.import))}),"complete"===document.readyState||e.flags.eager)t();else if("interactive"!==document.readyState||window.attachEvent||window.HTMLImports&&!window.HTMLImports.ready){var s=window.HTMLImports&&!window.HTMLImports.ready?"HTMLImportsLoaded":"DOMContentLoaded";window.addEventListener(s,t)}else t()}(window.CustomElements),function(){var e=document.createElement("style");e.textContent="body {transition: opacity ease-in 0.2s; } \nbody[unresolved] {opacity: 0; display: block; overflow: hidden; position: relative; } \n";var t=document.querySelector("head");t.insertBefore(e,t.firstChild)}(window.WebComponents),function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.PointerEventsPolyfill=t()}(this,function(){"use strict";function e(e,t){t=t||Object.create(null);var n=document.createEvent("Event");n.initEvent(e,t.bubbles||!1,t.cancelable||!1);for(var r,o=2;l.length>o;o++)r=l[o],n[r]=t[r]||d[o];n.buttons=t.buttons||0;var i=0;return i=t.pressure?t.pressure:n.buttons?.5:0,n.x=n.clientX,n.y=n.clientY,n.pointerId=t.pointerId||0,n.width=t.width||0,n.height=t.height||0,n.pressure=i,n.tiltX=t.tiltX||0,n.tiltY=t.tiltY||0,n.pointerType=t.pointerType||"",n.hwTimestamp=t.hwTimestamp||0,n.isPrimary=t.isPrimary||!1,n}function t(){this.array=[],this.size=0}function n(e,t,n,r){this.addCallback=e.bind(r),this.removeCallback=t.bind(r),this.changedCallback=n.bind(r),O&&(this.observer=new O(this.mutationWatcher.bind(this)))}function r(e){return"body /shadow-deep/ "+o(e)}function o(e){return'[touch-action="'+e+'"]'}function i(e){return"{ -ms-touch-action: "+e+"; touch-action: "+e+"; touch-action-delay: none; }"}function a(){if(A){I.forEach(function(e){e+""===e?(k+=o(e)+i(e)+"\n",x&&(k+=r(e)+i(e)+"\n")):(k+=e.selectors.map(o)+i(e.rule)+"\n",x&&(k+=e.selectors.map(r)+i(e.rule)+"\n"))});var e=document.createElement("style");e.textContent=k,document.head.appendChild(e)}}function s(){if(!window.PointerEvent){if(window.PointerEvent=h,window.navigator.msPointerEnabled){var e=window.navigator.msMaxTouchPoints;Object.defineProperty(window.navigator,"maxTouchPoints",{value:e,enumerable:!0}),_.registerSource("ms",ot)}else _.registerSource("mouse",U),void 0!==window.ontouchstart&&_.registerSource("touch",et);_.register(document)}}function c(e){if(!_.pointermap.has(e))throw Error("InvalidPointerId")}function u(){window.Element&&!Element.prototype.setPointerCapture&&Object.defineProperties(Element.prototype,{setPointerCapture:{value:J},releasePointerCapture:{value:Q}})}var l=["bubbles","cancelable","view","detail","screenX","screenY","clientX","clientY","ctrlKey","altKey","shiftKey","metaKey","button","relatedTarget","pageX","pageY"],d=[!1,!1,null,null,0,0,0,0,!1,!1,!1,!1,0,null,0,0],h=e,p=window.Map&&window.Map.prototype.forEach,f=p?Map:t;t.prototype={set:function(e,t){return void 0===t?this.delete(e):(this.has(e)||this.size++,this.array[e]=t,void 0)},has:function(e){return void 0!==this.array[e]},"delete":function(e){this.has(e)&&(delete this.array[e],this.size--)},get:function(e){return this.array[e]},clear:function(){this.array.length=0,this.size=0},forEach:function(e,t){return this.array.forEach(function(n,r){e.call(t,n,r,this)},this)}};var m=f,v=["bubbles","cancelable","view","detail","screenX","screenY","clientX","clientY","ctrlKey","altKey","shiftKey","metaKey","button","relatedTarget","buttons","pointerId","width","height","pressure","tiltX","tiltY","pointerType","hwTimestamp","isPrimary","type","target","currentTarget","which","pageX","pageY","timeStamp"],b=[!1,!1,null,null,0,0,0,0,!1,!1,!1,!1,0,null,0,0,0,0,0,0,0,"",0,!1,"",null,null,0,0,0,0],g={pointerover:1,pointerout:1,pointerenter:1,pointerleave:1},y="undefined"!=typeof SVGElementInstance,w={pointermap:new m,eventMap:Object.create(null),captureInfo:Object.create(null),eventSources:Object.create(null),eventSourceList:[],registerSource:function(e,t){var n=t,r=n.events;r&&(r.forEach(function(e){n[e]&&(this.eventMap[e]=n[e].bind(n))},this),this.eventSources[e]=n,this.eventSourceList.push(n))},register:function(e){for(var t,n=this.eventSourceList.length,r=0;n>r&&(t=this.eventSourceList[r]);r++)t.register.call(t,e)},unregister:function(e){for(var t,n=this.eventSourceList.length,r=0;n>r&&(t=this.eventSourceList[r]);r++)t.unregister.call(t,e)},contains:function(e,t){try{return e.contains(t)}catch(n){return!1}},down:function(e){e.bubbles=!0,this.fireEvent("pointerdown",e)},move:function(e){e.bubbles=!0,this.fireEvent("pointermove",e)},up:function(e){e.bubbles=!0,this.fireEvent("pointerup",e)},enter:function(e){e.bubbles=!1,this.fireEvent("pointerenter",e)},leave:function(e){e.bubbles=!1,this.fireEvent("pointerleave",e)},over:function(e){e.bubbles=!0,this.fireEvent("pointerover",e)},out:function(e){e.bubbles=!0,this.fireEvent("pointerout",e)},cancel:function(e){e.bubbles=!0,this.fireEvent("pointercancel",e)},leaveOut:function(e){this.out(e),this.contains(e.target,e.relatedTarget)||this.leave(e)},enterOver:function(e){this.over(e),this.contains(e.target,e.relatedTarget)||this.enter(e)},eventHandler:function(e){if(!e._handledByPE){var t=e.type,n=this.eventMap&&this.eventMap[t];n&&n(e),e._handledByPE=!0}},listen:function(e,t){t.forEach(function(t){this.addEvent(e,t)},this)},unlisten:function(e,t){t.forEach(function(t){this.removeEvent(e,t)},this)},addEvent:function(e,t){e.addEventListener(t,this.boundHandler)},removeEvent:function(e,t){e.removeEventListener(t,this.boundHandler)},makeEvent:function(e,t){this.captureInfo[t.pointerId]&&(t.relatedTarget=null);var n=new h(e,t);return t.preventDefault&&(n.preventDefault=t.preventDefault),n._target=n._target||t.target,n},fireEvent:function(e,t){var n=this.makeEvent(e,t);return this.dispatchEvent(n)},cloneEvent:function(e){for(var t,n=Object.create(null),r=0;v.length>r;r++)t=v[r],n[t]=e[t]||b[r],!y||"target"!==t&&"relatedTarget"!==t||n[t]instanceof SVGElementInstance&&(n[t]=n[t].correspondingUseElement);return e.preventDefault&&(n.preventDefault=function(){e.preventDefault()}),n},getTarget:function(e){var t=this.captureInfo[e.pointerId];return t?e._target!==t&&e.type in g?void 0:t:e._target},setCapture:function(e,t){this.captureInfo[e]&&this.releaseCapture(e),this.captureInfo[e]=t;var n=document.createEvent("Event");n.initEvent("gotpointercapture",!0,!1),n.pointerId=e,this.implicitRelease=this.releaseCapture.bind(this,e),document.addEventListener("pointerup",this.implicitRelease),document.addEventListener("pointercancel",this.implicitRelease),n._target=t,this.asyncDispatchEvent(n)},releaseCapture:function(e){var t=this.captureInfo[e];if(t){var n=document.createEvent("Event");n.initEvent("lostpointercapture",!0,!1),n.pointerId=e,this.captureInfo[e]=void 0,document.removeEventListener("pointerup",this.implicitRelease),document.removeEventListener("pointercancel",this.implicitRelease),n._target=t,this.asyncDispatchEvent(n)}},dispatchEvent:function(e){var t=this.getTarget(e);return t?t.dispatchEvent(e):void 0},asyncDispatchEvent:function(e){requestAnimationFrame(this.dispatchEvent.bind(this,e))}};w.boundHandler=w.eventHandler.bind(w);var _=w,E={shadow:function(e){return e?e.shadowRoot||e.webkitShadowRoot:void 0},canTarget:function(e){return e&&Boolean(e.elementFromPoint)},targetingShadow:function(e){var t=this.shadow(e);return this.canTarget(t)?t:void 0},olderShadow:function(e){var t=e.olderShadowRoot;if(!t){var n=e.querySelector("shadow");n&&(t=n.olderShadowRoot)}return t},allShadows:function(e){for(var t=[],n=this.shadow(e);n;)t.push(n),n=this.olderShadow(n);return t},searchRoot:function(e,t,n){if(e){var r,o,i=e.elementFromPoint(t,n);for(o=this.targetingShadow(i);o;){if(r=o.elementFromPoint(t,n)){var a=this.targetingShadow(r);return this.searchRoot(a,t,n)||r}o=this.olderShadow(o)}return i}},owner:function(e){for(var t=e;t.parentNode;)t=t.parentNode;return t.nodeType!==Node.DOCUMENT_NODE&&t.nodeType!==Node.DOCUMENT_FRAGMENT_NODE&&(t=document),t},findTarget:function(e){var t=e.clientX,n=e.clientY,r=this.owner(e.target);return r.elementFromPoint(t,n)||(r=document),this.searchRoot(r,t,n)}},T=Array.prototype.forEach.call.bind(Array.prototype.forEach),C=Array.prototype.map.call.bind(Array.prototype.map),M=Array.prototype.slice.call.bind(Array.prototype.slice),L=Array.prototype.filter.call.bind(Array.prototype.filter),O=window.MutationObserver||window.WebKitMutationObserver,S="[touch-action]",N={subtree:!0,childList:!0,attributes:!0,attributeOldValue:!0,attributeFilter:["touch-action"]};n.prototype={watchSubtree:function(e){this.observer&&E.canTarget(e)&&this.observer.observe(e,N)},enableOnSubtree:function(e){this.watchSubtree(e),e===document&&"complete"!==document.readyState?this.installOnLoad():this.installNewSubtree(e)},installNewSubtree:function(e){T(this.findElements(e),this.addElement,this)},findElements:function(e){return e.querySelectorAll?e.querySelectorAll(S):[]},removeElement:function(e){this.removeCallback(e)},addElement:function(e){this.addCallback(e)},elementChanged:function(e,t){this.changedCallback(e,t)},concatLists:function(e,t){return e.concat(M(t))},installOnLoad:function(){document.addEventListener("readystatechange",function(){"complete"===document.readyState&&this.installNewSubtree(document)}.bind(this))},isElement:function(e){return e.nodeType===Node.ELEMENT_NODE},flattenMutationTree:function(e){var t=C(e,this.findElements,this);return t.push(L(e,this.isElement)),t.reduce(this.concatLists,[])},mutationWatcher:function(e){e.forEach(this.mutationHandler,this)},mutationHandler:function(e){if("childList"===e.type){var t=this.flattenMutationTree(e.addedNodes);t.forEach(this.addElement,this);var n=this.flattenMutationTree(e.removedNodes);n.forEach(this.removeElement,this)}else"attributes"===e.type&&this.elementChanged(e.target,e.oldValue)}};var P=n,I=["none","auto","pan-x","pan-y",{rule:"pan-x pan-y",selectors:["pan-x pan-y","pan-y pan-x"]}],k="",A=window.PointerEvent||window.MSPointerEvent,x=!window.ShadowDOMPolyfill&&document.head.createShadowRoot,D=_.pointermap,R=25,H=[1,4,2,8,16],j=!1;try{j=1===new MouseEvent("test",{buttons:1}).buttons}catch(F){}var q,Y={POINTER_ID:1,POINTER_TYPE:"mouse",events:["mousedown","mousemove","mouseup","mouseover","mouseout"],register:function(e){_.listen(e,this.events)},unregister:function(e){_.unlisten(e,this.events)},lastTouches:[],isEventSimulatedFromTouch:function(e){for(var t,n=this.lastTouches,r=e.clientX,o=e.clientY,i=0,a=n.length;a>i&&(t=n[i]);i++){var s=Math.abs(r-t.x),c=Math.abs(o-t.y);if(R>=s&&R>=c)return!0}},prepareEvent:function(e){var t=_.cloneEvent(e),n=t.preventDefault;return t.preventDefault=function(){e.preventDefault(),n()},t.pointerId=this.POINTER_ID,t.isPrimary=!0,t.pointerType=this.POINTER_TYPE,t},prepareButtonsForMove:function(e,t){var n=D.get(this.POINTER_ID);e.buttons=n?n.buttons:0,t.buttons=e.buttons},mousedown:function(e){if(!this.isEventSimulatedFromTouch(e)){var t=D.get(this.POINTER_ID),n=this.prepareEvent(e);j||(n.buttons=H[n.button],t&&(n.buttons|=t.buttons),e.buttons=n.buttons),D.set(this.POINTER_ID,e),t?_.move(n):_.down(n)}},mousemove:function(e){if(!this.isEventSimulatedFromTouch(e)){var t=this.prepareEvent(e);j||this.prepareButtonsForMove(t,e),_.move(t)}},mouseup:function(e){if(!this.isEventSimulatedFromTouch(e)){var t=D.get(this.POINTER_ID),n=this.prepareEvent(e);if(!j){var r=H[n.button];n.buttons=t?t.buttons&~r:0,e.buttons=n.buttons}D.set(this.POINTER_ID,e),0===n.buttons||n.buttons===H[n.button]?(this.cleanupMouse(),_.up(n)):_.move(n)}},mouseover:function(e){if(!this.isEventSimulatedFromTouch(e)){var t=this.prepareEvent(e);j||this.prepareButtonsForMove(t,e),_.enterOver(t)}},mouseout:function(e){if(!this.isEventSimulatedFromTouch(e)){var t=this.prepareEvent(e);j||this.prepareButtonsForMove(t,e),_.leaveOut(t)}},cancel:function(e){var t=this.prepareEvent(e);_.cancel(t),this.cleanupMouse()},cleanupMouse:function(){D.delete(this.POINTER_ID)}},U=Y,X=_.captureInfo,B=E.findTarget.bind(E),z=E.allShadows.bind(E),W=_.pointermap,V=2500,K=200,G="touch-action",$=!1,Z={events:["touchstart","touchmove","touchend","touchcancel"],register:function(e){$?_.listen(e,this.events):q.enableOnSubtree(e)},unregister:function(e){$&&_.unlisten(e,this.events)},elementAdded:function(e){var t=e.getAttribute(G),n=this.touchActionToScrollType(t);n&&(e._scrollType=n,_.listen(e,this.events),z(e).forEach(function(e){e._scrollType=n,_.listen(e,this.events)},this))},elementRemoved:function(e){e._scrollType=void 0,_.unlisten(e,this.events),z(e).forEach(function(e){e._scrollType=void 0,_.unlisten(e,this.events)},this)},elementChanged:function(e,t){var n=e.getAttribute(G),r=this.touchActionToScrollType(n),o=this.touchActionToScrollType(t);r&&o?(e._scrollType=r,z(e).forEach(function(e){e._scrollType=r},this)):o?this.elementRemoved(e):r&&this.elementAdded(e)},scrollTypes:{EMITTER:"none",XSCROLLER:"pan-x",YSCROLLER:"pan-y",SCROLLER:/^(?:pan-x pan-y)|(?:pan-y pan-x)|auto$/},touchActionToScrollType:function(e){var t=e,n=this.scrollTypes;return"none"===t?"none":t===n.XSCROLLER?"X":t===n.YSCROLLER?"Y":n.SCROLLER.exec(t)?"XY":void 0},POINTER_TYPE:"touch",firstTouch:null,isPrimaryTouch:function(e){return this.firstTouch===e.identifier},setPrimaryTouch:function(e){(0===W.size||1===W.size&&W.has(1))&&(this.firstTouch=e.identifier,this.firstXY={X:e.clientX,Y:e.clientY},this.scrolling=!1,this.cancelResetClickCount())},removePrimaryPointer:function(e){e.isPrimary&&(this.firstTouch=null,this.firstXY=null,this.resetClickCount())},clickCount:0,resetId:null,resetClickCount:function(){var e=function(){this.clickCount=0,this.resetId=null}.bind(this);this.resetId=setTimeout(e,K)},cancelResetClickCount:function(){this.resetId&&clearTimeout(this.resetId)},typeToButtons:function(e){var t=0;return("touchstart"===e||"touchmove"===e)&&(t=1),t},touchToPointer:function(e){var t=this.currentTouchEvent,n=_.cloneEvent(e),r=n.pointerId=e.identifier+2;n.target=X[r]||B(n),n.bubbles=!0,n.cancelable=!0,n.detail=this.clickCount,n.button=0,n.buttons=this.typeToButtons(t.type),n.width=e.radiusX||e.webkitRadiusX||0,n.height=e.radiusY||e.webkitRadiusY||0,n.pressure=e.force||e.webkitForce||.5,n.isPrimary=this.isPrimaryTouch(e),n.pointerType=this.POINTER_TYPE;var o=this;return n.preventDefault=function(){o.scrolling=!1,o.firstXY=null,t.preventDefault()},n},processTouches:function(e,t){var n=e.changedTouches;this.currentTouchEvent=e;for(var r,o=0;n.length>o;o++)r=n[o],t.call(this,this.touchToPointer(r))},shouldScroll:function(e){if(this.firstXY){var t,n=e.currentTarget._scrollType;if("none"===n)t=!1;else if("XY"===n)t=!0;else{var r=e.changedTouches[0],o=n,i="Y"===n?"X":"Y",a=Math.abs(r["client"+o]-this.firstXY[o]),s=Math.abs(r["client"+i]-this.firstXY[i]);t=a>=s}return this.firstXY=null,t}},findTouch:function(e,t){for(var n,r=0,o=e.length;o>r&&(n=e[r]);r++)if(n.identifier===t)return!0},vacuumTouches:function(e){var t=e.touches;if(W.size>=t.length){var n=[];W.forEach(function(e,r){if(1!==r&&!this.findTouch(t,r-2)){var o=e.out;n.push(o)}},this),n.forEach(this.cancelOut,this)}},touchstart:function(e){this.vacuumTouches(e),this.setPrimaryTouch(e.changedTouches[0]),this.dedupSynthMouse(e),this.scrolling||(this.clickCount++,this.processTouches(e,this.overDown))},overDown:function(e){W.set(e.pointerId,{target:e.target,out:e,outTarget:e.target}),_.over(e),_.enter(e),_.down(e)},touchmove:function(e){this.scrolling||(this.shouldScroll(e)?(this.scrolling=!0,this.touchcancel(e)):(e.preventDefault(),this.processTouches(e,this.moveOverOut)))},moveOverOut:function(e){var t=e,n=W.get(t.pointerId);if(n){var r=n.out,o=n.outTarget;_.move(t),r&&o!==t.target&&(r.relatedTarget=t.target,t.relatedTarget=o,r.target=o,t.target?(_.leaveOut(r),_.enterOver(t)):(t.target=o,t.relatedTarget=null,this.cancelOut(t))),n.out=t,n.outTarget=t.target}},touchend:function(e){this.dedupSynthMouse(e),this.processTouches(e,this.upOut)},upOut:function(e){this.scrolling||(_.up(e),_.out(e),_.leave(e)),this.cleanUpPointer(e)},touchcancel:function(e){this.processTouches(e,this.cancelOut)},cancelOut:function(e){_.cancel(e),_.out(e),_.leave(e),this.cleanUpPointer(e)},cleanUpPointer:function(e){W.delete(e.pointerId),this.removePrimaryPointer(e)},dedupSynthMouse:function(e){var t=U.lastTouches,n=e.changedTouches[0];if(this.isPrimaryTouch(n)){var r={x:n.clientX,y:n.clientY};t.push(r);var o=function(e,t){var n=e.indexOf(t);n>-1&&e.splice(n,1)}.bind(null,t,r);setTimeout(o,V)}}};$||(q=new P(Z.elementAdded,Z.elementRemoved,Z.elementChanged,Z));var J,Q,et=Z,tt=_.pointermap,nt=window.MSPointerEvent&&"number"==typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE,rt={events:["MSPointerDown","MSPointerMove","MSPointerUp","MSPointerOut","MSPointerOver","MSPointerCancel","MSGotPointerCapture","MSLostPointerCapture"],register:function(e){_.listen(e,this.events)},unregister:function(e){_.unlisten(e,this.events)},POINTER_TYPES:["","unavailable","touch","pen","mouse"],prepareEvent:function(e){var t=e;return nt&&(t=_.cloneEvent(e),t.pointerType=this.POINTER_TYPES[e.pointerType]),t},cleanup:function(e){tt.delete(e)},MSPointerDown:function(e){tt.set(e.pointerId,e);var t=this.prepareEvent(e);_.down(t)},MSPointerMove:function(e){var t=this.prepareEvent(e);_.move(t)},MSPointerUp:function(e){var t=this.prepareEvent(e);_.up(t),this.cleanup(e.pointerId)},MSPointerOut:function(e){var t=this.prepareEvent(e);_.leaveOut(t)},MSPointerOver:function(e){var t=this.prepareEvent(e);_.enterOver(t)},MSPointerCancel:function(e){var t=this.prepareEvent(e);_.cancel(t),this.cleanup(e.pointerId)},MSLostPointerCapture:function(e){var t=_.makeEvent("lostpointercapture",e);_.dispatchEvent(t)},MSGotPointerCapture:function(e){var t=_.makeEvent("gotpointercapture",e);_.dispatchEvent(t)}},ot=rt,it=window.navigator;it.msPointerEnabled?(J=function(e){c(e),this.msSetPointerCapture(e)},Q=function(e){c(e),this.msReleasePointerCapture(e)}):(J=function(e){c(e),_.setCapture(e,this)},Q=function(e){c(e),_.releaseCapture(e,this)}),a(),s(),u();var at={dispatcher:_,Installer:P,PointerEvent:h,PointerMap:m,targetFinding:E};return at}),function(){function e(e){var t=D.call(e);return x[t]||(x[t]=t.match(R)[1].toLowerCase())}function t(n,r){var o=t[r||e(n)];return o?o(n):n}function n(t){return H[e(t)]?[t]:Array.prototype.slice.call(t,0)}function r(e,t){return(t||j).length?n(e.querySelectorAll(t)):[]}function o(e){e()}function i(n,r,o){var i=e(o);return"object"==i&&"object"==e(n[r])?X.merge(n[r],o):n[r]=t(o,i),n}function a(e,t,n){var r,o={};for(var i in t)o[i.split(":")[0]]=i;for(i in n)r=o[i.split(":")[0]],"function"==typeof t[r]?(r.match(":mixins")||(t[r+":mixins"]=t[r],delete t[r],r+=":mixins"),t[r].__mixin__=X.applyPseudos(i+(i.match(":mixins")?"":":mixins"),n[i],e.pseudos,t[r].__mixin__)):(t[i]=n[i],delete t[r])}function s(e,t,n){for(var r in n)t[r+":__mixin__("+F++ +")"]=X.applyPseudos(r,n[r],e.pseudos)}function c(e,t){for(var n=e.length;n--;)t.unshift(e[n]),X.mixins[e[n]].mixins&&c(X.mixins[e[n]].mixins,t);return t}function u(e){return c(e.mixins,[]).forEach(function(t){var n=X.mixins[t];for(var r in n){var o=n[r],i=e[r];if(i)switch(r){case"mixins":break;case"events":s(e,i,o);break;case"accessors":case"prototype":for(var c in o)i[c]?a(e,i[c],o[c],t):i[c]=o[c];break;default:a(e,i,o,t)}else e[r]=o}}),e}function l(e,t){for(var n,r=t.target,o=t.currentTarget;!n&&r&&r!=o;)r.tagName&&A.call(r,e.value)&&(n=r),r=r.parentNode;return!n&&o.tagName&&A.call(o,e.value)&&(n=o),n?e.listener=e.listener.bind(n):null}function d(e){return 0===e.button}function h(e,t,n,r){r?t[e]=n[e]:Object.defineProperty(t,e,{writable:!0,enumerable:!0,value:n[e]})}function p(e,t){var n=Object.getOwnPropertyDescriptor(e,"target");for(var r in t)q[r]||h(r,e,t,n);e.baseEvent=t}function f(e,t,n,r,o){_[o].call(e,n,t&&t.boolean?"":r)}function m(e,t,n,r,o){if(t&&(t.property||t.selector))for(var i=t.property?[e.xtag[t.property]]:t.selector?X.query(e,t.selector):[],a=i.length;a--;)i[a][o](n,r)}function v(e,t,n,r,o,i){var a=n.split(":"),s=a[0];"get"==s?(a[0]=t,e.prototype[t].get=X.applyPseudos(a.join(":"),r[n],e.pseudos,r[n])):"set"==s?(a[0]=t,e.prototype[t].set=X.applyPseudos(a.join(":"),o?function(e){var t,a="setAttribute";o.boolean?(e=!!e,t=this.hasAttribute(i),e||(a="removeAttribute")):(e=o.validate?o.validate.call(this,e):e,t=this.getAttribute(i)),f(this,o,i,e,a),r[n].call(this,e,t),m(this,o,i,e,a)}:r[n]?function(e){r[n].call(this,e)}:null,e.pseudos,r[n]),o&&(o.setter=r[n])):e.prototype[t][n]=r[n]}function b(e,t){e.prototype[t]={};var n,r=e.accessors[t],o=r.attribute;o&&(n=o.name=(o?o.name||t.replace(O,"$1-$2"):t).toLowerCase(),o.key=t,e.attributes[n]=o);for(var i in r)v(e,t,i,r,o,n);if(o){if(!e.prototype[t].get){var a=(o.boolean?"has":"get")+"Attribute";e.prototype[t].get=function(){return this[a](n)}}e.prototype[t].set||(e.prototype[t].set=function(e){e=o.boolean?!!e:o.validate?o.validate.call(this,e):e;var t=o.boolean?e?"setAttribute":"removeAttribute":"setAttribute";f(this,o,n,e,t),m(this,o,n,e,t)})}}function g(e){return"function"==typeof e?U.exec(""+e)[1]:e}var y=window,w=document,_={setAttribute:Element.prototype.setAttribute,removeAttribute:Element.prototype.removeAttribute},E=Element.prototype.createShadowRoot,T=w.createElement("div"),C=function(){},M=function(){return!0},L=/,/g,O=/([a-z])([A-Z])/g,S=/\(|\)/g,N=/:(\w+)\u276A(.+?(?=\u276B))|:(\w+)/g,P=/(\d+)/g,I={action:function(e,t){return e.value.match(P).indexOf(t.keyCode+"")>-1==("keypass"==e.name)||null}},k=function(){var e=Object.keys(window).join(),t=(e.match(/,(ms)/)||e.match(/,(moz)/)||e.match(/,(O)/)||[null,"webkit"])[1].toLowerCase();return{dom:"ms"==t?"MS":t,lowercase:t,css:"-"+t+"-",js:"ms"==t?t:t.charAt(0).toUpperCase()+t.substring(1)}}(),A=Element.prototype.matches||Element.prototype.matchesSelector||Element.prototype[k.lowercase+"MatchesSelector"],x={},D=x.toString,R=/\s([a-zA-Z]+)/;t.object=function(e){var n={};for(var r in e)n[r]=t(e[r]);return n},t.array=function(e){for(var n=e.length,r=Array(n);n--;)r[n]=t(e[n]);return r};var H={undefined:1,"null":1,number:1,"boolean":1,string:1,"function":1},j="",F=0,q={};for(var Y in w.createEvent("CustomEvent"))q[Y]=1;var U=/\/\*!?(?:\@preserve)?[ \t]*(?:\r\n|\n)([\s\S]*?)(?:\r\n|\n)\s*\*\//,X={tags:{},defaultOptions:{pseudos:[],mixins:[],events:{},methods:{},accessors:{},lifecycle:{},attributes:{},prototype:{xtag:{get:function(){return this.__xtag__?this.__xtag__:this.__xtag__={data:{}}}}}},register:function(e,t){var r;if("string"!=typeof e)throw"First argument must be a Custom Element string name";r=e.toLowerCase(),X.tags[r]=t||{};var o=t.prototype;delete t.prototype;var i=X.tags[r].compiled=u(X.merge({},X.defaultOptions,t)),a=i.prototype,s=i.lifecycle;for(var c in i.events)i.events[c]=X.parseEvent(c,i.events[c]);for(c in s)s[c.split(":")[0]]=X.applyPseudos(c,s[c],i.pseudos,s[c]);for(c in i.methods)a[c.split(":")[0]]={value:X.applyPseudos(c,i.methods[c],i.pseudos,i.methods[c]),enumerable:!0};for(c in i.accessors)b(i,c);i.shadow&&(i.shadow=i.shadow.nodeName?i.shadow:X.createFragment(i.shadow)),i.content&&(i.content=i.content.nodeName?i.content.innerHTML:g(i.content));var l=s.created,d=s.finalized;a.createdCallback={enumerable:!0,value:function(){var e=this;i.shadow&&E&&this.createShadowRoot().appendChild(i.shadow.cloneNode(!0)),i.content&&(this.appendChild(document.createElement("div")).outerHTML=i.content);var t=l?l.apply(this,arguments):null;X.addEvents(this,i.events);for(var n in i.attributes){var r=i.attributes[n],o=this.hasAttribute(n),a=void 0!==r.def;(o||r.boolean||a)&&(this[r.key]=r.boolean?o:!o&&a?r.def:this.getAttribute(n))}return i.pseudos.forEach(function(t){t.onAdd.call(e,t)}),this.xtagComponentReady=!0,d&&d.apply(this,arguments),t}};var h=s.inserted,p=s.removed;(h||p)&&(a.attachedCallback={value:function(){return p&&(this.xtag.__parentNode__=this.parentNode),h?h.apply(this,arguments):void 0},enumerable:!0}),p&&(a.detachedCallback={value:function(){var e=n(arguments);e.unshift(this.xtag.__parentNode__);var t=p.apply(this,e);return delete this.xtag.__parentNode__,t},enumerable:!0}),s.attributeChanged&&(a.attributeChangedCallback={value:s.attributeChanged,enumerable:!0}),a.setAttribute={writable:!0,enumerable:!0,value:function(e,t){var n,r=e.toLowerCase(),o=i.attributes[r];o&&(n=this.getAttribute(r),t=o.boolean?"":o.validate?o.validate.call(this,t):t),f(this,o,r,t,"setAttribute"),o&&(o.setter&&o.setter.call(this,o.boolean?!0:t,n),m(this,o,r,t,"setAttribute"))}},a.removeAttribute={writable:!0,enumerable:!0,value:function(e){var t=e.toLowerCase(),n=i.attributes[t],r=this.hasAttribute(t);f(this,n,t,"","removeAttribute"),n&&(n.setter&&n.setter.call(this,n.boolean?!1:void 0,r),m(this,n,t,"","removeAttribute"))}};var v={},_=o instanceof y.HTMLElement,T=i["extends"]&&(v["extends"]=i["extends"]);return o&&Object.getOwnPropertyNames(o).forEach(function(e){var t=a[e],n=_?Object.getOwnPropertyDescriptor(o,e):o[e];if(t)for(var r in n)t[r]="function"==typeof n[r]&&t[r]?X.wrap(n[r],t[r]):n[r];a[e]=t||n}),v.prototype=Object.create(T?Object.create(w.createElement(T).constructor).prototype:y.HTMLElement.prototype,a),w.registerElement(r,v)},mixins:{},prefix:k,captureEvents:{focus:1,blur:1,scroll:1,DOMMouseScroll:1},customEvents:{animationstart:{attach:[k.dom+"AnimationStart"]},animationend:{attach:[k.dom+"AnimationEnd"]},transitionend:{attach:[k.dom+"TransitionEnd"]},move:{attach:["pointermove"]},enter:{attach:["pointerenter"]},leave:{attach:["pointerleave"]},scrollwheel:{attach:["DOMMouseScroll","mousewheel"],condition:function(e){return e.delta=e.wheelDelta?e.wheelDelta/40:Math.round(-1*(e.detail/3.5)),!0
}},tap:{attach:["pointerdown","pointerup"],condition:function(e,t){if("pointerdown"==e.type)t.startX=e.clientX,t.startY=e.clientY;else if(0===e.button&&10>Math.abs(t.startX-e.clientX)&&10>Math.abs(t.startY-e.clientY))return!0}},tapstart:{attach:["pointerdown"],condition:d},tapend:{attach:["pointerup"],condition:d},tapmove:{attach:["pointerdown"],condition:function(e,t){if("pointerdown"==e.type){var n=t.listener.bind(this);t.tapmoveListeners||(t.tapmoveListeners=X.addEvents(document,{pointermove:n,pointerup:n,pointercancel:n}))}else("pointerup"==e.type||"pointercancel"==e.type)&&(X.removeEvents(document,t.tapmoveListeners),t.tapmoveListeners=null);return!0}},taphold:{attach:["pointerdown","pointerup"],condition:function(e,t){if("pointerdown"==e.type)(t.pointers=t.pointers||{})[e.pointerId]=setTimeout(X.fireEvent.bind(null,this,"taphold"),t.duration||1e3);else{if("pointerup"!=e.type)return!0;t.pointers&&(clearTimeout(t.pointers[e.pointerId]),delete t.pointers[e.pointerId])}}}},pseudos:{__mixin__:{},mixins:{onCompiled:function(e,t){var n=t.source&&t.source.__mixin__||t.source;if(!n)return e;switch(t.value){case null:case"":case"before":return function(){return n.apply(this,arguments),e.apply(this,arguments)};case"after":return function(){var t=e.apply(this,arguments);return n.apply(this,arguments),t};case"none":return e}}},keypass:I,keyfail:I,delegate:{action:l},preventable:{action:function(e,t){return!t.defaultPrevented}},duration:{onAdd:function(e){e.source.duration=Number(e.value)}},capture:{onCompiled:function(e,t){t.source&&(t.source.capture=!0)}}},clone:t,typeOf:e,toArray:n,wrap:function(e,t){return function(){var n=e.apply(this,arguments);return t.apply(this,arguments),n}},merge:function(t,n,r){if("string"==e(n))return i(t,n,r);for(var o=1,a=arguments.length;a>o;o++){var s=arguments[o];for(var c in s)i(t,c,s[c])}return t},uid:function(){return Math.random().toString(36).substr(2,10)},query:r,skipTransition:function(e,t,n){var r=k.js+"TransitionProperty";e.style[r]=e.style.transitionProperty="none";var o=t?t.call(n||e):null;return X.skipFrame(function(){e.style[r]=e.style.transitionProperty="",o&&o.call(n||e)})},requestFrame:function(){var e=y.requestAnimationFrame||y[k.lowercase+"RequestAnimationFrame"]||function(e){return y.setTimeout(e,20)};return function(t){return e(t)}}(),cancelFrame:function(){var e=y.cancelAnimationFrame||y[k.lowercase+"CancelAnimationFrame"]||y.clearTimeout;return function(t){return e(t)}}(),skipFrame:function(e){var t=X.requestFrame(function(){t=X.requestFrame(e)});return t},matchSelector:function(e,t){return A.call(e,t)},set:function(e,t,n){e[t]=n,window.CustomElements&&CustomElements.upgradeAll(e)},innerHTML:function(e,t){X.set(e,"innerHTML",t)},hasClass:function(e,t){return e.className.split(" ").indexOf(t.trim())>-1},addClass:function(e,t){var n=e.className.trim().split(" ");return t.trim().split(" ").forEach(function(e){~n.indexOf(e)||n.push(e)}),e.className=n.join(" ").trim(),e},removeClass:function(e,t){var n=t.trim().split(" ");return e.className=e.className.trim().split(" ").filter(function(e){return e&&!~n.indexOf(e)}).join(" "),e},toggleClass:function(e,t){return X[X.hasClass(e,t)?"removeClass":"addClass"].call(null,e,t)},queryChildren:function(e,t){var r=e.id,o="#"+(e.id=r||"x_"+X.uid())+" > ",i=e.parentNode||!T.appendChild(e);t=o+(t+"").replace(L,","+o);var a=e.parentNode.querySelectorAll(t);return r||e.removeAttribute("id"),i||T.removeChild(e),n(a)},createFragment:function(e){var t=document.createElement("template");return e&&(e.nodeName?n(arguments).forEach(function(e){t.content.appendChild(e)}):t.innerHTML=g(e)),document.importNode(t.content,!0)},manipulate:function(e,t){var n=e.nextSibling,r=e.parentNode,o=t.call(e)||e;n?r.insertBefore(o,n):r.appendChild(o)},applyPseudos:function(e,t,r,i){var a=t,s={};if(e.match(":")){var c=[],u=0;e.replace(S,function(e){return"("==e?1==++u?"❪":"(":--u?")":"❫"}).replace(N,function(e,t,n,r){c.push([t||r,n])});for(var l=c.length;l--;)o(function(){var o=c[l][0],u=c[l][1];if(!X.pseudos[o])throw"pseudo not found: "+o+" "+u;u=""===u||u===void 0?null:u;var d=s[l]=Object.create(X.pseudos[o]);d.key=e,d.name=o,d.value=u,d.arguments=(u||"").split(","),d.action=d.action||M,d.source=i,d.onAdd=d.onAdd||C,d.onRemove=d.onRemove||C;var h=d.listener=a;a=function(){var e=d.action.apply(this,[d].concat(n(arguments)));return null===e||e===!1?e:(e=d.listener.apply(this,arguments),d.listener=h,e)},r?r.push(d):d.onAdd.call(t,d)})}for(var d in s)s[d].onCompiled&&(a=s[d].onCompiled(a,s[d])||a);return a},removePseudos:function(e,t){t.forEach(function(t){t.onRemove.call(e,t)})},parseEvent:function(e,t){var r=e.split(":"),o=r.shift(),i=X.customEvents[o],a=X.merge({type:o,stack:C,condition:M,capture:X.captureEvents[o],attach:[],_attach:[],pseudos:"",_pseudos:[],onAdd:C,onRemove:C},i||{});a.attach=n(a.base||a.attach),a.chain=o+(a.pseudos.length?":"+a.pseudos:"")+(r.length?":"+r.join(":"):"");var s=X.applyPseudos(a.chain,t,a._pseudos,a);return a.stack=function(e){e.currentTarget=e.currentTarget||this;var t=e.detail||{};return t.__stack__?t.__stack__==s?(e.stopPropagation(),e.cancelBubble=!0,s.apply(this,arguments)):void 0:s.apply(this,arguments)},a.listener=function(e){var t=n(arguments),r=a.condition.apply(this,t.concat([a]));return r?e.type!=o&&e.baseEvent&&e.type!=e.baseEvent.type?(X.fireEvent(e.target,o,{baseEvent:e,detail:r!==!0&&(r.__stack__=s)?r:{__stack__:s}}),void 0):a.stack.apply(this,t):r},a.attach.forEach(function(e){a._attach.push(X.parseEvent(e,a.listener))}),a},addEvent:function(e,t,n,r){var o="function"==typeof n?X.parseEvent(t,n):n;return o._pseudos.forEach(function(t){t.onAdd.call(e,t)}),o._attach.forEach(function(t){X.addEvent(e,t.type,t)}),o.onAdd.call(e,o,o.listener),e.addEventListener(o.type,o.stack,r||o.capture),o},addEvents:function(e,t){var n={};for(var r in t)n[r]=X.addEvent(e,r,t[r]);return n},removeEvent:function(e,t,n){n=n||t,n.onRemove.call(e,n,n.listener),X.removePseudos(e,n._pseudos),n._attach.forEach(function(t){X.removeEvent(e,t)}),e.removeEventListener(n.type,n.stack)},removeEvents:function(e,t){for(var n in t)X.removeEvent(e,t[n])},fireEvent:function(e,t,n){var r=w.createEvent("CustomEvent");n=n||{},r.initCustomEvent(t,n.bubbles!==!1,n.cancelable!==!1,n.detail),n.baseEvent&&p(r,n.baseEvent),e.dispatchEvent(r)}};y.xtag=X,w.addEventListener("WebComponentsReady",function(){X.fireEvent(w.body,"DOMComponentsLoaded")})}();



;(function () {
	'use strict';

	/**
	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
	 *
	 * @codingstandard ftlabs-jsv2
	 * @copyright The Financial Times Limited [All Rights Reserved]
	 * @license MIT License (see LICENSE.txt)
	 */

	/*jslint browser:true, node:true*/
	/*global define, Event, Node*/


	/**
	 * Instantiate fast-clicking listeners on the specified layer.
	 *
	 * @constructor
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	function FastClick(layer, options) {
		var oldOnClick;

		options = options || {};

		/**
		 * Whether a click is currently being tracked.
		 *
		 * @type boolean
		 */
		this.trackingClick = false;


		/**
		 * Timestamp for when click tracking started.
		 *
		 * @type number
		 */
		this.trackingClickStart = 0;


		/**
		 * The element being tracked for a click.
		 *
		 * @type EventTarget
		 */
		this.targetElement = null;


		/**
		 * X-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartX = 0;


		/**
		 * Y-coordinate of touch start event.
		 *
		 * @type number
		 */
		this.touchStartY = 0;


		/**
		 * ID of the last touch, retrieved from Touch.identifier.
		 *
		 * @type number
		 */
		this.lastTouchIdentifier = 0;


		/**
		 * Touchmove boundary, beyond which a click will be cancelled.
		 *
		 * @type number
		 */
		this.touchBoundary = options.touchBoundary || 10;


		/**
		 * The FastClick layer.
		 *
		 * @type Element
		 */
		this.layer = layer;

		/**
		 * The minimum time between tap(touchstart and touchend) events
		 *
		 * @type number
		 */
		this.tapDelay = options.tapDelay || 200;

		/**
		 * The maximum time for a tap
		 *
		 * @type number
		 */
		this.tapTimeout = options.tapTimeout || 700;

		if (FastClick.notNeeded(layer)) {
			return;
		}

		// Some old versions of Android don't have Function.prototype.bind
		function bind(method, context) {
			return function() { return method.apply(context, arguments); };
		}


		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
		var context = this;
		for (var i = 0, l = methods.length; i < l; i++) {
			context[methods[i]] = bind(context[methods[i]], context);
		}

		// Set up event handlers as required
		//deviceIsIOS was added by Mojo
		if (deviceIsAndroid || deviceIsIOS) {
			layer.addEventListener('mouseover', this.onMouse, true);
			layer.addEventListener('mousedown', this.onMouse, true);
			layer.addEventListener('mouseup', this.onMouse, true);
		}

		layer.addEventListener('click', this.onClick, true);
		layer.addEventListener('touchstart', this.onTouchStart, false);
		layer.addEventListener('touchmove', this.onTouchMove, false);
		layer.addEventListener('touchend', this.onTouchEnd, false);
		layer.addEventListener('touchcancel', this.onTouchCancel, false);

		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
		// layer when they are cancelled.
		if (!Event.prototype.stopImmediatePropagation) {
			layer.removeEventListener = function(type, callback, capture) {
				var rmv = Node.prototype.removeEventListener;
				if (type === 'click') {
					rmv.call(layer, type, callback.hijacked || callback, capture);
				} else {
					rmv.call(layer, type, callback, capture);
				}
			};

			layer.addEventListener = function(type, callback, capture) {
				var adv = Node.prototype.addEventListener;
				if (type === 'click') {
					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
						if (!event.propagationStopped) {
							callback(event);
						}
					}), capture);
				} else {
					adv.call(layer, type, callback, capture);
				}
			};
		}

		// If a handler is already declared in the element's onclick attribute, it will be fired before
		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
		// adding it as listener.
		if (typeof layer.onclick === 'function') {

			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
			// - the old one won't work if passed to addEventListener directly.
			oldOnClick = layer.onclick;
			layer.addEventListener('click', function(event) {
				oldOnClick(event);
			}, false);
			layer.onclick = null;
		}
	}

	/**
	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
	*
	* @type boolean
	*/
	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;

	/**
	 * Android requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;


	/**
	 * iOS requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;


	/**
	 * iOS 4 requires an exception for select elements.
	 *
	 * @type boolean
	 */
	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


	/**
	 * iOS 6.0-7.* requires the target element to be manually derived
	 *
	 * @type boolean
	 */
	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);

	/**
	 * BlackBerry requires exceptions.
	 *
	 * @type boolean
	 */
	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;

	/**
	 * Determine whether a given element requires a native click.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element needs a native click
	 */
	FastClick.prototype.needsClick = function(target) {
		switch (target.nodeName.toLowerCase()) {

		// Don't send a synthetic click to disabled inputs (issue #62)
		case 'button':
		case 'select':
		case 'textarea':
			if (target.disabled) {
				return true;
			}

			break;
		case 'input':

			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
				return true;
			}

			break;
		case 'label':
		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
		case 'video':
			return true;
		}

        // CODE ADDED BY MICHAEL (added for case when we need to have click for html that we have no control over
        //                          (our example is the contents of an ACE editor need regular clicks but we cant add a "needsclick" to every element in an ACE editor)
        //                       )
        var currentElement = target.parentNode;

        // loop through parents and if any of the parents has the "childrenneedsclick" class than return true
        while (currentElement && currentElement.parentNode && currentElement.parentNode.nodeName !== 'HTML') {
            if (currentElement.classList.contains('childrenneedsclick')) {//alert('test');
                return true;
            }

            currentElement = currentElement.parentNode;
        }

		return (/\bneedsclick\b/).test(target.className);
	};


	/**
	 * Determine whether a given element requires a call to focus to simulate click into element.
	 *
	 * @param {EventTarget|Element} target Target DOM element
	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
	 */
	FastClick.prototype.needsFocus = function(target) {
		switch (target.nodeName.toLowerCase()) {
		case 'textarea':
			return true;
		case 'select':
			return !deviceIsAndroid;
		case 'input':
			switch (target.type) {
			case 'button':
			case 'checkbox':
			case 'file':
			case 'image':
			case 'radio':
			case 'submit':
				return false;
			}

			// No point in attempting to focus disabled inputs
			return !target.disabled && !target.readOnly;
		default:
			return (/\bneedsfocus\b/).test(target.className);
		}
	};


	/**
	 * Send a click event to the specified element.
	 *
	 * @param {EventTarget|Element} targetElement
	 * @param {Event} event
	 */
	FastClick.prototype.sendClick = function(targetElement, event) {
		var clickEvent, touch;

		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
		if (document.activeElement && document.activeElement !== targetElement) {
			document.activeElement.blur();
		}

		touch = event.changedTouches[0];
		//console.log('test click');

		// Synthesise a click event, with an extra attribute so it can be tracked
		clickEvent = document.createEvent('MouseEvents');
		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
		clickEvent.forwardedTouchEvent = true;
		targetElement.dispatchEvent(clickEvent);
	};

	FastClick.prototype.determineEventType = function(targetElement) {

		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
			return 'mousedown';
		}

		return 'click';
	};


	/**
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.focus = function(targetElement) {
		var length;

		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
			length = targetElement.value.length;
			targetElement.setSelectionRange(length, length);
		} else {
			targetElement.focus();
		}
	};


	/**
	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
	 *
	 * @param {EventTarget|Element} targetElement
	 */
	FastClick.prototype.updateScrollParent = function(targetElement) {
		var scrollParent, parentElement;

		scrollParent = targetElement.fastClickScrollParent;

		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
		// target element was moved to another parent.
		if (!scrollParent || !scrollParent.contains(targetElement)) {
			parentElement = targetElement;
			do {
				if (parentElement.scrollHeight > parentElement.offsetHeight) {
					scrollParent = parentElement;
					targetElement.fastClickScrollParent = parentElement;
					break;
				}

				parentElement = parentElement.parentElement;
			} while (parentElement);
		}

		// Always update the scroll top tracker if possible.
		if (scrollParent) {
			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
		}
	};


	/**
	 * @param {EventTarget} targetElement
	 * @returns {Element|EventTarget}
	 */
	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {

		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
		if (eventTarget.nodeType === Node.TEXT_NODE) {
			return eventTarget.parentNode;
		}

		return eventTarget;
	};


	/**
	 * On touch start, record the position and scroll offset.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchStart = function(event) {
		var targetElement, touch, selection;

		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
		if (event.targetTouches.length > 1) {
			return true;
		}

		targetElement = this.getTargetElementFromEventTarget(event.target);
		touch = event.targetTouches[0];

		if (deviceIsIOS) {

			// Only trusted events will deselect text on iOS (issue #49)
			selection = window.getSelection();
			if (selection.rangeCount && !selection.isCollapsed) {
				return true;
			}

			if (!deviceIsIOS4) {

				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
				// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
				// random integers, it's safe to to continue if the identifier is 0 here.
				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
					event.preventDefault();
					return false;
				}

				this.lastTouchIdentifier = touch.identifier;

				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
				// 1) the user does a fling scroll on the scrollable layer
				// 2) the user stops the fling scroll with another tap
				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
				this.updateScrollParent(targetElement);
			}
		}

		this.trackingClick = true;
		this.trackingClickStart = event.timeStamp;
		this.targetElement = targetElement;

		this.touchStartX = touch.pageX;
		this.touchStartY = touch.pageY;

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			event.preventDefault();
		}

		return true;
	};


	/**
	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.touchHasMoved = function(event) {
		var touch = event.changedTouches[0], boundary = this.touchBoundary;

		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
			return true;
		}

		return false;
	};


	/**
	 * Update the last position.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchMove = function(event) {
		if (!this.trackingClick) {
			return true;
		}

		// If the touch has moved, cancel the click tracking
		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
			this.trackingClick = false;
			this.targetElement = null;
		}

		return true;
	};


	/**
	 * Attempt to find the labelled control for the given label element.
	 *
	 * @param {EventTarget|HTMLLabelElement} labelElement
	 * @returns {Element|null}
	 */
	FastClick.prototype.findControl = function(labelElement) {

		// Fast path for newer browsers supporting the HTML5 control attribute
		if (labelElement.control !== undefined) {
			return labelElement.control;
		}

		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
		if (labelElement.htmlFor) {
			return document.getElementById(labelElement.htmlFor);
		}

		// If no for attribute exists, attempt to retrieve the first labellable descendant element
		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
	};


	/**
	 * On touch end, determine whether to send a click event at once.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onTouchEnd = function(event) {
		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

		if (!this.trackingClick) {
			return true;
		}

		// Prevent phantom clicks on fast double-tap (issue #36)
		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
			this.cancelNextClick = true;
			return true;
		}

		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
			return true;
		}

		// Reset to prevent wrong click cancel on input (issue #156).
		this.cancelNextClick = false;

		this.lastClickTime = event.timeStamp;

		trackingClickStart = this.trackingClickStart;
		this.trackingClick = false;
		this.trackingClickStart = 0;

		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
		// is performing a transition or scroll, and has to be re-detected manually. Note that
		// for this to function correctly, it must be called *after* the event target is checked!
		// See issue #57; also filed as rdar://13048589 .
		if (deviceIsIOSWithBadTarget) {
			touch = event.changedTouches[0];

			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
		}

		targetTagName = targetElement.tagName.toLowerCase();
		if (targetTagName === 'label') {
			forElement = this.findControl(targetElement);
			if (forElement) {
				this.focus(targetElement);
				if (deviceIsAndroid) {
					return false;
				}

				targetElement = forElement;
			}
		} else if (this.needsFocus(targetElement)) {

			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
				this.targetElement = null;
				return false;
			}

			this.focus(targetElement);
			this.sendClick(targetElement, event);

			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
			if (!deviceIsIOS || targetTagName !== 'select') {
				this.targetElement = null;
				event.preventDefault();
			}

			return false;
		}

		if (deviceIsIOS && !deviceIsIOS4) {

			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
			scrollParent = targetElement.fastClickScrollParent;
			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
				return true;
			}
		}

		// Prevent the actual click from going though - unless the target node is marked as requiring
		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
		if (!this.needsClick(targetElement)) {
			event.preventDefault();
			this.sendClick(targetElement, event);
		}

		return false;
	};


	/**
	 * On touch cancel, stop tracking the click.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.onTouchCancel = function() {
		this.trackingClick = false;
		this.targetElement = null;
	};


	/**
	 * Determine mouse events which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onMouse = function(event) {

		// If a target element was never set (because a touch event was never fired) allow the event
		if (!this.targetElement) {
			return true;
		}

		if (event.forwardedTouchEvent) {
			return true;
		}

		// Programmatically generated events targeting a specific element should be permitted
		if (!event.cancelable) {
			return true;
		}

		// Derive and check the target element to see whether the mouse event needs to be permitted;
		// unless explicitly enabled, prevent non-touch click events from triggering actions,
		// to prevent ghost/doubleclicks.
		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

			// Prevent any user-added listeners declared on FastClick element from being fired.
			if (event.stopImmediatePropagation) {
				event.stopImmediatePropagation();
			} else {

				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
				event.propagationStopped = true;
			}

			// Cancel the event
			event.stopPropagation();
			event.preventDefault();

			return false;
		}

		// If the mouse event is permitted, return true for the action to go through.
		return true;
	};


	/**
	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
	 * an actual click which should be permitted.
	 *
	 * @param {Event} event
	 * @returns {boolean}
	 */
	FastClick.prototype.onClick = function(event) {
		var permitted;

		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
		if (this.trackingClick) {
			this.targetElement = null;
			this.trackingClick = false;
			return true;
		}

		// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
		if (event.target.type === 'submit' && event.detail === 0) {
			return true;
		}

		permitted = this.onMouse(event);

		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
		if (!permitted) {
			this.targetElement = null;
		}

		// If clicks are permitted, return true for the action to go through.
		return permitted;
	};


	/**
	 * Remove all FastClick's event listeners.
	 *
	 * @returns {void}
	 */
	FastClick.prototype.destroy = function() {
		var layer = this.layer;

		if (deviceIsAndroid) {
			layer.removeEventListener('mouseover', this.onMouse, true);
			layer.removeEventListener('mousedown', this.onMouse, true);
			layer.removeEventListener('mouseup', this.onMouse, true);
		}

		layer.removeEventListener('click', this.onClick, true);
		layer.removeEventListener('touchstart', this.onTouchStart, false);
		layer.removeEventListener('touchmove', this.onTouchMove, false);
		layer.removeEventListener('touchend', this.onTouchEnd, false);
		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
	};


	/**
	 * Check whether FastClick is needed.
	 *
	 * @param {Element} layer The layer to listen on
	 */
	FastClick.notNeeded = function(layer) {
		var metaViewport;
		var chromeVersion;
		var blackberryVersion;

		// Devices that don't support touch don't need FastClick
		if (typeof window.ontouchstart === 'undefined') {
			return true;
		}

		// Chrome version - zero for other browsers
		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

		if (chromeVersion) {

			if (deviceIsAndroid) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// Chrome 32 and above with width=device-width or less don't need FastClick
					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}

			// Chrome desktop doesn't need FastClick (issue #15)
			} else {
				return true;
			}
		}

		if (deviceIsBlackBerry10) {
			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);

			// BlackBerry 10.3+ does not require Fastclick library.
			// https://github.com/ftlabs/fastclick/issues/251
			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
				metaViewport = document.querySelector('meta[name=viewport]');

				if (metaViewport) {
					// user-scalable=no eliminates click delay.
					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
						return true;
					}
					// width=device-width (or less than device-width) eliminates click delay.
					if (document.documentElement.scrollWidth <= window.outerWidth) {
						return true;
					}
				}
			}
		}

		// IE10 with -ms-touch-action: none, which disables double-tap-to-zoom (issue #97)
		if (layer.style.msTouchAction === 'none') {
			return true;
		}

		// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
		if (layer.style.touchAction === 'none') {
			return true;
		}

		return false;
	};


	/**
	 * Factory method for creating a FastClick object
	 *
	 * @param {Element} layer The layer to listen on
	 * @param {Object} [options={}] The options to override the defaults
	 */
	FastClick.attach = function(layer, options) {
		return new FastClick(layer, options);
	};


	if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {

		// AMD. Register as an anonymous module.
		define(function() {
			return FastClick;
		});
	} else if (typeof module !== 'undefined' && module.exports) {
		module.exports = FastClick.attach;
		module.exports.FastClick = FastClick;
	}// else {

	window.FastClick = FastClick;
	//}
}());



//(function () {
//	'use strict';
//
//	/**
//	 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
//	 *
//	 * @codingstandard ftlabs-jsv2
//	 * @copyright The Financial Times Limited [All Rights Reserved]
//	 * @license MIT License (see LICENSE.txt)
//	 */
//
//	/*jslint browser:true, node:true*/
//	/*global define, Event, Node*/
//
//
//	/**
//	 * Instantiate fast-clicking listeners on the specified layer.
//	 *
//	 * @constructor
//	 * @param {Element} layer The layer to listen on
//	 * @param {Object} [options={}] The options to override the defaults
//	 */
//	function FastClick(layer, options) {
//		var oldOnClick;
//
//		options = options || {};
//
//		/**
//		 * Whether a click is currently being tracked.
//		 *
//		 * @type boolean
//		 */
//		this.trackingClick = false;
//
//
//		/**
//		 * Timestamp for when click tracking started.
//		 *
//		 * @type number
//		 */
//		this.trackingClickStart = 0;
//
//
//		/**
//		 * The element being tracked for a click.
//		 *
//		 * @type EventTarget
//		 */
//		this.targetElement = null;
//
//
//		/**
//		 * X-coordinate of touch start event.
//		 *
//		 * @type number
//		 */
//		this.touchStartX = 0;
//
//
//		/**
//		 * Y-coordinate of touch start event.
//		 *
//		 * @type number
//		 */
//		this.touchStartY = 0;
//
//
//		/**
//		 * ID of the last touch, retrieved from Touch.identifier.
//		 *
//		 * @type number
//		 */
//		this.lastTouchIdentifier = 0;
//
//
//		/**
//		 * Touchmove boundary, beyond which a click will be cancelled.
//		 *
//		 * @type number
//		 */
//		this.touchBoundary = options.touchBoundary || 10;
//
//
//		/**
//		 * The FastClick layer.
//		 *
//		 * @type Element
//		 */
//		this.layer = layer;
//
//		/**
//		 * The minimum time between tap(touchstart and touchend) events
//		 *
//		 * @type number
//		 */
//		this.tapDelay = options.tapDelay || 200;
//
//		/**
//		 * The maximum time for a tap
//		 *
//		 * @type number
//		 */
//		this.tapTimeout = options.tapTimeout || 700;
//
//		if (FastClick.notNeeded(layer)) {
//			return;
//		}
//
//		// Some old versions of Android don't have Function.prototype.bind
//		function bind(method, context) {
//			return function() { return method.apply(context, arguments); };
//		}
//
//
//		var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
//		var context = this;
//		for (var i = 0, l = methods.length; i < l; i++) {
//			context[methods[i]] = bind(context[methods[i]], context);
//		}
//
//		// Set up event handlers as required
//		if (deviceIsAndroid) {
//			layer.addEventListener('mouseover', this.onMouse, true);
//			layer.addEventListener('mousedown', this.onMouse, true);
//			layer.addEventListener('mouseup', this.onMouse, true);
//		}
//
//		layer.addEventListener('click', this.onClick, true);
//		layer.addEventListener('touchstart', this.onTouchStart, false);
//		layer.addEventListener('touchmove', this.onTouchMove, false);
//		layer.addEventListener('touchend', this.onTouchEnd, false);
//		layer.addEventListener('touchcancel', this.onTouchCancel, false);
//
//		// Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
//		// which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
//		// layer when they are cancelled.
//		if (!Event.prototype.stopImmediatePropagation) {
//			layer.removeEventListener = function(type, callback, capture) {
//				var rmv = Node.prototype.removeEventListener;
//				if (type === 'click') {
//					rmv.call(layer, type, callback.hijacked || callback, capture);
//				} else {
//					rmv.call(layer, type, callback, capture);
//				}
//			};
//
//			layer.addEventListener = function(type, callback, capture) {
//				var adv = Node.prototype.addEventListener;
//				if (type === 'click') {
//					adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
//						if (!event.propagationStopped) {
//							callback(event);
//						}
//					}), capture);
//				} else {
//					adv.call(layer, type, callback, capture);
//				}
//			};
//		}
//
//		// If a handler is already declared in the element's onclick attribute, it will be fired before
//		// FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
//		// adding it as listener.
//		if (typeof layer.onclick === 'function') {
//
//			// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
//			// - the old one won't work if passed to addEventListener directly.
//			oldOnClick = layer.onclick;
//			layer.addEventListener('click', function(event) {
//				oldOnClick(event);
//			}, false);
//			layer.onclick = null;
//		}
//	}
//
//	/**
//	* Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
//	*
//	* @type boolean
//	*/
//	var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;
//
//	/**
//	 * Android requires exceptions.
//	 *
//	 * @type boolean
//	 */
//	var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;
//
//
//	/**
//	 * iOS requires exceptions.
//	 *
//	 * @type boolean
//	 */
//	var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;
//
//
//	/**
//	 * iOS 4 requires an exception for select elements.
//	 *
//	 * @type boolean
//	 */
//	var deviceIsIOS4 = deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);
//
//
//	/**
//	 * iOS 6.0-7.* requires the target element to be manually derived
//	 *
//	 * @type boolean
//	 */
//	var deviceIsIOSWithBadTarget = deviceIsIOS && (/OS [6-7]_\d/).test(navigator.userAgent);
//
//	/**
//	 * BlackBerry requires exceptions.
//	 *
//	 * @type boolean
//	 */
//	var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;
//
//	/**
//	 * Determine whether a given element requires a native click.
//	 *
//	 * @param {EventTarget|Element} target Target DOM element
//	 * @returns {boolean} Returns true if the element needs a native click
//	 */
//	FastClick.prototype.needsClick = function(target) {
//		switch (target.nodeName.toLowerCase()) {
//
//		// Don't send a synthetic click to disabled inputs (issue #62)
//		case 'button':
//		case 'select':
//		case 'textarea':
//			if (target.disabled) {
//				return true;
//			}
//
//			break;
//		case 'input':
//
//			// File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
//			if ((deviceIsIOS && target.type === 'file') || target.disabled) {
//				return true;
//			}
//
//			break;
//		case 'label':
//		case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames
//		case 'video':
//			return true;
//		}
//
//		return (/\bneedsclick\b/).test(target.className);
//	};
//
//
//	/**
//	 * Determine whether a given element requires a call to focus to simulate click into element.
//	 *
//	 * @param {EventTarget|Element} target Target DOM element
//	 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
//	 */
//	FastClick.prototype.needsFocus = function(target) {
//		switch (target.nodeName.toLowerCase()) {
//		case 'textarea':
//			return true;
//		case 'select':
//			return !deviceIsAndroid;
//		case 'input':
//			switch (target.type) {
//			case 'button':
//			case 'checkbox':
//			case 'file':
//			case 'image':
//			case 'radio':
//			case 'submit':
//				return false;
//			}
//
//			// No point in attempting to focus disabled inputs
//			return !target.disabled && !target.readOnly;
//		default:
//			return (/\bneedsfocus\b/).test(target.className);
//		}
//	};
//
//
//	/**
//	 * Send a click event to the specified element.
//	 *
//	 * @param {EventTarget|Element} targetElement
//	 * @param {Event} event
//	 */
//	FastClick.prototype.sendClick = function(targetElement, event) {
//		var clickEvent, touch;
//
//		// On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
//		if (document.activeElement && document.activeElement !== targetElement) {
//			document.activeElement.blur();
//		}
//
//		touch = event.changedTouches[0];
//
//		// Synthesise a click event, with an extra attribute so it can be tracked
//		clickEvent = document.createEvent('MouseEvents');
//		clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
//		clickEvent.forwardedTouchEvent = true;
//		targetElement.dispatchEvent(clickEvent);
//	};
//
//	FastClick.prototype.determineEventType = function(targetElement) {
//
//		//Issue #159: Android Chrome Select Box does not open with a synthetic click event
//		if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
//			return 'mousedown';
//		}
//
//		return 'click';
//	};
//
//
//	/**
//	 * @param {EventTarget|Element} targetElement
//	 */
//	FastClick.prototype.focus = function(targetElement) {
//		var length;
//
//		// Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
//		if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && //targetElement.type !== 'month') {
//			length = targetElement.value.length;
//			targetElement.setSelectionRange(length, length);
//		} else {
//			targetElement.focus();
//		}
//	};
//
//
//	/**
//	 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
//	 *
//	 * @param {EventTarget|Element} targetElement
//	 */
//	FastClick.prototype.updateScrollParent = function(targetElement) {
//		var scrollParent, parentElement;
//
//		scrollParent = targetElement.fastClickScrollParent;
//
//		// Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
//		// target element was moved to another parent.
//		if (!scrollParent || !scrollParent.contains(targetElement)) {
//			parentElement = targetElement;
//			do {
//				if (parentElement.scrollHeight > parentElement.offsetHeight) {
//					scrollParent = parentElement;
//					targetElement.fastClickScrollParent = parentElement;
//					break;
//				}
//
//				parentElement = parentElement.parentElement;
//			} while (parentElement);
//		}
//
//		// Always update the scroll top tracker if possible.
//		if (scrollParent) {
//			scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
//		}
//	};
//
//
//	/**
//	 * @param {EventTarget} targetElement
//	 * @returns {Element|EventTarget}
//	 */
//	FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
//
//		// On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
//		if (eventTarget.nodeType === Node.TEXT_NODE) {
//			return eventTarget.parentNode;
//		}
//
//		return eventTarget;
//	};
//
//
//	/**
//	 * On touch start, record the position and scroll offset.
//	 *
//	 * @param {Event} event
//	 * @returns {boolean}
//	 */
//	FastClick.prototype.onTouchStart = function(event) {
//		var targetElement, touch, selection;
//
//		// Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
//		if (event.targetTouches.length > 1) {
//			return true;
//		}
//
//		targetElement = this.getTargetElementFromEventTarget(event.target);
//		touch = event.targetTouches[0];
//
//		if (deviceIsIOS) {
//
//			// Only trusted events will deselect text on iOS (issue #49)
//			selection = window.getSelection();
//			if (selection.rangeCount && !selection.isCollapsed) {
//				return true;
//			}
//
//			if (!deviceIsIOS4) {
//
//				// Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
//				// when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
//				// with the same identifier as the touch event that previously triggered the click that triggered the alert.
//				// Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
//				// immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
//				// Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
//				// which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
//				// random integers, it's safe to to continue if the identifier is 0 here.
//				if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
//					event.preventDefault();
//					return false;
//				}
//
//				this.lastTouchIdentifier = touch.identifier;
//
//				// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
//				// 1) the user does a fling scroll on the scrollable layer
//				// 2) the user stops the fling scroll with another tap
//				// then the event.target of the last 'touchend' event will be the element that was under the user's finger
//				// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
//				// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
//				this.updateScrollParent(targetElement);
//			}
//		}
//
//		this.trackingClick = true;
//		this.trackingClickStart = event.timeStamp;
//		this.targetElement = targetElement;
//
//		this.touchStartX = touch.pageX;
//		this.touchStartY = touch.pageY;
//
//		// Prevent phantom clicks on fast double-tap (issue #36)
//		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
//			event.preventDefault();
//		}
//
//		return true;
//	};
//
//
//	/**
//	 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
//	 *
//	 * @param {Event} event
//	 * @returns {boolean}
//	 */
//	FastClick.prototype.touchHasMoved = function(event) {
//		var touch = event.changedTouches[0], boundary = this.touchBoundary;
//
//		if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
//			return true;
//		}
//
//		return false;
//	};
//
//
//	/**
//	 * Update the last position.
//	 *
//	 * @param {Event} event
//	 * @returns {boolean}
//	 */
//	FastClick.prototype.onTouchMove = function(event) {
//		if (!this.trackingClick) {
//			return true;
//		}
//
//		// If the touch has moved, cancel the click tracking
//		if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
//			this.trackingClick = false;
//			this.targetElement = null;
//		}
//
//		return true;
//	};
//
//
//	/**
//	 * Attempt to find the labelled control for the given label element.
//	 *
//	 * @param {EventTarget|HTMLLabelElement} labelElement
//	 * @returns {Element|null}
//	 */
//	FastClick.prototype.findControl = function(labelElement) {
//
//		// Fast path for newer browsers supporting the HTML5 control attribute
//		if (labelElement.control !== undefined) {
//			return labelElement.control;
//		}
//
//		// All browsers under test that support touch events also support the HTML5 htmlFor attribute
//		if (labelElement.htmlFor) {
//			return document.getElementById(labelElement.htmlFor);
//		}
//
//		// If no for attribute exists, attempt to retrieve the first labellable descendant element
//		// the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
//		return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
//	};
//
//
//	/**
//	 * On touch end, determine whether to send a click event at once.
//	 *
//	 * @param {Event} event
//	 * @returns {boolean}
//	 */
//	FastClick.prototype.onTouchEnd = function(event) {
//		var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;
//
//        //console.trace('TRACE');
//
//		if (!this.trackingClick) {
//			return true;
//		}
//
//		// Prevent phantom clicks on fast double-tap (issue #36)
//		if ((event.timeStamp - this.lastClickTime) < this.tapDelay) {
//			this.cancelNextClick = true;
//			return true;
//		}
//
//		if ((event.timeStamp - this.trackingClickStart) > this.tapTimeout) {
//			return true;
//		}
//
//		// Reset to prevent wrong click cancel on input (issue #156).
//		this.cancelNextClick = false;
//
//		this.lastClickTime = event.timeStamp;
//
//		trackingClickStart = this.trackingClickStart;
//		this.trackingClick = false;
//		this.trackingClickStart = 0;
//
//		// On some iOS devices, the targetElement supplied with the event is invalid if the layer
//		// is performing a transition or scroll, and has to be re-detected manually. Note that
//		// for this to function correctly, it must be called *after* the event target is checked!
//		// See issue #57; also filed as rdar://13048589 .
//		if (deviceIsIOSWithBadTarget) {
//			touch = event.changedTouches[0];
//
//			// In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
//			targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
//			targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
//		}
//
//		targetTagName = targetElement.tagName.toLowerCase();
//		if (targetTagName === 'label') {
//			forElement = this.findControl(targetElement);
//			if (forElement) {
//				this.focus(targetElement);
//				if (deviceIsAndroid) {
//					return false;
//				}
//
//				targetElement = forElement;
//			}
//		} else if (this.needsFocus(targetElement)) {
//
//			// Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
//			// Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
//			if ((event.timeStamp - trackingClickStart) > 100 || (deviceIsIOS && window.top !== window && targetTagName === 'input')) {
//				this.targetElement = null;
//				return false;
//			}
//
//			this.focus(targetElement);
//			this.sendClick(targetElement, event);
//
//			// Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
//			// Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)
//			if (!deviceIsIOS || targetTagName !== 'select') {
//				this.targetElement = null;
//				event.preventDefault();
//			}
//
//			return false;
//		}
//
//		if (deviceIsIOS && !deviceIsIOS4) {
//
//			// Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
//			// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
//			scrollParent = targetElement.fastClickScrollParent;
//			if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
//				return true;
//			}
//		}
//
//		// Prevent the actual click from going though - unless the target node is marked as requiring
//		// real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
//		if (!this.needsClick(targetElement)) {
//			event.preventDefault();
//			this.sendClick(targetElement, event);
//		}
//
//		return false;
//	};
//
//
//	/**
//	 * On touch cancel, stop tracking the click.
//	 *
//	 * @returns {void}
//	 */
//	FastClick.prototype.onTouchCancel = function() {
//		this.trackingClick = false;
//		this.targetElement = null;
//	};
//
//
//	/**
//	 * Determine mouse events which should be permitted.
//	 *
//	 * @param {Event} event
//	 * @returns {boolean}
//	 */
//	FastClick.prototype.onMouse = function(event) {
//
//		// If a target element was never set (because a touch event was never fired) allow the event
//		if (!this.targetElement) {
//			return true;
//		}
//
//		if (event.forwardedTouchEvent) {
//			return true;
//		}
//
//		// Programmatically generated events targeting a specific element should be permitted
//		if (!event.cancelable) {
//			return true;
//		}
//
//		// Derive and check the target element to see whether the mouse event needs to be permitted;
//		// unless explicitly enabled, prevent non-touch click events from triggering actions,
//		// to prevent ghost/doubleclicks.
//		if (!this.needsClick(this.targetElement) || this.cancelNextClick) {
//
//			// Prevent any user-added listeners declared on FastClick element from being fired.
//			if (event.stopImmediatePropagation) {
//				event.stopImmediatePropagation();
//			} else {
//
//				// Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
//				event.propagationStopped = true;
//			}
//
//			// Cancel the event
//			event.stopPropagation();
//			event.preventDefault();
//
//			return false;
//		}
//
//		// If the mouse event is permitted, return true for the action to go through.
//		return true;
//	};
//
//
//	/**
//	 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
//	 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
//	 * an actual click which should be permitted.
//	 *
//	 * @param {Event} event
//	 * @returns {boolean}
//	 */
//	FastClick.prototype.onClick = function(event) {
//		var permitted;
//
//		// It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
//		if (this.trackingClick) {
//			this.targetElement = null;
//			this.trackingClick = false;
//			return true;
//		}
//
//		// Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
//		if (event.target.type === 'submit' && event.detail === 0) {
//			return true;
//		}
//
//		permitted = this.onMouse(event);
//
//		// Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the //browser's click doesn't go through.
//		if (!permitted) {
//			this.targetElement = null;
//		}
//
//		// If clicks are permitted, return true for the action to go through.
//		return permitted;
//	};
//
//
//	/**
//	 * Remove all FastClick's event listeners.
//	 *
//	 * @returns {void}
//	 */
//	FastClick.prototype.destroy = function() {
//		var layer = this.layer;
//
//		if (deviceIsAndroid) {
//			layer.removeEventListener('mouseover', this.onMouse, true);
//			layer.removeEventListener('mousedown', this.onMouse, true);
//			layer.removeEventListener('mouseup', this.onMouse, true);
//		}
//
//		layer.removeEventListener('click', this.onClick, true);
//		layer.removeEventListener('touchstart', this.onTouchStart, false);
//		layer.removeEventListener('touchmove', this.onTouchMove, false);
//		layer.removeEventListener('touchend', this.onTouchEnd, false);
//		layer.removeEventListener('touchcancel', this.onTouchCancel, false);
//	};
//
//
//	/**
//	 * Check whether FastClick is needed.
//	 *
//	 * @param {Element} layer The layer to listen on
//	 */
//	FastClick.notNeeded = function(layer) {
//		var metaViewport;
//		var chromeVersion;
//		var blackberryVersion;
//		var firefoxVersion;
//
//		// Devices that don't support touch don't need FastClick
//		if (typeof window.ontouchstart === 'undefined') {
//			return true;
//		}
//
//		// Chrome version - zero for other browsers
//		chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];
//
//		if (chromeVersion) {
//
//			if (deviceIsAndroid) {
//				metaViewport = document.querySelector('meta[name=viewport]');
//
//				if (metaViewport) {
//					// Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
//					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
//						return true;
//					}
//					// Chrome 32 and above with width=device-width or less don't need FastClick
//					if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
//						return true;
//					}
//				}
//
//			// Chrome desktop doesn't need FastClick (issue #15)
//			} else {
//				return true;
//			}
//		}
//
//		if (deviceIsBlackBerry10) {
//			blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/);
//
//			// BlackBerry 10.3+ does not require Fastclick library.
//			// https://github.com/ftlabs/fastclick/issues/251
//			if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
//				metaViewport = document.querySelector('meta[name=viewport]');
//
//				if (metaViewport) {
//					// user-scalable=no eliminates click delay.
//					if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
//						return true;
//					}
//					// width=device-width (or less than device-width) eliminates click delay.
//					if (document.documentElement.scrollWidth <= window.outerWidth) {
//						return true;
//					}
//				}
//			}
//		}
//
//		// IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)
//		if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
//			return true;
//		}
//
//		// Firefox version - zero for other browsers
//		firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];
//
//		if (firefoxVersion >= 27) {
//			// Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896
//
//			metaViewport = document.querySelector('meta[name=viewport]');
//			if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
//				return true;
//			}
//		}
//
//		// IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
//		// http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx
//		if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
//			return true;
//		}
//
//		return false;
//	};
//
//
//	/**
//	 * Factory method for creating a FastClick object
//	 *
//	 * @param {Element} layer The layer to listen on
//	 * @param {Object} [options={}] The options to override the defaults
//	 */
//	FastClick.attach = function(layer, options) {
//		return new FastClick(layer, options);
//	};
//
//
//	if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
//
//		// AMD. Register as an anonymous module.
//		define(function() {
//			return FastClick;
//		});
//	} else if (typeof module !== 'undefined' && module.exports) {
//		module.exports = FastClick.attach;
//		module.exports.FastClick = FastClick;
//	} else {
//		window.FastClick = FastClick;
//	}
//}());




/*
    json_parse.js
    2012-06-20

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    This file creates a json_parse function.

        json_parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = json_parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

    This is a reference implementation. You are free to copy, modify, or
    redistribute.

    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.
*/

/*members "", "\"", "\/", "\\", at, b, call, charAt, f, fromCharCode,
    hasOwnProperty, message, n, name, prototype, push, r, t, text
*/


window.JSON = window.JSON || {};

window.JSON.parse = (function () {
    "use strict";

// This is a function that can parse a JSON text, producing a JavaScript
// data structure. It is a simple, recursive descent parser. It does not use
// eval or regular expressions, so it can be used as a model for implementing
// a JSON parser in other languages.

// We are defining the function inside of another function to avoid creating
// global variables.

    var at,     // The index of the current character
        ch,     // The current character
        escapee = {
            '"':  '"',
            '\\': '\\',
            '/':  '/',
            b:    '\b',
            f:    '\f',
            n:    '\n',
            r:    '\r',
            t:    '\t'
        },
        text,

        error = function (m) {

// Call error when something is wrong.

            throw {
                name:    'SyntaxError',
                message: m,
                at:      at,
                text:    text
            };
        },

        next = function (c) {

// If a c parameter is provided, verify that it matches the current character.

            if (c && c !== ch) {
                error("Expected '" + c + "' instead of '" + ch + "'");
            }

// Get the next character. When there are no more characters,
// return the empty string.

            ch = text.charAt(at);
            at += 1;
            return ch;
        },

        number = function () {

// Parse a number value.

            var number,
                string = '';

            if (ch === '-') {
                string = '-';
                next('-');
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
            if (ch === '.') {
                string += '.';
                while (next() && ch >= '0' && ch <= '9') {
                    string += ch;
                }
            }
            if (ch === 'e' || ch === 'E') {
                string += ch;
                next();
                if (ch === '-' || ch === '+') {
                    string += ch;
                    next();
                }
                while (ch >= '0' && ch <= '9') {
                    string += ch;
                    next();
                }
            }
            number = +string;
            if (!isFinite(number)) {
                error("Bad number");
            } else {
                return number;
            }
        },

        string = function () {

// Parse a string value.

            var hex,
                i,
                string = '',
                uffff;

// When parsing for string values, we must look for " and \ characters.

            if (ch === '"') {
                while (next()) {
                    if (ch === '"') {
                        next();
                        return string;
                    }
                    if (ch === '\\') {
                        next();
                        if (ch === 'u') {
                            uffff = 0;
                            for (i = 0; i < 4; i += 1) {
                                hex = parseInt(next(), 16);
                                if (!isFinite(hex)) {
                                    break;
                                }
                                uffff = uffff * 16 + hex;
                            }
                            string += String.fromCharCode(uffff);
                        } else if (typeof escapee[ch] === 'string') {
                            string += escapee[ch];
                        } else {
                            break;
                        }
                    } else {
                        string += ch;
                    }
                }
            }
            error("Bad string");
        },

        white = function () {

// Skip whitespace.

            while (ch && ch <= ' ') {
                next();
            }
        },

        word = function () {

// true, false, or null.

            switch (ch) {
            case 't':
                next('t');
                next('r');
                next('u');
                next('e');
                return true;
            case 'f':
                next('f');
                next('a');
                next('l');
                next('s');
                next('e');
                return false;
            case 'n':
                next('n');
                next('u');
                next('l');
                next('l');
                return null;
            }
            error("Unexpected '" + ch + "'");
        },

        value,  // Place holder for the value function.

        array = function () {

// Parse an array value.

            var array = [];

            if (ch === '[') {
                next('[');
                white();
                if (ch === ']') {
                    next(']');
                    return array;   // empty array
                }
                while (ch) {
                    array.push(value());
                    white();
                    if (ch === ']') {
                        next(']');
                        return array;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad array");
        },

        object = function () {

// Parse an object value.

            var key,
                object = {};

            if (ch === '{') {
                next('{');
                white();
                if (ch === '}') {
                    next('}');
                    return object;   // empty object
                }
                while (ch) {
                    key = string();
                    white();
                    next(':');
                    if (Object.hasOwnProperty.call(object, key)) {
                        error('Duplicate key "' + key + '"');
                    }
                    object[key] = value();
                    white();
                    if (ch === '}') {
                        next('}');
                        return object;
                    }
                    next(',');
                    white();
                }
            }
            error("Bad object");
        };

    value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

        white();
        switch (ch) {
        case '{':
            return object();
        case '[':
            return array();
        case '"':
            return string();
        case '-':
            return number();
        default:
            return ch >= '0' && ch <= '9' ? number() : word();
        }
    };

// Return the json_parse function. It will have access to all of the above
// functions and variables.

    return function (source, reviver) {
        var result;

        text = source;
        at = 0;
        ch = ' ';
        result = value();
        white();
        if (ch) {
            error("Syntax error");
        }

// If there is a reviver function, we recursively walk the new structure,
// passing each name/value pair to the reviver function for possible
// transformation, starting with a temporary root object that holds the result
// in an empty key. If there is not a reviver function, we simply return the
// result.

        return typeof reviver === 'function'
            ? (function walk(holder, key) {
                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }({'': result}, ''))
            : result;
    };
}());// ##############################################################
// ################ doT.js AND RELATED FUNCTIONS ################
// ##############################################################

// Laura Doktorova https://github.com/olado/doT
// version: 1.0.3
(function(){function p(b,a,d){return("string"===typeof a?a:a.toString()).replace(b.define||h,function(a,c,e,g){0===c.indexOf("def.")&&(c=c.substring(4));c in d||(":"===e?(b.defineParams&&g.replace(b.defineParams,function(a,b,l){d[c]={arg:b,text:l}}),c in d||(d[c]=g)):(new Function("def","def['"+c+"']="+g))(d));return""}).replace(b.use||h,function(a,c){b.useParams&&(c=c.replace(b.useParams,function(a,b,c,l){if(d[c]&&d[c].arg&&l)return a=(c+":"+l).replace(/'|\\/g,"_"),d.__exp=d.__exp||{},d.__exp[a]=
d[c].text.replace(new RegExp("(^|[^\\w$])"+d[c].arg+"([^\\w$])","g"),"$1"+l+"$2"),b+"def.__exp['"+a+"']"}));var e=(new Function("def","return "+c))(d);return e?p(b,e,d):e})}function k(b){return b.replace(/\\('|\\)/g,"$1").replace(/[\r\t\n]/g," ")}var f={version:"1.0.3",templateSettings:{evaluate:/\{\{([\s\S]+?(\}?)+)\}\}/g,interpolate:/\{\{=([\s\S]+?)\}\}/g,encode:/\{\{!([\s\S]+?)\}\}/g,use:/\{\{#([\s\S]+?)\}\}/g,useParams:/(^|[^\w$])def(?:\.|\[[\'\"])([\w$\.]+)(?:[\'\"]\])?\s*\:\s*([\w$\.]+|\"[^\"]+\"|\'[^\']+\'|\{[^\}]+\})/g,
define:/\{\{##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\}\}/g,defineParams:/^\s*([\w$]+):([\s\S]+)/,conditional:/\{\{\?(\?)?\s*([\s\S]*?)\s*\}\}/g,iterate:/\{\{~\s*(?:\}\}|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\}\})/g,varname:"it",strip:!0,append:!0,selfcontained:!1,doNotSkipEncoded:!1},template:void 0,compile:void 0},m;



// f.encodeHTMLSource = function(b) {
//         var a = {
//                 "&": "&#38;",
//                 "<": "&#60;",
//                 ">": "&#62;",
//                 '"': "&#34;",
//                 "'": "&#39;",
//                 "/": "&#47;"
//             },
//             d = b ? /[&<>"'\/]/g : /&(?!#?\w+;)|<|>|"|'|\//g;
//         return function(b) {
//                 return b ?

f.encodeHTMLSource=function(b){var a={"&":"&#38;","<":"&#60;",">":"&#62;",'"':"&#34;","'":"&#39;","/":"&#47;"},d=b?/[&<>"'\/]/g:/&(?!#?\w+;)|<|>|"|'|\//g;return function(b){return b?
b.toString().replace(d,function(b){return a[b]||b}):b}}; // replaced :"" with :b so that if you put a zero in encodehtml you get a zero out of encodehtml


m=function(){return this||(0,eval)("this")}();

"undefined"!==typeof module&&module.exports?module.exports=f:"function"===typeof define&&define.amd?define(function(){return f}):m.doT=f;



var r={start:"'+(",end:")+'",startencode:"'+encodeHTML("},s={start:"';out+=(",end:");out+='",startencode:"';out+=encodeHTML("},h=/$^/;f.template=function(b,a,d){a=a||f.templateSettings;var n=a.append?r:s,c,e=0,g;b=a.use||a.define?p(a,b,d||{}):b;b=("var out='"+(a.strip?
b.replace(/(^|\r|\n)\t* +| +\t*(\r|\n|$)/g," ").replace(/\r|\n|\t|\/\*[\s\S]*?\*\//g,""):b).replace(/'|\\/g,"\\$&").replace(a.interpolate||h,function(b,a){return n.start+k(a)+n.end}).replace(a.encode||h,function(b,a){c=!0;return n.startencode+k(a)+n.end}).replace(a.conditional||h,function(b,a,c){return a?c?"';}else if("+k(c)+"){out+='":"';}else{out+='":c?"';if("+k(c)+"){out+='":"';}out+='"}).replace(a.iterate||h,function(b,a,c,d){if(!a)return"';} } out+='";e+=1;g=d||"i"+e;a=k(a);return"';var arr"+
e+"="+a+";if(arr"+e+"){var "+c+","+g+"=-1,l"+e+"=arr"+e+".length-1;while("+g+"<l"+e+"){"+c+"=arr"+e+"["+g+"+=1];out+='"}).replace(a.evaluate||h,function(a,b){return"';"+k(b)+"out+='"})+"';return out;").replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/\r/g,"\\r").replace(/(\s|;|\}|^|\{)out\+='';/g,"$1").replace(/\+''/g,"");c&&(a.selfcontained||!m||m._encodeHTML||(m._encodeHTML=f.encodeHTMLSource(a.doNotSkipEncoded)),b="var encodeHTML = typeof _encodeHTML !== 'undefined' ? _encodeHTML : ("+f.encodeHTMLSource.toString()+
"("+(a.doNotSkipEncoded||"")+"));"+b);try{return new Function(a.varname,b)}catch(q){throw"undefined"!==typeof console&&console.log("Could not create a template function: "+b),q;}};f.compile=function(b,a){return f.template(b,null,a)}


    // we use doT.js in the global space, but sometimes module may be
    //      defined (electron defines module automatically) so we need to copy dot to
    //      the global namespace
    if (!window.doT) { // && window.module
        window.doT = f;

        //window.doT.encodeHTMLSource = module.exports.encodeHTMLSource;
        //window.doT.compile = module.exports.compile;
        //window.doT.templateSettings = module.exports.templateSettings;
        //window.doT.template = module.exports.template;
    }
})();


doT.templateSettings = {
    evaluate:    /\{\{([\s\S]+?)\}\}/g,
    interpolate: /\{\{=([\s\S]+?)\}\}/g,
    encode:      /\{\{!([\s\S]+?)\}\}/g,
    use:         /\{\{#([\s\S]+?)\}\}/g,
    define:      /\{\{##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\}\}/g,
    conditional: /\{\{\?(\?)?\s*([\s\S]*?)\s*\}\}/g,
    iterate:     /\{\{~\s*(?:}}|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\}\})/g,
    varname: 'jo',
    strip: false,
    append: true,
    selfcontained: false
};

// html encoding function used by doT.js
function encodeHTML(text) {
    'use strict';
    var encode = {
        "&": "&#38;",
        "<": "&#60;",
        ">": "&#62;",
        '"': "&#34;",
        "'": "&#39;",
        "/": "&#47;"
    };
    return text ? text.toString().replace(/&|<|>|"|'|\//g, function (letter) {
        return encode[letter] || letter;
    }) : text;
}

// html decoding function
function decodeHTML(text) {
    'use strict';
    var decode = {
        "&#38;": "&",
        "&amp;": "&",

        "&#60;": "<",
        "&#62;": ">",

        "&lt;":  "<", // The rose by another name
        "&gt;":  ">", // The rose by another name

        "&#34;": '"',
        "&#39;": "'",
        "&#47;": "/"
    };
    return text ? text.toString().replace(/&#38;|&amp;|&#60;|&#62;|&lt;|&gt;|&#34;|&#39;|&#47;/g, function (letter) {
        return decode[letter] || letter;
    }) : text;
}

// multiline strings in javascript
//
// ml(function () {/*
//     multiline string
//     hey
// */console.log});
function ml(func) {
    'use strict';

    func = func.toString();

    return func.substring(func.indexOf('/*') + 2, func.indexOf('*/'));
}
//global window
//jslint white:true multivar:true

// #############################################################
// ################### CROSS PLATFORM EVENTS ###################
// #############################################################

if (window.evt === undefined) {
    window.evt = {};
}

// function for testing if the device has touch capibilities
function touchDeviceTest() {
    'use strict';
    //return 'ontouchstart' in window ||    // works on most browsers
    //       'onmsgesturechange' in window; // works on ie10
    return (('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) || false;
}

// display type based on size
function getDeviceType() {
    'use strict';
    // if we are not on a touch device than we must be a desktop
    if (evt.touchDevice === false) {
        return 'desktop';
    }
    // if touch device and screen is bigger than normal phone
    if (evt.touchDevice === true && screen.width > 500) {
        return 'tablet';
    }
    // if the screen is small and we are a touch device we are a phone
    return 'phone';
}

/*DOC
Name:
    evt.*

Description:
    This is a collection of global variables that are used for browser-type detection and for using different events for different devices.
    The reason for this is because even though the 'mousedown' event works on a phone it is substantially slower than if you had used 'touchstart',
    But if you used 'touchstart' it wouldn't work on the computer so we wrap both under the name evt.mousedown and only give mobile browsers
    'touchstart' and desktop browsers 'mousedown' so that you dont have to differentiate.

List of variables:
    evt.touchDevice  equals true|false depending on whether or not we are on a touch-enabled devide
    evt.deviceType   equals 'desktop'|'tablet'|'phone' depending on what type of device you are on

    evt.mousedown    if we are on a touch device: 'touchstart'  else  'mousedown'
    evt.mouseover    if we are on a touch device: 'touchenter'  else  'mouseover'
    evt.mousemove    if we are on a touch device: 'touchmove'   else  'mousemove'
    evt.mouseout     if we are on a touch device: 'touchleave'  else  'mouseout'
    evt.mouseup      if we are on a touch device: 'touchend'    else  'mouseup'
    evt.click        if we are on a touch device: 'touchend'    else  'click'

*/

// this is for detecting whether or not we are in an touch device
evt.touchDevice = touchDeviceTest();

// set global variable for display type
evt.deviceType = getDeviceType();

evt.mousedown = evt.touchDevice ? 'touchstart': 'mousedown';
evt.mouseover = evt.touchDevice ? 'touchenter': 'mouseover';
evt.mousemove = evt.touchDevice ? 'touchmove' : 'mousemove';
evt.mouseout  = evt.touchDevice ? 'touchleave': 'mouseout';
evt.mouseup   = evt.touchDevice ? 'touchend'  : 'mouseup';
evt.click     = 'click';

// ##############################################################
// ########### PINK BACKGROUND WHEN NOT IN PRODUCTION ###########
// ##############################################################
/*
//DO NOT UNCOMMENT
//To use:
//Add this javascript to the test.sh file
//Append to greyspots.js after the rsync of the web_root files
window.addEventListener('load', function () {
    var styleElement, helperElement, helperFunction;

    styleElement = document.createElement('style');
    styleElement.innerHTML = 'body, body gs-panel, body gs-panel gs-header, body gs-panel gs-body, ' +
                             'body gs-page, body gs-page gs-header, body gs-page gs-body {\n' +
                             '    background-color: #FFBBBB;\n' +
                             '}';

    document.head.appendChild(styleElement);
});
*/

// #############################################################
// #################### DEFINE GS NAMESPACE ####################
// #############################################################

if (window.GS === undefined) {
    window.GS = {};

    GS.version = function () {
        'use strict';
        return '1.1.1';
    };

    window.addEventListener('design-register-element', function () {
        'use strict';

        registerDesignSnippet('GS.version', 'GS.version', 'GS.version();');
    });
}

// ##############################################################
// ################## DEFINE support NAMESPACE ##################
// ##############################################################

if (window.shimmed === undefined) {
    window.shimmed = {};
}

// ##############################################################
// ############### DEFINE functionality NAMESPACE ###############
// ##############################################################

if (window.functionality === undefined) {
    window.functionality = {"errors": {}};
}

// ##############################################################
// ####################### NO CONSOLE FIX #######################
// ##############################################################

// in IE8 when the dev tools are not open console.log is not defined so if there was a console.log() the page would error
//      this defines the console object if it is empty so that if there is a console.log() it will not error in IE8
if (typeof console === 'undefined' || !console.log) {
    window.console = {
        log:   function () { 'use strict'; },
        info:  function () { 'use strict'; },
        debug: function () { 'use strict'; },
        warn:  function () { 'use strict'; },
        trace: function () { 'use strict'; },
        error: function () { 'use strict'; }
    };
}


// ##############################################################
// ######## PREVENT WINDOW OVERSCROLLING ON TOUCH DEVICE ########
// ##############################################################
/*
if (evt.touchDevice) {
    (function () {
        var startTime, startTouchTop, endTime, endTouchTop, lastTouchTop, currentTouchTop,
            bolCurrentlyMonitoring = false, bolTouchScrollPrevented = false, currentScrollingElement, scrollingLooper;

        window.ontouchstart = function(event){
            lastTouchTop = GS.mousePosition(event).top;
        };

        //window.addEventListener('scroll', function (event) {
        //    console.log(event);
        //}, true);

        window.ontouchmove = function (event) {
            var currentTouchTop = GS.mousePosition(event).top, currentElement = GS.scrollParent(event.target), bolFoundScrollable = Boolean(currentElement);

            //console.log(currentElement,
            //            event.target,
            //            bolFoundScrollable,
            //            currentElement.scrollTop,
            //            currentElement.clientHeight,
            //            currentElement.scrollHeight,
            //            currentTouchTop,
            //            lastTouchTop);
            //console.log(currentElement.scrollTop <= 0,
            //            currentTouchTop > lastTouchTop,
            //            currentElement.scrollTop + currentElement.clientHeight >= currentElement.scrollHeight,
            //            currentTouchTop < lastTouchTop);

            if (bolFoundScrollable === false ||
                (currentElement.scrollTop <= 0 && currentTouchTop > lastTouchTop) ||
                (currentElement.scrollTop + currentElement.clientHeight >= currentElement.scrollHeight && currentTouchTop < lastTouchTop)) {

                //console.log('prevent default');

                bolTouchScrollPrevented = true;
                event.preventDefault();
                //event.stopPropagation();

            } else if (bolFoundScrollable === true && bolTouchScrollPrevented === true) {
                currentElement.scrollTop += (lastTouchTop - currentTouchTop);
            }

            currentScrollingElement = currentElement;
            lastTouchTop = currentTouchTop;
        };

        window.ontouchend = function () {
            bolTouchScrollPrevented = false;
        };
    })();
}*/


// ##############################################################
// ################### DATABASE NORMALIZATION ###################
// ##############################################################

GS.database = {"engine": "", "type": {}};
GS.database.engine = "postgres";


// if db is SQL Server: utf16 else utf8
(function () {
    "use strict";

    // get a cookie from the browser
    function getCookie(c_name) {
        var c_value = document.cookie, c_end,
            c_start = c_value.indexOf(" " + c_name + "=");

        if (c_start === -1) {
            c_start = c_value.indexOf(c_name + "=");
        }
        if (c_start === -1) {
            c_value = null;
        } else {
            c_start = c_value.indexOf("=", c_start) + 1;
            c_end = c_value.indexOf(";", c_start);
            if (c_end === -1) {
                c_end = c_value.length;
            }
            c_value = decodeURIComponent(c_value.substring(c_start, c_end));
        }
        return c_value;
    };

    if ((getCookie('DB') || 'PG').toUpperCase() === 'PG') {
        GS.database.engine = 'postgres';
    } else { //ss
        GS.database.engine = 'mssqlserver'
    }

    if (GS.database.engine === "postgres") {
        GS.database.type.text = "text";
        GS.database.type.timestamp = "timestamptz";

    } else if (GS.database.engine === "mssqlserver") {
        GS.database.type.text = "nvarchar(MAX)";
        GS.database.type.timestamp = "datetime";
    }
}());





// ##############################################################
// ########### LABEL CLICK: FOCUS USING FOR ATTRIBUTE ###########
// ##############################################################

window.addEventListener('click', function (event) {
    'use strict';
    var labelElement, targetElement;

    //console.log(event.target, GS.findParentTag(event.target, 'LABEL'));

    if (event.target.nodeName === 'LABEL') {
        labelElement = event.target;
    } else if (GS.findParentTag(event.target, 'LABEL')) {
        labelElement = GS.findParentTag(event.target, 'LABEL');
    }

    //console.log(labelElement, labelElement.getAttribute('for'));

    if (labelElement && labelElement.hasAttribute('for')) {
        targetElement = document.getElementById(labelElement.getAttribute('for'));

        //console.log(targetElement);
        //console.log(targetElement.focus, !targetElement.hasAttribute('disabled'));

        if (targetElement && targetElement.focus && !targetElement.hasAttribute('disabled')) {
            targetElement.focus();
        }
    }
});


// #############################################################
// ######################### PAGE CURL #########################
// #############################################################
(function () {
    function aboutDialog() {
        'use strict';
        var templateElement = document.createElement('template');

        templateElement.innerHTML = ml(function () {/*
            <gs-page>
                <gs-header><center><h3>About Envelope</h3></center></gs-header>
                <gs-body padded>
                    <gs-grid widths="1,1" reflow-at="767px">
                        <gs-block>
                            <center><h3><a target="_blank" href="http://x-tag.github.io/">X-Tag</a></h3></center>
                        </gs-block>
                        <gs-block>
                            <center><h4>Version Unknown</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center><h3><a target="_blank" href="http://olado.github.io/doT/">doT.js</a></h3></center>
                        </gs-block>
                        <gs-block>
                            <center><h4>{{DOT}}</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center><h3><a target="_blank" href="http://ace.c9.io/">Ace Editor</a></h3></center>
                        </gs-block>
                        <gs-block>
                            <center><h4>1.2.3</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center><h3><a target="_blank" href="http://jsbeautifier.org/">JSBeautifier</a></h3></center>
                        </gs-block>
                        <gs-block>
                            <center><h4>Version Unknown</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center>
                                <h3><a target="_blank" href="https://github.com/douglascrockford/JSON-js">
                                    json_parse.js (modified)
                                </a></h3>
                            </center>
                        </gs-block>
                        <gs-block>
                            <center><h4>Version Unknown</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center>
                                <h3><a target="_blank" href="https://www.polymer-project.org/1.0/">
                                    HTML Template Polyfill (modified)
                                </a></h3>
                            </center>
                        </gs-block>
                        <gs-block>
                            <center><h4>Version Unknown</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center>
                                <h3><a target="_blank" href="https://github.com/ftlabs/fastclick">FastClick</a></h3>
                            </center>
                        </gs-block>
                        <gs-block>
                            <center><h4>Version Unknown</h4></center>
                        </gs-block>
                        <br />
                        <gs-block>
                            <center>
                                <h3><a target="_blank" href="https://code.google.com/archive/p/crypto-js/">CryptoJS (MD5 Portion)</a></h3>
                            </center>
                        </gs-block>
                        <gs-block>
                            <center><h4>3.1.2</h4></center>
                        </gs-block>

                    </gs-grid>

                    <div>
                        All other source code and documentation copyright Workflow Products, LLC. All Rights Reserved.
                        <br /><br />
                        The Envelope platform is available for many platforms and most embedded devices. If you'd like your application built using Envelope technology please contact us.
                        <br /><br />
                        Commercial license terms for the Envelope platform are available for a small fee. Contact us for details.
                        <br /><br />
                        <center><b>Workflow Products, L.L.C.</b></center>
                        <center>7813 Harwood Road</center>
                        <center>North Richland Hills Texas 76180</center>
                        <center>(817) 503-9545</center>
                    </div>
                    <br />
                    <center><small><i>Copyright &copy; 2016-present by Workflow Products, L.L.C. (817) 503-9545</i></small></center>
                </gs-body>
                <gs-footer>
                    <gs-button dialogclose>Done</gs-button>
                </gs-footer>
            </gs-page>
        */}).replace(/\{\{DOT\}\}/gi, doT.version);

        GS.openDialog(templateElement);
    }


    window.addEventListener('load', function () {
        'use strict';
        var bolOpen, intMaxHeight, curlElement, menuElement, strPostageUName, strHTML, toggleCurl;

        if (window.bolCurl !== false) {
            bolOpen = false;
            intMaxHeight = 0;
            curlElement = document.createElement('div');
            menuElement = document.createElement('div');
            strPostageUName = GS.getCookie('postage_uname');
            strHTML = '';

            curlElement.setAttribute('id', 'gs-document-curl-container');
            curlElement.innerHTML = '<div id="gs-document-curl-part-1"></div>' +
                                    '<div id="gs-document-curl-part-2"></div>' +
                                    '<div id="gs-document-curl-part-3"></div>' +
                                    '<div id="gs-document-curl-part-4"></div>';

            document.body.appendChild(curlElement);

            if (evt.deviceType === 'phone') {
                curlElement.setAttribute('style', 'font-size: 1.3em;');
            } else {
                curlElement.setAttribute('style', 'font-size: 0.7em;');
            }

            menuElement.setAttribute('id', 'gs-document-menu-container');
            menuElement.setAttribute('style', 'height: 0px;');

            // this is for envelope
            if (location.pathname.indexOf('/env/') === 0) {
                strHTML += '<center><b><a target="_self" href="/env/app/all/index.html">Back To Main Menu</a></b></center>';
                strHTML += '<center>' +
                                '<gs-button target="_self" href="/env/auth/?action=logout" inline>Log out</gs-button><br />' +
                                '<gs-button onclick="GS.userChangePassword()" inline>Change Password</gs-button>' +
                            '</center>';
                intMaxHeight += 4.8;

            // and this is for postage
            } else {
                strHTML += '<center>' +
                                '<gs-button target="_self" href="/postage/auth?action=logout" inline>Log out</gs-button><br />' +
                                '<gs-button onclick="GS.userChangePassword()" inline>Change Password</gs-button>' +
                            '</center>';
                intMaxHeight += 3.4;
            }

            strHTML += '<center><gs-button onclick="GS.showShimmed()" inline>Browser Support</gs-button></center>';
            intMaxHeight += 1.9;

            strHTML += '<center><gs-button onclick="window.location.reload(true);" inline>Update Software</gs-button></center>';
            intMaxHeight += 1.9;

            if (location.pathname.indexOf('/env/') === 0) {
                strHTML += '<center><gs-button id="gs-button-about" inline>About</gs-button></center>';
                intMaxHeight += 1.9;
            }

            intMaxHeight += 1;

            menuElement.innerHTML = '<div id="gs-document-menu-link-container" style="height: ' + intMaxHeight + 'em;">' + strHTML + '</div>';
            document.body.appendChild(menuElement);

            if (location.pathname.indexOf('/env/') === 0) {
                document.getElementById('gs-button-about').addEventListener('click', aboutDialog);
            }

            // define function for toggling the page curl
            toggleCurl = function () {
                var intFontSize = GS.pxToEm(document.body, window.innerWidth) / 4,
                    intBottomLine = window.innerHeight - (GS.emToPx(document.body, intFontSize)),
                    closedSize = (evt.deviceType === 'phone' ? '1.3em' : '0.7em'); // replace evt.touchDevice with true to test on a desktop

                // maximum bottom line
                if (GS.pxToEm(document.body, intBottomLine) > intMaxHeight) {
                    intBottomLine = GS.emToPx(document.body, intMaxHeight);
                }

                //curlElement.classList.add('animating');
                //menuElement.classList.add('animating');

                if (bolOpen === false) {
                    document.body.insertBefore(GS.stringToElement('<div id="gs-document-curl-modal-background"></div>'), curlElement);
                    document.getElementById('gs-document-curl-modal-background').addEventListener('click', toggleCurl);

                    curlElement.style.fontSize = intFontSize + 'em';
                    curlElement.style.bottom = intBottomLine + 'px';
                    menuElement.style.height = intBottomLine + 'px';

                    //GS.animateStyle(curlElement, 'font-size', closedSize, intFontSize + 'em', function () {
                    //    curlElement.classList.remove('animating');
                    //}, 185, 14);
                    //
                    //GS.animateStyle(curlElement, 'bottom', '0px', intBottomLine + 'px', function () {
                    //    curlElement.classList.remove('animating');
                    //}, 185, 14);
                    //
                    //GS.animateStyle(menuElement, 'height', '0px', intBottomLine + 'px', function () {
                    //    menuElement.classList.remove('animating');
                    //}, 185, 14);

                    bolOpen = true;
                } else {
                    document.body.removeChild(document.getElementById('gs-document-curl-modal-background'));

                    curlElement.style.fontSize = closedSize;
                    curlElement.style.bottom = '0px';
                    menuElement.style.height = '0px';

                    //GS.animateStyle(curlElement, 'font-size', intFontSize + 'em', closedSize, function () {
                    //    curlElement.classList.remove('animating');
                    //}, 185, 14);
                    //
                    //GS.animateStyle(curlElement, 'bottom', intBottomLine + 'px', '0px', function () {
                    //    curlElement.classList.remove('animating');
                    //}, 185, 14);
                    //
                    //GS.animateStyle(menuElement, 'height', intBottomLine + 'px', '0px', function () {
                    //    menuElement.classList.remove('animating');
                    //}, 185, 14);

                    bolOpen = false;
                }
            };

            curlElement.addEventListener('click', toggleCurl);
        }
    });
})();

// ################################################################
// ###################### FASTCLICK POLYFILL ######################
// ################################################################

// double clicks will not work while using fastclick
// click events will not have a delay while using fastclick
// we chose fastclick :)

// if you need to turn fastclick off for an element use the "needsclick" class
// if you need to turn fastclick off for an elements children (but not the element itself) use the "childrenneedsclick" class
// if you need to turn fastclick off for an elements children and the element itself use the "childrenneedsclick" class and the "needsclick" class
if ('addEventListener' in document) {
    document.addEventListener('DOMContentLoaded', function() {
        'use strict';
        FastClick.attach(document.body);
    }, false);
}



// ##################################################################
// ##################### TEMPLATE GET INERT DOM #####################
// ##################################################################
/*
HTMLTemplateElement.prototype.contentTemplate = function () {
    'use strict';

    if (this.content) {

    } else {

    }
};
*/

// #################################################################
// ###################### POLYFILL/SHIM CHECK ######################
// #################################################################

window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('GS.showShimmed', 'GS.showShimmed', 'GS.showShimmed();');
});

window.addEventListener('load', function () {
    'use strict';
    function cleanFunctionForTest(fn) {
        fn = fn.toString().toLowerCase();   // convert function string and turn all text lowercase
        fn = fn.substring(fn.indexOf('{')); // remove everything up until the first open curly brace
        fn = fn.replace(/ /gim, '');        // remove all spaces

        return fn;
    }

    function nativeTest(fn) {
        // if there is not function: not native: return false
        if (!fn) {
            return false;
        }

        // clean function for native testing
        fn = cleanFunctionForTest(fn);

        return fn.indexOf('[nativecode]') > -1 ||                   // if '[nativecode]' is found in the cleaned text: native
               fn === cleanFunctionForTest(document.createElement); // else if the cleaned text matches a native function: native
    }

    shimmed.matchesSelector     = !nativeTest(Element.prototype.matchesSelector) &&
                                  !nativeTest(Element.prototype.webkitMatchesSelector) &&
                                  !nativeTest(Element.prototype.mozMatchesSelector) &&
                                  !nativeTest(Element.prototype.msMatchesSelector) &&
                                  !nativeTest(Element.prototype.MSMatchesSelector);

    shimmed.MutationObserver    = !nativeTest(window.MutationObserver);
    shimmed.WeakMap             = !nativeTest(window.WeakMap);
    shimmed.registerElement     = !nativeTest(document.registerElement);
    shimmed.DOMTokenList        = !nativeTest(window.DOMTokenList);
    shimmed.HTMLTemplateElement = Boolean(HTMLTemplateElement.bootstrap);

    // automated functionality testing

    functionality.matchesSelector = false;
    try {
        var bodyElement = document.body
          , matchesSelector = (Element.prototype.matchesSelector
                                || Element.prototype.webkitMatchesSelector
                                || Element.prototype.mozMatchesSelector
                                || Element.prototype.msMatchesSelector
                                || Element.prototype.MSMatchesSelector);

        functionality.matchesSelector = matchesSelector.apply(bodyElement, ['body']);

    } catch (e) {
        functionality.matchesSelector = false;
        functionality.errors.matchesSelector = e;
    }

    functionality.MutationObserver = false;
    try {
        var testElement = document.createElement('div'), observer;

        observer = new MutationObserver(function(mutations) {
            functionality.MutationObserver = (mutations.length > 0);
        });

        observer.observe(testElement, {'childList': true});
        testElement.appendChild(document.createElement('div'));
    } catch (e) {
        functionality.MutationObserver = false;
        functionality.errors.MutationObserver = e;
    }

    functionality.WeakMap = false;
    try {
        var testMap = new WeakMap(), testObject = function(){};

        testMap.set(testObject, 'asdfasdf');

        functionality.WeakMap = (testMap.get(testObject) === 'asdfasdf');
        functionality.WeakMap = (functionality.WeakMap && testMap.has(testObject) === true);

        testMap.delete(testObject);

        functionality.WeakMap = (functionality.WeakMap && testMap.has(testObject) === false);

    } catch (e) {
        functionality.WeakMap = false;
        functionality.errors.WeakMap = e;
    }

    functionality.registerElement = false;
    try {
        var prototype = Object.create(HTMLElement.prototype);
        prototype.testmethod = function () { return true; };
        document.registerElement('asdf-test', {'prototype': prototype});

        var testElement;
        testElement = document.createElement('asdf-test');

        functionality.registerElement = testElement.testmethod();

    } catch (e) {
        functionality.registerElement = false;
        functionality.errors.registerElement = e;
    }

    functionality.DOMTokenList = false;
    try {
        functionality.DOMTokenList = Boolean(document.body.classList);
    } catch (e) {
        functionality.DOMTokenList = false;
        functionality.errors.DOMTokenList = e;
    }

    functionality.HTMLTemplateElement = false;
    try {
        var testElement = document.createElement('template');

        xtag.register('asdf-test-two', {
            'lifecycle': {
                'created': function () {
                    var divElement = document.createElement('div');
                    divElement.classList.add('find-me');
                    this.appendChild(divElement);
                }
            }
        });

        testElement.innerHTML = '<div></div><p></p><asdf-test-two></asdf-test-two>';

        functionality.HTMLTemplateElement = (xtag.query(testElement, '.find-me').length === 0);

    } catch (e) {
        functionality.HTMLTemplateElement = false;
        functionality.errors.HTMLTemplateElement = e;
    }

    // function to show shim and functionality results
    GS.showShimmed = function () {
        var strHTML = '', key, templateElement;

        strHTML += '<br />\n' +
                   '<center>This dialog is for developers so that they can determine what technologies this browser supports and what technologies are being implemented manually.</center>\n' +
                   '<br />\n' +
                   '<hr />\n';

        for (key in shimmed) {
            strHTML += '<gs-grid reflow-at="450px">\n' +
                       '    <gs-block><center>' + encodeHTML(key) + '</center></gs-block>\n' +
                       '    <gs-block>\n' +
                       '        <center><b>' + (shimmed[key] ? 'SHIMMED' : 'NATIVE') + '</center></b>\n' +
                       '    </gs-block>\n' +
                       '    <gs-block>\n' +
                       '        <center>' + (functionality[key] ? '<b style="color: #3F9A3F;">FUNCTION PASS' : '<b style="color: #F00;">FUNCTION FAIL') + '</center></b>\n' +
                       '    </gs-block>\n' +
                       '</gs-grid>\n' +
                       '<hr />\n';
        }

        strHTML += '<br />';


        templateElement = document.createElement('template');

        templateElement.innerHTML = ml(function () {/*
            <gs-page>
                <gs-header><center><h3>Native Detection</h3></center></gs-header>
                <gs-body padded>
                    {{HTML}}
                </gs-body>
                <gs-footer><gs-button dialogclose>Done</gs-button></gs-footer>
            </gs-page>
        */}).replace('{{HTML}}', strHTML);

        GS.openDialog(templateElement);
    };
});

// ##################################################################
// ################ MULTIPLE ONBEFOREUNLOAD HANDLERS ################
// ##################################################################


window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('GS.addUnloadEvent', 'GS.addUnloadEvent', 'GS.addUnloadEvent(function () {' +
                                                                    '    $0' +
                                                                    '});');
});

(function () {
    'use strict';
    var arrFunctions = [],
        unloadFunction = function () {
            var i, len, ret, current;

            for (i = 0, len = arrFunctions.length; i < len; i += 1) {
                current = arrFunctions[i]();

                if (current && !ret) {
                    ret = current;
                }
            }

            if (ret) {
                return ret;
            }
        };

    window.addEventListener('load', function () {
        if (window.onbeforeunload && window.onbeforeunload !== unloadFunction) {
            console.error('Please use the GS.addUnloadEvent function to run code onbeforeunload.');
        }
    });

    GS.addBeforeUnloadEvent = function (functionToCall) {
        if (typeof functionToCall !== 'function') {
            throw new TypeError('GS.addUnloadEvent takes one argument, and it must be a function.');
        }

        if (!window.onbeforeunload) {
            window.onbeforeunload = unloadFunction;

        } else if (window.onbeforeunload !== unloadFunction) {
            console.error('Please use just the GS.addBeforeUnloadEvent function to run code onbeforeunload.');
            window.onbeforeunload = unloadFunction;
        }

        arrFunctions.push(functionToCall);
    };
})();





/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(h,r){var k={},l=k.lib={},n=function(){},f=l.Base={extend:function(a){n.prototype=this;var b=new n;a&&b.mixIn(a);b.hasOwnProperty("init")||(b.init=function(){b.$super.init.apply(this,arguments)});b.init.prototype=b;b.$super=this;return b},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var b in a)a.hasOwnProperty(b)&&(this[b]=a[b]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
j=l.WordArray=f.extend({init:function(a,b){a=this.words=a||[];this.sigBytes=b!=r?b:4*a.length},toString:function(a){return(a||s).stringify(this)},concat:function(a){var b=this.words,d=a.words,c=this.sigBytes;a=a.sigBytes;this.clamp();if(c%4)for(var e=0;e<a;e++)b[c+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((c+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)b[c+e>>>2]=d[e>>>2];else b.push.apply(b,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,b=this.sigBytes;a[b>>>2]&=4294967295<<
32-8*(b%4);a.length=h.ceil(b/4)},clone:function(){var a=f.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var b=[],d=0;d<a;d+=4)b.push(4294967296*h.random()|0);return new j.init(b,a)}}),m=k.enc={},s=m.Hex={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++){var e=b[c>>>2]>>>24-8*(c%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join("")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c+=2)d[c>>>3]|=parseInt(a.substr(c,
2),16)<<24-4*(c%8);return new j.init(d,b/2)}},p=m.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++)d.push(String.fromCharCode(b[c>>>2]>>>24-8*(c%4)&255));return d.join("")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c++)d[c>>>2]|=(a.charCodeAt(c)&255)<<24-8*(c%4);return new j.init(d,b)}},t=m.Utf8={stringify:function(a){try{return decodeURIComponent(escape(p.stringify(a)))}catch(b){throw Error("Malformed UTF-8 data");}},parse:function(a){return p.parse(unescape(encodeURIComponent(a)))}},
q=l.BufferedBlockAlgorithm=f.extend({reset:function(){this._data=new j.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=t.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var b=this._data,d=b.words,c=b.sigBytes,e=this.blockSize,f=c/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;c=h.min(4*a,c);if(a){for(var g=0;g<a;g+=e)this._doProcessBlock(d,g);g=d.splice(0,a);b.sigBytes-=c}return new j.init(g,c)},clone:function(){var a=f.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});l.Hasher=q.extend({cfg:f.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){q.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,d){return(new a.init(d)).finalize(b)}},_createHmacHelper:function(a){return function(b,d){return(new u.HMAC.init(a,
d)).finalize(b)}}});var u=k.algo={};return k}(Math);
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(E){function h(a,f,g,j,p,h,k){a=a+(f&g|~f&j)+p+k;return(a<<h|a>>>32-h)+f}function k(a,f,g,j,p,h,k){a=a+(f&j|g&~j)+p+k;return(a<<h|a>>>32-h)+f}function l(a,f,g,j,h,k,l){a=a+(f^g^j)+h+l;return(a<<k|a>>>32-k)+f}function n(a,f,g,j,h,k,l){a=a+(g^(f|~j))+h+l;return(a<<k|a>>>32-k)+f}for(var r=CryptoJS,q=r.lib,F=q.WordArray,s=q.Hasher,q=r.algo,a=[],t=0;64>t;t++)a[t]=4294967296*E.abs(E.sin(t+1))|0;q=q.MD5=s.extend({_doReset:function(){this._hash=new F.init([1732584193,4023233417,2562383102,271733878])},
_doProcessBlock:function(m,f){for(var g=0;16>g;g++){var j=f+g,p=m[j];m[j]=(p<<8|p>>>24)&16711935|(p<<24|p>>>8)&4278255360}var g=this._hash.words,j=m[f+0],p=m[f+1],q=m[f+2],r=m[f+3],s=m[f+4],t=m[f+5],u=m[f+6],v=m[f+7],w=m[f+8],x=m[f+9],y=m[f+10],z=m[f+11],A=m[f+12],B=m[f+13],C=m[f+14],D=m[f+15],b=g[0],c=g[1],d=g[2],e=g[3],b=h(b,c,d,e,j,7,a[0]),e=h(e,b,c,d,p,12,a[1]),d=h(d,e,b,c,q,17,a[2]),c=h(c,d,e,b,r,22,a[3]),b=h(b,c,d,e,s,7,a[4]),e=h(e,b,c,d,t,12,a[5]),d=h(d,e,b,c,u,17,a[6]),c=h(c,d,e,b,v,22,a[7]),
b=h(b,c,d,e,w,7,a[8]),e=h(e,b,c,d,x,12,a[9]),d=h(d,e,b,c,y,17,a[10]),c=h(c,d,e,b,z,22,a[11]),b=h(b,c,d,e,A,7,a[12]),e=h(e,b,c,d,B,12,a[13]),d=h(d,e,b,c,C,17,a[14]),c=h(c,d,e,b,D,22,a[15]),b=k(b,c,d,e,p,5,a[16]),e=k(e,b,c,d,u,9,a[17]),d=k(d,e,b,c,z,14,a[18]),c=k(c,d,e,b,j,20,a[19]),b=k(b,c,d,e,t,5,a[20]),e=k(e,b,c,d,y,9,a[21]),d=k(d,e,b,c,D,14,a[22]),c=k(c,d,e,b,s,20,a[23]),b=k(b,c,d,e,x,5,a[24]),e=k(e,b,c,d,C,9,a[25]),d=k(d,e,b,c,r,14,a[26]),c=k(c,d,e,b,w,20,a[27]),b=k(b,c,d,e,B,5,a[28]),e=k(e,b,
c,d,q,9,a[29]),d=k(d,e,b,c,v,14,a[30]),c=k(c,d,e,b,A,20,a[31]),b=l(b,c,d,e,t,4,a[32]),e=l(e,b,c,d,w,11,a[33]),d=l(d,e,b,c,z,16,a[34]),c=l(c,d,e,b,C,23,a[35]),b=l(b,c,d,e,p,4,a[36]),e=l(e,b,c,d,s,11,a[37]),d=l(d,e,b,c,v,16,a[38]),c=l(c,d,e,b,y,23,a[39]),b=l(b,c,d,e,B,4,a[40]),e=l(e,b,c,d,j,11,a[41]),d=l(d,e,b,c,r,16,a[42]),c=l(c,d,e,b,u,23,a[43]),b=l(b,c,d,e,x,4,a[44]),e=l(e,b,c,d,A,11,a[45]),d=l(d,e,b,c,D,16,a[46]),c=l(c,d,e,b,q,23,a[47]),b=n(b,c,d,e,j,6,a[48]),e=n(e,b,c,d,v,10,a[49]),d=n(d,e,b,c,
C,15,a[50]),c=n(c,d,e,b,t,21,a[51]),b=n(b,c,d,e,A,6,a[52]),e=n(e,b,c,d,r,10,a[53]),d=n(d,e,b,c,y,15,a[54]),c=n(c,d,e,b,p,21,a[55]),b=n(b,c,d,e,w,6,a[56]),e=n(e,b,c,d,D,10,a[57]),d=n(d,e,b,c,u,15,a[58]),c=n(c,d,e,b,B,21,a[59]),b=n(b,c,d,e,s,6,a[60]),e=n(e,b,c,d,z,10,a[61]),d=n(d,e,b,c,q,15,a[62]),c=n(c,d,e,b,x,21,a[63]);g[0]=g[0]+b|0;g[1]=g[1]+c|0;g[2]=g[2]+d|0;g[3]=g[3]+e|0},_doFinalize:function(){var a=this._data,f=a.words,g=8*this._nDataBytes,j=8*a.sigBytes;f[j>>>5]|=128<<24-j%32;var h=E.floor(g/
4294967296);f[(j+64>>>9<<4)+15]=(h<<8|h>>>24)&16711935|(h<<24|h>>>8)&4278255360;f[(j+64>>>9<<4)+14]=(g<<8|g>>>24)&16711935|(g<<24|g>>>8)&4278255360;a.sigBytes=4*(f.length+1);this._process();a=this._hash;f=a.words;for(g=0;4>g;g++)j=f[g],f[g]=(j<<8|j>>>24)&16711935|(j<<24|j>>>8)&4278255360;return a},clone:function(){var a=s.clone.call(this);a._hash=this._hash.clone();return a}});r.MD5=s._createHelper(q);r.HmacMD5=s._createHmacHelper(q)})(Math);
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function(){if("function"==typeof ArrayBuffer){var b=CryptoJS.lib.WordArray,e=b.init;(b.init=function(a){a instanceof ArrayBuffer&&(a=new Uint8Array(a));if(a instanceof Int8Array||a instanceof Uint8ClampedArray||a instanceof Int16Array||a instanceof Uint16Array||a instanceof Int32Array||a instanceof Uint32Array||a instanceof Float32Array||a instanceof Float64Array)a=new Uint8Array(a.buffer,a.byteOffset,a.byteLength);if(a instanceof Uint8Array){for(var b=a.byteLength,d=[],c=0;c<b;c++)d[c>>>2]|=a[c]<<
24-8*(c%4);e.call(this,d,b)}else e.apply(this,arguments)}).prototype=b}})();

// if db is SQL Server: utf16 else utf8
(function () {
    "use strict";

    // get a cookie from the browser
    function getCookie(c_name) {
        var c_value = document.cookie, c_end,
            c_start = c_value.indexOf(" " + c_name + "=");

        if (c_start === -1) {
            c_start = c_value.indexOf(c_name + "=");
        }
        if (c_start === -1) {
            c_value = null;
        } else {
            c_start = c_value.indexOf("=", c_start) + 1;
            c_end = c_value.indexOf(";", c_start);
            if (c_end === -1) {
                c_end = c_value.length;
            }
            c_value = decodeURIComponent(c_value.substring(c_start, c_end));
        }
        return c_value;
    };

    if ((getCookie('DB') || 'PG').toUpperCase() === 'PG') {
        GS.utfSafeMD5 = CryptoJS.MD5;
    } else { //ss
        GS.utfSafeMD5 = function (str) {
            "use strict";
            var buf = new ArrayBuffer(str.length * 2);
            var bufView = new Uint16Array(buf);
            var i;
            var strLen;

            for (i = 0, strLen = str.length; i < strLen; i += 1) {
                bufView[i] = str.charCodeAt(i);
            }

            return CryptoJS.MD5(CryptoJS.lib.WordArray.create(bufView));
        }
    }
}());
//global registerDesignSnippet

// snippets are in the textmate format more info:
//      http://blog.macromates.com/2005/the-power-of-snippets/

window.addEventListener('design-register-element', function () {
    // uncategorized snippets
    registerDesignSnippet('Lorem Ipsum', 'Lorem Ipsum', 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.');

    registerDesignSnippet('Document Start', 'Document Start',
            '<!DOCTYPE html>\n' +
            '<html>\n' +
            '    <head>\n' +
            '        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />\n' +
            '        <meta name="apple-mobile-web-app-capable" content="yes" />\n' +
            '        <meta name="apple-mobile-web-app-status-bar-style" content="black" />\n' +
            '        <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1.0, maximum-scale=1.0, minimal-ui" />\n' +
            '        <!-- Make this page use standard caching procedure when used as an iframe -->\n' +
            '        <meta http-equiv="Cache-control" content="no-store, must-revalidate" />\n' +
            '        \n' +
            '        <title>${1:New Page}</title>\n' +
            '        \n' +
            '        <script src="/js/greyspots.js" type="text/javascript"></script>\n' +
            '        <link href="/css/greyspots.css" type="text/css" rel="stylesheet" />\n' +
            '    </head>\n' +
            '    <body>\n' +
            '        $0\n' +
            '    </body>\n' +
            '</html>');

    registerDesignSnippet('Centered H1', 'Centered H1', '<center><h1>$0</h1></center>');
    registerDesignSnippet('Centered H2', 'Centered H2', '<center><h2>$0</h2></center>');
    registerDesignSnippet('Centered H3', 'Centered H3', '<center><h3>$0</h3></center>');
    registerDesignSnippet('Centered H4', 'Centered H4', '<center><h4>$0</h4></center>');
    registerDesignSnippet('Centered H5', 'Centered H5', '<center><h5>$0</h5></center>');
    registerDesignSnippet('Centered H6', 'Centered H6', '<center><h6>$0</h6></center>');

    // javascript snippets
    registerDesignSnippet('Window Load', 'window.addEventListener',
            'window.addEventListener(\'load\', function () {\n' +
            '    $0\n' +
            '});');

    registerDesignSnippet('Multiline String', 'Multiline String',
            'ml(function () {/*\n' +
            '    ${0}\n' +
            '})');

    registerDesignSnippet('ml()', 'ml()',
            'ml(function () {/*\n' +
            '    ${0}\n' +
            '*/})');

    // HTML snippets
    registerDesignSnippet('<style>', '<style>', 'style>\n' +
                                                '    $0\n' +
                                                '</style>');
    registerDesignSnippet('<script>', '<script>', 'script>\n' +
                                                  '    $0\n' +
                                                  '</script>');
    registerDesignSnippet('<link>', '<link>', 'link href="${1}" type="text/css" rel="stylesheet" />');


    // CSS snippets
    registerDesignSnippet('Curved Borders', 'Curved Borders', '-webkit-border-radius: ${1:50%};\n' +
                                                             '-moz-border-radius: ${1:50%};\n' +
                                                             '-ms-border-radius: ${1:50%};\n' +
                                                             '-o-border-radius: ${1:50%};\n' +
                                                             'border-radius: ${1:50%};');
    registerDesignSnippet('border-radius', 'border-radius', '-webkit-border-radius: ${1:50%};\n' +
                                                             '-moz-border-radius: ${1:50%};\n' +
                                                             '-ms-border-radius: ${1:50%};\n' +
                                                             '-o-border-radius: ${1:50%};\n' +
                                                             'border-radius: ${1:50%};');
    registerDesignSnippet('box-sizing', 'box-sizing', '-webkit-box-sizing: ${1:border-box};\n' +
                                                      '-moz-box-sizing: ${1:border-box};\n' +
                                                      '-ms-box-sizing: ${1:border-box};\n' +
                                                      '-o-box-sizing: ${1:border-box};\n' +
                                                      'box-sizing: ${1:border-box};');
    registerDesignSnippet('transform', 'transform', '-webkit-transform: ${1:rotate(42deg)};\n' +
                                                    '-moz-transform: ${1:rotate(42deg)};\n' +
                                                    '-ms-transform: ${1:rotate(42deg)};\n' +
                                                    '-o-transform: ${1:rotate(42deg)};\n' +
                                                    'transform: ${1:rotate(42deg)};');

    registerDesignSnippet('Desktop Media Query', 'Desktop Media Query', '@media only screen and (max-width: 5000px) {\n' +
                                                                        '    $0\n' +
                                                                        '}');
    registerDesignSnippet('Tablet Media Query', 'Tablet Media Query', '@media only screen and (max-width: 768px) {\n' +
                                                                      '    $0\n' +
                                                                      '}');
    registerDesignSnippet('Phone Media Query', 'Phone Media Query', '@media only screen and (max-width: 321px) {\n' +
                                                                    '    $0\n' +
                                                                    '}');
});//global registerDesignSnippet, window, GS, ml, encodeHTML
//jslint white:true multivar:true

window.addEventListener('design-register-element', function () {
    var strNormalCallbackContent = '    if (!error) {\n' +
                                   '        $0\n' +
                                   '    } else {\n' +
                                   '        GS.ajaxErrorDialog(data);\n' +
                                   '    }\n';

    registerDesignSnippet('JSON Ajax', 'JSON Ajax', 'GS.ajaxJSON(\'/env/${1:test.action_ship}\', \'${2:action=ship&id=}\', function (data, error) {\n' +
                                                        strNormalCallbackContent +
                                                    '});');
    registerDesignSnippet('GS.ajaxJSON', 'GS.ajaxJSON', 'GS.ajaxJSON(\'/env/${1:test.action_ship}\', \'${2:action=ship&id=}\', function (data, error) {\n' +
                                                            strNormalCallbackContent +
                                                        '});');


    registerDesignSnippet('TEXT Ajax', 'TEXT Ajax', 'GS.ajaxText(\'/env/${1:test.action_description}\', \'${2:action=get&id=}\', function (data, error) {\n' +
                                                        strNormalCallbackContent +
                                                    '});');
    registerDesignSnippet('GS.ajaxText', 'GS.ajaxText', 'GS.ajaxText(\'/env/${1:test.action_description}\', \'${2:action=get&id=}\', function (data, error) {\n' +
                                                            strNormalCallbackContent +
                                                        '});');

    registerDesignSnippet('PG FUNCTION AJAX', 'PG FUNCTION AJAX', 'GS.ajaxJSON(\'/env/${1:test.action_ship}\', \'${2:action=ship&id=}\', function (data, error) {\n' +
                                                  strNormalCallbackContent +
                                              '});');

    registerDesignSnippet('GS.ajaxErrorDialog', 'GS.ajaxErrorDialog', 'GS.ajaxErrorDialog(data,\n' +
              '                   function () {\n' +
              '                       // Try Again Button Callback\n' +
              '                       // delete this function if you dont want a try again button\n' +
              '                   },\n' +
              '                   function () {\n' +
              '                       // Cance Button Callback\n' +
              '                       // if you dont need to do anything when the cancel button is clicked: delete this function\n' +
              '                   });');

    registerDesignSnippet('GS.dataFetch', 'GS.dataFetch',
            'function getData(bolClearPrevious) {\n' +
            '    var data, strLink, dataResultHandler, dataEventFunction;\n' +
            '    \n' +
            '    // create function that will use the data\n' +
            '    dataResultHandler = function (data, error) {\n' +
            '        \n' +
            '    };\n' +
            '    \n' +
            '    // save data from request or\n' +
            '    //     start ajax if it hasn\'t already gotten the data yet or\n' +
            '    //     start new ajax if bolClearPrevious is true\n' +
            '    data = GS.dataFetch(strLink, bolClearPrevious);\n' +
            '    \n' +
            '    // if this request already has been completed\n' +
            '    if (data) {\n' +
            '        // handle result\n' +
            '        dataResultHandler(data.response, data.error);\n' +
            '    } else {\n' +
            '        dataEventFunction = function (event) {\n' +
            '            // unbind data event function\n' +
            '            document.removeEventListener(\'dataready_\' + encodeURIComponent(strLink), dataEventFunction);\n' +
            '            \n' +
            '            // handle result\n' +
            '            dataResultHandler(event.detail.response, event.detail.error);\n' +
            '        };\n' +
            '        \n' +
            '        // bind data event function\n' +
            '        document.addEventListener(\'dataready_\' + encodeURIComponent(strLink), dataEventFunction);\n' +
            '    }\n' +
            '}');

});

(function () {
    'use strict';
    function ajaxCheckJSONResponseForError(request) {
        if (request.responseJSON) {
            if (request.responseJSON.stat === false) {
                return true;
            }
        } else {
            return true;
        }

        return false;
    }

    function ajaxNormalizeError (request) {
        var response = request.response, jsnTemp, jsnRet = {
            'error_title': '',
            'error_hint': '',
            'error_text': '',
            'error_file': '',
            'error_context': '',
            'original_response': response
        };

        // get error title and error hint
        if (request.bolFrontEndTimeout === true) {
            jsnRet.error_text = 'Front-end Timeout Reached';
            jsnRet.error_title = 'Front-end Timeout Reached';
            jsnRet.error_hint = 'This request took too long. Please report this to a system administrator.';

        } else if (response.status === 403) {
            jsnRet.error_title = '403 Link Is Forbidden';
            jsnRet.error_hint = 'You have no permission to use this link. If you need this link contact a system administrator and request permission for this link.';

        } else if (response.status === 404) {
            jsnRet.error_title = '404 Link Could Not Be Found';
            jsnRet.error_hint = 'This link does not exist. Please report this to a system administrator.';

        } else if (response.status === 408) {
            jsnRet.error_title = '408 Request Took Too Long';
            jsnRet.error_hint = 'This link is broken. Please report this to a system administrator.';

        } else if (response.status === 500) {
            jsnRet.error_title = '500 Internal Server Error';
            jsnRet.error_hint = 'This call to the server failed. Please report this to a system administrator.';

        } else if (response.status === 502) {
            jsnRet.error_title = '502 Bad Gateway';
            jsnRet.error_hint = 'This link is broken. Please report this to a system administrator.';

        } else if (response.status === 504) {
            jsnRet.error_title = '504 Gateway Timeout';
            jsnRet.error_hint = 'This link is broken. Please report this to a system administrator.';
        }

        // get error text
        try {
            jsnTemp = JSON.parse(response.responseText || response).dat;

            jsnRet.error_text = jsnTemp.error;
            jsnRet.error_file = jsnTemp.filename;
            jsnRet.error_context = jsnTemp.context;

            if (!jsnRet.error_text) {
                jsnRet.error_text = JSON.parse(response.responseText || response).dat;
            }
        } catch (err) {
            if (response) {
                jsnRet.error_text = response.responseText || JSON.stringify(response);
            } else {
                jsnRet.error_text = jsnRet.error_text || response;
            }
        }

        jsnRet.error_file = jsnRet.error_file || '';

        return jsnRet;
    }

    GS.ajaxJSON = function (strLink, strParams, callback, intTimeout) {
        var request = new XMLHttpRequest();

        callback = callback || function () {};

        request.onreadystatechange = function() {
            var normalizedError;

            // if expired cookie: go to login page
            if (request.readyState === 4) {
                if (request.status === 440) {
                    window.location = '/index.html?error=Connection%20timed%20out&redirect=' + encodeURIComponent(window.location.pathname);
                } else {
                    try {
                        request.responseJSON = JSON.parse(request.responseText || request.response);
                    } catch (e) {
                        //throw e;
                    }

                    if (!ajaxCheckJSONResponseForError(request)) {
                        callback(request.responseJSON);

                    } else {
                        normalizedError = ajaxNormalizeError(request);

                        // if session error: have the user log back in and refresh
                        if ((normalizedError.error_text.indexOf('Session expired') === 0 ||
                            normalizedError.error_text.indexOf('No Cookie') !== -1 ||
                            normalizedError.error_text.indexOf('requires you to login') !== -1) &&
                            strLink.indexOf('action_info') === -1) {
                            GS.normalUserLogin(function () {
                                window.location.reload();
                            }, '', request.responseJSON.dat.default_subdomain);

                        // else: callback with normalized error
                        } else {
                            callback(normalizedError, 'error');
                        }
                    }
                }
            }
        };

        request.open('POST', strLink + '?anticache=' + ((new Date()).getMilliseconds() + Math.floor(Math.random() * 1e9)), true);
        request.setRequestHeader('Content-type','application/x-www-form-urlencoded; charset=UTF-8');
        request.send(strParams);

        // if intTimeout has been set: start a timer to abort
        if (typeof intTimeout === 'number') {
            if (request && request.readyState !== 4) {
                setTimeout(function() {
                    request.bolFrontEndTimeout = true;
                    request.abort();
                }, intTimeout);
            }
        }

        return request;
    };

    GS.ajaxText = function (strLink, strParams, callback, intTimeout) {
        var request = new XMLHttpRequest();

        callback = callback || function () {};

        request.onreadystatechange = function() {
            var normalizedError;

            if (request.readyState === 4) {
                if (request.status === 200) {
                    callback(request.responseText);

                } else if (request.status === 440) {
                    window.location = '/index.html?error=Connection%20timed%20out&redirect=' + encodeURIComponent(window.location.pathname);

                } else {
                    normalizedError = ajaxNormalizeError(request);

                    // if session error: have the user log back in and refresh
                    if ((normalizedError.error_text.indexOf('Session expired') === 0 ||
                        normalizedError.error_text.indexOf('No Cookie') !== -1 ||
                        normalizedError.error_text.indexOf('requires you to login') !== -1) &&
                        strLink.indexOf('action_info') === -1) {
                        GS.normalUserLogin(function () {
                            window.location.reload();
                        }); //, '', JSON.parse(request.responseText || request.response).dat.default_subdomain

                    // else: callback with normalized error
                    } else {
                        callback(normalizedError, 'error');
                    }
                }
            }
        };

        request.open('POST', strLink + '?anticache=' + ((new Date()).getMilliseconds() + Math.floor(Math.random() * 1e9)), true);
        request.setRequestHeader('Content-type','application/x-www-form-urlencoded; charset=UTF-8');
        request.send(strParams);

        // if intTimeout has been set: start a timer to abort
        if (typeof intTimeout === 'number') {
            if (request && request.readyState !== 4) {
                setTimeout(function() {
                    request.bolFrontEndTimeout = true;
                    request.abort();
                }, intTimeout);
            }
        }

        return request;
    };
}());

(function () {
    "use strict";

    function cleanErrorValue(strValue) {
        strValue = strValue || '';

        if (strValue.indexOf('DB_exec failed:') !== -1) {
            strValue = strValue.replace(/[.\s\S]*DB_exec\ failed:/mi, '');
        }

        if (strValue.indexOf('Query failed:') !== -1) {
            strValue = strValue.replace(/[.\s\S]*Query\ failed:/mi, '');
        }

        if (strValue.indexOf('FATAL') !== -1) {
            strValue = strValue.replace(/[.\s\S]*FATAL/mi, '');
        }

        strValue = strValue
                        .replace(/\\?\\n/gi, '\n')
                        .replace(/\\?\\t/gi, '\t')
                        .replace(/\[.*\]/gi, '')
                        .replace(/\([0-9]*\)/gi, '');

        return GS.trim(strValue.trim(), '"');
    }

    function errorJSONToHTML(errorJSON) {
        var errorHTML = '<pre style="word-break: break-all; white-space: pre-wrap;">' +
                    'There was an error:' +
                    (errorJSON.error_text //TODO: maybe make this red -Joseph 09/14/16
                        ? '<br /><br />' + encodeHTML(GS.decodeFromTabDelimited(errorJSON.error_text))
                        : '') +
                    (errorJSON.error_file
                        ? '<br /><br />The error was on file: ' + encodeHTML(GS.decodeFromTabDelimited(errorJSON.error_file))
                        : '') +
                    (errorJSON.error_hint
                        ? '<br /><br />' + encodeHTML(GS.decodeFromTabDelimited(errorJSON.error_hint))
                        : '') +
                    (errorJSON.error_context
                        ? '<br /><br />' + encodeHTML(errorJSON.error_context)
                        : '') +
                    (errorJSON.error_addin
                        ? '<br /><br />' + encodeHTML(errorJSON.error_addin)
                        : '') +
                '</pre>';
        return errorHTML;
    }

    GS.ajaxErrorDialog = function (jsnError, tryAgainCallback, cancelCallback) {
        'use strict';
        var templateElement = document.createElement('template'), strHTML;

        var jsnErrorCopy = {};
        jsnErrorCopy.error_text    = cleanErrorValue(jsnError.error_text);
        jsnErrorCopy.error_file    = cleanErrorValue(jsnError.error_file);
        jsnErrorCopy.error_hint    = cleanErrorValue(jsnError.error_hint);
        jsnErrorCopy.error_context = cleanErrorValue(jsnError.error_context);
        jsnErrorCopy.error_addin   = cleanErrorValue(jsnError.error_addin);

        templateElement.setAttribute('data-theme', 'error');
        strHTML = ml(function () {/*
            <gs-page>
                <gs-header><center><h3>There was an error!</h3></center></gs-header>
                <gs-body padded>
                    {{HTML}}
                    <gs-button class="error-button-show-full-text">Show Full Error Text</gs-button>
                </gs-body>
                <gs-footer>{{BUTTONS}}</gs-footer>
            </gs-page>
        */}).replace('{{HTML}}', errorJSONToHTML(jsnErrorCopy));


        var openFunction = function () {
            xtag.query(this, '.error-button-show-full-text')[0].addEventListener('click', function () {
                var templateElement = document.createElement('template');

                templateElement.innerHTML = ml(function () {/*
                    <gs-page>
                        <gs-header><center><h3>Full Error Text</h3></center></gs-header>
                        <gs-body padded>
                            {{HTML}}
                        </gs-body>
                        <gs-footer><gs-button dialogclose>Done</gs-button></gs-footer>
                    </gs-page>
                */}).replace('{{HTML}}', errorJSONToHTML(jsnError));

                GS.openDialog(templateElement);
            });
        };


        if (typeof tryAgainCallback === 'function') {
            templateElement.innerHTML = strHTML.replace('{{BUTTONS}}',
                        '<gs-grid>' +
                        '   <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>' +
                        '   <gs-block><gs-button dialogclose listen-for-return>Try Again</gs-button></gs-block>' +
                        '</gs-grid>');
            GS.openDialog(templateElement, openFunction, function (event, strAnswer) {
                if (strAnswer === 'Try Again') {
                    tryAgainCallback(strAnswer);
                } else {
                    if (typeof cancelCallback === 'function') {
                        cancelCallback(strAnswer);
                    }
                }
            });
        } else {
            templateElement.innerHTML = strHTML.replace('{{BUTTONS}}', '<gs-button dialogclose listen-for-return>Ok</gs-button>');
            GS.openDialog(templateElement, openFunction);
        }
    };

}());

/*

var strLink = '/env/action_select?view=wtkv2.ttime&where=user_name%20%3D%20\'michael%40tocci.org\'&offset=0&limit=25&order_by=id%20DESC&header=true';

document.addEventListener('dataready_' + encodeURIComponent(strLink), function (event) {
    console.log(event);
});f

dataFetch(strLink, false);

*/

if (GS.dataLedger === undefined) {
    GS.dataLedger = {};
}

GS.dataFetch = function (strLink, bolClearPrevious) {
    'use strict';
    var arrLinkParts = strLink.split('?'), strId = encodeURIComponent(strLink);

    // if something wants to fetch data where the id does not already exist then do an ajax call
    if (GS.dataLedger[strId] === undefined || bolClearPrevious === true) {

        GS.dataLedger[strId] = {'status': 'waiting', 'response': ''};

        GS.ajaxJSON(arrLinkParts[0], arrLinkParts[1] || '', function (data, error) {
            var event; // The custom event that will be created

            if (document.createEvent) {
                event = document.createEvent('HTMLEvents');
                event.initEvent('dataready_' + strId, true, true);
                event.eventName = 'dataready_' + strId;
            } else {
                event = document.createEventObject();
                event.eventType = 'dataready_' + strId;
                event.eventName = 'dataready_' + strId;
            }

            if (!error) {
                GS.dataLedger[strId].response = (data.dat !== undefined ? data.dat : data);
                GS.dataLedger[strId].status = 'finished';

                event.detail = {'response': GS.dataLedger[strId].response};

            } else {
                GS.dataLedger[strId].data = data;
                GS.dataLedger[strId].status = 'error';
                GS.dataLedger[strId].error = 'error';

                event.detail = {'response': data, 'error': 'error'};
            }

            if (document.createEvent) {
                document.dispatchEvent(event);
            } else {
                document.fireEvent('on' + event.eventType, event);
            }
        });

        return '';
    }

    if (GS.dataLedger[strId].status === 'finished' || GS.dataLedger[strId].status === 'error') {
        return GS.dataLedger[strId];
    }

    return '';
};
window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('GS.findParentTag', 'GS.findParentTag', 'GS.findParentTag(${1:element}, \'${0:tag-to-find}\');');

    registerDesignSnippet('GS.findParentElement', 'GS.findParentElement',
                                                    'GS.findParentElement(${1:element}, ${0:\'selector, element or function\'});');

    registerDesignSnippet('GS.insertElementAfter', 'GS.insertElementAfter',
                                                    'GS.insertElementAfter(${1:elementToInsert}, \'${0:elementToInsertAfter}\');');

    registerDesignSnippet('GS.getElementOffset', 'GS.getElementOffset', 'GS.getElementOffset(${0:element});');

    registerDesignSnippet('GS.animateStyle', 'GS.animateStyle',
                                            'GS.animateStyle(${1:elementToAnimate}, ' +
                                                            '${2:CSSPropertyToAnimate}, ' +
                                                            '${3:startValue}, ' +
                                                            '${4:endValue}, ' +
                                                            '${5:callbackAfterAnimation}, ' +
                                                            '${6:durationInMilliseconds}, ' +
                                                            '${0:numberOfFrames});');

    registerDesignSnippet('GS.stringToElement', 'GS.stringToElement', 'GS.stringToElement(\'${0:<div>your HTML here</div>}\');');

    registerDesignSnippet('GS.cloneElement', 'GS.cloneElement', 'GS.cloneElement(${0:element});');

    registerDesignSnippet('GS.isElementFocusable', 'GS.isElementFocusable', 'GS.isElementFocusable(${0:element});');

    registerDesignSnippet('GS.scrollParent', 'GS.scrollParent', 'GS.scrollParent(${0:element});');

    registerDesignSnippet('GS.scrollIntoView', 'GS.scrollIntoView', 'GS.scrollIntoView(${0:element});');

    registerDesignSnippet('GS.getInputSelection', 'GS.getInputSelection', 'GS.getInputSelection(${0:inputOrTextareaElement});');

    registerDesignSnippet('GS.setInputSelection', 'GS.setInputSelection',
                                    'GS.setInputSelection(${1:inputOrTextareaElement}, ${2:startAtNumber}, ${0:endAtNumber});');

    registerDesignSnippet('GS.getElementPositionData', 'GS.getElementPositionData', 'GS.getElementPositionData(${0:element});');
});

// #################################################################
// #################### DOM TRAVERSAL FUNCTIONS ####################
// #################################################################

// loop through parents until tag is found
GS.findParentTag = function (element, strTagName) {
    'use strict';
    var currentElement = element.parentNode;

    strTagName = strTagName.toUpperCase();

    while (currentElement && currentElement.nodeName !== strTagName && currentElement.nodeName !== 'HTML') {
        currentElement = currentElement.parentNode;
    }

    if (!currentElement || currentElement.nodeName !== strTagName) {
        return undefined;
    }

    return currentElement;
};

// loop through parents until checkParameter is satisfied or we run into HTML
GS.findParentElement = function (element, checkParameter) {
    'use strict';
    var currentElement = element;

    // if checkParameter is a function: use it to check the element
    if (typeof checkParameter === 'function') {
        while (currentElement && !checkParameter(currentElement) && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }

    // else if checkParameter is a string: use checkParameter as a selector string and use xtag.matchSelector
    } else if (typeof checkParameter === 'string') {
        while (currentElement && !xtag.matchSelector(currentElement, checkParameter) && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }

    // else: assume checkParameter is an element and use ===
    } else {
        while (currentElement && currentElement !== checkParameter && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }
    }

    if (!currentElement) {
        return undefined;
    }

    return currentElement;
};


// ################################################################
// #################### HTML ELEMENT FUNCTIONS ####################
// ################################################################

// insert element after another element
GS.insertElementAfter = function (elementToInsert, target) {
    if (target.nextElementSibling) {
        target.parentNode.insertBefore(elementToInsert, target.nextElementSibling);
    } else {
        target.parentNode.appendChild(elementToInsert);
    }
};

// get element's position on the screen
GS.getElementOffset = function (element) {
    'use strict';
    var intX = 0, intY = 0, ret;

    if (element.getBoundingClientRect) {
        ret = element.getBoundingClientRect();

    } else {
        while (element && element.nodeName !== 'HTML') {
            intX += element.offsetLeft - element.scrollLeft;// + element.clientLeft;
            intY += element.offsetTop - element.scrollTop;// + element.clientTop;

            //console.log(element.offsetTop, element.scrollTop, element);

            element = element.parentNode; //element.offsetParent
        }

        ret = {
            left: intX,
            top: intY
        };
    }

    return ret;
};

//
GS.animateStyle = function (element, strStyleProperty, strStart, strEnd, callback, intDuration, intFrames) {
    var intStart         = parseInt(strStart, 10),
        intEnd           = parseInt(strEnd, 10),
        strStartUnit     = strStart.replace(/[0-9\.-]/gi, '').toLowerCase(),
        //strEndUnit       = strEnd.replace(/[0-9\.-]/gi, '').toLowerCase(),
        intFrameDuration = intDuration / intFrames,
        i, timeoutFunction, intCurrent, intJump;

    //if (strStartUnit !== 'em' && strStartUnit !== 'px' && strStartUnit !== '') {
    //    throw 'animateStyle error: strStart has an invalid unit, use px or em or nothing';
    //
    //} else if (strEndUnit !== 'em' && strEndUnit !== 'px' && strEndUnit !== '') {
    //    throw 'animateStyle error: strEnd has an invalid unit, use px or em or nothing';
    //
    //} else {
    intCurrent = intStart;
    intJump = (intEnd - intStart) / intFrames;
    i = 1;

    element.style[strStyleProperty] = strStart;

    timeoutFunction = function () {
        setTimeout(function () {
            intCurrent += intJump;
            //element.style[strStyleProperty] = intCurrent + strStartUnit;
            //console.log(intCurrent, i, intFrames, element, element.style[strStyleProperty], intStart, intCurrent, strStartUnit);

            if (i < intFrames) {
                element.style[strStyleProperty] = intCurrent + strStartUnit;
                i += 1;
                timeoutFunction();
            } else {
                element.style[strStyleProperty] = strEnd;
                callback();
            }
        }, intFrameDuration);
    };

    timeoutFunction();
    //}
};

//
GS.stringToElement = function (strHTML, optionalTargetDocument) {
    var strFirstTagName, parentElement, indexInElement, parsedElement, targetDocument;

    if (optionalTargetDocument) {
        targetDocument = optionalTargetDocument;
    } else {
        targetDocument = document;
    }

    //console.log(strFirstTagName);

    strFirstTagName = strHTML.substring(strHTML.indexOf('<') + 1, strHTML.indexOf('>'));

    //console.log(strFirstTagName);

    if (strFirstTagName.indexOf(' ') > -1) {
        strFirstTagName = strFirstTagName.substring(0, strFirstTagName.indexOf(' '));
    }

    //console.log(strFirstTagName);

    if (strFirstTagName === 'body') {
        parentElement = targetDocument.createElement('html');
        indexInElement = 1;

    } else if (strFirstTagName === 'thead' || strFirstTagName === 'tbody') {
        parentElement = targetDocument.createElement('table');
        indexInElement = 0;

    } else if (strFirstTagName === 'tr') {
        parentElement = targetDocument.createElement('tbody');
        indexInElement = 0;

    } else if (strFirstTagName === 'td' || strFirstTagName === 'th') {
        parentElement = targetDocument.createElement('tr');
        indexInElement = 0;

    } else if (strFirstTagName === 'li') {
        parentElement = targetDocument.createElement('ul');
        indexInElement = 0;
    } else {
        parentElement = targetDocument.createElement('div');
        indexInElement = 0;
    }

    parentElement.innerHTML = strHTML;
    parsedElement = parentElement.children[indexInElement];

    //console.log(strFirstTagName, parsedElement);

    return parsedElement;
};

//
GS.cloneElement = function (element, optionalTargetDocument) {
    // if there is a template element in the element: copy the element without cloneNode because for some reason cloneNode breaks templates on IOS
    if (xtag.query(element, 'template').length > 0 || optionalTargetDocument) {
        return GS.stringToElement(element.outerHTML, optionalTargetDocument);
    }

    // else: just use cloneNode
    return element.cloneNode(true);
};

/*
// change the tag of an element
GS.changeElementTag = function (element, strNewTag, alterCallback) {
    var strHTML = element.outerHTML.trim(), newElement;

    strHTML = '<' + strNewTag + strHTML.substring(strHTML.indexOf(' '), strHTML.lastIndexOf('</')) + '</' + strNewTag + '>';

    //console.log(strHTML);

    newElement = GS.stringToElement(strHTML);

    if (typeof alterCallback === 'function') {
        alterCallback.apply(newElement);
    }

    return newElement;
};*/

// check to see if an element is focusable
GS.isElementFocusable = function (element) {
    return  (
                element.nodeName === 'INPUT' ||
                element.nodeName === 'TEXTAREA' ||
                element.nodeName === 'SELECT' ||
                element.nodeName === 'BUTTON' ||
                element.nodeName === 'IFRAME' ||
                (element.hasAttribute('tabindex') && element.getAttribute('tabindex') !== '-1') ||
                (element.focus &&
                    element.focus.toString().indexOf('[native code]') === -1 &&
                    element.focus.toString() !== document.createElement('div').focus.toString()) ||
                (
                    element.nodeName === 'A' &&
                    element.hasAttribute('href')
                ) ||
                (
                    element.nodeName === 'AREA' &&
                    element.hasAttribute('href')
                )
            ) &&
            !element.hasAttribute('disabled');
};

// see function in 006-utl.js
//// search for a parent with a scrollbar
//GS.scrollParent = function (element) {
//    var i = 0, currentElement = element, bolFoundScrollable = false, strOverflow;
//
//    if (currentElement) {
//        while (currentElement && currentElement.nodeName !== 'HTML' && bolFoundScrollable === false && i < 75) {
//            strOverflow = GS.getStyle(currentElement, 'overflow');
//
//            if (strOverflow === 'scroll' || (strOverflow === 'auto' && currentElement.clientHeight < currentElement.scrollHeight)) {
//                bolFoundScrollable = true;
//            } else {
//                currentElement = currentElement.parentNode;
//                i += 1;
//            }
//        }
//        return bolFoundScrollable ? currentElement : undefined;
//    }
//    return undefined;
//};
// see function in 006-utl.js
// scroll an element to the middle of its scrollparent
// GS.scrollIntoView = function (element) {
//     var scrollingContainer = GS.scrollParent(element), arrSiblings, i, len, intScrollTop;
//     console.log(scrollingContainer);
//     if (scrollingContainer) {
//         //console.log(scrollingContainer);

//         arrSiblings = element.parentNode.children;

//         for (i = 0, intScrollTop = 0, len = arrSiblings.length; i < len; i += 1) {
//             if (arrSiblings[i] === element) {
//                 intScrollTop += arrSiblings[i].offsetHeight / 2;

//                 break;
//             } else {
//                 intScrollTop += arrSiblings[i].offsetHeight;
//             }
//         }

//         intScrollTop = intScrollTop - (scrollingContainer.offsetHeight / 2);

//         //console.log(intScrollTop);

//         scrollingContainer.scrollTop = intScrollTop;
//     }
// };


// GS.scrollIntoView = function (element, strDirection) {
//     var strDirectionText;
//     if (strDirection) {
//         strDirectionText = strDirection;
//     } else {
//         strDirectionText = 'vertical';
//     }
//     var scrollingContainer = GS.scrollParent(element, strDirectionText), arrSiblings, i, len, intScrollTop;


//     if (scrollingContainer) {

//         arrSiblings = element.parentNode.children;

//         for (i = 0, intScrollTop = 0, len = arrSiblings.length; i < len; i += 1) {
//             if (arrSiblings[i] === element) {
//                 intScrollTop += arrSiblings[i].offsetHeight / 2;

//                 break;
//             } else {
//                 intScrollTop += arrSiblings[i].offsetHeight;
//             }
//         }

//         intScrollTop = intScrollTop - (scrollingContainer.offsetHeight / 2);

//         //console.log(intScrollTop);

//         scrollingContainer.scrollTop = intScrollTop;
//     }
// };






// #################################################################
// ################### INPUT SELECTION FUNCTIONS ###################
// #################################################################

GS.getInputSelection = function (input) {
    'use strict';
    var start = 0, end = 0, normalizedValue, range, textInputRange, len, endRange;

    if (typeof input.selectionStart === "number" && typeof input.selectionEnd === "number") {
        start = input.selectionStart;
        end = input.selectionEnd;
    } else {
        range = (document.createRange() || document.selection.createRange());

        if (range && range.parentElement() == input) {
            len = input.value.length;
            normalizedValue = input.value.replace(/\r\n/g, "\n");

            // Create a working TextRange that lives only in the input
            textInputRange = input.createTextRange();
            textInputRange.moveToBookmark(range.getBookmark());

            // Check if the start and end of the selection are at the very end
            // of the input, since moveStart/moveEnd doesn't return what we want
            // in those cases
            endRange = input.createTextRange();
            endRange.collapse(false);

            if (textInputRange.compareEndPoints("StartToEnd", endRange) > -1) {
                start = end = len;
            } else {
                start = -textInputRange.moveStart("character", -len);
                start += normalizedValue.slice(0, start).split("\n").length - 1;

                if (textInputRange.compareEndPoints("EndToEnd", endRange) > -1) {
                    end = len;
                } else {
                    end = -textInputRange.moveEnd("character", -len);
                    end += normalizedValue.slice(0, end).split("\n").length - 1;
                }
            }
        }
    }

    return {
        start: start,
        end: end
    };
};

GS.setInputSelection = function (input, intStart, intEnd) {
    'use strict';
    var range;

    if (intStart === undefined || intStart === '' || isNaN(intStart) || intStart === null) {
        intStart = input.value.length;
    }

    if (intEnd === undefined || intEnd === '' || isNaN(intEnd) || intEnd === null) {
        intEnd = intStart;
    }

    if (input.createTextRange) {
        range = input.createTextRange();
        range.collapse();
        range.moveStart('character', intStart);
        range.collapse();
        range.moveEnd('character', intEnd);
        range.select();
    } else if (input.setSelectionRange) {
        input.focus();
        input.setSelectionRange(intStart, intEnd);
    }
};


// #################################################################
// ################### ELEMENT POSITION FUNCTION ###################
// #################################################################

// return a whole bunch of position data variables for an element
GS.getElementPositionData = function (element) {
    var objElementOffset  = GS.getElementOffset(element),
        intElementWidth   = element.offsetWidth,
        intElementHeight  = element.offsetHeight,
        intElementTop     = objElementOffset.top,
        intElementLeft    = objElementOffset.left,
        intElementBottom  = window.innerHeight - (intElementTop    + intElementHeight),
        intElementRight   = window.innerWidth  - (intElementLeft   + intElementWidth),
        intRoomAbove      = window.innerHeight - (intElementBottom + intElementHeight),
        intRoomBelow      = intElementBottom,
        intRoomLeft       = window.innerWidth  - (intElementRight  + intElementWidth),
        intRoomRight      = intElementRight;

    /*console.log(element, '\n' +
                'intElementWidth:   ' + intElementWidth + '\n' +
                'intElementHeight:  ' + intElementHeight + '\n' +
                'intElementTop:     ' + intElementTop + '\n' +
                'intElementBottom:  ' + intElementBottom + '\n' +
                'intElementLeft:    ' + intElementLeft + '\n' +
                'intElementRight:   ' + intElementRight + '\n' +
                'intRoomAbove:      ' + intRoomAbove + '\n' +
                'intRoomBelow:      ' + intRoomBelow + '\n' +
                'intRoomLeft:       ' + intRoomLeft + '\n' +
                'intRoomRight:      ' + intRoomRight);*/

    return {
        'element':           element,
        'objElementOffset':  objElementOffset,
        'intElementWidth':   intElementWidth,
        'intElementHeight':  intElementHeight,
        'intElementTop':     intElementTop,
        'intElementLeft':    intElementLeft,
        'intElementBottom':  intElementBottom,
        'intElementRight':   intElementRight,
        'intRoomAbove':      intRoomAbove,
        'intRoomBelow':      intRoomBelow,
        'intRoomLeft':       intRoomLeft,
        'intRoomRight':      intRoomRight
    };
};

// #################################################################
// ####################### DOCUMENT FRAGMENT #######################
// #################################################################
/*                                       ,--- the problem with this code is the DOM we get back is not 100% reliably inert.
                                         V          To make it reliable I believe I have to change how my elements work.
GS.createDocumentFragment = function (strHTML) {
    'use strict';
    var element = document.createElement('div'),
        fragment = document.createDocumentFragment(),
        arrChildren = element.childNodes;

    // fill element with HTML
    element.innerHTML = strHTML;

    // append the element to the body (NECCESSARY FOR THE HTML TO BE INERT, I DON'T KNOW WHY -michael)
    document.body.appendChild(element);

    // transfer children from element to fragment
    while (arrChildren[0]) {
        fragment.appendChild(arrChildren[0]);
    }

    // remove element from the body
    document.body.removeChild(element);

    // return inert fragment
    return fragment;
};

GS.getDocumentFragmentHTML = function (fragment) {
    'use strict';
    var strHTML, i, len, arrChildren = fragment.children;

    for (strHTML = '', i = 0, len = arrChildren.length; i < len; i += 1) {
        strHTML += arrChildren[i].outerHTML;
    }

    return strHTML;
};
*/

// #################################################################
// ########################### INERT DOM ###########################
// #################################################################
/*tell papa if you uncomment
GS.createInertDOM = function (strHTML) {
    'use strict';
    var templateElement = document.createElement('template'), iframeElement;

    // if the content property is on a template element: no iframe neccessary
    if ('content' in templateElement) {
        templateElement.innerHTML = strHTML;

        return templateElement.content;

    // else: use iframe to create inert HTML
    } else {
        if (!document.getElementById('gs-inert-dom-generator')) {
            iframeElement = document.createElement('iframe');

            iframeElement.setAttribute('id', 'gs-inert-dom-generator');
            iframeElement.setAttribute('hidden', '');

            document.body.appendChild(iframeElement);

        } else {
            iframeElement = document.getElementById('gs-inert-dom-generator');
        }

        iframeElement.contentWindow.inertDOM = iframeElement.contentWindow.document.createElement('div');
        iframeElement.contentWindow.inertDOM.innerHTML = strHTML;

        return iframeElement.contentWindow.inertDOM;
    }
};

GS.getInertDOMHTML = function (inertDOM) {
    'use strict';
    var strHTML, i, len, arrChildren = inertDOM.children;

    for (strHTML = '', i = 0, len = arrChildren.length; i < len; i += 1) {
        strHTML += arrChildren[i].outerHTML;
    }

    return strHTML;
};
*/

// ##################################################################
// ###################### TABLE COPY/SELECTION ######################
// ##################################################################
(function () {
    'use strict';
    function getCellFromTarget(element) {
        var currentElement = element;

        while (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH' && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }

        if (currentElement && currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH') {
            return undefined;
        }

        return currentElement;
    }

    function selectHandler(tableElement, dragOrigin, dragCurrentCell, dragMode) {
        var bolThead, bolFirstTh, arrRecords, arrCells, arrRecordsToAffect = [], arrCellsToAffect = [],
            arrNewSelection = [], arrCellsToRemoveFromSelection = [], i, len, intFrom, intTo;

        arrRecords = xtag.query(tableElement, 'tr');
        arrCells = xtag.query(tableElement, 'td, th');

        if (arrRecords.length > 0) {
            bolThead = Boolean(xtag.queryChildren(tableElement, 'thead')[0]);

            if ((bolThead && arrRecords.length > 1) || (!bolThead && arrRecords > 0)) {
                if (bolThead) {
                    bolFirstTh = arrRecords[1].children[0].nodeName === 'TH';
                } else {
                    bolFirstTh = arrRecords[0].children[0].nodeName === 'TH';
                }
            }

            // if origin & currentCell are both the top-left cell and the cell is a heading: select all cells
            if (bolThead && bolFirstTh &&
                dragOrigin.parentNode.rowIndex === 0 && dragCurrentCell.parentNode.rowIndex === 0 &&
                dragOrigin.cellIndex === 0 && dragCurrentCell.cellIndex === 0) {
                arrCellsToAffect = arrCells;

            // else if origin & currentCell are both first ths: select the records from origin to currentCell
            } else if (bolFirstTh && dragOrigin.cellIndex === 0 && dragCurrentCell.cellIndex === 0) {
                arrRecordsToAffect =
                    arrRecords.slice(Math.min(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex),
                                     Math.max(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex) + 1);

                for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
                    Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children));
                }

            // else if origin & currentCell are both headings: select the columns from origin to currentCell
            } else if (bolThead && dragOrigin.parentNode.rowIndex === 0 && dragCurrentCell.parentNode.rowIndex === 0) {
                intFrom = Math.min(dragOrigin.cellIndex, dragCurrentCell.cellIndex);
                intTo   = Math.max(dragOrigin.cellIndex, dragCurrentCell.cellIndex) + 1;

                for (i = 0, len = arrRecords.length; i < len; i += 1) {
                    Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecords[i].children).slice(intFrom, intTo));
                }

            //// else if origin & currentCell are the same cell: select the record
            //} else if (dragOrigin === dragCurrentCell) {
            //    arrRecordsToAffect = arrRecords.slice(dragOrigin.parentNode.rowIndex, dragOrigin.parentNode.rowIndex + 1);
            //
            //    for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
            //        Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children));
            //    }
            //
            // else select cells from origin to currentCell
            } else {
                arrRecordsToAffect =
                    arrRecords.slice(Math.min(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex),
                                     Math.max(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex) + 1);

                intFrom = Math.min(dragOrigin.cellIndex, dragCurrentCell.cellIndex);
                intTo   = Math.max(dragOrigin.cellIndex, dragCurrentCell.cellIndex) + 1;

                for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
                    Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children).slice(intFrom, intTo));
                }
            }

            if (dragMode === 'select') {
                // add new cells to tableElement.selectionSelectedCells
                for (i = 0, len = tableElement.selectionSelectedCells.length; i < len; i += 1) {
                    if (arrCellsToAffect.indexOf(tableElement.selectionSelectedCells[i]) === -1) {
                        arrCellsToRemoveFromSelection.push(tableElement.selectionSelectedCells[i]);
                    }
                }
                tableElement.selectionSelectedCells = arrCellsToAffect;

                // add new cells to tableElement.selectedCells
                arrNewSelection = tableElement.selectedCells;
                for (i = 0, len = arrCellsToAffect.length; i < len; i += 1) {
                    GS.listAdd(arrNewSelection, arrCellsToAffect[i]);
                }
                for (i = 0, len = arrCellsToRemoveFromSelection.length; i < len; i += 1) {
                    arrNewSelection.splice(arrNewSelection.indexOf(arrCellsToRemoveFromSelection[i]), 1);
                }
                tableElement.selectedCells = arrNewSelection;

            } else { // implied if: dragMode === 'deselect'
                // deselect cells from arrCellsToAffect
                arrNewSelection = tableElement.selectedCells;

                for (i = 0, len = arrCellsToAffect.length; i < len; i += 1) {
                    if (arrNewSelection.indexOf(arrCellsToAffect[i]) > -1) {
                        arrNewSelection.splice(arrNewSelection.indexOf(arrCellsToAffect[i]), 1);
                    }
                }
                tableElement.selectedCells = arrNewSelection;
            }
        }
    }






    function getSelectedCopyHTML(element) {
        var strHTMLCopyString, intFromRecord, intToRecord, intFromCell = 9999999, intToCell = 0
          , i, len, cell_i, cell_len, arrSelected, strCellHTML, arrRecords, arrCells
          , strHTMLRecordString, strNull, bolColumns;

        arrSelected = element.selectedCells;

        strNull    = (element.getAttribute('null-values')  || "NULL");
        bolColumns = (element.getAttribute('column-names') || "true") === "true";

        // loop through the selected cells and create an html string using the text of the cell
        if (arrSelected.length > 0) {
            intFromRecord = arrSelected[0].parentNode.rowIndex;
            intToRecord = arrSelected[arrSelected.length - 1].parentNode.rowIndex + 1;

            for (i = 0, len = arrSelected.length; i < len; i += 1) {
                if (arrSelected[i].cellIndex < intFromCell) {
                    intFromCell = arrSelected[i].cellIndex;
                    intFromCell = (intFromCell === 0 ? 1 : intFromCell);
                }
                if (arrSelected[i].cellIndex + 1 > intToCell) {
                    intToCell = arrSelected[i].cellIndex + 1;
                }
            }

            arrRecords = xtag.query(element, 'tr');
            strHTMLCopyString = '';

            // if bolColumns is true and the first record is not selected: add first record first
            if (bolColumns && intFromRecord > 0) {
                arrCells = arrRecords[0].children;
                strHTMLRecordString = '';

                for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                    strCellHTML = '';

                    if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) {
                        strCellHTML = arrCells[cell_i].firstElementChild.textValue ||
                                      arrCells[cell_i].firstElementChild.value ||
                                      (arrCells[cell_i].firstElementChild.checked || '').toString() ||
                                      arrCells[cell_i].firstElementChild.textContent || '';//.trim();

                    } else if (arrCells[cell_i].lastElementChild) {
                        strCellHTML = arrCells[cell_i].lastElementChild.textValue ||
                                      arrCells[cell_i].lastElementChild.value ||
                                      (arrCells[cell_i].lastElementChild.checked || '').toString() ||
                                      arrCells[cell_i].lastElementChild.textContent || '';
                    } else {
                        strCellHTML = arrCells[cell_i].textContent;//.trim();
                    }

                    strCellHTML = encodeHTML(strCellHTML).replace(/\n/gim, '<br />');

                    strCellHTML = '<' + 'td rowspan="1" colspan="1">' + (strCellHTML || '') + '</td>'

                    strHTMLRecordString += (cell_i === intFromCell ? '<' + 'tr>' : '');
                    strHTMLRecordString += (strCellHTML || '');
                    strHTMLRecordString += (cell_i === (intToCell - 1) ? '<' + '/tr>' : '');
                }

                if (strHTMLRecordString.trim()) {
                    strHTMLCopyString += strHTMLRecordString;
                }
            }

            for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
                arrCells = arrRecords[i].children;
                strHTMLRecordString = '';

                if (!arrRecords[i].classList.contains('insert-record')) {
                    for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                        strCellHTML = '';

                        if (arrCells[cell_i].hasAttribute('selected') || (i === 0 && bolColumns)) {
                            if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) {
                                strCellHTML = arrCells[cell_i].firstElementChild.textValue ||
                                              arrCells[cell_i].firstElementChild.value ||
                                              (arrCells[cell_i].firstElementChild.checked || '').toString() ||
                                              arrCells[cell_i].firstElementChild.textContent || '';//.trim();

                            } else if (arrCells[cell_i].lastElementChild) {
                                strCellHTML = arrCells[cell_i].lastElementChild.textValue ||
                                              arrCells[cell_i].lastElementChild.value ||
                                              (arrCells[cell_i].lastElementChild.checked || '').toString() ||
                                              arrCells[cell_i].lastElementChild.textContent || '';
                            } else {
                                strCellHTML = arrCells[cell_i].textContent;//.trim();
                            }

                            strCellHTML = encodeHTML(strCellHTML).replace(/\n/gim, '<br />');

                            if (strCellHTML === 'NULL' || strCellHTML === '\N') {
                                strCellHTML = strNull;
                            }
                        }

                        strCellHTML = '<' + 'td rowspan="1" colspan="1">' + (strCellHTML || '') + '</td>'

                        strHTMLRecordString += (cell_i === intFromCell ? '<' + 'tr>' : '');
                        strHTMLRecordString += (strCellHTML || '');
                        strHTMLRecordString += (cell_i === (intToCell - 1) ? '<' + '/tr>' : '');
                    }
                }
                if (strHTMLRecordString.trim()) {
                    strHTMLCopyString += strHTMLRecordString;
                }
            }
            //console.log('*****', strHTMLCopyString);
            if (strHTMLCopyString) {
                strHTMLCopyString = '<' + 'style>' +
                                        'br { mso-data-placement:same-cell; } ' +
                                        'th, td { white-space: pre-wrap; }' +
                                    '<' + '/style>' +
                                    '<' + 'table border="0" cellpadding="0" cellspacing="0">' + strHTMLCopyString + '<' + '/table>';
            }
        }

        return strHTMLCopyString || '';
    }

    function getSelectedCopyText(element) {
        var strTextCopyString, intFromRecord, intToRecord, intFromCell = 9999999, intToCell = 0,
            i, len, cell_i, cell_len, arrSelected, strCellText, arrRecords, arrCells, arrCellIndexes, strTextRecordString,
            strQuoteType, strQuoteChar, strFieldDelimiter, strRowDelimiter, strNull, bolColumns, quoteRegex;

        strQuoteType      = (element.getAttribute('quote-type')      || "strings");
        strQuoteChar      = (element.getAttribute('quote-char')      || '"');
        strFieldDelimiter = (element.getAttribute('field-delimiter') || "\t");
        strNull           = (element.getAttribute('null-values')     || "NULL");
        bolColumns        = (element.getAttribute('column-names')    || "true") === "true";
        strRowDelimiter   = (element.getAttribute('row-delimiter')   || "\n");

        quoteRegex = new RegExp(strQuoteChar, 'g');

        arrSelected = element.selectedCells;

        // loop through the selected cells and create a tsv string using the text of the cell
        if (arrSelected.length > 0) {
            intFromRecord = arrSelected[0].parentNode.rowIndex;
            intToRecord = arrSelected[arrSelected.length - 1].parentNode.rowIndex + 1;

            for (i = 0, len = arrSelected.length; i < len; i += 1) {
                if (arrSelected[i].cellIndex < intFromCell) {
                    intFromCell = arrSelected[i].cellIndex;
                    intFromCell = (intFromCell === 0 ? 1 : intFromCell);
                }
                if (arrSelected[i].cellIndex + 1 > intToCell) {
                    intToCell = arrSelected[i].cellIndex + 1;
                }
            }

            arrRecords = xtag.query(element, 'tr');
            strTextCopyString = '';

            // if bolColumns is true and the first record is not selected: add first record first
            if (bolColumns && intFromRecord > 0) {
                arrCells = arrRecords[0].children;
                strTextRecordString = '';

                for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                    strCellText = '';

                    if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) {
                        strCellText = arrCells[cell_i].firstElementChild.textValue ||
                                      arrCells[cell_i].firstElementChild.value ||
                                      (arrCells[cell_i].firstElementChild.checked || '').toString() ||
                                      arrCells[cell_i].firstElementChild.textContent || '';//.trim();

                    } else if (arrCells[cell_i].lastElementChild) {
                        strCellText = arrCells[cell_i].lastElementChild.textValue ||
                                      arrCells[cell_i].lastElementChild.value ||
                                      (arrCells[cell_i].lastElementChild.checked || '').toString();
                    } else {
                        strCellText = arrCells[cell_i].textContent;//.trim();
                    }

                    strCellText = strCellText.replace(quoteRegex, (strQuoteChar + strQuoteChar));

                    if (strCellText === 'NULL' || strCellText === '\N') {
                        strCellText = strNull;
                    } else {
                        if (strQuoteType === 'all') {
                            strCellText = strQuoteChar + strCellText + strQuoteChar;
                        } else if (strQuoteType === 'strings' && isNaN(strCellText)) {
                            strCellText = strQuoteChar + strCellText + strQuoteChar;
                        }
                    }

                    strTextRecordString += (cell_i !== intFromCell ? strFieldDelimiter : '');
                    strTextRecordString += (strCellText || '');
                }

                strTextCopyString += strTextRecordString;
                strTextCopyString += strRowDelimiter;
            }

            for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
                arrCells = arrRecords[i].children;
                strTextRecordString = '';

                for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                    strCellText = '';

                    if (arrCells[cell_i].hasAttribute('selected')) {
                        if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) {
                            strCellText = arrCells[cell_i].firstElementChild.textValue ||
                                          arrCells[cell_i].firstElementChild.value ||
                                          (arrCells[cell_i].firstElementChild.checked || '').toString() ||
                                          arrCells[cell_i].firstElementChild.textContent;//.trim();

                        } else if (arrCells[cell_i].lastElementChild) {
                            strCellText = arrCells[cell_i].lastElementChild.textValue ||
                                          arrCells[cell_i].lastElementChild.value ||
                                          (arrCells[cell_i].lastElementChild.checked || '').toString();
                        } else {
                            strCellText = arrCells[cell_i].textContent;//.trim();
                        }

                        strCellText = strCellText.replace(quoteRegex, (strQuoteChar + strQuoteChar));

                        if (strCellText === 'NULL' || strCellText === '\N') {
                            strCellText = strNull;
                        } else {
                            if (strQuoteType === 'all') {
                                strCellText = strQuoteChar + strCellText + strQuoteChar;
                            } else if (strQuoteType === 'strings' && isNaN(strCellText)) {
                                strCellText = strQuoteChar + strCellText + strQuoteChar;
                            }
                        }
                    } else {
                        if (strQuoteType === 'all' || strQuoteType === 'strings') {
                            strCellText = strQuoteChar + strCellText + strQuoteChar;
                        }
                    }

                    strTextRecordString += (cell_i !== intFromCell ? strFieldDelimiter : '');
                    strTextRecordString += (strCellText || '');
                }
                //if (strTextRecordString.trim()) {
                strTextCopyString += strTextRecordString;
                //}
                if (i + 1 !== len) { //&& strTextRecordString.trim()
                    strTextCopyString += strRowDelimiter;
                }
            }
        }

        return strTextCopyString || '';
    }

    function handleClipboardData(event, strCopyString, strType) {
        var clipboardData = event.clipboardData || window.clipboardData, strMime;

        if (!clipboardData) { return; }
        if (!clipboardData.setData) { return; }

        if (strType === 'text') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = 'Text';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/plain';
            }

        } else if (strType === 'html') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = '';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/html';
            }

        } else {
            throw 'handleClipboardData Error: Type "' + strType + '" not recognized, recognized types are "text" and "html".';
        }

        if (strMime) {
            if (strCopyString && strMime) {
                return clipboardData.setData(strMime, strCopyString) !== false;
            } else {
                return clipboardData.getData(strMime);
            }
        }
    }



    //function handleClipboardData(event, strCopyString) {
    //    var clipboardData = event.clipboardData || window.clipboardData, strMime;
    //
    //    if (!clipboardData) {
    //        return;
    //    }
    //    if (!clipboardData.setData) {
    //        return;
    //    }
    //
    //    if (window.clipboardData && window.clipboardData.getData) { // IE
    //        strMime = 'Text';
    //    } else if (event.clipboardData && event.clipboardData.getData) {
    //        strMime = 'text/plain';
    //    }
    //
    //    if (strCopyString) {
    //        return clipboardData.setData(strMime, strCopyString) !== false;
    //    } else {
    //        return clipboardData.getData(strMime);
    //    }
    //}

    GS.makeTableSelectable = function (tableElement, bolSingleRecord) {
        var copyElement;

        // tableElement verification
        if (!tableElement || tableElement.nodeName !== 'TABLE') {
            throw 'GS.makeTableSelectable Error: you must provide a <table> element as the first parameter.';
        }

        // prevent text selection
        //tableElement.setAttribute('prevent-text-selection', '');

        // define selectedCells getter and setter on the table element itself
        Object.defineProperty(tableElement, 'selectedCells', {
            get: function () {
                return xtag.query(this, '[selected]');
            },

            set: function (newValue) {
                var i, len, intIdIndex, arrCells = this.selectedCells, arrRecords, cell_i, cell_len;

                // clear old selection
                for (i = 0, len = arrCells.length; i < len; i += 1) {
                    arrCells[i].removeAttribute('selected');
                }

                arrCells = xtag.query(this, '[selected-secondary]');
                for (i = 0, len = arrCells.length; i < len; i += 1) {
                    arrCells[i].removeAttribute('selected-secondary');
                }

                // if newValue is not an array: make it an array
                if (typeof newValue === 'object' && newValue.length === undefined) {
                    arrCells = [newValue];
                } else {
                    arrCells = newValue;
                }

                // set new selection
                for (i = 0, len = arrCells.length; i < len; i += 1) {
                    arrCells[i].setAttribute('selected', '');
                }

                arrRecords = this.selectedRecords;

                for (i = 0, len = arrRecords.length; i < len; i += 1) {
                    arrCells = arrRecords[i].children;

                    for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                        if (!arrCells[cell_i].hasAttribute('selected')) {
                            arrCells[cell_i].setAttribute('selected-secondary', '');
                        }
                    }
                }

                GS.triggerEvent(this, 'after_selection');
            }
        });

        // define selectedRecords getter and setter on the table element itself
        Object.defineProperty(tableElement, 'selectedRecords', {
            get: function () {
                var i, len, intRecordIndex = -1, arrRecord = [], selected = this.selectedCells;

                // loop through the selected cells and create an array of trs
                for (i = 0, len = selected.length; i < len; i += 1) {
                    if (selected[i].parentNode.rowIndex > intRecordIndex && selected[i].parentNode.parentNode.nodeName !== 'THEAD') {
                        intRecordIndex = selected[i].parentNode.rowIndex;

                        arrRecord.push(selected[i].parentNode);
                    }
                }

                return arrRecord;
            },

            set: function (newValue) {
                var i, len, cell_i, cell_len, intIdIndex, arrCells = this.selectedCells, arrRecords, arrCellChildren;

                // clear old selection
                for (i = 0, len = arrCells.length; i < len; i += 1) {
                    arrCells[i].removeAttribute('selected');
                }

                arrCells = xtag.query(this, '[selected-secondary]');
                for (i = 0, len = arrCells.length; i < len; i += 1) {
                    arrCells[i].removeAttribute('selected-secondary');
                }

                // if newValue is not an array: make it an array
                if (typeof newValue === 'object' && newValue.length === undefined) {
                    arrRecords = [newValue];
                } else {
                    arrRecords = newValue;
                }

                // set new selection
                for (i = 0, len = arrRecords.length, arrCells = []; i < len; i += 1) {
                    arrCellChildren = arrRecords[i].children;

                    for (cell_i = 0, cell_len = arrCellChildren.length; cell_i < cell_len; cell_i += 1) {
                        arrCells.push(arrCellChildren[cell_i]);
                    }
                }

                this.selectedCells = arrCells;

                GS.triggerEvent(this, 'after_selection');
            }
        });

        // if we are on a touchdevice or bolSingleRecord is true: single record selection
        if (evt.touchDevice || bolSingleRecord === true) {
            tableElement.addEventListener(evt.mousedown, function (event) {
                var target = event.target;

                if (target.nodeName === 'TD' || target.nodeName === 'TH' || getCellFromTarget(target)) {
                    tableElement.selectedCells = [];

                    // if there is a parent record to the target: select all of the cells in the record
                    if (GS.findParentTag(target, 'tr')) {
                        tableElement.selectedCells = GS.findParentTag(target, 'tr').children;
                    }
                }
            });

        // else: cell/record selection
        } else {
            // mousedown (on selected and unselected) + drag
            //      clear previous selection(s)
            //      select cells from origin cell to current cell
            //
            // shift + mousedown (on selected and unselected) + drag
            //      alter previous selection
            //      select cells from previous origin cell to current cell
            //
            // command + mousedown (on unselected) + drag
            //      maintain previous selection(s)
            //      select cells from origin cell to current cell
            //
            // command + mousedown (on selected) + drag
            //      maintain previous selection(s)
            //      deselect cells from origin cell to current cell
            //
            // collision handling
            //      when colliding with previous selections: dont treat them different
            //
            // copy handling
            //      selection ("X" marks selected cells (imagine all cells contain the letter "a")):
            //          1  2  3  4  5
            //          -------------
            //          a  a  a  a  a
            //          a  X  X  a  a
            //          a  a  X  X  a
            //          a  a  a  a  a
            //
            //      yields ("'" marks an empty cell):
            //          2  3  4
            //          -------
            //          a  a  '
            //          '  a  a

            tableElement.addEventListener(evt.mousedown, function (event) {
                var target = event.target, cellFromTarget = getCellFromTarget(target), closestCell, arrSelectedCells, i, len;

                if (GS.findParentTag(event.target, 'table')) {
                    if (cellFromTarget) {
                        closestCell = cellFromTarget;
                    }

                    if (closestCell) {
                        tableElement.dragAllowed = true;
                        tableElement.dragCurrentCell = closestCell;
                        tableElement.selectionSelectedCells = [];

                        // if shift is down and there is a previous origin: use previous origin for current origin
                        if (event.shiftKey && tableElement.selectionPreviousOrigin) {

                            // if there are previously selected cells: deselect the previous selected cells
                            if (tableElement.selectionPreviousSelectedCells) {
                                arrSelectedCells = tableElement.selectedCells;

                                for (i = 0, len = tableElement.selectionPreviousSelectedCells.length; i < len; i += 1) {
                                    arrSelectedCells.splice(arrSelectedCells.indexOf(tableElement.selectionPreviousSelectedCells[i]), 1);
                                }

                                tableElement.selectedCells = arrSelectedCells;
                            }

                            tableElement.dragOrigin = tableElement.selectionPreviousOrigin;
                            tableElement.dragMode = 'select';

                        // else if ctrl or cmd is down and the target cell is not selected: select cells from target cell to current cell
                        } else if (!event.shiftKey && (event.metaKey || event.ctrlKey) && !closestCell.hasAttribute('selected')) {
                            tableElement.dragOrigin = closestCell;
                            tableElement.dragMode = 'select';

                        // else if ctrl or cmd is down and the target cell is selected: deselect cells from target cell to current cell
                        } else if (!event.shiftKey && (event.metaKey || event.ctrlKey) && closestCell.hasAttribute('selected')) {
                            tableElement.dragOrigin = closestCell;
                            tableElement.dragMode = 'deselect';

                        // else: deselect all cells and start new selection
                        } else {
                            tableElement.selectedCells = [];
                            tableElement.dragOrigin = closestCell;
                            tableElement.dragMode = 'select';
                        }

                        selectHandler(tableElement, tableElement.dragOrigin, tableElement.dragCurrentCell, tableElement.dragMode);
                    }
                }
            });
            tableElement.addEventListener(evt.mousemove, function (event) {
                var target, closestCell, cellFromTarget;

                // if mouse is down
                if (event.which !== 0) {
                    target = event.target;
                    cellFromTarget = getCellFromTarget(target);

                    if (cellFromTarget) {
                        closestCell = cellFromTarget;
                    }

                    // if selection is allowed at this point and closestCell is different from tableElement.dragCurrentCell
                    if (tableElement.dragAllowed && tableElement.dragCurrentCell !== closestCell) {
                        tableElement.dragCurrentCell = getCellFromTarget(closestCell);
                        selectHandler(tableElement, tableElement.dragOrigin, tableElement.dragCurrentCell, tableElement.dragMode);
                    }
                } else {
                    tableElement.dragAllowed = false;
                    tableElement.selectionPreviousOrigin = tableElement.dragOrigin;
                    tableElement.selectionPreviousSelectedCells = tableElement.selectionSelectedCells;
                }
            });
            tableElement.addEventListener(evt.mouseup, function (event) {
                tableElement.dragAllowed = false;

                if (tableElement.dragMode === 'select') {
                    tableElement.selectionPreviousOrigin = tableElement.dragOrigin;
                    tableElement.selectionPreviousSelectedCells = tableElement.selectionSelectedCells;
                }
            });
        }

        // add input for clipboard compatibility
        copyElement = document.createElement('input');
        copyElement.value = 'Firefox compatibility input';
        copyElement.setAttribute('gs-dynamic', '');
        copyElement.setAttribute('style', 'position: fixed; left: 50%; top: 50%; z-index: -5000; opacity: 0.00000001;');

        tableElement.appendChild(copyElement);

        // add tabindex so that we can listen for focus on the table
        tableElement.tabIndex = 0;

        // when a focus event happens on the table: focus the copy input if the element that is focused is the table
        tableElement.addEventListener('focus', function (event) {
            if (document.activeElement === tableElement) {
                tableElement.focus();
                GS.setInputSelection(copyElement, 0, 'Firefox compatibility input'.length);
            }
        });

        // clipboard handling
        document.body.addEventListener('copy', function (event) {
            var elementClosestTable = GS.findParentTag(document.activeElement, 'table')
              , strTextCopyString, strHTMLCopyString;

            if (elementClosestTable === tableElement &&
                (
                    document.activeElement.value === 'Firefox compatibility input' ||
                    document.activeElement.selectionStart === document.activeElement.selectionEnd
                )) {
                GS.setInputSelection(document.activeElement, document.activeElement.value.length,
                                            document.activeElement.value.length);

                strTextCopyString = getSelectedCopyText(tableElement);
                strHTMLCopyString = getSelectedCopyHTML(tableElement);

                if (strTextCopyString && strHTMLCopyString) {
                    if (handleClipboardData(event, strTextCopyString, 'text')) {
                        event.preventDefault(event);
                    }
                    if (handleClipboardData(event, strHTMLCopyString, 'html')) {
                        event.preventDefault(event);
                    }
                }

                GS.setInputSelection(document.activeElement, 0, document.activeElement.value.length);
            }
        });
            //var elementClosestTable = GS.findParentTag(document.activeElement, 'table'), strCopyString,
            //    i, len, cell_i, cell_len, arrSelected, intFromRecord = 9999999, intFromCell = 9999999,
            //    intToRecord = 0, intToCell = 0, strCellText, arrRecords, arrCells, strRecordString;
            //
            //if (elementClosestTable === tableElement &&
            //    (
            //        document.activeElement.value === 'Firefox compatibility input' ||
            //        document.activeElement.selectionStart === document.activeElement.selectionEnd
            //    )) {
            //    arrSelected = tableElement.selectedCells;
            //
            //    // loop through the selected cells and create a tsv string using the text of the cell
            //    if (arrSelected.length > 0) {
            //        for (i = 0, len = arrSelected.length; i < len; i += 1) {
            //            if (arrSelected[i].parentNode.rowIndex < intFromRecord) {
            //                intFromRecord = arrSelected[i].parentNode.rowIndex;
            //            }
            //            if (arrSelected[i].cellIndex < intFromCell) {
            //                intFromCell = arrSelected[i].cellIndex;
            //            }
            //            if (arrSelected[i].parentNode.rowIndex + 1 > intToRecord) {
            //                intToRecord = arrSelected[i].parentNode.rowIndex + 1;
            //            }
            //            if (arrSelected[i].cellIndex + 1 > intToCell) {
            //                intToCell = arrSelected[i].cellIndex + 1;
            //            }
            //        }
            //
            //        arrRecords = xtag.query(tableElement, 'tr');
            //        strCopyString = '';
            //
            //        for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
            //            arrCells = arrRecords[i].children;
            //
            //            for (cell_i = intFromCell, cell_len = intToCell, strRecordString = ''; cell_i < cell_len; cell_i += 1) {
            //                if (arrCells[cell_i].hasAttribute('selected')) {
            //                    if (arrCells[cell_i].nodeName === 'TH' && arrCells[cell_i].firstElementChild) {
            //                        strCellText = arrCells[cell_i].firstElementChild.textValue ||
            //                                      arrCells[cell_i].firstElementChild.value ||
            //                                      (arrCells[cell_i].firstElementChild.checked || '').toString() ||
            //                                      arrCells[cell_i].firstElementChild.textContent.trim();
            //                    } else if (arrCells[cell_i].lastElementChild) {
            //                        strCellText = arrCells[cell_i].lastElementChild.textValue ||
            //                                      arrCells[cell_i].lastElementChild.value ||
            //                                      (arrCells[cell_i].lastElementChild.checked || '').toString() ||
            //                                      arrCells[cell_i].lastElementChild.textContent.trim();
            //                    } else {
            //                        strCellText = arrCells[cell_i].textContent.trim();
            //                    }
            //                } else {
            //                    strCellText = '';
            //                }
            //
            //                strRecordString += (cell_i !== intFromCell ? '\t' : '') + (strCellText || '');
            //            }
            //
            //            if (strRecordString.trim()) {
            //                strCopyString += strRecordString;
            //            }
            //
            //            if (i + 1 !== len && strRecordString.trim()) {
            //                strCopyString += '\r\n';
            //            }
            //        }
            //    }
            //
            //    if (strCopyString) {
            //        if (handleClipboardData(event, strCopyString)) {
            //            event.preventDefault(event);
            //        }
            //    }
            //}
    };
})();
window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('GS.qryFromJSON', 'GS.qryFromJSON', 'GS.qryFromJSON(${0:jsnObjectToConvert});');

    registerDesignSnippet('GS.qryToJSON', 'GS.qryToJSON', 'GS.qryToJSON(${0:strQueryStringToConvert});');

    registerDesignSnippet('GS.qryToWhere', 'GS.qryToWhere',
                                'GS.qryToWhere(${1:strQueryString}, ${2:strColumnNameInQueryString}, ${0:strColumnNameInTarget});');

    registerDesignSnippet('GS.qryGetKeys', 'GS.qryGetKeys', 'GS.qryGetKeys(${0:queryString});');

    registerDesignSnippet('GS.qryGetVals', 'GS.qryGetVals', 'GS.qryGetVals(${0:queryString});');

    registerDesignSnippet('GS.qryGetVal', 'GS.qryGetVal', 'GS.qryGetVal(${1:queryString}, \'${0:keyToGet}\');');

    registerDesignSnippet('GS.qrySetVal', 'GS.qrySetVal', 'GS.qrySetVal(${1:queryString}, \'${0:newKeyValuePair}\');');

    registerDesignSnippet('GS.qryDeleteKey', 'GS.qryDeleteKey', 'GS.qryDeleteKey(${1:queryString}, \'${0:keyToDelete}\');');

    registerDesignSnippet('GS.getQueryString', 'GS.getQueryString', 'GS.getQueryString();');

    registerDesignSnippet('GS.pushQueryString', 'GS.pushQueryString', 'GS.pushQueryString(${0:newQueryString});');

    registerDesignSnippet('GS.removeFromQueryString', 'GS.removeFromQueryString', 'GS.removeFromQueryString(${0:removeKeys});');
});


// ########## CONVERSION FUNCTIONS ##########
GS.qryFromJSON = function (jsnToConvert) {
    'use strict';
    var key, strRet = '', strType, currentValue;

    for (key in jsnToConvert) {
        currentValue = jsnToConvert[key];
        strType = typeof currentValue;

        if (strType === 'number' || strType === 'string' || strType === 'boolean') {
            strRet += (strRet === '' ? '' : '&') + key + '=' + encodeURIComponent(jsnToConvert[key]);

        } else if (currentValue === null || currentValue === undefined) {
            strRet += (strRet === '' ? '' : '&') + key + '=';

        } else if (typeof currentValue !== 'object') {
            throw 'GS.qryFromJSON Error: Invalid value: ' + JSON.stringify(currentValue);
        }
    }

    return strRet;
};

GS.qryToJSON = function (strQueryString) {
    'use strict';
    var arrKeyValueList = [], jsnQueryString = {}, strKeyValue, i, len, strKey, strValue, jsnNavigator, arrSubParts, sub_i, sub_len;

    if (strQueryString) {
        arrKeyValueList = strQueryString.split('&');

        for (i = 0, len = arrKeyValueList.length; i < len; i += 1) {
            strKeyValue = arrKeyValueList[i];
            strKey      = strKeyValue.substring(0, strKeyValue.indexOf('='));
            strValue    = decodeURIComponent(strKeyValue.substring(strKeyValue.indexOf('=') + 1));

            jsnQueryString[strKey] = strValue;

            // if a dot is found in the key: create a sub JSON structure
            if (strKey.indexOf('.') > -1) {
                arrSubParts = strKey.split('.');

                jsnNavigator = jsnQueryString;
                for (sub_i = 0, sub_len = arrSubParts.length; sub_i < sub_len; sub_i += 1) {
                    if (sub_i < sub_len - 1) {
                        jsnNavigator[arrSubParts[sub_i]] = jsnNavigator[arrSubParts[sub_i]] || {};
                    } else {
                        jsnNavigator[arrSubParts[sub_i]] = jsnNavigator[arrSubParts[sub_i]] || strValue;
                    }

                    jsnNavigator = jsnNavigator[arrSubParts[sub_i]];
                }
            }
        }
    }

    return jsnQueryString;
};

// get data from query string and turn it into a where clause
//      (
//          the second two params are optional
//              (
//                  they are for when you want only one column out of a query string to be converted
//              )
//      )
GS.qryToWhere = function (strQS, strColumnNameInQS, strColumnNameInTarget) {
    'use strict';
    var strWhere = '', key, jsnArgs;

    if (strColumnNameInQS) {
        strColumnNameInTarget = (strColumnNameInTarget || strColumnNameInQS);

        if (!isNaN(GS.qryGetVal(strQS, strColumnNameInQS))) {
            strWhere = strColumnNameInTarget + '=' + GS.qryGetVal(strQS, strColumnNameInQS);
        } else {
            strWhere = 'CAST(' + strColumnNameInTarget + ' AS ' + GS.database.type.text + ') = ' +
                       'CAST($WhereQUOTE$' +
                            encodeURIComponent(GS.qryGetVal(strQS, strColumnNameInQS)) +
                            '$WhereQUOTE$ AS ' + GS.database.type.text + ')';
        }
    } else {
        jsnArgs = GS.qryToJSON(strQS);

        for (key in jsnArgs) {
            if (jsnArgs.hasOwnProperty(key)) {
                if (!isNaN(jsnArgs[key])) {
                    strWhere += (strWhere === '' ? '': ' AND ') + key + '=' + jsnArgs[key];
                } else {
                    strWhere += (strWhere === '' ? '': ' AND ') +
                                'CAST(' + key + ' AS ' + GS.database.type.text + ') = ' +
                                'CAST($WhereQUOTE$' + encodeURIComponent(jsnArgs[key]) + '$WhereQUOTE$ AS ' + GS.database.type.text + ')';
                }
            }
        }
    }

    return strWhere;
};


// ########## LISTING FUNCTIONS ##########
GS.qryGetKeys = function (strQueryString) {
    'use strict';
    var arrKeyValueList = [], arrKeys = [], i, len, strKeyValue;

    if (strQueryString) {
        arrKeyValueList = strQueryString.split('&');

        for (i = 0, len = arrKeyValueList.length; i < len; i += 1) {
            strKeyValue = arrKeyValueList[i];

            arrKeys.push(strKeyValue.substring(0, strKeyValue.indexOf('=')));
        }
    }

    return arrKeys;
};

GS.qryGetVals = function (strQueryString) {
    'use strict';
    var arrKeyValueList = [], arrValues = [], i, len, strKeyValue;

    if (strQueryString) {
        arrKeyValueList = strQueryString.split('&');

        for (i = 0, len = arrKeyValueList.length; i < len; i += 1) {
            strKeyValue = arrKeyValueList[i];

            arrValues.push(decodeURIComponent(strKeyValue.substring(strKeyValue.indexOf('=') + 1)));
        }
    }

    return arrValues;
};


// ########## PARAMETER GET/SET FUNCTIONS ##########
GS.qryGetVal = function (strQueryString, strKey) {
    'use strict';
    var arrKeyValueList, strSlice, i, len;

    if (strQueryString) {
        arrKeyValueList = strQueryString.split('&');

        for (i = 0, len = arrKeyValueList.length; i < len; i = i + 1) {
            strSlice = arrKeyValueList[i];

            if (strSlice.split('=')[0] === strKey) {
                return decodeURIComponent(strSlice.substring(strSlice.indexOf('=') + 1));
            }
        }
    }

    return '';
};

GS.qrySetVal = function (strQueryString, strKeyValue) {
    'use strict';
    strQueryString = GS.qryDeleteKey(strQueryString, strKeyValue.split('=')[0]);
    strQueryString = strQueryString + (strQueryString ? '&' : '') + strKeyValue;

    return strQueryString;
};


// ########## KEY DELETE FUNCTION ##########
GS.qryDeleteKey = function (strQueryString, strKey) {
    'use strict';
    var arrKeyValueList, strSlice, i, len;

    if (strQueryString) {
        arrKeyValueList = strQueryString.split('&');

        for (i = 0, len = arrKeyValueList.length; i < len; i = i + 1) {
            strSlice = arrKeyValueList[i];

            if (strSlice.split('=')[0] === strKey) {
                arrKeyValueList.splice(i, 1);

                break;
            }
        }

        return arrKeyValueList.join('&');
    }

    return '';
};


// ########## MISC FUNCTIONS ##########
GS.getQueryString = function () {
    'use strict';
    return window.location.search.substring(1);
};

GS.pushQueryString = function (QS) {
    var arrNewQS = QS.split('&'), i, len, newQS = GS.getQueryString();
    for (i = 0, len = arrNewQS.length; i < len; i += 1) {
        newQS = GS.qrySetVal(newQS, arrNewQS[i]);
    }
    GS.pushState({}, '', '?' + newQS);
};


GS.removeFromQueryString = function (keys) {
    var arrRemoveKeys = keys.split(','), i, len, newQS = GS.getQueryString();
    for (i = 0, len = arrRemoveKeys.length; i < len; i += 1) {
        newQS = GS.qryDeleteKey(newQS, arrRemoveKeys[i]);
    }
    GS.pushState({}, '', '?' + newQS);
};

window.addEventListener('design-register-element', function () {
    'use strict';

    //registerDesignSnippet('GS.qryFromJSON', 'GS.qryFromJSON', 'GS.qryFromJSON(${0:jsnObjectToConvert});');
});



GS.templateColumnToValue = function (templateHTML) {
    'use strict';
    var templateElementEncoded = document.createElement('template'),
        templateElementNonEncoded = document.createElement('template'),
        arrTemplateElementEncoded, arrTemplateElementNonEncoded,
        jsnTemplates = {}, arrColumnElement = [], templateHTMLEncoded, bolInCommand, i, len, strID;

    // get template element encoded with all "&"s (that are not inside a doT command) encoded,
    //      so that html encoded characters are not lost in the next operations

    for (i = 0, len = templateHTML.length, templateHTMLEncoded = '', bolInCommand = false; i < len; i += 1) {
        if (!bolInCommand && templateHTML[i] === '{' && templateHTML[i + 1] === '{') {
            bolInCommand = true;
            i += 1;
            templateHTMLEncoded += '{{';

        } else if (bolInCommand && templateHTML[i] === '}' && templateHTML[i + 1] === '}') {
            bolInCommand = false;
            i += 1;
            templateHTMLEncoded += '}}';

        } else if (!bolInCommand && templateHTML[i] === '&') {
            templateHTMLEncoded += '&amp;';

        } else {
            templateHTMLEncoded += templateHTML[i];
        }
    }

    //console.log(templateHTML);
    //console.log(templateHTMLEncoded);
    templateElementEncoded.innerHTML = templateHTMLEncoded; //templateHTML.replace(/&/gi, '&amp;');

    // get template element non-encoded with everything in it, so that sub templates are not touched
    templateElementNonEncoded.innerHTML = templateHTML;

    // go through element encoded and replace templates with tokens
    // go through element non-encoded and gather templates and make sure they reference the same tokens
    arrTemplateElementEncoded = xtag.query(templateElementEncoded.content, 'template');
    arrTemplateElementNonEncoded = xtag.query(templateElementNonEncoded.content, 'template');
    i = 0;

    //console.log(arrTemplateElementEncoded);
    //console.log(arrTemplateElementNonEncoded);

    //console.log(arrTemplateElementEncoded.length);
    while (arrTemplateElementEncoded.length > 0 && i < 500) {
        //console.log(arrTemplateElementNonEncoded[0].parentNode);

        if (arrTemplateElementNonEncoded[0].parentNode &&
            arrTemplateElementNonEncoded[0].parentNode.hasAttribute &&
                (
                    arrTemplateElementNonEncoded[0].parentNode.hasAttribute('src') ||
                    arrTemplateElementNonEncoded[0].parentNode.hasAttribute('source')
                )) {
            strID = 'UnIqUE_PLaCEh0LDER-' + GS.GUID() + '-UniQUE_PLaCEh0LdER';
            jsnTemplates[strID] = arrTemplateElementNonEncoded[0].outerHTML;
            arrTemplateElementEncoded[0].outerHTML = strID;
        } else {
            // append any sub templates to the "arrTemplateElementEncoded" and "arrTemplateElementNonEncoded"
            //      variables
            arrTemplateElementEncoded = arrTemplateElementEncoded
                                            .concat(xtag.query(arrTemplateElementEncoded[0].content, 'template'));
            arrTemplateElementNonEncoded = arrTemplateElementNonEncoded
                                                .concat(xtag.query(arrTemplateElementNonEncoded[0].content, 'template'));

            // append any column elements in this template to the "arrColumnElement" variable
            arrColumnElement = arrColumnElement.concat(xtag.query(arrTemplateElementEncoded[0].content, '[column]'));
        }

        // remove the current template from the arrays
        arrTemplateElementEncoded.splice(0, 1);
        arrTemplateElementNonEncoded.splice(0, 1);

        i += 1;
    }

    // go through element encoded and add calculated "value" attribute to any element with a "column"
    //      attribute but no "value" attribute
    arrColumnElement = arrColumnElement.concat(xtag.query(templateElementEncoded.content, '[column]'));

    for (i = 0, len = arrColumnElement.length; i < len; i += 1) {
        if (!arrColumnElement[i].hasAttribute('value')) {
            arrColumnElement[i].setAttribute('value', '{{! row[\'' + arrColumnElement[i].getAttribute('column').replace(/\\/gi, '\\\\').replace(/\'/gi, '\\\'') + '\'] }}');
        }
    }

    //console.log(templateHTML);
    //console.log(arrColumnElement);
    //console.log(jsnTemplates);
    //console.log(templateElementEncoded.innerHTML);

    // save element encoded innerHTML as template HTML
    templateHTML = templateElementEncoded.innerHTML;

    // go through template HTML and replace template tokens with template HTML
    for (strID in jsnTemplates) {
        //                                      DO NOT DELETE, this allows single dollar signs to be inside dot notation
        //                                                                                                V
        templateHTML = templateHTML.replace(new RegExp(strID, 'g'), jsnTemplates[strID].replace(/\$/g, '$$$$'));
    }

    //console.log(element.templateHTML);

    return templateHTML;
};


GS.templateWithQuerystring = function (templateText) {
    'use strict';
    var strWrapperTemplate = '{{##def.snippet:\n' +
                             '    {{ var qs = jo; }} {{# def.template }}\n' +
                             '#}}\n' +
                             '{{#def.snippet}}';

    return doT.template(strWrapperTemplate, null, {'template': templateText})(GS.qryToJSON(GS.getQueryString())).trim();
};


GS.templateHideSubTemplates = function (templateHTML, bolRecord) {
    'use strict';
    var templateElement, strID, arrTemplates, i, len, jsnTemplates, strRet, strStart, strEnd;

    if (bolRecord) {
        strStart = '<table><tbody>';
        strEnd = '</tbody></table>';
        templateHTML = (strStart + templateHTML + strEnd);
    }

    templateElement = document.createElement('template');
    templateElement.innerHTML = templateHTML;

    // temporarily remove templates
    // recursively go through templates whose parents do not have the source attribute
    i = 0;
    arrTemplates = xtag.query(templateElement.content, 'template');
    jsnTemplates = {};

    //console.log(arrTemplates.length);

    while (arrTemplates.length > 0 && i < 100) {
        //console.log(arrTemplates[0], arrTemplates[0].parentNode);
        // if the current template has a source parent: remove temporarily
        if (arrTemplates[0].parentNode &&
            arrTemplates[0].parentNode.hasAttribute && (arrTemplates[0].parentNode.hasAttribute('src') ||
                                                        arrTemplates[0].parentNode.hasAttribute('source'))) {
            strID = 'UNIqUE_PLaCEhOLDER-' + GS.GUID() + '-UNiQUE_PLaCEhOLdER';
            jsnTemplates[strID] = arrTemplates[0].outerHTML;
            arrTemplates[0].outerHTML = strID;

        // else: add to the arrTemplates array
        } else if (arrTemplates[0].content) {
            arrTemplates.push.apply(arrTemplates, xtag.query(arrTemplates[0].content, 'template'));
        }

        // remove the current template from the arrTemplates array
        arrTemplates.splice(0, 1);

        i += 1;
    }

    strRet = decodeHTML(templateElement.innerHTML);

    if (bolRecord) {
        strRet = strRet.substring(strStart.length, strRet.length - strEnd.length);
    }

    return {'templateHTML': strRet, 'templateData': jsnTemplates}
};

GS.templateShowSubTemplates = function (strRet, jsnTemplate) {
    'use strict';
    var strID;

    for (strID in jsnTemplate.templateData) {
        //                                       DO NOT DELETE, this allows single dollar signs to be inside dot notation
        //                                                                  V
        strRet = strRet.replace(new RegExp(strID, 'g'), jsnTemplate.templateData[strID].replace(/\$/g, '$$$$'));
    }

    return strRet;
};

GS.templateWithEnvelopeData = function (templateHTML, data, i, len, rowNumberOffset) {
    'use strict';
    return doT.template(ml(function () {/*
        {{##def.snippet:
            {{ var row, row_number, i, len, col_i, col_len
                 , qs = GS.qryToJSON(GS.getQueryString())
                 , rowNumberOffset = (jo.rowNumberOffset || 0);

            if (!isNaN(jo.i)) {
                i = jo.i;
                len = (jo.len === undefined || jo.len === null ? jo.i + 1 : jo.len);

            } else {
                i = 0;
                len = jo.data.dat.length;
            }

            for (; i < len; i += 1) {
                row = {};
                row_number = (i + 1) + rowNumberOffset;
                row.row_number = row_number;

                for (col_i = 0, col_len = jo.data.arr_column.length; col_i < col_len; col_i += 1) {
                    if (jo.data.dat[i][col_i] === undefined || jo.data.dat[i][col_i] === null) {
                        row[jo.data.arr_column[col_i]] = '';
                    } else {
                        row[jo.data.arr_column[col_i]] = jo.data.dat[i][col_i];
                    }
                } }}{{# def.record }}
            {{ } }}
        #}}
        {{#def.snippet}}*/console.log;
    }), null, {"record":  templateHTML})({ 'data': data, 'i': i, 'len': len, 'rowNumberOffset': rowNumberOffset });
};





window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('GS.userChangePassword', 'GS.userChangePassword', 'GS.userChangePassword();');
    //registerDesignSnippet('GS.superChangePassword', 'GS.superChangePassword', 'GS.superChangePassword();');
    //registerDesignSnippet('GS.superUserLogin', 'GS.superUserLogin', 'GS.superUserLogin(${0:loggedInCallback});');
    registerDesignSnippet('GS.normalUserLogin', 'GS.normalUserLogin', 'GS.normalUserLogin(${0:loggedInCallback});');
});

(function () {
    function changePassword(strLink, strRank) {
        var templateElement = document.createElement('template');

        templateElement.innerHTML = ml(function () {/*
            <gs-page>
                <gs-header><center><h3>Change {{RANK}} Password</h3></center></gs-header>
                <gs-body padded>
                    <div id="pword-error" style="color: #FF0000;"></div>
                    <label for="old-password">Old Password:</label>
                    <gs-text id="old-password" type="password"></gs-text>
                    <label for="new-password">New Password:</label>
                    <gs-text id="new-password" type="password"></gs-text>
                    <label for="new-password-confirm">Confirm New Password:</label>
                    <gs-text id="new-password-confirm" type="password"></gs-text>
                </gs-body>
                <gs-footer>
                    <gs-grid>
                        <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
                        <gs-block><gs-button id="button-change-password" disabled>Change {{RANK}} Password</gs-button></gs-block>
                    </gs-grid>
                </gs-footer>
            </gs-page>
        */}).replace(/\{\{RANK\}\}/gim, strRank);

        GS.openDialog(templateElement, function () {
            var dialog = this, keydownHandler;

            keydownHandler = function (event) {
                var intKeyCode = event.which || event.keyCode;

                if (intKeyCode === 13 &&
                    document.getElementById('old-password').value &&
                    document.getElementById('new-password').value &&
                    document.getElementById('new-password-confirm').value) {
                    GS.triggerEvent(document.getElementById('button-change-password'), 'click');

                } else {
                    if (document.getElementById('old-password').value &&
                        document.getElementById('new-password').value &&
                        document.getElementById('new-password-confirm').value) {
                        document.getElementById('button-change-password').removeAttribute('disabled');
                    } else {
                        document.getElementById('button-change-password').setAttribute('disabled');
                    }
                }
            };

            document.getElementById('old-password').addEventListener('keydown', keydownHandler);
            document.getElementById('new-password').addEventListener('keydown', keydownHandler);
            document.getElementById('new-password-confirm').addEventListener('keydown', keydownHandler);

            document.getElementById('button-change-password').addEventListener('click', function () {
                var newPassword, parameters;

                if (document.getElementById('new-password').value === document.getElementById('new-password-confirm').value) {
                    parameters = 'action=change_pw' +
                                '&password_old=' + encodeURIComponent(document.getElementById('old-password').value) +
                                '&password_new=' + encodeURIComponent(document.getElementById('new-password').value);

                    document.getElementById('old-password').value = '';
                    document.getElementById('new-password').value = '';
                    document.getElementById('new-password-confirm').value = '';

                    GS.ajaxJSON(
                        location.pathname.indexOf('/env/') === 0 ?
                        '/env/auth' : '/postage/auth', parameters, function (data, error) {
                        if (!error) {
                            GS.pushMessage('Password Successfully Changed', 1000);
                            GS.closeDialog(dialog, 'change');
                        } else {
                            document.getElementById('pword-error').textContent = data.error_text;
                        }
                    });
                } else {
                    document.getElementById('pword-error').textContent = 'New Password Doesn\'t Match Confirm New Password.';
                }
            });
        });
    }

    GS.userChangePassword = function () {
        changePassword('env', 'User');
    };

    //GS.superChangePassword = function () {
    //    changePassword('postage', 'SUPERUSER');
    //};
})();

// check if the user is logged in as a normal user
// if there is no login dialog create it then open it
GS.normalUserLogin = function (loggedInCallback, strOldError, strDefaultSubDomain) {
    'use strict';
    GS.removeAllLoaders();

    if (!window.userLogin) {
        window.userLogin = true;

        // this action checks to see if we are logged in as a super user
        // if not, open a login dialog
        GS.ajaxJSON('/env/action_info', '', function (data, error) {
            var templateElement = document.createElement('template');

            if (!error && data.dat) {
                if (typeof loggedInCallback === 'function') {
                    loggedInCallback(data.dat, strDefaultSubDomain);
                }
            } else {
                templateElement.innerHTML = ml(function () {/*
                    <gs-page>
                        <gs-header><center><h3>Login</h3></center></gs-header>
                        <gs-body padded>
                            You are not currently logged in, please fill in the login form below.<br /><br />
                            <label for="normal-uname">Username:</label>
                            <gs-text id="normal-uname" autocapitalize="off" autocomplete="off" autocorrect="off"></gs-text>
                            <label for="normal-pword">Password:</label>
                            <gs-text id="normal-pword" type="password"></gs-text>
                            {{ERROR}}
                        </gs-body>
                        <gs-footer>
                            <gs-grid>
                                <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
                                <gs-block><gs-button id="normal-login">Log In</gs-button></gs-block>
                            </gs-grid>
                        </gs-footer>
                    </gs-page>
                */}).replace('{{ERROR}}', (strOldError ? '<br /><div style="color: #FF0000">' + strOldError + '</div>' : ''));

                if (GS.getCookie('greyspots_uname')) {
                    xtag.query(templateElement.content, '#normal-uname')[0].setAttribute('value', decodeURIComponent(GS.getCookie('greyspots_uname')));
                    xtag.query(templateElement.content, '#normal-pword')[0].setAttribute('autofocus', '');
                } else {
                    xtag.query(templateElement.content, '#normal-uname')[0].setAttribute('autofocus', '');
                }

                GS.openDialog(templateElement, function () {
                    var dialog = this;

                    document.getElementById('normal-pword').addEventListener('keydown', function (event) {
                        var intKeyCode = event.which || event.keyCode;

                        if (intKeyCode === 13) {
                            GS.triggerEvent(document.getElementById('normal-login'), 'click');
                        }
                        //if (this.value) {
                        //    document.getElementById('normal-login').removeAttribute('disabled');
                        //} else {
                        //    document.getElementById('normal-login').setAttribute('disabled', '');
                        //}
                    });

                    //document.getElementById('normal-pword').addEventListener('keyup', function () {
                    //    if (this.value) {
                    //        document.getElementById('normal-login').removeAttribute('disabled');
                    //    } else {
                    //        document.getElementById('normal-login').setAttribute('disabled', '');
                    //    }
                    //});

                    document.getElementById('normal-login').addEventListener('click', function () {
                        var strUserName = document.getElementById('normal-uname').value, strLink;

                        if (document.getElementById('normal-pword').value) {
                            GS.addLoader('log-in', 'Logging In...');

                            GS.ajaxJSON('/env/auth', 'action=login' +
                                                       '&username=' + encodeURIComponent(document.getElementById('normal-uname').value) +
                                                       '&password=' + encodeURIComponent(document.getElementById('normal-pword').value),
                                                       function (data, error) {
                                GS.removeLoader('log-in');
                                GS.closeDialog(dialog, '');
                                window.userLogin = false;

                                if (!error) {
                                    GS.setCookie('greyspots_uname', strUserName, 30);

                                    if (typeof loggedInCallback === 'function') {
                                        if (window.location.hostname.substring(0, window.location.hostname.indexOf('.')) ===
                                                        strDefaultSubDomain) {
                                            GS.normalUserLogin(loggedInCallback, '', strDefaultSubDomain);
                                        } else {
                                            loggedInCallback(data.dat, strDefaultSubDomain);
                                        }
                                    }

                                } else {
                                    GS.normalUserLogin(loggedInCallback, data.error_text, strDefaultSubDomain);
                                }
                            });
                        }
                    });
                });
            }
        });
    }
};
//jslint white:true

(function () {
    'use strict';

    // encodeForTabDelimited('asdf\\asdf\\asdf\r\nasdf\r\nasdf\tasdf\tasdf')
    function encodeForTabDelimited(strValue) {
        return  strValue === '\\N' ? strValue :
                strValue.replace(/\\/g, '\\\\') // double up backslashes
                        .replace(/\n/g, '\\n')  // replace newline with the text representation '\n'
                        .replace(/\r/g, '\\r')  // replace carriage return with the text representation '\r'
                        .replace(/\t/g, '\\t')  // replace tab with the text representation '\t'
                        .replace(/^NULL$/g, '\\N');
    }

    GS.bolPreventErrors = false;
    function webSocketConnectionErrorDialog(socket, addinText, retryCallback, cancelCallback) {

        if (!document.getElementById('dialog-from-dialog-ws-conn-error') && GS.bolPreventErrors === false) {
            var templateElement = document.createElement('template');

            GS.removeAllLoaders();

            templateElement.setAttribute('id', 'dialog-ws-conn-error');
            templateElement.setAttribute('data-theme', 'error');
            templateElement.innerHTML = ml(function () {/*
                <gs-page>
                    <gs-header><center><h3>There was an error!</h3></center></gs-header>
                    <gs-body padded>
                        <pre style="white-space: pre-wrap;">
    There has been an error with the Database connection.{{ADDIN}}</pre>
                    </gs-body>
                    <gs-footer>
                        <gs-grid gutter reflow-at="420">
                            <gs-block><gs-button dialogclose>Try to reconnect</gs-button></gs-block>
                            <gs-block><gs-button dialogclose>Dismiss so I can copy my progress</gs-button></gs-block>
                        </gs-grid>
                    </gs-footer>
                </gs-page>
            */}).replace('{{ADDIN}}', decodeURIComponent((addinText ? '\n\n' + addinText : '')));

            GS.openDialog(templateElement, '', function (event, strAnswer) {
                if (strAnswer === 'Try to reconnect') {
                    GS.closeSocket(GS.envSocket);
                    GS.envSocket = GS.openSocket('env', socket.GSSessionID, socket.notifications);
                } else {
                    GS.bolPreventErrors = true;
                }
            });
        }
    }

    function webSocketNormalizeError(event) {
        var i;
        var len;
        var arrLines;
        var arrLine;
        var strData;
        var jsnRet = {
            'error_title': '',
            'error_text': '',
            'error_detail': '',
            'error_hint': '',
            'error_query': '',
            'error_context': '',
            'error_position': '',
            'error_notice': '',
            'original_data': event
        };

        event = event || {};

        jsnRet.error_text = event.reason || '';

        // if there is message data: parse it
        if (event.data) {
            strData = event.data;

            // strip out messageid
            if (strData.substring(0, strData.indexOf(' ')) === 'messageid') {
                strData = strData.substring(strData.indexOf('\n') + 1);
            }

            // strip out response number
            if (strData.substring(0, strData.indexOf(' ')) === 'responsenumber') {
                strData = strData.substring(strData.indexOf('\n') + 1);
            }

            // strip out response number
            if (strData.substring(0, strData.indexOf(' ')) === 'transactionid') {
                strData = strData.substring(strData.indexOf('\n') + 1);
            }

            // strip out fatal
            if (strData.indexOf('FATAL\n') === 0) {
                strData = strData.substring(strData.indexOf('\n') + 1);
            }

            // strip out "Query failed: "
            if (strData.indexOf('Query failed: ') === 0) {
                strData = strData.substring('Query failed: '.length);
            }

            // save error text in case we dont find any error part labels
            jsnRet.error_text = strData;
            jsnRet.orig_error_text = strData;

            // trim and split on return for parsing
            arrLines = strData.trim().split('\n');

            for (i = 0, len = arrLines.length; i < len; i += 1) {
                arrLine = arrLines[i].split('\t');

                jsnRet[arrLine[0]] = GS.decodeFromTabDelimited(arrLine[1] || '');
            }

            if (!jsnRet.error_text) {
                jsnRet = {
                    'error_text': arrLines[0]
                };
            }
        }

        // get error title and error hint
        if (event.code === 1001) {
            jsnRet.error_title = 'Going Away';
            jsnRet.error_hint = 'The server or client closed the connection because of server shutdown or navigating away from the page.';

        } else if (event.code === 1002) {
            jsnRet.error_title = 'Protocol';
            jsnRet.error_hint = 'The connection was closed because of error related to the protocol used.';

        } else if (event.code === 1003) {
            jsnRet.error_title = 'Unsupported Data';
            jsnRet.error_hint = 'The connection was closed because the data that was received was not it a supported format.';

        } else if (event.code === 1005) {
            jsnRet.error_title = 'No Status Received';
            jsnRet.error_hint = 'The connection was closed because it received an empty status.';

        } else if (event.code === 1006) {
            jsnRet.error_title = 'Abnormal Closure';
            jsnRet.error_hint = 'The connection was closed because of abnormal circumstances.';

        } else if (event.code === 1007) {
            jsnRet.error_title = 'Invalid Payload Data';
            jsnRet.error_hint = 'The connection was closed because the payload type did not match the defined message type.';

        } else if (event.code === 1008) {
            jsnRet.error_title = 'Policy Violation';
            jsnRet.error_hint = 'The connection was closed because policy governing this connection was violated.';

        } else if (event.code === 1009) {
            jsnRet.error_title = 'Message Too Big';
            jsnRet.error_hint = 'The connection was closed because the message was too long for it to proccess.';

        } else if (event.code === 1010) {
            jsnRet.error_title = 'Mandatory Extension';
            jsnRet.error_hint = 'The client closed the connection because the server was supposed to negotiate extension(s) but it did not.';

        } else if (event.code === 1011) {
            jsnRet.error_title = 'Internal Server';
            jsnRet.error_hint = 'The server closed the connection because it could not fulfill the request.';

        } else if (event.code === 1015) {
            jsnRet.error_title = 'TLS handshake';
            jsnRet.error_hint = 'The connection was closed because the handshake failed.';
        }

        //console.log(jsnRet);

        return jsnRet;
    }

    function cleanErrorValue(strValue) {
        strValue = strValue || '';

        if (strValue.indexOf('DB_exec failed:') !== -1) {
            strValue = strValue.replace(/[.\s\S]*DB_exec\ failed:/mi, '');
        }

        if (strValue.indexOf('Query failed:') !== -1) {
            strValue = strValue.replace(/[.\s\S]*Query\ failed:/mi, '');
        }

        if (strValue.indexOf('FATAL') !== -1) {
            strValue = strValue.replace(/[.\s\S]*FATAL/mi, '');
        }

        strValue = strValue
                        .replace(/\\n/gi, '\n')
                        .replace(/\\t/gi, '\t')
                        .replace(/\[.*\]/gi, '')
                        .replace(/\([0-9]*\)/gi, '');

        return GS.trim(strValue.trim(), '"');
    }

    function errorJSONToHTML(errorJSON) {
        //console.log(errorJSON);
        return '<pre style="word-break: break-all; white-space: pre-wrap;">' +
                    (errorJSON.error_title ?
                        'There was ' +
                            (
                                ['A', 'E', 'I', 'O', 'U']
                                    .indexOf(errorJSON.error_title[0].toUpperCase()) === -1
                                        ? 'a'
                                        : 'an'
                            ) +
                            ' "' + encodeHTML(errorJSON.error_title) + '" error:' :
                        'There was an error:') +
                        (
                            errorJSON.error_text     ? '<br /><br />' + encodeHTML(errorJSON.error_text)
                            :   (errorJSON.error_hint     ? '<br /><br />HINT: ' + encodeHTML(errorJSON.error_hint) : '') +
                                (errorJSON.error_detail   ? '<br /><br />DETAIL: ' + encodeHTML(errorJSON.error_detail) : '') +
                                (errorJSON.error_query    ? '<br /><br />QUERY: ' + encodeHTML(errorJSON.error_query) : '') +
                                (errorJSON.error_position ? '<br /><br />ERROR POSITION: ' + encodeHTML(errorJSON.error_position) : '') +
                                (errorJSON.error_context  ? '<br /><br />CONTEXT: ' + encodeHTML(errorJSON.error_context) : '') +
                                (errorJSON.error_notice   ? '<br /><br /><br />' + encodeHTML(errorJSON.error_notice) : '')
                        ) +
                '</pre>';
    }

    GS.webSocketErrorDialog = function (jsnError, tryAgainCallback, cancelCallback) {
        if (GS.bolPreventErrors === false) {
            var templateElement = document.createElement('template'), strHTML, jsnErrorClean;

            jsnErrorClean = {};

            jsnErrorClean.error_text     = cleanErrorValue(jsnError.error_text);
            jsnErrorClean.error_hint     = cleanErrorValue(jsnError.error_hint);
            jsnErrorClean.error_detail   = cleanErrorValue(jsnError.error_detail);
            jsnErrorClean.error_query    = cleanErrorValue(jsnError.error_query);
            jsnErrorClean.error_position = cleanErrorValue(jsnError.error_position);
            jsnErrorClean.error_context  = cleanErrorValue(jsnError.error_context);
            jsnErrorClean.error_notice   = cleanErrorValue(jsnError.error_notice);

            templateElement.setAttribute('data-theme', 'error');
            strHTML = ml(function () {/*
                <gs-page>
                    <gs-header><center><h3>There was an error!</h3></center></gs-header>
                    <gs-body padded>
                        {{HTML}}
                        <br />
                        <gs-button class="error-button-show-full-text">Show Full Error Text</gs-button>
                    </gs-body>
                    <gs-footer>{{BUTTONS}}</gs-footer>
                </gs-page>
            */}).replace('{{HTML}}', errorJSONToHTML(jsnErrorClean));

            var openFunction = function () {
                xtag.query(this, '.error-button-show-full-text')[0].addEventListener('click', function () {
                    var templateElement = document.createElement('template');

                    templateElement.innerHTML = ml(function () {/*
                        <gs-page>
                            <gs-header><center><h3>Full Error Text</h3></center></gs-header>
                            <gs-body padded>
                                {{HTML}}
                            </gs-body>
                            <gs-footer><gs-button dialogclose>Done</gs-button></gs-footer>
                        </gs-page>
                    */}).replace('{{HTML}}', errorJSONToHTML(jsnError));

                    GS.openDialog(templateElement);
                });
            };

            if (typeof tryAgainCallback === 'function') {
                templateElement.innerHTML =
                    strHTML.replace(
                        '{{BUTTONS}}',
                        '<gs-grid>' +
                        '    <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>' +
                        '    <gs-block><gs-button dialogclose listen-for-return>Try Again</gs-button></gs-block>' +
                        '</gs-grid>'
                    );

                GS.openDialog(templateElement, openFunction, function (event, strAnswer) {
                    if (strAnswer === 'Try Again') {
                        tryAgainCallback(strAnswer);
                    } else {
                        if (typeof cancelCallback === 'function') {
                            cancelCallback(strAnswer);
                        }
                    }
                });

            } else {
                templateElement.innerHTML = strHTML.replace('{{BUTTONS}}', '<gs-button dialogclose listen-for-return>Ok</gs-button>');
                GS.openDialog(templateElement, openFunction);
            }
        }
    };

    GS.websockets = new Array();

    GS.closeAllSockets = function () {
        var i, len = GS.websockets.length;
        for (i = 0;i < len;i++) {
            GS.closeSocket(GS.websockets[i]);
        }
    };

    var sequence = 0, jsnMessages = {}, arrWaitingCalls = [];
    GS.openSocket = function (strLink, relinkSessionID, relinkSessionNotifications, socketname) {
        var strLoc = window.location.toString(),
            intUrlStart = strLoc.indexOf('/postage/') + 9,
            strConn = strLoc.substring(intUrlStart, strLoc.substring(intUrlStart).indexOf('/') + intUrlStart),
            strURL = '';

        if (strLoc.indexOf('/postage/') >= 0) {
            strURL =    (window.location.protocol.toLowerCase().indexOf('https') === 0 ? 'wss' : 'ws') +
                        '://' + (window.location.host || window.location.hostname) + '/postage/' + strConn + '/' + strLink +
                        (relinkSessionID ? '?sessionid=' + relinkSessionID : '');
        } else {
            strURL =    (window.location.protocol.toLowerCase().indexOf('https') === 0 ? 'wss' : 'ws') +
                        '://' + (window.location.host || window.location.hostname) + '/' + strLink +
                        (relinkSessionID ? '?sessionid=' + relinkSessionID : '');
        }

        var socket = new WebSocket(strURL);
        if (socketname) {
            GS.websockets[socketname] = socket;
        }

        GS.websockets.push(socket);

        if (relinkSessionID) {
            socket.GSSessionID = relinkSessionID;
            socket.oldSessionID = relinkSessionID;
        }
        if (relinkSessionNotifications) {
            socket.notifications = relinkSessionNotifications;
        } else {
            socket.notifications = [];
        }
        socket.onmessage = function (event) {
            var message = event.data, messageID, responseNumber, key, strError, arrLines, i, len, jsnMessage, startFrom;

            if (typeof (message) === 'object') {
                //window.binaryTestTEST = message;
                //console.log(message);
                var buf = message;
                message = String.fromCharCode.apply(null, new Uint8Array(buf));
                //console.log(buf);
                //console.log(message);
            }

            // if sessionid
            if (message.indexOf('sessionid = ') === 0) {
                socket.GSSessionID = message.substring('sessionid = '.length, message.indexOf('\n'));
                GS.triggerEvent(window, 'socket-connect');

                for (key in jsnMessages) {
                    jsnMessage = jsnMessages[key];

                    if (
                        jsnMessage &&
                        (
                            jsnMessage.session === socket.GSSessionID ||
                            jsnMessage.session === socket.oldSessionID
                        ) &&
                        jsnMessage.bolFinished === false
                    ) {

                        jsnMessage.session = socket.GSSessionID;

                        startFrom = 1;
                        for (i = 0, len = jsnMessage.arrResponseNumbers.length; i < len; i += 1) {
                            // if there is a difference between the current response number and the
                            //      startFrom: stop looping because startFrom now holds the number that we want
                            if (startFrom !== jsnMessage.arrResponseNumbers[i]) {
                                break;
                            }
                            startFrom += 1;
                        }

                        GS.requestFromSocket(socket, 'SEND FROM\t' + startFrom, '', jsnMessage.id);
                    }
                }

                for (i = 0, len = arrWaitingCalls.length; i < len; i += 1) {
                    arrWaitingCalls[0]();
                    arrWaitingCalls.splice(0, 1);
                }

            // else
            } else {
                messageID = message.substring('messageid = '.length, message.indexOf('\n'));
                message = message.substring(message.indexOf('\n') + 1);

                jsnMessage = jsnMessages[messageID];

                // if there is a message entry for this message ID
                if (jsnMessage) {
                    arrLines = message.split('\n');

                    // if there is no response number: assume this is the last message and mark the message as finished
                    if (message.indexOf('responsenumber = ') === -1 ||
                        (
                            message.indexOf('responsenumber = ') === 0 &&
                            (
                                arrLines[1] === 'TRANSACTION COMPLETED' ||
                                arrLines[2] === 'OK'
                            )
                        )) {
                        jsnMessage.bolFinished = true;
                    }

                    // if there is a response number
                    if (message.indexOf('responsenumber = ') === 0) {
                        // get message number
                        responseNumber = message.substring('responsenumber = '.length, message.indexOf('\n'));
                        message = message.substring(message.indexOf('\n') + 1);

                        // append message number and message content to arrays
                        jsnMessage.arrResponseNumbers.push(parseInt(responseNumber, 10));
                        jsnMessage.arrResponses.push(message);

                        // send confirm signal
                        GS.requestFromSocket(socket, 'CONFIRM\t' + responseNumber, '', messageID);
                    }

                    // ERROR CHECK
                    arrLines = message.split('\n');

                    // if there is a transactionid: look at the second line
                    if (arrLines[0].indexOf('transactionid') === 0 && arrLines[1] === 'FATAL') {
                        strError = 'error';
                        message = message.substring(message.indexOf('\n') + 1);
                        message = message.substring(message.indexOf('\n') + 1);
                        message = arrLines[0] + '\n' + message;

                    // else: check the first line
                    } else if (arrLines[0] === 'FATAL') {
                        strError = 'error';
                        message = message.substring(message.indexOf('\n') + 1);
                    }

                    // if transaction complete: clear message arrays and mark as finised
                    if (message === 'TRANSACTION COMPLETED') { // || message === 'EMPTY\n\\.'
                        jsnMessage.arrResponseNumbers = [];
                        jsnMessage.arrResponses = [];
                        jsnMessage.bolFinished = true;
                    }

                    // if there was a FATAL: mark as finished and apply callback
                    if (strError) {
                        jsnMessage.bolFinished = true;
                        jsnMessage.callback.apply(null, [message, strError, webSocketNormalizeError(event)]);

                    // else: call callback with message
                    } else {
                        jsnMessage.callback.apply(null, [message]);
                    }

                    if (jsnMessage.bolFinished === true) {
                        delete jsnMessages[messageID];
                    }

                // else if the messageID is 'NULL': notification from the server
                } else if (messageID === 'NULL') {
                    socket.notifications.push(message);
                    GS.triggerEvent(window, 'notification', {'socket': socket, 'message': message});
                }
            }
        };

        socket.onopen = function (event) {

        };

        socket.onerror = function (event) {
            var i, len;

            console.log('SOCKET ERROR', event);
            socket.bolError = true;
            //socket.stayClosed = true;

            //for (i = 0, len = arrWaitingCalls.length; i < len; i += 1) {
            //    arrWaitingCalls[0]();
            //    arrWaitingCalls.splice(0, 1);
            //}
        };

        socket.onclose = function (event) {
            console.log('SOCKET CLOSING', socket.stayClosed, socket.bolError, event);

            // error closure dialog
            if (socket.bolError && arrWaitingCalls.length > 0) {
                // abnormal closure
                if (event.code === 1006) {
                    webSocketConnectionErrorDialog(socket, 'The connection to the database has been closed. We cannot display the reasons for this closure because the browser does not give us access to those details, please check the server logs for the error details.');

                // protocol error
                } else if (event.code === 1002) {
                    webSocketConnectionErrorDialog(socket, 'The connection to the database has been closed. Either the server or the browser has closed the connection because of a Websocket Protocol error.');

                // type error
                } else if (event.code === 1003) {
                    webSocketConnectionErrorDialog(socket, 'The connection to the database has been closed. Either the server or the browser has closed the connection because of it was sent a data type it could not understand.');
                } else {
                    webSocketConnectionErrorDialog(socket, 'The connection to the database has been closed. The cause of this is unknown.');
                }
            }

            if (!socket.stayClosed) {
                setTimeout(function() {
                    console.log('ATTEMPTING SOCKET RE-OPEN', socket);
                    GS.triggerEvent(window, 'socket-reconnect');
                    if (socketname) {
                        GS.closeSocket(GS.websockets[socketname]);
                        GS.websockets[socketname] = GS.openSocket('env', GS.websockets[socketname].GSSessionID, GS.websockets[socketname].notifications);
                    } else {
                        GS.closeSocket(GS.envSocket);
                        GS.envSocket = GS.openSocket('env', GS.envSocket.GSSessionID, GS.envSocket.notifications);
                    }
                }, 1000);
            } else {
                if (socket.bolError) {
                    console.log('SOCKET NOT RE-OPENING DUE TO ERROR');
                } else {
                    console.log('SOCKET NOT RE-OPENING DUE TO MANUAL CLOSE');
                }
            }
        };

        return socket;
    };

    GS.requestFromSocket = function (socket, strMessage, callback, forceMessageID) {
        var oldOnOpen, messageID;

        if (!socket || socket.readyState === socket.CLOSED) {
            if (!GS.envSocket || GS.envSocket.readyState === socket.CLOSED) {
                //console.trace('ATTEMPTING SOCKET RE-OPEN 2');
                GS.envSocket = GS.openSocket('env');
            }
            socket = GS.envSocket;
        }

        // if the socket is open: register callback and send request
        if (socket.readyState === socket.OPEN && socket.GSSessionID) {

            if (!forceMessageID) {
                sequence += 1;
                messageID = socket.GSSessionID + '_' + sequence;
                jsnMessages[messageID] = {
                    'id': messageID,
                    'session': socket.GSSessionID,
                    'callback': callback,
                    'arrResponseNumbers': [],
                    'arrResponses': [],
                    'bolFinished': false
                };

            } else {
                messageID = forceMessageID;
            }

            if (typeof (strMessage) === 'object') {
                jsnMessages[messageID].parameters = new Blob(['messageid = ' + messageID + '\n', strMessage], {type: 'application/x-binary'});
            } else {
                jsnMessages[messageID].parameters = 'messageid = ' + messageID + '\n' + strMessage;
            }
            socket.send(jsnMessages[messageID].parameters);
            //console.log('SOCKET MESSAGE SENT                   ', 'messageid = ' + sequence);// + '\n' + strMessage);

            return messageID;

        // if the socket is connecting: bind socket onopen to call this funtion again
        } else if (socket.readyState === socket.CONNECTING || socket.readyState === socket.OPEN) {
            //console.log('SOCKET REQUEST WHILE CONNECTING       ');

            arrWaitingCalls.push(function () {
                GS.requestFromSocket(socket, strMessage, callback);
            });

        // if the socket is closed: error
        } else if (socket.readyState === socket.CLOSED) {
            //console.log('SOCKET REQUEST WHILE CLOSED           ');
            callback.apply(null, ['Socket Is Closed', 'error', webSocketNormalizeError({'reason': 'Socket Is Closed'})]);

        // if the socket is closing: error
        } else if (socket.readyState === socket.CLOSING) {
            //console.log('SOCKET REQUEST WHILE CLOSING          ');
            callback.apply(null, ['Socket Is Closing', 'error', webSocketNormalizeError({'reason': 'Socket Is Closing'})]);
        }
    };


    GS.requestActionFromSocket = function (socket, strSchema, strObject, strArgs, finalCallback) {
        var strMessage = 'ACTION\t' + encodeForTabDelimited(strSchema) + '\t' + encodeForTabDelimited(strObject) +
                            '\t' + encodeForTabDelimited(strArgs) + '\n',
            intResponse = 0, strRet;

        //console.log(strMessage);

        GS.requestFromSocket(socket, strMessage, function (data, error, errorData) {
            var arrLines, i, len;
            if (!error) {
                if (intResponse === 0) {
                    strRet = data;

                } else {
                    finalCallback(strRet, error);
                }

            } else {
                finalCallback(errorData, error);
            }
            intResponse += 1;
        });
    };

    // abstraction function for ease of use of the RAW format
    GS.requestRawFromSocket = function (socket, strQuery, callback, bolAutocommit) {
        var intResponsePart = 0, intQueryNumber = 0, intCallbackNumber = 0, intCallbackNumberThisQuery = 0
          , intResponseNumberThisQuery = 0, arrMessages, arrColumnNames, arrColumnTypes
          , arrStart, dteStart, arrEnd, dteEnd, intRows;

        bolAutocommit = bolAutocommit !== undefined ? bolAutocommit : true;
        return GS.requestFromSocket(socket, 'RAW' + (!bolAutocommit ? '\tDISABLE AUTOCOMMIT\n' : '\n') + strQuery, function (data, error, errorData) {
            var arrRecords, arrLines, i, len, strMode;

            if (!error) {
                if (intResponseNumberThisQuery === 0) {
                    // clear variables
                    strQuery = '';
                    arrMessages = [];
                    arrColumnNames = [];
                    arrColumnTypes = [];
                }

                // if QUERY is found: reset response part to 0
                if (data.indexOf('QUERY\n') === 0) {
                    //console.log('Per Query Reset');
                    intResponsePart = 0;
                    intCallbackNumberThisQuery = 0;
                }

                // if first line is 'Rows Affected': add one to intResponsePart
                if (data.indexOf('Rows Affected\n') === 0 || data === 'EMPTY' || data === 'TRANSACTION COMPLETED' || data === 'TRANSACTION OPEN') {
                    intResponsePart += 1;
                }

                //console.log('1***', data);
                //console.log(intResponsePart, data);

                // response part 0 is:
                //      strQuery
                //      arrMessages
                //      arrColumnNames
                //      arrColumnTypes
                if (intResponsePart === 0) {
                    //console.log('2***');
                    // split lines
                    arrLines = data.split('\n');

                    // loop through lines
                    for (i = 0, len = arrLines.length; i < len; i += 1) {
                        // if mode line: set mode
                        if (arrLines[i].indexOf('QUERY\t') === 0 ||
                            arrLines[i].indexOf('START\t') === 0 ||
                            arrLines[i].indexOf('END\t') === 0 ||
                            arrLines[i].indexOf('ROWS\t') === 0 ||
                            arrLines[i].indexOf('DEBUG\t') === 0 ||
                            arrLines[i].indexOf('LOG\t') === 0 ||
                            arrLines[i].indexOf('INFO\t') === 0 ||
                            arrLines[i].indexOf('NOTICE\t') === 0 ||
                            arrLines[i].indexOf('WARNING\t') === 0 ||
                            arrLines[i] === 'COLUMNS') {

                            if (arrLines[i] === 'COLUMNS') {
                                strMode = arrLines[i];
                            } else {
                                strMode = arrLines[i].substring(0, arrLines[i].indexOf('\t'));
                            }
                        }

                        //console.log(strMode, arrLines[i]);

                        // if mode is QUERY: save query
                        if (strMode === 'QUERY') {
                            strQuery = GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1));
                            //console.log(arrLines[i], strQuery);

                        // if mode is START: save start
                        } else if (strMode === 'START') {
                            arrStart = GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1)).split('\t');
                            dteStart = new Date(arrStart[0] + ' ' + arrStart[1] + ' GMT');
                            if (arrStart[2]) {
                                dteStart.setMilliseconds(parseInt(arrStart[2], 10) / 1000);
                            }
                            //console.log(strStart, dteStart);

                        // if mode is END: save end
                        } else if (strMode === 'END') {
                            arrEnd = GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1)).split('\t');
                            dteEnd = new Date(arrEnd[0] + ' ' + arrEnd[1] + ' GMT');
                            if (arrEnd[2]) {
                                dteEnd.setMilliseconds(parseInt(arrEnd[2], 10) / 1000);
                            }
                            //console.log(strEnd, dteEnd);

                        // if mode is ROWS: save total rows
                        } else if (strMode === 'ROWS') {
                            intRows = parseInt(GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1)), 10);

                        // if mode is DEBUG: add DEBUG to array
                        } else if (strMode === 'DEBUG') {
                            arrMessages.push({
                                'level': 'DEBUG',
                                'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                            });

                        // if mode is LOG: add LOG to array
                        } else if (strMode === 'LOG') {
                            arrMessages.push({
                                'level': 'LOG',
                                'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                            });

                        // if mode is INFO: add INFO to array
                        } else if (strMode === 'INFO') {
                            arrMessages.push({
                                'level': 'INFO',
                                'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                            });

                        // if mode is NOTICE: add NOTICE to array
                        } else if (strMode === 'NOTICE') {
                            arrMessages.push({
                                'level': 'NOTICE',
                                'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                            });

                        // if mode is WARNING: add WARNING to array
                        } else if (strMode === 'WARNING') {
                            arrMessages.push({
                                'level': 'WARNING',
                                'content': GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1).replace(/\\n$/,''))
                            });

                        // if mode is COLUMNS: get COLUMNS
                        } else if (strMode === 'COLUMNS') {
                            arrColumnNames = arrLines[i + 1].split('\t');
                            arrColumnTypes = arrLines[i + 2].split('\t');
                            intResponsePart += 1;
                            break;
                        }
                    }

                } else if (intResponsePart >= 1) {
                    //console.log(intQueryNumber, intCallbackNumber, intCallbackNumberThisQuery,
                    //            strQuery, arrMessages, arrColumnNames, arrColumnTypes, data);
                    //console.log('3***');
                    if (typeof callback === 'function') {
                        //console.log('4*** CALLBACK');
                        callback({
                            'intQueryNumber': intQueryNumber,
                            'intCallbackNumber': intCallbackNumber,
                            'intCallbackNumberThisQuery': intCallbackNumberThisQuery,
                            'strQuery': strQuery,
                            'dteStart': dteStart,
                            'dteEnd': dteEnd,
                            'intRows': intRows,
                            'arrMessages': arrMessages,
                            'arrColumnNames': arrColumnNames,
                            'arrColumnTypes': arrColumnTypes,
                            'strMessage': (data !== 'TRANSACTION COMPLETED' || data === 'TRANSACTION OPEN' ? data : ''),
                            'bolLastMessage': (data === 'TRANSACTION COMPLETED' || data === 'TRANSACTION OPEN'),
							'bolTransactionOpen': (data === 'TRANSACTION OPEN')
                        }, error);

                        intCallbackNumber += 1;
                        intCallbackNumberThisQuery += 1;
                    }
                }

                intResponseNumberThisQuery += 1;

                if (data === '\\.' || data.indexOf('Rows Affected\n') === 0) {
                    intQueryNumber += 1;
                    intCallbackNumberThisQuery = 0;
                    intResponsePart = 0;
                    intResponseNumberThisQuery = 0;
                }

            } else {
                // if QUERY is found: reset response part to 0
                if (data.indexOf('QUERY\n') === 0) {
                    //console.log('Per Query Reset');
                    intResponsePart = 0;
                    intCallbackNumberThisQuery = 0;
                }

                if (intResponsePart === 0) {
                    //console.log('2***');
                    // split lines
                    arrLines = data.split('\n');

                    // loop through lines
                    for (i = 0, len = arrLines.length; i < len; i += 1) {
                        // if mode line: set mode
                        if (arrLines[i].indexOf('QUERY\t') === 0 ||
                            arrLines[i].indexOf('START\t') === 0 ||
                            arrLines[i].indexOf('END\t') === 0 ||
                            arrLines[i].indexOf('ROWS\t') === 0 ||
                            arrLines[i].indexOf('DEBUG\t') === 0 ||
                            arrLines[i].indexOf('LOG\t') === 0 ||
                            arrLines[i].indexOf('INFO\t') === 0 ||
                            arrLines[i].indexOf('NOTICE\t') === 0 ||
                            arrLines[i].indexOf('WARNING\t') === 0 ||
                            arrLines[i] === 'COLUMNS') {

                            if (arrLines[i] === 'COLUMNS') {
                                strMode = arrLines[i];
                            } else {
                                strMode = arrLines[i].substring(0, arrLines[i].indexOf('\t'));
                            }
                        }

                        //console.log(strMode, arrLines[i]);

                        // if mode is QUERY: save query
                        if (strMode === 'QUERY') {
                            strQuery = GS.decodeFromTabDelimited(arrLines[i].substring(arrLines[i].indexOf('\t') + 1));
                            //console.log(arrLines[i], strQuery);

                        // if mode is COLUMNS: get COLUMNS
                        } else if (strMode === 'COLUMNS') {
                            break;
                        }
                    }
                }

                errorData.strQuery = strQuery;
                errorData.arrMessages = arrMessages
                if (typeof callback === 'function') {
                    callback(errorData, error);
                }
            }
        });
    };

    GS.requestSelectFromSocket = function (socket, strSchema, strObject, strReturnCols, strWhere, strOrd, strLimit, strOffset, finalCallback) {
        var strMessage = 'SELECT\t' + encodeForTabDelimited(strSchema) + '\t' + encodeForTabDelimited(strObject) +
                            '\nRETURN\t' + strReturnCols + '\n\n' +
                            'where\t' + (strOrd ? 'order by\t' : '') + 'limit\toffset\n' +
                            encodeForTabDelimited(strWhere || '1=1') + '\t' + (strOrd ? encodeForTabDelimited(strOrd) + '\t' : '') +
                            encodeForTabDelimited(strLimit || 'ALL') + '\t' + encodeForTabDelimited(strOffset || '0'),
            intResponse = 0, intCallback = 0, arrColumnNames, arrColumnTypes, arrDecodedColumnNames, arrDecodedColumnTypes;

        //console.log(strMessage);

        GS.requestFromSocket(socket, strMessage, function (data, error, errorData) {
            var arrLines, i, len;
            if (!error) {
                if (intResponse === 0) {
                    arrLines = data.split('\n');
                    arrColumnNames = arrLines[0].split('\t');
                    arrColumnTypes = arrLines[1].split('\t');
                    arrDecodedColumnNames = [];
                    arrDecodedColumnTypes = [];

                    for (i = 0, len = arrColumnNames.length; i < len; i += 1) {
                        arrDecodedColumnNames.push(GS.decodeFromTabDelimited(arrColumnNames[i]));
                    }

                    for (i = 0, len = arrColumnTypes.length; i < len; i += 1) {
                        arrDecodedColumnTypes.push(GS.decodeFromTabDelimited(arrColumnTypes[i]));
                    }

                } else {
                    finalCallback({
                        'arrColumnNames': arrColumnNames,
                        'arrColumnTypes': arrColumnTypes,
                        'arrDecodedColumnNames': arrDecodedColumnNames,
                        'arrDecodedColumnTypes': arrDecodedColumnTypes,
                        'intCallback': intCallback,
                        'strMessage': data
                    }, error);
                    intCallback += 1;
                }

            } else {
                finalCallback(errorData, error);
            }
            intResponse += 1;
        });
    };

    GS.requestArbitrarySelectFromSocket = function (socket, strSQL, strWhere, strOrd, strLimit, strOffset, finalCallback) {
        var strMessage = (
            'SELECT\t' + encodeForTabDelimited(strSQL) +
            '\nRETURN\t*\n\n' +
            'where\t' +
            (strOrd ? 'order by\t' : '') +
            'limit\t' +
            'offset\n' +
            encodeForTabDelimited(strWhere || '1=1') + '\t' +
            (strOrd ? encodeForTabDelimited(strOrd) + '\t' : '') +
            encodeForTabDelimited(strLimit || 'ALL') + '\t' +
            encodeForTabDelimited(strOffset || '0')
        );
        var intResponse = 0;
        var intCallback = 0;
        var arrColumnNames;
        var arrColumnTypes;
        var arrDecodedColumnNames;
        var arrDecodedColumnTypes;

        //console.log(strMessage);

        GS.requestFromSocket(socket, strMessage, function (data, error, errorData) {
            var arrLines, i, len;
            if (!error) {
                if (intResponse === 0) {
                    arrLines = data.split('\n');
                    arrColumnNames = arrLines[0].split('\t');
                    arrColumnTypes = arrLines[1].split('\t');
                    arrDecodedColumnNames = [];
                    arrDecodedColumnTypes = [];

                    for (i = 0, len = arrColumnNames.length; i < len; i += 1) {
                        arrDecodedColumnNames.push(GS.decodeFromTabDelimited(arrColumnNames[i]));
                    }

                    for (i = 0, len = arrColumnTypes.length; i < len; i += 1) {
                        arrDecodedColumnTypes.push(GS.decodeFromTabDelimited(arrColumnTypes[i]));
                    }

                } else {
                    finalCallback({
                        'arrColumnNames': arrColumnNames,
                        'arrColumnTypes': arrColumnTypes,
                        'arrDecodedColumnNames': arrDecodedColumnNames,
                        'arrDecodedColumnTypes': arrDecodedColumnTypes,
                        'intCallback': intCallback,
                        'strMessage': data
                    }, error);
                    intCallback += 1;
                }

            } else {
                finalCallback(errorData, error);
            }
            intResponse += 1;
        });
    };

    /*
        INSERT	test	rmultiple_pk_test
        RETURN	id1	id2	id3	page_name_pk	id4	test1	test2	test3
        PK	id1	id2	id3	page_name_pk	id4
        SEQ	test.seq1	test.seq2

        page_name_pk	test1	test2	test3
        page_name_pk1	test1	test2	test3
        page_name_pk2	test1	test2	test3
        page_name_pk3	test1	test2	test3
        page_name_pk4	test1	test2	test3



        If a column is being inserted, then the SEQ entry for it needs to be empty
    */
    GS.requestInsertFromSocket = function (socket, strSchema, strObject, strReturnCols, strPkCols, strSeqCols, insertData, beginCallback, confirmCallback, finalCallback) {
        var strMessage = 'INSERT\t' + encodeForTabDelimited(strSchema) + '\t' + encodeForTabDelimited(strObject) +
                         '\nRETURN\t' + strReturnCols +
                         (strPkCols ? '\nPK\t' + strPkCols : '') +
                         (strPkCols ? '\nSEQ\t' + strSeqCols : '') +
                         '\n\n' + insertData;

        //console.log(strMessage);

        GS.requestBegin(socket, function (data, error) {
            var transactionID;

            if (!error) {
                transactionID = data;
                if (typeof beginCallback === 'function') { beginCallback(data, error); }

                GS.requestFromSocket(GS.envSocket, 'transactionid = ' + transactionID + '\n' + strMessage, function (data, error, errorData) {
                    var commitFunction, rollbackFunction;

                    if (!error) {
                        data = data.substring(data.indexOf('\n') + 1); // transactionid
                        //data = data.substring(data.indexOf('\n') + 1); // responsenumber
                    }

                    console.log('INSERT DATA:', data);
                    console.log('INSERT TRANSID:', transactionID);

                    commitFunction = function () {
                        GS.requestCommit(socket, transactionID, function (data, error) {
                            if (!error) { data = data.substring(data.indexOf('\n') + 1); }

                            finalCallback('COMMIT', data, error);
                        });
                    };
                    rollbackFunction = function () {
                        GS.requestRollback(socket, transactionID, function (data, error) {
                            if (!error) { data = data.substring(data.indexOf('\n') + 1); }

                            finalCallback('ROLLBACK', data, error);
                        });
                    };

                    if (!error) {
                        confirmCallback(data, error, transactionID, commitFunction, rollbackFunction);
                    } else {
                        confirmCallback(errorData, error, transactionID, commitFunction, rollbackFunction);
                    }
                });

            } else {
                if (typeof beginCallback === 'function') { beginCallback(data, error); }
            }
        });
    };


    GS.requestUpdateFromSocket = function (socket, strSchema, strObject, strReturnCols, strHashCols, updateData, beginCallback, confirmCallback, finalCallback) {
        var strMessage = 'UPDATE\t' + encodeForTabDelimited(strSchema) + '\t' + encodeForTabDelimited(strObject) +
                         '\nRETURN\t' + strReturnCols +
                         (strHashCols ? '\nHASH\t' + strHashCols : '') +
                         '\n\n' + updateData;

        //console.log(strMessage);

        GS.requestBegin(socket, function (data, error) {
            var transactionID;

            if (!error) {
                transactionID = data;
                if (typeof beginCallback === 'function') { beginCallback(data, error); }

                GS.requestFromSocket(GS.envSocket, 'transactionid = ' + transactionID + '\n' + strMessage, function (data, error, errorData) {
                    var commitFunction, rollbackFunction;

                    if (!error) {
                        data = data.substring(data.indexOf('\n') + 1); // transactionid
                        //data = data.substring(data.indexOf('\n') + 1); // responsenumber
                    }

                    commitFunction = function () {
                        GS.requestCommit(socket, transactionID, function (data, error) {
                            if (!error) { data = data.substring(data.indexOf('\n') + 1); }

                            finalCallback('COMMIT', data, error);
                        });
                    };
                    rollbackFunction = function () {
                        GS.requestRollback(socket, transactionID, function (data, error) {
                            if (!error) { data = data.substring(data.indexOf('\n') + 1); }

                            finalCallback('ROLLBACK', data, error);
                        });
                    };

                    if (!error) {
                        confirmCallback(data, error, transactionID, commitFunction, rollbackFunction);
                    } else {
                        confirmCallback(errorData, error, transactionID, commitFunction, rollbackFunction);
                    }
                });

            } else {
                if (typeof beginCallback === 'function') { beginCallback(data, error); }
            }
        });
    };

    GS.requestDeleteFromSocket = function (socket, strSchema, strObject, strHashCols, deleteData, beginCallback, confirmCallback, finalCallback) {
        var strMessage = 'DELETE\t' + encodeForTabDelimited(strSchema) + '\t' + encodeForTabDelimited(strObject) +
                         (strHashCols ? '\nHASH\t' + strHashCols : '') + '\n\n' +
                         deleteData;

        //console.log(strMessage);

        GS.requestBegin(socket, function (data, error) {
            var transactionID;

            if (!error) {
                transactionID = data;
                if (typeof beginCallback === 'function') { beginCallback(data, error); }

                GS.requestFromSocket(GS.envSocket, 'transactionid = ' + transactionID + '\n' + strMessage, function (data, error, errorData) {
                    var commitFunction, rollbackFunction;

                    if (!error) {
                        data = data.substring(data.indexOf('\n') + 1); // transactionid
                        //data = data.substring(data.indexOf('\n') + 1); // responsenumber
                    }

                    commitFunction = function () {
                        GS.requestCommit(socket, transactionID, function (data, error) {
                            if (!error) { data = data.substring(data.indexOf('\n') + 1); }

                            finalCallback('COMMIT', data, error);
                        });
                    };
                    rollbackFunction = function () {
                        GS.requestRollback(socket, transactionID, function (data, error) {
                            if (!error) { data = data.substring(data.indexOf('\n') + 1); }

                            finalCallback('ROLLBACK', data, error);
                        });
                    };

                    if (!error) {
                        confirmCallback(data, error, transactionID, commitFunction, rollbackFunction);
                    } else {
                        confirmCallback(errorData, error, transactionID, commitFunction, rollbackFunction);
                    }
                });

            } else {
                if (typeof beginCallback === 'function') { beginCallback(data, error); }
            }
        });
    };

    GS.requestBegin = function (socket, callback) {
        GS.requestFromSocket(GS.envSocket, 'BEGIN', function (data, error, errorData) {
            var transactionID;

            if (typeof callback === 'function') {
                if (!error) {
                    transactionID = data.substring('transactionid = '.length, data.indexOf('\n'));
                    callback(transactionID, error);
                } else {
                    callback(errorData, error);
                }
            }
        });
    };

    GS.requestRollback = function (socket, transactionID, callback) {
        GS.requestFromSocket(socket, 'transactionid = ' + transactionID + '\nROLLBACK', function (data, error, errorData) {
            if (typeof callback === 'function') {
                if (!error) {
                    callback(data, error);
                } else {
                    callback(errorData, error);
                }
            }
        });
    };

    GS.requestCommit = function (socket, transactionID, callback) {
        GS.requestFromSocket(socket, 'transactionid = ' + transactionID + '\nCOMMIT', function (data, error, errorData) {
            if (typeof callback === 'function') {
                if (!error) {
                    callback(data, error);
                } else {
                    callback(errorData, error);
                }
            }
        });
    };

    GS.rebootSocket = function (socket) {
        socket.stayClosed = false;
        socket.close();
    };

    GS.closeSocket = function (socket) {
        socket.stayClosed = true;
        socket.close();
    };


    var cacheLedger = [];
    window.testtesttest = cacheLedger;
    GS.requestCachingSelect = function (socket, strSchema, strObject, strColumns, strWhere, strOrd, strLimit, strOffset, callback, bolClearCache) {
        var strKey = (strSchema + strObject + strColumns + strWhere + strOrd + strLimit + strOffset)
          , intQueryIndex, i, len, currentEntry;

        //console.log(strKey, bolClearCache, cacheLedger[strKey]);

        if (bolClearCache) {
            cacheLedger[strKey] = null;
        }

        if (cacheLedger[strKey]) {
            for (i = 0, len = cacheLedger[strKey].results.length; i < len; i += 1) {
                callback(cacheLedger[strKey].results[i][0], cacheLedger[strKey].results[i][1]);
            }
            cacheLedger[strKey].callbacks.push({'callback': callback, 'ready': true});

        } else {
            currentEntry = cacheLedger[strKey] = {
                results: [],
                callbacks: [
                    {'callback': callback, 'ready': true}
                ]
            };

            //console.log('cache:' + bolClearCache);
            GS.requestSelectFromSocket(socket, strSchema, strObject, strColumns
                                     , strWhere, strOrd, strLimit, strOffset
                                     , function (data, error) {
                var i, len;

                //console.log('data:', data);
                currentEntry.results.push([data, error]);

                for (i = 0, len = currentEntry.callbacks.length; i < len; i += 1) {
                    if (currentEntry.callbacks[i].ready) {
                        currentEntry.callbacks[i].callback(data, error);
                    }
                }
            });
        }
    };

    // Nunzio removed on 2017-05-06
    /*
    var cacheQueries = [], cacheCallbacks = [], cacheResults = [];
    GS.requestCachingSelect = function (socket, strSchema, strObject, strColumns, strWhere, strOrd, strLimit, strOffset, callback, bolClearCache) {
        var strKey = (strSchema + strObject + strColumns + strWhere + strOrd + strLimit + strOffset)
          , intQueryIndex, i, len;

        if (bolClearCache) {
            intQueryIndex = cacheQueries.indexOf(strKey);

            cacheQueries.splice(intQueryIndex, 1);
            cacheCallbacks.splice(intQueryIndex, 1);
            cacheResults.splice(intQueryIndex, 1);
        }

        intQueryIndex = cacheQueries.indexOf(strKey);

        if (intQueryIndex !== -1) {
            for (i = 0, len = cacheResults[intQueryIndex].length; i < len; i += 1) {
                callback(cacheResults[intQueryIndex][i][0], cacheResults[intQueryIndex][i][1]);
            }
            cacheCallbacks[intQueryIndex].push({'callback': callback, 'ready': true});

        } else {
            //console.log(strKey);
            //console.log(cacheQueries.length);
            cacheQueries.push(strKey);
            cacheCallbacks.push([{'callback': callback, 'ready': true}]);
            cacheResults.push([]);
            //console.log(cacheQueries.length);
            intQueryIndex = (cacheQueries.length - 1);
            //console.log(intQueryIndex);

            GS.requestSelectFromSocket(socket, strSchema, strObject, strColumns
                                     , strWhere, strOrd, strLimit, strOffset
                                     , function (data, error) {
                var i, len;

                cacheResults[intQueryIndex].push([data, error]);

                for (i = 0, len = cacheCallbacks[intQueryIndex].length; i < len; i += 1) {
                    if (cacheCallbacks[intQueryIndex][i].ready) {
                        cacheCallbacks[intQueryIndex][i].callback(data, error);
                    }
                }
            });
        }
    };*/
})();


// GS.encodeForTabDelimited('asdf\\asdf\\asdf\r\nasdf\r\nasdf\tasdf\tasdf')
GS.encodeForTabDelimited = function (strValue, nullValue) {
    'use strict';
    strValue = String(strValue || '');

    if (strValue === '\\N') {
        return strValue;
    } else {
        strValue = strValue.replace(/\\/g, '\\\\') // double up backslashes
                        .replace(/\n/g, '\\n')     // replace newline with the text representation '\n'
                        .replace(/\r/g, '\\r')     // replace carriage return with the text representation '\r'
                        .replace(/\t/g, '\\t');    // replace tab with the text representation '\t'

        if (strValue === nullValue) {
            strValue = '\\N';
        }

        return strValue;
    }
};

// GS.decodeFromTabDelimited('asdf\\\\asdf\\\\asdf\\r\\nasdf\\r\\nasdf\\tasdf\\tasdf')
GS.decodeFromTabDelimited = function (strValue, nullValue) {
    'use strict';
    var i, len, strRet = '';
    //console.log(strValue, nullValue);
    if (nullValue === undefined) {
        nullValue = '\\N';
    }

    for (i = 0, len = strValue.length; i < len; i += 1) {
        if (strValue[i] === '\\' && strValue[i + 1]) {
            i += 1;

            if (strValue[i] === 'n') {
                strRet += '\n';

            } else if (strValue[i] === 'r') {
                strRet += '\r';

            } else if (strValue[i] === 't') {
                strRet += '\t';

            } else if (strValue[i] === 'N') {
                strRet += nullValue;

            } else if (strValue[i] === '\\') {
                strRet += '\\';

            } else {
                strRet += '\\' + strValue[i];
            }

        } else {
            strRet += strValue[i];
        }
    }

    return strRet;

    //return strValue.replace(/\\\\/g, '\\')
    //               .replace(/\\n/g, '\n')
    //               .replace(/\\r/g, '\r')
    //               .replace(/\\t/g, '\t')
    //               .replace(/\\N/g, 'NULL');
};

window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('GS.rightPad', 'GS.rightPad',
                                    'GS.rightPad(${1:stringToPad}, \'${2:stringToPadWith}\', ${0:lengthToPadTo});');

    registerDesignSnippet('GS.leftPad', 'GS.leftPad',
                                    'GS.leftPad(${1:stringToPad}, \'${2:stringToPadWith}\', ${0:lengthToPadTo});');

    registerDesignSnippet('GS.pxToEm', 'GS.pxToEm', 'GS.pxToEm(${1:elementToTestIn}, ${0:pxToConvert});');

    registerDesignSnippet('GS.emToPx', 'GS.emToPx', 'GS.emToPx(${1:elementToTestIn}, ${0:emToConvert});');

    registerDesignSnippet('GS.keyCode', 'GS.keyCode', 'GS.keyCode(\'${0:characterToGetTheKeyCodeOf}\');');

    registerDesignSnippet('GS.charFromKeyCode', 'GS.charFromKeyCode', 'GS.charFromKeyCode(\'${0:eventObject}\');');

    registerDesignSnippet('GS.getStyle', 'GS.getStyle', 'GS.getStyle(${1:element}, \'${0:CSSProperty}\');');

    registerDesignSnippet('GS.listAdd', 'GS.listAdd', 'GS.listAdd(${1:arrayToAddTo}, \'${0:valueToAddIfUnique}\');');

    registerDesignSnippet('GS.triggerEvent', 'GS.triggerEvent', 'GS.triggerEvent(${1:target}, \'${2:eventName}\', ${0:jsnModifiers});');

    registerDesignSnippet('GS.strToTitle', 'GS.strToTitle', 'GS.strToTitle(${0:valueToConvert});');

    registerDesignSnippet('GS.mousePosition', 'GS.mousePosition', 'GS.mousePosition(${0:event});');

    registerDesignSnippet('GS.GUID', 'GS.GUID', 'GS.GUID();');

    registerDesignSnippet('GS.safeDecodeURIComponent', 'GS.safeDecodeURIComponent', 'GS.safeDecodeURIComponent(${0:valueToDecode});');

    registerDesignSnippet('GS.getTextHeight', 'GS.getTextHeight', 'GS.getTextHeight(${1:elementToTestIn}, ${0:bolNormalLineHeight});');

    registerDesignSnippet('GS.getTextWidth', 'GS.getTextWidth', 'GS.getTextWidth(${1:elementToTestIn}, ${0:strTextToGetTheWidthOf});');

    registerDesignSnippet('GS.scrollParent', 'GS.scrollParent', 'GS.scrollParent(${0:elementToStartFrom});');

    registerDesignSnippet('GS.scrollIntoView', 'GS.scrollIntoView', 'GS.scrollIntoView(${0:elementToScrollIntoView});');

    registerDesignSnippet('GS.envGetCell', 'GS.envGetCell', 'GS.envGetCell(${1:envelopeData}, ${2:recordNumber}, \'${0:columnName}\');');

    registerDesignSnippet('GS.trim', 'GS.trim', 'GS.trim(${1:stringToBeTrimmed}, \'${0:stringToTrimOff}\');');

    registerDesignSnippet('GS.setCookie', 'GS.setCookie', 'GS.setCookie(\'${1:cookieName}\', ${2:newValue}, ${0:daysUntilExpire});');

    registerDesignSnippet('GS.getCookie', 'GS.getCookie', 'GS.getCookie(\'${1:cookieName}\');');

    registerDesignSnippet('GS.pushState', 'GS.pushState', 'GS.pushState(${1:stateObj}, ${2:title}, ${0:newURL});');

    registerDesignSnippet('GS.replaceState', 'GS.replaceState', 'GS.replaceState(${1:stateObj}, ${2:title}, ${0:newURL});');

    registerDesignSnippet('GS.searchToWhere', 'GS.searchToWhere', 'GS.searchToWhere(\'${1:columns}\', ${0:searchClause});');

    registerDesignSnippet('GS.iconList', 'GS.iconList', 'GS.iconList();');

    registerDesignSnippet('GS.lorem', 'GS.lorem', 'GS.lorem();');

    registerDesignSnippet('GS.numberSuffix', 'GS.numberSuffix', 'GS.numberSuffix(${1:intNumber});');

    registerDesignSnippet('GS.hitLink', 'GS.hitLink', 'GS.hitLink(${1:strLink});');

    registerDesignSnippet('GS.log', 'GS.log', 'GS.log(\'${1:send}\', ${2:message});');
});

function gt(x,y)  { return x >  y; }
function gte(x,y) { return x >= y; }
function lt(x,y)  { return x <  y; }
function lte(x,y) { return x <= y; }

// sometimes, we need to hit a link without paying attention
//      to the response and without opening a new tab. for
//      example, mailto: and tel: links
GS.hitLink = function (strLink) {
    "use strict";
    var iframeElement;

    iframeElement = document.createElement('iframe');
    iframeElement.setAttribute('hidden', '');
    iframeElement.addEventListener('load', function () {
        if (iframeElement.parentNode === document.body) {
            document.body.removeChild(iframeElement);
        }
    });

    iframeElement.setAttribute("src", strLink);
    document.body.appendChild(iframeElement);
};


GS.log = function (bolsend, message) {
    "use strict";
    var msg = message;
    if (bolsend) {
        var e = new Error();
        if (!e.stack) {
            try {
                // IE requires the Error to actually be thrown or else the
                // Error's 'stack' property is undefined.
                throw e;
            } catch (e) {
                if (!e.stack) {
                    //return 0; // IE < 10, likely
                }
            }
        }
        var stack = e.stack.toString().split(/\r\n|\n/);
        if (msg === '') {
            msg = '""';
        }
        console.log(msg, ' ' + stack[1].trim().substring(stack[1].trim().indexOf('('), stack[1].trim().length) + '');
    }
};


GS.numberSuffix = function(intNumber) {
    'use strict';
    var strNumber = String(intNumber),
        jsnSuffixes = {
            '0': 'th', '1': 'st',
            '2': 'nd', '3': 'rd',
            '4': 'th', '5': 'th',
            '6': 'th', '7': 'th',
            '8': 'th', '9': 'th'
        };

    return strNumber + jsnSuffixes[strNumber[strNumber.length - 1]];
}

// ###########################################################
// #################### PADDING FUNCTIONS ####################
// ###########################################################

// pad a string with another string on the right side of the string
//      repeating until the pad_str until the str length is >= the padToLength

//  PARAM         "str": string to pad
//  PARAM   "padString": string to pad with
//  PARAM "padToLength": number of characters to pad for
GS.rightPad = function (str, padString, padToLength) {
    'use strict';
    str = String(str);

    while (str.length < padToLength) {
        str += padString;
    }

    return str;
};


// pad a string with another string on the left side of the string
//      repeating until the padString until the str length is >= the padToLength

//  PARAM         "str": string to pad
//  PARAM   "padString": string to pad with
//  PARAM "padToLength": number of characters to pad for
GS.leftPad = function (str, padString, padToLength) {
    'use strict';
    str = String(str);

    while (str.length < padToLength) {
        str = padString + str;
    }

    return str;
};



// ################################################################
// ################ EM AND PX CONVERSION FUNCTIONS ################
// ################################################################

// convert pixels to ems
GS.pxToEm = function (elementScope, fromPX) {
    'use strict';
	var intPX = parseFloat(fromPX),
	    heightTestElement = document.createElement('div'),
	    intElementHeight;

    elementScope = elementScope || document.body;

    heightTestElement.style.fontSize = '1em';
    heightTestElement.style.margin = '0';
    heightTestElement.style.padding = '0';
    heightTestElement.style.lineHeight = '1';
    heightTestElement.style.border = '0';

    heightTestElement.innerHTML = 'a';

    elementScope.appendChild(heightTestElement);
    intElementHeight = heightTestElement.offsetHeight;
    elementScope.removeChild(heightTestElement);

	return parseFloat((intPX / intElementHeight).toFixed(8), 10);
};

// convert ems to pixels
GS.emToPx = function (elementScope, fromEM) {
    'use strict';
	var intEM = parseFloat(fromEM),
	    heightTestElement = document.createElement('div'),
	    intElementHeight;

    elementScope = elementScope || document.body;

    heightTestElement.style.fontSize = '1em';
    heightTestElement.style.margin = '0';
    heightTestElement.style.padding = '0';
    heightTestElement.style.lineHeight = '1';
    heightTestElement.style.border = '0';

    heightTestElement.innerHTML = 'a';

    elementScope.appendChild(heightTestElement);
    intElementHeight = heightTestElement.offsetHeight;
    elementScope.removeChild(heightTestElement);

	return Math.round(intEM * intElementHeight); // not sure if we want to round here but the old function did
	                                             // so I will leave it here until there is a problem -michael
};



// ################################################################
// #################### MISC UTILITY FUNCTIONS ####################
// ################################################################

GS.charFromKeyCode = function (event) {
    // (this function contains a (modified) substantial portion of code from another source
    //    here is the copyright for sake of legality)

    // name: jQuery getChar
    // repository: https://github.com/bpeacock/key-to-charCode
    // @author Brian Peacock
    // @version 0.3
    // Copyright 2013, Brian Peacock
    // Licensed under the MIT license.

    'use strict';

    var code = event.which;

    //Ignore Shift Key events & arrows
    var ignoredCodes = {
        16: true,
        37: true,
        38: true,
        39: true,
        40: true,
        20: true,
        17: true,
        18: true,
        91: true
    };

    if (ignoredCodes[code] === true) {
        return false;
    }

    // These are special cases that don't fit the ASCII mapping
    var exceptions = {
        186: 59, // ;
        187: 61, // =
        188: 44, // ,
        189: 45, // -
        190: 46, // .
        191: 47, // /
        192: 96, // `
        219: 91, // [
        220: 92, // \
        221: 93, // ]
        222: 39, // '
        //numeric keypad
        96: '0'.charCodeAt(0),
        97: '1'.charCodeAt(0),
        98: '2'.charCodeAt(0),
        99: '3'.charCodeAt(0),
        100: '4'.charCodeAt(0),
        101: '5'.charCodeAt(0),
        102: '6'.charCodeAt(0),
        103: '7'.charCodeAt(0),
        104: '8'.charCodeAt(0),
        105: '9'.charCodeAt(0)
    };

    if (exceptions[code] !== undefined) {
        code = exceptions[code];
    }

    var ch = String.fromCharCode(code);

    // Handle Shift
    if (event.shiftKey) {
        var special = {
            1: '!',
            2: '@',
            3: '#',
            4: '$',
            5: '%',
            6: '^',
            7: '&',
            8: '*',
            9: '(',
            0: ')',
            ',': '<',
            '.': '>',
            '/': '?',
            ';': ':',
            "'": '"',
            '[': '{',
            ']': '}',
            '\\': '|',
            '`': '~',
            '-': '_',
            '=': '+'
        };

        if (special[ch] !== undefined) {
            ch = special[ch];
        }
    } else {
        ch = ch.toLowerCase();
    }

    return ch;
};

// keyCode string to number
GS.keyCode = function (inChar) {
    "use strict";
	/*
	Key 	Code
backspace 	8
tab 	9
enter 	13
shift 	16
ctrl 	17
alt 	18
pause/break 	19
caps lock 	20
escape 	27
(space) 	32
page up 	33
page down 	34
end 	35
home 	36
left arrow 	37
up arrow 	38
right arrow 	39
down arrow 	40
insert 	45
delete 	46
0 	48
1 	49
2 	50
3 	51
4 	52
5 	53
6 	54
7 	55
8 	56
9 	57
a 	65
b 	66
c 	67
d 	68

Key 	Code
e 	69
f 	70
g 	71
h 	72
i 	73
j 	74
k 	75
l 	76
m 	77
n 	78
o 	79
p 	80
q 	81
r 	82
s 	83
t 	84
u 	85
v 	86
w 	87
x 	88
y 	89
z 	90
left window key 	91
right window key 	92
select key 	93
numpad 0 	96
numpad 1 	97
numpad 2 	98
numpad 3 	99
numpad 4 	100
numpad 5 	101
numpad 6 	102
numpad 7 	103
*/
    inChar = inChar.toLowerCase();
	return '\b'          == inChar ? '8' :
	       'backspace'   == inChar ? '8' :
	       '\t'          == inChar ? '9' :
	       'tab'         == inChar ? '9' :
	       '\r'          == inChar ? '13' :
	       '\n'          == inChar ? '13' :
	       'enter'       == inChar ? '13' :
	       'return'      == inChar ? '13' :
	       'newline'     == inChar ? '13' :
	       'shift'       == inChar ? '16' :
	       'ctrl'        == inChar ? '17' :
	       'alt'         == inChar ? '18' :
	       'pause/break' == inChar ? '19' :
	       'caps lock'   == inChar ? '20' :
	       'escape'      == inChar ? '27' :
	       'space'       == inChar ? '32' :
	       ' '           == inChar ? '32' :
	       'page up'     == inChar ? '33' :
	       'page down'   == inChar ? '34' :
	       'end'         == inChar ? '35' :
	       'home'        == inChar ? '36' :
	       'left arrow'  == inChar ? '37' :
	       'up arrow'    == inChar ? '38' :
	       'right arrow' == inChar ? '39' :
	       'down arrow'  == inChar ? '40' :
	       'insert'      == inChar ? '45' :
	       'delete'      == inChar ? '46' :
	       '0'           == inChar ? '48' :
	       '1'           == inChar ? '49' :
	       '2'           == inChar ? '50' :
	       '3'           == inChar ? '51' :
	       '4'           == inChar ? '52' :
	       '5'           == inChar ? '53' :
	       '6'           == inChar ? '54' :
	       '7'           == inChar ? '55' :
	       '8'           == inChar ? '56' :
	       '9'           == inChar ? '57' :
	       'a'           == inChar ? '65' :
	       'b'           == inChar ? '66' :
	       'c'           == inChar ? '67' :
	       'd'           == inChar ? '68' :
	       'e'           == inChar ? '69' :
	       'f'           == inChar ? '70' :
	       'g'           == inChar ? '71' :
	       'h'           == inChar ? '72' :
	       'i'           == inChar ? '73' :
	       'j'           == inChar ? '74' :
	       'k'           == inChar ? '75' :
	       'l'           == inChar ? '76' :
	       'm'           == inChar ? '77' :
	       'n'           == inChar ? '78' :
	       'o'           == inChar ? '79' :
	       'p'           == inChar ? '80' :
	       'q'           == inChar ? '81' :
	       'r'           == inChar ? '82' :
	       's'           == inChar ? '83' :
	       't'           == inChar ? '84' :
	       'u'           == inChar ? '85' :
	       'v'           == inChar ? '86' :
	       'w'           == inChar ? '87' :
	       'x'           == inChar ? '88' :
	       'y'           == inChar ? '89' :
	       'z'           == inChar ? '90' :
	       'left window key'  == inChar ? '91' :
	       'right window key' == inChar ? '92' :
	       'select key'  == inChar ? '93' :
	       'numpad 0'    == inChar ? '96' :
	       'numpad 1'    == inChar ? '97' :
	       'numpad 2'    == inChar ? '98' :
	       'numpad 3'    == inChar ? '99' :
	       'numpad 4'    == inChar ? '100' :
	       'numpad 5'    == inChar ? '101' :
	       'numpad 6'    == inChar ? '102' :
	       'numpad 7'    == inChar ? '103' :
	       'numpad 8'    == inChar ? '104' :
	       'numpad 9'    == inChar ? '105' :
	       'multiply'    == inChar ? '106' :
	       'add'         == inChar ? '107' :
	       '+'           == inChar ? '107' :
	       'subtract'    == inChar ? '109' :
	       '-'           == inChar ? '109' :
	       'decimal point' == inChar ? '110' :
	       'divide'      == inChar ? '111' :
	       'f1'          == inChar ? '112' :
	       'f2'          == inChar ? '113' :
	       'f3'          == inChar ? '114' :
	       'f4'          == inChar ? '115' :
	       'f5'          == inChar ? '116' :
	       'f6'          == inChar ? '117' :
	       'f7'          == inChar ? '118' :
	       'f8'          == inChar ? '119' :
	       'f9'          == inChar ? '120' :
	       'f10'         == inChar ? '121' :
	       'f11'         == inChar ? '122' :
	       'f12'         == inChar ? '123' :
	       'num lock'    == inChar ? '144' :
	       'scroll lock' == inChar ? '145' :
	       'semi-colon'  == inChar ? '186' :
	       ';'           == inChar ? '186' :
	       'equal sign'  == inChar ? '187' :
	       '='           == inChar ? '187' :
	       'comma'       == inChar ? '188' :
	       ','           == inChar ? '188' :
	       'dash'        == inChar ? '189' :
	       '-'           == inChar ? '189' :
	       'period'      == inChar ? '190' :
	       '.'           == inChar ? '190' :
	       'forward slash' == inChar ? '191' :
	       '/'             == inChar ? '191' :
	       'grave accent'  == inChar ? '192' :
	       'open bracket'  == inChar ? '219' :
	       '['             == inChar ? '219' :
	       'back slash'    == inChar ? '220' :
	       '\\'            == inChar ? '220' :
	       'close bracket' == inChar ? '221' :
	       ']'             == inChar ? '221' :
	       'single quote'  == inChar ? '222' :
	       '\''            == inChar ? '222' :
	       '';
	/*
Key 	Code
numpad 8 	104
numpad 9 	105
multiply 	106
add 	107
subtract 	109
decimal point 	110
divide 	111
f1 	112
f2 	113
f3 	114
f4 	115
f5 	116
f6 	117
f7 	118
f8 	119
f9 	120
f10 	121
f11 	122
f12 	123
num lock 	144
scroll lock 	145
semi-colon 	186
equal sign 	187
comma 	188
dash 	189
period 	190
forward slash 	191
grave accent 	192
open bracket 	219
back slash 	220
close braket 	221
single quote 	222
*/
};

// get computed or current style (current style if it is availible)
GS.getStyle = function (element, style) {
	if (element.currentStyle !== undefined) {
        return element.currentStyle[style];
	}

    return document.defaultView.getComputedStyle(element, null)[style];
};

// push to array if the value is unique
GS.listAdd = function (arrArray, newValue) {
    'use strict';
    if (arrArray.indexOf(newValue) === -1) {
        arrArray.push(newValue);
    }
};

// trigger an event on a target
GS.triggerEvent = function (target, strEventName, jsnConfig) {
    'use strict';
    var event, key;

    //console.trace('trigger', target);

    if (document.createEvent) {
        event = document.createEvent('HTMLEvents');
        event.initEvent(strEventName, true, true);
    } else {
        event = document.createEventObject();
        event.eventType = strEventName;
    }

    event.eventName = strEventName;

    if (jsnConfig) {
        for (key in jsnConfig) {
            event[key] = jsnConfig[key];
        }
    }

    if (document.createEvent) {
        target.dispatchEvent(event);
    } else {
        target.fireEvent("on" + event.eventType, event);
    }

    return event;
};

// converts a string into a more user readable format
GS.strToTitle = function (strInput) {
    'use strict';
    var i, len, chrCurrent, chrLast = '', strRet = '';

    strInput = strInput || '';

    for (i = 0, len = strInput.length; i < len; i += 1) {
        chrCurrent = strInput.charAt(i);

        if (!(/[a-zA-Z]/).test(chrLast)) {
            strRet += chrCurrent.toUpperCase();

        } else if (chrCurrent === '_') {
            strRet += ' ';

        } else {
            strRet += chrCurrent;
        }

        chrLast = chrCurrent;
    }

    return strRet;
};

// normalize top, left, bottom and right on a mouse event
GS.mousePosition = function (event) {
    'use strict';
    var pageX = (evt.touchDevice ? event.touches[0].pageX: event.pageX),// get the left and top of the mouse
        pageY = (evt.touchDevice ? event.touches[0].pageY: event.pageY);//   (or the touch position if we are on a phone)

    return {
        'top':    pageY,
        'left':   pageX,
        'bottom': window.innerHeight - pageY,
        'right':  window.innerWidth - pageX,

        //'x':      pageY, // alias <== messed these up
        //'y':      pageX  // alias

        'x':      pageX, // alias
        'y':      pageY  // alias
    };
};

// original function found here: http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
GS.GUID = function () {
    var strTime = new Date().getTime().toString();

    function randomString() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    }

    return  randomString() + randomString() + '-' +
            randomString() + '-' +
            randomString() + '-' +
            randomString() + '-' +
            strTime.substring(strTime.length - 4) + '-' +
            randomString() + randomString() + randomString();
};

/*  ,---- no longer works
//  V
GS.getSelectedText = function () {
    if (window.getSelection) {
        return window.getSelection() + '';
    }

    // FireFox
    if (document.getSelection) {
        return document.getSelection() + '';
    }

    // IE 6/7
    if (document.selection) {
        return document.selection.createRange().text + '';
    }

    console.warn('GS.getSelectedText warning: no selection collection function found (could not find a way to get the selected text)');
    return '';
}*/

// decode uri component safe from "URI malformed" error
GS.safeDecodeURIComponent = function (string) {
    var strRet;

    try {
        strRet = decodeURIComponent(string);

    } catch (error) {
        if (error.toString().indexOf('URI malformed') > -1) {
            strRet = string;
        } else {
            throw error;
        }
    }

    return strRet;
};

//
GS.getTextHeight = function (scope, bolNormalLineHeight) {
    var divElement = document.createElement('div'), intHeight;

    scope = scope || document.body;

    divElement.style.visibility = 'invisible';
    divElement.style.fontSize   = '1em';
    divElement.style.margin     = '0';
    divElement.style.padding    = '0';
    divElement.style.lineHeight = (bolNormalLineHeight ? 'normal' : '1');
    divElement.style.border     = '0';
    divElement.textContent      = 'a';

    scope.appendChild(divElement);

    intHeight = divElement.clientHeight;

    scope.removeChild(divElement);

    return intHeight;
};


//
GS.getTextWidth = function (scope, strText, bolWhitePreserve) {
    var divElement = document.createElement('div'), intWidth;

    scope = scope || document.body;

    divElement.style.display       = 'inline-block';
    divElement.style.visibility    = 'invisible';
    divElement.style.fontSize      = '1em';
    divElement.style.margin        = '0';
    divElement.style.padding       = '0';
    divElement.style.letterSpacing = 'inherit';
    divElement.style.border        = '0';
    divElement.style.whiteSpace    = (bolWhitePreserve ? 'pre' : '');
    divElement.textContent         = strText;

    scope.appendChild(divElement);

    intWidth = divElement.clientWidth;

    scope.removeChild(divElement);

    return intWidth;
};



GS.scrollParent = function (element, strDirection) {
    "use strict";
    var strDirectionText;
    if (strDirection) {
        strDirectionText = strDirection;
    } else {
        strDirectionText = 'vertical';
    }
    var i = 0;
    var currentElement = element;
    var bolFoundScrollable = false;
    var strOverflow;

    if (currentElement) {
        while (
            currentElement &&
            currentElement.nodeName !== 'HTML' &&
            bolFoundScrollable === false &&
            i < 75
        ) {
            strOverflow = GS.getStyle(currentElement, 'overflow');
            if (
                strOverflow === 'scroll' ||
                (
                    strOverflow === 'auto' &&
                    strDirectionText === 'vertical' &&
                    currentElement.clientHeight < currentElement.scrollHeight
                ) ||
                (
                    strOverflow === 'auto' &&
                    strDirectionText === 'horizontal' &&
                    currentElement.clientWidth < currentElement.scrollWidth
                )
            ) {
                bolFoundScrollable = true;
            } else {
                currentElement = currentElement.parentNode;
                i += 1;
            }
        }

        //console.log(currentElement.nodeName);
        if (!currentElement || currentElement.nodeName === 'HTML') {
            return document.body;
        }

        return (
            bolFoundScrollable
                ? currentElement
                : undefined
        );
    }
    return undefined;
}


//
GS.scrollIntoView = function (element, strDirection) {
    var strDirectionText;
    if (strDirection) {
        strDirectionText = strDirection;
    } else {
        strDirectionText = 'vertical';
    }
    var scrollingContainer = GS.scrollParent(element, strDirectionText), arrSiblings, i, len, intScrollTop, intScrollLeft;
    if (scrollingContainer) {
        //console.log(scrollingContainer);
        if (strDirectionText === 'horizontal') {
            arrSiblings = element.parentNode.children;

            for (i = 0, intScrollLeft = 0, len = arrSiblings.length; i < len; i += 1) {
                if (arrSiblings[i] === element) {
                    intScrollLeft += arrSiblings[i].offsetWidth / 2;

                    break;
                } else {
                    intScrollLeft += arrSiblings[i].offsetWidth;
                }
            }

            intScrollLeft = intScrollLeft - (scrollingContainer.offsetWidth / 2);
            scrollingContainer.scrollLeft = intScrollLeft;
        } else {
            arrSiblings = element.parentNode.children;

            for (i = 0, intScrollTop = 0, len = arrSiblings.length; i < len; i += 1) {
                if (arrSiblings[i] === element) {
                    intScrollTop += arrSiblings[i].offsetHeight / 2;

                    break;
                } else {
                    intScrollTop += arrSiblings[i].offsetHeight;
                }
            }

            intScrollTop = intScrollTop - (scrollingContainer.offsetHeight / 2);
            scrollingContainer.scrollTop = intScrollTop;
        }
    }
};

// return value from: envelope data, record number and column name
GS.envGetCell = function (data, record_number, column_name) {
    'use strict';
    var index;

    if (data.stat) {
        data = data.dat;
    }

    index = data.arr_column.indexOf(column_name);

    if (index === -1) {
        console.error(column_name, data);
        throw 'Error in GS.envGetCell: column not found';
    }

    return data.dat[record_number][index];
};

GS.trim = function(string, strStringToTrim) {
    "use strict";
    var safeRegexString = strStringToTrim.replace(/([.?*+^$[\]\\(){}|-])/g,'\\$1'),
        trimRegex = new RegExp('^' + safeRegexString + '+|' + safeRegexString + '+$', 'g');

    return string.replace(trimRegex, '');
};

// set a cookie in the browser
GS.setCookie = function (c_name, value, exdays) {
    'use strict';
    var exDayNum;
    if (!exdays) {
        exDayNum = 30;
    } else {
        exDayNum = exdays;
    }

    var hostname = location.hostname;
    var exdate = new Date(), c_value;
    hostname = hostname.substring(hostname.indexOf('.'));
    exdate.setDate(exdate.getDate() + exDayNum);

    c_value = encodeURIComponent(value) + ((exDayNum === null || exDayNum === undefined) ? '' : '; expires=' + exdate.toUTCString()) + '; domain=' + hostname + '; path=/';

    document.cookie = c_name + '=' + c_value;
};

// get a cookie from the browser
GS.getCookie = function (c_name) {
    'use strict';
    var c_value = document.cookie, c_end,
        c_start = c_value.indexOf(" " + c_name + "=");

    if (c_start === -1) {
        c_start = c_value.indexOf(c_name + "=");
    }

    if (c_start === -1) {
        c_value = null;
    } else {
        c_start = c_value.indexOf("=", c_start) + 1;
        c_end = c_value.indexOf(";", c_start);
        if (c_end === -1) {
            c_end = c_value.length;
        }
        c_value = decodeURIComponent(c_value.substring(c_start, c_end));
    }

    return c_value;
};

GS.pushState = function (stateObj, title, url) {
    history.pushState(stateObj, title, url);
    GS.triggerEvent(window, 'pushstate');
};

GS.replaceState = function (stateObj, title, url) {
    history.replaceState(stateObj, title, url);
    GS.triggerEvent(window, 'replacestate');
};

GS.searchToWhere = function (columns, searchClause) {
    //console.log(searchClause);
    var arrToken, arrNoQuotes = [], strNoQuotes = '', arrColumn, arrRequired = [], strRequired = '', arrWhere = [], strWhere = '', strRet = '', token, numTokens, col, numCols, i, len, strSearch;

    if (!searchClause) {
        return '1=1';
    }

    arrColumn = columns.split(',');

    // First get all quoted tokens, leave everything else
    arrToken = searchClause.match(/[\+|\-]?"[^"]*?"/g);

    if (arrToken) {
        for (token = 0, numTokens = arrToken.length; token < numTokens; token += 1) {
            arrToken[token] = GS.trim(arrToken[token], '+');
            for (col = 0, numCols = arrColumn.length; col < numCols; col += 1) {
                if (arrToken[token][0] === '-') {
                    arrToken[token] = GS.trim(arrToken[token], '-');
                    arrRequired[token] =
                        (arrRequired[token] ? arrRequired[token] + ' AND ' : '') +
                        'CASE WHEN ' + arrColumn[col] +
                        ' IS NOT NULL THEN ' + arrColumn[col] +
                        ' NOT ILIKE \'%' + GS.trim(arrToken[token], '"') +
                        '%\' ELSE TRUE END';
                    arrToken[token] = '-' + arrToken[token];
                } else {
                    arrRequired[token] =
                        (arrRequired[token] ? arrRequired[token] + ' OR ' : '') +
                        (arrColumn[col] + ' ILIKE \'%' + GS.trim(arrToken[token], '"') + '%\'');
                }
            }
        }

        for (i = 0, len = arrRequired.length; i < len; i += 1) {
            strRequired = (strRequired ? strRequired + ' AND ' : '') + '(' + arrRequired[i] + ')';
        }
        //console.log('strRequired:', strRequired);
    }

    // Get non-quoted tokens and remove extra space
    /*
    //NOT CROSS BROWSER
    arrNoQuotes = strSearch.split(/([\+|\-]?"[^"]*?")/);
    strNoQuotes = arrNoQuotes.join(' ');
    arrNoQuotes = strNoQuotes.split(/[ ]+/);
    */
    strSearch = searchClause.trim();
    strSearch = strSearch.replace('-"', '"');
    strSearch = strSearch.replace('+"', '"');
    strSearch = strSearch.replace(/"[^"]*"/, '""');
    arrNoQuotes = strSearch.split('""');
    //console.log("arrNoQuotes: ", arrNoQuotes);
    strNoQuotes = arrNoQuotes.join(' ');
    //console.log("strNoQuotes: >" + strNoQuotes + "<");
    strNoQuotes = strNoQuotes.replace('  ', ' ');
    strNoQuotes = strNoQuotes.replace('  ', ' ');
    arrNoQuotes = strNoQuotes.split(' ');
    //console.log("arrNoQuotes: ", arrNoQuotes);
    /*
    //DIDN'T WORK
    strSearch = searchClause.trim();
    strSearch = strSearch.replace('-"', '"');
    strSearch = strSearch.replace('+"', '"');
    arrNoQuotes = strSearch.split('"');
    strSearch = '';
    if (searchClause.trim()[0] === '"') {
        for (i = 1, len = arrNoQuotes.length; i < len; i += 2) {
            strSearch = strSearch + (strSearch === '' ? '' : ' ') + arrNoQuotes[i].trim();
        }
    } else {
        for (i = 0, len = arrNoQuotes.length; i < len; i += 2) {
            strSearch = strSearch + (strSearch === '' ? '' : ' ') + arrNoQuotes[i].trim();
        }
    }
    //console.log(strSearch);
    strSearch = strSearch.replace('  ', ' ');
    strSearch = strSearch.replace('  ', ' ');
    arrNoQuotes = strSearch.split(' ');
    //console.log(arrNoQuotes);
    */
    // Put items into arrRequired or arrWhere
    arrRequired = [''];
    if (arrNoQuotes.length > 0) {
        //console.log('1');
        for (token = 0, numTokens = arrNoQuotes.length; token < numTokens; token += 1) {
            //console.log('2');
            for (col = 0, numCols = arrColumn.length; col < numCols; col += 1) {
                //console.log('3 arrNoQuotes[' + token + ']: ' + arrNoQuotes[token]);
                if (arrNoQuotes[token].length > 0) {
                    //console.log('4');
                    if (arrNoQuotes[token][0] === '-') {
                        arrRequired[token] =
                            (arrRequired[token] ? arrRequired[token] + ' AND ' : '') +
                            ' CASE WHEN ' + arrColumn[col] +
                            ' IS NOT NULL THEN ' + arrColumn[col] +
                            ' NOT ILIKE $$%' + GS.trim(GS.trim(arrNoQuotes[token], '-'), ' ') +
                            '%$$ ELSE TRUE END ';
                    } else if (arrNoQuotes[token][0] === '+') {
                        arrRequired[token] =
                            (arrRequired[token] ? arrRequired[token] + ' OR ' : '') +
                            arrColumn[col] + ' ILIKE $$%' +
                            GS.trim(GS.trim(arrNoQuotes[token], '+'), ' ') + '%$$ ';
                    } else {
                        arrWhere[token] =
                            (arrWhere[token] ? arrWhere[token] + ' OR ' : '') +
                            arrColumn[col] + ' ILIKE $$%' + GS.trim(arrNoQuotes[token], ' ') + '%$$ ';
                    }
                }
            }
        }
    }

    if (arrRequired.length > 0) {
        for (i = 0, len = arrRequired.length; i < len; i += 1) {
            if (arrRequired[i]) {
                strRequired = (strRequired ? strRequired + ' AND ' : '') + '(' + arrRequired[i] + ')';
            }
        }
    }
    //console.log('strRequired: ', strRequired);

    if (arrWhere.length > 0) {
        for (i = 0, len = arrWhere.length; i < len; i += 1) {
            if (arrWhere[i]) {
                strWhere = (strWhere ? strWhere + ' AND ' : '') + '(' + arrWhere[i] + ')';
            }
        }
    }
    //console.log('strWhere: ', strWhere);

    strRet =
        (
            strWhere && strRequired ? '(' + strWhere + ') AND (' + strRequired + ')' :
            strWhere ? strWhere :
            strRequired
        );

    //console.log('strRet: ' + strRet);

    return strRet;
};

GS.iconList = function () {
    return [{"name":"500px","code":"f26e"},{"name":"adjust","code":"f042"},{"name":"adn","code":"f170"},{"name":"align-center","code":"f037"},{"name":"align-justify","code":"f039"},{"name":"align-left","code":"f036"},{"name":"align-right","code":"f038"},{"name":"amazon","code":"f270"},{"name":"ambulance","code":"f0f9"},{"name":"anchor","code":"f13d"},{"name":"android","code":"f17b"},{"name":"angellist","code":"f209"},{"name":"angle-double-down","code":"f103"},{"name":"angle-double-left","code":"f100"},{"name":"angle-double-right","code":"f101"},{"name":"angle-double-up","code":"f102"},{"name":"angle-down","code":"f107"},{"name":"angle-left","code":"f104"},{"name":"angle-right","code":"f105"},{"name":"angle-up","code":"f106"},{"name":"apple","code":"f179"},{"name":"archive","code":"f187"},{"name":"area-chart","code":"f1fe"},{"name":"arrow-circle-down","code":"f0ab"},{"name":"arrow-circle-left","code":"f0a8"},{"name":"arrow-circle-o-down","code":"f01a"},{"name":"arrow-circle-o-left","code":"f190"},{"name":"arrow-circle-o-right","code":"f18e"},{"name":"arrow-circle-o-up","code":"f01b"},{"name":"arrow-circle-right","code":"f0a9"},{"name":"arrow-circle-up","code":"f0aa"},{"name":"arrow-down","code":"f063"},{"name":"arrow-left","code":"f060"},{"name":"arrow-right","code":"f061"},{"name":"arrow-up","code":"f062"},{"name":"arrows","code":"f047"},{"name":"arrows-alt","code":"f0b2"},{"name":"arrows-h","code":"f07e"},{"name":"arrows-v","code":"f07d"},{"name":"asterisk","code":"f069"},{"name":"at","code":"f1fa"},{"name":"automobile","code":"f1b9"},{"name":"backward","code":"f04a"},{"name":"balance-scale","code":"f24e"},{"name":"ban","code":"f05e"},{"name":"bank","code":"f19c"},{"name":"bar-chart","code":"f080"},{"name":"bar-chart-o","code":"f080"},{"name":"barcode","code":"f02a"},{"name":"bars","code":"f0c9"},{"name":"battery-0","code":"f244"},{"name":"battery-1","code":"f243"},{"name":"battery-2","code":"f242"},{"name":"battery-3","code":"f241"},{"name":"battery-4","code":"f240"},{"name":"battery-empty","code":"f244"},{"name":"battery-full","code":"f240"},{"name":"battery-half","code":"f242"},{"name":"battery-quarter","code":"f243"},{"name":"battery-three-quarters","code":"f241"},{"name":"bed","code":"f236"},{"name":"beer","code":"f0fc"},{"name":"behance","code":"f1b4"},{"name":"behance-square","code":"f1b5"},{"name":"bell","code":"f0f3"},{"name":"bell-o","code":"f0a2"},{"name":"bell-slash","code":"f1f6"},{"name":"bell-slash-o","code":"f1f7"},{"name":"bicycle","code":"f206"},{"name":"binoculars","code":"f1e5"},{"name":"birthday-cake","code":"f1fd"},{"name":"bitbucket","code":"f171"},{"name":"bitbucket-square","code":"f172"},{"name":"bitcoin","code":"f15a"},{"name":"black-tie","code":"f27e"},{"name":"bluetooth","code":"f293"},{"name":"bluetooth-b","code":"f294"},{"name":"bold","code":"f032"},{"name":"bolt","code":"f0e7"},{"name":"bomb","code":"f1e2"},{"name":"book","code":"f02d"},{"name":"bookmark","code":"f02e"},{"name":"bookmark-o","code":"f097"},{"name":"briefcase","code":"f0b1"},{"name":"btc","code":"f15a"},{"name":"bug","code":"f188"},{"name":"building","code":"f1ad"},{"name":"building-o","code":"f0f7"},{"name":"bullhorn","code":"f0a1"},{"name":"bullseye","code":"f140"},{"name":"bus","code":"f207"},{"name":"buysellads","code":"f20d"},{"name":"cab","code":"f1ba"},{"name":"calculator","code":"f1ec"},{"name":"calendar","code":"f073"},{"name":"calendar-check-o","code":"f274"},{"name":"calendar-minus-o","code":"f272"},{"name":"calendar-o","code":"f133"},{"name":"calendar-plus-o","code":"f271"},{"name":"calendar-times-o","code":"f273"},{"name":"camera","code":"f030"},{"name":"camera-retro","code":"f083"},{"name":"car","code":"f1b9"},{"name":"caret-down","code":"f0d7"},{"name":"caret-left","code":"f0d9"},{"name":"caret-right","code":"f0da"},{"name":"caret-square-o-down","code":"f150"},{"name":"caret-square-o-left","code":"f191"},{"name":"caret-square-o-right","code":"f152"},{"name":"caret-square-o-up","code":"f151"},{"name":"caret-up","code":"f0d8"},{"name":"cart-arrow-down","code":"f218"},{"name":"cart-plus","code":"f217"},{"name":"cc","code":"f20a"},{"name":"cc-amex","code":"f1f3"},{"name":"cc-diners-club","code":"f24c"},{"name":"cc-discover","code":"f1f2"},{"name":"cc-jcb","code":"f24b"},{"name":"cc-mastercard","code":"f1f1"},{"name":"cc-paypal","code":"f1f4"},{"name":"cc-stripe","code":"f1f5"},{"name":"cc-visa","code":"f1f0"},{"name":"certificate","code":"f0a3"},{"name":"chain","code":"f0c1"},{"name":"chain-broken","code":"f127"},{"name":"check","code":"f00c"},{"name":"check-circle","code":"f058"},{"name":"check-circle-o","code":"f05d"},{"name":"check-square","code":"f14a"},{"name":"check-square-o","code":"f046"},{"name":"chevron-circle-down","code":"f13a"},{"name":"chevron-circle-left","code":"f137"},{"name":"chevron-circle-right","code":"f138"},{"name":"chevron-circle-up","code":"f139"},{"name":"chevron-down","code":"f078"},{"name":"chevron-left","code":"f053"},{"name":"chevron-right","code":"f054"},{"name":"chevron-up","code":"f077"},{"name":"child","code":"f1ae"},{"name":"chrome","code":"f268"},{"name":"circle","code":"f111"},{"name":"circle-o","code":"f10c"},{"name":"circle-o-notch","code":"f1ce"},{"name":"circle-thin","code":"f1db"},{"name":"clipboard","code":"f0ea"},{"name":"clock-o","code":"f017"},{"name":"clone","code":"f24d"},{"name":"close","code":"f00d"},{"name":"cloud","code":"f0c2"},{"name":"cloud-download","code":"f0ed"},{"name":"cloud-upload","code":"f0ee"},{"name":"cny","code":"f157"},{"name":"code","code":"f121"},{"name":"code-fork","code":"f126"},{"name":"codepen","code":"f1cb"},{"name":"codiepie","code":"f284"},{"name":"coffee","code":"f0f4"},{"name":"cog","code":"f013"},{"name":"cogs","code":"f085"},{"name":"columns","code":"f0db"},{"name":"comment","code":"f075"},{"name":"comment-o","code":"f0e5"},{"name":"commenting","code":"f27a"},{"name":"commenting-o","code":"f27b"},{"name":"comments","code":"f086"},{"name":"comments-o","code":"f0e6"},{"name":"compass","code":"f14e"},{"name":"compress","code":"f066"},{"name":"connectdevelop","code":"f20e"},{"name":"contao","code":"f26d"},{"name":"copy","code":"f0c5"},{"name":"copyright","code":"f1f9"},{"name":"creative-commons","code":"f25e"},{"name":"credit-card","code":"f09d"},{"name":"credit-card-alt","code":"f283"},{"name":"crop","code":"f125"},{"name":"crosshairs","code":"f05b"},{"name":"css3","code":"f13c"},{"name":"cube","code":"f1b2"},{"name":"cubes","code":"f1b3"},{"name":"cut","code":"f0c4"},{"name":"cutlery","code":"f0f5"},{"name":"dashboard","code":"f0e4"},{"name":"dashcube","code":"f210"},{"name":"database","code":"f1c0"},{"name":"dedent","code":"f03b"},{"name":"delicious","code":"f1a5"},{"name":"desktop","code":"f108"},{"name":"deviantart","code":"f1bd"},{"name":"diamond","code":"f219"},{"name":"digg","code":"f1a6"},{"name":"dollar","code":"f155"},{"name":"dot-circle-o","code":"f192"},{"name":"download","code":"f019"},{"name":"dribbble","code":"f17d"},{"name":"dropbox","code":"f16b"},{"name":"drupal","code":"f1a9"},{"name":"edge","code":"f282"},{"name":"edit","code":"f044"},{"name":"eject","code":"f052"},{"name":"ellipsis-h","code":"f141"},{"name":"ellipsis-v","code":"f142"},{"name":"empire","code":"f1d1"},{"name":"envelope","code":"f0e0"},{"name":"envelope-o","code":"f003"},{"name":"envelope-square","code":"f199"},{"name":"eraser","code":"f12d"},{"name":"eur","code":"f153"},{"name":"euro","code":"f153"},{"name":"exchange","code":"f0ec"},{"name":"exclamation","code":"f12a"},{"name":"exclamation-circle","code":"f06a"},{"name":"exclamation-triangle","code":"f071"},{"name":"expand","code":"f065"},{"name":"expeditedssl","code":"f23e"},{"name":"external-link","code":"f08e"},{"name":"external-link-square","code":"f14c"},{"name":"eye","code":"f06e"},{"name":"eye-slash","code":"f070"},{"name":"eyedropper","code":"f1fb"},{"name":"facebook","code":"f09a"},{"name":"facebook-f","code":"f09a"},{"name":"facebook-official","code":"f230"},{"name":"facebook-square","code":"f082"},{"name":"fast-backward","code":"f049"},{"name":"fast-forward","code":"f050"},{"name":"fax","code":"f1ac"},{"name":"feed","code":"f09e"},{"name":"female","code":"f182"},{"name":"fighter-jet","code":"f0fb"},{"name":"file","code":"f15b"},{"name":"file-archive-o","code":"f1c6"},{"name":"file-audio-o","code":"f1c7"},{"name":"file-code-o","code":"f1c9"},{"name":"file-excel-o","code":"f1c3"},{"name":"file-image-o","code":"f1c5"},{"name":"file-movie-o","code":"f1c8"},{"name":"file-o","code":"f016"},{"name":"file-pdf-o","code":"f1c1"},{"name":"file-photo-o","code":"f1c5"},{"name":"file-picture-o","code":"f1c5"},{"name":"file-powerpoint-o","code":"f1c4"},{"name":"file-sound-o","code":"f1c7"},{"name":"file-text","code":"f15c"},{"name":"file-text-o","code":"f0f6"},{"name":"file-video-o","code":"f1c8"},{"name":"file-word-o","code":"f1c2"},{"name":"file-zip-o","code":"f1c6"},{"name":"files-o","code":"f0c5"},{"name":"film","code":"f008"},{"name":"filter","code":"f0b0"},{"name":"fire","code":"f06d"},{"name":"fire-extinguisher","code":"f134"},{"name":"firefox","code":"f269"},{"name":"flag","code":"f024"},{"name":"flag-checkered","code":"f11e"},{"name":"flag-o","code":"f11d"},{"name":"flash","code":"f0e7"},{"name":"flask","code":"f0c3"},{"name":"flickr","code":"f16e"},{"name":"floppy-o","code":"f0c7"},{"name":"folder","code":"f07b"},{"name":"folder-o","code":"f114"},{"name":"folder-open","code":"f07c"},{"name":"folder-open-o","code":"f115"},{"name":"font","code":"f031"},{"name":"fonticons","code":"f280"},{"name":"fort-awesome","code":"f286"},{"name":"forumbee","code":"f211"},{"name":"forward","code":"f04e"},{"name":"foursquare","code":"f180"},{"name":"frown-o","code":"f119"},{"name":"futbol-o","code":"f1e3"},{"name":"gamepad","code":"f11b"},{"name":"gavel","code":"f0e3"},{"name":"gbp","code":"f154"},{"name":"ge","code":"f1d1"},{"name":"gear","code":"f013"},{"name":"gears","code":"f085"},{"name":"genderless","code":"f22d"},{"name":"get-pocket","code":"f265"},{"name":"gg","code":"f260"},{"name":"gg-circle","code":"f261"},{"name":"gift","code":"f06b"},{"name":"git","code":"f1d3"},{"name":"git-square","code":"f1d2"},{"name":"github","code":"f09b"},{"name":"github-alt","code":"f113"},{"name":"github-square","code":"f092"},{"name":"gittip","code":"f184"},{"name":"glass","code":"f000"},{"name":"globe","code":"f0ac"},{"name":"google","code":"f1a0"},{"name":"google-plus","code":"f0d5"},{"name":"google-plus-square","code":"f0d4"},{"name":"google-wallet","code":"f1ee"},{"name":"graduation-cap","code":"f19d"},{"name":"gratipay","code":"f184"},{"name":"group","code":"f0c0"},{"name":"h-square","code":"f0fd"},{"name":"hacker-news","code":"f1d4"},{"name":"hand-grab-o","code":"f255"},{"name":"hand-lizard-o","code":"f258"},{"name":"hand-o-down","code":"f0a7"},{"name":"hand-o-left","code":"f0a5"},{"name":"hand-o-right","code":"f0a4"},{"name":"hand-o-up","code":"f0a6"},{"name":"hand-paper-o","code":"f256"},{"name":"hand-peace-o","code":"f25b"},{"name":"hand-pointer-o","code":"f25a"},{"name":"hand-rock-o","code":"f255"},{"name":"hand-scissors-o","code":"f257"},{"name":"hand-spock-o","code":"f259"},{"name":"hand-stop-o","code":"f256"},{"name":"hashtag","code":"f292"},{"name":"hdd-o","code":"f0a0"},{"name":"header","code":"f1dc"},{"name":"headphones","code":"f025"},{"name":"heart","code":"f004"},{"name":"heart-o","code":"f08a"},{"name":"heartbeat","code":"f21e"},{"name":"history","code":"f1da"},{"name":"home","code":"f015"},{"name":"hospital-o","code":"f0f8"},{"name":"hotel","code":"f236"},{"name":"hourglass","code":"f254"},{"name":"hourglass-1","code":"f251"},{"name":"hourglass-2","code":"f252"},{"name":"hourglass-3","code":"f253"},{"name":"hourglass-end","code":"f253"},{"name":"hourglass-half","code":"f252"},{"name":"hourglass-o","code":"f250"},{"name":"hourglass-start","code":"f251"},{"name":"houzz","code":"f27c"},{"name":"html5","code":"f13b"},{"name":"i-cursor","code":"f246"},{"name":"ils","code":"f20b"},{"name":"image","code":"f03e"},{"name":"inbox","code":"f01c"},{"name":"indent","code":"f03c"},{"name":"industry","code":"f275"},{"name":"info","code":"f129"},{"name":"info-circle","code":"f05a"},{"name":"inr","code":"f156"},{"name":"instagram","code":"f16d"},{"name":"institution","code":"f19c"},{"name":"internet-explorer","code":"f26b"},{"name":"intersex","code":"f224"},{"name":"ioxhost","code":"f208"},{"name":"italic","code":"f033"},{"name":"joomla","code":"f1aa"},{"name":"jpy","code":"f157"},{"name":"jsfiddle","code":"f1cc"},{"name":"key","code":"f084"},{"name":"keyboard-o","code":"f11c"},{"name":"krw","code":"f159"},{"name":"language","code":"f1ab"},{"name":"laptop","code":"f109"},{"name":"lastfm","code":"f202"},{"name":"lastfm-square","code":"f203"},{"name":"leaf","code":"f06c"},{"name":"leanpub","code":"f212"},{"name":"legal","code":"f0e3"},{"name":"lemon-o","code":"f094"},{"name":"level-down","code":"f149"},{"name":"level-up","code":"f148"},{"name":"life-bouy","code":"f1cd"},{"name":"life-buoy","code":"f1cd"},{"name":"life-ring","code":"f1cd"},{"name":"life-saver","code":"f1cd"},{"name":"lightbulb-o","code":"f0eb"},{"name":"line-chart","code":"f201"},{"name":"link","code":"f0c1"},{"name":"linkedin","code":"f0e1"},{"name":"linkedin-square","code":"f08c"},{"name":"linux","code":"f17c"},{"name":"list","code":"f03a"},{"name":"list-alt","code":"f022"},{"name":"list-ol","code":"f0cb"},{"name":"list-ul","code":"f0ca"},{"name":"location-arrow","code":"f124"},{"name":"lock","code":"f023"},{"name":"long-arrow-down","code":"f175"},{"name":"long-arrow-left","code":"f177"},{"name":"long-arrow-right","code":"f178"},{"name":"long-arrow-up","code":"f176"},{"name":"magic","code":"f0d0"},{"name":"magnet","code":"f076"},{"name":"mail-forward","code":"f064"},{"name":"mail-reply","code":"f112"},{"name":"mail-reply-all","code":"f122"},{"name":"male","code":"f183"},{"name":"map","code":"f279"},{"name":"map-marker","code":"f041"},{"name":"map-o","code":"f278"},{"name":"map-pin","code":"f276"},{"name":"map-signs","code":"f277"},{"name":"mars","code":"f222"},{"name":"mars-double","code":"f227"},{"name":"mars-stroke","code":"f229"},{"name":"mars-stroke-h","code":"f22b"},{"name":"mars-stroke-v","code":"f22a"},{"name":"maxcdn","code":"f136"},{"name":"meanpath","code":"f20c"},{"name":"medium","code":"f23a"},{"name":"medkit","code":"f0fa"},{"name":"meh-o","code":"f11a"},{"name":"mercury","code":"f223"},{"name":"microphone","code":"f130"},{"name":"microphone-slash","code":"f131"},{"name":"minus","code":"f068"},{"name":"minus-circle","code":"f056"},{"name":"minus-square","code":"f146"},{"name":"minus-square-o","code":"f147"},{"name":"mixcloud","code":"f289"},{"name":"mobile","code":"f10b"},{"name":"mobile-phone","code":"f10b"},{"name":"modx","code":"f285"},{"name":"money","code":"f0d6"},{"name":"moon-o","code":"f186"},{"name":"mortar-board","code":"f19d"},{"name":"motorcycle","code":"f21c"},{"name":"mouse-pointer","code":"f245"},{"name":"music","code":"f001"},{"name":"navicon","code":"f0c9"},{"name":"neuter","code":"f22c"},{"name":"newspaper-o","code":"f1ea"},{"name":"object-group","code":"f247"},{"name":"object-ungroup","code":"f248"},{"name":"odnoklassniki","code":"f263"},{"name":"odnoklassniki-square","code":"f264"},{"name":"opencart","code":"f23d"},{"name":"openid","code":"f19b"},{"name":"opera","code":"f26a"},{"name":"optin-monster","code":"f23c"},{"name":"outdent","code":"f03b"},{"name":"pagelines","code":"f18c"},{"name":"paint-brush","code":"f1fc"},{"name":"paper-plane","code":"f1d8"},{"name":"paper-plane-o","code":"f1d9"},{"name":"paperclip","code":"f0c6"},{"name":"paragraph","code":"f1dd"},{"name":"paste","code":"f0ea"},{"name":"pause","code":"f04c"},{"name":"pause-circle","code":"f28b"},{"name":"pause-circle-o","code":"f28c"},{"name":"paw","code":"f1b0"},{"name":"paypal","code":"f1ed"},{"name":"pencil","code":"f040"},{"name":"pencil-square","code":"f14b"},{"name":"pencil-square-o","code":"f044"},{"name":"percent","code":"f295"},{"name":"phone","code":"f095"},{"name":"phone-square","code":"f098"},{"name":"photo","code":"f03e"},{"name":"picture-o","code":"f03e"},{"name":"pie-chart","code":"f200"},{"name":"pied-piper","code":"f1a7"},{"name":"pied-piper-alt","code":"f1a8"},{"name":"pinterest","code":"f0d2"},{"name":"pinterest-p","code":"f231"},{"name":"pinterest-square","code":"f0d3"},{"name":"plane","code":"f072"},{"name":"play","code":"f04b"},{"name":"play-circle","code":"f144"},{"name":"play-circle-o","code":"f01d"},{"name":"plug","code":"f1e6"},{"name":"plus","code":"f067"},{"name":"plus-circle","code":"f055"},{"name":"plus-square","code":"f0fe"},{"name":"plus-square-o","code":"f196"},{"name":"power-off","code":"f011"},{"name":"print","code":"f02f"},{"name":"product-hunt","code":"f288"},{"name":"puzzle-piece","code":"f12e"},{"name":"qq","code":"f1d6"},{"name":"qrcode","code":"f029"},{"name":"question","code":"f128"},{"name":"question-circle","code":"f059"},{"name":"quote-left","code":"f10d"},{"name":"quote-right","code":"f10e"},{"name":"ra","code":"f1d0"},{"name":"random","code":"f074"},{"name":"rebel","code":"f1d0"},{"name":"recycle","code":"f1b8"},{"name":"reddit","code":"f1a1"},{"name":"reddit-alien","code":"f281"},{"name":"reddit-square","code":"f1a2"},{"name":"refresh","code":"f021"},{"name":"registered","code":"f25d"},{"name":"remove","code":"f00d"},{"name":"renren","code":"f18b"},{"name":"reorder","code":"f0c9"},{"name":"repeat","code":"f01e"},{"name":"reply","code":"f112"},{"name":"reply-all","code":"f122"},{"name":"retweet","code":"f079"},{"name":"rmb","code":"f157"},{"name":"road","code":"f018"},{"name":"rocket","code":"f135"},{"name":"rotate-left","code":"f0e2"},{"name":"rotate-right","code":"f01e"},{"name":"rouble","code":"f158"},{"name":"rss","code":"f09e"},{"name":"rss-square","code":"f143"},{"name":"rub","code":"f158"},{"name":"ruble","code":"f158"},{"name":"rupee","code":"f156"},{"name":"safari","code":"f267"},{"name":"save","code":"f0c7"},{"name":"scissors","code":"f0c4"},{"name":"scribd","code":"f28a"},{"name":"search","code":"f002"},{"name":"search-minus","code":"f010"},{"name":"search-plus","code":"f00e"},{"name":"sellsy","code":"f213"},{"name":"send","code":"f1d8"},{"name":"send-o","code":"f1d9"},{"name":"server","code":"f233"},{"name":"share","code":"f064"},{"name":"share-alt","code":"f1e0"},{"name":"share-alt-square","code":"f1e1"},{"name":"share-square","code":"f14d"},{"name":"share-square-o","code":"f045"},{"name":"shekel","code":"f20b"},{"name":"sheqel","code":"f20b"},{"name":"shield","code":"f132"},{"name":"ship","code":"f21a"},{"name":"shirtsinbulk","code":"f214"},{"name":"shopping-bag","code":"f290"},{"name":"shopping-basket","code":"f291"},{"name":"shopping-cart","code":"f07a"},{"name":"sign-in","code":"f090"},{"name":"sign-out","code":"f08b"},{"name":"signal","code":"f012"},{"name":"simplybuilt","code":"f215"},{"name":"sitemap","code":"f0e8"},{"name":"skyatlas","code":"f216"},{"name":"skype","code":"f17e"},{"name":"slack","code":"f198"},{"name":"sliders","code":"f1de"},{"name":"slideshare","code":"f1e7"},{"name":"smile-o","code":"f118"},{"name":"soccer-ball-o","code":"f1e3"},{"name":"sort","code":"f0dc"},{"name":"sort-alpha-asc","code":"f15d"},{"name":"sort-alpha-desc","code":"f15e"},{"name":"sort-amount-asc","code":"f160"},{"name":"sort-amount-desc","code":"f161"},{"name":"sort-asc","code":"f0de"},{"name":"sort-desc","code":"f0dd"},{"name":"sort-down","code":"f0dd"},{"name":"sort-numeric-asc","code":"f162"},{"name":"sort-numeric-desc","code":"f163"},{"name":"sort-up","code":"f0de"},{"name":"soundcloud","code":"f1be"},{"name":"space-shuttle","code":"f197"},{"name":"spinner","code":"f110"},{"name":"spoon","code":"f1b1"},{"name":"spotify","code":"f1bc"},{"name":"square","code":"f0c8"},{"name":"square-o","code":"f096"},{"name":"stack-exchange","code":"f18d"},{"name":"stack-overflow","code":"f16c"},{"name":"star","code":"f005"},{"name":"star-half","code":"f089"},{"name":"star-half-empty","code":"f123"},{"name":"star-half-full","code":"f123"},{"name":"star-half-o","code":"f123"},{"name":"star-o","code":"f006"},{"name":"steam","code":"f1b6"},{"name":"steam-square","code":"f1b7"},{"name":"step-backward","code":"f048"},{"name":"step-forward","code":"f051"},{"name":"stethoscope","code":"f0f1"},{"name":"sticky-note","code":"f249"},{"name":"sticky-note-o","code":"f24a"},{"name":"stop","code":"f04d"},{"name":"stop-circle","code":"f28d"},{"name":"stop-circle-o","code":"f28e"},{"name":"street-view","code":"f21d"},{"name":"strikethrough","code":"f0cc"},{"name":"stumbleupon","code":"f1a4"},{"name":"stumbleupon-circle","code":"f1a3"},{"name":"subscript","code":"f12c"},{"name":"subway","code":"f239"},{"name":"suitcase","code":"f0f2"},{"name":"sun-o","code":"f185"},{"name":"superscript","code":"f12b"},{"name":"support","code":"f1cd"},{"name":"table","code":"f0ce"},{"name":"tablet","code":"f10a"},{"name":"tachometer","code":"f0e4"},{"name":"tag","code":"f02b"},{"name":"tags","code":"f02c"},{"name":"tasks","code":"f0ae"},{"name":"taxi","code":"f1ba"},{"name":"television","code":"f26c"},{"name":"tencent-weibo","code":"f1d5"},{"name":"terminal","code":"f120"},{"name":"text-height","code":"f034"},{"name":"text-width","code":"f035"},{"name":"th","code":"f00a"},{"name":"th-large","code":"f009"},{"name":"th-list","code":"f00b"},{"name":"thumb-tack","code":"f08d"},{"name":"thumbs-down","code":"f165"},{"name":"thumbs-o-down","code":"f088"},{"name":"thumbs-o-up","code":"f087"},{"name":"thumbs-up","code":"f164"},{"name":"ticket","code":"f145"},{"name":"times","code":"f00d"},{"name":"times-circle","code":"f057"},{"name":"times-circle-o","code":"f05c"},{"name":"tint","code":"f043"},{"name":"toggle-down","code":"f150"},{"name":"toggle-left","code":"f191"},{"name":"toggle-off","code":"f204"},{"name":"toggle-on","code":"f205"},{"name":"toggle-right","code":"f152"},{"name":"toggle-up","code":"f151"},{"name":"trademark","code":"f25c"},{"name":"train","code":"f238"},{"name":"transgender","code":"f224"},{"name":"transgender-alt","code":"f225"},{"name":"trash","code":"f1f8"},{"name":"trash-o","code":"f014"},{"name":"tree","code":"f1bb"},{"name":"trello","code":"f181"},{"name":"tripadvisor","code":"f262"},{"name":"trophy","code":"f091"},{"name":"truck","code":"f0d1"},{"name":"try","code":"f195"},{"name":"tty","code":"f1e4"},{"name":"tumblr","code":"f173"},{"name":"tumblr-square","code":"f174"},{"name":"turkish-lira","code":"f195"},{"name":"tv","code":"f26c"},{"name":"twitch","code":"f1e8"},{"name":"twitter","code":"f099"},{"name":"twitter-square","code":"f081"},{"name":"umbrella","code":"f0e9"},{"name":"underline","code":"f0cd"},{"name":"undo","code":"f0e2"},{"name":"university","code":"f19c"},{"name":"unlink","code":"f127"},{"name":"unlock","code":"f09c"},{"name":"unlock-alt","code":"f13e"},{"name":"unsorted","code":"f0dc"},{"name":"upload","code":"f093"},{"name":"usb","code":"f287"},{"name":"usd","code":"f155"},{"name":"user","code":"f007"},{"name":"user-md","code":"f0f0"},{"name":"user-plus","code":"f234"},{"name":"user-secret","code":"f21b"},{"name":"user-times","code":"f235"},{"name":"users","code":"f0c0"},{"name":"venus","code":"f221"},{"name":"venus-double","code":"f226"},{"name":"venus-mars","code":"f228"},{"name":"viacoin","code":"f237"},{"name":"video-camera","code":"f03d"},{"name":"vimeo","code":"f27d"},{"name":"vimeo-square","code":"f194"},{"name":"vine","code":"f1ca"},{"name":"vk","code":"f189"},{"name":"volume-down","code":"f027"},{"name":"volume-off","code":"f026"},{"name":"volume-up","code":"f028"},{"name":"warning","code":"f071"},{"name":"wechat","code":"f1d7"},{"name":"weibo","code":"f18a"},{"name":"weixin","code":"f1d7"},{"name":"whatsapp","code":"f232"},{"name":"wheelchair","code":"f193"},{"name":"wifi","code":"f1eb"},{"name":"wikipedia-w","code":"f266"},{"name":"windows","code":"f17a"},{"name":"won","code":"f159"},{"name":"wordpress","code":"f19a"},{"name":"wrench","code":"f0ad"},{"name":"xing","code":"f168"},{"name":"xing-square","code":"f169"},{"name":"y-combinator","code":"f23b"},{"name":"y-combinator-square","code":"f1d4"},{"name":"yahoo","code":"f19e"},{"name":"yc","code":"f23b"},{"name":"yc-square","code":"f1d4"},{"name":"yelp","code":"f1e9"},{"name":"yen","code":"f157"},{"name":"youtube","code":"f167"},{"name":"youtube-play","code":"f16a"},{"name":"youtube-square","code":"f166"}];
};

GS.lorem = function () {
    return 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.';
};

if (!String.prototype.repeat) {
  String.prototype.repeat = function(count) {
    'use strict';
    if (this == null) {
      throw new TypeError('can\'t convert ' + this + ' to object');
    }
    var str = '' + this;
    count = +count;
    if (count != count) {
      count = 0;
    }
    if (count < 0) {
      throw new RangeError('repeat count must be non-negative');
    }
    if (count == Infinity) {
      throw new RangeError('repeat count must be less than infinity');
    }
    count = Math.floor(count);
    if (str.length == 0 || count == 0) {
      return '';
    }
    // Ensuring count is a 31-bit integer allows us to heavily optimize the
    // main part. But anyway, most current (August 2014) browsers can't handle
    // strings 1 << 28 chars or longer, so:
    if (str.length * count >= 1 << 28) {
      throw new RangeError('repeat count must not overflow maximum string size');
    }
    var rpt = '';
    for (;;) {
      if ((count & 1) == 1) {
        rpt += str;
      }
      count >>>= 1;
      if (count == 0) {
        break;
      }
      str += str;
    }
    // Could we try:
    // return Array(count + 1).join(this);
    return rpt;
  }
}
if (!String.prototype.trim) {
  String.prototype.trim = function () {
    return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
  };
}
window.addEventListener('design-register-element', function () {
    registerDesignSnippet('Add Loader (to page)', 'GS.addLoader', 'addLoader(\'${0:class-name}\', \'${1:Loading...}\');');
    registerDesignSnippet('Add Loader (to element)', 'GS.addLoader', 'addLoader(${0:document.getElementById(\'id\')}, \'${1:Loading...}\');');
    registerDesignSnippet('Remove Loader (from page)', 'GS.removeLoader', 'removeLoader(\'${0:class-name}\');');
    registerDesignSnippet('Remove Loader (from element)', 'GS.removeLoader', 'removeLoader(${0:document.getElementById(\'id\')});');
});

document.addEventListener('DOMContentLoaded', function () {
    xtag.register('gs-loader', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {}
    });
});

GS.addLoader = function (loaderClassOrTarget, loaderContent) {
    var loaderElement = document.createElement('gs-loader'), loaderClass, loaderTarget;

    // turn loaderClassOrTarget into class or target
    if (typeof loaderClassOrTarget === 'string') {
        loaderClass = loaderClassOrTarget;

    } else if (typeof loaderClassOrTarget === 'object') {
        loaderTarget = loaderClassOrTarget;
    }

    // if there is a loader class: add class to loader for future identification
    if (loaderClass) {
        loaderElement.classList.add('loader-' + loaderClass);
    }

    // default loader target to body
    if (!loaderTarget) {
        loaderTarget = document.body;
    }

    // add spinning elements and loader content to loader container
    loaderElement.innerHTML =   '<div class="loader-positioning" gs-dynamic>' +
                                    '<div class="loader" gs-dynamic></div>' +
                                    '<div class="loader-inner spinning" gs-dynamic></div>' +
                                    '<div class="loader-inner-inner spinning" gs-dynamic></div>' +
                                    '<div class="loader-inner-inner-inner spinning" gs-dynamic></div>' +
                                    (loaderContent ? '<div class="loader-content" gs-dynamic>' + loaderContent + '</div>' : '') +
                                '</div>';

    // prevent scrolling on a loader
    loaderElement.addEventListener('mousewheel', function (event) {
        event.preventDefault();
    });

    // append loader to target
    loaderTarget.appendChild(loaderElement); // document.body
};

GS.removeLoader = function (loaderClassOrTarget) {
    var element, i, len, arrLoaders, loaderClass, loaderTarget;

    if (typeof loaderClassOrTarget === 'string') {
        loaderClass = loaderClassOrTarget;

    } else if (typeof loaderClassOrTarget === 'object') {
        loaderTarget = loaderClassOrTarget;
    }

    if (loaderClass) {
        element = document.getElementsByClassName('loader-' + loaderClass)[0];

    } else if (loaderTarget) {
        element = xtag.queryChildren(loaderTarget, 'gs-loader')[0];

    } else {
        arrLoaders = xtag.queryChildren(document.body, 'gs-loader');

        for (i = 0, len = arrLoaders.length; i < len; i += 1) {
            if (!arrLoaders[i].hasAttribute('id')) {
                element = arrLoaders[i];
                break;
            }
        }
    }

    if (element) {
        element.parentNode.removeChild(element);
    } else {
        console.warn('GS.removeLoader Error: loader' + (loaderClass ? ' class: "' + loaderClass + '"' : '') + ' not found');
    }
};

GS.removeAllLoaders = function () {
    'use strict';
    var i, len, arrLoaders;

    arrLoaders = xtag.query(document.body, 'gs-loader');

    for (i = 0, len = arrLoaders.length; i < len; i += 1) {
        if (!arrLoaders[i].hasAttribute('id')) {
            arrLoaders[i].parentNode.removeChild(arrLoaders[i]);
        }
    }
};
window.addEventListener('design-register-element', function () {
    window.designElementProperty_GSBODY = function(selectedElement) {
        addFlexContainerProps(selectedElement);
        //addFlexProps(selectedElement);

        addProp('Padded', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('padded')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'padded', (this.value === 'true'), true);
        });
    };

    registerDesignSnippet('<gs-body>', '<gs-body>', 'gs-body>\n' +
                                                    '    $0\n' +
                                                    '</gs-body>');

    designRegisterElement('gs-body', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-page.html');
});

document.addEventListener('DOMContentLoaded', function () {
    xtag.register('gs-body', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {}
    });
});

(function () {
    'use strict';

    function defineButton(strTagName, strDocLink, arrDisableWhenEmptyAttributes, designAdditionalFunction, clickFunction) {
        strDocLink = strDocLink || '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-buttons-toggle.html';
        designAdditionalFunction = designAdditionalFunction || function () {};
        clickFunction = clickFunction || function () {};

        window.addEventListener('design-register-element', function () {
            registerDesignSnippet('<' + strTagName + '>', '<' + strTagName + '>', strTagName + '>${1}</' + strTagName + '>');

            designRegisterElement(strTagName, strDocLink);

            window['designElementProperty_' + strTagName.replace(/[^a-z0-9]/gi, '').toUpperCase()] = function (selectedElement) {
                var strIconPos = '', strIconRotation = '', strVisibilityAttribute = '', strFontAttribute = '', strBackgroundAttribute = '';

                addProp('Icon', true, '<div flex-horizontal>' +
                                      '     <gs-text id="prop-icon-input" class="target" value="' + (selectedElement.getAttribute('icon') || '') +
                                                                                                            '" mini flex></gs-text>' +
                                      '     <gs-button id="prop-icon-picker-button" mini icononly icon="list"></gs-button>' +
                                      '     <style>#prop-icon-picker-button:after {font-size: 1em;}</style>' +
                                      '</div>', function () {
                    return setOrRemoveTextAttribute(selectedElement, 'icon', this.value, false);
                });

                document.getElementById('prop-icon-picker-button').addEventListener('click', function () {
                    var i, len, html, arrIcons = GS.iconList(), strName, templateElement;

                    for (i = 0, len = arrIcons.length, html = ''; i < len; i += 1) {
                        strName = arrIcons[i].name;
                        html += '<gs-block>' +
                                    '<gs-button iconleft icon="' + strName + '" dialogclose>' + strName + '</gs-button>' +
                                '</gs-block>';
                    }

                    templateElement = document.createElement('template');
                    templateElement.setAttribute('data-max-width', '1100px');
                    templateElement.innerHTML =
                        '<gs-page>' +
                        '    <gs-header><center><h3>Choose An Icon</h3></center></gs-header>' +
                        '    <gs-body padded><gs-grid widths="1,1,1,1" reflow-at="767px">' + html + '</gs-grid></gs-body>' +
                        '    <gs-footer><gs-button dialogclose>Cancel</gs-button></gs-footer>' +
                        '</gs-page>';

                    GS.openDialog(templateElement, '', function (event, strAnswer) {
                        var propInput = document.getElementById('prop-icon-input');

                        if (strAnswer !== 'Cancel') {
                            propInput.value = strAnswer;
                            GS.triggerEvent(propInput, 'change');
                        }
                    });
                });

                       if (selectedElement.hasAttribute('iconleft'))   { strIconPos = 'iconleft';
                } else if (selectedElement.hasAttribute('iconright'))  { strIconPos = 'iconright';
                } else if (selectedElement.hasAttribute('icontop'))    { strIconPos = 'icontop';
                } else if (selectedElement.hasAttribute('iconbottom')) { strIconPos = 'iconbottom';
                } else if (selectedElement.hasAttribute('icononly'))   { strIconPos = 'icononly'; }

                addProp('Icon Position', true, '<gs-select class="target" value="' + strIconPos + '" mini>' +
                                                    '   <option value="">Default</option>' +
                                                    '   <option value="iconleft">Left</option>' +
                                                    '   <option value="iconright">Right</option>' +
                                                    '   <option value="icontop">Top</option>' +
                                                    '   <option value="iconbottom">Bottom</option>' +
                                                    '   <option value="icononly">Icononly</option>' +
                                                    '</gs-select>', function () {
                    selectedElement.removeAttribute('iconleft');
                    selectedElement.removeAttribute('iconright');
                    selectedElement.removeAttribute('icontop');
                    selectedElement.removeAttribute('iconbottom');
                    selectedElement.removeAttribute('icononly');

                    if (this.value) {
                        selectedElement.setAttribute(this.value, '');
                    }

                    return selectedElement;
                });

                       if (selectedElement.hasAttribute('iconrotateright')) { strIconRotation = 'iconrotateright';
                } else if (selectedElement.hasAttribute('iconrotatedown'))  { strIconRotation = 'iconrotatedown';
                } else if (selectedElement.hasAttribute('iconrotateleft'))  { strIconRotation = 'iconrotateleft'; }

                addProp('Icon&nbsp;Rotation', true, '<gs-select class="target" value="' + strIconRotation + '" mini>' +
                                                    '   <option value="">None</option>' +
                                                    '   <option value="iconrotateright">90 degrees</option>' +
                                                    '   <option value="iconrotatedown">180 degrees</option>' +
                                                    '   <option value="iconrotateleft">270 degrees</option>' +
                                                    '</gs-select>', function () {
                    selectedElement.removeAttribute('iconrotateright');
                    selectedElement.removeAttribute('iconrotatedown');
                    selectedElement.removeAttribute('iconrotateleft');

                    if (this.value) {
                        selectedElement.setAttribute(this.value, '');
                    }

                    return selectedElement;
                });

                addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
                    return setOrRemoveTextAttribute(selectedElement, 'column', this.value, false);
                });

                addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
                    return setOrRemoveTextAttribute(selectedElement, 'value', this.value, false);
                });

                addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
                    return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
                });

                addProp('Jumbo', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('jumbo')) + '" mini></gs-checkbox>', function () {
                    return setOrRemoveBooleanAttribute(selectedElement, 'jumbo', (this.value === 'true'), true);
                });

                addProp('Focusable', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-focus')) + '" mini></gs-checkbox>', function () {
                    return setOrRemoveBooleanAttribute(selectedElement, 'no-focus', (this.value === 'true'), false);
                });
                /* TODO: remove emphasis and add other colors
                addProp('Emphasis', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('emphasis')) + '" mini></gs-checkbox>', function () {
                    return setOrRemoveBooleanAttribute(selectedElement, 'emphasis', (this.value === 'true'), true);
                });
                */


                //<gs-delete-button>

                // Font Color attributes
                strFontAttribute = '';
                if (selectedElement.hasAttribute('txt-primary'))  { strFontAttribute = 'txt-primary'; }
                if (selectedElement.hasAttribute('txt-success'))  { strFontAttribute = 'txt-success'; }
                if (selectedElement.hasAttribute('txt-info'))     { strFontAttribute = 'txt-info'; }
                if (selectedElement.hasAttribute('txt-warning'))  { strFontAttribute = 'txt-warning'; }
                if (selectedElement.hasAttribute('txt-danger'))   { strFontAttribute = 'txt-danger'; }

                addProp('Font Color', true, '<gs-select class="target" value="' + strFontAttribute + '" mini>' +
                                                '<option value="">Default</option>' +
                                                '<option value="txt-primary">Primary</option>' +
                                                '<option value="txt-success">Success</option>' +
                                                '<option value="txt-info">Info</option>' +
                                                '<option value="txt-warning">Warning</option>' +
                                                '<option value="txt-danger">Danger</option>' +
                                            '</gs-select>', function () {
                    selectedElement.removeAttribute('txt-primary');
                    selectedElement.removeAttribute('txt-success');
                    selectedElement.removeAttribute('txt-info');
                    selectedElement.removeAttribute('txt-warning');
                    selectedElement.removeAttribute('txt-danger');

                    if (this.value) {
                        selectedElement.setAttribute(this.value, '');
                    }

                    return selectedElement;
                });

                // Background Color attributes
                strBackgroundAttribute = '';
                if (selectedElement.hasAttribute('bg-primary'))  { strBackgroundAttribute = 'bg-primary'; }
                if (selectedElement.hasAttribute('bg-success'))  { strBackgroundAttribute = 'bg-success'; }
                if (selectedElement.hasAttribute('bg-info'))     { strBackgroundAttribute = 'bg-info'; }
                if (selectedElement.hasAttribute('bg-warning'))  { strBackgroundAttribute = 'bg-warning'; }
                if (selectedElement.hasAttribute('bg-danger'))   { strBackgroundAttribute = 'bg-danger'; }

                addProp('Background Color', true, '<gs-select class="target" value="' + strBackgroundAttribute + '" mini>' +
                                                '<option value="">Default</option>' +
                                                '<option value="bg-primary">Primary</option>' +
                                                '<option value="bg-success">Success</option>' +
                                                '<option value="bg-info">Info</option>' +
                                                '<option value="bg-warning">Warning</option>' +
                                                '<option value="bg-danger">Danger</option>' +
                                            '</gs-select>', function () {
                    selectedElement.removeAttribute('bg-primary');
                    selectedElement.removeAttribute('bg-success');
                    selectedElement.removeAttribute('bg-info');
                    selectedElement.removeAttribute('bg-warning');
                    selectedElement.removeAttribute('bg-danger');

                    if (this.value) {
                        selectedElement.setAttribute(this.value, '');
                    }

                    return selectedElement;
                });

                addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '0') + '" mini></gs-number>', function () {
                    return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
                });

                addProp('Inline', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('inline')) + '" mini></gs-checkbox>', function () {
                    return setOrRemoveBooleanAttribute(selectedElement, 'inline', (this.value === 'true'), true);
                });
                addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
                    return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
                });

                addProp('Key', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('key') || '') + '" mini></gs-text>', function () {
                    return setOrRemoveTextAttribute(selectedElement, 'key', this.value, false);
                });

                addProp('No Modifier Key For Hot Key', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-modifier-key') || '') + '" mini></gs-checkbox>', function () {
                    return setOrRemoveBooleanAttribute(selectedElement, 'no-modifier-key', this.value === 'true', true);
                });

                // TITLE attribute
                addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
                    return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
                });

                // DISABLED attribute
                addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
                    return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
                });

                // SUSPEND-INSERTED attribute
                addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
                    return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
                });

                // visibility attributes
                if (selectedElement.hasAttribute('hidden'))          { strVisibilityAttribute = 'hidden'; }
                if (selectedElement.hasAttribute('hide-on-desktop')) { strVisibilityAttribute = 'hide-on-desktop'; }
                if (selectedElement.hasAttribute('hide-on-tablet'))  { strVisibilityAttribute = 'hide-on-tablet'; }
                if (selectedElement.hasAttribute('hide-on-phone'))   { strVisibilityAttribute = 'hide-on-phone'; }
                if (selectedElement.hasAttribute('show-on-desktop')) { strVisibilityAttribute = 'show-on-desktop'; }
                if (selectedElement.hasAttribute('show-on-tablet'))  { strVisibilityAttribute = 'show-on-tablet'; }
                if (selectedElement.hasAttribute('show-on-phone'))   { strVisibilityAttribute = 'show-on-phone'; }

                addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                                '<option value="">Visible</option>' +
                                                '<option value="hidden">Invisible</option>' +
                                                '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                                '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                                '<option value="hide-on-phone">Invisible at phone size</option>' +
                                                '<option value="show-on-desktop">Visible at desktop size</option>' +
                                                '<option value="show-on-tablet">Visible at tablet size</option>' +
                                                '<option value="show-on-phone">Visible at phone size</option>' +
                                            '</gs-select>', function () {
                    selectedElement.removeAttribute('hidden');
                    selectedElement.removeAttribute('hide-on-desktop');
                    selectedElement.removeAttribute('hide-on-tablet');
                    selectedElement.removeAttribute('hide-on-phone');
                    selectedElement.removeAttribute('show-on-desktop');
                    selectedElement.removeAttribute('show-on-tablet');
                    selectedElement.removeAttribute('show-on-phone');

                    if (this.value) {
                        selectedElement.setAttribute(this.value, '');
                    }

                    return selectedElement;
                });

                // addProp('Corners', true,   '<div class="target">' +
                //                                 '<gs-grid>\n' +
                //                                 '    <gs-block>\n' +
                //                                 '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                //                                                             selectedElement.hasAttribute('remove-top') ||
                //                                                             selectedElement.hasAttribute('remove-left') ||
                //                                                             selectedElement.hasAttribute('remove-top-left'))).toString() +
                //                                             '" remove-right remove-bottom id="round-top-left-corner________"></gs-checkbox>' +

                //                                 '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                //                                                             selectedElement.hasAttribute('remove-bottom') ||
                //                                                             selectedElement.hasAttribute('remove-left') ||
                //                                                             selectedElement.hasAttribute('remove-bottom-left'))).toString() +
                //                                             '" remove-right remove-top id="round-bottom-left-corner________"></gs-checkbox>' +
                //                                 '    </gs-block>\n' +
                //                                 '    <gs-block>\n' +
                //                                 '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                //                                                             selectedElement.hasAttribute('remove-top') ||
                //                                                             selectedElement.hasAttribute('remove-right') ||
                //                                                             selectedElement.hasAttribute('remove-top-right'))).toString() +
                //                                             '" remove-left remove-bottom id="round-top-right-corner________"></gs-checkbox>' +

                //                                 '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                //                                                             selectedElement.hasAttribute('remove-bottom') ||
                //                                                             selectedElement.hasAttribute('remove-right') ||
                //                                                             selectedElement.hasAttribute('remove-bottom-right'))).toString() +
                //                                             '" remove-left remove-top id="round-bottom-right-corner________"></gs-checkbox>' +
                //                                 '    </gs-block>\n' +
                //                                 '</gs-grid>\n' +
                //                             '</div>', function () {
                //     var topLeft     = document.getElementById('round-top-left-corner________').value === 'true',
                //         topRight    = document.getElementById('round-top-right-corner________').value === 'true',
                //         bottomLeft  = document.getElementById('round-bottom-left-corner________').value === 'true',
                //         bottomRight = document.getElementById('round-bottom-right-corner________').value === 'true',
                //         arrStrAttr = [], i, len;

                //     selectedElement.removeAttribute('remove-all');
                //     selectedElement.removeAttribute('remove-top');
                //     selectedElement.removeAttribute('remove-bottom');
                //     selectedElement.removeAttribute('remove-left');
                //     selectedElement.removeAttribute('remove-right');
                //     selectedElement.removeAttribute('remove-top-left');
                //     selectedElement.removeAttribute('remove-top-right');
                //     selectedElement.removeAttribute('remove-bottom-left');
                //     selectedElement.removeAttribute('remove-bottom-right');

                //     if (!topLeft && !topRight && !bottomLeft && !bottomRight) {
                //         arrStrAttr.push('remove-all');
                //     } else if (!topLeft && !topRight) {
                //         arrStrAttr.push('remove-top');
                //     } else if (!bottomLeft && !bottomRight) {
                //         arrStrAttr.push('remove-bottom');

                //     } else if (!topLeft && !bottomLeft) {
                //         arrStrAttr.push('remove-left');
                //     } else if (!topRight && !bottomRight) {
                //         arrStrAttr.push('remove-right');
                //     }

                //     if (!topLeft && !bottomLeft && arrStrAttr[0] !== 'remove-all') {
                //         arrStrAttr.push('remove-left');
                //     } else if (!topLeft && topRight) {
                //         arrStrAttr.push('remove-top-left');
                //     } else if (!bottomLeft && bottomRight) {
                //         arrStrAttr.push('remove-bottom-left');
                //     }

                //     if (!topRight && !bottomRight && arrStrAttr[0] !== 'remove-all') {
                //         arrStrAttr.push('remove-right');
                //     } else if (topLeft && !topRight) {
                //         arrStrAttr.push('remove-top-right');
                //     } else if (bottomLeft && !bottomRight) {
                //         arrStrAttr.push('remove-bottom-right');
                //     }

                //     for (i = 0, len = arrStrAttr.length; i < len; i += 1) {
                //         selectedElement.setAttribute(arrStrAttr[i], '');
                //     }

                //     return selectedElement;
                // });

                designAdditionalFunction(selectedElement);
            };
        });

        document.addEventListener('DOMContentLoaded', function () {
            function handleDisable(element) {
                var i, len;

                element.removeAttribute('disabled');

                for (i = 0, len = arrDisableWhenEmptyAttributes.length; i < len; i += 1) {
                    if (!element.getAttribute(arrDisableWhenEmptyAttributes[i])) {
                        element.setAttribute('disabled', '');
                        break;
                    }
                }
            }

            //function pushReplacePopHandler(element) {
            //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');

            //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
            //        element.setAttribute('value', GS.qryGetVal(strQueryString, strQSCol));
            //    }
            //}
            function saveDefaultAttributes(element) {
                var i;
                var len;
                var arrAttr;
                var jsnAttr;

                // we need a place to store the attributes
                element.internal.defaultAttributes = {};

                // loop through attributes and store them in the internal defaultAttributes object
                arrAttr = element.attributes;
                i = 0;
                len = arrAttr.length;
                while (i < len) {
                    jsnAttr = arrAttr[i];

                    element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

                    i += 1;
                }
            }

            function pushReplacePopHandler(element) {
                var i;
                var len;
                var strQS = GS.getQueryString();
                var strQSCol = element.getAttribute('qs');
                var strQSValue;
                var strQSAttr;
                var arrQSParts;
                var arrAttrParts;
                var strOperator;

                if (strQSCol.indexOf('=') !== -1) {
                    arrAttrParts = strQSCol.split(',');
                    i = 0;
                    len = arrAttrParts.length;
                    while (i < len) {
                        strQSCol = arrAttrParts[i];

                        if (strQSCol.indexOf('!=') !== -1) {
                            strOperator = '!=';
                            arrQSParts = strQSCol.split('!=');
                        } else {
                            strOperator = '=';
                            arrQSParts = strQSCol.split('=');
                        }

                        strQSCol = arrQSParts[0];
                        strQSAttr = arrQSParts[1] || arrQSParts[0];

                        // if the key is not present or we've got the negator: go to the attribute's default or remove it
                        if (strOperator === '!=') {
                            // if the key is not present: add the attribute
                            if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                                element.setAttribute(strQSAttr, '');
                            // else: remove the attribute
                            } else {
                                element.removeAttribute(strQSAttr);
                            }
                        } else {
                            // if the key is not present: go to the attribute's default or remove it
                            if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                                if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                    element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                                } else {
                                    element.removeAttribute(strQSAttr);
                                }
                            // else: set attribute to exact text from QS
                            } else {
                                element.setAttribute(strQSAttr, (
                                    GS.qryGetVal(strQS, strQSCol) ||
                                    element.internal.defaultAttributes[strQSAttr] ||
                                    ''
                                ));
                            }
                        }
                        i += 1;
                    }
                } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                    strQSValue = GS.qryGetVal(strQS, strQSCol);

                    if (element.internal.bolQSFirstRun !== true) {
                        if (strQSValue !== '' || !element.getAttribute('value')) {
                            element.setAttribute('value', strQSValue);
                        }
                    } else {
                        element.setAttribute('value', strQSValue);
                    }
                }

                element.internal.bolQSFirstRun = true;
            }

            // dont do anything that modifies the element here
            function elementCreated(element) {
                // if "created" hasn't been suspended: run created code
                if (!element.hasAttribute('suspend-created')) {

                }
            }

            //
            function elementInserted(element) {
                var strKey, strQSValue;

                if (element.tagName.toUpperCase() === 'GS-DELETE-BUTTON' && !element.hasAttribute('src')) {
                    console.warn(element, 'gs-delete-button needs a [src=""] attribute!');
                }

                // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
                if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    // if this is the first time inserted has been run: continue
                    if (!element.inserted) {
                        element.inserted = true;
                        element.internal = {};
                        saveDefaultAttributes(element);

                        if (element.getAttribute('qs')) {
                            //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                            //if (strQSValue !== '' || !element.getAttribute('value')) {
                            //    element.setAttribute('value', strQSValue);
                            //}
                            pushReplacePopHandler(element);
                            window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                            window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                            window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                        }

                        // add a tabindex to allow focus (if allowed)
                        if (!element.hasAttribute('no-focus')) {
                            if ((!element.tabIndex) || element.tabIndex === -1) {
                                element.tabIndex = 0;
                            }
                        } else {
                            element.removeAttribute('tabindex');
                        }

                        if (!evt.touchDevice) {
                            element.addEventListener('focus', function (event) {
                                element.classList.add('focus');
                            });

                            element.addEventListener('blur', function (event) {
                                element.classList.remove('focus');
                            });


                            element.addEventListener(evt.mousedown, function (event) {
                                element.classList.add('down');
                            });

                            element.addEventListener(evt.mouseout, function (event) {
                                element.classList.remove('down');
                                element.classList.remove('hover');
                            });

                            element.addEventListener(evt.mouseover, function (event) {
                                element.classList.remove('down');
                                element.classList.add('hover');
                            });

                            element.addEventListener('keydown', function (event) {
                                if (!element.hasAttribute('disabled') && !element.classList.contains('down') &&
                                    (event.keyCode === 13 || event.keyCode === 32)) {

                                    element.classList.add('down');
                                }
                            });

                            element.addEventListener('keyup', function (event) {
                                // if we are not disabled and we pressed return (13) or space (32): trigger click
                                if (!element.hasAttribute('disabled') && element.classList.contains('down') &&
                                    (event.keyCode === 13 || event.keyCode === 32)) {
                                    GS.triggerEvent(element, 'click');
                                }
                            });
                        }

                        element.addEventListener('click', function (event) {
                            element.classList.remove('down');
                            clickFunction(element);
                        });

                        element.addEventListener('keypress', function (event) {
                            // if we pressed return (13) or space (32): prevent default and stop propagation (to prevent scrolling of the page)
                            if (event.keyCode === 13 || event.keyCode === 32) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        });

                        if (element.getAttribute('key')) {
                            strKey = element.getAttribute('key');

                            if (GS.keyCode(strKey)) {
                                if (strKey.match(/[arfcvxzntypq]/gim)) {
                                    console.warn('gs-skype-button Warning: by setting the hot key of this button to "' + strKey + '" you may be overriding browser functionality.', element);
                                }

                                window.addEventListener('keydown', function (event) {
                                    if (String(event.keyCode || event.which) === GS.keyCode(strKey) &&
                                        (
                                            (element.hasAttribute('no-modifier-key') && !event.metaKey && !event.ctrlKey) ||
                                            (!element.hasAttribute('no-modifier-key') && (event.metaKey || event.ctrlKey))
                                        )) {
                                        event.preventDefault();
                                        event.stopPropagation();

                                        element.focus();
                                        GS.triggerEvent(element, 'click');
                                    }
                                });

                            } else if (strKey.length > 1) {
                                console.error('gs-skype-button Error: \'key="' + strKey + '"\' is not a valid hot-key.', element);
                            }
                        }

                        handleDisable(element);
                    }
                }
            }

            xtag.register(strTagName, {
                lifecycle: {
                    created: function () {
                        elementCreated(this);
                    },

                    inserted: function () {
                        elementInserted(this);
                    },

                    attributeChanged: function (strAttrName, oldValue, newValue) {
                        // if "suspend-created" has been removed: run created and inserted code
                        if (strAttrName === 'suspend-created' && newValue === null) {
                            elementCreated(this);
                            elementInserted(this);

                        // if "suspend-inserted" has been removed: run inserted code
                        } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                            elementInserted(this);

                        } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                            if (strAttrName === 'no-focus') {
                                if (!this.hasAttribute('no-focus')) {
                                    if ((!this.tabIndex) || this.tabIndex === -1) {
                                        this.tabIndex = 0;
                                    }
                                } else {
                                    this.removeAttribute('tabindex');
                                }
                            } else if (strAttrName === 'disabled') {
                                this.classList.remove('down');
                            } else if (arrDisableWhenEmptyAttributes.indexOf(strAttrName) > -1) {
                                handleDisable(this);
                            }
                        }
                    }
                },
                accessors: {
                    value: {
                        get: function () {
                            return this.getAttribute('value');
                        },
                        set: function (newValue) {
                            this.setAttribute('value', newValue);
                        }
                    }
                }
            });
        });
    }



    defineButton('gs-email-button', '', ['value'], '', function (element) {
        var emailAddress = element.getAttribute('value'), linkIframe, mousedownHandler;

        if (emailAddress) {
            linkIframe = document.createElement('iframe');
            document.body.appendChild(linkIframe);

            linkIframe.setAttribute('src', 'mailto:' + emailAddress);

            mousedownHandler = function () {
                document.body.removeChild(linkIframe);
                window.removeEventListener('mousedown', mousedownHandler);
            };

            window.addEventListener('mousedown', mousedownHandler);
        }
    });

    defineButton('gs-facetime-button', '', ['value'], '', function (element) {
        var appleID = element.getAttribute('value');

        if (appleID) {
            window.open('facetime:' + appleID);
        }
    });

    defineButton('gs-map-button', '', ['value'], '', function (element) {
        var strLocation = encodeURIComponent(element.getAttribute('value'));

        if (strLocation) {
            if (element.hasAttribute('google') === true) {
                window.open('https://maps.google.com/maps?q=' + strLocation);
            } else if (element.hasAttribute('bing') === true) {
                window.open('http://www.bing.com/maps/default.aspx?q=' + strLocation);
            } else {
                window.open('https://maps.google.com/maps?q=' + strLocation);
            }
        }
    });

    defineButton('gs-phone-button', '', ['value'], '', function (element) {
        var phoneNumber = element.getAttribute('value');

        if (phoneNumber) {
            if (evt.deviceType === 'phone') {
                window.open('tel:' + phoneNumber);

            } else {
                GS.msgbox('Phone Number', '<center>' + phoneNumber + '</center>', ['Done']);
            }
        }
    });

    defineButton('gs-tracking-button', '', ['value'], function (selectedElement) {
        var strService = '';

               if (selectedElement.hasAttribute('usps'))  { strService = 'usps';
        } else if (selectedElement.hasAttribute('ups'))   { strService = 'ups';
        } else if (selectedElement.hasAttribute('fedex')) { strService = 'fedex';
        } else if (selectedElement.hasAttribute('royal')) { strService = 'royal';
        } else if (selectedElement.hasAttribute('amz'))   { strService = 'amz'; }

        addProp('Service', true, '<gs-select class="target" value="' + strService + '" mini>' +
                                            '   <option value="">None</option>' +
                                            '   <option value="usps">USPS</option>' +
                                            '   <option value="ups">UPS</option>' +
                                            '   <option value="fedex">FEDEX</option>' +
                                            '   <option value="royal">Royal Mail</option>' +
                                            '   <option value="amz">Amazon</option>' +
                                            '</gs-select>', function () {
            selectedElement.removeAttribute('usps');
            selectedElement.removeAttribute('ups');
            selectedElement.removeAttribute('fedex');
            selectedElement.removeAttribute('royal');
            selectedElement.removeAttribute('amazon');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

    }, function (element) {
        var strTrackingNumber = element.getAttribute('value');

        if (strTrackingNumber) {
            if (element.hasAttribute('usps') === true) {
                window.open(' https://tools.usps.com/go/TrackConfirmAction?tLabels=' + strTrackingNumber);

            } else if (element.hasAttribute('ups') === true) {
                window.open('http://www.ups.com/WebTracking/processInputRequest?tracknum=' + strTrackingNumber);

            } else if (element.hasAttribute('fedex') === true) {
                window.open('https://www.fedex.com/apps/fedextrack/index.html?tracknumbers=' + strTrackingNumber);

            } else if (element.hasAttribute('royal') === true) {
                window.open('https://www.royalmail.com/track-your-item?trackNumber=' + strTrackingNumber);

            } else if (element.hasAttribute('amz') === true) {
                window.open(decodeURIComponent(strTrackingNumber));

            } else {
                GS.msgbox('Please Choose...',
                          '<center>Please Choose UPS, USPS, Fedex, Royal Mail or Amazon</center>',
                          ['UPS', 'USPS', 'Fedex', 'Royal Mail', 'Amazon'],
                          function (strAnswer) {
                    if (strAnswer === 'UPS') {
                        window.open('http://www.ups.com/WebTracking/processInputRequest?tracknum=' + strTrackingNumber);
                    } else if (strAnswer === 'USPS') {
                         window.open('https://tools.usps.com/go/TrackConfirmAction?tLabels=' + strTrackingNumber);
                    } else if (strAnswer === 'Fedex') {
                         window.open('https://www.fedex.com/apps/fedextrack/index.html?tracknumbers=' + strTrackingNumber);
                    } else if (strAnswer === 'Royal Mail') {
                         window.open('https://www.royalmail.com/track-your-item?trackNumber' + strTrackingNumber);
                    } else if (strAnswer === 'Amazon') {
                         window.open(strTrackingNumber);
                    }
                });
            }
        }
    });

    defineButton('gs-skype-button', '', ['value'], '', function (element) {
        if (element.getAttribute('value')) {
            window.open('skype:' + element.getAttribute('value'));
        }
    });

    defineButton('gs-delete-button',
                 '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-delete-button.html',
                 ['value', 'src'],
                 function (selectedElement) {
        addProp('Source', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('src') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'src', this.value, false);
        });

        addProp('Delete Action', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('action-delete') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'action-delete', this.value);
        });

    }, function (element) {
        if (element.getAttribute('value')) {
            var arrSrcParts = element.getAttribute('src').split('.')
              , strSchema = arrSrcParts[0]
              , strObject = arrSrcParts[1]
              , strPkColumn, strLockColumn
              , deleteRecordData, strHashColumns, strRoles, strColumns, strRecord
              , strDeleteData, strHash, strPkValue, strLockValue;

            element.classList.remove('down');

            strPkColumn = element.getAttribute('column') || 'id';
            strLockColumn = strPkColumn;
            strHashColumns = strLockColumn;

            strPkValue = GS.encodeForTabDelimited(element.getAttribute('value') || '');
            strLockValue = element.getAttribute('value') || '';

            strRoles = 'pk\thash';
            strColumns = strPkColumn + '\thash';

            strHash = CryptoJS.MD5(strLockValue === 'NULL' ? '' : strLockValue).toString();

            strDeleteData = strPkValue + '\t' + strHash + '\n';
            strDeleteData = strRoles + '\n' + strColumns + '\n' + strDeleteData;

            // create delete transaction
            GS.addLoader(element, 'Creating Delete Transaction...');
            GS.requestDeleteFromSocket(
                GS.envSocket, strSchema, strObject, strHashColumns, strDeleteData
                , function (data, error, transactionID) {
                    if (error) {
                        GS.removeLoader(element);
                        GS.webSocketErrorDialog(data);
                    }
                }
                , function (data, error, transactionID, commitFunction, rollbackFunction) {
                    var arrElements, i, len, templateElement;
                    GS.removeLoader(element);

                    if (!error) {
                        if (data !== 'TRANSACTION COMPLETED') {

                        } else {
                            templateElement = document.createElement('template');
                            templateElement.innerHTML = ml(function () {/*
                                <gs-page>
                                    <gs-header><center><h3>Are you sure...</h3></center></gs-header>
                                    <gs-body padded>
                                        <center>Are you sure you want to delete?</center>
                                    </gs-body>
                                    <gs-footer>
                                        <gs-grid>
                                            <gs-block><gs-button dialogclose>No</gs-button></gs-block>
                                            <gs-block><gs-button id="datasheet-focus-me" dialogclose bg-primary tabindex="0">Yes</gs-button></gs-block>
                                        </gs-grid>
                                    </gs-footer>
                                </gs-page>
                            */});

                            GS.openDialog(templateElement, function () {
                                document.getElementById('datasheet-focus-me').focus();

                            }, function (event, strAnswer) {
                                if (strAnswer === 'Yes') {
                                    commitFunction();
                                    GS.addLoader(element, 'Commiting Delete Transaction...');
                                } else {
                                    rollbackFunction();
                                    GS.addLoader(element, 'Rolling Back Delete Transaction...');
                                }
                            });
                        }

                    } else {
                        rollbackFunction();
                        GS.webSocketErrorDialog(data);
                    }
                }
                , function (strAnswer, data, error) {
                    var arrElements, i, len;
                    GS.removeLoader(element);

                    if (!error) {
                        if (strAnswer === 'COMMIT') {
                            GS.triggerEvent(element, 'success');
                            if (element.hasAttribute('onsuccess')) {
                                new Function(element.getAttribute('onsuccess')).apply(element);
                            }
                        }

                    } else {
                        getData(element);
                        GS.webSocketErrorDialog(data);
                    }
                }
            );
        }
    });

    defineButton('gs-option',
                 '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-optionbox.html',
                 [],
                 function (selectedElement) {},
                 function (element) {});

    defineButton('gs-dialog-button',
        '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-dialog-button.html',
        [],
        function (selectedElement) { // design code
            addProp('Template', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('template') || '') + '" mini></gs-text>', function () {
                return setOrRemoveTextAttribute(selectedElement, 'template', this.value, false);
            });

            addProp('Attach To Element', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('target-element') || '') + '" mini></gs-text>', function () {
                return setOrRemoveTextAttribute(selectedElement, 'target-element', this.value, false);
            });

            addProp('Attachment Direction', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('direction') || '') + '" mini>' +
                                                        '<option value="">Default</option>' +
                                                        '<option value="left">Left</option>' +
                                                        '<option value="right">Right</option>' +
                                                        '<option value="up">Up</option>' +
                                                        '<option value="down">Down</option>' +
                                                  '</gs-select>', function () {
                return setOrRemoveTextAttribute(selectedElement, 'direction', this.value, false);
            });

            addProp('Before Open JS', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('before-open') || '') + '" mini></gs-text>', function () {
                return setOrRemoveTextAttribute(selectedElement, 'before-open', this.value, false);
            });

            addProp('After Open JS', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('after-open') || '') + '" mini></gs-text>', function () {
                return setOrRemoveTextAttribute(selectedElement, 'after-open', this.value, false);
            });

            addProp('Before Close JS', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('before-close') || '') + '" mini></gs-text>', function () {
                return setOrRemoveTextAttribute(selectedElement, 'before-close', this.value, false);
            });

            addProp('After Close JS', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('after-close') || '') + '" mini></gs-text>', function () {
                return setOrRemoveTextAttribute(selectedElement, 'after-close', this.value, false);
            });
        },
        function (element) {// on click
            var targetElement
              , strTemplate = element.getAttribute('template')
              , templateElement
              , strTargetSelector = element.getAttribute('target')
              , strDirection = element.getAttribute('direction')
              , strBeforeOpen = element.getAttribute('before-open')
              , strAfterOpen = element.getAttribute('after-open')
              , strBeforeClose = element.getAttribute('before-close')
              , strAfterClose = element.getAttribute('after-close')
              , afterOpenFunction
              , beforeCloseFunction
              , afterCloseFunction;

            templateElement = (strTemplate ? document.getElementById(strTemplate) : xtag.queryChildren(element, 'template')[0]);
            //console.log(templateElement);

            if (templateElement) {
                if (strBeforeOpen) {
                    new Function(strBeforeOpen).apply(element);
                }
                GS.triggerEvent(element, 'before-open');

                afterOpenFunction = function () {
                    if (strAfterOpen) {
                        new Function(strAfterOpen).apply(this);
                    }
                    GS.triggerEvent(element, 'after-open');
                };

                beforeCloseFunction = function (event, strAnswer) {
                    // if there is a before close function: run the code
                    if (strBeforeClose) {
                        // append a definition for the "strAnswer" variable before the code (the replace calls are to make the string safe)
                        new Function('var strAnswer = \'' + strAnswer.replace(/'/g, 'donTGueSsThiSUniTokEN1975') + '\'' +
                                                    '.replace(/donTGueSsThiSUniTokEN1975/g, \'\\\'\');\n' + strBeforeClose).apply(this);
                    }
                    GS.triggerEvent(element, 'before-close', {'strAnswer': strAnswer});
                };

                afterCloseFunction = function (event, strAnswer) {
                    // if there is a after close function: run the code
                    if (strAfterClose) {
                        // append a definition for the "strAnswer" variable before the code (the replace calls are to make the string safe)
                        new Function('var strAnswer = \'' + strAnswer.replace(/'/g, 'donTGueSsThiSUniTokEN1975') + '\'' +
                                                    '.replace(/donTGueSsThiSUniTokEN1975/g, \'\\\'\');\n' + strAfterClose).apply(element);
                    }
                    GS.triggerEvent(element, 'after-close', {'strAnswer': strAnswer});
                };

                if (strTargetSelector || element.hasAttribute('target')) {
                    strTargetSelector = (strTargetSelector || 'this');
                    targetElement = (strTargetSelector === 'this' ? element : document.querySelector(strTargetSelector));
                    strDirection = (strDirection || 'down');

                    GS.openDialogToElement(targetElement, templateElement, strDirection,
                                            afterOpenFunction, beforeCloseFunction, afterCloseFunction);

                } else {
                    GS.openDialog(templateElement, afterOpenFunction, beforeCloseFunction, afterCloseFunction);
                }
            }
        });
})();














window.addEventListener('design-register-element', function () {

    registerDesignSnippet('<gs-button>', '<gs-button>', 'gs-button>${1}</gs-button>');

    designRegisterElement('gs-button', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-buttons-toggle.html');

    window.designElementProperty_GSBUTTON = function(selectedElement) {
        var strIconPos, strIconRotation;

        addProp('Icon', true, '<div flex-horizontal>' +
                              '     <gs-text id="prop-icon-input" class="target" value="' + (selectedElement.getAttribute('icon') || '') + '" mini flex></gs-text>' +
                              '     <gs-button id="prop-icon-picker-button" mini icononly icon="list"></gs-button>' +
                              '     <style>#prop-icon-picker-button:after {font-size: 1em;}</style>' +
                              '</div>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'icon', this.value);
        });

        document.getElementById('prop-icon-picker-button').addEventListener('click', function () {
            var i, len, html, arrIcons = GS.iconList(), strName, templateElement;

            for (i = 0, len = arrIcons.length, html = ''; i < len; i += 1) {
                strName = arrIcons[i].name;
                html += '<gs-block>' +
                            '<gs-button iconleft icon="' + strName + '" dialogclose>' + strName + '</gs-button>' +
                        '</gs-block>';
            }

            templateElement = document.createElement('template');
            templateElement.setAttribute('data-max-width', '1100px');

            templateElement.innerHTML = ml(function () {/*
                <gs-page>
                    <gs-header><center><h3>Choose An Icon</h3></center></gs-header>
                    <gs-body padded>
                        <gs-grid widths="1,1,1,1" reflow-at="767px">{{HTML}}</gs-grid>
                    </gs-body>
                    <gs-footer><gs-button dialogclose>Cancel</gs-button></gs-footer>
                </gs-page>
            */}).replace('{{HTML}}', html);

            GS.openDialog(templateElement, '', function (event, strAnswer) {
                var propInput = document.getElementById('prop-icon-input');

                if (strAnswer !== 'Cancel') {
                    propInput.value = strAnswer;
                    GS.triggerEvent(propInput, 'change');
                }
            });
        });

        // iconleft
        // iconright
        // icontop
        // iconbottom
        // icononly
               if (selectedElement.hasAttribute('iconleft'))   { strIconPos = 'iconleft';
        } else if (selectedElement.hasAttribute('iconright'))  { strIconPos = 'iconright';
        } else if (selectedElement.hasAttribute('icontop'))    { strIconPos = 'icontop';
        } else if (selectedElement.hasAttribute('iconbottom')) { strIconPos = 'iconbottom';
        } else if (selectedElement.hasAttribute('icononly'))   { strIconPos = 'icononly';
        } else { strIconPos = ''; }

        addProp('Icon Position', true, '<gs-select class="target" value="' + strIconPos + '" mini>' +
                                        '   <option value="">Default</option>' +
                                        '   <option value="iconleft">Left</option>' +
                                        '   <option value="iconright">Right</option>' +
                                        '   <option value="icontop">Top</option>' +
                                        '   <option value="iconbottom">Bottom</option>' +
                                        '   <option value="icononly">Icononly</option>' +
                                        '</gs-select>', function () {
            selectedElement.removeAttribute('iconleft');
            selectedElement.removeAttribute('iconright');
            selectedElement.removeAttribute('icontop');
            selectedElement.removeAttribute('iconbottom');
            selectedElement.removeAttribute('icononly');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // None
        // 90 degrees  (iconrotateright)
        // 180 degrees (iconrotatedown)
        // 270 degrees (iconrotateleft)
               if (selectedElement.hasAttribute('iconrotateright')) { strIconRotation = 'iconrotateright';
        } else if (selectedElement.hasAttribute('iconrotatedown'))  { strIconRotation = 'iconrotatedown';
        } else if (selectedElement.hasAttribute('iconrotateleft'))  { strIconRotation = 'iconrotateleft';
        } else { strIconRotation = ''; }

        addProp('Icon&nbsp;Rotation', true, '<gs-select class="target" value="' + strIconRotation + '" mini>' +
                                            '   <option value="">None</option>' +
                                            '   <option value="iconrotateright">90 degrees</option>' +
                                            '   <option value="iconrotatedown">180 degrees</option>' +
                                            '   <option value="iconrotateleft">270 degrees</option>' +
                                            '</gs-select>', function () {
            selectedElement.removeAttribute('iconrotateright');
            selectedElement.removeAttribute('iconrotatedown');
            selectedElement.removeAttribute('iconrotateleft');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        addProp('Href', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('href') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'href', this.value, false);
        });
        if (selectedElement.getAttribute('href')) {
            addProp('Target', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('target') || '') + '" mini>' +
                                        '<option value="">New Window</option>' +
                                        '<option value="_self">Current Window</option>' +
                                    '</gs-select>', function () {
                return setOrRemoveTextAttribute(selectedElement, 'target', this.value, false);
            });
        }

        addProp('Jumbo', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('jumbo')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'jumbo', (this.value === 'true'), true);
        });

        addProp('Focusable', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-focus')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-focus', (this.value === 'true'), false);
        });

        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '0') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });

        addProp('Inline', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('inline')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'inline', (this.value === 'true'), true);
        });
        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });
        /*
        addProp('Emphasis', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('emphasis')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'emphasis', (this.value === 'true'), true);
        });
        */

        //<gs-button txt-info bg-success>

        // Font Color attributes
        var strFontAttribute = '';
        if (selectedElement.hasAttribute('txt-primary'))  { strFontAttribute = 'txt-primary'; }
        if (selectedElement.hasAttribute('txt-success'))  { strFontAttribute = 'txt-success'; }
        if (selectedElement.hasAttribute('txt-info'))     { strFontAttribute = 'txt-info'; }
        if (selectedElement.hasAttribute('txt-warning'))  { strFontAttribute = 'txt-warning'; }
        if (selectedElement.hasAttribute('txt-danger'))   { strFontAttribute = 'txt-danger'; }

        addProp('Font Color', true, '<gs-select class="target" value="' + strFontAttribute + '" mini>' +
                                        '<option value="">Default</option>' +
                                        '<option value="txt-primary">Primary</option>' +
                                        '<option value="txt-success">Success</option>' +
                                        '<option value="txt-info">Info</option>' +
                                        '<option value="txt-warning">Warning</option>' +
                                        '<option value="txt-danger">Danger</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('txt-primary');
            selectedElement.removeAttribute('txt-success');
            selectedElement.removeAttribute('txt-info');
            selectedElement.removeAttribute('txt-warning');
            selectedElement.removeAttribute('txt-danger');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // Background Color attributes
        var strBackgroundAttribute = '';
        if (selectedElement.hasAttribute('bg-primary'))  { strBackgroundAttribute = 'bg-primary'; }
        if (selectedElement.hasAttribute('bg-success'))  { strBackgroundAttribute = 'bg-success'; }
        if (selectedElement.hasAttribute('bg-info'))     { strBackgroundAttribute = 'bg-info'; }
        if (selectedElement.hasAttribute('bg-warning'))  { strBackgroundAttribute = 'bg-warning'; }
        if (selectedElement.hasAttribute('bg-danger'))   { strBackgroundAttribute = 'bg-danger'; }

        addProp('Background Color', true, '<gs-select class="target" value="' + strBackgroundAttribute + '" mini>' +
                                        '<option value="">Default</option>' +
                                        '<option value="bg-primary">Primary</option>' +
                                        '<option value="bg-success">Success</option>' +
                                        '<option value="bg-info">Info</option>' +
                                        '<option value="bg-warning">Warning</option>' +
                                        '<option value="bg-danger">Danger</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('bg-primary');
            selectedElement.removeAttribute('bg-success');
            selectedElement.removeAttribute('bg-info');
            selectedElement.removeAttribute('bg-warning');
            selectedElement.removeAttribute('bg-danger');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        addProp('Key', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('key') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'key', this.value, false);
        });

        addProp('No Modifier Key For Hot Key', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-modifier-key') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-modifier-key', this.value === 'true', true);
        });

        // TEXT CONTENT
        addProp('Text', true, '<gs-text class="target" value="' + (selectedElement.textContent || '') + '" mini></gs-text>', function () {
            selectedElement.textContent = this.value;

            return selectedElement;
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        // DIALOGCLOSE attribute
        addProp('Dialog Close', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('dialogclose') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'dialogclose', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))          { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop')) { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))  { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))   { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop')) { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))  { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))   { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // addProp('Corners', true,   '<div class="target">' +
        //                                 '<gs-grid>\n' +
        //                                 '    <gs-block>\n' +
        //                                 '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
        //                                                             selectedElement.hasAttribute('remove-top') ||
        //                                                             selectedElement.hasAttribute('remove-left') ||
        //                                                             selectedElement.hasAttribute('remove-top-left'))).toString() +
        //                                             '" remove-right remove-bottom id="round-top-left-corner________"></gs-checkbox>' +

        //                                 '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
        //                                                             selectedElement.hasAttribute('remove-bottom') ||
        //                                                             selectedElement.hasAttribute('remove-left') ||
        //                                                             selectedElement.hasAttribute('remove-bottom-left'))).toString() +
        //                                             '" remove-right remove-top id="round-bottom-left-corner________"></gs-checkbox>' +
        //                                 '    </gs-block>\n' +
        //                                 '    <gs-block>\n' +
        //                                 '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
        //                                                             selectedElement.hasAttribute('remove-top') ||
        //                                                             selectedElement.hasAttribute('remove-right') ||
        //                                                             selectedElement.hasAttribute('remove-top-right'))).toString() +
        //                                             '" remove-left remove-bottom id="round-top-right-corner________"></gs-checkbox>' +

        //                                 '        <gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
        //                                                             selectedElement.hasAttribute('remove-bottom') ||
        //                                                             selectedElement.hasAttribute('remove-right') ||
        //                                                             selectedElement.hasAttribute('remove-bottom-right'))).toString() +
        //                                             '" remove-left remove-top id="round-bottom-right-corner________"></gs-checkbox>' +
        //                                 '    </gs-block>\n' +
        //                                 '</gs-grid>\n' +
        //                             '</div>', function () {
        //     var topLeft     = document.getElementById('round-top-left-corner________').value === 'true',
        //         topRight    = document.getElementById('round-top-right-corner________').value === 'true',
        //         bottomLeft  = document.getElementById('round-bottom-left-corner________').value === 'true',
        //         bottomRight = document.getElementById('round-bottom-right-corner________').value === 'true',
        //         arrStrAttr = [], i, len;

        //     selectedElement.removeAttribute('remove-all');
        //     selectedElement.removeAttribute('remove-top');
        //     selectedElement.removeAttribute('remove-bottom');
        //     selectedElement.removeAttribute('remove-left');
        //     selectedElement.removeAttribute('remove-right');
        //     selectedElement.removeAttribute('remove-top-left');
        //     selectedElement.removeAttribute('remove-top-right');
        //     selectedElement.removeAttribute('remove-bottom-left');
        //     selectedElement.removeAttribute('remove-bottom-right');

        //     if (!topLeft && !topRight && !bottomLeft && !bottomRight) {
        //         arrStrAttr.push('remove-all');
        //     } else if (!topLeft && !topRight) {
        //         arrStrAttr.push('remove-top');
        //     } else if (!bottomLeft && !bottomRight) {
        //         arrStrAttr.push('remove-bottom');
        //     } else if (!topLeft && !bottomLeft) {
        //         arrStrAttr.push('remove-left');
        //     } else if (!topRight && !bottomRight) {
        //         arrStrAttr.push('remove-right');
        //     }

        //     if (!topLeft && !bottomLeft && arrStrAttr[0] !== 'remove-all') {
        //         arrStrAttr.push('remove-left');
        //     } else if (!topLeft && topRight) {
        //         arrStrAttr.push('remove-top-left');
        //     } else if (!bottomLeft && bottomRight) {
        //         arrStrAttr.push('remove-bottom-left');
        //     }

        //     if (!topRight && !bottomRight && arrStrAttr[0] !== 'remove-all') {
        //         arrStrAttr.push('remove-right');
        //     } else if (topLeft && !topRight) {
        //         arrStrAttr.push('remove-top-right');
        //     } else if (bottomLeft && !bottomRight) {
        //         arrStrAttr.push('remove-bottom-right');
        //     }

        //     for (i = 0, len = arrStrAttr.length; i < len; i += 1) {
        //         selectedElement.setAttribute(arrStrAttr[i], '');
        //     }

        //     return selectedElement;
        // });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});





document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    function refreshAnchor(element) {
        var strLink = element.getAttribute('href') || element.getAttribute('value');

        if (element.anchorElement) {
            element.removeChild(element.anchorElement);
        }
        if (strLink) {
            element.anchorElement = document.createElement('a');
            element.anchorElement.setAttribute('gs-dynamic', '');
            element.anchorElement.setAttribute('target', element.getAttribute('target') || '_blank');
            element.anchorElement.setAttribute('href', strLink);

            if (element.getAttribute('onclick')) {
                element.anchorElement.setAttribute('onclick', element.getAttribute('onclick'));
            }

            if (element.hasAttribute('download')) {
                element.anchorElement.setAttribute('download', element.getAttribute('download'));
            }

            element.appendChild(element.anchorElement);

        }
    }

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.setAttribute('value', strQSValue);
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    //
    function elementInserted(element) {
        var strKey;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (element.getAttribute('qs')) {
                    //var strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.setAttribute('value', strQSValue);
                    //}
                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                }

                // add a tabindex to allow focus (if allowed)
                if (!element.hasAttribute('no-focus')) {
                    if ((!element.tabIndex) || element.tabIndex === -1) {
                        element.tabIndex = 0;
                    }
                } else {
                    element.removeAttribute('tabindex');
                }

                element.classList.remove('down');
                element.classList.remove('hover');

                if (!evt.touchDevice) {
                    element.addEventListener('focus', function (event) {
                        element.classList.add('focus');
                    });

                    element.addEventListener('blur', function (event) {
                        element.classList.remove('focus');
                    });

                    element.addEventListener(evt.mousedown, function (event) {
                        element.classList.add('down');
                    });

                    element.addEventListener(evt.mouseout, function (event) {
                        element.classList.remove('down');
                        element.classList.remove('hover');
                    });

                    element.addEventListener(evt.mouseover, function (event) {
                        element.classList.remove('down');
                        element.classList.add('hover');
                    });

                    element.addEventListener('keydown', function (event) {
                        if (!element.hasAttribute('disabled') &&
                            (event.keyCode === 13 || event.keyCode === 32)) {
                            element.classList.add('down');
                        }
                    });

                    element.addEventListener('keyup', function (event) {
                        // if we are not disabled and we pressed return (13) or space (32): trigger click
                        if (!element.hasAttribute('disabled') && element.classList.contains('down') &&
                            (event.keyCode === 13 || event.keyCode === 32)) {
                            GS.triggerEvent(element, 'click');
                        }
                    });
                }

                refreshAnchor(element);

                element.addEventListener('click', function (event) {
                    element.classList.remove('down');
                });

                element.addEventListener('keypress', function (event) {
                    // if we pressed return (13) or space (32): prevent default and stop propagation (to prevent scrolling of the page)
                    if (event.keyCode === 13 || event.keyCode === 32) {
                        event.preventDefault();
                        event.stopPropagation();
                    }
                });

                strKey = element.getAttribute('key');

                if (strKey) {
                    if (GS.keyCode(strKey)) {
                        if (strKey.match(/[arfcvxzntypq]/gim)) {
                            console.warn('gs-button Warning: by setting the hot key of this button to "' + strKey + '" you may be overriding browser functionality.', element);
                        }

                        window.addEventListener('keydown', function (event) {
                            if (
                                    String(event.keyCode || event.which) === GS.keyCode(strKey) &&
                                    (
                                        (
                                            element.hasAttribute('no-modifier-key') &&
                                            !event.metaKey &&
                                            !event.ctrlKey
                                        ) ||
                                        (
                                            !element.hasAttribute('no-modifier-key') &&
                                            (event.metaKey || event.ctrlKey)
                                        )
                                    )
                                ) {
                                event.preventDefault();
                                event.stopPropagation();

                                element.focus();
                                GS.triggerEvent(element, 'click');
                            }
                        });

                    } else if (strKey.length > 1) {
                        console.error('gs-button Error: \'key="' + strKey + '"\' is not a valid hot-key.', element);
                    }
                }
            }
        }
    }

    xtag.register('gs-button', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'no-focus') {
                        if (!this.hasAttribute('no-focus') && !this.hasAttribute('tabindex')) {
                            this.setAttribute('tabindex', 0);
                        } else if (this.hasAttribute('no-focus')) {
                            this.removeAttribute('tabindex');
                        }
                    } else if (strAttrName === 'disabled') {
                        this.classList.remove('down');

                    } else if (strAttrName === 'href' || strAttrName === 'target' || strAttrName === 'onclick' || strAttrName === 'download') {
                        refreshAnchor(this);
                    }
                }
            }
        },
        events: {},
        accessors: {},
        methods: {}
    });
});//global addProp, encodeHTML, window, GS, setOrRemoveBooleanAttribute, setOrRemoveTextAttribute, addFlexProps, registerDesignSnippet, designRegisterElement

window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet(
        '<gs-checkbox>',
        '<gs-checkbox>',
        'gs-checkbox type="smallint" column="${1:ready_to_ship}">${2}</gs-checkbox>'
    );
    registerDesignSnippet(
        '<gs-checkbox> With Label',
        '<gs-checkbox>',
        'label for="${1:date-insert-ready_to_ship}">${2:Ready To Ship?}:</label>\n' +
                '<gs-checkbox id="${1:date-insert-ready_to_ship}" type="smallint" column="${3:ready_to_ship}"></gs-checkbox>'
    );

    designRegisterElement(
        'gs-checkbox',
        '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-checkbox.html'
    );

    window.designElementProperty_GSCHECKBOX = function (selectedElement) {
        var strVisibilityAttribute;

        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Triple State', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('triplestate')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'triplestate', (this.value === 'true'), true);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        addProp('Inline', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('inline')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'inline', (this.value === 'true'), true);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });

        addProp('Type', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('type') || '') + '" mini>' +
                                        '<option value="">Detect</option>' +
                                        '<option value="smallint">Smallint</option>' +
                                        '<option value="boolean">Boolean</option>' +
                                    '</gs-select>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'type', this.value);
        });

        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp(
            'Visibility',
            true,
            '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                    '    <option value="">Visible</option>' +
                    '    <option value="hidden">Invisible</option>' +
                    '    <option value="hide-on-desktop">Invisible at desktop size</option>' +
                    '    <option value="hide-on-tablet">Invisible at tablet size</option>' +
                    '    <option value="hide-on-phone">Invisible at phone size</option>' +
                    '    <option value="show-on-desktop">Visible at desktop size</option>' +
                    '    <option value="show-on-tablet">Visible at tablet size</option>' +
                    '    <option value="show-on-phone">Visible at phone size</option>' +
                    '</gs-select>',
            function () {
                selectedElement.removeAttribute('hidden');
                selectedElement.removeAttribute('hide-on-desktop');
                selectedElement.removeAttribute('hide-on-tablet');
                selectedElement.removeAttribute('hide-on-phone');
                selectedElement.removeAttribute('show-on-desktop');
                selectedElement.removeAttribute('show-on-tablet');
                selectedElement.removeAttribute('show-on-phone');

                if (this.value) {
                    selectedElement.setAttribute(this.value, '');
                }

                return selectedElement;
            }
        );

        // DISABLED attribute
        addProp(
            'Disabled',
            true,
            '<gs-checkbox class="target" value="' + (
                selectedElement.hasAttribute('disabled') || ''
            ) +
                    '" mini></gs-checkbox>',
            function () {
                return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
            }
        );

        // READONLY attribute
        addProp(
            'Readonly',
            true,
            '<gs-checkbox class="target" value="' + (
                selectedElement.hasAttribute('readonly') || ''
            ) +
                    '" mini></gs-checkbox>',
            function () {
                return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
            }
        );

        // addProp('Corners', true, '<div class="target">' +
        //             '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
        //                                         selectedElement.hasAttribute('remove-top') ||
        //                                         selectedElement.hasAttribute('remove-left') ||
        //                                         selectedElement.hasAttribute('remove-top-left'))).toString() +
        //                     '" remove-right remove-bottom id="round-top-left-corner________" inline></gs-checkbox>' +

        //             '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
        //                                         selectedElement.hasAttribute('remove-top') ||
        //                                         selectedElement.hasAttribute('remove-right') ||
        //                                         selectedElement.hasAttribute('remove-top-right'))).toString() +
        //                     '" remove-left remove-bottom id="round-top-right-corner________" inline></gs-checkbox><br />' +

        //             '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
        //                                         selectedElement.hasAttribute('remove-bottom') ||
        //                                         selectedElement.hasAttribute('remove-left') ||
        //                                         selectedElement.hasAttribute('remove-bottom-left'))).toString() +
        //                     '" remove-right remove-top id="round-bottom-left-corner________" inline></gs-checkbox>' +

        //             '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
        //                                         selectedElement.hasAttribute('remove-bottom') ||
        //                                         selectedElement.hasAttribute('remove-right') ||
        //                                         selectedElement.hasAttribute('remove-bottom-right'))).toString() +
        //                     '" remove-left remove-top id="round-bottom-right-corner________" inline></gs-checkbox>' +
        //         '</div>', function () {
        //     var topLeft = document.getElementById('round-top-left-corner________').value === 'true';
        //     var topRight = document.getElementById('round-top-right-corner________').value === 'true';
        //     var bottomLeft = document.getElementById('round-bottom-left-corner________').value === 'true';
        //     var bottomRight = document.getElementById('round-bottom-right-corner________').value === 'true';
        //     var arrStrAttr = [];
        //     var i;
        //     var len;

        //     selectedElement.removeAttribute('remove-all');
        //     selectedElement.removeAttribute('remove-top');
        //     selectedElement.removeAttribute('remove-bottom');
        //     selectedElement.removeAttribute('remove-left');
        //     selectedElement.removeAttribute('remove-right');
        //     selectedElement.removeAttribute('remove-top-left');
        //     selectedElement.removeAttribute('remove-top-right');
        //     selectedElement.removeAttribute('remove-bottom-left');
        //     selectedElement.removeAttribute('remove-bottom-right');

        //     if (!topLeft && !topRight && !bottomLeft && !bottomRight) {
        //         arrStrAttr.push('remove-all');
        //     } else if (!topLeft && !topRight) {
        //         arrStrAttr.push('remove-top');
        //     } else if (!bottomLeft && !bottomRight) {
        //         arrStrAttr.push('remove-bottom');
        //     } else if (!topLeft && !bottomLeft) {
        //         arrStrAttr.push('remove-left');
        //     } else if (!topRight && !bottomRight) {
        //         arrStrAttr.push('remove-right');
        //     }

        //     if (!topLeft && !bottomLeft && arrStrAttr[0] !== 'remove-all') {
        //         arrStrAttr.push('remove-left');
        //     } else if (!topLeft && topRight) {
        //         arrStrAttr.push('remove-top-left');
        //     } else if (!bottomLeft && bottomRight) {
        //         arrStrAttr.push('remove-bottom-left');
        //     }

        //     if (!topRight && !bottomRight && arrStrAttr[0] !== 'remove-all') {
        //         arrStrAttr.push('remove-right');
        //     } else if (topLeft && !topRight) {
        //         arrStrAttr.push('remove-top-right');
        //     } else if (bottomLeft && !bottomRight) {
        //         arrStrAttr.push('remove-bottom-right');
        //     }

        //     i = 0;
        //     len = arrStrAttr.length;
        //     while (i < len) {
        //         selectedElement.setAttribute(arrStrAttr[i], '');
        //         i += 1;
        //     }

        //     return selectedElement;
        // });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);

        //// SUSPEND-CREATED attribute
        //addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
        //    return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        //});

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }

        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                element.internal.bolQSFirstRun = true;
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};

                // save default attribute settings so that the qs code can access those values
                saveDefaultAttributes(element);

                // if this checkbox has the "qs" attribute: fill from querystring and bind to querystring
                if (element.hasAttribute('qs')) {
                    pushReplacePopHandler(element);

                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                }

                element.addEventListener('focus', function (event) {
                    element.classList.add('focus');
                });

                element.addEventListener('blur', function (event) {
                    element.classList.remove('focus');
                });

                element.addEventListener(evt.mouseout, function (event) {
                    element.classList.remove('hover');
                });

                element.addEventListener(evt.mouseover, function (event) {
                    element.classList.add('hover');
                });

                // default value to false
                if (element.getAttribute('type') === 'smallint') {
                    element.value = element.getAttribute('value') || 0;
                } else {
                    element.value = element.getAttribute('value') || false;
                }

                // add a tabindex to allow focus
                if (!element.hasAttribute('tabindex')) {
                    element.tabIndex = 0;
                }
            }
        }
    }

    xtag.register('gs-checkbox', {
        lifecycle: {
            created: function () {
                var element = this;
                // if the value was set before the "created" lifecycle code runs: set attribute
                //      (discovered when trying to set a value of a date control in the after_open of a dialog)
                //      ("delete" keyword added because of firefox)
                if (
                    !element.getAttribute('value') &&
                    element.value !== null &&
                    element.value !== undefined &&
                    (
                        typeof element.value === 'boolean' ||
                        element.value === '-1' ||
                        element.value === '0' ||
                        element.value === 'true' ||
                        element.value === 'false' ||
                        element.value === 'null' ||
                        element.value === 'n'
                    )
                ) {
                    element.setAttribute('value', element.value);
                    delete element.value;
                }

                elementCreated(element);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // attribute code
                }
            }
        },
        events: {
            'mousedown': function () {
                if (!this.hasAttribute('suspend-created') &&
                    !this.hasAttribute('suspend-inserted') &&
                    !this.hasAttribute('readonly')) {
                    this.classList.add('down');
                }
            },
            'mouseout': function () {
                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (this.classList.contains('down')) {
                        this.classList.remove('down');
                    }
                }
            },
            'click': function (event) {
                var bolTripleState;
                var strValue;
                var strType;

                if (!this.hasAttribute('suspend-created') &&
                    !this.hasAttribute('suspend-inserted') &&
                    !this.hasAttribute('readonly')) {
                    bolTripleState = this.hasAttribute('triplestate');
                    strValue = this.getAttribute('value').trim().toLowerCase();

                    // get type from type attribute
                    strType = this.getAttribute('type');

                    // if type is not valid, get type from current value
                    if (strType !== 'smallint' && strType !== 'boolean') {
                        if (strValue === 'false' || strValue === 'true' || strValue === 'null') {
                            strType = 'boolean';
                        } else if (strValue === '0' || strValue === '-1' || strValue === 'n') {
                            strType = 'smallint';
                    // else default to boolean (backwards compatibility)
                        } else {
                            strType = 'boolean';
                        }
                    }

                    // resolve current value to the correct type
                    if (strType === 'smallint') {
                        if (strValue === '0' || strValue === 'false') {
                            strValue = '0';
                        } else if (strValue === '-1' || strValue === 'true') {
                            strValue = '-1';
                        } else if (strValue === 'n' || strValue === 'null') {
                            strValue = 'n';
                        } else {
                            strValue = '0';
                        }
                    } else if (strType === 'boolean') {
                        if (strValue === '0' || strValue === 'false') {
                            strValue = 'false';
                        } else if (strValue === '-1' || strValue === 'true') {
                            strValue = 'true';
                        } else if (strValue === 'n' || strValue === 'null') {
                            strValue = 'null';
                        } else {
                            strValue = 'false';
                        }
                    }

                    // get new value based on current value
                    if (strType === 'smallint') {
                        if (strValue === '0') {
                            strValue = '-1';
                        } else if (strValue === '-1') {
                            if (bolTripleState) {
                                strValue = 'n';
                            } else {
                                strValue = '0';
                            }
                        } else if (strValue === 'n') {
                            strValue = '0';
                        }
                    } else if (strType === 'boolean') {
                        if (strValue === 'false') {
                            strValue = 'true';
                        } else if (strValue === 'true') {
                            if (bolTripleState) {
                                strValue = 'null';
                            } else {
                                strValue = 'false';
                            }
                        } else if (strValue === 'null') {
                            strValue = 'false';
                        }
                    }

                    // set new value
                    this.setAttribute('value', strValue);

                    //// here be dragons
                    //if (strValue === 'false') {
                    //    this.setAttribute('value', 'true');
                    //} else if (strValue === 'true') {
                    //    if (bolTripleState) {
                    //        this.setAttribute('value', 'null');
                    //    } else {
                    //        this.setAttribute('value', 'false');
                    //    }
                    //} else if (strValue === 'null') {
                    //    this.setAttribute('value', 'false');
                    //} else if (strValue === '0') {
                    //    this.setAttribute('value', '-1');
                    //} else if (strValue === '-1') {
                    //    if (bolTripleState) {
                    //        this.setAttribute('value', 'n');
                    //    } else {
                    //        this.setAttribute('value', '0');
                    //    }
                    //} else if (strValue === 'n') {
                    //    this.setAttribute('value', '0');
                    //} else if (strValue === 0) {
                    //    this.setAttribute('value', -1);
                    //} else if (strValue === -1) {
                    //    if (bolTripleState) {
                    //        this.setAttribute('value', 'n');
                    //    } else {
                    //        this.setAttribute('value', 0);
                    //    }
                    //} else if (strValue === 'n') {
                    //    this.setAttribute('value', 0);
                    //} else if (strValue === false) {
                    //    this.setAttribute('value', true);
                    //} else if (strValue === true) {
                    //    if (bolTripleState) {
                    //        this.setAttribute('value', null);
                    //    } else {
                    //        this.setAttribute('value', false);
                    //    }
                    //} else if (strValue === null) {
                    //    //this.setAttribute('value', false);
                    //    if (this.getAttribute('type') === 'smallint') {
                    //        this.setAttribute('value', '-1');
                    //    } else {
                    //        this.setAttribute('value', 'true');
                    //    }
                    //} else {
                    //    if (this.getAttribute('type') === 'smallint') {
                    //        this.setAttribute('value', '-1');
                    //    } else {
                    //        this.setAttribute('value', 'true');
                    //    }
                    //}

                    this.classList.remove('down');
                    xtag.fireEvent(this, 'change', {bubbles: true, cancelable: true});
                }
            },
            'keydown': function (event) {
                if (!this.hasAttribute('suspend-created') &&
                    !this.hasAttribute('suspend-inserted') &&
                    !this.hasAttribute('readonly')) {
                    // if we pressed return (13) or space (32)
                    if (event.keyCode === 13 || event.keyCode === 32) {
                        // prevent default and stop propagation (to prevent scrolling of the page)
                        event.preventDefault();
                        event.stopPropagation();
                    }

                    // if we are not disabled and we pressed return (13) or space (32): trigger click
                    if (!this.attributes.disabled && (event.keyCode === 13 || event.keyCode === 32)) {
                        xtag.fireEvent(this, 'click', { bubbles: true, cancelable: true });
                    }
                }
            }
        },
        accessors: {
            value: {
                // get value straight from the attribute
                get: function () {
                    return this.getAttribute('value');
                },

                // set the value attribute
                set: function (newValue) {
                    this.setAttribute('value', newValue);
                }
            },
            textValue: {
                // return a text representation of the value
                get: function () {
                    var currentValue = this.getAttribute('value');

                    // if value is true: return YES
                    if (currentValue === '-1' || currentValue === 'true') {
                        return 'YES';
                    }

                    // if value is false: return NO
                    if (currentValue === '0' || currentValue === 'false') {
                        return 'NO';
                    }

                    // if value is null: return empty string
                    return '';
                },

                // set the value attribute
                set: function (newValue) {
                    if (newValue === 'YES') {
                        newValue = 'true';
                    }
                    if (newValue === 'NO') {
                        newValue = 'false';
                    }
                    this.setAttribute('value', newValue);
                }
            }
        },
        methods: {

        }
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('<gs-combo>', '<gs-combo>', 'gs-combo src="${1:test.tpeople}" column="${2}"></gs-combo>');

    designRegisterElement('gs-combo', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-combo.html');

    window.designElementProperty_GSCOMBO = function (selectedElement) {
        addProp('Source', true,
                '<gs-memo class="target" value="' + encodeHTML(decodeURIComponent(selectedElement.getAttribute('src') ||
                                                                        selectedElement.getAttribute('source') || '')) + '" mini></gs-memo>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'src', encodeURIComponent(this.value));
        });

        addProp('Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('cols') || '') + '" mini></gs-text>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'cols', this.value);
        });

        addProp('Initialize Source', true,
                '<gs-memo class="target" value="' + encodeHTML(decodeURIComponent(selectedElement.getAttribute('initialize') || '')) + '" mini></gs-memo>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'initialize', encodeURIComponent(this.value));
        });

        addProp('Hide Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('hide') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'hide', this.value);
        });

        addProp('Where', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('where') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'where', this.value);
        });

        addProp('Order By', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('ord') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'ord', this.value);
        });

        addProp('Limit', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('limit') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'limit', this.value);
        });

        addProp('Offset', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('offset') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'offset', this.value);
        });
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Allow Empty', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('allow-empty')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'allow-empty', (this.value === 'true'), true);
        });

        addProp('Limit&nbsp;To&nbsp;List', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('limit-to-list')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'limit-to-list', (this.value === 'true'), true);
        });

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });

        addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))          { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop')) { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))  { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))   { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop')) { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))  { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))   { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        // READONLY attribute
        addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
        });

        addProp('Refresh On Querystring Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('refresh-on-querystring-values') || '') + '" mini></gs-text>', function () {
            this.removeAttribute('refresh-on-querystring-change');
            return setOrRemoveTextAttribute(selectedElement, 'refresh-on-querystring-values', this.value);
        });

        addProp('Refresh On Querystring Change', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('refresh-on-querystring-change')) + '" mini></gs-checkbox>', function () {
            this.removeAttribute('refresh-on-querystring-values');
            return setOrRemoveBooleanAttribute(selectedElement, 'refresh-on-querystring-change', this.value === 'true', true);
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);

        //// SUSPEND-CREATED attribute
        //addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
        //    return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        //});

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    // scroll the dropdown to the selected record
    function scrollToSelectedRecord(element) {
        var positioningContainer, scrollingContainer, arrTrs, i, len, intScrollTop, bolFoundSelected = false;

        if (element.currentDropDownContainer) {
            positioningContainer = xtag.queryChildren(element.currentDropDownContainer, '.gs-combo-positioning-container')[0];
            scrollingContainer = xtag.queryChildren(positioningContainer, '.gs-combo-scroll-container')[0];
            arrTrs = xtag.query(element.dropDownTable, 'tr');

            for (i = 0, intScrollTop = 0, len = arrTrs.length; i < len; i += 1) {
                if (arrTrs[i].hasAttribute('selected')) {
                    intScrollTop += arrTrs[i].offsetHeight / 2;

                    bolFoundSelected = true;

                    break;
                } else {
                    intScrollTop += arrTrs[i].offsetHeight;
                }
            }

            if (bolFoundSelected) {
                intScrollTop = intScrollTop - scrollingContainer.offsetHeight / 2;
            } else {
                intScrollTop = 0;
            }

            scrollingContainer.scrollTop = intScrollTop;
        }
    }

    // removes selected class from old selected records
    function clearSelection(element) {
        var i, len, arrSelectedTrs;

        // clear previous selection
        arrSelectedTrs = xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr[selected]');

        for (i = 0, len = arrSelectedTrs.length; i < len; i += 1) {
            arrSelectedTrs[i].removeAttribute('selected');
        }
    }

    // clears old selection and adds selected class to record
    function highlightRecord(element, record) {
        // clear previous selection
        clearSelection(element);

        // select/highlight the record that was provided
        record.setAttribute('selected', '');
    }

    // loops through the records and finds a record using the parameter (if bolPartialMatchAllowed === true then only search the first td text)
    function findRecordFromString(element, strSearchString, bolPartialMatchAllowed) {
        var i, len, matchedRecord, arrTrs = xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr');

        // if bolPartialMatchAllowed is true: only search the first td text (case insensitive)
        if (bolPartialMatchAllowed === true) {
            strSearchString = strSearchString.toLowerCase();

            for (i = 0, len = arrTrs.length; i < len; i += 1) {
                if (xtag.queryChildren(arrTrs[i], 'td')[0].textContent.toLowerCase().indexOf(strSearchString) === 0) {
                    matchedRecord = arrTrs[i];

                    break;
                }
            }

        // else: search exact text and search both the value attribute (if present) and the first td text
        } else {
            for (i = 0, len = arrTrs.length; i < len; i += 1) {
                if (arrTrs[i].getAttribute('value') === strSearchString ||
                    xtag.queryChildren(arrTrs[i], 'td')[0].textContent === strSearchString) {
                    matchedRecord = arrTrs[i];

                    break;
                }
            }
        }

        return matchedRecord;
    }

    // highlights record, sets value of the combobox using record
    function selectRecord(element, record, bolChange) {
        // add the yellow selection to the record
        highlightRecord(element, record);

        handleChange(element, bolChange);
    }

    // highlights record, sets value of the combobox using value attribute
    //      if bolChange === true then:
    //          change event and check for limit to list
    function selectRecordFromValue(element, strValue, bolChange) {
        var record = findRecordFromString(element, strValue, false);

        // if a record was found: select it
        if (record) {
            selectRecord(element, record, bolChange);

        // else if limit to list (and no record was found):
        } else if (element.hasAttribute('limit-to-list') && bolChange) {
            if (strValue === '' && element.hasAttribute('allow-empty')) {
                handleChange(element, bolChange);

            } else {
                alert('The text you entered is not in the list');
                openDropDown(element);
                GS.setInputSelection(element.control, 0, strValue.length);
            }

        // else (not limit to list and no record found):
        } else {
            clearSelection(element);

            if (!element.hasAttribute('limit-to-list')) {
                element.control.value = strValue;
                element.innerValue = strValue;
            }

            handleChange(element, bolChange);
        }
    }

    function handleChange(element, bolChange) {
        var arrSelectedTrs, strHiddenValue = '', strTextValue = '', beforechangeevent, oldRecord,
            oldInnerValue = element.innerValue, oldControlValue = element.control.value;

        if (element.dropDownTable) {
            arrSelectedTrs = xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr[selected]');

            // if there is a selected record
            if (arrSelectedTrs.length > 0) {
                // gather values from the selected record
                strHiddenValue = arrSelectedTrs[0].getAttribute('value');
                var firstTd = xtag.queryChildren(arrSelectedTrs[0], 'td')[0],
                    lastChild = firstTd.lastElementChild;
                if (lastChild && lastChild.tagName.substring(0, 3) === 'GS-') {
                    strTextValue = lastChild.textValue || lastChild.value || lastChild.textContent;
                } else {
                    strTextValue = firstTd.textContent;
                }

            } else {
                strTextValue = element.control.value;
            }

        } else {
            strTextValue = element.control.value;
        }

        // set innervalue and control value using the values we gather from the record
        element.innerValue = strHiddenValue || strTextValue;
        element.control.value = strTextValue || strHiddenValue;

        if (bolChange) {
            if (document.createEvent) {
                beforechangeevent = document.createEvent('HTMLEvents');
                beforechangeevent.initEvent('beforechange', true, true);
            } else {
                beforechangeevent = document.createEventObject();
                beforechangeevent.eventType = 'beforechange';
            }

            beforechangeevent.eventName = 'beforechange';

            if (document.createEvent) {
                element.dispatchEvent(beforechangeevent);
            } else {
                element.fireEvent("on" + beforechangeevent.eventType, beforechangeevent);
            }

            // xtag.fireEvent(element, 'beforechange', { bubbles: true, cancelable: true });

            //console.log(beforechangeevent.defaultPrevented);
            if (beforechangeevent.defaultPrevented !== true) {
                xtag.fireEvent(element, 'change', { bubbles: true, cancelable: true });

            } else {
                element.innerValue = oldInnerValue;
                element.control.value = oldControlValue;

                oldRecord = findRecordFromString(element, oldInnerValue, false);

                if (oldRecord) {
                    highlightRecord(element, oldRecord);
                } else {
                    clearSelection(element);
                }
            }

            element.ignoreChange = false;
        }
    }

    // open dropdown
    function openDropDown(element) {
        // if we are not already dropping down
        if (!element.droppingDown) {
            // if there is a source attribute on the combobox: refresh data
            if (element.getAttribute('src') || element.getAttribute('source')) {
                getData(element, false, true, function () {
                    dropDown(element);
                });
            } else {
                dropDown(element);
            }
            element.droppingDown = true;
        }
    }

    function dropDown(element) {
        var dropDownContainer = document.createElement('div'), overlay, positioningContainer, scrollContainer, observer;

        // focus control
        element.control.focus();

        // create the dropdown element (and its children)
        dropDownContainer.classList.add('gs-combo-dropdown-container');
        dropDownContainer.setAttribute('gs-dynamic', '');
        dropDownContainer.innerHTML =   '<div class="gs-combo-positioning-container" gs-dynamic>' +
                                        '    <div class="gs-combo-scroll-container" gs-dynamic></div>' +
                                        '</div>';

        // append dropdown to the body
        document.body.appendChild(dropDownContainer);

        // set variables for the various elements that we will need for calculation
        positioningContainer = xtag.queryChildren(dropDownContainer, '.gs-combo-positioning-container')[0];
        scrollContainer =      xtag.queryChildren(positioningContainer, '.gs-combo-scroll-container')[0];

        element.currentDropDownContainer = dropDownContainer;

        //console.log(element.currentDropDownContainer);
        //console.log(element.dropDownTable);

        // fill dropdown with content
        if (element.dropDownTable) {
            //element.dropDownTable = GS.cloneElement(element.staticDropDownTable);
            scrollContainer.appendChild(element.dropDownTable);

        //} else if (element.tableTemplate) {
        //    scrollContainer.innerHTML = element.tableTemplate;
        //
        } else {
            scrollContainer.innerHTML = element.initalHTML;
        }

        // create an observer instance
        observer = new MutationObserver(function(mutations) {
            dropDownSize(element);
        });

        // pass in the element node, as well as the observer options
        observer.observe(scrollContainer, {childList: true, subtree: true});

        //console.log(scrollContainer);

        dropDownSize(element);
    }

    function dropDownSize(element) {
        var dropDownContainer    = element.currentDropDownContainer,
            positioningContainer = xtag.queryChildren(dropDownContainer, '.gs-combo-positioning-container')[0],
            scrollContainer      = xtag.queryChildren(positioningContainer, '.gs-combo-scroll-container')[0],
            overlay, jsnComboOffset, intComboHeight, intComboWidth, intViewportWidth, intViewportHeight,
            intFromControlToBottomHeight, intFromControlToTopHeight, intContentHeight, intNewWidth,
            strWidth = '', strHeight = '', strLeft = '', strTop = '', strBottom = '';

        // set variables needed for position calculation
        intComboHeight               = element.offsetHeight;
        intComboWidth                = element.offsetWidth;
        intViewportHeight            = window.innerHeight;
        intViewportWidth             = window.innerWidth;
        jsnComboOffset               = GS.getElementOffset(element);
        intContentHeight             = scrollContainer.scrollHeight;
        intFromControlToBottomHeight = intViewportHeight - (jsnComboOffset.top + intComboHeight);
        intFromControlToTopHeight    = jsnComboOffset.top;


        //console.log(intFromControlToBottomHeight, intFromControlToTopHeight);


        // set position, height and (top or bottom) variables
        // if desktop:
        if (!evt.touchDevice) {
            // if viewport is too small go full page
            if (window.innerHeight < 500 &&
                intContentHeight > intFromControlToTopHeight &&
                intContentHeight > intFromControlToBottomHeight) {
                strHeight = window.innerHeight + 'px';
                strTop =  '0px';

            // try 200px
            } else if (intContentHeight < 500) {
                strHeight = '200px';

                if (intFromControlToBottomHeight > intFromControlToTopHeight || intFromControlToBottomHeight > 200) {
                    strTop = (intFromControlToTopHeight + intComboHeight) + 'px';
                } else {
                    strBottom = (intFromControlToBottomHeight + intComboHeight) + 'px';
                }

            // try height from control to bottom of viewport
            } else if (intFromControlToBottomHeight >= intFromControlToTopHeight) {
                strHeight = intFromControlToBottomHeight + 'px';
                strTop = (intFromControlToTopHeight + intComboHeight) + 'px';

            // else height from control to top of viewport
            } else {// if (intFromControlToTopHeight >= intFromControlToBottomHeight) {
                strHeight = intFromControlToTopHeight + 'px';
                strBottom = (intFromControlToBottomHeight + intComboHeight) + 'px';
            }

        // else mobile:
        } else {
            // try 200px bottom
            if (intFromControlToBottomHeight > 200 && intContentHeight < 500) {
                strHeight = intFromControlToBottomHeight + 'px';
                strTop = (intFromControlToTopHeight + intComboHeight) + 'px';

            // try 200px top
            } else if (intFromControlToTopHeight > 200 && intContentHeight < 500) {
                strHeight = intFromControlToTopHeight + 'px';
                strBottom = (intFromControlToBottomHeight + intComboHeight) + 'px';

            // else full page
            } else {
                strHeight = window.innerHeight + 'px';
                strTop =  '0px';
            }
        }


        // set width and left variables
        // try regular
        if (scrollContainer.scrollWidth <= scrollContainer.offsetWidth) {
            if (intComboWidth < 150) {
                intNewWidth = (window.innerWidth - jsnComboOffset.left) - 20;

                if (intNewWidth < 300) {
                    strWidth = intNewWidth + 'px';
                } else {
                    strWidth = '300px';
                }

            } else {
                strWidth = intComboWidth + 'px';
            }
            strLeft = jsnComboOffset.left + 'px';

        // else full width
        } else {
            strWidth = '100%';
            strLeft = '0px';
        }


        // set position and size using variables
        positioningContainer.style.left   = strLeft;
        positioningContainer.style.top    = strTop;
        positioningContainer.style.bottom = strBottom;
        positioningContainer.style.width  = strWidth;
        positioningContainer.style.height = strHeight;

        if (strTop) {
            dropDownContainer.classList.add('below');
        } else {
            dropDownContainer.classList.add('above');
        }


        // if the table is wider than the drop down: reflow
        if (scrollContainer.clientWidth < scrollContainer.scrollWidth &&
            xtag.query(scrollContainer, 'tbody tr:first-child td, tbody tr:first-child th').length > 1) {
            scrollContainer.classList.add('reflow');
        }


        // if the table is shorter than the drop down: resize the dropdown to be as short as the table
        if (intContentHeight < scrollContainer.clientHeight) {
            positioningContainer.style.height = intContentHeight + 'px';
        }


        // make combobox float over overlay so that you can focus into the input box
        element.classList.add('open');

        //// if there is already a placeholder: delete the old one
        //if (element.placeholderElement) {
        //    element.parentNode.removeChild(element.placeholderElement);
        //    element.placeholderElement = undefined;
        //
        //    element.style.left   = element.oldLeft;
        //    element.style.right  = element.oldRight;
        //    element.style.top    = element.oldTop;
        //    element.style.bottom = element.oldBottom;
        //    element.style.width  = element.oldWidth;
        //    element.style.height = element.oldHeight;
        //}
        //
        //// save old styles
        //element.oldLeft   = element.style.left;
        //element.oldRight  = element.style.right;
        //element.oldTop    = element.style.top;
        //element.oldBottom = element.style.bottom;
        //element.oldWidth  = element.style.width;
        //element.oldHeight = element.style.height;
        //
        //element.style.left = '';
        //element.style.right = '';
        //element.style.top = '';
        //element.style.bottom = '';
        //element.style.width = '';
        //element.style.height = '';
        //
        //element.style.left   = jsnComboOffset.left + 'px';
        //element.style.top    = jsnComboOffset.top + 'px';
        //element.style.width  = intComboWidth + 'px';
        //element.style.height = intComboHeight + 'px';
        //
        //// put a placeholder element so that elements dont jump under where the combobox was
        //element.placeholderElement = document.createElement('div');
        //
        //element.placeholderElement.setAttribute('gs-dynamic', '');
        //element.placeholderElement.style.left   = element.oldLeft;
        //element.placeholderElement.style.right  = element.oldRight;
        //element.placeholderElement.style.top    = element.oldTop;
        //element.placeholderElement.style.bottom = element.oldBottom;
        //element.placeholderElement.style.width  = element.oldWidth;      // this will set the width of the placholder if
        //                                                                 //     the combobox had a set width
        //element.placeholderElement.style.height = intComboHeight + 'px'; // set the height of the placeholder to the
        //                                                                 //     actual height of the combobox
        //
        //element.parentNode.insertBefore(element.placeholderElement, element);

        // change element open state variable
        element.open = true;


        // bind drop down
        bindDropDown(element);


        // scroll to the selected record (if any)
        scrollToSelectedRecord(element);
    }

    // bind dropdown events
    function bindDropDown(element) {
        var selectableTrs, closeDropDownHandler, selectRecordHandler, i, len,
            unbindSelectRecordHandler, unbindDropDownEvents, wheelHandler;

        wheelHandler = function (event) {
            var tableElement = GS.findParentElement(event.target, '.gs-combo-dropdown-container');

            if (tableElement !== element.currentDropDownContainer) {
                closeDropDownHandler();
            }
        };

        // unbind function
        unbindDropDownEvents = function () {
            var i, len;

            for (i = 0, len = selectableTrs.length; i < len; i += 1) {
                selectableTrs[i].removeEventListener('click', selectRecordHandler);
            }

            window.removeEventListener('resize', closeDropDownHandler);
            window.removeEventListener('orientationchange', closeDropDownHandler);
            window.removeEventListener('mousewheel', wheelHandler);
            document.body.removeEventListener('click', closeDropDownHandler);
        };

        // handle record click
        selectableTrs = xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr');

        selectRecordHandler = function (event) {
            selectRecord(element, GS.findParentTag(event.target, 'tr'), true);
            closeDropDownHandler();
        };

        for (i = 0, len = selectableTrs.length; i < len; i += 1) {
            selectableTrs[i].addEventListener('click', selectRecordHandler);
        }

        // handle dropdown close
        closeDropDownHandler = function (event) {
            closeDropDown(element);
            unbindDropDownEvents();
        };

        window.addEventListener('resize', closeDropDownHandler);
        window.addEventListener('orientationchange', closeDropDownHandler);
        window.addEventListener('mousewheel', wheelHandler);
        document.body.addEventListener('click', closeDropDownHandler);
    }

    // remove dropdown from screen
    function closeDropDown(element) {
        // if there is a dropdown to remove: remove the dropdown
        if (element.currentDropDownContainer) {
            document.body.removeChild(element.currentDropDownContainer);
            element.currentDropDownContainer = undefined;

            element.classList.remove('open');
            element.open = false;
            element.droppingDown = false;

            //element.parentNode.removeChild(element.placeholderElement);
            //element.placeholderElement = undefined;
            //
            //element.style.left   = element.oldLeft;
            //element.style.right  = element.oldRight;
            //element.style.top    = element.oldTop;
            //element.style.bottom = element.oldBottom;
            //element.style.width  = element.oldWidth;
            //element.style.height = element.oldHeight;
        }
    }

    // handle behaviours on keydown
    function handleKeyDown(element, event) {
        var intKeyCode = event.keyCode || event.which, selectedTr, trs, i, len, selectedRecordIndex, firstTd, lastChild, strTextValue;

        if (!element.hasAttribute('disabled') && !element.hasAttribute('readonly')) {
            if ((intKeyCode === 40 || intKeyCode === 38) && !event.shiftKey && !event.metaKey && !event.ctrlKey && !element.error) {
                if (!element.open) {
                    openDropDown(element);

                } else {
                    trs = xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr');

                    for (i = 0, len = trs.length; i < len; i += 1) {
                        if (trs[i].hasAttribute('selected')) {
                            selectedRecordIndex = i;
                            selectedTr = trs[i];
                            trs[i].removeAttribute('selected');

                            break;
                        }
                    }

                    if (intKeyCode === 40) {// next record or circle to first record or start selection at the first
                        if (!selectedTr || selectedRecordIndex === trs.length - 1) {
                            highlightRecord(element, trs[0]);
                            selectedTr = trs[0];

                        } else {
                            highlightRecord(element, trs[selectedRecordIndex + 1]);
                            selectedTr = trs[selectedRecordIndex + 1];
                        }

                    } else if (intKeyCode === 38) {// prev record or circle to last record or start selection at the last
                        if (!selectedTr || selectedRecordIndex === 0) {
                            highlightRecord(element, trs[trs.length - 1]);
                            selectedTr = trs[trs.length - 1];

                        } else {
                            highlightRecord(element, trs[selectedRecordIndex - 1]);
                            selectedTr = trs[selectedRecordIndex - 1];
                        }
                    }
                    scrollToSelectedRecord(element);
                }
                if (selectedTr) {
                    element.control.value = xtag.queryChildren(selectedTr, 'td')[0].textContent;
                }

                GS.setInputSelection(element.control, 0, element.control.value.length);

                event.preventDefault();
                event.stopPropagation();

            } else if ((intKeyCode === 39) && !event.shiftKey && !event.metaKey && !event.ctrlKey && !element.error) {
                selectedTr = xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr[selected]')[0];

                if (selectedTr) {
                    firstTd = xtag.queryChildren(selectedTr, 'td')[0];
                    lastChild = firstTd.lastElementChild;

                    if (lastChild && lastChild.tagName.substring(0, 3) === 'GS-') {
                        strTextValue = lastChild.textValue || lastChild.value || lastChild.textContent;
                    } else {
                        strTextValue = firstTd.textContent;
                    }

                    //console.log(element.innerValue, element.control.value, selectedTr.getAttribute('value'), strTextValue);

                    selectRecord(element, selectedTr,
                                element.innerValue !== (selectedTr.getAttribute('value') || strTextValue));
                }

                event.stopPropagation();

            } else if (event.keyCode === 13 || event.keyCode === 9) {
                if (element.dropDownTable && xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr[selected]').length > 0) {
                    selectRecordFromValue(element, element.control.value, true);
                    element.ignoreChange = true;
                }

                closeDropDown(element);

            } else if (!event.metaKey &&       // not command key
                       !event.ctrlKey &&       // not control key
                       event.keyCode !== 37 && // not arrow keys
                       event.keyCode !== 38 &&
                       event.keyCode !== 39 &&
                       event.keyCode !== 40 &&
                       event.keyCode !== 46 && // not forward delete key
                       event.keyCode !== 8) {  // not delete key
                element.attemptSearchOnNextKeyup = true;
            }
        } else {
            if (event.keyCode !== 9) {
                event.preventDefault();
                event.stopPropagation();
            }
        }
    }

    // search on keyup
    //      the reason we are using keyup for search is because on keydown the letter has not been typed in yet and
    //      it would be harder if we tried to use the keycode to get the letter that was typed. so on keydown
    //      (which is where we can tell if CMD or CTRL and other keys that we dont want to search on and pressed)
    //      if we didn't type something that we dont want to search on but we typed somthing else: set this.attemptSearchOnNextKeyup
    //      to true and on keyup we read that and if it is set to true then we do a search and set it back to false
    function handleKeyUp(element, event) {
        var intKeyCode = event.keyCode || event.which, strSearch = element.control.value, matchRecord;

        // if element.attemptSearchOnNextKeyup is true and
        //      there is a search string and
        //      the user has their text selection at the end of the of the input
        if (element.attemptSearchOnNextKeyup === true &&
            strSearch &&
            GS.getInputSelection(element.control).start === strSearch.length) {

            // ######### FOR CROSS
            // you need to comment the code inside this block.
            // you need an if statment for >2000 records.
            // you need to use the currently commented code for <=2000 records.
            // you need new code for >2000.
            // you need to get the template and put it inside a virtual template element.
            // a virtual template element is just a template element inside a javascript variable.
            //      var templateElement = document.createElement('template');
            // you need to fill templateElement with the record template string, don't use the thead. (you'll find most everything in element.tableTemplate)
            // you need to extract the contents of the first td and put that into a variable.
            // you need to extract the contents of the "value" attribute on the tr (if present).
            // because you extracted the contents before templating, the variables are untemplated.
            // you need to get the column name from the first td template.
            //      there are three things you need to try:
            //          do a regex for "row.something", cut off the row
            //              OR
            //          do a regex for "row['something']", cut off the row[' and ']
            //              OR
            //          do a regex for "row["something"]", cut off the row[" and "]
            //
            //      that should be good enough. if you can't get the column: stop and
            //          console.warn to tell the developer to stick <!-- row.column -->
            //          at the top of the first td
            // you need to run an AJAX call on the postgres object in "src" with a where clause.
            // the where clause will be something like this:
            //          (OLDWHERE) AND COLUMN ILIKE $UnCOPYQTE$ strSearch%$UnCOPYQTE$
            // the ajax call should only get one record.
            // use the two templates to set the value (copy the original code).
            //
            // after you're done, leave these comments for future developers



            //<gs-combo src="test.tpeople" column="">
            //    <template>
            //        <table>
            //            <thead>
            //                <tr>
            //                    <th>asdf</th>
            //                    <th>fdsa</th>
            //                </tr>
            //            </thead>
            //            <tbody>
            //                <tr value="{{! row.id }}"> <--- hidden value, if present
            //                    <td>{{! row.asdf }}</td> <--- visible value
            //                    <td>{{! row.fdsa }}</td>
            //                </tr>
            //            </tbody>
            //        </table>
            //    </template>
            //</gs-combo>

            if (xtag.queryChildren(xtag.queryChildren(element.dropDownTable, 'tbody')[0], 'tr').length > 2000) {
                var strSearchCol = '', templateElement = element.tableTemplate;

                templateElement = templateElement.substring(templateElement.indexOf('td'), templateElement.indexOf('/td') - 1);
                templateElement = templateElement.substring(templateElement.indexOf('{'), templateElement.length);
                if (templateElement.indexOf('row.') === -1) {
                    if (templateElement.indexOf('row[') === -1) {
                        console.warn('There is no doT.js in the first "<td>" in your template please fill your first "<td>" with templating code.');
                    } else {
                        templateElement = templateElement.substring(parseInt(templateElement.indexOf('row['), 10) + 5, templateElement.length - 2 - 3).trim();
                    }
                } else {
                    templateElement = templateElement.substring(parseInt(templateElement.indexOf('row.'), 10) + 4, templateElement.length - 3).trim();
                }


                strSearchCol = templateElement;

                var strSrc     = GS.templateWithQuerystring(element.getAttribute('src'))
                  , srcParts   = strSrc[0] === '(' ? [strSrc, ''] : strSrc.split('.')
                  , strSchema  = srcParts[0]
                  , strObject  = srcParts[1]
                  , strColumns = GS.templateWithQuerystring(element.getAttribute('cols') || '*').split(',').join('\t')
                  , strWhere   = (
                      element.hasAttribute('where')
                        ? GS.templateWithQuerystring(element.getAttribute('where') || '') + ' AND ' + strSearchCol + '::text ILIKE $UnCOPYQTE$' + strSearch + '%$UnCOPYQTE$'
                        : strSearchCol + '::text ILIKE $UnCOPYQTE$' + strSearch + '%$UnCOPYQTE$'
                      )
                  , strOrd     = GS.templateWithQuerystring(element.getAttribute('ord') || '')
                  , strLimit   = '1'
                  , strOffset  = GS.templateWithQuerystring(element.getAttribute('offset') || '')
                  , response_i = 0, response_len = 0, arrTotalRecords = [];

                //console.log(strLink);
                //console.log(strSearchCol);


                if (strSearchCol) {
                    GS.requestSelectFromSocket(GS.envSocket, strSchema, strObject, strColumns
                                             , strWhere, strOrd, strLimit, strOffset
                                             , function (data, error) {
                        var arrCells, cell_i, cell_len;

                        if (!error) {
                            if (data.strMessage !== 'TRANSACTION COMPLETED') {
                                arrCells = arrRecords[i].split('\t');

                                element.control.value = arrCells[0] = arrCells[0] === '\\N' ? null : GS.decodeFromTabDelimited(arrCells[0]);
                                GS.setInputSelection(element.control, strSearch.length, element.control.value.length);
                                if (element.open) {
                                    matchRecord = findRecordFromString(element, strSearch, true);
                                    if (matchRecord) {
                                        highlightRecord(element, matchRecord);
                                        scrollToSelectedRecord(element);
                                    }
                                }
                            }
                        } else {
                            handleData(element, bolInitalLoad, data, error);
                            //GS.removeLoader(element);
                        }
                    });
                }



            } else {
                matchRecord = findRecordFromString(element, strSearch, true);

                // if we found a record and its was already selected: selected the matched record and dont
                if (matchRecord) {
                    highlightRecord(element, matchRecord);
                    element.control.value = xtag.queryChildren(matchRecord, 'td')[0].textContent;
                    GS.setInputSelection(element.control, strSearch.length, element.control.value.length);

                    scrollToSelectedRecord(element);

                } else {
                    clearSelection(element);
                    //selectRecordFromValue(element, strSearch, false);
                    //GS.setInputSelection(element.control, strSearch.length, element.control.value.length);
                }
            }


        }

        if (element.attemptSearchOnNextKeyup === true) {
            element.attemptSearchOnNextKeyup = false;
        }
    }

    // handles fetching the data
    //      if bolInitalLoad === true then
    //          use: initialize query COALESCE TO source query
    //      else
    //          use: source query
    function getData(element, bolInitalLoad, bolClearPrevious, callback) {
        var strSrc     = GS.templateWithQuerystring(
                            (bolInitalLoad && element.getAttribute('initialize')
                                ? element.getAttribute('initialize')
                                : element.getAttribute('src')
                            )
                        )
          , srcParts   = strSrc[0] === '(' ? [strSrc, ''] : strSrc.split('.')
          , strSchema  = srcParts[0]
          , strObject  = srcParts[1]
          , strColumns = GS.templateWithQuerystring(element.getAttribute('cols') || '*').split(',').join('\t')
          , strWhere   = GS.templateWithQuerystring(element.getAttribute('where') || '')
          , strOrd     = GS.templateWithQuerystring(element.getAttribute('ord') || '')
          , strLimit   = GS.templateWithQuerystring(element.getAttribute('limit') || '')
          , strOffset  = GS.templateWithQuerystring(element.getAttribute('offset') || '')
          , response_i = 0, response_len = 0, arrTotalRecords = [];


        //GS.addLoader(element, 'Loading...');
        GS.requestCachingSelect(GS.envSocket, strSchema, strObject, strColumns
                                 , strWhere, strOrd, strLimit, strOffset
                                 , function (data, error) {
            var arrRecords, arrCells, envData
              , i, len, cell_i, cell_len;

            if (!error) {
                if (data.strMessage !== 'TRANSACTION COMPLETED') {
                    arrRecords = GS.trim(data.strMessage, '\n').split('\n');

                    for (i = 0, len = arrRecords.length; i < len; i += 1) {
                        arrCells = arrRecords[i].split('\t');

                        for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                            arrCells[cell_i] = arrCells[cell_i] === '\\N' ? null : GS.decodeFromTabDelimited(arrCells[cell_i]);
                        }

                        arrTotalRecords.push(arrCells);
                    }
                } else {
                    //GS.removeLoader(element);
                    element.arrColumnNames = data.arrColumnNames;

                    envData = {'arr_column': element.arrColumnNames, 'dat': arrTotalRecords};

                    handleData(element, bolInitalLoad, envData);
                    if (typeof callback === 'function') {
                        callback();
                    }
                }
            } else {
                handleData(element, bolInitalLoad, data, error);
                //GS.removeLoader(element);
            }
        }, bolClearPrevious);
    }

    // handles data result from method function: getData
    //      success:  template
    //      error:    add error classes
    function handleData(element, bolInitalLoad, data, error) {
        var divElement, tableElement, theadElement, theadCellElements, tbodyElement, tbodyCellElements, lastRecordElement,
            currentCellLabelElement, template, i, len, arrHeaders = [], strTemplate, arrHide, strHeaderCells, strRecordCells,
            tableTemplateElement, recordElements, recordElement, jsnTemplate, strHTML;

        //GS.triggerEvent(this, 'after_select'); <== caused a MAJOR issue where code that was supposed to
        //                                              run after an envelope after_select caught all of
        //                                              the after selects of the comboboxes in the envelope

        // clear any old error status
        element.classList.remove('error');
        element.dropDownButton.setAttribute('title', '');
        element.dropDownButton.setAttribute('icon', 'angle-down');

        // if there was no error
        if (!error) {
            element.error = false;

            //console.log(this, this.tableTemplate);

            if (element.tableTemplate) {
                //tableTemplateElement = document.createElement('template');
                //tableTemplateElement.innerHTML = this.tableTemplate;
                //
                //theadElement = xtag.query(tableTemplateElement.content, 'thead')[0];
                //tbodyElement = xtag.query(tableTemplateElement.content, 'tbody')[0];
                //
                //console.log(theadElement, tbodyElement);

                strTemplate = element.tableTemplate; //this.initalHTML;

            } else { // if (data.arr_column)
                // create an array of hidden column numbers
                arrHide = (element.getAttribute('hide') || '').split(/[\s]*,[\s]*/);

                // build up the header cells variable and the record cells variable
                for (i = 0, len = data.arr_column.length, strHeaderCells = '', strRecordCells = ''; i < len; i += 1) {
                    // if this column is not hidden
                    if (arrHide.indexOf((i + 1) + '') === -1 && arrHide.indexOf(data.arr_column[i]) === -1) {
                        // append a new cell to each of the header cells and record cells variables
                        strHeaderCells += '<th gs-dynamic>' + encodeHTML(data.arr_column[i]) + '</th> ';
                        strRecordCells += '<td gs-dynamic>{{! row[\'' + data.arr_column[i] + '\'] }}</td> ';
                    }
                }

                // put everything together
                strTemplate =   '<table gs-dynamic>' +
                                    '<thead gs-dynamic>' +
                                        '<tr gs-dynamic>' +
                                            strHeaderCells +
                                        '</tr>' +
                                    '</thead>' +
                                    '<tbody gs-dynamic>' +
                                        '<tr value="{{! row[\'' + data.arr_column[0] + '\'] }}" gs-dynamic>' +
                                            strRecordCells +
                                        '</tr>' +
                                    '</tbody>' +
                                '<table>';
            }

            divElement = document.createElement('div');

            divElement.innerHTML = strTemplate;

            tableElement = xtag.queryChildren(divElement, 'table')[0];
            theadElement = xtag.queryChildren(tableElement, 'thead')[0];
            tbodyElement = xtag.queryChildren(tableElement, 'tbody')[0];

            // if there is a tbody
            if (tbodyElement) {
                recordElement = xtag.queryChildren(tbodyElement, 'tr')[0];

                // if there is a record: template
                if (recordElement) {

                    // if there is a thead element: add reflow cell headers to the tds
                    if (theadElement) {
                        theadCellElements = xtag.query(theadElement, 'td, th');
                        tbodyCellElements = xtag.query(tbodyElement, 'td, th');

                        for (i = 0, len = theadCellElements.length; i < len; i += 1) {
                            currentCellLabelElement = document.createElement('b');
                            currentCellLabelElement.classList.add('cell-label');
                            currentCellLabelElement.setAttribute('data-text', (theadCellElements[i].textContent || '') + ':');
                            currentCellLabelElement.setAttribute('gs-dynamic', '');

                            if (tbodyCellElements[i].childNodes) {
                                tbodyCellElements[i].insertBefore(currentCellLabelElement, tbodyCellElements[i].childNodes[0]);
                            } else {
                                tbodyCellElements[i].insertChild(currentCellLabelElement);
                            }
                        }
                    }

                    // template
                    jsnTemplate = GS.templateHideSubTemplates(tbodyElement.innerHTML, true);
                    strHTML = GS.templateWithEnvelopeData(tbodyElement.innerHTML, data);
                    tbodyElement.innerHTML = GS.templateShowSubTemplates(strHTML, jsnTemplate);

                    element.dropDownTable = tableElement;
                    element.ready = true;
                }
            }

            //if (data.arr_column) {
            if (bolInitalLoad && element.getAttribute('value')) {
                selectRecordFromValue(element, element.getAttribute('value'), false);

            } else if (element.value) {
                selectRecordFromValue(element, element.value, false);
            }
            //}

        // else there was an error: add error class, title attribute
        } else {
            console.error(data);
            element.error = true;
            element.ready = false;
            element.classList.add('error');
            element.dropDownButton.setAttribute('title', 'This combobox has failed to load.');
            element.dropDownButton.setAttribute('icon', 'exclamation-circle');

            if (element.hasAttribute('limit-to-list')) {
                element.setAttribute('disabled', '');
            }
        }
    }

    function refreshControl(element) {
        var i, len, divElement, arrPassThroughAttributes = [
                'placeholder',
                'name',
                'maxlength',
                'autocorrect',
                'autocapitalize',
                'autocomplete',
                'autofocus',
                'spellcheck',
                'readonly'
            ];

        // if the gs-text element has a tabindex: save the tabindex and remov the attribute
        if (element.hasAttribute('tabindex')) {
            element.savedTabIndex = element.getAttribute('tabindex');
            element.removeAttribute('tabindex');
        }

        // clear out the combobox HTML
        element.innerHTML = '';

        // creating/setting root
        divElement = document.createElement('div');
        divElement.setAttribute('gs-dynamic', '');
        divElement.classList.add('root');

        element.appendChild(divElement);
        element.root = divElement;

        element.root.innerHTML = '<input gs-dynamic class="control" type="text" />' +
                                 '<gs-button gs-dynamic class="drop_down_button" icononly icon="angle-down" no-focus></gs-button>';

        element.control = xtag.query(element, '.control')[0];
        element.dropDownButton = xtag.query(element, '.drop_down_button')[0];

        // copy passthrough attrbutes to control
        for (i = 0, len = arrPassThroughAttributes.length; i < len; i += 1) {
            if (element.hasAttribute(arrPassThroughAttributes[i])) {
                element.control.setAttribute(arrPassThroughAttributes[i], element.getAttribute(arrPassThroughAttributes[i]) || '');
            }
        }

        // if we saved a tabindex: apply the tabindex to the control
        if (element.savedTabIndex !== undefined && element.savedTabIndex !== null) {
            element.control.setAttribute('tabindex', element.savedTabIndex);
        }

        // bind change event to control
        //console.log('change bound');
        element.control.addEventListener('change', function (event) {
            event.preventDefault();
            event.stopPropagation();

            //console.log('change detected');
            if (!element.ignoreChange) {
                selectRecordFromValue(element, this.value, true);
            }
            element.ignoreChange = false;
        });


        //  on safari the change event doesn't occur if you click out while the autocomplete has
        //      completed the value (because the user technically didn't change after the javascript changed the value)
        //  to solve this the code below will mimic a change event if one does not occur at the right time

        // there are two ways that user's cause change events:
        //      1) after making a change to the value: taking the focus out of the field
        //      2) after making a change to the value: hitting return

        // this code counts on the fact that a browser will always emit a change event before a 'blur' or 'keyup'
        // the execution is as follows

        // this is the basic plan:
        //  change:
        //          // changeOccured tells the event code to not do anything because a change event did fire
        //          element.changeOccured to true
        //  focus:
        //          // element.lastValue allows us to compare the value to the old value, and if there's a difference: we need a change event
        //          set element.lastValue to current value of the control
        //  blur:
        //          if element.changeOccured === true:
        //              set element.changeOccured = false
        //          else:
        //              if control.value !== lastValue: // if the value has been changed
        //                  trigger artificial change event on control
        //  keyup (on return key):
        //          if element.changeOccured === true:
        //              set element.changeOccured = false
        //          else:
        //              if control.value !== lastValue: // if the value has been changed
        //                  trigger artificial change event on control


        element.control.addEventListener('change', function (event) {
            element.changeOccured = true;
        });

        element.control.addEventListener('focus', function (event) {
            element.lastValue = element.control.value;

            event.target.parentNode.parentNode.classList.add('focus');
        });

        element.control.addEventListener('blur', function (event) {
            if (element.changeOccured === true) {
                element.changeOccured = false;
            } else if (element.control.value !== element.lastValue) {
                GS.triggerEvent(element.control, 'change');
            }

            event.target.parentNode.parentNode.classList.remove('focus');
        });

        element.control.addEventListener(evt.mouseout, function (event) {
            event.target.parentNode.parentNode.classList.remove('hover');
        });

        element.control.addEventListener(evt.mouseover, function (event) {
            event.target.parentNode.parentNode.classList.add('hover');
        });

        element.control.addEventListener('keyup', function (event) {
            // if the key was return
            if ((event.keyCode || event.which) === 13 && !element.hasAttribute('readonly')) {
                if (element.changeOccured === true) {
                    element.changeOccured = false;
                } else if (element.control.value !== element.lastValue) {
                    GS.triggerEvent(element.control, 'change');
                }
            }
        });
    }

    //function pushReplacePopHandler(element) {
    //    var i, len, arrPopKeys, currentValue, bolRefresh = false, strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //
    //    if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //
    //    if (element.hasAttribute('refresh-on-querystring-values')) {
    //        arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
    //
    //        for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
    //            currentValue = GS.qryGetVal(strQueryString, arrPopKeys[i]);
    //
    //            if (element.popValues[arrPopKeys[i]] !== currentValue) {
    //                bolRefresh = true;
    //            }
    //
    //            element.popValues[arrPopKeys[i]] = currentValue;
    //        }
    //
    //    } else if (element.hasAttribute('refresh-on-querystring-change')) {
    //        bolRefresh = true;
    //    }
    //
    //    if (bolRefresh) {
    //        getData(element);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var arrPopKeys;
        var currentValue;
        var bolRefresh;
        var strOperator;

        if (strQSCol) {
            if (strQSCol.indexOf('=') !== -1) {
                arrAttrParts = strQSCol.split(',');
                i = 0;
                len = arrAttrParts.length;
                while (i < len) {
                    strQSCol = arrAttrParts[i];

                    if (strQSCol.indexOf('!=') !== -1) {
                        strOperator = '!=';
                        arrQSParts = strQSCol.split('!=');
                    } else {
                        strOperator = '=';
                        arrQSParts = strQSCol.split('=');
                    }

                    strQSCol = arrQSParts[0];
                    strQSAttr = arrQSParts[1] || arrQSParts[0];

                    // if the key is not present or we've got the negator: go to the attribute's default or remove it
                    if (strOperator === '!=') {
                        // if the key is not present: add the attribute
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            element.setAttribute(strQSAttr, '');
                        // else: remove the attribute
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    } else {
                        // if the key is not present: go to the attribute's default or remove it
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                            } else {
                                element.removeAttribute(strQSAttr);
                            }
                        // else: set attribute to exact text from QS
                        } else {
                            element.setAttribute(strQSAttr, (
                                GS.qryGetVal(strQS, strQSCol) ||
                                element.internal.defaultAttributes[strQSAttr] ||
                                ''
                            ));
                        }
                    }
                    i += 1;
                }
            } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                strQSValue = GS.qryGetVal(strQS, strQSCol);

                if (element.internal.bolQSFirstRun !== true) {
                    if (strQSValue !== '' || !element.getAttribute('value')) {
                        element.setAttribute('value', strQSValue);
                    }
                } else {
                    element.value = strQSValue;
                }
            }
        }

        // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
        if (element.internal.bolQSFirstRun === true) {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);

                    if (element.popValues[arrPopKeys[i]] !== currentValue) {
                        bolRefresh = true;
                    }

                    element.popValues[arrPopKeys[i]] = currentValue;
                }
            } else if (element.hasAttribute('refresh-on-querystring-change')) {
                bolRefresh = true;
            }

            if (bolRefresh && element.hasAttribute('src')) {
                getData(element);
            } else if (bolRefresh && !element.hasAttribute('src')) {
                console.warn('gs-combo Warning: element has "refresh-on-querystring-values" or "refresh-on-querystring-change", but no "src".', element);
            }
        } else {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                }
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    //
    function elementInserted(element) {
        var tableTemplateElement, tableTemplateElementCopy, oldRootElement, i, len,
            recordElement, strQueryString = GS.getQueryString(), arrElement, currentElement, strQSValue;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                element.open = false;
                element.error = false;
                element.ready = false;

                // handle "qs" attribute
                if (element.getAttribute('qs') ||
                        element.getAttribute('refresh-on-querystring-values') ||
                        element.hasAttribute('refresh-on-querystring-change')) {
                    //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.setAttribute('value', strQSValue);
                    //}

                    element.popValues = {};
                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate', function () {    pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate', function () {     pushReplacePopHandler(element); });
                }

                //
                tableTemplateElement = xtag.queryChildren(element, 'template')[0];

                if (tableTemplateElement) {
                    if (tableTemplateElement.innerHTML.indexOf('&gt;') > -1 || tableTemplateElement.innerHTML.indexOf('&lt;') > -1) {
                        console.warn('GS-COMBO WARNING: &gt; or &lt; detected in table template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                    }

                    tableTemplateElementCopy = document.createElement('template');
                    tableTemplateElementCopy.innerHTML = tableTemplateElement.innerHTML;

                    recordElement = xtag.query(xtag.query(tableTemplateElementCopy.content, 'tbody')[0], 'tr')[0];

                    if (recordElement) {
                        arrElement = xtag.query(recordElement, '[column]');

                        for (i = 0, len = arrElement.length; i < len; i += 1) {
                            currentElement = arrElement[i];

                            if ((!currentElement.getAttribute('value')) && currentElement.getAttribute('column')) {
                                currentElement.setAttribute('value', '{{! row.' + currentElement.getAttribute('column') + ' }}');
                            }
                        }

                        element.tableTemplate = tableTemplateElementCopy.innerHTML;

                        if (!element.getAttribute('src') && !element.getAttribute('source') && !element.getAttribute('initalize')) {
                            //element.staticDropDownTable = GS.cloneElement(tableTemplateElementCopy.content.children[0]);
                            //element.dropDownTable = GS.cloneElement(tableTemplateElementCopy.content.children[0]); //element.staticDropDownTable;

                            element.dropDownTable = GS.cloneElement(xtag.query(tableTemplateElementCopy.content, 'table')[0]);
                        }
                    }
                }

                // filling root
                refreshControl(element);

                //
                element.addEventListener('click', function (event) {
                    var clickHandler;

                    if (event.target.classList.contains('drop_down_button')) {
                        //console.log(element.open, element.error);
                        if (!element.open && !element.error) {
                            clickHandler = function () {
                                openDropDown(element);
                                window.removeEventListener('click', clickHandler);
                            };

                            window.addEventListener('click', clickHandler);
                        } else {
                            //closeDropDown(element);
                        }
                    }
                });

                element.addEventListener('keydown', function (event) {
                    if (event.target.classList.contains('control')) {
                        handleKeyDown(element, event);
                    }
                });

                element.addEventListener('keyup', function (event) {
                    if (event.target.classList.contains('control')) {
                        handleKeyUp(element, event);
                    }
                });

                if (xtag.queryChildren(element, '.root').length < 1) {
                    refreshControl(element);
                }

                if (element.getAttribute('src') || element.getAttribute('source') || element.getAttribute('initalize')) {
                    getData(element, true);
                } else {
                    element.ready = true;

                    if (element.getAttribute('value')) {
                        selectRecordFromValue(element, element.getAttribute('value'), false);

                    } else if (element.value) {
                        selectRecordFromValue(element, element.value, false);
                    }
                }
            }
        }
    }

    xtag.register('gs-combo', {
        lifecycle: {
            created: function () {
                // if the value was set before the "created" lifecycle code runs: set attribute
                //      (discovered when trying to set a value of a date control in the after_open of a dialog)
                //      ("delete" keyword added because of firefox)
                if (this.value && !this.hasAttribute('value')) {
                    this.setAttribute('value', this.value);
                    delete this.value;
                }

                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value' && oldValue !== newValue) {
                        this.value = newValue;
                    }
                }
            }
        },
        events: {},
        accessors: {
            value: {
                get: function () {
                    if (this.control || this.innerValue) {
                        return this.innerValue || this.control.value;
                    } else if (this.getAttribute('value')) {
                        return this.getAttribute('value');
                    }
                    return undefined;
                },

                // set the value of the input and set the value attribute
                set: function (newValue) {

                    // if we have not yet templated: just stick the value in an attribute
                    if (this.ready === false) {
                        if (newValue !== this.getAttribute('value')) {
                            this.setAttribute('value', newValue);
                        }

                    // else if the value is empty and allow-empty is present
                    } else if (newValue === '' && this.hasAttribute('allow-empty')) {
                        this.innerValue = '';
                        this.control.value = '';

                    // else select the record using the string that was sent
                    } else {
                        selectRecordFromValue(this, newValue, false);
                    }
                }
            },
            textValue: {
                // get value straight from the input
                get: function () {
                    return this.control.value;
                },

                // set the value of the input and set the value attribute
                set: function (newValue) {

                    // if we have not yet templated: just stick the value in an attribute
                    if (this.ready === false) {
                        this.setAttribute('value', newValue);

                    // else select the record using the string that was sent
                    } else {
                        selectRecordFromValue(this, newValue, false);
                    }
                }
            }
        },
        methods: {
            focus: function () {
                this.control.focus();
            },

            'getData': function () {
                getData(this, undefined, true);
            },

            'refresh': function () {
                getData(this, undefined, true);
            }
        }
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('<gs-container>', '<gs-container>', 'gs-container min-width="${1:sml;med;lrg;}" ${2:padded}>\n' +
                                                                '    ${0}\n' +
                                                                '</gs-container>');

    designRegisterElement('gs-container', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-container-jumbo.html');

    window.designElementProperty_GSCONTAINER = function(selectedElement) {
        var strVisibilityAttribute;

        addProp('Min-Width Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('min-width') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'min-width', this.value);
        });

        addProp('Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('media') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'media', this.value);
        });

        addProp('Padded', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('padded')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'padded', (this.value === 'true'), true);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var arrTakenContainers = [], intScrollBarWidth;

    function getScrollBarWidth() {
        var inner = document.createElement('div'),
            outer = document.createElement('div'),
            intWidth;

        inner.style.height = '200px';

        outer.style.position = 'absolute';
        outer.style.top = '0';
        outer.style.left = '0';
        outer.style.visibility = 'hidden';
        outer.style.overflow = 'scroll';

        outer.style.width = '50px';
        outer.style.height = '100px';

        outer.appendChild(inner);
        document.body.appendChild(outer);

        intWidth = (outer.offsetWidth - inner.offsetWidth);

        document.body.removeChild(outer);

        return intWidth;
    };

    intScrollBarWidth = getScrollBarWidth();

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    //
    function elementInserted(element) {
        var styleElement;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                // if the style element for the container CSS doesn't exist: create it
                if (!document.getElementById('gs-dynamic-css')) {
                    styleElement = document.createElement('style');
                    styleElement.setAttribute('id', 'gs-dynamic-css');
                    styleElement.setAttribute('gs-dynamic', '');
                    document.head.appendChild(styleElement);
                }

                if (element.getAttribute('min-width')) {
                    element.handleMinWidthCSS();
                } else if (element.getAttribute('media')) {
                    element.handleMediaCSS();
                }
            }
        }
    }

    xtag.register('gs-container', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // if the "min-width" attribute changed
                    if (strAttrName === 'min-width') {
                        this.handleMinWidthCSS();

                    // if the "media" attribute changed
                    } else if (strAttrName === 'media') {
                        this.handleMediaCSS();
                    }
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            handleMinWidthCSS: function () {
                var strMinWidth = this.getAttribute('min-width'), arrMinWidths, strCSS, i, len,
                    arrClassesToRemove, intContainerID, intWidthNumber, strWidthOperator, strNewWidth;

                // remove old classes
                arrClassesToRemove = String(this.classList).match(/container-id-[0-9]*/g) || [];

                for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                    this.classList.remove(arrClassesToRemove[i]);
                }

                // sml;med;lrg
                // medium
                // 100;200;300;400;500;600;700;800;900;1000;1100;1200

                // remove all whitespace, lowercase, trim off semicolons
                strMinWidth = GS.trim(strMinWidth.replace(/\s+/g, '').toLowerCase(), ';');

                // replace shortcuts (lrg => 1200px)
                strMinWidth = strMinWidth.replace(/small|sml/g, '768px').replace(/medium|med/g, '992px').replace(/large|lrg/g, '1200px');

                arrMinWidths = strMinWidth.split(';'); // seperate out layouts

                //console.log(strMinWidth, arrMinWidths);

                if (arrTakenContainers.indexOf(strMinWidth) === -1) {
                    arrTakenContainers.push(strMinWidth);
                    intContainerID = arrTakenContainers.length - 1;
                    strCSS = '';

                    for (i = 0, len = arrMinWidths.length; i < len; i += 1) {
                        intWidthNumber = parseInt(arrMinWidths[i]);
                        strWidthOperator = arrMinWidths[i].replace(/[0-9]/g, '');

                        if (strWidthOperator === 'px') {
                            intWidthNumber -= intScrollBarWidth;
                        } else if (strWidthOperator === 'em') {
                            intWidthNumber -= GS.pxToEm(this.parentNode, intScrollBarWidth);
                        }

                        strNewWidth = intWidthNumber + strWidthOperator;

                        strCSS +=   '\n@media (min-width:' + arrMinWidths[i] + ') {\n' +
                                    '    gs-container.container-id-' + intContainerID +
                                                ' { width:' + strNewWidth + '; margin-left:auto; margin-right:auto; }\n' +
                                    '}\n';
                    }

                    //console.log(strCSS);

                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML +=
                            '\n/* container #' + intContainerID + ' */\n' + strCSS;

                } else {
                    intContainerID = arrTakenContainers.indexOf(strMinWidth);
                }

                this.classList.add('container-id-' + intContainerID);
            },

            handleMediaCSS: function () {
                var strMedia = this.getAttribute('media'), arrMedias, strCSS, i, len,
                    arrClassesToRemove, arrParts, strCurrentMedia, strWidth, intContainerID;

                // remove old classes
                arrClassesToRemove = String(this.classList).match(/container-id-[0-9]*/g) || [];

                for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                    this.classList.remove(arrClassesToRemove[i]);
                }

                // (min-width: 500) {small}; (max-width: 500) {50}
                // (max-width: small) {small}; (min-width: small) {small}
                // (max-width: small) {50}; (min-width: small) {500}

                // trim, remove all close curly braces, lowercase, trim off semicolons
                strMedia = GS.trim(strMedia.trim().replace(/\}/g, '').toLowerCase(), ';');

                // replace shortcuts (lrg => 1200px)
                strMedia = strMedia.replace(/small|sml/g, '768px').replace(/medium|med/g, '992px').replace(/large|lrg/g, '1200px');

                arrMedias = strMedia.split(';'); // seperate out layouts

                //console.log(strMedia, arrMedias);

                if (arrTakenContainers.indexOf(strMedia) === -1) {
                    arrTakenContainers.push(strMedia);
                    intContainerID = arrTakenContainers.length - 1;
                    strCSS = '';


                    for (i = 0, len = arrMedias.length; i < len; i += 1) {
                        arrParts = arrMedias[i].split('{');
                        strCurrentMedia = arrParts[0].trim() || 'all';
                        strWidth = arrParts[1].trim() || '900px';

                        strCSS +=   '\n@media ' + strCurrentMedia + ' {\n' +
                                    '    gs-container.container-id-' + intContainerID + ' ' +
                                                '{ width:' + strWidth + '; margin-left:auto; margin-right:auto; }\n' +
                                    '}\n';
                    }

                    //console.log(strCSS);

                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* container #' + intContainerID + ' */\n' + strCSS;

                } else {
                    intContainerID = arrTakenContainers.indexOf(strMinWidth);
                }

                this.classList.add('container-id-' + intContainerID);
            }
        }
    });
});window.addEventListener('design-register-element', function () {
    registerDesignSnippet('<gs-current-record>', '<gs-current-record>', 'gs-current-record for="${1:for}"></gs-current-record>');
    window.designElementProperty_GSCURRENT_RECORD = function (selectedElement) {
        addProp('For', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('for') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'for', this.value);
        });

        addProp('Inline', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('inline') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'inline', this.value === 'true', true);
        });
    };
});

//global xtag
//jslint browser:true
document.addEventListener("DOMContentLoaded", function () {
    "use strict";
    function buildElement(element) {

        element.forTable = document.getElementById(element.getAttribute('for'));

        element.forTable.addEventListener('selection_change', function () {
            element.refresh(element);
        });
        element.forTable.addEventListener('after_select', function () {
            element.refresh(element);
        });
        element.forTable.addEventListener('after_selection', function () {
            element.refresh(element);
        });

        element.firstChild.addEventListener('change', function (event) {
            var tableElem = element.forTable;
            var strValue = event.target.value;
            var intValue = parseInt(strValue.substring(0, strValue.indexOf(' ')), 10);
            var intMaxRecord = tableElem.internalData.records.length;

            var intMinColumn = (
                tableElem.internalDisplay.recordSelectorVisible
                    ? -1
                    : 0
            );

            // if we couldn't extract a record number from the
            //      user's value, go to the first record
            if (isNaN(intValue)) {
                intValue = 1;
            }

            if (intMaxRecord === 0) {
                intValue = undefined;
            }

            // prevent intValue from being greater than the number
            //      of records
            if (intValue > intMaxRecord) {
                intValue = intMaxRecord;
            }

            // intValue is from a user and therefore one-based
            if (!isNaN(intValue)) {
                // correct one-based by subtracting one
                intValue -= 1;
            }

            // override all current ranges to select the new record
            if (intValue !== undefined) {
                tableElem.internalSelection.ranges = [
                    {
                        "start": {
                            "row": intValue,
                            "column": intMinColumn
                        },
                        "end": {
                            "row": intValue,
                            "column": intMinColumn
                        },
                        "negator": false
                    }
                ];
            } else {
                tableElem.internalSelection.ranges = [];
            }

            // render selection and scroll into view
            tableElem.goToLine(intValue + 1);
            event.target.parentNode.refresh(event.target.parentNode);
        });
    }

    function elementInserted(element) {
        if (element.children.length === 0) {
            var gsText = document.createElement("gs-text");
            element.appendChild(gsText);
        }
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute("suspend-created") && !element.hasAttribute("suspend-inserted")) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                if (!element.children[0].classList.contains('root')) {
                    buildElement(element);
                }
            }
        }
    }

    xtag.register("gs-current-record", {
        lifecycle: {
            inserted: function () {
                elementInserted(this);
            },
            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;

                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === "suspend-created" && newValue === null) {
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === "suspend-inserted" && newValue === null) {
                    elementInserted(element);
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            'refresh': function (element) {
                element.bolRefreshing = true;
                var tableElem = element.forTable;
                var intOriginRecord = (
                    tableElem.internalSelection.originRecord
                );
                // we need the element that contains the selection status
                var statusElement = element.firstChild;
                // if the element that is supposed to contain the status is
                //      in the DOM
                if (statusElement) {
                    // if we know the origin record
                    if (intOriginRecord !== undefined) {
                        statusElement.value = (
                            // origin record number is zero-based
                            (intOriginRecord + 1) +
                            ' of ' +
                            tableElem.internalData.records.length
                        );
                    // else, we don't know the origin record
                    } else {
                        statusElement.value = (
                            'nothing selected'
                        );
                    }
                }
                element.bolRefreshing = false;
            }
        }
    });
});//jslint browser:true, white:true, multivar:true, for:true
window.addEventListener('design-register-element', function (event) {
    'use strict';

    registerDesignSnippet('<gs-datasheet>', '<gs-datasheet>',
            'gs-datasheet src="${1:test.tpeople}">\n' +
            '    <template for="hud"></template>\n' +
            '    <template for="table">\n' +
            '        <table>\n' +
            '            <tbody>\n' +
            '                <tr>\n' +
            '                    <th heading="#"><gs-static column="row_number"></gs-static></th>\n' +
            '                    <td heading="">$0</td>\n' +
            '                </tr>\n' +
            '            </tbody>\n' +
            '        </table>\n' +
            '    </template>\n' +
            '    <template for="insert"></template>\n' +
            '</gs-datasheet>');

    designRegisterElement('gs-datasheet', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-datasheet.html');

    window.designElementProperty_GSDATASHEET = function (selectedElement) {
        addProp('Source', true,
                '<gs-memo class="target" autoresize rows="1" value="' +
                        encodeHTML(decodeURIComponent(selectedElement.getAttribute('src'))) + '" mini></gs-memo>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'src', encodeURIComponent(this.value));
        });

        addProp('Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('cols') || '') + '" mini></gs-text>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'cols', this.value);
        });

        addProp('Lock Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('lock') || '') + '" mini></gs-text>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'lock', this.value);
        });

        addProp('Primary Keys', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('pk') || '') + '" mini></gs-text>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'pk', this.value);
        });

        addProp('Where', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('where') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'where', (this.value));
        });

        addProp('Order By', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('ord') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'ord', this.value);
        });

        addProp('Limit', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('limit') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'limit', this.value);
        });

        addProp('Offset', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('offset') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'offset', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Parent&nbsp;Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Line Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('child-column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'child-column', this.value);
        });

        addProp('Reflow At', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('reflow-at') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'reflow-at', this.value);
        });

        addProp('Scroll To Bottom', true, '<gs-checkbox class="target" value="' + encodeHTML(selectedElement.hasAttribute('scroll-to-bottom') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'scroll-to-bottom', (this.value === 'true'), true);
        });

        addProp('HUD Paginate', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-hudpaginate')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-hudpaginate', (this.value === 'true'), false);
        });

        addProp('HUD Refresh', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-hudrefresh')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-hudrefresh', (this.value === 'true'), false);
        });

        addProp('HUD Delete', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-huddelete')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-huddelete', (this.value === 'true'), false);
        });

        addProp('Expand&nbsp;To&nbsp;Content', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('expand-to-content')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'expand-to-content', (this.value === 'true'), true);
        });

        addProp('Null String', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('null-string') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'null-string', this.value);
        });

        addProp('Filter Popup', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-filter')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-filter', (this.value === 'true'), false);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        addProp('Refresh On Querystring Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('refresh-on-querystring-values') || '') + '" mini></gs-text>', function () {
            this.removeAttribute('refresh-on-querystring-change');
            return setOrRemoveTextAttribute(selectedElement, 'refresh-on-querystring-values', this.value);
        });

        addProp('Refresh On Querystring Change', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('refresh-on-querystring-change')) + '" mini></gs-checkbox>', function () {
            this.removeAttribute('refresh-on-querystring-values');
            return setOrRemoveBooleanAttribute(selectedElement, 'refresh-on-querystring-change', this.value === 'true', true);
        });

        //// SUSPEND-CREATED attribute
        //addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
        //    return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        //});

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var KEY_RETURN = 13, KEY_TAB = 9, KEY_BACKSPACE = 8, KEY_DELETE = 46
      , KEY_UP = 38, KEY_RIGHT = 39, KEY_DOWN = 40, KEY_LEFT = 37;

    function deleteSelection(element) {
        var strSchema = GS.templateWithQuerystring(element.getAttribute('schema'))
          , strObject = GS.templateWithQuerystring(element.getAttribute('object'))
          , arrSelectRecords = element.selectedRecords, deleteRecord, deleteRecordData
          , arrPk, arrLock, strHashColumns, strRoles, strColumns, strRecord
          , strRecordToHash, strDeleteData, strTemp, i, len, col_i, col_len;

        // if the first record is the header: remove it from the selection
        if (arrSelectRecords[0] && arrSelectRecords[0].parentNode.nodeName === 'THEAD') {
            arrSelectRecords.splice(0, 1);
        }

        if (element.numberOfSelections === 1
                && arrSelectRecords.length > 0
                && arrSelectRecords[0].children[0].hasAttribute('selected')
                && !element.deleteButton.hasAttribute('disabled')) {

            // generate the information to send to the websocket
            arrPk = (element.getAttribute('pk') || '').split(/[\s]*,[\s]*/);
            arrLock = (element.getAttribute('lock') || '').split(/[\s]*,[\s]*/);

            for (i = 0, len = arrPk.length, strRoles = '', strColumns = ''; i < len; i += 1) {
                strRoles += (strRoles ? '\t' : '') + 'pk';
                strColumns += (strColumns ? '\t' : '') + arrPk[i];
            }

            for (i = 0, len = arrLock.length, strHashColumns = ''; i < len; i += 1) {
                strHashColumns += (strHashColumns ? '\t' : '') + arrLock[i];
            }

            strRoles += (strRoles ? '\t' : '') + 'hash';
            strColumns += (strColumns ? '\t' : '') + 'hash';

            for (i = 0, len = arrSelectRecords.length, strDeleteData = ''; i < len; i += 1) {
                strRecord = '';
                deleteRecord = arrSelectRecords[i];
                deleteRecordData = element.internalData.arrRecords[parseInt(deleteRecord.getAttribute('data-index'), 10)];
                //console.log(deleteRecordData);

                // get 'pk' columns
                for (col_i = 0, col_len = arrPk.length; col_i < col_len; col_i += 1) {
                    strRecord += (strRecord ? '\t' : '');
                    strRecord += GS.encodeForTabDelimited(deleteRecordData[element.internalData.arrColumnNames.indexOf(arrPk[col_i])], element.nullString);
                }

                // get 'hash' columns
                strRecordToHash = '';
                for (col_i = 0, col_len = arrLock.length; col_i < col_len; col_i += 1) {
                    strRecordToHash += (strRecordToHash ? '\t' : '');
                    strTemp = deleteRecordData[element.internalData.arrColumnNames.indexOf(arrLock[col_i])];

                    // I believe that this needs to use the null-string instead of 'NULL'
                    strRecordToHash += (strTemp === 'NULL' ? '' : strTemp);
                }

                strDeleteData += (strRecord + (strRecord ? '\t' : '') + GS.utfSafeMD5(strRecordToHash).toString() + '\n');
                arrSelectRecords[i].classList.add('bg-red');
            }

            strDeleteData = (strRoles + '\n' + strColumns + '\n' + strDeleteData);

            // create delete transaction
            GS.addLoader(element, 'Creating Delete Transaction...');
            GS.requestDeleteFromSocket(
                getSocket(element), strSchema, strObject, strHashColumns, strDeleteData
                , function (data, error, transactionID) {
                    if (error) {
                        getData(element);
                        GS.removeLoader(element);
                        GS.webSocketErrorDialog(data);
                    }
                }
                , function (data, error, transactionID, commitFunction, rollbackFunction) {
                    var arrElements, i, len, templateElement;
                    GS.removeLoader(element);

                    if (!error) {
                        if (data !== 'TRANSACTION COMPLETED') {
                            arrElements = xtag.query(element, '.bg-red');

                            for (i = 0, len = arrElements.length; i < len; i += 1) {
                                arrElements[i].classList.remove('bg-red');
                                arrElements[i].classList.add('bg-amber');
                            }

                        // open confirm message box
                        } else {
                            templateElement = document.createElement('template');
                            templateElement.innerHTML = ml(function () {/*
                                <gs-page>
                                    <gs-header><center><h3>Are you sure...</h3></center></gs-header>
                                    <gs-body padded>
                                        <center>Are you sure you want to delete {{numberofrecords}} records?</center>
                                    </gs-body>
                                    <gs-footer>
                                        <gs-grid>
                                            <gs-block><gs-button dialogclose>No</gs-button></gs-block>
                                            <gs-block><gs-button id="datasheet-focus-me" dialogclose bg-primary tabindex="0">Yes</gs-button></gs-block>
                                        </gs-grid>
                                    </gs-footer>
                                </gs-page>
                            */}).replace(/\{\{numberofrecords\}\}/gi, xtag.query(element, '.bg-amber').length);

                            GS.openDialog(templateElement, function () {
                                document.getElementById('datasheet-focus-me').focus();

                            }, function (event, strAnswer) {
                                if (strAnswer === 'Yes') {
                                    commitFunction();
                                    GS.addLoader(element, 'Commiting Delete Transaction...');
                                } else {
                                    rollbackFunction();
                                    GS.addLoader(element, 'Rolling Back Delete Transaction...');
                                }
                            });
                        }

                    } else {
                        rollbackFunction();
                        getData(element);
                        GS.webSocketErrorDialog(data);
                    }
                }
                // final result callback, because we need to handle the commit/rollback response
                , function (strAnswer, data, error) {
                    var arrElements, i, len;
                    GS.removeLoader(element);

                    if (!error) {
                        if (strAnswer === 'COMMIT') {
                            // remove amber records, because the amber records have now been deleted
                            removeRecords(element, 'bg-amber');

                            // clear internal variables for selection now that the selected records have been deleted,
                            //      because if you try to shift-select to extend the selection and the origin cell has
                            //      been deleted this may cause an error
                            clearSelection(element);

                            // trigger after_delete so that developers can react to a successful delete
                            GS.triggerEvent(element, 'after_delete');

                        } else {
                            // clear bg-amber class and don't add a green fade
                            clearRecordColor(element, 'bg-amber', false);
                        }

                        // update record selector numbers to reflect current record numbers
                        //      because after you delete records there may be a gap in the numbers and that is not acceptable
                        arrElements = xtag.query(element, 'tbody > tr');

                        for (i = 0, len = arrElements.length; i < len; i += 1) {
                            if (!arrElements[i].classList.contains('insert-record')) {
                                arrElements[i].children[0].textContent = (i + 1);
                            }
                        }

                    // if an error occurred
                    } else {
                        // get new data, because after an error we don't know the current state
                        //      of the data so a re-fetch will help mitigate inaccurate data errors
                        getData(element);

                        // open an error dialog so that the user knows there was an error
                        GS.webSocketErrorDialog(data);
                    }
                }
            );
        }
    }

    function insertDialog(element) {
        var templateElement = document.createElement('template'), strAddin;

        // if there is a column attribute on this element: append child column (or column) and
        //      the value to the insert string so that we can have parent-child relationships
        if (element.getAttribute('column') || element.getAttribute('qs')) {
            strAddin =  (
                            element.getAttribute('child-column')
                         || element.getAttribute('column')
                         || element.getAttribute('qs')
                        ) +
                        '=' +
                        element.value;
        }

        templateElement.innerHTML = ml(function () {/*
            <gs-page gs-dynamic>
                <gs-header>
                    <center><h3>Insert</h3></center>
                </gs-header>
                <gs-body padded>
                    <gs-insert id="insert-dialog-content-container" src="{{SRC}}" addin="{{ADDIN}}">{{HTML}}</gs-insert>
                </gs-body>
                <gs-footer>
                    <gs-grid widths="1,1" class="width-2">
                        <gs-block width="1">
                            <gs-button dialogclose>Cancel</gs-button>
                        </gs-block>
                        <gs-block width="1">
                            <gs-button class="dialog-envelope-insert" listen-for-return bg-primary>Ok</gs-button>
                        </gs-block>
                    </gs-grid>
                </gs-footer>
            </gs-page>
        */}).replace('{{HTML}}', element.insertTemplate)
            .replace('{{SRC}}', encodeHTML(element.getAttribute('src')))
            .replace('{{ADDIN}}', encodeHTML(strAddin || ''));

        GS.openDialog(templateElement, function () {
            var dialog = this;

            // if gs-datasheet has sequence attribute: add sequence attribute to gs-insert
            if (element.getAttribute('seq')) {
                document.getElementById('insert-dialog-content-container').setAttribute('seq', element.getAttribute('seq'));
            }

            GS.triggerEvent(element, 'insert_dialog_open');

            xtag.query(dialog, '.dialog-envelope-insert')[0].addEventListener('click', function () {
                var insertContainer = document.getElementById('insert-dialog-content-container');

                insertContainer.submit(function (lastval, jsnRow) {
                    getData(element);
                    GS.triggerEvent(element, 'after_insert');
                    GS.closeDialog(dialog, 'Ok');
                });
            });
        });
    }

    function clearSelection(element) {
        element.savedSelection = [];
        element.savedSelectionCopy = [];
        element.dragOrigin = null;
        element.dragCurrentCell = null;
        element.selectionPreviousOrigin = null;
        element.numberOfSelections = 0;
        element.selectedCells = [];
    }

    function templateRecordsForInsert(element, strRecords, strClasses) {
        var arrRecords, arrCells, i, len, cell_i, cell_len, col_len, strHTML, intRowNumberAdd;

        // calculate the number of cells across
        if (element.getAttribute('cols')) {
            col_len = (element.getAttribute('cols') || '').split(/[\s]*,[\s]*/).length;
        }

        arrRecords = strRecords.split('\n');

        // calculate how much to add to the row numbers
        intRowNumberAdd = xtag.query(element, 'tr:not(.bg-red):not(.insert-record)').length - 1;

        for (i = 1, len = arrRecords.length - 1, strHTML = ''; i < len; i += 1) {
            arrCells = arrRecords[i].split('\t');

            strHTML += '<tr ' + (strClasses ? ' class="' + strClasses + '"' : '');

            for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                strHTML += 'data-' + element.internalData.arrColumnNames[cell_i] +
                                '="' + encodeHTML(GS.decodeFromTabDelimited(arrCells[cell_i], element.nullString)) + '"';
            }

            strHTML += '><th>' + (intRowNumberAdd + (i)) + '</th>';

            for (cell_i = 0, cell_len = (col_len || arrCells.length); cell_i < cell_len; cell_i += 1) {
                strHTML += '<td><textarea rows="1" column="' + element.internalData.arrColumnNames[cell_i] + '">' +
                                encodeHTML(GS.decodeFromTabDelimited(arrCells[cell_i], element.nullString) || '') +
                            '</textarea></td>';
            }

            strHTML += '</tr>';
        }


        //    strHTML = GS.templateWithEnvelopeData(element.tableTemplate.templateHTML, {
        //                        'arr_column': data.arrColumnNames
        //                      , 'dat': element.internalData.arrRecords
        //              }, intStart, element.internalData.arrRecords.length);
        //
        //    strHTML = GS.templateShowSubTemplates(strHTML, element.tableTemplate);
        //
        //trMaker.children[0].classList.add('insert-record');

        return strHTML;
    }

    function handleData(element, data, bolFirstLoad, bolManualRefresh) {
        var strHTML, i, len, cell_i, cell_len, col_len, arrRecords
          , arrCells, disabled, arrColumns, arrElements, tbodyElement
          , trMaker, intStart, bolHeader, strWidth, numberOffset;

        // calculate the number of cells across
        if (element.getAttribute('cols')) {
            //col_len = (element.getAttribute('cols') || '').split(/[\s]*,[\s]*/).length;

            arrColumns = (element.getAttribute('cols') || '').split(/[\s]*,[\s]*/);

            for (i = 0, len = arrColumns.length; i < len; i += 1) {
                arrColumns[i] = data.arrColumnNames.indexOf(arrColumns[i]);
            }
        }

        disabled = element.hasAttribute('disabled') || !element.hasAttribute('pk');

        // if first callback: table and header
        if (data.intCallback === 0) {
            if (!element.hasAttribute('lock')) {
                element.setAttribute('lock', data.arrColumnNames.join(','));
            }
            if (!element.hasAttribute('cols')) {
                element.setAttribute('cols', data.arrColumnNames.join(','));
            }
            if (disabled) {
                element.deleteButton.setAttribute('disabled', '');
            } else {
                element.deleteButton.removeAttribute('disabled');
            }

            element.internalData = {
                'arrColumnNames': data.arrColumnNames || []
              , 'arrColumnTypes': data.arrColumnTypes || []
              , 'arrRecords': []
            };

            if (element.headerTemplateRecord) {
                strHTML = GS.templateWithQuerystring(element.headerTemplateRecord);
                element.scrollContainer.innerHTML = '<table><thead>' + strHTML + '</thead><tbody></tbody></table>';

            } else {
                arrElements = xtag.queryChildren(element.tableTemplateRecord, 'td, th');
                for (i = 0, len = arrElements.length, strHTML = ''; i < len; i += 1) {
                    strHTML += '<th>' + encodeHTML(arrElements[i].getAttribute('heading') || '') + '</th>';

                    bolHeader = Boolean(arrElements[i].hasAttribute('heading') || '') || bolHeader;
                }
                strHTML = '<tr>' + strHTML + '</tr>';

                if (bolHeader) {
                    element.scrollContainer.innerHTML = '<table><thead>' + strHTML + '</thead><tbody></tbody></table>';
                } else {
                    element.scrollContainer.innerHTML = '<table><thead hidden>' + strHTML + '</thead><tbody></tbody></table>';
                }
            }
        }

        // if not last callback: append data to end of table
        if (data.strMessage !== 'TRANSACTION COMPLETED') {
            arrRecords = data.strMessage.split('\n');

            intStart = element.internalData.arrRecords.length;

            for (i = 0, len = arrRecords.length - 1, strHTML = ''; i < len; i += 1) {
                arrCells = arrRecords[i].split('\t');

                for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                    arrCells[cell_i] = GS.decodeFromTabDelimited(arrCells[cell_i], element.nullString);
                }

                element.internalData.arrRecords.push(arrCells);
            }

            if (element.paginated === true && !isNaN(element.getAttribute('offset'))) {
                numberOffset = parseInt(element.getAttribute('offset'), 10);
            } else {
                numberOffset = 0
            }

            strHTML = GS.templateWithEnvelopeData(
                        element.tableTemplate.templateHTML
                      , {
                            'arr_column': data.arrColumnNames
                          , 'dat': element.internalData.arrRecords
                        }
                      , intStart
                      , element.internalData.arrRecords.length
                      , numberOffset);

            strHTML = GS.templateShowSubTemplates(strHTML, element.tableTemplate);

            trMaker = document.createElement('tbody');
            trMaker.innerHTML = strHTML;
            tbodyElement = xtag.query(element.scrollContainer, 'tbody')[0];

            arrElements = xtag.toArray(trMaker.children);
            for (i = 0, len = arrElements.length; i < len; i += 1) {
                tbodyElement.appendChild(arrElements[i]);
            }
            //xtag.query(element.scrollContainer, 'tbody')[0].innerHTML += strHTML;

        // if last callback: insert record
        } else {
            arrElements = xtag.query(element.scrollContainer, 'tbody tr');

            if (arrElements[0] && arrElements[0].children[0].nodeName === 'TH' && !isNaN(arrElements[0].children[0].textContent)) {

                strWidth = (
                                GS.pxToEm(element.hudContainer,
                                    GS.getTextWidth(element.hudContainer,
                                        String(element.internalData.arrRecords.length + 1)
                                    )
                                ) + 1
                            ) + 'em';

                xtag.query(element.scrollContainer, 'thead th')[0].style.width = strWidth;
                xtag.query(element.scrollContainer, 'tbody th')[0].style.width = strWidth;
            }

            if (parseInt((element.getAttribute('limit') || '0'), 10) > arrElements.length) {
                element.pageRightButton.setAttribute('disabled', '');
            } else {
                element.pageRightButton.removeAttribute('disabled');
            }

            //if (element.insertRecordElement) {
            //    trMaker = document.createElement('tbody');
            //    trMaker.innerHTML = element.insertRecordElement.outerHTML;
            //    trMaker.children[0].classList.add('insert-record');
            //    tbodyElement = xtag.query(element.scrollContainer, 'tbody')[0];
            //
            //    //if (tbodyElement.children[0]) {
            //    //    tbodyElement.insertBefore(trMaker.children[0], tbodyElement.children[0]);
            //    //} else {
            //    tbodyElement.appendChild(trMaker.children[0]);
            //    //}
            //}

            arrElements = xtag.query(element.scrollContainer, 'tr');

            if (arrElements[0].parentNode.hasAttribute('hidden')) {
                element.headerContainer.innerHTML = '<table><thead hidden>' + arrElements[0].outerHTML + '</thead></table>';
            } else {
                element.headerContainer.innerHTML = '<table><thead>' + arrElements[0].outerHTML + '</thead></table>';
            }

            element.headerTR = element.headerContainer.children[0].children[0].children[0];

            refreshReflow(element);
            refreshHeight(element);
            synchronize(element, undefined, true, bolManualRefresh);
            synchronizeHeaderWidths(element);
            synchronizeHeaderScroll(element);

            if (bolFirstLoad && element.hasAttribute('scroll-to-bottom')) {
                element.scrollContainer.scrollTop = element.scrollContainer.scrollHeight;
            }

            GS.triggerEvent(element, 'after_select');
        }
    }

    function synchronizeHeaderWidths(element) {
        'use strict';
        var guideTR, targetTR, arrChildren, i, len, subtractPadding;

        targetTR = element.headerTR;
        if (element.scrollContainer) {
            guideTR = xtag.query(element.scrollContainer, 'tr')[0];

            if (guideTR) {
                arrChildren = xtag.toArray(guideTR.children);
                subtractPadding = 0; //GS.emToPx(element.headerContainer, 0.2);

                if (element.scrollContainer.scrollHeight > element.scrollContainer.clientHeight) {
                    element.headerContainer.classList.add('scroll');
                } else {
                    element.headerContainer.classList.remove('scroll');
                }

                for (i = 0, len = arrChildren.length; i < len; i += 1) {
                    targetTR.children[i].style.width = (arrChildren[i].clientWidth - subtractPadding) + 'px';
                }
            }
        }
    }
    function synchronizeHeaderScroll(element) {
        'use strict';
        if (element.headerContainer && element.scrollContainer) {
            if (element.scrollContainer.scrollTop > 0) {
                element.headerContainer.classList.add('shadow');
            } else {
                element.headerContainer.classList.remove('shadow');
            }
            element.headerContainer.scrollLeft = element.scrollContainer.scrollLeft;
        }
    }


    // get return column list
    function getReturn(element) {
        var arrColumns = [], arrSupplementalColumns = [], arrColsAttr, strColumns, arrPK, arrLock, i, len;

        // pk
        arrPK = (element.getAttribute('pk') || '').split(/[\s]*,[\s]*/);

        for (i = 0, len = arrPK.length; i < len; i += 1) {
            if (arrPK[i]) {
                GS.listAdd(arrSupplementalColumns, arrPK[i]);
            }
        }

        // lock
        arrLock = (element.getAttribute('lock') || '').split(/[\s]*,[\s]*/);

        for (i = 0, len = arrLock.length; i < len; i += 1) {
            if (arrLock[i]) {
                GS.listAdd(arrSupplementalColumns, arrLock[i]);
            }
        }

        if (element.internalData && element.internalData.arrColumnNames) {
            for (i = 0, len = element.internalData.arrColumnNames.length; i < len; i += 1) {
                GS.listAdd(arrColumns, element.internalData.arrColumnNames[i]);
            }
        } else if (element.getAttribute('cols')) {
            arrColsAttr = element.getAttribute('cols').split(/[\s]*,[\s]*/);

            for (i = 0, len = arrColsAttr.length; i < len; i += 1) {
                GS.listAdd(arrColumns, arrColsAttr[i]);
            }
        }

        if (arrColumns.length === 0 || (arrColumns.length === 1 && arrColumns[0] === '*')) {
            strColumns = '*';

        } else {
            for (i = 0, len = arrSupplementalColumns.length; i < len; i += 1) {
                GS.listAdd(arrColumns, arrSupplementalColumns[i]);
            }

            strColumns = arrColumns.join('\t');
        }

        return strColumns;
    }

    function valueListToHTML(valueText, fieldDelimiter, recordDelimiter, bolFirstContainsHeadings, quoteCharacter, decodeFunction) {
        var i = 0, len = valueText.length, col_i, col_len,
            arrHeadings = [], arrRecords = [], arrRecord = [],
            bolInQuote = false,
            strCell = '',
            strRecord,
            strHTML = '', strPreviousChar;

        // if there is a recordDelimiter at the beginning: add 1 to "i" to skip over it
        if (valueText[0] === recordDelimiter) {
            i += 1;
        }

        // make sure there is a recordDelimiter at the end
        if (valueText[len - 1] !== recordDelimiter) {
            valueText += recordDelimiter;
            len = valueText.length;
        }

        // looper
        for (; i < len; i += 1) {
            if (valueText[i] === quoteCharacter && bolInQuote === false
                && (
                    strPreviousChar === fieldDelimiter ||
                    strPreviousChar === recordDelimiter ||
                    strPreviousChar === undefined
                )) {
                bolInQuote = true;

            } else if (valueText[i] === quoteCharacter && bolInQuote === true) {
                bolInQuote = false;

            } else if (valueText[i] === fieldDelimiter && bolInQuote === false) {
                arrRecord.push(decodeFunction(strCell, element.nullString));
                strCell = '';

            } else if (valueText[i] === recordDelimiter && bolInQuote === false) {
                arrRecord.push(decodeFunction(strCell, element.nullString));
                strCell = '';

                arrRecords.push(arrRecord);
                arrRecord = [];

            } else {
                strCell += valueText[i];
            }

            strPreviousChar = valueText[i];
        }

        // data structure to html
        for (i = 0, len = arrRecords.length; i < len; i += 1) {
            for (col_i = 0, col_len = arrRecords[i].length, strRecord = ''; col_i < col_len; col_i += 1) {
                strRecord += '<td>' + encodeHTML(arrRecords[i][col_i]) + '</td>';
            }

            strHTML += '<tr>' + strRecord + '</tr>';
        }

        return '<table>' + strHTML + '</table>';
    }

    function quoteIdent(strValue) {
        strValue = strValue || '';

        // if first char is not a lowercase letter or there is a character that is not a lowercase letter, underscore or number
        if (!(/[a-z]/).test(strValue[0]) || (/[^a-z_]/).test(strValue)) {
            strValue = '"' + strValue.replace(/\"/gim, '""') + '"';
        }

        return strValue;
    }

    // disfated's answer at: http://stackoverflow.com/questions/202605/repeat-string-javascript
    function stringRepeat(pattern, count) {
        if (count < 1) return '';
        var result = '';
        while (count > 1) {
            if (count & 1) result += pattern;
            count >>= 1, pattern += pattern;
        }
        return result + pattern;
    }

    function getSocket(element) {
        if (element.getAttribute('socket')) {
            return GS[element.getAttribute('socket')];
        }
        return GS.envSocket;
    }

    function getData(element, refocusSelector, refocusSelection, bolFirstLoad, bolManualRefresh) {
        var strSchema = GS.templateWithQuerystring(element.getAttribute('schema') || '')
          , strObject = GS.templateWithQuerystring(element.getAttribute('object') || '')
          , strReturn = getReturn(element) || ''
          , strWhere  = GS.templateWithQuerystring(element.getAttribute('where')  || '1=1')
          , strOrd    = GS.templateWithQuerystring(element.getAttribute('ord')    || '')
          , strLimit  = GS.templateWithQuerystring(element.getAttribute('limit')  || '')
          , strOffset = GS.templateWithQuerystring(element.getAttribute('offset') || '0')
          , strWhereColumn;

        // add in user where, if any
        if (element.getAttribute('user-where')) {
            strWhere = '(' + element.getAttribute('user-where') + ')' + (strWhere ? ' AND ' + strWhere : '');
        }

        // add in a column or qs where, if any

        // if there is a column attribute on element element: combine the where attribute with a where generated by value
        if ((element.getAttribute('column') || element.getAttribute('qs')) && element.value) {
            strWhereColumn = element.getAttribute('child-column') || element.getAttribute('column') || element.getAttribute('qs');

            if (isNaN(element.value)) {
                strWhere =
                    'CAST(' + strWhereColumn + ' AS ' + GS.database.type.text + ') = ' +
                    'CAST($WhereQUOTE$' + (element.value) + '$WhereQUOTE$ AS ' + GS.database.type.text + ')' +
                    (strWhere !== '' ? ' AND (' + strWhere + ')' : '');
            } else {
                strWhere = strWhereColumn + '=' + (element.value) + (strWhere !== '' ? ' AND (' + strWhere + ')' : '');
            }
        }

        // disabled, hide or not the pageinate buttons
        if (strLimit === '') {
            element.pageLeftButton.setAttribute('hidden', '');
            element.pageRightButton.setAttribute('hidden', '');
        } else if (strOffset === '' || strOffset === '0') {
            element.pageLeftButton.setAttribute('disabled', '');
        }

        GS.addLoader(element, 'Loading...');
        GS.requestSelectFromSocket(
                        getSocket(element), strSchema, strObject, strReturn
                      , strWhere, strOrd, strLimit, strOffset
          , function (data, error) {
                var refocusElement;

                if (!error) {
                    handleData(element, data, bolFirstLoad, bolManualRefresh);

                    if (data.strMessage === 'TRANSACTION COMPLETED') {
                        GS.removeLoader(element);
                    }

                    if (data.strMessage === 'TRANSACTION COMPLETED' && refocusSelector) {
                        refocusElement = xtag.query(element, refocusSelector)[0];

                        if (refocusElement) {
                            refocusElement.focus();

                            if (refocusSelection) {
                                GS.setInputSelection(refocusElement, refocusSelection.start, refocusSelection.end);
                            }
                        }
                    }

                } else {
                    GS.removeLoader(element);
                    if (!element.scrollContainer.innerHTML) {
                        element.scrollContainer.innerHTML = '<' + 'center><h2>Couldn\'t Load Data.</h2></' + 'center>';
                    }
                    GS.webSocketErrorDialog(data);
                }
            }
        );
    }


    function getSelectedCopyHTML(element) {
        var strHTMLCopyString, intFromRecord, intToRecord, intFromCell = 9999999, intToCell = 0
          , i, len, cell_i, cell_len, arrSelected, strCellHTML, arrRecords, arrCells
          , strHTMLRecordString;

        arrSelected = element.selectedCells;

        // loop through the selected cells and create an html string using the text of the cell
        if (arrSelected.length > 0) {
            intFromRecord = arrSelected[0].parentNode.rowIndex;
            intToRecord = arrSelected[arrSelected.length - 1].parentNode.rowIndex + 1;

            for (i = 0, len = arrSelected.length; i < len; i += 1) {
                if (arrSelected[i].cellIndex < intFromCell) {
                    intFromCell = arrSelected[i].cellIndex;
                    intFromCell = (intFromCell === 0 ? 1 : intFromCell);
                }
                if (arrSelected[i].cellIndex + 1 > intToCell) {
                    intToCell = arrSelected[i].cellIndex + 1;
                }
            }

            arrRecords = xtag.query(element, 'tr');
            strHTMLCopyString = '';

            for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
                arrCells = arrRecords[i].children;
                strHTMLRecordString = '';

                if (!arrRecords[i].classList.contains('insert-record')) {
                    for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                        strCellHTML = '';

                        if (arrCells[cell_i].hasAttribute('selected')) {
                            if (arrCells[cell_i].lastElementChild) {
                                strCellHTML = arrCells[cell_i].lastElementChild.textValue ||
                                              arrCells[cell_i].lastElementChild.value ||
                                              (arrCells[cell_i].lastElementChild.checked || '').toString();
                            } else {
                                strCellHTML = arrCells[cell_i].textContent.trim();
                            }

                            strCellHTML = encodeHTML(strCellHTML).replace(/\n/gim, '<br />');
                        }

                        strCellHTML = '<' + 'td rowspan="1" colspan="1">' + (strCellHTML || '') + '</td>'

                        strHTMLRecordString += (cell_i === intFromCell ? '<' + 'tr>' : '');
                        strHTMLRecordString += (strCellHTML || '');
                        strHTMLRecordString += (cell_i === (intToCell - 1) ? '<' + '/tr>' : '');
                    }
                }
                if (strHTMLRecordString.trim()) {
                    strHTMLCopyString += strHTMLRecordString;
                }
            }

            if (strHTMLCopyString) {
                strHTMLCopyString = '<' + 'style>' +
                                        'br { mso-data-placement:same-cell; } ' +
                                        'th, td { white-space: pre-wrap; }' +
                                    '<' + '/style>' +
                                    '<' + 'table border="0" cellpadding="0" cellspacing="0">' + strHTMLCopyString + '<' + '/table>';
            }
        }

        return strHTMLCopyString || '';
    }

    function getSelectedCopyText(element) {
        var strTextCopyString, intFromRecord, intToRecord, intFromCell = 9999999, intToCell = 0,
            i, len, cell_i, cell_len, arrSelected, strCellText, arrRecords, arrCells, arrCellIndexes, strTextRecordString;

        arrSelected = element.selectedCells;

        // loop through the selected cells and create a tsv string using the text of the cell
        if (arrSelected.length > 0) {
            intFromRecord = arrSelected[0].parentNode.rowIndex;
            intToRecord = arrSelected[arrSelected.length - 1].parentNode.rowIndex + 1;

            for (i = 0, len = arrSelected.length; i < len; i += 1) {
                if (arrSelected[i].cellIndex < intFromCell) {
                    intFromCell = arrSelected[i].cellIndex;
                    intFromCell = (intFromCell === 0 ? 1 : intFromCell);
                }
                if (arrSelected[i].cellIndex + 1 > intToCell) {
                    intToCell = arrSelected[i].cellIndex + 1;
                }
            }

            arrRecords = xtag.query(element, 'tr');
            strTextCopyString = '';

            for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
                arrCells = arrRecords[i].children;
                strTextRecordString = '';

                for (cell_i = intFromCell, cell_len = intToCell; cell_i < cell_len; cell_i += 1) {
                    if (!arrCells[cell_i].parentNode.classList.contains('insert-record')) {
                        strCellText = '';

                        if (arrCells[cell_i].hasAttribute('selected')) {
                            if (arrCells[cell_i].lastElementChild) {
                                strCellText = arrCells[cell_i].lastElementChild.textValue ||
                                              arrCells[cell_i].lastElementChild.value ||
                                              (arrCells[cell_i].lastElementChild.checked || '').toString();
                            } else {
                                strCellText = arrCells[cell_i].textContent.trim();
                            }

                            strCellText = strCellText.replace(/\"/gim, '""');
                        }

                        strTextRecordString += (cell_i !== intFromCell ? '\t' : '');
                        strTextRecordString += (strCellText || '');
                    }
                }
                //if (strTextRecordString.trim()) {
                strTextCopyString += strTextRecordString;
                //}
                if (i + 1 !== len) { //&& strTextRecordString.trim()
                    strTextCopyString += '\n';
                }
            }
        }

        return strTextCopyString || '';
    }

    function handleClipboardData(event, strCopyString, strType) {
        var clipboardData = event.clipboardData || window.clipboardData, strMime;

        if (!clipboardData) { return; }
        if (!clipboardData.setData) { return; }

        if (strType === 'text') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = 'Text';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/plain';
            }

        } else if (strType === 'html') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = '';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/html';
            }

        } else {
            throw 'handleClipboardData Error: Type "' + strType + '" not recognized, recognized types are "text" and "html".';
        }

        if (strMime) {
            if (strCopyString && strMime) {
                return clipboardData.setData(strMime, strCopyString) !== false;
            } else {
                return clipboardData.getData(strMime);
            }
        }
    }


    function selectHandler(element, dragOriginCell, dragCurrentCell, dragMode) {
        var arrRecords = xtag.query(element, 'tr'), arrCells = xtag.query(element, 'td, th'),
            dragOriginRecord = dragOriginCell.parentNode,
            dragCurrentRecord = dragCurrentCell.parentNode,
            intStartRecordIndex, intStartCellIndex, intEndRecordIndex, intEndCellIndex,
            i, len, col_i, col_len, selectionIndex;

        // if origin & currentCell are both the top-left cell and the cell is a heading: select all cells
        if (dragOriginRecord.rowIndex === 0 && dragCurrentRecord.rowIndex === 0 &&
            dragOriginCell.cellIndex === 0 && dragCurrentCell.cellIndex === 0) {
            intStartRecordIndex = 0;
            intStartCellIndex = 0;
            intEndRecordIndex = arrRecords.length - 1;
            intEndCellIndex = arrRecords[0].children.length - 1;

        // else if origin is a first th: select the records from origin to currentCell
        } else if (dragOriginCell.cellIndex === 0) {
            intStartRecordIndex = Math.min(dragOriginRecord.rowIndex, dragCurrentRecord.rowIndex);
            intStartCellIndex = 0;
            intEndRecordIndex = Math.max(dragOriginRecord.rowIndex, dragCurrentRecord.rowIndex);
            intEndCellIndex = arrRecords[0].children.length - 1;

        // else if origin is a heading: select the columns from origin to currentCell
        } else if (dragOriginRecord.rowIndex === 0) {
            intStartRecordIndex = 0;
            intStartCellIndex = Math.min(dragOriginCell.cellIndex, dragCurrentCell.cellIndex);
            intEndRecordIndex = arrRecords.length - 1;
            intEndCellIndex = Math.max(dragOriginCell.cellIndex, dragCurrentCell.cellIndex);

        // else select cells from origin to currentCell
        } else {
            intStartRecordIndex = Math.min(dragOriginRecord.rowIndex, dragCurrentRecord.rowIndex);
            intStartCellIndex = Math.min(dragOriginCell.cellIndex, dragCurrentCell.cellIndex);
            intEndRecordIndex = Math.max(dragOriginRecord.rowIndex, dragCurrentRecord.rowIndex);
            intEndCellIndex = Math.max(dragOriginCell.cellIndex, dragCurrentCell.cellIndex);
        }

        element.savedSelection = element.savedSelectionCopy.slice(0);

        if (dragMode === 'select') {
            for (i = intStartRecordIndex, len = intEndRecordIndex + 1; i < len; i += 1) {
                for (col_i = intStartCellIndex, col_len = intEndCellIndex + 1; col_i < col_len; col_i += 1) {
                    if (element.savedSelection.indexOf(i + ',' + col_i) === -1) {
                        element.savedSelection.push(i + ',' + col_i);
                    }
                }
            }

        } else { // implied if: dragMode === 'deselect'
            for (i = intStartRecordIndex, len = intEndRecordIndex + 1; i < len; i += 1) {
                for (col_i = intStartCellIndex, col_len = intEndCellIndex + 1; col_i < col_len; col_i += 1) {
                    selectionIndex = element.savedSelection.indexOf(i + ',' + col_i);

                    if (selectionIndex > -1) {
                        element.savedSelection.splice(selectionIndex, 1);
                    }
                }
            }
        }

        synchronize(element);
    }

    function synchronize(element, bolScroll, bolOnLoad, bolManualRefresh) {
        var arrRecords = xtag.query(element, 'tr'), selectCells = [], i, len,
            arrParts, arrTextareas, focusedElement, recordIndex, cellIndex;

        // selection
        if (element.savedSelection) {
            // loop through savedSelection
            for (i = 0, len = element.savedSelection.length; i < len; i += 1) {
                // any cell position that is in saved selection gets added to the selectCells
                arrParts = element.savedSelection[i].split(',');
                recordIndex = parseInt(arrParts[0], 10);
                cellIndex = parseInt(arrParts[1], 10);

                if (recordIndex < arrRecords.length && cellIndex < arrRecords[0].children.length) {
                    selectCells.push(arrRecords[recordIndex].children[cellIndex]);
                }
            }

            // select cells
            element.selectedCells = selectCells;
        }

        // focus
        if (element.lastFocusedControl) {
            element.lastFocusedControl.focus();
            focusedElement = element.lastFocusedControl;
        } else if (!bolOnLoad || bolManualRefresh) {
            focusedElement = element.copyControl;
            element.copyControl.focus();
        }

        // if there was no control to focus and
        //      there is a selection and
        //      bolScroll is true: scroll to selected
        if (!element.lastFocusedControl && element.selectedCells.length > 0 && bolScroll) {
            GS.scrollIntoView(element.selectedCells[0].parentNode);
        }

        // if there was a control and bolScroll is true: scroll to focused record
        if (focusedElement && bolScroll) {
            GS.scrollIntoView(GS.findParentElement(document.activeElement, 'tr'));
        }

        if (focusedElement && element.lastTextSelection) {
            GS.setInputSelection(focusedElement, element.lastTextSelection.start, element.lastTextSelection.end);
        }
    }

    function clearRecordColor(element, strClass, bolGreenFade) {
        var arrElements = xtag.query(element, 'tr.' + strClass), i, len;

        if (bolGreenFade) {
            for (i = 0, len = arrElements.length; i < len; i += 1) {
                arrElements[i].classList.remove(strClass);
                arrElements[i].classList.add('bg-green-fade');
            }

            setTimeout(function () {
                for (i = 0, len = arrElements.length; i < len; i += 1) {
                    arrElements[i].classList.remove('bg-green-fade');
                }
            }, 1000);

        } else {
            for (i = 0, len = arrElements.length; i < len; i += 1) {
                arrElements[i].classList.remove(strClass);
            }
        }
    }

    function removeRecords(element, strClass) {
        var arrElements = xtag.query(element, 'tr.' + strClass), i, len;

        for (i = 0, len = arrElements.length; i < len; i += 1) {
            arrElements[i].parentNode.removeChild(arrElements[i]);
        }
    }

    function insertRecords(element, strColumns, strInsertData, strLocalData, bolDialog) {
        var strSchema = GS.templateWithQuerystring(element.getAttribute('schema'))
          , strObject = GS.templateWithQuerystring(element.getAttribute('object'))
          , templateElement, strSeq, arrSeq, strPk, arrPk
          , strColumn, arrColumns, i, len, col_i, col_len
          , tbodyElement, arrElements, insertRecord;

        arrSeq = (GS.templateWithQuerystring(element.getAttribute('seq') || '')).split(/[\s]*,[\s]*/);
        arrPk = (GS.templateWithQuerystring(element.getAttribute('pk') || '')).split(/[\s]*,[\s]*/);

        arrColumns = strColumns.split('\t');
        for (i = 0, len = arrColumns.length; i < len; i += 1) {
            strColumn = GS.decodeFromTabDelimited(arrColumns[i], element.nullString);

            if (arrSeq.indexOf(strColumn) > -1) {
                arrSeq[arrSeq.indexOf(strColumn)] = '';
            }
        }

        //console.log(getReturn(element) + '\n' + strLocalData);

        // template local record data
        tbodyElement = document.createElement('tbody');
        tbodyElement.innerHTML = templateRecordsForInsert(element, strColumns + '\n' + strLocalData, 'bg-red');

        // add local records to the table before the insert record
        arrElements = xtag.toArray(tbodyElement.children);
        insertRecord = xtag.query(element, 'tr.insert-record')[0];

        for (i = 0, len = arrElements.length; i < len; i += 1) {
            insertRecord.parentNode.insertBefore(arrElements[i], insertRecord);
        }

        // scroll all the way down
        element.scrollContainer.scrollTop = element.scrollContainer.scrollHeight;

        // get pk and sequence values
        for (i = 0, len = arrPk.length, strPk = ''; i < len; i += 1) {
            strPk += (strPk ? '\t' : '') + GS.encodeForTabDelimited(arrPk[i], element.nullString);
        }

        for (i = 0, len = arrSeq.length, strSeq = ''; i < len; i += 1) {
            if (arrColumns.indexOf(arrPk[i]) > -1) {
                strSeq += (i === 0 ? '' : '\t') + '';
            } else {
                strSeq += (i === 0 ? '' : '\t') + GS.encodeForTabDelimited(arrSeq[i], element.nullString);
            }
        }

        strInsertData = strColumns + '\n' + strInsertData;

        GS.addLoader(element, 'Creating Insert Transaction...');
        GS.requestInsertFromSocket(
            getSocket(element), strSchema, strObject, getReturn(element), strPk, strSeq, strInsertData
            , function (data, error) {
                if (error) {
                    removeRecords(element, 'bg-red');
                    GS.removeLoader(element);
                    GS.webSocketErrorDialog(data);
                }
            }
            , function (data, error, transactionID, commitFunction, rollbackFunction) {
                var tbodyElement, arrElements, arrReplaceElements, i, len, templateElement;

                GS.removeLoader(element);

                if (!error) {
                    if (data !== 'TRANSACTION COMPLETED') {
                        data = getReturn(element) + '\n' + data;

                        // replace red records with amber records
                        tbodyElement = document.createElement('tbody');
                        tbodyElement.innerHTML = templateRecordsForInsert(element, data, 'bg-amber');
                        arrElements = xtag.toArray(tbodyElement.children);
                        arrReplaceElements = xtag.query(element, 'tr.bg-red');

                        for (i = 0, len = arrElements.length; i < len; i += 1) {
                            arrReplaceElements[i].parentNode.replaceChild(arrElements[i], arrReplaceElements[i]);
                        }

                    // open confirm message box
                    } else {
                        if (bolDialog) {
                            templateElement = document.createElement('template');
                            templateElement.innerHTML = ml(function () {/*
                                <gs-page>
                                    <gs-header><center><h3>Are you sure...</h3></center></gs-header>
                                    <gs-body padded>
                                        <center>Are you sure you want create {{numberofrecords}} records?</center>
                                    </gs-body>
                                    <gs-footer>
                                        <gs-grid>
                                            <gs-block><gs-button dialogclose>No</gs-button></gs-block>
                                            <gs-block><gs-button id="datasheet-focus-me" dialogclose bg-primary tabindex="0">Yes</gs-button></gs-block>
                                        </gs-grid>
                                    </gs-footer>
                                </gs-page>
                            */}).replace(/\{\{numberofrecords\}\}/gi, xtag.query(element, '.bg-amber').length);

                            GS.openDialog(templateElement, function () {
                                document.getElementById('datasheet-focus-me').focus();

                            }, function (event, strAnswer) {
                                if (strAnswer === 'Yes') {
                                    commitFunction();
                                    GS.addLoader(element, 'Commiting Insert...');
                                } else {
                                    rollbackFunction();
                                    GS.addLoader(element, 'Rolling Back Insert...');
                                }
                            });
                        } else {
                            commitFunction();
                        }
                    }

                } else {
                    removeRecords(element, 'bg-red');
                    rollbackFunction();
                    GS.webSocketErrorDialog(data);
                }
            }
            , function (strAnswer, data, error) {
                GS.removeLoader(element);

                if (!error) {
                    if (strAnswer === 'COMMIT') {
                        clearRecordColor(element, 'bg-amber', true);
                        GS.triggerEvent(element, 'after_insert');
                    } else {
                        removeRecords(element, 'bg-amber');
                    }
                } else {
                    removeRecords(element, 'bg-red');
                    GS.webSocketErrorDialog(data);
                }
            }
        );
    }


    function refreshRecordsAfterUpdate(element, arrRecordsToUpdate, data) {
        var arrColumns, arrRecords, arrValues, arrElements, arrColumnTypes,
            i, len, record_i, record_len, col_i, col_len, controlElement;

        // if last character is a \n: remove it
        if (data[data.length - 1] === '\n') {
            data = data.substring(0, data.length - 1);
        }

        // split records
        arrRecords = data.split('\n');

        // seperate first record (for column names)
        arrColumns = arrRecords[0].split('\t');
        arrRecords.splice(0, 1);

        // loop through each record
        len = arrRecordsToUpdate.length;
        record_len = arrRecords.length;
        i = 0;
        record_i = 0;
        while (i < len && record_i < record_len) {
            if (arrRecordsToUpdate[i].classList.contains('bg-red') && arrRecords[record_i]) {
                arrRecordsToUpdate[i].classList.remove('bg-red');
                arrRecordsToUpdate[i].classList.add('bg-amber');

                // build json row
                arrValues = arrRecords[record_i].split('\t');
                for (col_i = 0, col_len = arrValues.length; col_i < col_len; col_i += 1) {
                    arrRecordsToUpdate[i].setAttribute('data-' + arrColumns[col_i], GS.decodeFromTabDelimited(arrValues[col_i], element.nullString));

                    controlElement = xtag.query(arrRecordsToUpdate[i], '[column="' + arrColumns[col_i] + '"]')[0];
                    if (controlElement) {
                        controlElement.value = GS.decodeFromTabDelimited(arrValues[col_i], element.nullString);
                    }
                }

                record_i += 1;
            }
            i += 1;
        }
    }

    function updateRecords(element, strHashColumns, strUpdateData, arrUpdateRecords, bolDialog) {
        var strSchema = GS.templateWithQuerystring(element.getAttribute('schema'))
          , strObject = GS.templateWithQuerystring(element.getAttribute('object'))
          , templateElement, i, len, refreshData;

        for (i = 0, len = arrUpdateRecords.length; i < len; i += 1) {
            arrUpdateRecords[i].classList.add('bg-red');
        }

        // create transaction
        GS.addLoader(element, 'Creating Update Transaction...');
        GS.requestUpdateFromSocket(
            getSocket(element), strSchema, strObject, getReturn(element), strHashColumns, strUpdateData
            , function (data, error, transactionID) {
                if (error) {
                    getData(element);
                    GS.removeLoader(element);
                    GS.webSocketErrorDialog(data);
                }
            }
            , function (data, error, transactionID, commitFunction, rollbackFunction) {
                GS.removeLoader(element);
                if (!error) {
                    if (data !== 'TRANSACTION COMPLETED') {
                        refreshData = data;
                        data = getReturn(element) + '\n' + data;

                        // make the records amber and refresh their data
                        refreshRecordsAfterUpdate(element, arrUpdateRecords, data);

                    // open confirm message box
                    } else {
                        if (bolDialog) {
                            templateElement = document.createElement('template');
                            templateElement.innerHTML = ml(function () {/*
                                <gs-page>
                                    <gs-header><center><h3>Are you sure...</h3></center></gs-header>
                                    <gs-body padded>
                                        <center>Are you sure you want to update {{numberofrecords}} records?</center>
                                    </gs-body>
                                    <gs-footer>
                                        <gs-grid>
                                            <gs-block><gs-button dialogclose>No</gs-button></gs-block>
                                            <gs-block><gs-button id="datasheet-focus-me" dialogclose bg-primary tabindex="0">Yes</gs-button></gs-block>
                                        </gs-grid>
                                    </gs-footer>
                                </gs-page>
                            */}).replace(/\{\{numberofrecords\}\}/gi, xtag.query(element, '.bg-amber').length);

                            GS.openDialog(templateElement, function () {
                                document.getElementById('datasheet-focus-me').focus();

                            }, function (event, strAnswer) {
                                if (strAnswer === 'Yes') {
                                    commitFunction();
                                    GS.addLoader(element, 'Commiting Update...');
                                } else {
                                    rollbackFunction();
                                    GS.addLoader(element, 'Rolling Back Update...');
                                }
                            });
                        } else {
                            commitFunction();
                        }
                    }

                } else {
                    rollbackFunction();
                    getData(element);
                    GS.webSocketErrorDialog(data);
                }
            }
            , function (strAnswer, data, error) {
                var arrRecords, arrCells, recordData, recordIndex, i, len, col_i, col_len;

                GS.removeLoader(element);

                if (!error) {
                    if (strAnswer === 'COMMIT') {
                        clearRecordColor(element, 'bg-amber', true);

                        // refresh internal data
                        arrRecords = refreshData.split('\n');

                        for (i = 0, len = arrUpdateRecords.length; i < len; i += 1) {
                            arrCells = arrRecords[i].split('\t');
                            recordIndex = parseInt(arrUpdateRecords[i].getAttribute('data-index'), 10);

                            for (col_i = 0, col_len = arrCells.length; col_i < col_len; col_i += 1) {
                                element.internalData.arrRecords[recordIndex][col_i] = GS.decodeFromTabDelimited(arrCells[col_i], element.nullString)
                            }
                        }
                        GS.triggerEvent(element, 'after_update');

                    } else {
                        getData(element);
                    }
                } else {
                    getData(element);
                    GS.webSocketErrorDialog(data);
                }
            }
        );
    }

    function pasteHandler(element, event) {
        var clipboardData = (event.clipboardData || window.clipboardData)
          , templateElement = document.createElement('template')
          , pasteHTML, pastePlain, arrPasteRecords, arrSelectRecords, arrSetColumns
          , strColumn, strColumns, i, len, col_i, col_len, cell, arrPk, arrLock
          , strRecord, strInsertData, strLocalData, strLeftPad, strRightPad
          , strTemp, strRecordToHash, strHashColumns, strRoles, strUpdateData
          , arrRecords, arrUpdateRecords, arrUpdateColumns, updateRecord
          , updateRecordData, pasteElement;

        if (window.clipboardData) {
            pastePlain = clipboardData.getData('Text');
        } else {
            pasteHTML = clipboardData.getData('text/html');
            pastePlain = clipboardData.getData('Text');
        }

        // if no html: build HTML using plain
        if (!pasteHTML || (pasteHTML.indexOf('<' + 'table') === -1 && pasteHTML.indexOf('<' + 'tr') === -1)) {
            pasteHTML = valueListToHTML(pastePlain, '\t', '\n', false, '"', GS.decodeFromTabDelimited);
        }

        //console.log('HTML:', pasteHTML);
        //console.log('PLAIN:', pastePlain);

        // put HTML into a template element for traversal
        templateElement.innerHTML = pasteHTML;

        arrPasteRecords = xtag.query(xtag.query(templateElement.content, 'table')[0], 'tr');
        arrSelectRecords = element.selectedRecords;

        // if the first record is the header: remove it from the selection
        if (arrSelectRecords[0] && arrSelectRecords[0].parentNode.nodeName === 'THEAD') {
            arrSelectRecords.splice(0, 1);
        }

        if (element.numberOfSelections === 1) {
            arrSetColumns = xtag.query(arrSelectRecords[0], 'td[selected]');

            // if the selection starts on the insert record
            if (arrSelectRecords[0].classList.contains('insert-record')) {
                strColumns = '';
                for (i = 0, len = Math.min(arrSetColumns.length, arrPasteRecords[0].children.length); i < len; i += 1) {
                    strColumn = arrSetColumns[i].children[0].getAttribute('column');
                    strColumns += (strColumns ? '\t' : '') + strColumn;
                }

                // extract data from paste HTML
                strLeftPad = stringRepeat('\t', arrSetColumns[0].cellIndex - 1);
                strRightPad = stringRepeat('\t', (element.internalData.arrColumnNames.length - ((arrSetColumns[0].cellIndex - 1) + arrSetColumns.length)));

                for (i = 0, len = arrPasteRecords.length, strInsertData = '', strLocalData = ''; i < len; i += 1) {
                    for (col_i = 0, col_len = arrSetColumns.length, strRecord = ''; col_i < col_len; col_i += 1) {
                        cell = arrPasteRecords[i].children[col_i];
                        strRecord += (strRecord ? '\t' : '') + GS.encodeForTabDelimited(cell.innerText || cell.textContent, element.nullString);
                    }

                    strInsertData += strRecord + '\n';
                    strLocalData += strLeftPad + strRecord + strRightPad + '\n';
                }

                insertRecords(element, strColumns, strInsertData, strLocalData, (arrPasteRecords.length > 1));

            // else (if the selection starts on an update record)
            } else {
                // if the last record is the insert: remove it from the selection
                if (arrSelectRecords[arrSelectRecords.length - 1].parentNode.nodeName === 'THEAD') {
                    arrSelectRecords.pop();
                }

                arrPk = (GS.templateWithQuerystring(element.getAttribute('pk') || '')).split(/[\s]*,[\s]*/);
                arrLock = (GS.templateWithQuerystring(element.getAttribute('lock') || '')).split(/[\s]*,[\s]*/);

                // gathering update headers
                for (i = 0, len = arrPk.length, strRoles = '', strColumns = ''; i < len; i += 1) {
                    strRoles += (strRoles ? '\t' : '') + 'pk';
                    strColumns += (strColumns ? '\t' : '') + arrPk[i];
                }

                for (i = 0, len = arrLock.length, strHashColumns = ''; i < len; i += 1) {
                    strHashColumns += (strHashColumns ? '\t' : '') + arrLock[i];
                }
                strRoles += (strRoles ? '\t' : '') + 'hash';
                strColumns += (strColumns ? '\t' : '') + 'hash';

                arrUpdateColumns = [];
                for (i = 0, len = Math.min(arrSetColumns.length, arrPasteRecords[0].children.length); i < len; i += 1) {
                    pasteElement = xtag.query(arrSetColumns[i], '[column]')[0];//arrSetColumns[i].children[0];

                    if (pasteElement) {
                        strColumn = pasteElement.getAttribute('column');

                        strRoles += (strRoles ? '\t' : '') + 'set';
                        strColumns += (strColumns ? '\t' : '') + strColumn;

                        arrUpdateColumns.push(strColumn);
                    }
                }

                arrUpdateRecords = [];
                for (i = 0, len = Math.min(arrSelectRecords.length, arrPasteRecords.length), strUpdateData = ''; i < len; i += 1) {
                    strRecord = '';
                    updateRecord = arrSelectRecords[i];
                    updateRecordData = element.internalData.arrRecords[parseInt(updateRecord.getAttribute('data-index'), 10)];

                    // get 'pk' columns
                    for (col_i = 0, col_len = arrPk.length; col_i < col_len; col_i += 1) {
                        strRecord += (strRecord ? '\t' : '');
                        strRecord += GS.encodeForTabDelimited(updateRecordData[element.internalData.arrColumnNames.indexOf(arrPk[col_i])], element.nullString);
                    }

                    // get 'hash' columns
                    strRecordToHash = '';
                    for (col_i = 0, col_len = arrLock.length; col_i < col_len; col_i += 1) {
                        strRecordToHash += (strRecordToHash ? '\t' : '');
                        strTemp = updateRecordData[element.internalData.arrColumnNames.indexOf(arrLock[col_i])];
                        strRecordToHash += (strTemp === 'NULL' ? '' : strTemp);
                    }

                    strRecord += (strRecord ? '\t' : '') + GS.utfSafeMD5(strRecordToHash).toString();

                    // get 'set' columns
                    for (col_i = 0, col_len = arrSetColumns.length; col_i < col_len; col_i += 1) {
                        pasteElement = xtag.query(arrSetColumns[col_i], '[column]')[0];

                        if (pasteElement) {
                            cell = arrPasteRecords[i].children[col_i];
                            strRecord += (strRecord ? '\t' : '') + GS.encodeForTabDelimited(cell.innerText || cell.textContent, element.nullString);
                        }
                    }

                    strUpdateData += strRecord + '\n';
                    arrUpdateRecords.push(arrSelectRecords[i]);
                }

                strUpdateData = (strRoles + '\n' + strColumns + '\n' + strUpdateData);
                updateRecords(element, strHashColumns, strUpdateData, arrUpdateRecords, (arrPasteRecords.length > 1));
            }
        }
    }

    function refreshHeight(element) {
        var intHeight;

        if (element.hasAttribute('expand-to-content') &&
                element.hudContainer &&
                element.scrollContainer &&
                element.scrollContainer.children[0]) {
            element.style.height = '';

            intHeight = (
                            element.hudContainer.scrollHeight +
                            element.scrollContainer.children[0].scrollHeight
                        );

            element.style.height = intHeight + 'px';
            element.style.height = (intHeight + (element.scrollContainer.scrollHeight - element.scrollContainer.clientHeight)) + 'px';
        }
    }

    function refreshReflow(element) {
        var strReflowAt = GS.templateWithQuerystring(element.getAttribute('reflow-at') || ''), intReflowAt, intElementWidth;

        if (strReflowAt) {
            intElementWidth = element.offsetWidth;
            intReflowAt = parseInt(strReflowAt, 10);

            if (intElementWidth < intReflowAt) {
                element.dataContainer.classList.add('grid-reflow');
            } else {
                element.dataContainer.classList.remove('grid-reflow');
            }
        } else {
            element.dataContainer.classList.remove('grid-reflow');
        }
    }


    // clean the slate and set initial html
    function prepareElement(element) {
        var tableTemplateElement, HUDTemplateElement, strHTML, recordElement, insertTemplateElement, arrParts
          , headerRecordElement;
        var i, len, arrElements, arrHeaderElements;
        var tempTemplateElement;

        // default pk and lock
        if (!element.hasAttribute('pk'))   { element.setAttribute('pk',   'id'); }
        if (!element.hasAttribute('lock')) { element.setAttribute('lock', 'change_stamp'); }

        // harvest the templates, error if problems
        tableTemplateElement = xtag.query(element, 'template[for="table"]')[0];
        HUDTemplateElement = xtag.query(element, 'template[for="hud"]')[0];
        insertTemplateElement = xtag.query(element, 'template[for="insert"]')[0];

        if (
            HUDTemplateElement &&
            (
                HUDTemplateElement.innerHTML.indexOf('&gt;') > -1 ||
                HUDTemplateElement.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn('GS-DATASHEET WARNING: &gt; or &lt; detected in HUD template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
        }
        if (
            tableTemplateElement &&
            (
                tableTemplateElement.innerHTML.indexOf('&gt;') > -1 ||
                tableTemplateElement.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn('GS-DATASHEET WARNING: &gt; or &lt; detected in table template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
        }
        if (
            insertTemplateElement &&
            (
                insertTemplateElement.innerHTML.indexOf('&gt;') > -1 ||
                insertTemplateElement.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn('GS-DATASHEET WARNING: &gt; or &lt; detected in insert template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
        }

        if (!tableTemplateElement || tableTemplateElement.nodeName !== 'TEMPLATE') {
            throw 'gs-datasheet error: No table template provided.';
        }

        // V----- cannot do .children on template.content
        //if (tableTemplateElement.content.children[0].nodeName !== 'TABLE') {
        //    throw 'gs-datasheet error: Table is not the first element in the provided table template.';
        //}

        // make header template
        headerRecordElement = xtag.query(tableTemplateElement.content, 'thead tr')[0];
        if (headerRecordElement) {

            arrHeaderElements = xtag.query(headerRecordElement, 'td, th');
            arrElements = xtag.query(tableTemplateElement.content, 'tbody td, tbody th');

            for (i = 0, len = arrHeaderElements.length; i < len; i += 1) {
                if (!arrElements[i].hasAttribute('heading')) {
                    arrElements[i].setAttribute('heading', arrHeaderElements[i].textContent);
                }
            }

            element.headerTemplateRecord = headerRecordElement.outerHTML;
        }

        // make table template
        recordElement = xtag.query(tableTemplateElement.content, 'tbody tr')[0];
        recordElement.setAttribute('data-index', '{{= i }}');
        strHTML = GS.templateColumnToValue(tableTemplateElement.innerHTML);
        tempTemplateElement = document.createElement('template');
        tempTemplateElement.innerHTML = strHTML;
        recordElement = xtag.query(tempTemplateElement.content, 'tbody tr')[0];

        element.tableTemplate = GS.templateHideSubTemplates(recordElement.outerHTML, true);
        element.tableTemplateRecord = recordElement;

        if (insertTemplateElement && insertTemplateElement.innerHTML) {
            element.insertTemplate = insertTemplateElement.innerHTML;
        }

        // split schema and object
        arrParts = GS.templateWithQuerystring(element.getAttribute('src')).split('.');

        element.setAttribute('schema', arrParts[0]);
        element.setAttribute('object', arrParts[1]);

        // replace element inner html and create element variables
        strHTML = ml(function () {/*
            <div class="root" flex-vertical flex-fill>
                <div class="hud-container">
                    <gs-button icon="refresh" remove-right icononly no-focus title="Refresh Data." class="refresh-button"></gs-button>
                    <gs-button icon="times" remove-left icononly no-focus title="Delete Selected Records." class="delete-button"></gs-button>

                    <gs-button icon="plus" icononly no-focus title="Create Record." class="insert-button"></gs-button>

                    <gs-button icon="backward" remove-right icononly no-focus title="Go to previous page." class="paginate-left"></gs-button>
                    <gs-button icon="forward" remove-left icononly no-focus title="Go to next page." class="paginate-right"></gs-button>

                    {{HUDHTML}}

                    <gs-button icon="filter" icononly no-focus title="Edit Filters." class="filter-button" hidden></gs-button>
                    <textarea class="hidden-focus-control">Focus Control</textarea>
                </div>
                <div class="data-container" flex>
                    <div class="data-flex-reset">
                        <div class="scroll-container"></div>
                        <div class="header-container"></div>
                        <div class="insert-container"></div>
                    </div>
                </div>
            </div>
        */});

        if (HUDTemplateElement) {
            strHTML = strHTML.replace(/\{\{HUDHTML\}\}/gi, HUDTemplateElement.innerHTML);
        } else {
            strHTML = strHTML.replace(/\{\{HUDHTML\}\}/gi, '');
        }

        element.innerHTML = strHTML;

        element.root = element.children[0];

        element.hudContainer    = element.root.children[0];
        element.dataContainer   = element.root.children[1];

        element.dataFlexReset   = element.dataContainer.children[0];

        element.scrollContainer = element.dataFlexReset.children[0];
        element.headerContainer = element.dataFlexReset.children[1];
        element.insertContainer = element.dataFlexReset.children[2];

        element.refreshButton   = xtag.queryChildren(element.hudContainer, '.refresh-button')[0];
        element.deleteButton    = xtag.queryChildren(element.hudContainer, '.delete-button')[0];
        element.insertButton    = xtag.queryChildren(element.hudContainer, '.insert-button')[0];
        element.pageLeftButton  = xtag.queryChildren(element.hudContainer, '.paginate-left')[0];
        element.pageRightButton = xtag.queryChildren(element.hudContainer, '.paginate-right')[0];
        element.copyControl     = xtag.queryChildren(element.hudContainer, '.hidden-focus-control')[0];
        element.filterButton    = xtag.queryChildren(element.hudContainer, '.filter-button')[0];

        if (element.hasAttribute('no-huddelete') && element.hasAttribute('no-hudrefresh')) {
            element.hudContainer.removeChild(element.refreshButton);//.setAttribute('hidden', '');
            element.hudContainer.removeChild(element.deleteButton);//.setAttribute('hidden', '');

        } else if (element.hasAttribute('no-huddelete')) {
            element.hudContainer.removeChild(element.deleteButton);//.setAttribute('hidden', '');
            element.refreshButton.removeAttribute('remove-right');

        } else if (element.hasAttribute('no-hudrefresh')) {
            element.hudContainer.removeChild(element.refreshButton);//.setAttribute('hidden', '');
            element.deleteButton.removeAttribute('remove-left');
        }

        if (element.hasAttribute('no-hudpaginate')) {
            element.hudContainer.removeChild(element.pageLeftButton);//.setAttribute('hidden', '');
            element.hudContainer.removeChild(element.pageRightButton);//.setAttribute('hidden', '');
        }

        if (!element.insertTemplate) {
            element.insertButton.setAttribute('hidden', '');
        }
    }

    //function pushReplacePopHandler(element) {
    //    var i, len, arrPopKeys, currentValue, bolRefresh = false, strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //
    //    if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //
    //    if (element.hasAttribute('refresh-on-querystring-values')) {
    //        arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
    //
    //        for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
    //            currentValue = GS.qryGetVal(strQueryString, arrPopKeys[i]);
    //
    //            if (element.popValues[arrPopKeys[i]] !== currentValue) {
    //                bolRefresh = true;
    //            }
    //
    //            element.popValues[arrPopKeys[i]] = currentValue;
    //        }
    //
    //    } else if (element.hasAttribute('refresh-on-querystring-change')) {
    //        bolRefresh = true;
    //    }
    //
    //    if (bolRefresh) {
    //        getData(element);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var arrPopKeys;
        var currentValue;
        var bolRefresh;
        var strOperator;

        if (strQSCol) {
            if (strQSCol.indexOf('=') !== -1) {
                arrAttrParts = strQSCol.split(',');
                i = 0;
                len = arrAttrParts.length;
                while (i < len) {
                    strQSCol = arrAttrParts[i];

                    if (strQSCol.indexOf('!=') !== -1) {
                        strOperator = '!=';
                        arrQSParts = strQSCol.split('!=');
                    } else {
                        strOperator = '=';
                        arrQSParts = strQSCol.split('=');
                    }

                    strQSCol = arrQSParts[0];
                    strQSAttr = arrQSParts[1] || arrQSParts[0];

                    // if the key is not present or we've got the negator: go to the attribute's default or remove it
                    if (strOperator === '!=') {
                        // if the key is not present: add the attribute
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            element.setAttribute(strQSAttr, '');
                        // else: remove the attribute
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    } else {
                        // if the key is not present: go to the attribute's default or remove it
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                            } else {
                                element.removeAttribute(strQSAttr);
                            }
                        // else: set attribute to exact text from QS
                        } else {
                            element.setAttribute(strQSAttr, (
                                GS.qryGetVal(strQS, strQSCol) ||
                                element.internal.defaultAttributes[strQSAttr] ||
                                ''
                            ));
                        }
                    }
                    i += 1;
                }
            } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                strQSValue = GS.qryGetVal(strQS, strQSCol);

                if (element.internal.bolQSFirstRun !== true) {
                    if (strQSValue !== '' || !element.getAttribute('value')) {
                        element.setAttribute('value', strQSValue);
                    }
                } else {
                    element.value = strQSValue;
                }
            }
        }

        // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
        if (element.internal.bolQSFirstRun === true) {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);

                    if (element.popValues[arrPopKeys[i]] !== currentValue) {
                        bolRefresh = true;
                    }

                    element.popValues[arrPopKeys[i]] = currentValue;
                }
            } else if (element.hasAttribute('refresh-on-querystring-change')) {
                bolRefresh = true;
            }

            if (bolRefresh && element.hasAttribute('src')) {
                getData(element);
            } else if (bolRefresh && !element.hasAttribute('src')) {
                console.warn('gs-combo Warning: element has "refresh-on-querystring-values" or "refresh-on-querystring-change", but no "src".', element);
            }
        } else {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                }
            }
        }

        element.internal.bolQSFirstRun = true;
    }


    // bind delegating events
    function bindElement(element) {
        var strQSValue;

        // handle "qs" attribute
        if (element.getAttribute('qs') ||
                element.getAttribute('refresh-on-querystring-values') ||
                element.hasAttribute('refresh-on-querystring-change')) {
            //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
            //
            //if (strQSValue !== '' || !element.getAttribute('value')) {
            //    element.setAttribute('value', strQSValue);
            //}

            element.popValues = {};
            pushReplacePopHandler(element);
            window.addEventListener('pushstate', function () {    pushReplacePopHandler(element); });
            window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
            window.addEventListener('popstate', function () {     pushReplacePopHandler(element); });
        }

        // on focus control: set oldvalue for update
        element.addEventListener('focus', function (event) {
            if (event.target.hasAttribute('column')) {
                event.target.strOldValue = event.target.value;
            }
        }, true);

        if (!evt.touchDevice) {
            // focus copy control
            element.addEventListener('mousedown', function (event) {
                var parentDatasheet = GS.findParentTag(event.target, 'gs-datasheet');

                // we dont want to override the focus if the currently focused
                //      element is inside the gs-datasheet and is capable of being focus
                if (
                    !GS.isElementFocusable(event.target) ||
                    !parentDatasheet ||
                    parentDatasheet.nodeName !== 'GS-DATASHEET'
                ) {
                    element.copyControl.focus();
                }
            });
        }

        // copy
        element.copyControl.addEventListener('copy', function (event) {
            var strTextCopyString, strHTMLCopyString;

            if (document.activeElement.classList.contains('hidden-focus-control') ||
                document.activeElement.selectionStart === document.activeElement.selectionEnd) {

                GS.setInputSelection(document.activeElement, document.activeElement.value.length,
                                            document.activeElement.value.length);

                strTextCopyString = getSelectedCopyText(element);
                strHTMLCopyString = getSelectedCopyHTML(element);

                if (strTextCopyString && strHTMLCopyString) {
                    if (handleClipboardData(event, strTextCopyString, 'text')) {
                        event.preventDefault(event);
                    }
                    if (handleClipboardData(event, strHTMLCopyString, 'html')) {
                        event.preventDefault(event);
                    }
                }

                GS.setInputSelection(document.activeElement, 0, document.activeElement.value.length);
            }
        });

        // focus
        window.addEventListener('focus', function (event) {//element
            if (GS.findParentTag(document.activeElement, 'gs-datasheet') === element) {
                element.lastFocusedControl = document.activeElement;
            } else {
                element.lastFocusedControl = null;
            }
        });//, true

        // paste
        element.addEventListener('paste', function (event) {
            if (document.activeElement === element.copyControl) {
                event.preventDefault();
                pasteHandler(element, event);
            }
        });

        // selection
        if (!evt.touchDevice) {
            element.dragAllowed = false;
            element.numberOfSelections = 0;

            // on mousedown (event delagation style)
            element.addEventListener('mousedown', function (event) {
                var target = GS.findParentElement(event.target, 'th,td'), originalTarget = event.target;

                // if target is a cell: begin selection
                if (target && (target.nodeName === 'TH' || target.nodeName === 'TD')) {
                    if (GS.findParentElement(target, 'div').classList.contains('header-container')) {
                        target = xtag.query(element.scrollContainer, 'th, td')[target.cellIndex];
                        originalTarget = target;
                    }

                    // if shift key is down and there is currently a selection to connect to
                    element.dragOrigin = target;
                    if (event.shiftKey && xtag.query(element, '[selected]').length > 0) {
                        element.dragOrigin = element.selectionPreviousOrigin;
                    }

                    // if ctrl and cmd are not down: deselect all cells
                    if (!event.metaKey && !event.ctrlKey) {
                        element.selectedCells = [];
                        element.savedSelection = [];
                        element.numberOfSelections = 0;
                    }

                    element.savedSelectionCopy = element.savedSelection.slice(0);
                    element.dragAllowed = true;
                    element.dragCurrentCell = target;
                    element.numberOfSelections += 1;

                    element.dragMode = 'select';
                    if (target.hasAttribute('selected')) {
                        element.dragMode = 'deselect';
                    }

                    // if the original target is a cell or if the dragOrigin isn't the target cell or
                    //      if there are already selected cells: blur focused element and prevent default
                    if (originalTarget.nodeName === 'TH' || originalTarget.nodeName === 'TD' ||
                        element.dragOrigin !== target || element.selectedCells.length > 0) {
                        element.lastFocusedControl = null;
                        element.copyControl.focus();
                        GS.triggerEvent(element.copyControl, 'focus');
                        event.preventDefault();
                    }

                    selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                }
            });

            element.addEventListener('mousemove', function (event) {
                var cellFromTarget;

                // if mouse is down
                if (event.which !== 0) {
                    cellFromTarget = GS.findParentElement(event.target, 'th,td');

                    // if selection is allowed at this point and closestCell is different from element.dragCurrentCell
                    if (cellFromTarget && element.dragAllowed && element.dragCurrentCell !== cellFromTarget) {
                        element.lastFocusedControl = null;
                        element.copyControl.focus();
                        GS.triggerEvent(element.copyControl, 'focus');

                        element.dragCurrentCell = cellFromTarget;
                        selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                        event.preventDefault();
                    }
                } else {
                    element.dragAllowed = false;
                    element.selectionPreviousOrigin = element.dragOrigin;
                }
            });

            element.addEventListener('mouseup', function (event) {
                if (element.dragAllowed) {
                    if (document.activeElement === element || document.activeElement === document.body) {
                        element.copyControl.focus();
                        GS.triggerEvent(element.copyControl, 'focus');
                    }
                    element.dragAllowed = false;
                    element.selectionPreviousOrigin = element.dragOrigin;
                }
            });
        }

        if (!element.hasAttribute('no-filter')) {
            // filter edit button
            element.filterButton.addEventListener('click', function () {
                var templateElement = document.createElement('template');

                templateElement.setAttribute('data-max-width', '300px');
                templateElement.setAttribute('data-overlay-close', 'true');

                templateElement.innerHTML = ml(function () {/*
                    <gs-body padded>
                        <label for="memo-datagrid-filters">Filters:</label>
                        <gs-memo id="memo-datagrid-filters" rows="6" no-resize-handle></gs-memo>
                        <br />
                        <gs-grid>
                            <gs-block><gs-button dialogclose remove-right>Cancel</gs-button></gs-block>
                            <gs-block><gs-button dialogclose remove-all style="border-left: 0 none;">Clear Filters</gs-button></gs-block>
                            <gs-block><gs-button dialogclose remove-left style="border-left: 0 none;">Update Filters</gs-button></gs-block>
                        </gs-grid>
                    </gs-body>
                */});

                GS.openDialogToElement(element.filterButton, templateElement, 'down', function () {
                    document.getElementById('memo-datagrid-filters').value = element.getAttribute('user-where').replace(/\sAND\s/gi, '\nAND ');

                }, function (event, strAnswer) {
                    var strValue = document.getElementById('memo-datagrid-filters').value;

                    if (strAnswer === 'Clear Filters' || (strAnswer === 'Update Filters' && strValue.trim() === '')) {
                        element.removeAttribute('user-where');
                        element.filterButton.setAttribute('hidden', '');
                        getData(element);

                    } else if (strAnswer === 'Update Filters') {
                        element.setAttribute('user-where', strValue);
                        getData(element);
                    }
                });
            });

            // filter popup
            var cellFloatingButtonFunction = function (targetCell) {
                var jsnElementPosition = GS.getElementPositionData(targetCell), strHTML;

                // targetCell is a th or if targetCell doesn't have a child with the "column" attribute:
                //      remove the floating button if it exists
                if (targetCell.nodeName === 'TH' || xtag.query(targetCell, '[column]').length === 0) {
                    if (element.cellFloatingButtonContainer && element.cellFloatingButtonContainer.parentNode) {
                        element.cellFloatingButtonContainer.parentNode.removeChild(element.cellFloatingButtonContainer);
                        element.cellFloatingButtonContainer = null;
                    }

                // else: add the floating button
                } else {
                    // if no floating button exists for this grid: create/append/bind one
                    if (!element.cellFloatingButtonContainer || !element.cellFloatingButtonContainer.parentNode) {
                        element.cellFloatingButtonContainer = document.createElement('div');
                        element.cellFloatingButtonContainer.classList.add('floating-button-container');

                        element.cellFloatingButtonContainer.innerHTML =
                                        '<gs-button icononly icon="filter" inline bg-primary no-focus></gs-button>';

                        //element.scrollContainer.appendChild(element.cellFloatingButtonContainer);
                        element.dataFlexReset.appendChild(element.cellFloatingButtonContainer);

                        element.cellFloatingButtonContainer.addEventListener(evt.mousedown, function () {
                            element.cellFloatingButtonContainer.targetControl.bolSubstring =
                                document.activeElement === element.cellFloatingButtonContainer.targetControl;
                        });

                        element.cellFloatingButtonContainer.addEventListener('click', function () {
                            var targetControl = element.cellFloatingButtonContainer.targetControl
                              , jsnSelection, strMatchText = targetControl.value || targetControl.textContent
                              , templateElement = document.createElement('template');

                            //console.log(targetControl, targetControl.value, strMatchText);

                            if (targetControl.nodeName === 'INPUT' || targetControl.nodeName === 'TEXTAREA') {
                                jsnSelection = GS.getInputSelection(element.cellFloatingButtonContainer.targetControl);
                            }

                            if (targetControl.bolSubstring && jsnSelection && jsnSelection.start !== jsnSelection.end) {
                                strMatchText = strMatchText.substring(jsnSelection.start, jsnSelection.end);
                            }

                            templateElement.setAttribute('data-max-width', '250px');
                            templateElement.setAttribute('data-overlay-close', 'true');

                            strHTML = '<gs-body padded>';

                            if (evt.touchDevice) {
                                strHTML += '<gs-button class="text-left" dialogclose>Select Range</gs-button>';
                                strHTML += '<gs-button class="text-left" dialogclose>Select Records</gs-button><hr />';
                            }

                            strHTML +=
                                '<gs-button class="text-left" dialogclose>Equals "<u>{{VALUE}}</u>"</gs-button>' +
                                '<gs-button class="text-left" dialogclose>Doesn\'t Equal "<u>{{VALUE}}</u>"</gs-button>' +
                                '<gs-button class="text-left" dialogclose>Contains "<u>{{VALUE}}</u>"</gs-button>' +
                                '<gs-button class="text-left" dialogclose>Doesn\'t Contain "<u>{{VALUE}}</u>"</gs-button>' +
                                '<gs-button class="text-left" dialogclose>Starts With "<u>{{VALUE}}</u>"</gs-button>' +
                                '<gs-button class="text-left" dialogclose>Ends With "<u>{{VALUE}}</u>"</gs-button>';

                            strHTML += '</gs-body>';

                            strHTML = strHTML.replace(/\{\{VALUE\}\}/gim, encodeHTML(strMatchText));

                            templateElement.innerHTML = strHTML;

                            GS.openDialogToElement(element.cellFloatingButtonContainer, templateElement, 'left', '',
                                                                                            function (event, strAnswer) {
                                var clickFunction
                                  , addUserWhere = function (strNewWhere) {
                                        var strWhere = element.getAttribute('user-where');

                                        strWhere = (strWhere ? (strWhere + ' AND ' + strNewWhere) : strNewWhere);

                                        element.setAttribute('user-where', strWhere);
                                        element.filterButton.removeAttribute('hidden');
                                        getData(element);
                                    }
                                  , control = element.cellFloatingButtonContainer.targetCell.children[0];

                                if (strAnswer === 'Select Range' || strAnswer === 'Select Records') {
                                    if (strAnswer === 'Select Records') {
                                        element.dragOrigin = element.cellFloatingButtonContainer.targetCell.parentNode.children[0];
                                    } else if (strAnswer === 'Select Range') {
                                        element.dragOrigin = element.cellFloatingButtonContainer.targetCell;
                                    }

                                    element.selectedCells = [];
                                    clickFunction = function (event) {
                                        var target;

                                        if (strAnswer === 'Select Records') {
                                            target = GS.findParentElement(event.target, 'tr');
                                            element.dragCurrentCell = target.children[0];

                                        } else if (strAnswer === 'Select Range') {
                                            target = GS.findParentElement(event.target, 'td,th');
                                            element.dragCurrentCell = target;
                                        }

                                        if (target) {
                                            element.selectionPreviousOrigin = element.dragOrigin;
                                            element.savedSelection = [];
                                            element.savedSelectionCopy = [];
                                            element.numberOfSelections = 1;
                                            element.dragMode = 'select';

                                            selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);

                                            document.activeElement.blur();
                                            event.preventDefault();
                                            element.removeEventListener('click', clickFunction, true);
                                        }
                                    };

                                    element.addEventListener('click', clickFunction, true);

                                } else if (strAnswer.indexOf('Equals') === 0) {
                                    addUserWhere('CAST(' + control.getAttribute('column') + 'AS ' + GS.database.type.text + ') ' +
                                                        '= $$' + strMatchText + '$$');

                                } else if (strAnswer.indexOf('Doesn\'t Equal') === 0) {
                                    addUserWhere('CAST(' + control.getAttribute('column') + 'AS ' + GS.database.type.text + ') ' +
                                                        '!= $$' + strMatchText + '$$');

                                } else if (strAnswer.indexOf('Contains') === 0) {
                                    addUserWhere('CAST(' + control.getAttribute('column') + 'AS ' + GS.database.type.text + ') ' +
                                                        'LIKE $$%' + strMatchText + '%$$');

                                } else if (strAnswer.indexOf('Doesn\'t Contain') === 0) {
                                    addUserWhere('CAST(' + control.getAttribute('column') + 'AS ' + GS.database.type.text + ') ' +
                                                        'NOT LIKE $$%' + strMatchText + '%$$');

                                } else if (strAnswer.indexOf('Starts With') === 0) {
                                    addUserWhere('CAST(' + control.getAttribute('column') + 'AS ' + GS.database.type.text + ') ' +
                                                        'LIKE $$' + strMatchText + '%$$');

                                } else if (strAnswer.indexOf('Ends With') === 0) {
                                    addUserWhere('CAST(' + control.getAttribute('column') + 'AS ' + GS.database.type.text + ') ' +
                                                        'LIKE $$%' + strMatchText + '$$');
                                }
                            });
                        });
                    }

                    // hover center next to the cell
                    element.cellFloatingButtonContainer.targetCell = targetCell;
                    element.cellFloatingButtonContainer.targetControl = xtag.query(targetCell, '[column]')[0];
                    element.cellFloatingButtonContainer.children[0].removeAttribute('remove-top-left');
                    element.cellFloatingButtonContainer.children[0].removeAttribute('remove-top-right');
                    element.cellFloatingButtonContainer.children[0].removeAttribute('remove-bottom-left');
                    element.cellFloatingButtonContainer.children[0].removeAttribute('remove-bottom-right');

                    // top left
                    if (jsnElementPosition.intRoomAbove > element.cellFloatingButtonContainer.clientHeight &&
                        jsnElementPosition.intRoomLeft > element.cellFloatingButtonContainer.clientWidth) {
                        element.cellFloatingButtonContainer.setAttribute('style',
                                    'left: ' + ((jsnElementPosition.intElementLeft -
                                                    element.cellFloatingButtonContainer.clientWidth) + 4) + 'px;' +
                                    'top: ' + ((jsnElementPosition.intElementTop -
                                                    element.cellFloatingButtonContainer.clientHeight) + 4) + 'px;');

                        element.cellFloatingButtonContainer.children[0].setAttribute('remove-bottom-right', '');

                    // top right
                    } else if (jsnElementPosition.intRoomAbove > element.cellFloatingButtonContainer.clientHeight &&
                               jsnElementPosition.intRoomRight > element.cellFloatingButtonContainer.clientWidth) {
                        element.cellFloatingButtonContainer.setAttribute('style',
                                    'left: ' + ((jsnElementPosition.intElementLeft +
                                                    jsnElementPosition.intElementWidth) - 4) + 'px;' +
                                    'top: ' + ((jsnElementPosition.intElementTop -
                                                    element.cellFloatingButtonContainer.clientHeight) + 4) + 'px;');

                        element.cellFloatingButtonContainer.children[0].setAttribute('remove-bottom-left', '');

                    // bottom left
                    } else if (jsnElementPosition.intRoomBelow > element.cellFloatingButtonContainer.clientHeight &&
                               jsnElementPosition.intRoomLeft > element.cellFloatingButtonContainer.clientWidth) {
                        element.cellFloatingButtonContainer.setAttribute('style',
                                    'left: ' + ((jsnElementPosition.intElementLeft -
                                                    element.cellFloatingButtonContainer.clientWidth) + 4) + 'px;' +
                                    'top: ' + ((jsnElementPosition.intElementTop +
                                                    jsnElementPosition.intElementHeight) - 4) + 'px;');

                        element.cellFloatingButtonContainer.children[0].setAttribute('remove-top-right', '');

                    // bottom right
                    } else if (jsnElementPosition.intRoomBelow > element.cellFloatingButtonContainer.clientHeight &&
                               jsnElementPosition.intRoomRight > element.cellFloatingButtonContainer.clientWidth) {
                        element.cellFloatingButtonContainer.setAttribute('style',
                                    'left: ' + ((jsnElementPosition.intElementLeft +
                                                    jsnElementPosition.intElementWidth) - 4) + 'px;' +
                                    'top: ' + ((jsnElementPosition.intElementTop +
                                                    jsnElementPosition.intElementHeight) - 4) + 'px;');

                        element.cellFloatingButtonContainer.children[0].setAttribute('remove-top-left', '');
                    }
                }
            };

            element.addEventListener('after_selection', function (event) {
                var arrSelected = element.selectedCells;

                if (arrSelected.length === 1) {
                    cellFloatingButtonFunction(element.dragCurrentCell || arrSelected[arrSelected.length - 1]);

                } else if (element.cellFloatingButtonContainer && element.cellFloatingButtonContainer.parentNode) {
                    element.cellFloatingButtonContainer.parentNode.removeChild(element.cellFloatingButtonContainer);
                    element.cellFloatingButtonContainer = null;
                }
            });

            element.addEventListener('focus', function (event) {
                if (event.target.hasAttribute('column')) {
                    cellFloatingButtonFunction(event.target.parentNode);
                }
            }, true);// this true is for making it so that the focus event (which doesn't bubble) gets captured

            // on mousewheel: remove floating button (scroll version of this is in the handleData function)
            element.addEventListener('mousewheel', function (event) {
                if (element.cellFloatingButtonContainer && element.cellFloatingButtonContainer.parentNode) {
                    element.cellFloatingButtonContainer.parentNode.removeChild(element.cellFloatingButtonContainer);
                    element.cellFloatingButtonContainer = null;
                }
            });
            element.scrollContainer.addEventListener('scroll', function (event) {
                if (element.cellFloatingButtonContainer && element.cellFloatingButtonContainer.parentNode) {
                    element.cellFloatingButtonContainer.parentNode.removeChild(element.cellFloatingButtonContainer);
                    element.cellFloatingButtonContainer = null;
                }
            });
        }

        // ################################################################
        // #################### TOUCH DEVICE CLIPBOARD ####################
        // ################################################################

        if (evt.touchDevice) {
            var rangeFloatingButtonFunction = function (arrSelected) {
                var i, len, targetCell, arrSelectedRecords, bolCenter = true, jsnElementPosition,
                    intTopBoundry, intBottomBoundry, intLeftBoundry, intRightBoundry;

                // if no floating button exists for this grid: create/append/bind one
                if (!element.rangeFloatingButtonContainer || !element.rangeFloatingButtonContainer.parentNode) {
                    element.rangeFloatingButtonContainer = document.createElement('div');
                    element.rangeFloatingButtonContainer.classList.add('floating-button-container');

                    element.rangeFloatingButtonContainer.innerHTML =
                                    '<gs-button icononly icon="clipboard" inline bg-primary no-focus></gs-button>' +
                                    '<div contenteditable="true" style=" position: fixed;  border: 0 none;' +
                                                                        'margin: 0;        padding: 0;' +
                                                                        'z-index: -5000;   opacity: 0.00000001;' +
                                                                        '-webkit-appearance: none;' +
                                                                        '-moz-appearance: none;"></div>';

                    element.scrollContainer.appendChild(element.rangeFloatingButtonContainer);

                    element.rangeFloatingButtonContainer.control = element.rangeFloatingButtonContainer.children[1];

                    element.rangeFloatingButtonContainer.addEventListener('click', function () {
                        element.rangeFloatingButtonContainer.control.innerHTML = getSelectedCopyHTML(element) || 'Nothing To Copy';
                        element.rangeFloatingButtonContainer.control.focus();
                        document.execCommand('selectAll', false, null);
                    });

                    element.rangeFloatingButtonContainer.control.addEventListener('cut', function () {
                        var strSchema = GS.templateWithQuerystring(element.getAttribute('schema'))
                          , strObject = GS.templateWithQuerystring(element.getAttribute('object'))
                          , strUpdateData = '', strRecord, arrSetColumnElements, strHashColumns
                          , arrSetColumns = [], arrPk, arrLock, arrLines, arrRecords, tbodyElement, arrElements
                          , tr_len, i, len, col_i, col_len, colIndex, arrRecordsToRefresh = [], updateFunction
                          , strColumns = '', strRoles = '', strColumn, strRecordToHash, strTemp;

                        // gathering variables for select traversal
                        arrRecords = element.selectedRecords;

                        // if the first record is the header: remove it
                        if (arrRecords[0] && arrRecords[0].parentNode.nodeName === 'THEAD') {
                            arrRecords[0].splice(0, 1);
                        }

                        arrSetColumnElements = xtag.query(arrRecords[0], '[selected]:not(th)');

                        arrPk = (element.getAttribute('pk') || '').split(/[\s]*,[\s]*/);
                        arrLock = (element.getAttribute('lock') || '').split(/[\s]*,[\s]*/);

                        // gathering update headers
                        for (i = 0, len = arrPk.length; i < len; i += 1) {
                            strRoles += (strRoles ? '\t' : '') + 'pk';
                            strColumns += (strColumns ? '\t' : '') + arrPk[i];
                        }

                        for (i = 0, len = arrLock.length, strHashColumns = ''; i < len; i += 1) {
                            strHashColumns += (strHashColumns ? '\t' : '') + arrLock[i];
                        }
                        strRoles += (strRoles ? '\t' : '') + 'hash';
                        strColumns += (strColumns ? '\t' : '') + 'hash';

                        for (i = 0, len = arrSetColumnElements.length; i < len; i += 1) {
                            strColumn = arrSetColumnElements[i].children[0].getAttribute('column');

                            strRoles += (strRoles ? '\t' : '') + 'set';
                            strColumns += (strColumns ? '\t' : '') + strColumn;
                            arrSetColumns.push(strColumn);
                        }

                        for (i = 0, len = arrRecords.length; i < len; i += 1) {
                            strRecord = '';

                            // get 'pk' columns
                            for (col_i = 0, col_len = arrPk.length; col_i < col_len; col_i += 1) {
                                strRecord += (strRecord ? '\t' : '');
                                strRecord += GS.encodeForTabDelimited(arrRecords[i].getAttribute('data-' + arrPk[col_i]), element.nullString);
                            }

                            // get 'hash' columns
                            strRecordToHash = '';
                            for (col_i = 0, col_len = arrLock.length; col_i < col_len; col_i += 1) {
                                strRecordToHash += (strRecordToHash ? '\t' : '');
                                strTemp = arrRecords[i].getAttribute('data-' + arrLock[col_i]);
                                strRecordToHash += (strTemp === 'NULL' ? '' : strTemp);
                            }

                            strRecord += (strRecord ? '\t' : '') + GS.utfSafeMD5(strRecordToHash).toString();

                            // get 'set' columns
                            for (col_i = 0, col_len = arrSetColumns.length; col_i < col_len; col_i += 1) {
                                strRecord += (strRecord ? '\t' : '');
                            }

                            strRecord += '\n';
                            strUpdateData += strRecord;
                            arrRecordsToRefresh.push(arrRecords[i]);

                            // make the records red
                            arrRecords[i].classList.add('bg-red');
                        }

                        strUpdateData = (strRoles + '\n' + strColumns + '\n' + strUpdateData);

                        // create update transaction
                        GS.addLoader(element, 'Creating Update Transaction...');
                        GS.requestUpdateFromSocket(
                            getSocket(element), strSchema, strObject, getReturn(element), strHashColumns, strUpdateData,
                            function (data, error, transactionID) {
                                if (error) {
                                    getData(element);
                                    GS.removeLoader(element);
                                    GS.webSocketErrorDialog(data);
                                }
                            }, function (data, error, transactionID, commitFunction, rollbackFunction) {
                                GS.removeLoader(element);

                                if (!error) {
                                    if (data !== 'TRANSACTION COMPLETED') {
                                        data = getReturn(element) + '\n' + data;

                                        // make the records amber and refresh their data
                                        refreshRecordsAfterUpdate(element, arrRecordsToRefresh, data);////
                                    } else {
                                        commitFunction();
                                    }

                                } else {
                                    rollbackFunction();
                                    getData(element);
                                    GS.webSocketErrorDialog(data);
                                }
                            }, function (strAnswer, data, error) {
                                GS.removeLoader(element);

                                if (!error) {
                                    if (strAnswer === 'COMMIT') {
                                        clearRecordColor(element, 'bg-amber', true);
                                        GS.triggerEvent(element, 'after_update');
                                    } else {
                                        getData(element);
                                    }
                                } else {
                                    getData(element);
                                    GS.webSocketErrorDialog(data);
                                }
                            }
                        );
                    });
                    element.rangeFloatingButtonContainer.control.addEventListener('copy', function (event) {
                        setTimeout(function () {
                            element.rangeFloatingButtonContainer.control.blur();
                            element.rangeFloatingButtonContainer.control.innerHTML = '';
                        }, 1);
                    });
                    element.rangeFloatingButtonContainer.control.addEventListener('paste', function (event) {
                        pasteHandler(element, event);
                        setTimeout(function () {
                            element.rangeFloatingButtonContainer.control.blur();
                            element.rangeFloatingButtonContainer.control.innerHTML = '';
                        }, 1);
                    });
                }

                // position button
                intTopBoundry = 99999999;
                intBottomBoundry = 99999999;
                intLeftBoundry = 99999999;
                intRightBoundry = 99999999;

                for (i = 0, len = arrSelected.length; i < len; i += 1) {
                    jsnElementPosition = GS.getElementPositionData(arrSelected[i]);

                    if (jsnElementPosition.intElementTop < intTopBoundry) {
                        intTopBoundry = jsnElementPosition.intElementTop;
                    }
                    if (jsnElementPosition.intElementBottom < intBottomBoundry) {
                        intBottomBoundry = jsnElementPosition.intElementBottom;
                    }
                    if (jsnElementPosition.intElementLeft < intLeftBoundry) {
                        intLeftBoundry = jsnElementPosition.intElementLeft;
                    }
                    if (jsnElementPosition.intElementRight < intRightBoundry) {
                        intRightBoundry = jsnElementPosition.intElementRight;
                    }
                }

                // top right
                if (intTopBoundry >= 0 && intRightBoundry >= 0) {
                    element.rangeFloatingButtonContainer.style.top = (intTopBoundry + 4) + 'px';
                    element.rangeFloatingButtonContainer.style.right = (intRightBoundry + 4) + 'px';

                // top left
                } else if (intTopBoundry >= 0 && intLeftBoundry >= 0) {
                    element.rangeFloatingButtonContainer.style.top = (intTopBoundry + 4) + 'px';
                    element.rangeFloatingButtonContainer.style.left = (intLeftBoundry + 4) + 'px';

                // bottom right
                } else if (intBottomBoundry >= 0 && intRightBoundry >= 0) {
                    element.rangeFloatingButtonContainer.style.bottom = (intBottomBoundry + 4) + 'px';
                    element.rangeFloatingButtonContainer.style.right = (intRightBoundry + 4) + 'px';

                // bottom left
                } else if (intBottomBoundry >= 0 && intLeftBoundry >= 0) {
                    element.rangeFloatingButtonContainer.style.bottom = (intBottomBoundry + 4) + 'px';
                    element.rangeFloatingButtonContainer.style.left = (intLeftBoundry + 4) + 'px';
                }
            };

            element.addEventListener('after_selection', function (event) {
                var arrSelected = element.selectedCells;

                if (arrSelected.length > 0 && element.numberOfSelections === 1) {
                    rangeFloatingButtonFunction(arrSelected);

                } else if (element.rangeFloatingButtonContainer && element.rangeFloatingButtonContainer.parentNode) {
                    element.rangeFloatingButtonContainer.parentNode.removeChild(element.rangeFloatingButtonContainer);
                    element.rangeFloatingButtonContainer = null;
                }
            });

            element.scrollContainer.addEventListener('scroll', function (event) {
                if (element.rangeFloatingButtonContainer && element.rangeFloatingButtonContainer.parentNode) {
                    element.rangeFloatingButtonContainer.parentNode.removeChild(element.rangeFloatingButtonContainer);
                    element.rangeFloatingButtonContainer = null;
                }
            });
        }

        // ######################################################################################################
        // ######################################################################################################
        // ######################################################################################################

        // delete, refresh, page left and page right buttons
        element.addEventListener('click', function (event) {
            var target = event.target, intOffset, intLimit

            // delete button
            if (target.classList.contains('delete-button')) {
                deleteSelection(element);

            // refresh button
            } else if (target.classList.contains('refresh-button')) {
                getData(element, undefined, undefined, undefined, true);

            // refresh button
            } else if (target.classList.contains('insert-button')) {
                insertDialog(element);

            } else if (target.classList.contains('paginate-left') || target.classList.contains('paginate-right')) {
                intLimit = parseInt(element.getAttribute('limit'), 10);
                intOffset = parseInt(element.getAttribute('offset') || '0', 10);

                if (target.classList.contains('paginate-left')) {
                    intOffset -= intLimit;
                } else {
                    intOffset += intLimit;
                }

                if (intOffset <= 0) {
                    intOffset = 0;
                    element.pageLeftButton.setAttribute('disabled', '');
                } else {
                    element.pageLeftButton.removeAttribute('disabled');
                }

                element.setAttribute('offset', intOffset);
                element.paginated = true;
                getData(element);
            }
        });

        if (!evt.touchDevice) {
            element.addEventListener('keydown', function (event) {
                var intKeyCode = (event.which || event.keyCode);

                if (!element.hasAttribute('no-huddelete')) {
                    if (event.target === element.copyControl && (intKeyCode === KEY_BACKSPACE || intKeyCode === KEY_DELETE)) {
                        deleteSelection(element);
                        event.preventDefault();
                    }
                }
            });
        }

        // manuel update
        var updateFromEntry = function (target) {

            var updateRecord = GS.findParentElement(target, 'tr')
              , updateRecordData = element.internalData.arrRecords[parseInt(updateRecord.getAttribute('data-index'), 10)]
              , arrPk, arrLock, i, len, col_i, col_len, strRoles, strColumns
              , strHashColumns, strRecordToHash, strTemp, strRecord, strUpdateData;

            arrPk = (element.getAttribute('pk') || '').split(/[\s]*,[\s]*/);
            arrLock = (element.getAttribute('lock') || '').split(/[\s]*,[\s]*/);

            // gathering update headers
            for (i = 0, len = arrPk.length, strRoles = '', strColumns = ''; i < len; i += 1) {
                strRoles += (strRoles ? '\t' : '') + 'pk';
                strColumns += (strColumns ? '\t' : '') + arrPk[i];
            }

            for (i = 0, len = arrLock.length, strHashColumns = ''; i < len; i += 1) {
                strHashColumns += (strHashColumns ? '\t' : '') + arrLock[i];
            }
            strRoles += (strRoles ? '\t' : '') + 'hash';
            strColumns += (strColumns ? '\t' : '') + 'hash';

            strRoles += (strRoles ? '\t' : '') + 'set';
            strColumns += (strColumns ? '\t' : '') + target.getAttribute('column');

            // get update data
            strRecord = '';

            // get 'pk' columns
            for (col_i = 0, col_len = arrPk.length; col_i < col_len; col_i += 1) {
                strRecord += (strRecord ? '\t' : '');
                strRecord += GS.encodeForTabDelimited(updateRecordData[element.internalData.arrColumnNames.indexOf(arrPk[col_i])], element.nullString);
            }

            // get 'hash' columns
            strRecordToHash = '';
            for (col_i = 0, col_len = arrLock.length; col_i < col_len; col_i += 1) {
                strRecordToHash += (strRecordToHash ? '\t' : '');
                strTemp = updateRecordData[element.internalData.arrColumnNames.indexOf(arrLock[col_i])];
                strRecordToHash += (strTemp === 'NULL' ? '' : strTemp);
            }

            strRecord += (strRecord ? '\t' : '') + GS.utfSafeMD5(strRecordToHash).toString();

            // get 'set' column
            strRecord += (strRecord ? '\t' : '') + GS.encodeForTabDelimited(target.value, element.nullString);

            strUpdateData = (strRoles + '\n' + strColumns + '\n' + strRecord + '\n');
            updateRecords(element, strHashColumns, strUpdateData, [updateRecord], false);
        };

        element.addEventListener('change', function (event) {
            var target = event.target;

            if (
                target.hasAttribute('column') &&
                !GS.findParentElement(target, 'tr').classList.contains('insert-record') &&
                !event.shiftKey
            ) {
                updateFromEntry(target);
            }
        });

        // manuel insert
        var insertFromInsertRecord = function () {
            var arrElements = xtag.query(element, 'tr.insert-record > td > [column]')
              , i, len, strColumns, strInsertData, strLocalData;

            for (i = 0, len = arrElements.length, strColumns = '', strInsertData = '', strLocalData = ''; i < len; i += 1) {
                strColumns += (strColumns ? '\t' : '') + arrElements[i].getAttribute('column');
                strInsertData += (strInsertData ? '\t' : '') + GS.encodeForTabDelimited(arrElements[i].value || 'NULL', element.nullString);
                strLocalData += (strLocalData ? '\t' : '') + GS.encodeForTabDelimited(arrElements[i].value || '', element.nullString);
                arrElements[i].value = '';
            }

            //console.log('strColumns:    ', strColumns);
            //console.log('strInsertData: ', strInsertData);
            //console.log('strLocalData:  ', strLocalData);

            insertRecords(element, strColumns, strInsertData + '\n', strLocalData + '\n', false);
        };

        element.addEventListener('keydown', function (event) {
            var intKeyCode = (event.which || event.keyCode), target = event.target;

            if (target.hasAttribute('column') && GS.findParentElement(target, 'tr').classList.contains('insert-record') && !event.shiftKey) {
                if (intKeyCode === KEY_RETURN) {
                    insertFromInsertRecord();
                    event.preventDefault();
                }
            }
        });

        // arrow navigation, key selection
        if (!evt.touchDevice) {
            element.addEventListener('keydown', function (event) {
                var intKeyCode = (event.which || event.keyCode)
                  , target = event.target, targetValue = target.value || '', bolNavigateMode = false
                  , parentCell, parentRecord, parentTBody, jsnCursorPos, intCursorPosition, bolSelect
                  , bolFullSelection, bolCursorAtFirst, bolCursorAtTop, bolCursorAtLast, bolCursorAtBottom
                  , arrSelected, arrRecords, focusElement;

                // find out if we are in focus mode
                // if we are in a cell control: we might be in focus mode (we need to check further)
                if ((event.target.nodeName === 'INPUT' || event.target.nodeName === 'TEXTAREA') &&
                    !target.classList.contains('hidden-focus-control')) {
                    jsnCursorPos = GS.getInputSelection(event.target);

                    // if fill text selection and shift is down: not focus mode
                    if (!(jsnCursorPos.start === 0 && jsnCursorPos.end === event.target.value.length && event.shiftKey)) {
                        bolNavigateMode = true;
                    }
                } else if (target.hasAttribute('column')) {
                    jsnCursorPos = {'start': 0, 'end': targetValue.length};
                    if (!event.shiftKey) {
                        bolNavigateMode = true;
                    }
                }

                // if we're in navigate mode: change focused cell
                if (bolNavigateMode) {
                    if (target.nodeName === 'INPUT' || target.nodeName === 'TEXTAREA') {
                        jsnCursorPos = GS.getInputSelection(target);
                    } else {
                        jsnCursorPos = {'start': 0, 'end': targetValue.length};
                    }

                    parentCell = GS.findParentElement(target, 'th,td');
                    parentRecord = parentCell.parentNode;
                    parentTBody = parentRecord.parentNode;

                    bolFullSelection = (jsnCursorPos.start === 0 && jsnCursorPos.end === targetValue.length);

                    // if we don't have a full selection and the selection is one character position
                    if (!bolFullSelection && jsnCursorPos.start === jsnCursorPos.end) {
                        // find out where the cursor is
                        intCursorPosition = jsnCursorPos.start;
                        bolCursorAtFirst = (intCursorPosition === 0);
                        bolCursorAtTop = (intCursorPosition < (targetValue.indexOf('\n') === -1 ?
                                                                    targetValue.length + 1 :
                                                                    targetValue.indexOf('\n') + 1)) ||
                                         (intCursorPosition === 0);
                        bolCursorAtLast = (intCursorPosition === targetValue.length);
                        bolCursorAtBottom = (intCursorPosition > targetValue.lastIndexOf('\n'));
                    }

                    // if left arrow and (full selection or the cursor is at the first character)
                    if (intKeyCode === KEY_LEFT && (bolFullSelection || bolCursorAtFirst)) {
                        if (parentCell.previousElementSibling && parentCell.previousElementSibling.nodeName !== 'TH') {
                            focusElement = parentCell.previousElementSibling;
                            bolSelect = true;

                        } else if (parentRecord.previousElementSibling) {
                            focusElement = parentRecord.previousElementSibling.lastElementChild;
                            bolSelect = true;
                        }

                    // if up arrow and (full selection or the cursor is in the top line)
                    } else if (intKeyCode === KEY_UP && (bolFullSelection || bolCursorAtTop)) {
                        if (parentRecord.previousElementSibling) {
                            focusElement = parentRecord.previousElementSibling.children[parentCell.cellIndex];
                            bolSelect = true;

                        } else if (parentCell.previousElementSibling && parentCell.previousElementSibling.nodeName !== 'TH') {
                            focusElement = parentTBody.lastElementChild.children[parentCell.cellIndex - 1];
                            bolSelect = true;
                        }

                    // if right arrow and (full selection or the cursor is at the last character)
                    } else if (intKeyCode === KEY_RIGHT && (bolFullSelection || bolCursorAtLast)) {
                        if (parentCell.nextElementSibling && parentCell.nextElementSibling.nodeName !== 'TH') {
                            focusElement = parentCell.nextElementSibling;
                            parentCell.nextElementSibling.children[0].focus();
                            bolSelect = true;

                        } else if (parentRecord.nextElementSibling) {
                            focusElement = parentRecord.nextElementSibling.children[1];
                            bolSelect = true;
                        }

                    // if down arrow  and (full selection or the cursor is in the last line)
                    } else if (intKeyCode === KEY_DOWN && (bolFullSelection || bolCursorAtBottom)) {
                        if (parentRecord.nextElementSibling) {
                            focusElement = parentRecord.nextElementSibling.children[parentCell.cellIndex];
                            bolSelect = true;

                        } else if (parentCell.nextElementSibling && parentCell.nextElementSibling.nodeName !== 'TH') {
                            focusElement = parentTBody.firstElementChild.children[parentCell.cellIndex + 1];
                            bolSelect = true;
                        }
                    }

                    // if something was selected
                    if (bolSelect) {
                        // set selected cells
                        element.savedSelection = [];
                        element.savedSelectionCopy = [];
                        element.dragOrigin = GS.findParentElement(focusElement, 'td, th');
                        element.dragCurrentCell = element.dragOrigin;
                        element.selectionPreviousOrigin = element.dragOrigin;
                        element.numberOfSelections = 1;
                        element.dragMode = 'select';

                        selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);

                        // this makes it so that the keyup doesn't happen,
                        //      allowing the new text selection to stay
                        event.preventDefault();
                        event.stopPropagation();
                    }

                    if (focusElement) {
                        focusElement = xtag.query(focusElement, 'input, textarea, select, [tabindex]')[0];
                        if (focusElement) {
                            focusElement.focus();

                            // select all the text and scroll into view
                            if (focusElement !== window) {
                                if (focusElement.nodeName === 'INPUT' || focusElement.nodeName === 'TEXTAREA') {
                                    GS.setInputSelection(focusElement, 0, focusElement.value.length);
                                }
                                parentRecord = GS.findParentTag(focusElement, 'tr');

                                if (parentRecord && parentRecord.nodeName === 'TR') {
                                    GS.scrollIntoView(parentRecord);
                                }
                            }
                        }
                    }

                // else: change selection
                } else if (event.target === element ||
                           event.target.hasAttribute('column') ||
                           event.target.classList.contains('hidden-focus-control')) {

                    // if mouse selection is not happening right now
                    if (!element.dragAllowed) {
                        arrSelected = element.selectedCells;

                        // if the key was tab
                        if (intKeyCode === KEY_TAB) {
                            // if is a selection origin: focus the inner control
                            if (element.dragOrigin) {
                                element.dragOrigin.children[0].focus();

                                // this makes it so that the keyup doesn't happen,
                                //      allowing the new text selection to stay
                                event.preventDefault();
                            }

                        // else if the key was return
                        } else if (intKeyCode === KEY_RETURN) {
                            // if there is only one cell selected: go into the cell control
                            if (arrSelected.length === 1) {
                                arrSelected[0].children[0].focus();
                            } else {
                                element.dragOrigin.children[0].focus();
                            }

                            GS.setInputSelection(document.activeElement, document.activeElement.value.length);
                            GS.scrollIntoView(GS.findParentTag(document.activeElement, 'tr'));

                            // this makes it so that the keyup doesn't happen,
                            //      allowing the new text selection to stay
                            event.preventDefault();

                        // else if an arrow key was pressed
                        } else if (intKeyCode === KEY_UP || intKeyCode === KEY_DOWN || intKeyCode === KEY_LEFT || intKeyCode === KEY_RIGHT) {
                            arrRecords = xtag.query(element, 'tr');
                            element.dragMode = 'select';

                            // if no selection: select first editable cell
                            if (arrSelected.length === 0) {
                                //console.log('2***');
                                element.savedSelection = [];
                                element.savedSelectionCopy = [];
                                element.dragOrigin = xtag.query(element, 'tbody td')[0];
                                element.dragCurrentCell = element.dragOrigin;
                                element.selectionPreviousOrigin = element.dragOrigin;
                                element.numberOfSelections = 1;

                                bolSelect = true;

                            // if shift: expand current selection
                            } else if (event.shiftKey) {
                                //console.log('3***', element.dragCurrentCell);
                                element.dragOrigin = element.selectionPreviousOrigin;
                                parentRecord = element.dragCurrentCell.parentNode;

                                // if left arrow
                                if (intKeyCode === 37 && element.dragCurrentCell.previousElementSibling) {
                                    element.dragCurrentCell = element.dragCurrentCell.previousElementSibling;

                                // if up arrow
                                } else if (intKeyCode === 38 && arrRecords[parentRecord.rowIndex - 1]) {
                                    element.dragCurrentCell = arrRecords[parentRecord.rowIndex - 1]
                                                                    .children[element.dragCurrentCell.cellIndex];

                                // if right arrow
                                } else if (intKeyCode === 39 && element.dragCurrentCell.nextElementSibling) {
                                    element.dragCurrentCell = element.dragCurrentCell.nextElementSibling;

                                // if down arrow
                                } else if (intKeyCode === 40 && arrRecords[parentRecord.rowIndex + 1]) {
                                    element.dragCurrentCell = arrRecords[parentRecord.rowIndex + 1]
                                                                    .children[element.dragCurrentCell.cellIndex];
                                }

                                bolSelect = true;

                            // else: move selected cell based on origin cell
                            } else {
                                //console.log('4***', arrSelected.length);
                                if (arrSelected.length > 1) {
                                    element.dragCurrentCell = element.selectionPreviousOrigin;
                                }

                                parentRecord = element.dragCurrentCell.parentNode;

                                // if left arrow
                                if (intKeyCode === 37 && element.dragCurrentCell.previousElementSibling) {
                                    element.dragCurrentCell = element.dragCurrentCell.previousElementSibling;

                                // if up arrow
                                } else if (intKeyCode === 38 && arrRecords[parentRecord.rowIndex - 1]) {
                                    element.dragCurrentCell = arrRecords[parentRecord.rowIndex - 1]
                                                                    .children[element.dragCurrentCell.cellIndex];

                                // if right arrow
                                } else if (intKeyCode === 39 && element.dragCurrentCell.nextElementSibling) {
                                    element.dragCurrentCell = element.dragCurrentCell.nextElementSibling;

                                // if down arrow
                                } else if (intKeyCode === 40 && arrRecords[parentRecord.rowIndex + 1]) {
                                    element.dragCurrentCell = arrRecords[parentRecord.rowIndex + 1]
                                                                    .children[element.dragCurrentCell.cellIndex];
                                }

                                element.savedSelection = [];
                                element.savedSelectionCopy = [];
                                element.dragOrigin = element.dragCurrentCell;
                                element.selectionPreviousOrigin = element.dragCurrentCell;
                                element.numberOfSelections = 1;

                                bolSelect = true;
                            }

                            // if the above code has produced the info for a selection: call the select handler
                            if (bolSelect) {
                                //console.log('5***', element, element.dragOrigin, element.dragCurrentCell, element.dragMode);

                                element.lastFocusedControl = null;
                                element.copyControl.focus();

                                selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                                GS.scrollIntoView(element.dragCurrentCell.parentNode);
                                event.preventDefault();
                            }
                        }
                    }
                }
            });
        }


        element.addEventListener('mousewheel', function (event) {
            synchronizeHeaderScroll(element);
        });
        element.scrollContainer.addEventListener('scroll', function (event) {
            synchronizeHeaderScroll(element);
        });
        window.addEventListener('resize', function (event) {
            refreshReflow(element);
            refreshHeight(element);
            synchronizeHeaderWidths(element);
        });
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (element.hasAttribute('null-string')) {
                    element.nullString = element.getAttribute('null-string') || '';
                } else {
                    element.nullString = 'NULL';
                }

                prepareElement(element);
                bindElement(element);
                getData(element, '', '', true);
            }
        }
    }

    xtag.register('gs-datasheet', {
        lifecycle: {
            created: function () {},

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;

                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);

                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value' && this.root) {
                        this.refresh();
                    }
                }
            }
        },
        events: {},
        accessors: {
            selectedCells: {

                /*
                    function synchronize(element, bolScroll) {
                        var arrRecords = xtag.query(element, 'tr'), selectCells = [], i, len,
                            arrParts, arrTextareas, focusedElement, recordIndex, cellIndex;

                        // selection
                        if (element.savedSelection) {
                            // loop through savedSelection
                            for (i = 0, len = element.savedSelection.length; i < len; i += 1) {
                                // any cell position that is in saved selection gets added to the selectCells
                                arrParts = element.savedSelection[i].split(',');
                                recordIndex = parseInt(arrParts[0], 10);
                                cellIndex = parseInt(arrParts[1], 10);

                                if (recordIndex < arrRecords.length && cellIndex < arrRecords[0].children.length) {
                                    selectCells.push(arrRecords[recordIndex].children[cellIndex]);
                                }
                            }

                            // select cells
                            element.selectedCells = selectCells;
                        }

                        // focus
                        if (element.lastFocusedControl) {
                            element.lastFocusedControl.focus();
                            focusedElement = element.lastFocusedControl;
                        } else {
                            focusedElement = element.copyControl;
                            focusedElement.focus();
                        }

                        // if there was no control to focus and
                        //      there is a selection and
                        //      bolScroll is true: scroll to selected
                        if (!element.lastFocusedControl && element.selectedCells.length > 0 && bolScroll) {
                            GS.scrollIntoView(element.selectedCells[0].parentNode);
                        }

                        // if there was a control and bolScroll is true: scroll to focused record
                        if (focusedElement && bolScroll) {
                            GS.scrollIntoView(GS.findParentElement(document.activeElement, 'tr'));
                        }

                        if (focusedElement && element.lastTextSelection) {
                            GS.setInputSelection(focusedElement, element.lastTextSelection.start, element.lastTextSelection.end);
                        }
                    }
                    function clearSelection(element) {
                        element.savedSelection = [];
                        element.savedSelectionCopy = [];
                        element.dragOrigin = null;
                        element.dragCurrentCell = null;
                        element.selectionPreviousOrigin = null;
                        element.numberOfSelections = 0;
                        element.selectedCells = [];
                    }
                */

                get: function () {
                    return xtag.query(this.scrollContainer, '[selected]');
                },

                set: function (newValue) {
                    var i, len, intIdIndex, arrCells = xtag.query(this, '[selected]'),
                        cell_i, cell_len, arrRowIndexes = [], arrHeaderIndexes = [],
                        arrRecordSelectors, arrHeaders;

                    // clear old selection
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected');
                    }

                    arrCells = xtag.query(this, '[selected-secondary]');
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected-secondary');
                    }

                    // if newValue is not an array: make it an array
                    if (typeof newValue === 'object' && newValue.length === undefined) {
                        arrCells = [newValue];
                    } else {
                        arrCells = newValue;
                    }

                    // if this call is the result of a javascript ".selectedCells = ARRAY" call and there are more than zero cells to set
                    if (!this.dragAllowed && arrCells.length > 0) {
                        this.dragOrigin = arrCells[0];
                        this.dragCurrentCell = arrCells[arrCells.length - 1];
                    }
                    if (!this.savedSelection) { this.savedSelection = []; }

                    // set new selection
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        GS.listAdd(arrRowIndexes, arrCells[i].parentNode.rowIndex);
                        GS.listAdd(arrHeaderIndexes, arrCells[i].cellIndex);

                        this.savedSelection.push(arrCells[i].parentNode.rowIndex + ',' + arrCells[i].cellIndex);

                        arrCells[i].setAttribute('selected', '');
                    }

                    // highlight non-selected headers and row selectors

                    arrRecordSelectors = xtag.query(this, 'tbody th, thead th:first-child');
                    for (i = 0, len = arrRecordSelectors.length; i < len; i += 1) {
                        if (arrRowIndexes.indexOf(i) !== -1 && !arrRecordSelectors[i].hasAttribute('selected')) {
                            arrRecordSelectors[i].setAttribute('selected-secondary', '');
                        }
                    }

                    arrHeaders = xtag.query(this, 'thead th');
                    for (i = 0, len = arrHeaders.length; i < len; i += 1) {
                        if (arrHeaderIndexes.indexOf(i) !== -1 && !arrHeaders[i].hasAttribute('selected')) {
                            arrHeaders[i].setAttribute('selected-secondary', '');
                        }
                    }

                    //console.log(arrRecordSelectors, arrHeaders, arrRowIndexes, arrHeaderIndexes);

                    GS.triggerEvent(this, 'after_selection');
                }
            },

            selectedRecords: {
                get: function () {
                    var i, len, intRecordIndex = -1, arrRecord = [], selected = this.selectedCells;

                    // loop through the selected cells and create an array of trs
                    for (i = 0, len = selected.length; i < len; i += 1) {
                        if (selected[i].parentNode.rowIndex > intRecordIndex && selected[i].parentNode.parentNode.nodeName !== 'THEAD') {
                            intRecordIndex = selected[i].parentNode.rowIndex;

                            arrRecord.push(selected[i].parentNode);
                        }
                    }

                    return arrRecord;
                },

                set: function (newValue) {
                    var i, len, cell_i, cell_len, intIdIndex, arrCells = this.selectedCells, arrRecords, arrCellChildren;

                    // clear old selection
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected');
                    }

                    arrCells = xtag.query(this, '[selected-secondary]');
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected-secondary');
                    }

                    // if newValue is not an array: make it an array
                    if (typeof newValue === 'object' && newValue.length === undefined) {
                        arrRecords = [newValue];
                    } else {
                        arrRecords = newValue;
                    }

                    // set new selection
                    for (i = 0, len = arrRecords.length, arrCells = []; i < len; i += 1) {
                        arrCellChildren = arrRecords[i].children;

                        for (cell_i = 0, cell_len = arrCellChildren.length; cell_i < cell_len; cell_i += 1) {
                            arrCells.push(arrCellChildren[cell_i]);
                        }
                    }

                    this.selectedCells = arrCells;
                }
            },

            value: {
                get: function () {
                    return this.getAttribute('value');
                },

                set: function (newValue) {
                    return this.setAttribute('value', newValue);
                }
            }
        },
        methods: {
            'refresh': function () {
                getData(this);
            }

          , 'refreshFixedHeader': function () {
                synchronizeHeaderScroll(this);
                synchronizeHeaderWidths(this);
            }

          , 'refreshReflow': function () {
                refreshReflow(this);
            }
        }
    });
});window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('<gs-date>', '<gs-date>', 'gs-date column="${1:name}"></gs-date>');
    registerDesignSnippet('<gs-date> With Label', '<gs-date>', 'label for="${1:date-insert-start_date}">${2:Start Date}:</label>\n' +
                                                               '<gs-date id="${1:date-insert-start_date}" column="${3:start_date}"></gs-date>');

    designRegisterElement('gs-date', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-date.html');

    window.designElementProperty_GSDATE = function(selectedElement) {
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
        });

        //console.log(selectedElement.hasAttribute('mini'));

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        addProp('Date Picker', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-picker')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-picker', (this.value === 'true'), false);
        });

        addProp('Format', true, '<gs-combo class="target" value="' + encodeHTML(selectedElement.getAttribute('format') || '') + '" mini>' +
                        ml(function () {/*<template>
                                            <table>
                                                <tbody>
                                                    <tr value="">
                                                        <td hidden>Default</td>
                                                        <td><center>Default<br /> (01/01/2015)</center></td>
                                                    </tr>
                                                    <tr value="shortdate">
                                                        <td hidden>shortdate</td>
                                                        <td><center>shortdate<br /> (1/1/15)</center></td>
                                                    </tr>
                                                    <tr value="mediumdate">
                                                        <td hidden>mediumdate</td>
                                                        <td><center>mediumdate<br /> (Jan 1, 2015)</center></td>
                                                    </tr>
                                                    <tr value="longdate">
                                                        <td hidden>longdate</td>
                                                        <td><center>longdate<br /> (January 1, 2015)</center></td>
                                                    </tr>
                                                    <tr value="fulldate">
                                                        <td hidden>fulldate</td>
                                                        <td><center>fulldate<br /> (Thursday, January 1, 2015)</center></td>
                                                    </tr>
                                                    <tr value="isodate">
                                                        <td hidden>isodate</td>
                                                        <td><center>isodate<br /> (2015-01-01)</center></td>
                                                    </tr>
                                                    <tr value="isodatetime">
                                                        <td hidden>isodatetime</td>
                                                        <td><center>isodatetime<br /> (2015-01-01T00:00:00)</center></td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </template>
                                    </gs-combo>
                                */}), function () {
            return setOrRemoveTextAttribute(selectedElement, 'format', this.value);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });

        addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        // READONLY attribute
        addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);

        //// SUSPEND-CREATED attribute
        //addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
        //    return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        //});

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var singleLineTemplateElement = document.createElement('template'),
        singleLineTemplate;

    singleLineTemplateElement.innerHTML = '<input class="control" gs-dynamic type="text" />' +
                             '<gs-button class="date-picker-button" gs-dynamic inline icononly icon="calendar" no-focus></gs-button>';

    singleLineTemplate = singleLineTemplateElement.content;

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();

        //console.log('change event triggered');

        GS.triggerEvent(event.target.parentNode, 'change');

        handleFormat(event.target.parentNode, event);
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
        event.target.parentNode.classList.add('focus');
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'blur');
        event.target.parentNode.classList.remove('focus');
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseout);
        event.target.parentNode.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseover);
        event.target.parentNode.classList.add('hover');
    }


    function buttonClickFunction(event) {
        openDatePicker(event.target.parentNode);
    }

    //function pushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //
    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.setAttribute('value', GS.qryGetVal(strQueryString, strQSCol));
    //    }
    //}

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // sync control value and resize to text
    function syncView(element) {
        if (element.control) {
            element.setAttribute('value', element.control.value);
        }
    }

    function openDatePicker(element, dteDate) {
        var divElement = document.createElement('div')
          , jsnOffset = GS.getElementOffset(element.datePickerButton)
          , jsnControlOffset = GS.getElementOffset(element)
          , datePickerContainer, datePicker, strHTML = '', intTop, bolSelectOrigin
          , i, len, dateClickHandler, arrDateButtons, dteCurrent, strInputValue = element.control.value;

        // if there is a day of the week in the value: remove it
        if (strInputValue.match(/monday|tuesday|wednesday|thursday|friday|saturday|sunday/gim)) {
            strInputValue = strInputValue.replace(/monday|tuesday|wednesday|thursday|friday|saturday|sunday/gim, '')
                                         .replace(/  /gim, ' ')
                                         .trim();
        }

        // fix date being off by one day by replacing the dashes with slashes
        strInputValue = strInputValue.replace(/-/, '/')  // replace first dash with forward slash
                                     .replace(/-/, '/'); // replace second dash with forward slash

        dteCurrent = new Date(strInputValue);

        if (isNaN(dteCurrent.getTime())) {
            dteCurrent = new Date();
        }

        element.datePickerButton.setAttribute('selected', '');

        // if no date was sent
        if (!dteDate) {
            // try using the value from the input
            if (element.control.value) {
                dteDate = dteCurrent;
                bolSelectOrigin = true;

            // else just use now
            } else {
                dteDate = new Date();
            }
        }

        //if we are in the current month and year, Highlight the day we are on
        if (dteDate.getMonth() === dteCurrent.getMonth() && dteDate.getFullYear() === dteCurrent.getFullYear()) {
            bolSelectOrigin = true;
        }

        // set html using date
        strHTML = getContentForDatePicker(dteDate, bolSelectOrigin);

        divElement.innerHTML =  '<div class="gs-date-date-picker-container" gs-dynamic>' +
                                    '<div class="gs-date-date-picker" gs-dynamic>' + strHTML + '</div>' +
                                '</div>';

        datePickerContainer = divElement.children[0];
        element.datePickerContainer = datePickerContainer;

        datePicker = datePickerContainer.children[0];

        document.body.appendChild(datePickerContainer);

        // position datePickerContainer
        intTop = jsnOffset.top + element.offsetHeight;

        if (intTop + datePicker.offsetHeight > window.innerHeight) {
            intTop -= datePicker.offsetHeight;
            intTop -= element.offsetHeight;

            if (intTop < 0) {
                intTop = 0;
            }
        }

        datePicker.style.top = intTop + 'px';

        // if window width is wider than 450 pixels width AND the date picker will not fall off of the screen:
        if (window.innerWidth > 450 && jsnOffset.left > 450) {
            // datepicker width: 450px; right: calculated;
            datePicker.style.width = '450px';
            datePicker.style.right = window.innerWidth - (jsnOffset.left + element.datePickerButton.offsetWidth) + 'px';

        // if window width is wider than 450 pixels width AND the date picker will not fall off of the screen:
        } else if (window.innerWidth > 450 && jsnOffset.left <= 450) {
            // datepicker width: 450px; right: calculated;
            datePicker.style.width = '450px';
            datePicker.style.left = jsnControlOffset.left + 'px';

        // else:
        } else {
            // datepicker width: 96%; right: 2%;
            datePicker.style.width = '96%';
            datePicker.style.right = '2%';
        }

        // next month, previous month, next year, previous year click events
        datePickerContainer.getElementsByClassName('prev-month')[0].addEventListener('click', function () {
            dteDate.setMonth((dteDate.getMonth() - 1 < 0 ? 11 : dteDate.getMonth() - 1));
            closeDatePicker(element);
            openDatePicker(element, dteDate);
        });
        datePickerContainer.getElementsByClassName('next-month')[0].addEventListener('click', function () {
            var i, oldMonth;

            oldMonth = dteDate.getMonth();
            dteDate.setMonth((oldMonth + 1 > 11 ? 0 : oldMonth + 1));

            // if a month is skipped (no need to worry about the loop back to january because december and january both seem to have 31 days)
            if (dteDate.getMonth() === oldMonth + 2) {
                // loop backwards until we reach the correct month
                i = 0;
                while (dteDate.getMonth() === oldMonth + 2 && i < 20) {
                    dteDate.setDate(dteDate.getDate() - 1);
                    i += 1;
                }
            }

            closeDatePicker(element);
            openDatePicker(element, dteDate);
        });
        datePickerContainer.getElementsByClassName('prev-year')[0].addEventListener('click', function () {
            dteDate.setFullYear(dteDate.getFullYear() - 1);
            closeDatePicker(element);
            openDatePicker(element, dteDate);
        });
        datePickerContainer.getElementsByClassName('next-year')[0].addEventListener('click', function () {
            dteDate.setFullYear(dteDate.getFullYear() + 1);
            closeDatePicker(element);
            openDatePicker(element, dteDate);
        });

        // background click event
        datePickerContainer.addEventListener('click', function (event) {
            if (event.target.classList.contains('gs-date-date-picker-container')) {
                closeDatePicker(element);
            }
        });

        // date click events
        dateClickHandler = function () {
            var dteNewDate = new Date(this.getAttribute('data-date'));

            closeDatePicker(element);

            element.value = (dteNewDate.getMonth() + 1) + '/' + dteNewDate.getDate() + '/' + dteNewDate.getFullYear();
            //console.trace('test', element.value);
            handleFormat(element);
            xtag.fireEvent(element, 'change', { bubbles: true, cancelable: true });
        };

        arrDateButtons = datePickerContainer.getElementsByClassName('day-marker');

        for (i = 0, len = arrDateButtons.length; i < len; i += 1) {
            arrDateButtons[i].addEventListener('click', dateClickHandler);
        }
    }

    function closeDatePicker(element) {
        element.datePickerButton.removeAttribute('selected');
        document.body.removeChild(element.datePickerContainer);
    }

    function getContentForDatePicker(originDate, bolSelectOrigin) {
        var strHTML = '', i, looperDate, lookaheadDate, intFirstDayOfWeek = 0, dteToday = new Date(),
            arrDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            arrShortDays = ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
            arrMonths = [
                'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
            ];

        looperDate = new Date(originDate);
        looperDate.setDate(1);

        strHTML =   '<div class="month-marker" flex-horizontal gs-dynamic>' +
                        '<gs-button class="prev-month" inline icononly icon="arrow-left" gs-dynamic>Prev</gs-button>' +
                        '<span flex gs-dynamic>' + arrMonths[originDate.getMonth()] + '</span>' +
                        '<gs-button class="next-month" inline icononly icon="arrow-right" gs-dynamic>Next</gs-button>' +
                    '</div>' +
                    '<div class="year-marker" flex-horizontal gs-dynamic>' +
                        '<gs-button class="prev-year" inline icononly icon="arrow-left" gs-dynamic>Prev</gs-button>' +
                        '<span flex gs-dynamic>' + originDate.getFullYear() + '</span>' +
                        '<gs-button class="next-year" inline icononly icon="arrow-right" gs-dynamic>Next</gs-button>' +
                    '</div>';

        if (!isNaN(looperDate.getTime())) {

            // reverse back to the previous intFirstDayOfWeek
            i = 0;
            while (looperDate.getDay() !== intFirstDayOfWeek && i < 20) {
                looperDate.setDate(looperDate.getDate() - 1);

                i += 1;
            }
            //console.log(looperDate);

            // add day of week markers
            strHTML += '<div class="date-picker-divider" gs-dynamic></div><div class="day-of-week-markers-container" gs-dynamic>';
            for (i = 0; i < 7; i += 1) {
                strHTML += '<div class="day-of-week-marker" gs-dynamic>' + arrShortDays[i] + '</div>';
            }
            strHTML += '</div>';

            // loop through till at least the end of the month (or further to find the day that is before the next intFirstDayOfWeek)
            i = 0;

            lookaheadDate = new Date(looperDate);
            lookaheadDate.setDate(lookaheadDate.getDate() + 1);

            while (!(looperDate.getDay()         === intFirstDayOfWeek &&
                    (looperDate.getMonth()       !== originDate.getMonth() && i > 0) &&
                     lookaheadDate.getFullYear() >=  originDate.getFullYear()) &&
                   i < 50) {

                strHTML +=  '<gs-button inline class="day-marker';

                if (looperDate.getMonth() !== originDate.getMonth()) {
                    strHTML += ' other-month';
                }
                if (looperDate.getFullYear() === dteToday.getFullYear() &&
                    looperDate.getMonth() === dteToday.getMonth() &&
                    looperDate.getDate() === dteToday.getDate()) {
                    strHTML += ' today';
                }
                strHTML += '"';

                if (looperDate.getTime() === originDate.getTime() && bolSelectOrigin) {
                    strHTML += ' selected ';
                }

                strHTML +=  'data-date="' + looperDate + '" gs-dynamic>';
                if (looperDate.getFullYear() === dteToday.getFullYear() &&
                    looperDate.getMonth() === dteToday.getMonth() &&
                    looperDate.getDate() === dteToday.getDate()) {
                    strHTML += 'T';
                } else {
                    strHTML += looperDate.getDate();
                }
                strHTML += '</gs-button>';

                //console.log(looperDate, lookaheadDate);

                lookaheadDate.setDate(lookaheadDate.getDate() + 1);
                looperDate.setDate(looperDate.getDate() + 1);
                i += 1;
            }
        }

        return strHTML;
    }

    function handleFormat(element, event, bolAlertOnError) {
        ///console.log(element.value);
        if (element.value) {
            var dteValue, strValueToFormat = element.value, tempSelection = GS.getInputSelection(element.control);

            // if there is a day of the week in the value: remove it
            if (strValueToFormat.match(/monday|tuesday|wednesday|thursday|friday|saturday|sunday/gim)) {
                strValueToFormat = strValueToFormat.replace(/monday|tuesday|wednesday|thursday|friday|saturday|sunday/gim, '')
                                                   .replace(/  /gim, ' ')
                                                   .trim();
            }

            if (strValueToFormat.indexOf(':') !== -1) {
                strValueToFormat = strValueToFormat.substring(0, strValueToFormat.indexOf(':'));
                strValueToFormat = strValueToFormat.substring(0, strValueToFormat.lastIndexOf(' '));
            }

            // if there are only six numbers in the field assume that
            //      the first  two are the month
            //      the second two are the day   and
            //      the third  two are the year  and make a date out of that
            if (strValueToFormat.length === 6 && strValueToFormat.match(/[0-9]/g).join('') === element.value) {
                dteValue = new Date(strValueToFormat.substring(0, 2) + '/' +
                                    strValueToFormat.substring(2, 4) + '/' +
                                    strValueToFormat.substring(4, 6));
            } else {
                //console.log(strValueToFormat.replace(/-/, '/').replace(/-/, '/').replace(/-.*/, ''));
                dteValue = new Date(strValueToFormat.replace(/-/, '/').replace(/-/, '/').replace(/-.*/, ''));
                //console.log(dteValue, dteValue.getFullYear());
            }

            //console.trace('test', element.value, strValueToFormat, dteValue);

            if (isNaN(dteValue.getTime())) {
                if (bolAlertOnError !== undefined && bolAlertOnError !== false) {
                    alert('Invalid Date: ' + element.value);
                }

                if (document.activeElement === element.control) {
                    GS.setInputSelection(element.control, tempSelection.start, tempSelection.end);

                    if (event) {
                        if (event.keyCode === GS.keyCode('backspace')) {
                            GS.setInputSelection(element.control, tempSelection.start - 1, tempSelection.start - 1);
                        } else if (event.keyCode === GS.keyCode('delete')) {
                            GS.setInputSelection(element.control, tempSelection.start, tempSelection.start);
                        }
                        event.stopPropagation();
                        event.preventDefault();
                    }
                }

            } else {
                if (element.control) {
                    element.control.value = formatDate(dteValue, getFormatString(element));
                    if (document.activeElement === element.control) {
                        GS.setInputSelection(element.control, tempSelection.start, tempSelection.end);
                    }
                } else {
                    element.innerHTML = formatDate(dteValue, getFormatString(element));
                }
            }
        } else {
            return 'NULL';
        }
    }

    function getFormatString(element) {
        var strFormat;

        if (element.hasAttribute('format')) {
            strFormat = element.getAttribute('format');
        }

        if (!strFormat) {
            strFormat = 'MM/dd/yyyy';
        } else if (strFormat.toLowerCase() === 'shortdate') {
            strFormat = 'M/d/yy';
        } else if (strFormat.toLowerCase() === 'mediumdate') {
            strFormat = 'MMM d, yyyy';
        } else if (strFormat.toLowerCase() === 'longdate') {
            strFormat = 'MMMM d, yyyy';
        } else if (strFormat.toLowerCase() === 'fulldate') {
            strFormat = 'EEEE, MMMM d, yyyy';
        } else if (strFormat.toLowerCase() === 'shorttime') {
            strFormat = 'h:mm a';
        } else if (strFormat.toLowerCase() === 'mediumtime') {
            strFormat = 'h:mm:ss a';
        } else if (strFormat.toLowerCase() === 'isodate') {
            strFormat = 'yyyy-MM-dd';
        } else if (strFormat.toLowerCase() === 'isotime') {
            strFormat = 'HH:mm:ss';
        } else if (strFormat.toLowerCase() === 'isodatetime') {
            strFormat = 'yyyy-MM-dd\'T\'HH:mm:ss';
        }

        return strFormat;
    }

    function formatDate(dteValue, strFormat) {
        /* (this function contains a (modified) substantial portion of code from another source
            here is the copyright for sake of legality) (Uses code by Matt Kruse)
        Copyright (c) 2006-2009 Rostislav Hristov, Asual DZZD

        Permission is hereby granted, free of charge, to any person obtaining a
        copy of this software and associated documentation files
        (the "Software"), to deal in the Software without restriction,
        including without limitation the rights to use, copy, modify, merge,
        publish, distribute, sublicense, and/or sell copies of the Software,
        and to permit persons to whom the Software is furnished to do so,
        subject to the following conditions:

        The above copyright notice and this permission notice shall be included
        in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/
        var i = 0, j = 0, l = 0, c = '', token = '', x, y, yearLen,
            formatNumber = function (n, s) {
                if (typeof s == 'undefined' || s == 2) {
                  return (n >= 0 && n < 10 ? '0' : '') + n;
                } else {
                    if (n >= 0 && n < 10) {
                       return '00' + n;
                    }
                    if (n >= 10 && n <100) {
                       return '0' + n;
                    }
                    return n;
                }
            },
            locale = {
                monthsFull:   ['January','February','March','April','May','June', 'July','August','September','October','November','December'],
                monthsShort:  ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],
                daysFull:     ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
                daysShort:    ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],
                shortDateFormat: 'M/d/yyyy h:mm a',
                longDateFormat: 'EEEE, MMMM dd, yyyy h:mm:ss a'
            };

        y = dteValue.getFullYear();
        // Nunzio commented this out on Monday, October 19, 2015
        // It was causing an issue during typing in the year field
        /*if (y < 1000) {
            y = String(y + 1900);
        }*/

        var M = dteValue.getMonth() + 1,
            d = dteValue.getDate(),
            E = dteValue.getDay(),
            H = dteValue.getHours(),
            m = dteValue.getMinutes(),
            s = dteValue.getSeconds(),
            S = dteValue.getMilliseconds();

        //console.log(dteValue.getFullYear());

        yearLen = String(y).length;
        dteValue = {
            y: y,
            yyyy: y,
            yy: String(y).substring(yearLen - 2, yearLen),
            M: M,
            MM: formatNumber(M),
            MMM: locale.monthsShort[M-1],
            MMMM: locale.monthsFull[M-1],
            d: d,
            dd: formatNumber(d),
            EEE: locale.daysShort[E],
            EEEE: locale.daysFull[E],
            H: H,
            HH: formatNumber(H)
        };

        //console.log(dteValue);

        if (H === 0) {
            dteValue.h = 12;
        } else if (H > 12) {
            dteValue.h = H - 12;
        } else {
            dteValue.h = H;
        }

        dteValue.hh = formatNumber(dteValue.h);
        dteValue.k = H !== 0 ? H : 24;
        dteValue.kk = formatNumber(dteValue.k);

        if (H > 11) {
            dteValue.K = H - 12;
        } else {
            dteValue.K = H;
        }

        dteValue.KK = formatNumber(dteValue.K);

        if (H > 11) {
            dteValue.a = 'PM';
        } else {
            dteValue.a = 'AM';
        }

        dteValue.m = m;
        dteValue.mm = formatNumber(m);
        dteValue.s = s;
        dteValue.ss = formatNumber(s);
        dteValue.S = S;
        dteValue.SS = formatNumber(S);
        dteValue.SSS = formatNumber(S, 3);

        var result = '';

        i = 0;
        c = '';
        token = '';
        s = false;

        while (i < strFormat.length) {
            token = '';
            c = strFormat.charAt(i);
            if (c == '\'') {
                i++;
                if (strFormat.charAt(i) == c) {
                    result = result + c;
                    i++;
                } else {
                    s = !s;
                }
            } else {
                while (strFormat.charAt(i) == c) {
                    token += strFormat.charAt(i++);
                }
                if (token.indexOf('MMMM') != -1 && token.length > 4) {
                    token = 'MMMM';
                }
                if (token.indexOf('EEEE') != -1 && token.length > 4) {
                    token = 'EEEE';
                }
                if (typeof dteValue[token] != 'undefined' && !s) {
                    result = result + dteValue[token];
                } else {
                    result = result + token;
                }
            }
        }

        return result;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value && new Date(element.value).getTime()) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = undefined;
                //element.value = null;
            }

        }
    }

    //
    function elementInserted(element) {
        console.warn('GS-DATE WARNING: this element is deprecated, please use the gs-datetime instead.');
        var today, strQSValue;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                /*
                element.addEventListener(evt.mouseout, function (event) {
                    element.classList.remove('hover');
                });

                element.addEventListener(evt.mouseover, function (event) {
                    element.classList.add('hover');
                });
                */

                if (element.hasAttribute('tabindex')) {
                    element.oldTabIndex = element.getAttribute('tabindex');
                    element.removeAttribute('tabindex');
                }

                if (element.hasAttribute('value') && element.getAttribute('value').trim().toLowerCase() === 'today') {
                    today = new Date();
                    element.setAttribute('value', GS.leftPad(today.getFullYear(), '0', 4) + '/' + GS.leftPad(today.getMonth() + 1, '0', 2) + '/' + GS.leftPad(today.getDate(), '0', 2));
                }

                // handle "qs" attribute
                if (element.getAttribute('qs')) {
                    //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.setAttribute('value', strQSValue);
                    //}

                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                }

                //if (element.hasAttribute('disabled')) {
                //    element.innerHTML = element.getAttribute('value') || element.getAttribute('placeholder') || '';
                //} else {
                if (!element.hasAttribute('disabled')) {
                    element.innerHTML = '';
                    element.appendChild(singleLineTemplate.cloneNode(true));
                    if (element.oldTabIndex) {
                        xtag.query(element, '.control')[0].setAttribute('tabindex', element.oldTabIndex);
                    }
                }
                //}

                //if (element.innerHTML === '') {
                //    element.appendChild(singleLineTemplate.cloneNode(true));
                //    if (element.oldTabIndex) {
                //        xtag.query(element, '.control')[0].setAttribute('tabindex', element.oldTabIndex);
                //    }
                //}

                element.refresh();
            }
        }
    }

    function getControlState(element) {
        var jsnTextSelection, intStart, intEnd, strFormat = getFormatString(element),
            strValue = element.control.value, delimiter1index, delimiter2index,
            intCurrentSection, strCurrentSection, arrParts, intCurrentSectionSize;

        jsnTextSelection = GS.getInputSelection(element.control);
        intStart = jsnTextSelection.start;
        intEnd = jsnTextSelection.end;
        delimiter1index = (strValue.indexOf('-') === -1 ? strValue.indexOf('/') : strValue.indexOf('-'));
        delimiter2index = (strValue.lastIndexOf('-') === -1 ? strValue.lastIndexOf('/') : strValue.lastIndexOf('-'));
        arrParts = strFormat.split(/[-|/]/g);

        // calculate current section number
        if (intStart > delimiter2index) {
            intCurrentSection = 2;
        } else if (intStart > delimiter1index && intStart <= delimiter2index) {
            intCurrentSection = 1;
        } else {
            intCurrentSection = 0;
        }

        // calculate current part type
        if (arrParts[intCurrentSection].indexOf('y') !== -1) {
            strCurrentSection = 'year';
        } else if (arrParts[intCurrentSection].indexOf('M') !== -1) {
            strCurrentSection = 'month';
        } else {
            strCurrentSection = 'day';
        }

        // calculate current section size
        if (intCurrentSection === 2) {
            intCurrentSectionSize = (strValue.length) - (delimiter2index + 1);
        } else if (intCurrentSection === 1) {
            intCurrentSectionSize = delimiter2index - (delimiter1index + 1);
        } else {
            intCurrentSectionSize = delimiter1index;
        }

        return {
            'jsnTextSelection': jsnTextSelection,
            'intStart': intStart,
            'intEnd': intEnd,
            'strFormat': strFormat,
            'strValue': strValue,
            'delimiter1index': delimiter1index,
            'delimiter2index': delimiter2index,
            'intCurrentSection': intCurrentSection,
            'strCurrentSection': strCurrentSection,
            'arrParts': arrParts,
            'intCurrentSectionSize': intCurrentSectionSize
        };
    }

    xtag.register('gs-date', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'disabled' && newValue !== null) {
                        this.innerHTML = this.getAttribute('value') || this.getAttribute('placeholder');
                    } else if (strAttrName === 'disabled' && newValue === null) {
                        this.innerHTML = '';
                        this.appendChild(singleLineTemplate.cloneNode(true));
                        if (this.oldTabIndex) {
                            xtag.query(this, '.control')[0].setAttribute('tabindex', this.oldTabIndex);
                        }
                        this.refresh();
                    } else if (strAttrName === 'value') {
                        this.value = newValue;
                    }
                }
            }
        },
        events: {
            focus: function (event) {
                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    //console.log('1***', this.control, GS.getInputSelection(this.control));
                }
            },
            click: function (event) {
                var jsnTextSelection, intStart, strFormat, strValue, delimiter1index, delimiter2index;

                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted') && !this.hasAttribute('readonly')) {
                    jsnTextSelection = GS.getInputSelection(this.control);
                    strFormat = getFormatString(this);
                    strValue = this.control.value;

                    // if format is dash delimited or slash delimited and
                    //      we are not on a touch device
                    if ((/^[M|y]{1,}[/|-]{1}[M|d]{1,}[/|-]{1}[d|y]{1,}$/).test(strFormat) &&
                        (strValue.substring(jsnTextSelection.start, jsnTextSelection.end).match(/[-|/]/g) || []).length === 0 &&
                        !evt.touchDevice) {

                        // if there is a date and it's dash or slash delimited: select date part
                        if ((/^[0-9]{1,}[-]{1}[0-9]{1,}[-]{1}[0-9]{1,}$/).test(strValue) ||
                            (/^[0-9]{1,}[/]{1}[0-9]{1,}[/]{1}[0-9]{1,}$/).test(strValue)) {

                            intStart = jsnTextSelection.start;
                            delimiter1index = (strValue.indexOf('-') === -1 ? strValue.indexOf('/') : strValue.indexOf('-'));
                            delimiter2index = (strValue.lastIndexOf('-') === -1 ? strValue.lastIndexOf('/') : strValue.lastIndexOf('-'));

                            // if greater than second delimeter
                            if (intStart > delimiter2index) {
                                //console.log('Section 3');
                                GS.setInputSelection(this.control, delimiter2index + 1, strValue.length);

                            // if in between than first and second delimeter
                            } else if (intStart > delimiter1index && intStart <= delimiter2index) {
                                //console.log('Section 2');
                                GS.setInputSelection(this.control, delimiter1index + 1, delimiter2index);

                            // else
                            } else {
                                //console.log('Section 1');
                                GS.setInputSelection(this.control, 0, delimiter1index);
                            }

                            //console.log(intStart, delimiter1index, delimiter2index);
                        }
                    }
                }
            },
            keydown: function (event) { // tried "input" event
                var jsnTextSelection, intStart, intEnd, strFormat, strValue,
                    intKeyCode = (event.keyCode || event.which), delimiter1index, delimiter2index,
                    intCurrentSection, strCurrentSection, arrParts, dteDate, intCurrentSectionSize,
                    jsnState;

                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted') && !this.hasAttribute('readonly')) {
                    jsnTextSelection = GS.getInputSelection(this.control);
                    strValue = this.control.value;
                    strFormat = getFormatString(this);

                    // if format is dash delimited or slash delimited and
                    //      the selection doesn't encompass a delimeter and
                    //      we are not on a touch device
                    if ((/^[M|y]{1,}[/|-]{1}[M|d]{1,}[/|-]{1}[d|y]{1,}$/).test(strFormat) &&
                        (strValue.substring(jsnTextSelection.start, jsnTextSelection.end).match(/[-|/]/g) || []).length === 0 &&
                        !evt.touchDevice) {

                        // if there is a date and it's dash or slash delimited
                        if ((/^[0-9]{1,}[-]{1}[0-9]{1,}[-]{1}[0-9]{1,}$/).test(strValue) ||
                            (/^[0-9]{1,}[/]{1}[0-9]{1,}[/]{1}[0-9]{1,}$/).test(strValue)) {

                            // if shift, command and option keys are not down
                            if (!event.shiftKey && !event.metaKey && !event.ctrlKey) {
                                event.stopPropagation();

                                jsnState = getControlState(this)
                                jsnTextSelection =      jsnState.jsnTextSelection
                                intStart =              jsnState.intStart
                                intEnd =                jsnState.intEnd
                                strFormat =             jsnState.strFormat
                                strValue =              jsnState.strValue
                                delimiter1index =       jsnState.delimiter1index
                                delimiter2index =       jsnState.delimiter2index
                                intCurrentSection =     jsnState.intCurrentSection
                                strCurrentSection =     jsnState.strCurrentSection
                                arrParts =              jsnState.arrParts
                                intCurrentSectionSize = jsnState.intCurrentSectionSize

                                //// log
                                //console.log('intCurrentSectionSize: ' + intCurrentSectionSize + '\n' +
                                //            'intCurrentSection:     ' + intCurrentSection + '\n' +
                                //            'delimiter1index:       ' + delimiter1index + '\n' +
                                //            'delimiter2index:       ' + delimiter2index + '\n' +
                                //            'strValue.length:       ' + strValue.length + '\n' +
                                //            'strCurrentSection:     ' + strCurrentSection + '\n' +
                                //            'strValue:              ' + strValue + '\n' +
                                //            'Selection Start:       ' + jsnTextSelection.start + '\n' +
                                //            'Selection End:         ' + jsnTextSelection.end);

                                // if number: replace current date part
                                if ((intKeyCode >= 96 && intKeyCode <= 105) || // numpad numbers
                                    (intKeyCode >= 48 && intKeyCode <= 57)) {  // other numbers
                                    this.keyupHandle = true;

                                // if (/|-):
                                } else if (intKeyCode === 111 || intKeyCode === 191 || // "/"
                                           intKeyCode === 109 || intKeyCode === 189) { // "-"
                                    // if first part: go to second part
                                    if (intCurrentSection === 0) {
                                        intCurrentSection = 1;

                                    // if second part: go to third part
                                    } else if (intCurrentSection === 1) {
                                        intCurrentSection = 2;
                                    }

                                // if horizontal arrow: move to a different date part
                                } else if (intKeyCode === 37 || // left arrow
                                           intKeyCode === 39) { // right arrow
                                    //console.log(intCurrentSection, intKeyCode);

                                    if (intCurrentSection === 2 && intKeyCode === 37) {
                                        intCurrentSection = 1;

                                    } else if (intCurrentSection === 1) {
                                        if (intKeyCode === 37) {
                                            intCurrentSection = 0;
                                        } else {
                                            intCurrentSection = 2;
                                        }

                                    } else if (intCurrentSection === 0 && intKeyCode === 39) {
                                        intCurrentSection = 1;
                                    }

                                // if vertical arrow: update current date part
                                } else if (intKeyCode === 38 || // up arrow
                                           intKeyCode === 40) { // down arrow
                                    // If the date is in ISO format, new Date() will create it in GMT then convert it to the local timezone
                                    dteDate = new Date(strValue + ' 00:00:00');

                                    // if current part is year
                                    if (strCurrentSection === 'year') {
                                        //console.log(dteDate, dteDate.getFullYear(), dteDate.getYear(), (intKeyCode === 38 ? 1 : -1),
                                        //                        dteDate.getYear() + (intKeyCode === 38 ? 1 : -1));

                                        // We're using "getFullYear" here instead of "getYear" because "getYear" for some unknown reason
                                        //      worked fine before the 29th of october 2015 (that's the date of discovery anyway) but now
                                        //      throws a number over a thousand years off instead of the actual number.
                                        // Upon looking at the docs, "getYear" is apparently subject to the demons of y2k and no longer
                                        //      supported. Wouldn't it have been better to just make "getYear" do the dame thing as
                                        //      "getFullYear"?
                                        // Still unexplained is why when I tested not more than a week ago it worked without a hitch.
                                        dteDate.setFullYear(dteDate.getFullYear() + (intKeyCode === 38 ? 1 : -1));

                                        //console.log(dteDate);

                                    // if current part is month
                                    } else if (strCurrentSection === 'month') {
                                        dteDate.setMonth(dteDate.getMonth() + (intKeyCode === 38 ? 1 : -1));

                                    // if current part is day
                                    } else if (strCurrentSection === 'day') {
                                        dteDate.setDate(dteDate.getDate() + (intKeyCode === 38 ? 1 : -1));
                                    }

                                    // set the value
                                    strValue = formatDate(dteDate, strFormat);
                                    this.control.value = strValue;
                                    this.triggerChangeManually = true;
                                }

                                if (this.keyupHandle !== true) {
                                    // reset the section selection in case something has changed it
                                    if (intCurrentSection === 2) {
                                        GS.setInputSelection(this.control, delimiter2index + 1, strValue.length);

                                    } else if (intCurrentSection === 1) {
                                        GS.setInputSelection(this.control, delimiter1index + 1, delimiter2index);

                                    } else {
                                        GS.setInputSelection(this.control, 0, delimiter1index);
                                    }
                                }

                                // if not return or tab or number: prevent
                                if (!(intKeyCode >= 96 && intKeyCode <= 105) && // numpad numbers
                                    !(intKeyCode >= 48 && intKeyCode <= 57) &&
                                    intKeyCode !== 13 && // return/enter
                                    intKeyCode !== 9) {  // tab
                                    event.preventDefault();
                                }
                            }
                        }
                    }
                }
            },
            keyup: function (event) {
                var jsnTextSelection, intStart, intEnd, strFormat, strValue,
                    intKeyCode = (event.keyCode || event.which),
                    delimiter1index, delimiter2index, intCurrentSection, strCurrentSection,
                    arrParts, dteDate, intCurrentSectionSize, jsnState;

                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted') && !this.hasAttribute('readonly')) {
                    strFormat = getFormatString(this);

                    // if format is dash delimited or slash delimited and
                    //      keyup has been allowed and
                    //      we are not on a touch device
                    if ((/^[M|y]{1,}[/|-]{1}[M|d]{1,}[/|-]{1}[d|y]{1,}$/).test(strFormat) && this.keyupHandle && !evt.touchDevice) {

                        // if shift, command and option keys are not down
                        if (!event.shiftKey && !event.metaKey && !event.ctrlKey) {
                            jsnState = getControlState(this)
                            jsnTextSelection =      jsnState.jsnTextSelection
                            intStart =              jsnState.intStart
                            intEnd =                jsnState.intEnd
                            strFormat =             jsnState.strFormat
                            strValue =              jsnState.strValue
                            delimiter1index =       jsnState.delimiter1index
                            delimiter2index =       jsnState.delimiter2index
                            intCurrentSection =     jsnState.intCurrentSection
                            strCurrentSection =     jsnState.strCurrentSection
                            arrParts =              jsnState.arrParts
                            intCurrentSectionSize = jsnState.intCurrentSectionSize

                            //// log
                            //console.log('intCurrentSectionSize: ' + intCurrentSectionSize + '\n' +
                            //            'intCurrentSection:     ' + intCurrentSection + '\n' +
                            //            'delimiter1index:       ' + delimiter1index + '\n' +
                            //            'delimiter2index:       ' + delimiter2index + '\n' +
                            //            'strValue.length:       ' + strValue.length + '\n' +
                            //            'strCurrentSection:     ' + strCurrentSection + '\n' +
                            //            'strValue:              ' + strValue + '\n' +
                            //            'strFormat:             ' + strFormat);

                            if ((strCurrentSection === 'day' && intCurrentSectionSize === 2) ||
                                (strCurrentSection === 'month' && intCurrentSectionSize === 2) ||
                                (strCurrentSection === 'year' && intCurrentSectionSize === strFormat.match(/y/g).length)) {

                                if (intCurrentSection === 2) {
                                    GS.setInputSelection(this.control, delimiter2index + 1, strValue.length);

                                } else if (intCurrentSection === 1) {
                                    GS.setInputSelection(this.control, delimiter1index + 1, delimiter2index);

                                } else {
                                    GS.setInputSelection(this.control, 0, delimiter1index);
                                }
                            }
                        }
                    }
                    this.keyupHandle = false;

                    //console.log(intKeyCode);
                    if (intKeyCode === 13 && this.triggerChangeManually) {
                        this.triggerChangeManually = false;
                        GS.triggerEvent(this, 'change');
                    }
                }
            },
            focusout: function () {
                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    //console.log(this.triggerChangeManually);
                    if (this.triggerChangeManually) {
                        this.triggerChangeManually = false;
                        GS.triggerEvent(this, 'change');
                    }
                }
            }


            /*// on keydown and keyup sync the value attribute and the control value
            keydown: function (event) {
                var element = this, currentDate, currentSelectionRange, currentSelectionText, currentSelectionNumber, currentSelectionFormatText,
                    currentValue, newValue, strDateFormat, formatDivider, arrMatch, currentFieldRange, newCursorPos, newFieldValue,
                    daysOfTheWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                    monthsOfTheYear = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                    strKeyCode = event.keyCode.toString();

                currentSelectionRange = GS.getInputSelection(element.control);

                if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (element.getAttribute('disabled') !== null && event.keyCode !== 9) {
                        event.preventDefault();
                        event.stopPropagation();
                    } else {
                        //console.log(strKeyCode === GS.keyCode('left arrow')  , GS.keyCode('left arrow') );
                        //console.log(strKeyCode === GS.keyCode('up arrow')    , GS.keyCode('up arrow'));
                        //console.log(strKeyCode === GS.keyCode('right arrow') , GS.keyCode('right arrow'));
                        //console.log(strKeyCode === GS.keyCode('down arrow')  , GS.keyCode('down arrow'));

                        // When the user presses an arrow key:
                        // It finds the current number that the user has selected
                        //     If they pressed up or down
                        //         (inc/dec)rement the current number (handling day and month names of course)
                        //     If they pressed left or right
                        //         Move their selection to the left or right depending on what they pressed
                        // Then moves the selection to the current number (handling day/month name length differences)

                        // Fix date format
                        strDateFormat = element.getAttribute('format');
                        //console.log(strDateFormat);
                        if (!strDateFormat) {
                            strDateFormat = 'MM/dd/yyyy';
                        } else if (strDateFormat.toLowerCase() === 'shortdate') {
                            strDateFormat = 'M/d/yy';
                        } else if (strDateFormat.toLowerCase() === 'mediumdate') {
                            strDateFormat = 'MMM d, yyyy';
                        } else if (strDateFormat.toLowerCase() === 'longdate') {
                            strDateFormat = 'MMMM d, yyyy';
                        } else if (strDateFormat.toLowerCase() === 'fulldate') {
                            strDateFormat = 'EEEE, MMMM d, yyyy';
                        } else if (strDateFormat.toLowerCase() === 'shorttime') {
                            strDateFormat = 'h:mm a';
                        } else if (strDateFormat.toLowerCase() === 'mediumtime') {
                            strDateFormat = 'h:mm:ss a';
                        } else if (strDateFormat.toLowerCase() === 'isodate') {
                            strDateFormat = 'yyyy-MM-dd';
                        } else if (strDateFormat.toLowerCase() === 'isotime') {
                            strDateFormat = 'HH:mm:ss';
                        } else if (strDateFormat.toLowerCase() === 'isodatetime') {
                            strDateFormat = 'yyyy-MM-dd\'T\'HH:mm:ss';
                        }

                        formatDivider = strDateFormat.match(/[^mdyehmsa]/gi).join('');

                        currentValue = element.control.value;
                        currentDate = new Date(currentValue.replace('\'T\'', ' ').replace(/-/g, '/'));

                        if (strDateFormat.indexOf('M') === -1) {
                            currentDate = new Date('2015/6/15 ' + currentValue);
                        }

                        arrMatch = strDateFormat.match(/(M|E)+/g);
                        if (arrMatch && arrMatch[0].length > 3) {
                            strDateFormat = strDateFormat.replace(/E+/g, new Array(daysOfTheWeek[currentDate.getDay()].length + 1).join('E'));
                            strDateFormat = strDateFormat.replace(/M+/g, new Array(monthsOfTheYear[currentDate.getDay()].length + 1).join('M'));
                        }

                        // If it was an arrow that was pressed
                        if (strKeyCode === GS.keyCode('left arrow') ||
                            strKeyCode === GS.keyCode('up arrow') ||
                            strKeyCode === GS.keyCode('right arrow') ||
                            strKeyCode === GS.keyCode('down arrow')) {

                            //console.log('test');

                            // Prevent the browser from moving the cursor and prevent envelope from using arrows
                            event.preventDefault();
                            event.stopPropagation();

                            //console.log(currentValue, formatDivider, currentSelectionRange.start, currentSelectionRange.end);

                            // Encompass the field in which the cursor is inside
                            while (currentSelectionRange.start >= 0 && formatDivider.indexOf(currentValue[currentSelectionRange.start - 1]) < 0) {
                                currentSelectionRange.start -= 1;
                            }

                            currentSelectionRange.end = currentSelectionRange.start;
                            while ( currentSelectionRange.end < currentValue.length &&
                                    formatDivider.indexOf(currentValue[currentSelectionRange.end]) < 0) {
                                currentSelectionRange.end += 1;
                            }

                            //console.log(currentValue, currentSelectionRange.start, currentSelectionRange.end);

                            GS.setInputSelection(element.control, currentSelectionRange.start, currentSelectionRange.end);

                            currentSelectionText = currentValue.substring(currentSelectionRange.start, currentSelectionRange.end);
                            currentSelectionFormatText = strDateFormat.substring(currentSelectionRange.start, currentSelectionRange.end);

                            // If it is up or down
                            if (strKeyCode === GS.keyCode('up arrow') ||
                                strKeyCode === GS.keyCode('down arrow')) {
                                var increment = strKeyCode === GS.keyCode('up arrow') ? 1 : -1;

                                if (currentSelectionFormatText[0] === 'M') {
                                    currentDate.setMonth(currentDate.getMonth() +       increment);
                                    if ((currentSelectionRange.end - currentSelectionRange.start) > 2) {
                                        currentSelectionRange.end = currentSelectionRange.start + currentSelectionText.indexOf(' ');
                                    } else {
                                        currentSelectionRange.end = currentSelectionRange.start + currentDate.getMonth().toString().length;
                                    }

                                } else if (currentSelectionFormatText[0] === 'd') {
                                    currentDate.setDate(currentDate.getDate() + increment);
                                    currentSelectionRange.end = currentSelectionRange.start + currentDate.getDate().toString().length;

                                } else if (currentSelectionFormatText[0] === 'y') {
                                    currentDate.setFullYear(currentDate.getFullYear() + increment);
                                    currentSelectionRange.end = currentSelectionRange.start + currentDate.getFullYear().toString().length;

                                } else if (currentSelectionFormatText[0] === 'E') {
                                    currentDate.setDate(currentDate.getDate() + increment);
                                    currentSelectionRange.start = 0;
                                    currentSelectionRange.end = daysOfTheWeek[currentDate.getDay()].length;

                                } else if (currentSelectionFormatText[0] === 'h' || currentSelectionFormatText[0] === 'H') {
                                    currentDate.setHours(currentDate.getHours() + increment);
                                    currentSelectionRange.end = currentSelectionRange.start + currentDate.getHours().toString().length;

                                } else if (currentSelectionFormatText[0] === 'm') {
                                    currentDate.setMinutes(currentDate.getMinutes() + increment);
                                    currentSelectionRange.end = currentSelectionRange.start + currentDate.getMinutes().toString().length;

                                } else if (currentSelectionFormatText[0] === 's') {
                                    currentDate.setSeconds(currentDate.getSeconds() + increment);
                                    currentSelectionRange.end = currentSelectionRange.start + currentDate.getSeconds().toString().length;

                                } else if (currentSelectionFormatText[0] === 'a') {
                                    currentDate.setHours(currentDate.getHours() + 12);
                                }

                                newValue = formatDate(currentDate, strDateFormat);
                                this.control.value = newValue;
                                currentValue = newValue;
                            } else if (strKeyCode === GS.keyCode('left arrow')) {
                                currentSelectionRange.end = currentSelectionRange.start - 2;
                                currentSelectionRange.start = currentSelectionRange.end;
                            } else if (strKeyCode === GS.keyCode('right arrow')) {
                                currentSelectionRange.end = currentSelectionRange.end + 2;
                                currentSelectionRange.start = currentSelectionRange.end;
                            }

                            // Copied from above
                            arrMatch = strDateFormat.match(/(M|E)+/g);
                            if (arrMatch && arrMatch[0].length > 3) {
                                strDateFormat = strDateFormat.replace(/E+/g, new Array(daysOfTheWeek[currentDate.getDay()].length + 1).join('E'));
                                strDateFormat = strDateFormat.replace(/M+/g, new Array(monthsOfTheYear[currentDate.getDay()].length + 1).join('M'));
                            }
                            while (currentSelectionRange.start >= 0 && formatDivider.indexOf(currentValue[currentSelectionRange.start - 1]) < 0) {
                                currentSelectionRange.start -= 1;
                            }
                            currentSelectionRange.end = currentSelectionRange.start;
                            while ( currentSelectionRange.end < currentValue.length &&
                                    formatDivider.indexOf(currentValue[currentSelectionRange.end]) < 0) {
                                currentSelectionRange.end += 1;
                            }

                            GS.setInputSelection(element.control, currentSelectionRange.start, currentSelectionRange.end);

                        // All number keys
                        } else if (event.keyCode >= 96 && event.keyCode <= 105) {
                            //// HARK YE ONLOOKER:
                            //// This code caps the number that is inputed by the user to the length that the format allows,
                            //// this will dissallow anyone form entering a year that is > 4 characters unless the
                            //// page's developer allows it in a custom format.
                            ////
                            //// This should be fixed around the year 9998 to have all default formats have 5 character years

                            currentSelectionText = currentValue.substring(currentSelectionRange.start, currentSelectionRange.end);
                            currentSelectionFormatText = strDateFormat.substring(currentSelectionRange.start, currentSelectionRange.end);

                            currentValue = element.value;

                            // This is sort of copied from above
                            // There are only two differences:
                            //     the var name
                            //     the initialization on the next line
                            currentFieldRange = {
                                start: currentSelectionRange.start
                            };
                            while (currentFieldRange.start >= 0 && formatDivider.indexOf(currentValue[currentFieldRange.start - 1]) < 0) {
                                currentFieldRange.start -= 1;
                            }
                            currentFieldRange.end = currentFieldRange.start;
                            while ( currentFieldRange.end < currentValue.length &&
                                    formatDivider.indexOf(currentValue[currentFieldRange.end]) < 0) {
                                currentFieldRange.end += 1;
                            }

                            //console.log(currentFieldRange);

                            //console.log(currentValue.substring(0, currentSelectionRange.start));
                            //console.log(GS.charFromKeyCode(event), currentSelectionText, currentSelectionFormatText, currentDate);
                            //console.log(currentValue.substring(currentSelectionRange.end));

                            // This error checking is probably unneeded, but what the hey
                            currentFieldRange.start = Math.max(currentFieldRange.start, 0);
                            arrMatch = strDateFormat.match(strDateFormat[currentFieldRange.start] + '+', 'g');
                            if (arrMatch) {
                                // Prevent the browser from putting the number in for us
                                event.preventDefault();

                                // Get the character that they pressed
                                newFieldValue = GS.charFromKeyCode(event);
                                console.log(newFieldValue);
                                // Cap the length to the format field's length by using
                                // all characters in the field except the first one
                                newFieldValue = currentValue.substring(currentFieldRange.start + 1, currentFieldRange.start + arrMatch[0].length) + newFieldValue;
                                console.log(newFieldValue, currentValue);

                                console.log(currentFieldRange.start + 1, currentFieldRange.start + arrMatch[0].length);

                                // Build the value using the current field range and the new field value we built above
                                element.value =
                                    currentValue.substring(0, currentFieldRange.start) +
                                    newFieldValue +
                                    currentValue.substring(currentFieldRange.end);


                                console.log(currentValue.substring(0, currentFieldRange.start), newFieldValue, currentValue.substring(currentFieldRange.end));

                                // This is copied from above
                                currentFieldRange = {
                                    start: currentSelectionRange.start
                                };
                                while (currentFieldRange.start >= 0 && formatDivider.indexOf(currentValue[currentFieldRange.start - 1]) < 0) {
                                    currentFieldRange.start -= 1;
                                }
                                currentFieldRange.end = currentFieldRange.start;
                                while ( currentFieldRange.end < currentValue.length &&
                                        formatDivider.indexOf(currentValue[currentFieldRange.end]) < 0) {
                                    currentFieldRange.end += 1;
                                }

                                //                                                                          This indexOf does not need to be checked for -1
                                //                                                                          Because we know for a fact that the match is in
                                //                                                                          the string we are searching
                                newCursorPos = Math.min(currentFieldRange.start + arrMatch[0].length, strDateFormat.indexOf(arrMatch[0]) + arrMatch[0].length);
                                newCursorPos = Math.max(newCursorPos, currentFieldRange.end);
                                //console.log(arrMatch[0].length, strDateFormat.indexOf(arrMatch[0]), newCursorPos, arrMatch[0]);
                                GS.setInputSelection(element.control, newCursorPos, newCursorPos);
                            }

                        }

                        //// All visible keys
                        //} else if ( event.keyCode >= 48 && event.keyCode <= 90 ||
                        //            event.keyCode >= 96 && event.keyCode <= 109 ||
                        //            event.keyCode >= 186 && event.keyCode <= 222 ||
                        //            event.keyCode === 32) {
                        //    //console.log('test');
                        //
                        //    //GS.triggerEvent(element, 'change');
                        //
                        //    if ((currentSelectionRange.end - currentSelectionRange.start) > 0) {
                        //        element.control.addEventListener('keyup', function ______self() {
                        //            GS.setInputSelection(this, currentSelectionRange.start + 1, currentSelectionRange.start) + 1;
                        //            this.removeEventListener('keyup', ______self);
                        //        });
                        //    }
                        //}

                        //console.log(event.keyCode);

                        syncView(element);
                    }
                }
            },
            keyup: function () {
                var element = this;
                if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    syncView(element);
                }
            },
            click: function () {
                var element = this, currentSelectionRange = GS.getInputSelection(element.control),
                    daysOfTheWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                    monthsOfTheYear = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                    arrMatch, strDateFormat, formatDivider, currentValue, currentDate;
                //console.log(currentSelectionRange.start, currentSelectionRange.end);

                ////// Copied from above until otherwise noted

                // Fix date format
                strDateFormat = element.getAttribute('format');
                //console.log(strDateFormat);
                if (!strDateFormat) {
                    strDateFormat = 'MM/dd/yyyy';
                } else if (strDateFormat.toLowerCase() === 'shortdate') {
                    strDateFormat = 'M/d/yy';
                } else if (strDateFormat.toLowerCase() === 'mediumdate') {
                    strDateFormat = 'MMM d, yyyy';
                } else if (strDateFormat.toLowerCase() === 'longdate') {
                    strDateFormat = 'MMMM d, yyyy';
                } else if (strDateFormat.toLowerCase() === 'fulldate') {
                    strDateFormat = 'EEEE, MMMM d, yyyy';
                } else if (strDateFormat.toLowerCase() === 'shorttime') {
                    strDateFormat = 'h:mm a';
                } else if (strDateFormat.toLowerCase() === 'mediumtime') {
                    strDateFormat = 'h:mm:ss a';
                } else if (strDateFormat.toLowerCase() === 'isodate') {
                    strDateFormat = 'yyyy-MM-dd';
                } else if (strDateFormat.toLowerCase() === 'isotime') {
                    strDateFormat = 'HH:mm:ss';
                } else if (strDateFormat.toLowerCase() === 'isodatetime') {
                    strDateFormat = 'yyyy-MM-dd\'T\'HH:mm:ss';
                }

                formatDivider = strDateFormat.match(/[^mdyehmsa]/gi).join('');

                currentValue = element.control.value;
                currentDate = new Date(currentValue.replace('\'T\'', ' ').replace(/-/g, '/'));

                if (strDateFormat.indexOf('M') === -1) {
                    currentDate = new Date('2015/6/15 ' + currentValue);
                }

                arrMatch = strDateFormat.match(/(M|E)+/g);
                if (arrMatch && arrMatch[0].length > 3) {
                    strDateFormat = strDateFormat.replace(/E+/g, new Array(daysOfTheWeek[currentDate.getDay()].length + 1).join('E'));
                    strDateFormat = strDateFormat.replace(/M+/g, new Array(monthsOfTheYear[currentDate.getDay()].length + 1).join('M'));
                }

                while (currentSelectionRange.start >= 0 && formatDivider.indexOf(currentValue[currentSelectionRange.start - 1]) < 0) {
                    currentSelectionRange.start -= 1;
                }
                currentSelectionRange.end = currentSelectionRange.start;
                while ( currentSelectionRange.end < currentValue.length &&
                        formatDivider.indexOf(currentValue[currentSelectionRange.end]) < 0) {
                    currentSelectionRange.end += 1;
                }
                //console.log(currentSelectionRange.start, currentSelectionRange.end);

                ////// Not copied
                element.ignoreSelect = true;
                GS.setInputSelection(element.control, currentSelectionRange.start, currentSelectionRange.end);

                //console.log('CLICK EVENT FIRED');
            },
            focus: function () {
                GS.triggerEvent(this, 'click');
            },
            select: function () {
                //if (!this.ignoreSelect) {
                //    GS.triggerEvent(this, 'click');
                //    this.ignoreSelect = false;
                //}
                //console.log('SELECT EVENT FIRED', GS.getInputSelection(this.control));

                // Copied from click handler until otherwise noted
                var element = this, currentSelectionRange = GS.getInputSelection(element.control),
                    daysOfTheWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
                    monthsOfTheYear = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
                    arrMatch, strDateFormat, formatDivider, currentValue, currentDate;
                //console.log(currentSelectionRange.start, currentSelectionRange.end);

                ////// Copied from above until otherwise noted

                // Fix date format
                strDateFormat = element.getAttribute('format');
                //console.log(strDateFormat);
                if (!strDateFormat) {
                    strDateFormat = 'MM/dd/yyyy';
                } else if (strDateFormat.toLowerCase() === 'shortdate') {
                    strDateFormat = 'M/d/yy';
                } else if (strDateFormat.toLowerCase() === 'mediumdate') {
                    strDateFormat = 'MMM d, yyyy';
                } else if (strDateFormat.toLowerCase() === 'longdate') {
                    strDateFormat = 'MMMM d, yyyy';
                } else if (strDateFormat.toLowerCase() === 'fulldate') {
                    strDateFormat = 'EEEE, MMMM d, yyyy';
                } else if (strDateFormat.toLowerCase() === 'shorttime') {
                    strDateFormat = 'h:mm a';
                } else if (strDateFormat.toLowerCase() === 'mediumtime') {
                    strDateFormat = 'h:mm:ss a';
                } else if (strDateFormat.toLowerCase() === 'isodate') {
                    strDateFormat = 'yyyy-MM-dd';
                } else if (strDateFormat.toLowerCase() === 'isotime') {
                    strDateFormat = 'HH:mm:ss';
                } else if (strDateFormat.toLowerCase() === 'isodatetime') {
                    strDateFormat = 'yyyy-MM-dd\'T\'HH:mm:ss';
                }

                formatDivider = strDateFormat.match(/[^mdyehmsa]/gi).join('');

                currentValue = element.control.value;
                currentDate = new Date(currentValue.replace('\'T\'', ' ').replace(/-/g, '/'));

                if (strDateFormat.indexOf('M') === -1) {
                    currentDate = new Date('2015/6/15 ' + currentValue);
                }

                arrMatch = strDateFormat.match(/(M|E)+/g);
                if (arrMatch && arrMatch[0].length > 3) {
                    strDateFormat = strDateFormat.replace(/E+/g, new Array(daysOfTheWeek[currentDate.getDay()].length + 1).join('E'));
                    strDateFormat = strDateFormat.replace(/M+/g, new Array(monthsOfTheYear[currentDate.getDay()].length + 1).join('M'));
                }

                // Condition copied only
                if ((currentSelectionRange.start >= 0 && formatDivider.indexOf(currentValue[currentSelectionRange.start - 1]) < 0) ||
                    (currentSelectionRange.end < currentValue.length && formatDivider.indexOf(currentValue[currentSelectionRange.end]) < 0)) {
                    GS.triggerEvent(this, 'click');
                    this.ignoreSelect = false;
                }
            }*/
        },
        accessors: {
            value: {
                // get value straight from the input
                get: function () {
                    if (this.control) {
                        if (this.control.value.trim() === '') {
                            return 'NULL';
                        } else {
                            return this.control.value;
                        }
                    } else if (this.hasAttribute('disabled')) {
                        return this.innerHTML;
                    }

                    return undefined;
                },

                // set the value of the input and set the value attribute
                set: function (newValue) {
                    var tempSelection = this.control ? GS.getInputSelection(this.control) : null;

                    if (this.control) {
                        if (newValue && typeof newValue === 'object') {
                            this.control.value = newValue.toLocaleDateString();
                        } else {
                            this.control.value = newValue || '';
                        }

                        if (document.activeElement === this.control) {
                           GS.setInputSelection(this.control, tempSelection.start, tempSelection.end);
                        }

                    } else if (this.hasAttribute('disabled')) {
                        if (newValue && typeof newValue === 'object') {
                            this.innerHTML = formatDate(newValue, getFormatString(this));
                        } else {
                            this.innerHTML = newValue || '';
                        }

                    } else {
                        this.setAttribute('value', newValue);
                    }

                    if (this.control) {
                        handleFormat(this);
                    }
                    syncView(this);
                }
            }
        },
        methods: {
            refresh: function () {
                var element = this, arrPassThroughAttributes, i, len;

                // set a variable for the control element for convenience and speed
                element.control = xtag.query(element, '.control')[0];

                // set a variable for the date picker button element for convenience and speed
                element.datePickerButton = xtag.query(element, '.date-picker-button')[0];

                //console.log(element.control, element.getAttribute('value'), element.getAttribute('column'));

                if (element.control) {
                    element.control.removeEventListener('change', changeFunction);
                    element.control.addEventListener('change', changeFunction);

                    element.control.removeEventListener('focus', focusFunction);
                    element.control.addEventListener('focus', focusFunction);

                    element.control.removeEventListener('blur', blurFunction);
                    element.control.addEventListener('blur', blurFunction);

                    element.control.removeEventListener(evt.mouseout, mouseoutFunction);
                    element.control.addEventListener(evt.mouseout, mouseoutFunction);

                    element.control.removeEventListener(evt.mouseout, mouseoverFunction);
                    element.control.addEventListener(evt.mouseover, mouseoverFunction);
                }
                if (element.datePickerButton) {
                    element.datePickerButton.addEventListener('click', buttonClickFunction);
                }

                // if there is a value already in the attributes of the element: set the control value
                if (element.control && element.hasAttribute('value')) {
                    element.control.value = element.getAttribute('value');
                    handleFormat(element, undefined, false);
                }

                if (element.control) {
                // copy passthrough attributes to control
                    arrPassThroughAttributes = [
                        'placeholder',
                        'name',
                        'maxlength',
                        'autocorrect',
                        'autocapitalize',
                        'autocomplete',
                        'autofocus',
                        'spellcheck',
                        'readonly'
                    ];
                    for (i = 0, len = arrPassThroughAttributes.length; i < len; i += 1) {
                        if (element.hasAttribute(arrPassThroughAttributes[i])) {
                            element.control.setAttribute(arrPassThroughAttributes[i], element.getAttribute(arrPassThroughAttributes[i]) || '');
                        }
                    }
                }
            },

            focus: function () {
                GS.triggerEvent(this, 'focus');
                this.control.focus();
            }
        }
    });
});window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('<gs-datetime>', '<gs-datetime>', 'gs-datetime></gs-datetime>');

    designRegisterElement('gs-datetime', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-datetime.html');

    window.designElementProperty_GSDATETIME = function(selectedElement) {
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
        });

        //console.log(selectedElement.hasAttribute('mini'));

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility', true,
                '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                '    <option value="">Visible</option>' +
                '    <option value="hidden">Invisible</option>' +
                '    <option value="hide-on-desktop">Invisible at desktop size</option>' +
                '    <option value="hide-on-tablet">Invisible at tablet size</option>' +
                '    <option value="hide-on-phone">Invisible at phone size</option>' +
                '    <option value="show-on-desktop">Visible at desktop size</option>' +
                '    <option value="show-on-tablet">Visible at tablet size</option>' +
                '    <option value="show-on-phone">Visible at phone size</option>' +
                '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    function transformCSS(css) {
        return  '-webkit-transform: ' + css + '; ' +
                '-moz-transform: ' + css + '; ' +
                '-ms-transform: ' + css + '; ' +
                '-o-transform: ' + css + '; ' +
                'transform: ' + css + ';';
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    /***************** DATETIME WHEEL *****************/

    function datetimeOpenWheelDialog(element) {
        var i;
        var len;
        var arrFormat = element.getAttribute('format').split(/\b/);
        var arrDate = element.value.split(/\b/);
        if (arrFormat.indexOf('\'') > -1) {
            var arrTempDate = [];
            for (i = 0, len = arrDate.length; i < len; i += 1) {
                if (arrDate[i].indexOf('T') > 1) {
                    var temp = arrDate[i].split('T');
                    arrTempDate.push(temp[0], '\'', 'T', '\'', temp[1]);
                } else {
                    arrTempDate.push(arrDate[i]);
                }
            }
            arrDate = arrTempDate;
        }
        var dialogHTML;
        var label = element.hasAttribute('id') ? xtag.query(document, '[for="' + element.id + '"]')[0] : null;
        var labelHTML = label ? '<center><h3>' + label.innerHTML.replace(/:$/, '') + '</h3></center>' : '';
        var dialogTemplate = document.createElement('template');
        var monthsFull   = ['January','February','March','April','May','June', 'July','August','September','October','November','December'];
        var monthsShort  = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];

        var wheelHTML = function () {
            var strRet = '';
            for (i = 0, len = arrFormat.length; i < len; i += 1) {
                if (arrFormat[i] === '\'') {
                    i += 1;
                }

                if (arrFormat[i] === 'MMMM') {
                    arrFormat[i] = 'MM';
                    arrDate[i] = monthsFull.indexOf(arrDate[i]) + 1;

                } else if (arrFormat[i] === 'MMM') {
                    arrFormat[i] = 'MM';
                    arrDate[i] = monthsShort.indexOf(arrDate[i]) + 1;

                } else if (arrFormat[i] === 'a') {
                    arrFormat[i] = 'ampm';

                } else if (arrFormat[i] === 'EEE' || arrFormat[i] === 'EEEE') {
                    i += 1;
                    continue;
                }
                strRet += '<gs-wheel values="' + arrFormat[i] + '" value="' + arrDate[i] + '"></gs-wheel>';
                i += 1;

                if (arrFormat[i] === '\'') {
                    i += 1;
                }

                if (i < len) {
                    strRet += '<span class="divider"' + (evt.touchDevice ? ' touch' : '') + '><span>' + arrFormat[i] + '</span></span>';
                }
            }
            return strRet;
        };

        dialogHTML = ml(function () {/*
            <gs-page>
                <gs-header>
                    {{LABELHTML}}
                    <gs-grid widths="1,1,1">
                        <gs-block>
                            <gs-button dialogclose>Cancel</gs-button>
                        </gs-block>
                        <gs-block>
                            <gs-button class="now-button">Now</gs-button>
                        </gs-block>
                        <gs-block>
                            <gs-button dialogclose bg-primary>Done</gs-button>
                        </gs-block>
                    </gs-grid>
                </gs-header>
                <gs-body class="gs-datetime-wheel-dialog">
                    <div class="root">
                        {{WHEELS}}
                    </div>
                </gs-body>
            </gs-page>
        */}).replace('{{LABELHTML}}', labelHTML).replace('{{WHEELS}}', wheelHTML());
        dialogTemplate.innerHTML = dialogHTML;
        dialogTemplate.setAttribute('data-mode', 'full');
        GS.openDialog(dialogTemplate, function () {
            var dialog = xtag.query(document, 'gs-dialog')[0];

            xtag.query(dialog, '.now-button')[0].addEventListener('click', function () {
                element.dteValue = new Date();
                arrFormat = element.getAttribute('format').split(/\b/);
                arrDate = element.value.split(/\b/);
                xtag.query(dialog, '.gs-datetime-wheel-dialog > .root')[0].innerHTML = wheelHTML();
            });

            dialog.addEventListener('change', function (event) {
                console.log(event.target);
                if (event.target.getAttribute('values') === 'MM' || event.target.getAttribute('values')[0] === 'y') {
                    var year = xtag.query(dialog, 'gs-wheel[values^="y"]')[0].value;
                    var month = xtag.query(dialog, 'gs-wheel[values="MM"]')[0].value;
                    var dayElement = xtag.query(dialog, 'gs-wheel[values^="d"]')[0];
                    // month is zero based, but we pass a one based number
                    // 0 is the last day of the previous month
                    var days = new Date(year, month, 0).getDate();
                    console.log(days, dayElement);

                    var valuesPart = dayElement.getAttribute('values').match(/d*/)[0];
                    dayElement.parentNode.insertBefore(GS.stringToElement('<gs-wheel values="' + valuesPart + ',' + days + '" value="' + Math.min(dayElement.value, days) + '"></gs-wheel>'), dayElement);
                    dayElement.parentNode.removeChild(dayElement);
                }
            });
            GS.triggerEvent(xtag.query(dialog, 'gs-wheel[values="MM"]')[0], 'change');

        }, function (event, strAnswer) {
            if (strAnswer === 'Done') {
                for (i = 0, len = arrFormat.length; i < len; i += 1) {
                    if (arrFormat[i] === '\'') {
                        i += 1;
                    }

                    if (arrFormat[i] === 'MMMM') {
                        arrFormat[i] = 'MM';
                        arrDate[i] = monthsFull.indexOf(arrDate[i]);

                    } else if (arrFormat[i] === 'MMM') {
                        arrFormat[i] = 'MM';
                        arrDate[i] = monthsShort.indexOf(arrDate[i]);

                    } else if (arrFormat[i] === 'a') {
                        arrFormat[i] = 'ampm';

                    } else if (arrFormat[i] === 'EEE' || arrFormat[i] === 'EEEE') {
                        i += 1;
                        continue;
                    }
                    arrDate[i] = xtag.query(document, 'gs-dialog .gs-datetime-wheel-dialog gs-wheel[values="' + arrFormat[i] + '"]')[0].value;
                    i += 1;

                    if (arrFormat[i] === '\'') {
                        i += 1;
                    }
                }

                element.value = arrDate.join('').replace('\'T\'', 'T');
                element.dteValue = new Date(element.value);
                GS.triggerEvent(element, 'change');
            }
        });
    }

    /***************** DATETIME CALENDER *****************/

    function getFormatString(element) {
        var strFormat;

        if (element.hasAttribute('format')) {
            strFormat = element.getAttribute('format');
        }

        if (!strFormat) {
            strFormat = 'MM/dd/yyyy';
        } else if (strFormat.toLowerCase() === 'shortdate') {
            strFormat = 'M/d/yy';
        } else if (strFormat.toLowerCase() === 'mediumdate') {
            strFormat = 'MMM d, yyyy';
        } else if (strFormat.toLowerCase() === 'longdate') {
            strFormat = 'MMMM d, yyyy';
        } else if (strFormat.toLowerCase() === 'fulldate') {
            strFormat = 'EEEE, MMMM d, yyyy';
        } else if (strFormat.toLowerCase() === 'shorttime') {
            strFormat = 'h:mm a';
        } else if (strFormat.toLowerCase() === 'mediumtime') {
            strFormat = 'h:mm:ss a';
        } else if (strFormat.toLowerCase() === 'isodate') {
            strFormat = 'yyyy-MM-dd';
        } else if (strFormat.toLowerCase() === 'isotime') {
            strFormat = 'HH:mm:ss';
        } else if (strFormat.toLowerCase() === 'isodatetime') {
            strFormat = 'yyyy-MM-dd\'T\'HH:mm:ss';
        }

        return strFormat;
    }

    function formatDate(dteValue, strFormat) {
        /* (this function contains a (modified) substantial portion of code from another source
            here is the copyright for sake of legality) (Uses code by Matt Kruse)
        Copyright (c) 2006-2009 Rostislav Hristov, Asual DZZD

        Permission is hereby granted, free of charge, to any person obtaining a
        copy of this software and associated documentation files
        (the "Software"), to deal in the Software without restriction,
        including without limitation the rights to use, copy, modify, merge,
        publish, distribute, sublicense, and/or sell copies of the Software,
        and to permit persons to whom the Software is furnished to do so,
        subject to the following conditions:

        The above copyright notice and this permission notice shall be included
        in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/
        var i = 0, j = 0, l = 0, c = '', token = '', x, y, yearLen,
            formatNumber = function (n, s) {
                if (typeof s == 'undefined' || s == 2) {
                  return (n >= 0 && n < 10 ? '0' : '') + n;
                } else {
                    if (n >= 0 && n < 10) {
                       return '00' + n;
                    }
                    if (n >= 10 && n <100) {
                       return '0' + n;
                    }
                    return n;
                }
            },
            locale = {
                monthsFull:   ['January','February','March','April','May','June', 'July','August','September','October','November','December'],
                monthsShort:  ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'],
                daysFull:     ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
                daysShort:    ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],
                shortDateFormat: 'M/d/yyyy h:mm a',
                longDateFormat: 'EEEE, MMMM dd, yyyy h:mm:ss a'
            };

        y = dteValue.getFullYear();
        // Nunzio commented this out on Monday, October 19, 2015
        // It was causing an issue during typing in the year field
        /*if (y < 1000) {
            y = String(y + 1900);
        }*/

        var M = dteValue.getMonth() + 1,
            d = dteValue.getDate(),
            E = dteValue.getDay(),
            H = dteValue.getHours(),
            m = dteValue.getMinutes(),
            s = dteValue.getSeconds(),
            S = dteValue.getMilliseconds();

        //console.log(dteValue.getFullYear());

        yearLen = String(y).length;
        dteValue = {
            y: y,
            yyyy: y,
            yy: String(y).substring(yearLen - 2, yearLen),
            M: M,
            MM: formatNumber(M),
            MMM: locale.monthsShort[M-1],
            MMMM: locale.monthsFull[M-1],
            d: d,
            dd: formatNumber(d),
            EEE: locale.daysShort[E],
            EEEE: locale.daysFull[E],
            H: H,
            HH: formatNumber(H)
        };

        //console.log(dteValue);

        if (H === 0) {
            dteValue.h = 12;
        } else if (H > 12) {
            dteValue.h = H - 12;
        } else {
            dteValue.h = H;
        }

        dteValue.hh = formatNumber(dteValue.h);
        dteValue.k = H !== 0 ? H : 24;
        dteValue.kk = formatNumber(dteValue.k);

        if (H > 11) {
            dteValue.K = H - 12;
        } else {
            dteValue.K = H;
        }

        dteValue.KK = formatNumber(dteValue.K);

        if (H > 11) {
            dteValue.a = 'PM';
        } else {
            dteValue.a = 'AM';
        }

        dteValue.m = m;
        dteValue.mm = formatNumber(m);
        dteValue.s = s;
        dteValue.ss = formatNumber(s);
        dteValue.S = S;
        dteValue.SS = formatNumber(S);
        dteValue.SSS = formatNumber(S, 3);

        var result = '';

        i = 0;
        c = '';
        token = '';
        s = false;

        while (i < strFormat.length) {
            token = '';
            c = strFormat.charAt(i);
            if (c == '\'') {
                i++;
                if (strFormat.charAt(i) == c) {
                    result = result + c;
                    i++;
                } else {
                    s = !s;
                }
            } else {
                while (strFormat.charAt(i) == c) {
                    token += strFormat.charAt(i++);
                }
                if (token.indexOf('MMMM') != -1 && token.length > 4) {
                    token = 'MMMM';
                }
                if (token.indexOf('EEEE') != -1 && token.length > 4) {
                    token = 'EEEE';
                }
                if (typeof dteValue[token] != 'undefined' && !s) {
                    result = result + dteValue[token];
                } else {
                    result = result + token;
                }
            }
        }

        return result;
    }

    function datetimeOpenCalenderDialog(element) {
        'use strict';
        var i, len, dateHTML, timeHTML, pickerHTML, dialogHTML, dialogTemplate = document.createElement('template');
        var dteToday = new Date(), dteValue = element.dteValue || new Date(dteToday);

        dateHTML = ml(function () {/*
            <div class="date-section">
                <div class="adjust-section date-adjust-section centered">
                    <div class="date-today">&#xf017;</div>
                    <div class="date-input">
                        <input class="month" />
                        <span class="divider">/</span>
                        <input class="day" />
                        <span class="divider">/</span>
                        <input class="year" />
                    </div>
                    <div class="adjust-container">
                        <div class="date-adjust up">&#xf077;</div><div class="date-adjust down">&#xf078;</div>
                    </div>
                </div>
                <div class="calender centered">
                    <div flex-horizontal>
                        <gs-button icononly icon="chevron-left" class="month-adjust down"></gs-button>

                        <center flex class="month-label"></center>

                        <gs-button icononly icon="chevron-right" class="month-adjust up"></gs-button>
                    </div>
                    <div flex-horizontal>
                        <gs-button icononly icon="chevron-left" class="year-adjust down"></gs-button>

                        <center flex class="year-label"></center>

                        <gs-button icononly icon="chevron-right" class="year-adjust up"></gs-button>
                    </div>
                    <div>
                        <div class="day-letter">S</div><div class="day-letter">M</div><div class="day-letter">T</div><div class="day-letter">W</div><div class="day-letter">T</div><div class="day-letter">F</div><div class="day-letter">S</div>
                    </div>
                </div>
            </div>
        */});
        timeHTML = ml(function () {/*
            <div class="time-section">
                <div class="adjust-section time-adjust-section centered">
                    <div class="time-now">&#xf017;</div>
                    <div class="time-input">
                        <input class="hour" />
                        <span class="divider">:</span>
                        <input class="minute" />
                        <span class="divider">:</span>
                        <input class="second" />
                        <span class="divider"> </span>
                        <input class="ampm" />
                    </div>
                    <div class="adjust-container">
                        <div class="time-adjust up">&#xf077;</div><div class="time-adjust down">&#xf078;</div>
                    </div>
                </div>
                <div class="clock-parent">
                    <div class="clock"></div>
                </div>
            </div>
        */});

        if (element.hasDate && element.hasTime) {
            pickerHTML = ml(function () {/*
                <gs-grid widths="1,1">
                    <gs-block>
                        {{DATEHTML}}
                    </gs-block>
                    <gs-block>
                        {{TIMEHTML}}
                    </gs-block>
                </gs-grid>
            */}).replace('{{DATEHTML}}', dateHTML).replace('{{TIMEHTML}}', timeHTML);

        } else if (element.hasDate) {
            pickerHTML = dateHTML;

        } else if (element.hasTime) {
            pickerHTML = timeHTML;

        }

        dialogHTML = ml(function () {/*
            <gs-page>
                <gs-body class="gs-datetime-calender-dialog">
                    {{PICKERHTML}}
                    <gs-grid widths="1,1">
                        <gs-block>
                            <gs-button dialogclose>Cancel</gs-button>
                        </gs-block>
                        <gs-block>
                            <gs-button dialogclose bg-primary>Done</gs-button>
                        </gs-block>
                    </gs-grid>
                </gs-body>
            </gs-page>
        */}).replace('{{PICKERHTML}}', pickerHTML);
        dialogTemplate.innerHTML = dialogHTML;
        dialogTemplate.setAttribute('no-background', '');
        dialogTemplate.setAttribute('data-overlay-close', '');
        GS.openDialogToElement(element, dialogTemplate, 'down', function () {
            var dteStart = new Date(dteValue);

            var refreshDateInputs = function () {};
            var refreshTimeInputs = function () {};

            var regenerateCalender = function () {};
            var resetClock = function () {};

            if (element.hasDate) {
                var calender = xtag.query(document, 'gs-dialog .calender')[0];
                var dateAdjustSection = xtag.query(document, 'gs-dialog .date-adjust-section')[0];
                var dateInput = xtag.query(dateAdjustSection, '.date-input')[0];

                var dayInput = xtag.query(dateInput, '.day')[0];
                var monthInput = xtag.query(dateInput, '.month')[0];
                var yearInput = xtag.query(dateInput, '.year')[0];

                var monthLabel = xtag.query(calender, '.month-label')[0];
                var yearLabel = xtag.query(calender, '.year-label')[0];
                var arrMonth = [
                    'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
                ];

                refreshDateInputs = function () {
                    dayInput.value = GS.leftPad(dteValue.getDate(), '0', 2);
                    monthInput.value = GS.leftPad(dteValue.getMonth() + 1, '0', 2);
                    yearInput.value = dteValue.getFullYear();

                    if (dateInput.selectText) {
                        GS.setInputSelection(dateInput.selectText, 0, dateInput.selectText.value.length);
                        dateInput.selectText = null;
                    }
                };
                refreshDateInputs();

                regenerateCalender = function (dteStart) {
                    var children = xtag.queryChildren(calender, '.day');
                    for (var i = 0, len = children.length; i < len; i += 1) {
                        calender.removeChild(children[i]);
                    }

                    var dteCurrent = new Date(dteStart), intCurrentMonth = dteCurrent.getMonth(), intNextMonth = intCurrentMonth + 1;
                    if (intNextMonth === 12) {
                        intNextMonth = 0;
                    }

                    monthLabel.innerText = arrMonth[dteStart.getMonth()];
                    yearLabel.innerText = dteStart.getFullYear();

                    dteCurrent.setDate(1);
                    dteCurrent.setDate(dteCurrent.getDate() - dteCurrent.getDay());

                    while (dteCurrent.getMonth() !== intNextMonth || dteCurrent.getDay() !== 0) {
                        var day = document.createElement('div');
                        day.classList.add('day');
                        day.innerText = dteCurrent.getDate();
                        if (dteCurrent.getMonth() !== intCurrentMonth) {
                            day.classList.add('grey');
                        }
                        if (dteCurrent.getMonth() === dteToday.getMonth() && dteCurrent.getFullYear() === dteToday.getFullYear() && dteCurrent.getDate() === dteToday.getDate()) {
                            day.classList.add('today');
                            day.innerText = 'T';
                        }
                        if (dteCurrent.getMonth() === dteValue.getMonth() && dteCurrent.getFullYear() === dteValue.getFullYear() && dteCurrent.getDate() === dteValue.getDate()) {
                            day.classList.add('selected');
                        }
                        day.value = new Date(dteCurrent);
                        calender.appendChild(day);

                        dteCurrent.setDate(dteCurrent.getDate() + 1);
                    }
                };
                regenerateCalender(dteStart);

                dateInput.addEventListener('keydown', function (event) {
                    var code = event.which || event.keyCode || event.charCode;
                    var dtePreviousValue = new Date(dteValue);
                    // 38: up
                    // 40: down
                    if (code === 38 || code === 40) {
                        event.target.value = GS.leftPad((parseInt(event.target.value, 10) + (code === 38 ? 1 : -1)).toString(), '0', 2);
                        dateInput.selectText = event.target;
                        event.preventDefault();
                    }

                    if (event.target.classList.contains('year')) {
                        dteValue.setFullYear(event.target.value);
                        dteStart = new Date(dteValue);

                    } else if (event.target.classList.contains('month')) {
                        dteValue.setMonth(parseInt(event.target.value, 10) - 1);
                        dteStart = new Date(dteValue);

                    } else if (event.target.classList.contains('day')) {
                        dteValue.setDate(event.target.value);
                        dteStart = new Date(dteValue);
                    }

                    if (dtePreviousValue.getTime() !== dteValue.getTime()) {
                        refreshDateInputs();
                        regenerateCalender(dteStart);
                    }
                });

                dateAdjustSection.addEventListener('mousedown', function (event) {
                    if (event.target.nodeName.toUpperCase() !== 'INPUT') {
                        event.preventDefault();
                    }
                });

                dateAdjustSection.addEventListener('click', function (event) {
                    var dtePreviousValue = new Date(dteValue);
                    var activeElement = document.activeElement; // just to shorten things a bit

                    if (activeElement.parentNode.classList.contains('date-input') && event.target.classList.contains('date-adjust')) {
                        activeElement.value = GS.leftPad((parseInt(activeElement.value, 10) + (event.target.classList.contains('up') ? 1 : -1)).toString(), '0', 2);
                        dateInput.selectText = activeElement;

                        if (activeElement.classList.contains('year')) {
                            dteValue.setFullYear(activeElement.value);

                        } else if (activeElement.classList.contains('month')) {
                            dteValue.setMonth(parseInt(activeElement.value, 10) - 1);

                        } else if (activeElement.classList.contains('day')) {
                            dteValue.setDate(activeElement.value);
                        }
                        dteStart = new Date(dteValue);

                    } else if (event.target.classList.contains('date-today')) {
                        dteValue.setFullYear(dteToday.getFullYear());
                        dteValue.setMonth(dteToday.getMonth());
                        dteValue.setDate(dteToday.getDate());

                        dteStart = new Date(dteValue);

                    }

                    if (dtePreviousValue.getTime() !== dteValue.getTime()) {
                        refreshDateInputs();
                        regenerateCalender(dteStart);
                    }
                });

                calender.addEventListener('click', function (event) {
                    if (event.target.classList.contains('day')) {
                        var selected = xtag.query(calender, '.selected')[0];
                        if (selected) {
                            selected.classList.remove('selected');
                            event.target.classList.add('selected');
                        }

                        dteValue = event.target.value;
                        dteStart = new Date(dteValue);

                        refreshDateInputs();
                        if (event.target.classList.contains('grey')) {
                            regenerateCalender(dteStart);
                        }
                    } else if (event.target.classList.contains('month-adjust')) {
                        dteStart.setMonth(dteStart.getMonth() + (event.target.classList.contains('up') ? 1 : -1));

                        monthLabel.innerText = arrMonth[dteStart.getMonth()];

                        regenerateCalender(dteStart);
                    } else if (event.target.classList.contains('year-adjust')) {
                        dteStart.setFullYear(dteStart.getFullYear() + (event.target.classList.contains('up') ? 1 : -1));

                        yearLabel.innerText = dteStart.getFullYear();

                        regenerateCalender(dteStart);
                    }
                });
            }

            if (element.hasTime) {
                var clock = xtag.query(document, 'gs-dialog .clock')[0];
                var timeAdjustSection = xtag.query(document, 'gs-dialog .time-adjust-section')[0];
                var timeInput = xtag.query(timeAdjustSection, '.time-input')[0];

                var hourInput = xtag.query(timeInput, '.hour')[0];
                var minuteInput = xtag.query(timeInput, '.minute')[0];
                var secondInput = xtag.query(timeInput, '.second')[0];
                var ampmInput = xtag.query(timeInput, '.ampm')[0];

                var hourHand;
                var minuteHand;
                var secondHand;

                refreshTimeInputs = function () {
                    var hour = dteValue.getHours();
                    var ampm = hour >= 12 ? 'PM' : 'AM';
                    hour = hour === 0 ? 24 : hour;
                    hour = hour > 12 ? hour - 12 : hour;
                    hourInput.value = GS.leftPad(hour, '0', 2);
                    minuteInput.value = GS.leftPad(dteValue.getMinutes(), '0', 2);
                    secondInput.value = GS.leftPad(dteValue.getSeconds(), '0', 2);
                    ampmInput.value = ampm;

                    if (timeInput.selectText) {
                        GS.setInputSelection(timeInput.selectText, 0, timeInput.selectText.value.length);
                        timeInput.selectText = null;
                    }
                };
                refreshTimeInputs();

                var i = 0, len = 60, clockHTML = '';
                for (; i < len; i += 1) {
                    clockHTML += '<div class="marking' + ((i % 5) === 0 ? ' large' : '') + '" style="' + transformCSS('rotate(' + i * 6 + 'deg)') + '"></div>';
                }
                clockHTML += ml(function () {/*
                    <div class="position-reference"></div>
                    <div class="clock-hand hour-hand">
                        <div class="clock-hand-drag-handle"></div>
                    </div>
                    <div class="clock-hand minute-hand">
                        <div class="clock-hand-drag-handle"></div>
                    </div>
                    <div class="clock-hand second-hand">
                        <div class="clock-hand-drag-handle"></div>
                    </div>
                */});
                clock.innerHTML = clockHTML;
                hourHand = xtag.query(clock, '.hour-hand')[0];
                minuteHand = xtag.query(clock, '.minute-hand')[0];
                secondHand = xtag.query(clock, '.second-hand')[0];
                var resetClock = function () {
                    // the 180 is because the html is such that the hands point down
                    hourHand.setAttribute('style', transformCSS('rotate(' + (((dteValue.getHours() % 12) * 30) + 180) + 'deg)'));
                    minuteHand.setAttribute('style', transformCSS('rotate(' + ((dteValue.getMinutes() * 6) + 180) + 'deg)'));
                    secondHand.setAttribute('style', transformCSS('rotate(' + ((dteValue.getSeconds() * 6) + 180) + 'deg)'));
                };
                resetClock();

                timeInput.addEventListener('keydown', function (event) {
                    var code = event.which || event.keyCode || event.charCode;
                    var dtePreviousValue = new Date(dteValue);
                    // 38: up
                    // 40: down
                    // 65: a
                    // 80: p
                    if (event.target.classList.contains('ampm')) {
                        timeInput.selectText = event.target;
                        event.preventDefault();

                        if (dteValue.getHours() >= 12 && (code === 65 || code === 38 || code === 40)) {
                            dteValue.setHours(dteValue.getHours() - 12);

                        } else if (dteValue.getHours() < 12 && (code === 80 || code === 38 || code === 40)) {
                            dteValue.setHours(dteValue.getHours() + 12);

                        }

                    } else if (code === 38 || code === 40) {
                        event.target.value = GS.leftPad((parseInt(event.target.value, 10) + (code === 38 ? 1 : -1)).toString(), '0', 2);
                        timeInput.selectText = event.target;
                        event.preventDefault();
                    }

                    if (event.target.classList.contains('hour')) {
                        dteValue.setHours(event.target.value + (dteValue.getHours() > 12 ? 12 : 0));
                        dteStart = new Date(dteValue);

                    } else if (event.target.classList.contains('minute')) {
                        dteValue.setMinutes(event.target.value);
                        dteStart = new Date(dteValue);

                    } else if (event.target.classList.contains('second')) {
                        dteValue.setSeconds(event.target.value);
                        dteStart = new Date(dteValue);
                    }

                    if (dtePreviousValue.getTime() !== dteValue.getTime()) {
                        refreshTimeInputs();
                        refreshDateInputs();

                        resetClock(dteStart);
                        regenerateCalender(dteStart);
                    }
                });

                timeAdjustSection.addEventListener('mousedown', function (event) {
                    if (event.target.nodeName.toUpperCase() !== 'INPUT') {
                        event.preventDefault();
                    }
                });

                timeAdjustSection.addEventListener('click', function (event) {
                    var dtePreviousValue = new Date(dteValue);
                    var activeElement = document.activeElement; // just to shorten things a bit

                    if (event.target.classList.contains('ampm')) {
                        GS.setInputSelection(event.target, 0, 2);

                    } else if (activeElement.parentNode.classList.contains('time-input') && event.target.classList.contains('time-adjust')) {
                        if (activeElement.classList.contains('ampm')) {
                            if (dteValue.getHours() < 12) {
                                dteValue.setHours(dteValue.getHours() + 12);

                            } else {
                                dteValue.setHours(dteValue.getHours() - 12);
                            }

                        } else {
                            activeElement.value = GS.leftPad((parseInt(activeElement.value, 10) + (event.target.classList.contains('up') ? 1 : -1)).toString(), '0', 2);
                        }
                        timeInput.selectText = activeElement;

                        if (activeElement.classList.contains('hour')) {
                            if (activeElement.value === '11' && dteValue.getHours() === 0) {
                                dteValue.setHours(-1);

                                dteStart = new Date(dteValue);
                                regenerateCalender(dteStart);
                            } else {
                                dteValue.setHours(parseInt(activeElement.value, 10) + (dteValue.getHours() > 12 ? 12 : 0));
                            }

                        } else if (activeElement.classList.contains('minute')) {
                            dteValue.setMinutes(activeElement.value);

                        } else if (activeElement.classList.contains('second')) {
                            dteValue.setSeconds(activeElement.value);

                        }
                        dteStart = new Date(dteValue);

                    } else if (event.target.classList.contains('time-now')) {
                        var dteNow = new Date();
                        dteValue.setHours(dteToday.getHours());
                        dteValue.setMinutes(dteToday.getMinutes());
                        dteValue.setSeconds(dteToday.getSeconds());

                        dteStart = new Date(dteValue);

                    }

                    if (dtePreviousValue.getTime() !== dteValue.getTime()) {
                        refreshTimeInputs();
                        refreshDateInputs();

                        resetClock(dteStart);
                        regenerateCalender(dteStart);
                    }
                });

                clock.addEventListener('mousedown', function (event) {
                    var target = event.target;

                    var clockRect = clock.getBoundingClientRect();
                    var refX = clockRect.left + (clockRect.width / 2);
                    var refY = clockRect.top + (clockRect.height / 2);

                    if (target.classList.contains('clock-hand-drag-handle')) {
                        target = target.parentNode;
                    }

                    if (target.classList.contains('clock-hand')) {
                        var dragHandler = function (event) {
                            var x = event.clientX - refX;
                            var y = event.clientY - refY;
                            var thetaRad = Math.atan2(y, x); // atan2 needs y first (?!?!?!?)
                            var thetaDeg = thetaRad * (180 / Math.PI);
                            if (target.classList.contains('hour-hand')) {
                                var tMod30 = thetaDeg % 30;
                                if (tMod30 <= 15) {
                                    thetaDeg -= tMod30;
                                } else {
                                    thetaDeg += 30 - tMod30;
                                }
                            } else {
                                var tMod6 = thetaDeg % 6;
                                if (tMod6 <= 3) {
                                    thetaDeg -= tMod6;
                                } else {
                                    thetaDeg += 6 - tMod6;
                                }
                            }
                            thetaDeg += 90;
                            if (thetaDeg <= 0) {
                                thetaDeg += 360;
                            }

                            if (target.classList.contains('hour-hand')) {
                                var newHours = thetaDeg / 30;
                                // 11PM -> 12AM
                                if (dteValue.getHours() === 23 && newHours === 12) {
                                    dteValue.setHours(24);

                                // 1PM -> 12PM (because below we do 12 + newHours)
                                } else if (dteValue.getHours() === 13 && newHours === 12) {
                                    dteValue.setHours(12);

                                // 12AM -> 11PM
                                } else if (dteValue.getHours() === 0 && newHours === 11) {
                                    dteValue.setHours(-1);

                                // 12AM -> 12AM
                                } else if (dteValue.getHours() === 0 && newHours === 12) {
                                    dteValue.setHours(0);

                                // 11PM -> 10PM
                                } else if (dteValue.getHours() === 23 && newHours < 11) {
                                    dteValue.setHours(12 + newHours);

                                // 12PM -> 1PM
                                } else if (dteValue.getHours() === 12 && newHours === 1) {
                                    dteValue.setHours(13);

                                // 1AM -> 12AM
                                } else if (dteValue.getHours() === 1 && newHours === 12) {
                                    dteValue.setHours(0);

                                // *PM -> *PM
                                } else if (dteValue.getHours() > 12) {
                                    dteValue.setHours(12 + newHours);

                                // *AM -> *AM
                                } else {
                                    dteValue.setHours(newHours);
                                }

                            } else if (target.classList.contains('minute-hand')) {
                                var newMinutes = thetaDeg / 6;
                                newMinutes = newMinutes === 60 ? 0 : newMinutes;
                                if (dteValue.getMinutes() === 59 && newMinutes === 0) {
                                    dteValue.setMinutes(60);

                                } else if (dteValue.getMinutes() === 0 && newMinutes === 59) {
                                    dteValue.setMinutes(-1);

                                } else {
                                    dteValue.setMinutes(newMinutes);
                                }

                            } else if (target.classList.contains('second-hand')) {
                                var newSeconds = thetaDeg / 6;
                                newSeconds = newSeconds === 60 ? 0 : newSeconds;
                                if (dteValue.getSeconds() === 59 && newSeconds === 0) {
                                    dteValue.setSeconds(60);

                                } else if (dteValue.getSeconds() === 0 && newSeconds === 59) {
                                    dteValue.setSeconds(-1);

                                } else {
                                    dteValue.setSeconds(newSeconds);
                                }

                            }

                            if (dteStart.getTime() !== dteValue.getTime()) {
                                dteStart = new Date(dteValue);

                                refreshTimeInputs();
                                refreshDateInputs();

                                resetClock(dteStart);
                                regenerateCalender(dteStart);
                            }
                        };

                        var dragStopHandler = function (event) {
                            window.removeEventListener('mousemove', dragHandler);
                            window.removeEventListener('mouseup', dragStopHandler);
                        };

                        window.addEventListener('mousemove', dragHandler);
                        window.addEventListener('mouseup', dragStopHandler);
                    }
                });
            }
        }, function (event, strAnswer) {
            if (strAnswer === 'Done') {
                element.dteValue = dteValue;
                GS.triggerEvent(element, 'change');
            }
        });
    }

    // dont do anything that modifies the element here
    function datetimeElementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        event.target.classList.add('focus');
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        event.target.classList.remove('focus');
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        event.target.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        event.target.classList.add('hover');
    }

    function datetimeElementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (element.hasAttribute('format')) {
                    element.setAttribute('format', getFormatString(element));

                    var d1 = new Date(), d2 = new Date(formatDate(d1, element.getAttribute('format')));
                    if (d1.getTime() !== d2.getTime()) {
                        element.timezoneOffset = d2.getTime() - d1.getTime();
                    }
                } else {
                    element.setAttribute('format', getFormatString(element));
                }

                element.hasDate = /\b(y|yyyy|yy|M|MM|MMM|MMMM|d|dd|EEE|EEEE)\b/g.test(element.getAttribute('format'));
                element.hasTime = /\b(k|kk|hh|h|H|HH|m|mm|s|ss|S|SS|SSS)\b/g.test(element.getAttribute('format'));

                if (element.getAttribute('value') === 'today' || element.getAttribute('value') === 'now') {
                    element.dteValue = new Date();
                } else if (element.hasAttribute('value')) {
                    element.dteValue = new Date((element.hasDate ? '' : '1/1/1970 ') + element.getAttribute('value') + (element.hasTime ? '' : ' 00:00:00'));
                } else if (!element.getAttribute('value') && element.hasAttribute('placeholder')) {
                    element.innerHTML = '<span gs-dynamic class="placeholder">' + element.getAttribute('placeholder') + '</span>';
                }

                // handle "qs" attribute
                if (element.getAttribute('qs')) {
                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                }

                var label = element.hasAttribute('id') ? xtag.query(document, '[for="' + element.id + '"]')[0] : null;
                if (label) {
                    label.addEventListener('click', function () {
                        GS.triggerEvent(element, 'click');
                    });
                }

                element.addEventListener('click', function () {
                    if (!element.hasAttribute('disabled') && !element.hasAttribute('readonly')) {
                        if (evt.touchDevice) {
                            datetimeOpenWheelDialog(element);
                        } else {
                            datetimeOpenCalenderDialog(element);
                        }
                    }
                });

                element.addEventListener('keydown', function (event) {
                    var code = event.which || event.keyCode || event.charCode;

                    if (code !== 9) { // tab
                        event.preventDefault();
                        GS.triggerEvent(element, 'click');
                    }
                });

                element.addEventListener('focus', focusFunction);
                element.addEventListener('blur', blurFunction);
                element.addEventListener(evt.mouseout, mouseoutFunction);
                element.addEventListener(evt.mouseover, mouseoverFunction);
            }
        }
    }

    xtag.register('gs-datetime', {
        lifecycle: {
            created: function () {
                datetimeElementCreated(this);
            },

            inserted: function () {
                datetimeElementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {

                }
            }
        },
        events: {},
        accessors: {
            value: {
                get: function () {
                    return this.getAttribute('value');
                },
                set: function (newValue) {
                    this.setAttribute('value', newValue);
                    this.innerText = newValue;
                }
            },
            dteValue: {
                get: function () {
                    var value = this.value;
                    var dteValue = value ? new Date((this.hasDate ? '' : '1/1/1970 ') + value + (this.hasTime ? '' : ' 00:00:00')) : null;

                    return dteValue;
                },
                set: function (newValue) {
                    this.value = formatDate(newValue, this.getAttribute('format'));
                }
            }
        },
        methods: {}
    });

    /******************* WHEEL ******************/

    function wheelDragStartHandler(event) {
        var pageY = 0;
        if (event.touches && event.touches.length !== 1) {
            return;
        } else if (event.touches) {
            pageY = event.touches[0].pageY;
        } else if (event.pageY) {
            pageY = event.pageY;
        }
        var element = this;
        var fontSize = GS.emToPx(element, 1) / GS.emToPx(document.body, 1);
        var wheel = element.wheel;
        element.dragStart = pageY;
        element.rotationStart = element.rotation;
        element.numbersRotated = 1;
        if (element.kineticTimer) {
            clearTimeout(element.kineticTimer);
            element.kineticTimer = null;
        }
        // console.log(element.dragStart, pageY, element.velocity, element.rotation, event);
        // console.log('wheelDragStartHandler', element);

        var addNumberToStart = function () {
            wheel.removeChild(wheel.lastChild);
            var newRotation = parseFloat(wheel.firstChild.getAttribute('rotation')), newNumber = parseInt(wheel.firstChild.innerText, 10) - 1;
            newRotation += element.rotationInterval;
            if (newRotation > 0) {
                newRotation -= 360;
            }
            if (newNumber < element.min) {
                newNumber += (element.max + 1);
            }
            wheel.insertBefore(GS.stringToElement('<span class="value" rotation="' + newRotation + '" style="transform: rotateX(' + newRotation + 'deg) translateZ(' + element.radius + ');">' + GS.leftPad(newNumber, '0', 2) + '</span>'), wheel.firstChild);
        };

        var addNumberToEnd = function () {
            wheel.removeChild(wheel.firstChild);
            var newRotation = parseFloat(wheel.lastChild.getAttribute('rotation')), newNumber = parseInt(wheel.lastChild.innerText, 10) + 1;
            newRotation -= element.rotationInterval;
            if (newRotation < -360) {
                newRotation += 360;
            }
            if (newNumber >= (element.max + 1)) {
                newNumber -= (element.max + 1);
            }
            wheel.appendChild(GS.stringToElement('<span class="value" rotation="' + newRotation + '" style="transform: rotateX(' + newRotation + 'deg) translateZ(' + element.radius + ');">' + GS.leftPad(newNumber, '0', 2) + '</span>'));
        };

        var dragHandler = function (event) {
            var pageY = 0;
            if (event.touches && event.touches.length !== 1) {
                return;
            } else if (event.touches) {
                pageY = event.touches[0].pageY;
            } else if (event.pageY) {
                pageY = event.pageY;
            }
            // console.log('dragHandler', element);
            element.velocity = element.dragStart - pageY;
            // console.log(element.dragStart, pageY, element.velocity, element.rotation, event);

            element.rotation += element.velocity / fontSize;
            wheel.setAttribute('style', 'transform: translateZ(-' + element.radius + ') rotateX(' + element.rotation + 'deg);');

            if (!element.ampm) {
                while ((element.rotation - element.rotationStart) < ((element.numbersRotated - 1) * element.rotationInterval)) {
                    element.numbersRotated -= 1;

                    addNumberToStart();
                }

                while ((element.rotation - element.rotationStart) > (element.numbersRotated * element.rotationInterval)) {
                    element.numbersRotated += 1;

                    addNumberToEnd();
                }
            }

            element.dragStart = pageY;
        };

        var dragStopHandler = function (event) {
            // console.log('dragStopHandler', element);

            if (element.ampm) {
                while (element.rotation > 180) {
                    element.rotation -= 360;
                }
                while (element.rotation < -180) {
                    element.rotation += 360;
                }

                if (element.rotation < 11.25) {
                    element.rotation = 0;
                } else if (element.rotation >= 11.25) {
                    element.rotation = 22.25;
                }

                wheel.setAttribute('style', 'transform: translateZ(-' + element.radius + ') rotateX(' + element.rotation + 'deg);');

                var valueElement = xtag.query(wheel, '[rotation="' + (element.rotation * -1) + '"]')[0];
                element.setAttribute('value', valueElement.innerText);
                GS.triggerEvent(element, 'change');

            } else {
                if (Math.abs(element.velocity) > 5) {
                    var drag = 0.01;
                    var interval = 10;
                    element.kineticTimer = setTimeout(function kinetic() {
                        dragHandler({
                            pageY: element.dragStart - (element.velocity * (1 - drag))
                        });
                        drag *= 1.05;
                        if (drag < 1) {
                            element.kineticTimer = setTimeout(kinetic, interval);
                        } else {
                            element.kineticTimer = null;
                            element.velocity = 0;
                            dragStopHandler();
                        }
                    }, interval);

                } else {
                    var oldRotation = element.rotation;
                    element.rotation = Math.round(element.rotation / element.rotationInterval) * element.rotationInterval;

                    while (element.rotation > 360) {
                        element.rotation -= 360;
                    }
                    while (element.rotation < 0) {
                        element.rotation += 360;
                    }

                    var valueElement = xtag.query(wheel, '[rotation="' + (element.rotation * -1) + '"]')[0];
                    element.setAttribute('value', valueElement.innerText);

                    element.rotation = -180;
                    wheel.setAttribute('style', 'transform: translateZ(-' + element.radius + ') rotateX(' + element.rotation + 'deg);');
                    wheelGenerateHTML(element);
                    GS.triggerEvent(element, 'change');
                }
            }

            window.removeEventListener(evt.mousemove, dragHandler);
            window.removeEventListener(evt.mouseup, dragStopHandler);
            window.addEventListener(evt.mouseout, dragStopHandler);
        };

        window.addEventListener(evt.mousemove, dragHandler);
        window.addEventListener(evt.mouseup, dragStopHandler);
        window.addEventListener(evt.mouseout, dragStopHandler);
    }

    function wheelGenerateHTML(element) {
        element.wheel.innerHTML = '';
        for (var rotation = 0, j = parseInt(element.value, 10) - 8; rotation > -360; rotation -= element.rotationInterval, j += 1) {
            if (element.ampm) {
                element.wheel.appendChild(GS.stringToElement('<span class="value" rotation="' + rotation + '" style="transform: rotateX(' + rotation + 'deg) translateZ(' + element.radius + ');">' + (rotation === 0 ? 'AM' : 'PM') + '</span>'));
                if (rotation == -22.5) {
                    break;
                }
            } else {
                if (j < element.min) {
                    if (j >= 0) {
                        j = element.max - j;
                    } else {
                        j = (element.max + (element.min === 0 ? 1 : 0)) + j;
                    }
                }
                element.wheel.appendChild(GS.stringToElement('<span class="value" rotation="' + rotation + '" style="transform: rotateX(' + rotation + 'deg) translateZ(' + element.radius + ');">' + GS.leftPad(j, '0', 2) + '</span>'));
                if (j === element.max) {
                    j = element.min - 1;
                }
            }
        }
    }

    // dont do anything that modifies the element here
    function wheelElementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    //
    function wheelElementInserted(element) {
        var styleElement, i, len, wheelNames, wheelHTML;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                if (evt.touchDevice) {
                    element.setAttribute('touch', '');
                }

                var maybePreventPullToRefresh = false;
                var lastTouchY = 0;
                var touchstartHandler = function(e) {
                    if (e.touches.length != 1) {
                        return;
                    }
                    lastTouchY = e.touches[0].clientY;
                    // Pull-to-refresh will only trigger if the scroll begins when the
                    // document's Y offset is zero.
                    maybePreventPullToRefresh = window.pageYOffset == 0;
                };

                var touchmoveHandler = function(e) {
                    var touchY = e.touches[0].clientY;
                    var touchYDelta = touchY - lastTouchY;
                    lastTouchY = touchY;

                    if (maybePreventPullToRefresh) {
                        // To suppress pull-to-refresh it is sufficient to preventDefault the
                        // first overscrolling touchmove.
                        maybePreventPullToRefresh = false;
                        if (touchYDelta > 0) {
                            e.preventDefault();
                            return;
                        }
                    }

                    e.preventDefault();
                    return;

                    if (window.pageYOffset == 0 && touchYDelta > 0) {
                        e.preventDefault();
                        return;
                    }
                };

                element.addEventListener('touchstart', touchstartHandler, { passive: false });
                element.addEventListener('touchmove', touchmoveHandler, { passive: false });

                element.radius = '4em'; //(element.clientHeight / 2) + 'px';
                element.values = element.getAttribute('values');
                element.innerHTML = ml(function () {/*
                    <div class="root">
                        <div class="transparent top"></div>
                        <div class="container">
                            <div class="wheel" style="transform: translateZ(-{{RADIUS}}) rotateX(-180deg);"></div>
                        </div>
                        <div class="transparent bottom"></div>
                    </div>
                */}).replace('{{RADIUS}}', element.radius);
                element.wheel = xtag.query(element, '.wheel')[0];
                element.rotation = -180;
                element.addEventListener(evt.mousedown, wheelDragStartHandler);
                element.rotationInterval = 360 / 16;
                //y|yyyy|yy|M|MM|d|dd|EEE|EEEE
                //k|kk|hh|h|H|HH|m|mm|s|ss|S|SS|SSS
                console.log(element.values, element.values.substring(0, 2) === 'dd', element.values.substring(0, 1) === 'd');
                if (element.values === 'M' || element.values === 'MM' || element.values === 'H' || element.values === 'HH') {
                    element.min = 1;
                    element.max = 12;
                } else if (element.values === 'h' || element.values === 'hh') {
                    element.min = 0;
                    element.max = 23;
                } else if (element.values === 'k' || element.values === 'kk') {
                    element.min = 0;
                    element.max = 23;
                } else if (element.values === 'm' || element.values === 'mm' || element.values === 'ss') {
                    element.min = 0;
                    element.max = 59;
                } else if (element.values[0] === 'd') {
                    element.min = 1;
                    element.max = element.values.length > 2 ? parseInt(element.values.substring(element.values.length - 2, element.values.length), 10) : 31;
                } else if (element.values === 'y') {
                    element.min = 0;
                    element.max = 99;
                } else if (element.values === 'yyyy') {
                    element.min = 0;
                    element.max = 10000;

                } else if (element.values === 'ampm') {
                    element.ampm = true;
                    element.rotation = 0;
                    element.wheel.setAttribute('style', 'transform: translateZ(-' + element.radius + ') rotateX(' + element.rotation + 'deg);');
                } else {
                    var arrValue = element.values.split('-');
                    element.min = arrValue[0];
                    element.max = arrValue[1];
                }

                wheelGenerateHTML(element);
            }
        }
    }

    xtag.register('gs-wheel', {
        lifecycle: {
            created: function () {
                wheelElementCreated(this);
            },

            inserted: function () {
                wheelElementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {

                }
            }
        },
        events: {},
        accessors: {
            value: {
                get: function () {
                    return this.getAttribute('value') || '0';
                },
                set: function (newValue) {
                    this.setAttribute('value', newValue);
                    wheelGenerateHTML(this);
                }
            }
        },
        methods: {}
    });
});


window.addEventListener('design-register-element', function () {
    'use strict';
    registerDesignSnippet('Dialog From Template', 'Dialog From Template', 'GS.openDialog(\'${1:templateID}\', function () {\n' +
                                                                          '    // after dialog open \n' +
                                                                          '}, function (event, strAnswer) {\n' +
                                                                          '    if (strAnswer === \'${2:Ok}\') {\n' +
                                                                          '        // before dialog close\n' +
                                                                          '        $0\n' +
                                                                          '    }\n' +
                                                                          '});');

    registerDesignSnippet('GS.openDialog', 'GS.openDialog', 'GS.openDialog(\'${1:templateID}\', function () {\n' +
                                                            '    // after dialog open \n' +
                                                            '}, function (event, strAnswer) {\n' +
                                                            '    if (strAnswer === \'${2:Ok}\') {\n' +
                                                            '        // beforedialog close\n' +
                                                            '        $0\n' +
                                                            '    }\n' +
                                                            '});');


    registerDesignSnippet('GS.closeDialog', 'GS.closeDialog', 'GS.closeDialog(${1:dialog}, ${2:\'Ok\'});');
    registerDesignSnippet('Close Dialog', 'Close Dialog', 'GS.closeDialog(${1:dialog}, ${2:\'Ok\'});');

    registerDesignSnippet('GS.msgbox', 'GS.msgbox', 'GS.msgbox(${1:\'Are you sure...\'}, ${2:\'Are you sure you want to do this?\'}, ' +
                                                                            '${3:[\'Cancel\', \'Ok\']}, function (strAnswer) {\n' +
                                                    '    if (strAnswer === ${4:\'Ok\'}) {\n' +
                                                    '        // before dialog close\n' +
                                                    '        $0\n' +
                                                    '    }\n' +
                                                    '});');
    registerDesignSnippet('Message Box', 'Message Box', 'GS.msgbox(${1:\'Are you sure...\'}, ${2:\'Are you sure you want to do this?\'}, ' +
                                                                                '${3:[\'Cancel\', \'Ok\']}, function (strAnswer) {\n' +
                                                        '    if (strAnswer === ${4:\'Ok\'}) {\n' +
                                                        '        // before dialog close\n' +
                                                        '        $0\n' +
                                                        '    }\n' +
                                                        '});');

    registerDesignSnippet('GS.inputbox', 'GS.inputbox', 'GS.inputbox(${1:\'Are you sure...\'}, ${2:\'Are you sure you want to do this?\'}, ' +
                                                                                'function (strInputValue) {\n' +
                                                        '    // before dialog close\n' +
                                                        '    $0\n' +
                                                        '});');
    registerDesignSnippet('Input Box', 'Input Box', 'GS.inputbox(${1:\'Are you sure...\'}, ${2:\'Are you sure you want to do this?\'}, ' +
                                                                            'function (strInputValue) {\n' +
                                                    '    // before dialog close\n' +
                                                    '    $0\n' +
                                                    '});');

    registerDesignSnippet('GS.openDialogToElement', 'GS.openDialogToElement',
                                        'GS.openDialogToElement(${1:document.getElementById(\'target\')}, \'${2:templateID}\', ' +
                                                                            '\'${3:right}\', function () {\n' +
                                        '    // after dialog open \n' +
                                        '}, function (event, strAnswer) {\n' +
                                        '    if (strAnswer === \'${4:Ok}\') {\n' +
                                        '        // beforedialog close\n' +
                                        '        $0\n' +
                                        '    }\n' +
                                        '});');
    registerDesignSnippet('Dialog For Element', 'Dialog For Element',
                                        'GS.openDialogToElement(${1:document.getElementById(\'target\')}, \'${2:templateID}\', ' +
                                                                            '\'${3:right}\', function () {\n' +
                                        '    // after dialog open \n' +
                                        '}, function (event, strAnswer) {\n' +
                                        '    if (strAnswer === \'${4:Ok}\') {\n' +
                                        '        // beforedialog close\n' +
                                        '        $0\n' +
                                        '    }\n' +
                                        '});');
});


(function () {
    'use strict';

    function buttonHTML(buttons) {
        var strHTML, i, len;

        buttons = buttons || ['Ok'];

        // change button parameter to array format if it is string format (and the string is recognized)
        if (typeof buttons === 'string') {
            if (buttons === 'okcancel' || buttons === 'cancelok') {
                buttons = ['Cancel', 'Ok'];

            } else if (buttons === 'ok' || buttons === 'okonly') {
                buttons = ['Ok'];

            } else if (buttons === 'cancel' || buttons === 'cancelonly') {
                buttons = ['Cancel'];

            } else if (buttons === 'yesno' || buttons === 'noyes') {
                buttons = ['No', 'Yes'];

            } else if (buttons === 'Yes' || buttons === 'yesonly') {
                buttons = ['Yes'];

            } else if (buttons === 'No' || buttons === 'noonly') {
                buttons = ['No'];
            }
        }

        if (typeof buttons === 'object') {
            if (buttons.length > 0) {
                strHTML = '<gs-grid gs-dynamic>';

                for (i = 0, len = buttons.length; i < len; i += 1) {
                    strHTML +=
                        '<gs-block gs-dynamic>' +
                            '<gs-button dialogclose ' + (i === len - 1 ? 'bg-primary listen-for-return' : '') + ' gs-dynamic>' +
                                encodeHTML(buttons[i]) +
                            '</gs-button>' +
                        '</gs-block>';
                }

                strHTML += '</gs-grid>';

            } else {
                strHTML = '<gs-button dialogclose>Done</gs-button>';
            }
        } else {
            strHTML = buttons;
        }

        return strHTML;
    }

    // GS.msgbox('test1', 'test2', ['cancel', 'ok'], function (strAnswer) { console.log(strAnswer); });
    GS.msgbox = function (strTitle, strMessage, buttons, callback) {
        var templateElement = document.createElement('template');

        templateElement.innerHTML = '<gs-page>' +
                                    '    <gs-header><center><h3>' + strTitle + '</h3></center></gs-header>' +
                                    '    <gs-body padded>' +
                                    '        ' + strMessage +
                                    '    </gs-body>' +
                                    '    <gs-footer>' + buttonHTML(buttons) + '</gs-footer>' +
                                    '</gs-page>';

        GS.openDialog(templateElement, '', function (event, strAnswer) {
            if (typeof callback === 'function') {
                callback(strAnswer);
            }
        });
    };

    // GS.inputbox('test1', 'test2', function (strAnswer) { console.log(strAnswer); });
    GS.inputbox = function (strTitle, strMessage, callback) {
        var templateElement = document.createElement('template');

        templateElement.innerHTML = '<gs-page>' +
                                    '    <gs-header><center><h3>' + strTitle + '</h3></center></gs-header>' +
                                    '    <gs-body padded>' +
                                    '        ' + strMessage +
                                    '        <gs-text id="dialog-inputbox-control"></gs-text>' +
                                    '    </gs-body>' +
                                    '    <gs-footer>' + buttonHTML(['Cancel', 'Ok']) + '</gs-footer>' +
                                    '</gs-page>';

        GS.openDialog(templateElement, '', function (event, strAnswer) {
            if (strAnswer === 'Ok') {
                callback(document.getElementById('dialog-inputbox-control').value);
            } else {
                callback('');
            }
        });
    };
})();

GS.dialogClose = function (dialog, strAnswer) {
    'use strict';
    console.warn('Please use "GS.closeDialog" instead of "GS.dialogClose".');
    dialog.destroy(strAnswer);
};

GS.closeDialog = function (dialog, strAnswer) {
    'use strict';

    if (typeof dialog === 'string') {
        dialog = document.getElementById('dialog-from-' + dialog);
    }

    if (dialog) {
        dialog.destroy(strAnswer);
    } else {
        console.warn('GS.closeDialog Warning: Dialog not found.');
    }
};

(function () {
    'use strict';

    // on focus: if the currently focus element is not in the frontmost dialog: focus first control of the frontmost dialog
    document.addEventListener('focus', function (event) {
        var arrDialog = xtag.queryChildren(document.body, 'gs-dialog[focus-lock]');
        var frontDialog;
        var parentFind;
        var arrElements;
        var i;
        var len;

        //console.log('1*** focus: ', document.activeElement, arrDialog);
        if (arrDialog.length > 0) {
            frontDialog = arrDialog[arrDialog.length - 1];
            parentFind = GS.findParentElement(document.activeElement, frontDialog);

            //console.log('2***', parentFind, frontDialog);
            if (parentFind !== frontDialog) {
                arrElements = xtag.query(frontDialog, 'input, textarea, select, button, iframe, [tabindex], a');

                for (i = 0, len = arrElements.length; i < len; i += 1) {
                    if (GS.isElementFocusable(arrElements[i])) {
                        arrElements[i].focus();
                        break;
                    }
                }
                //console.log('3***');
            }
        }
    }, true);

    // DEPRECATED
    GS.dialog = function (options) {
        var strHTML, dialogOverlay, dialog, strContent = '', strButtons = '', i, len, gridEach,
            arrElements, tapHandler, strHeader, sizingFunction, observer, returnTarget;

        // change button parameter to array format if it is string format (and the string is recognized)
        if (typeof options.buttons === 'string') {
            if (options.buttons === 'okcancel' || options.buttons === 'cancelok') {
                options.buttons = ['Cancel', 'Ok'];

            } else if (options.buttons === 'ok' || options.buttons === 'okonly') {
                options.buttons = ['Ok'];

            } else if (options.buttons === 'cancel' || options.buttons === 'cancelonly') {
                options.buttons = ['Cancel'];

            } else if (options.buttons === 'yesno' || options.buttons === 'noyes') {
                options.buttons = ['No', 'Yes'];

            } else if (options.buttons === 'Yes' || options.buttons === 'yesonly') {
                options.buttons = ['Yes'];

            } else if (options.buttons === 'No' || options.buttons === 'noonly') {
                options.buttons = ['No'];
            }
        }

        // option defaults
        options.theme      = options.theme        || 'regular';
        options.type       = options.type         || 'html';
        options.header     = options.header       || '';
        options.content    = options.content      || '';
        options.buttons    = options.buttons      || ['Ok']; // either array or string
        options.max_width  = options.max_width    || '700px';
        options.max_height = options.max_height   || '700px';
        options.mode       = options.mode         || 'detect'; // phone, touch, constrained, full, detect
        options.padded     = options.padded       || false;
        options.autofocus  = (options.autofocus === undefined ? true : false);

        // if type is html or, use content as is
        if (options.type === 'html') {
            strContent = options.content;
            strHeader = options.header;

        // if type is formatted-html, wrap content with a <pre>
        } else if (options.type === 'formatted-html') {
            strContent = '<pre gs-dynamic>' + options.content + '</pre>';
            strHeader = '<pre gs-dynamic>' + options.header + '</pre>';

        // if type is text, encode to be text only
        } else if (options.type === 'text') {
            strContent = encodeHTML(options.content);
            strHeader = encodeHTML(options.header);

        // if type is formatted-text, encode to be text only, and wrap with a <pre>
        } else if (options.type === 'formatted-text') {
            strContent = '<pre gs-dynamic>' + encodeHTML(options.content) + '</pre>';
            strHeader = '<pre gs-dynamic>' + encodeHTML(options.header) + '</pre>';

        // if type is unrecognized, use content as is
        } else {
            console.warn('Dialog type not recognized... Defaulting to \'html\'.');
            strContent = options.content;
            strHeader = options.header;
        }

        // if buttons is an array, build array into button html
        if (typeof options.buttons === 'object') {
            if (options.buttons.length > 0) {
                strButtons = '<gs-grid gs-dynamic>';

                for (i = 0, len = options.buttons.length; i < len; i += 1) {
                    strButtons +=
                        '<gs-block gs-dynamic>' +
                            '<gs-button dialogclose ' + (i === len - 1 ? 'bg-primary listen-for-return' : '') + ' gs-dynamic>' +
                                encodeHTML(options.buttons[i]) +
                            '</gs-button>' +
                        '</gs-block>';
                }
                strButtons += '</gs-grid>';
            } else {
                strButtons = '';
            }

        // if buttons is not an array, use as html
        } else {
            strButtons = options.buttons;
        }

        // append dialog overlay element
        dialogOverlay = GS.stringToElement('<gs-dialog-overlay gs-dynamic></gs-dialog-overlay>');
        document.body.appendChild(dialogOverlay);

        dialogOverlay.addEventListener(evt.mousedown, function (event) {
            event.preventDefault();
        });
        dialogOverlay.addEventListener(evt.mousemove, function (event) {
            event.preventDefault();
        });

        // build dialog html
        strHTML = '<gs-dialog class="' + encodeHTML(options.theme) + '" gs-dynamic focus-lock ';

        // if mode is set to phone or touch and we are not on those types of devices: change mode to detect
        if ((options.mode === 'touch' && !evt.touchDevice) || (options.mode === 'phone' && evt.deviceType !== 'phone')) {
            options.mode = 'detect';
        }

        // deal with full page mode
        if ((options.mode === 'touch' && evt.touchDevice) || (options.mode === 'phone' && evt.deviceType === 'phone') || options.mode === 'full') {
            strHTML += 'style="width: 100%; height: 100%; top: 0;">';

        } else if (options.mode === 'constrained') {
            strHTML += 'style="max-width: ' + options.max_width + '; max-height: ' + options.max_height + '; width: 94%; height: 90%;">';// auto
                             //width: ' + options.width + '; ' +
                             //'height: ' + options.height + '; ' +
                             //'top: ' + options.top + '; ' +
                             //'margin-left: -' + ((parseInt(options.width, 10) / 2) + options.width.replace(/[0-9]/g, '')) + ';">' +

        } else { // if (options.mode === 'constrained')
            strHTML += 'style="max-width: ' + options.max_width + '; width: 94%;">';
        }

        strHTML +=      '<gs-page gs-dynamic>' +
                            (options.header ? '<gs-header gs-dynamic>' + strHeader + '</gs-header>' : '') +
                            '<gs-body' + (options.padded ? ' padded' : '') + ' gs-dynamic>' + strContent + '</gs-body>' +
                           (strButtons ? '<gs-footer gs-dynamic>' + strButtons + '</gs-footer>' : '') +
                        '</gs-page>' +
                    '</gs-dialog>';

        // append dialog
        dialog = GS.stringToElement(strHTML);
        document.body.appendChild(dialog);
        document.body.parentNode.classList.add('no-scroll-except-for-dialog');

        // bind dialog
        dialog.addEventListener('beforeclose', function (event) {
            if (typeof options.before_close === 'function') {
                options.before_close.apply(dialog, [event.originalEvent, event.data]);
            }
        });
        dialog.addEventListener('afterclose', function (event) {
            if (typeof options.after_close === 'function') {
                options.after_close.apply(dialog, [event.originalEvent, event.data]);
            }
        });

        if (!template.hasAttribute('no-focus-lock')) {
            // focus autofocus element if there is one
            arrElements = xtag.query(dialog, '[autofocus]');

            if (arrElements.length > 0) {
                arrElements[0].focus();

            // else if there is a listen-for-return: focus that
            } else {
                arrElements = xtag.query(dialog, '[listen-for-return]');

                if (arrElements.length > 0) {
                    arrElements[0].focus();
                }
            }
        }

        // bind listening for return if there is an element with the "listen-for-return"
        arrElements = xtag.query(dialog, '[listen-for-return]');

        if (arrElements.length > 0) {
            returnTarget = arrElements[0];

            dialog.addEventListener('keydown', function (event) {
                if (event.target !== returnTarget && (event.keyCode === 13 || event.which === 13)) {
                    GS.triggerEvent(returnTarget, 'click');
                }
            });

            if (arrElements.length > 1) {
                console.warn('dialog Warning: Too many [listen-for-return] elements, defaulting to the first one. Please have only one [listen-for-return] element per dialog.');
            }
        }

        // if mode is detect: do/bind detection
        if (options.mode === 'detect') {
            sizingFunction = function () {
                if (dialog.parentNode !== document.body) {
                    window.removeEventListener('resize', sizingFunction);
                    window.removeEventListener('orientationchange', sizingFunction);
                    observer.disconnect();

                    return;
                }

                // if dialog is taller than 98% of the window: add max-height and height
                if (dialog.offsetHeight > ((window.innerHeight / 100) * 98)) {
                    dialog.style.height = '98%';
                    dialog.style.maxHeight = options.max_height;
                }
            };

            sizingFunction();

            window.addEventListener('resize', sizingFunction);
            window.addEventListener('orientationchange', sizingFunction);

            observer = new MutationObserver(sizingFunction);
            observer.observe(dialog, {childList: true, subtree: true, attributes: true});
        }

        // after open function call
        if (typeof options.after_open === 'function') {
            options.after_open.apply(dialog, []);
        }

        return dialog;
    };


    GS.openDialog = function (templateLink, afterOpenFunction, beforeCloseFunction, afterCloseFunction) {
        var template, templateID, strHTML, dialogOverlay, dialog, i, len, arrCloseButtons, clickHandler, sizingFunction,
            observer, arrElements, strTag, returnTarget, strTheme, strMaxWidth, strMaxHeight, strMode, refocusElement,
            scrollTarget, jsnInitalMousePos, scrollProtectorTouchStart, scrollProtectorTouchMove, scrollProtectorMouseWheel,
            strTag, xtagSelector, intervalID, intervalI;

        // get template
        if (typeof templateLink === 'string') {
            template = document.getElementById(templateLink);
        } else {
            template = templateLink;
        }
        if (template.innerHTML.indexOf('&gt;') > -1 || template.innerHTML.indexOf('&lt;') > -1) {
            console.warn('GS-DIALOG WARNING: &gt; or &lt; detected in dialog template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
        }

        // save and blur currently focused element
        refocusElement = document.activeElement;
        if (!template.hasAttribute('no-focus-lock')) {
            refocusElement.blur();
        }

        // save template ID
        templateID = template.getAttribute('id');

        // warn if a dialog already uses this ID
        if (templateID && document.getElementById('dialog-from-' + templateID)) {
            console.warn('GS.openDialog Warning: A dialog using the ID "' + templateID + '" is already open.');
        }

        // handle autofocus
        arrElements = xtag.query(template.content, '[autofocus]');

        // if there are not autofocus elements: add autofocus to first control in the template
        if (arrElements.length === 0) {
            arrElements = xtag.query(template.content, '*');

            if (arrElements.length > 0) {
                for (i = 0, len = arrElements.length; i < len; i += 1) {
                    strTag = arrElements[i].nodeName.toLowerCase();

                    if (GS.isElementFocusable(arrElements[i]) ||
                        (
                            xtag.tags[strTag] &&
                            xtag.tags[strTag].methods &&
                            xtag.tags[strTag].methods.focus
                        )) {
                        arrElements[i].setAttribute('autofocus', '');
                        break;
                    }
                }
            }

        // warn if there are too many autofocus elements
        } else if (arrElements.length > 1) {
            for (i = 1, len = arrElements.length; i < len; i += 1) {
                arrElements[i].removeAttribute('autofocus');
            }

            console.warn('dialog Warning: Too many [autofocus] elements, defaulting to the first one. Please have only one [autofocus] element per dialog.');
        }

        // get and default parameters
        strTheme     = (template.getAttribute('data-theme') === 'error' ? 'error' : 'regular');
        strMaxWidth  = template.getAttribute('data-max-width')  || '700px';
        strMaxHeight = template.getAttribute('data-max-height') || '700px';
        strMode      = template.getAttribute('data-mode')       || 'detect'; // phone, touch, constrained, full, detect

        // build full dialog html
        strHTML = '<gs-dialog ' + (templateID ? 'id="dialog-from-' + templateID + '" ' : '') + 'class="' + strTheme + '" gs-dynamic ';

        if (!template.hasAttribute('no-focus-lock')) {
            strHTML += 'focus-lock ';
        }

        // if mode is set to phone or touch and we are not on those types of devices: change mode to detect
        if ((strMode === 'touch' && !evt.touchDevice) || (strMode === 'phone' && evt.deviceType !== 'phone')) {
            strMode = 'detect';
        }

        // deal with full page mode
        if ((strMode === 'touch' && evt.touchDevice) || (strMode === 'phone' && evt.deviceType === 'phone') || strMode === 'full') {
            strHTML += 'style="width: 100%; height: 100%; top: 0;">';

        } else if (strMode === 'constrained') {
            strHTML += 'style="max-width: ' + strMaxWidth + '; max-height: ' + strMaxHeight + '; width: 94%; height: 90%;">';

        } else {
            strHTML += 'style="max-width: ' + strMaxWidth + '; width: 94%;">';
        }

        strHTML +=      '<gs-page gs-dynamic>' +
                            template.innerHTML +
                        '</gs-page>' +
                    '</gs-dialog>';

        // get elements
        dialogOverlay = GS.stringToElement(
            '<gs-dialog-overlay gs-dynamic' +
            (
                template.hasAttribute('no-background')
                    ? ' no-background '
                    : ''
            ) +
            '></gs-dialog-overlay>'
        );
        dialog = GS.stringToElement(strHTML);

        // append overlay element
        document.body.appendChild(dialogOverlay);

        // if the template has: data-overlay-close: bind overlay
        if (template.hasAttribute('data-overlay-close')) {
            dialogOverlay.addEventListener(evt.mousedown, function (event) {
                GS.closeDialog(dialog, 'overlay');
            });
        }

        // bind overlay element
        dialogOverlay.addEventListener(evt.mousedown, function (event) {
            event.preventDefault();
        });
        dialogOverlay.addEventListener(evt.mousemove, function (event) {
            event.preventDefault();
        });
        dialogOverlay.addEventListener('mousewheel', function (event) {
            event.preventDefault();
        });

        // append dialog
        document.body.appendChild(dialog);
        //document.body.parentNode.classList.add('no-scroll-except-for-dialog');

        // bind dialog
        scrollProtectorTouchStart = function (event) {
            if (dialog.parentNode !== document.body) {
                dialog.removeEventListener('touchstart', scrollProtectorTouchStart);
                return true;
            }

            scrollTarget = GS.scrollParent(event.target);

            //console.log(scrollTarget);

            if (!scrollTarget || !GS.findParentTag(scrollTarget, 'gs-dialog')) {
                scrollTarget = dialog;
            }

            //console.log(scrollTarget);

            jsnInitalMousePos = GS.mousePosition(event);
        };

        scrollProtectorTouchMove = function (event) {
            var jsnMousePos = GS.mousePosition(event), bolVertical, bolHorizontal;

            if (dialog.parentNode !== document.body) {
                dialog.removeEventListener('touchmove', scrollProtectorTouchMove);
                return true;
            }

            //console.log('2***', scrollTarget, jsnInitalMousePos, jsnMousePos);

            if (Math.abs(jsnInitalMousePos.top - jsnMousePos.top) > Math.abs(jsnInitalMousePos.left - jsnMousePos.left)) {
                bolVertical = true;
            } else {
                bolHorizontal = true;
            }

            //console.log(bolVertical, bolHorizontal);

            // if down  AND we are already at the top
            // if up    AND we are already at the bottom
            // if right AND we are already at the left
            // if left  AND we are already at the right

            if ((bolVertical && (
                    (jsnInitalMousePos.top < jsnMousePos.top && scrollTarget.scrollTop <= 0) ||
                    (jsnInitalMousePos.top > jsnMousePos.top &&
                        (scrollTarget.scrollTop + scrollTarget.clientHeight) >= scrollTarget.scrollHeight))) ||
                (bolHorizontal && (
                    (jsnInitalMousePos.left < jsnMousePos.left && scrollTarget.scrollLeft <= 0) ||
                    (jsnInitalMousePos.left > jsnMousePos.left &&
                        (scrollTarget.scrollLeft + scrollTarget.clientWidth) >= scrollTarget.scrollWidth)))) {
                event.preventDefault();
                event.stopPropagation();
            }
        };

        scrollProtectorMouseWheel = function (event) {
            var target = GS.scrollParent(event.target); //event.target;

            //console.log(target);

            if (dialog.parentNode !== document.body) {
                dialog.removeEventListener('mousewheel', scrollProtectorMouseWheel);
                return true;
            }

            //console.log(event.deltaY, event.deltaX,
            //            target.scrollTop, target.scrollLeft,
            //            target.scrollHeight, target.scrollWidth,
            //            target.clientHeight, target.clientWidth);

            // if event.deltaY < 0 AND we are already at the top
            // if event.deltaY > 0 AND we are already at the bottom
            // if event.deltaX < 0 AND we are already at the left
            // if event.deltaX > 0 AND we are already at the right

            if ((event.deltaY < 0 && target.scrollTop <= 0) ||
                (event.deltaY > 0 && (target.scrollTop + target.clientHeight) >= target.scrollHeight) ||
                (event.deltaX < 0 && target.scrollLeft <= 0) ||
                (event.deltaX > 0 && (target.scrollLeft + target.clientWidth) >= target.scrollWidth)) {
                //console.log('prevented');

                event.preventDefault();
                event.stopPropagation();
            }
        };

        if (evt.touchDevice) {
            window.addEventListener('touchstart', scrollProtectorTouchStart);
            window.addEventListener('touchmove', scrollProtectorTouchMove);
        }

        dialog.addEventListener('mousewheel', scrollProtectorMouseWheel);

        dialog.addEventListener('beforeclose', function (event) {
            if (typeof beforeCloseFunction === 'function') {
                beforeCloseFunction.apply(dialog, [event.originalEvent, event.data]);
            }
        });

        dialog.addEventListener('afterclose', function (event) {
            refocusElement.focus();
            if (typeof afterCloseFunction === 'function') {
                afterCloseFunction.apply(dialog, [event.originalEvent, event.data]);
            }
        });


        // if mode equals 'detect'
        //console.log(strMode);
        if (strMode === 'detect') {
            // do/bind size detection
            sizingFunction = function () {
                if (dialog.parentNode !== document.body) {
                    window.removeEventListener('resize', sizingFunction);
                    window.removeEventListener('orientationchange', sizingFunction);
                    observer.disconnect();

                    return;
                }

                // if dialog is taller than 98% of the window: add max-height and height
                if (dialog.offsetHeight > ((window.innerHeight / 100) * 98)) {
                    dialog.style.height = '98%';
                    dialog.style.maxHeight = strMaxHeight;
                }
            };

            sizingFunction();

            window.addEventListener('resize', sizingFunction);
            window.addEventListener('orientationchange', sizingFunction);

            observer = new MutationObserver(sizingFunction);
            observer.observe(dialog, {childList: true, subtree: true, attributes: true});
        }


        var elementReadyCallback = function () {
            if (!template.hasAttribute('no-focus-lock')) {
                // focus autofocus element if there is one
                arrElements = xtag.query(dialog, '[autofocus]');

                if (arrElements.length > 0) {
                    arrElements[0].focus();

                // else if there is a listen-for-return: focus that
                } else {
                    arrElements = xtag.query(dialog, '[listen-for-return]');

                    if (arrElements.length > 0) {
                        arrElements[0].focus();
                    }
                }
            }

            // bind listening for return if there is an element with the "listen-for-return"
            arrElements = xtag.query(dialog, '[listen-for-return]');

            if (arrElements.length > 0) {
                returnTarget = arrElements[0];

                dialog.addEventListener('keydown', function (event) { // keydown, keyup, keypress
                    if (event.target !== returnTarget && (event.keyCode === 13 || event.which === 13)) {
                        //event.stopPropagation();
                        GS.triggerEvent(returnTarget, 'click');
                    }
                });

                if (arrElements.length > 1) {
                    console.warn('dialog Warning: Too many [listen-for-return] elements, defaulting to the first one. Please have only one [listen-for-return] element per dialog.');
                }
            }

            if (typeof afterOpenFunction === 'function') {
                afterOpenFunction.apply(dialog, []);
            }
        };


        // get a list of all the xtag elements
        // if they are not all instantiated check: on an interval until they are all instantiated


        // if element registration is shimmed: we need to wait to run the callback
        //      until after the elements are ready. to do this we'll get a list of
        //      the current elements that are xtag-defined and on a 30ms loop we'll
        //      check their __upgraded__ property until they are all true
        if (shimmed.registerElement === true) {
            // build selector to get all xtag elements
            xtagSelector = '';
            for (strTag in xtag.tags) {
                xtagSelector += (xtagSelector ? ',' : '');
                xtagSelector += strTag;
            }

            // get all xtag elements
            var elem_wait = xtag.query(dialog, xtagSelector);
            var elem_i;
            var elem_len;

            // begin interval (max out at 1 second)
            intervalI = 0;
            intervalID = setInterval(function () {
                if (elem_wait.length === 0 || intervalI >= 30) {
                    clearInterval(intervalID);
                    elementReadyCallback();
                } else {
                    elem_i = 0;
                    elem_len = elem_wait.length;
                    while (elem_i < elem_len) {
                        if (elem_wait[elem_i].__upgraded__ === true) {
                            elem_wait.splice(elem_i, 1);
                            elem_i -= 1;
                            elem_len -= 1;
                        }
                        elem_i += 1;
                    }
                }
                intervalI += 1;
            }, 30);

        // else: element instantiation blocks JS execution until the elements
        //      are ready, so we don't need to wait to run the after open callback
        } else {
            elementReadyCallback();
        }


        //// after open function call
        //if (typeof afterOpenFunction === 'function') {
        //    if (dialog.inserted === true) {
        //        console.log('1***');
        //        afterOpenFunction.apply(dialog, []);
        //    } else {
        //        console.log('2***', new Date().getTime());
        //        dialog.addEventListener('dialog-inserted', function () {
        //            console.log('3***', new Date().getTime());
        //            afterOpenFunction.apply(dialog, []);
        //        });
        //    }
        //}

        return dialog;
    };

    GS.openDialogToElement = function (elementTarget, templateLink, strDirectionRequest, afterOpenFunction, beforeCloseFunction, afterCloseFunction) {
        'use strict';
        var positionHandlingFunction, jsnPositionData, divElement = document.createElement('div'), dialogElement, observer,
            intDialogResolvedWidth, intDialogResolvedHeight, strResolvedDirection, intMargin = 5, intElementMidPoint,
            intDialogMidPoint, i, len, arrTests, arrCloseButtons, clickHandler, arrElements, template, strTheme, strMaxWidth,
            strMaxHeight, strTag, dialogOverlay, refocusElement, jsnInitalMousePos, scrollTarget, returnTarget,
            scrollProtectorTouchStart, scrollProtectorTouchMove, scrollProtectorMouseWheel, templateID,
            strTag, xtagSelector, intervalID, intervalI;

        // get template
        if (typeof templateLink === 'string') {
            template = document.getElementById(templateLink);
        } else {
            template = templateLink;
        }

        // save and blur currently focused element
        refocusElement = document.activeElement;
        if (!template.hasAttribute('no-focus-lock')) {
            refocusElement.blur();
        }

        // save template ID
        templateID = template.getAttribute('id');

        // warn if a dialog already uses this ID
        if (templateID && document.getElementById('dialog-from-' + templateID)) {
            console.warn('GS.openDialog Warning: A dialog using the ID "' + templateID + '" is already open.');
        }

        // handle autofocus
        arrElements = xtag.query(template.content, '[autofocus]');

        // if there are not autofocus elements: add autofocus to first control in the template
        if (arrElements.length === 0) {
            arrElements = xtag.query(template.content, '*');

            if (arrElements.length > 0) {
                for (i = 0, len = arrElements.length; i < len; i += 1) {
                    strTag = arrElements[i].nodeName.toLowerCase();

                    if (GS.isElementFocusable(arrElements[i]) ||
                        (
                            xtag.tags[strTag] &&
                            xtag.tags[strTag].methods &&
                            xtag.tags[strTag].methods.focus
                        )) {
                        arrElements[i].setAttribute('autofocus', '');
                        break;
                    }
                }
            }

        // warn if there are too many autofocus elements
        } else if (arrElements.length > 1) {
            for (i = 1, len = arrElements.length; i < len; i += 1) {
                arrElements[i].removeAttribute('autofocus');
            }

            console.warn('dialog Warning: Too many [autofocus] elements, defaulting to the first one. Please have only one [autofocus] element per dialog.');
        }

        // get and default parameters
        strTheme     = (template.getAttribute('data-theme') === 'error' ? 'error' : 'regular');
        strMaxWidth  = template.getAttribute('data-max-width')  || '700px';
        strMaxHeight = template.getAttribute('data-max-height') || '700px';

        // create dialog element
        divElement.innerHTML =
            '<gs-dialog ' +
                    (
                        templateID
                            ? 'id="dialog-from-' + templateID + '" '
                            : ''
                    ) +
                    'class="' + strTheme + '" ' +
                    'style="width: 94%; max-width: ' + strMaxWidth + ';" ' +
                    'no-window-listen ' +
                    (
                        template.hasAttribute('no-focus-lock')
                            ? ''
                            : 'focus-lock '
                    ) +
                    'gs-dynamic>' +
                '<gs-page gs-dynamic>' +
                    template.innerHTML +
                '</gs-page>' +
            '</gs-dialog>';

        dialogElement = divElement.children[0];

        // append dialog overlay element to the body
        dialogOverlay = GS.stringToElement(
            '<gs-dialog-overlay gs-dynamic' +
                    (
                        template.hasAttribute('no-background')
                            ? ' no-background '
                            : ''
                    ) +
                '></gs-dialog-overlay>'
        );
        document.body.appendChild(dialogOverlay);

        // if the template has: data-overlay-close: bind overlay
        if (template.hasAttribute('data-overlay-close')) {
            dialogOverlay.addEventListener('click', function (event) {
                GS.closeDialog(dialogElement, 'overlay');
            });
        }

        // bind dialog overlay
        dialogOverlay.addEventListener('mousewheel', function (event) {
            event.preventDefault();
        });

        // append dialog element to the body
        document.body.appendChild(dialogElement);

        // bind dialog
        scrollProtectorTouchStart = function (event) {
            if (dialogElement.parentNode !== document.body) {
                dialogElement.removeEventListener('touchstart', scrollProtectorTouchStart);
                return true;
            }

            scrollTarget = GS.scrollParent(event.target);

            //console.log(scrollTarget);

            if (!scrollTarget || !GS.findParentTag(scrollTarget, 'gs-dialog')) {
                scrollTarget = dialogElement;
            }

            //console.log(scrollTarget);

            jsnInitalMousePos = GS.mousePosition(event);
        };

        scrollProtectorTouchMove = function (event) {
            var jsnMousePos = GS.mousePosition(event), bolVertical, bolHorizontal;

            if (dialogElement.parentNode !== document.body) {
                dialogElement.removeEventListener('touchmove', scrollProtectorTouchMove);
                return true;
            }

            //console.log('2***', scrollTarget, jsnInitalMousePos, jsnMousePos);

            if (Math.abs(jsnInitalMousePos.top - jsnMousePos.top) > Math.abs(jsnInitalMousePos.left - jsnMousePos.left)) {
                bolVertical = true;
            } else {
                bolHorizontal = true;
            }

            //console.log(bolVertical, bolHorizontal);

            // if down  AND we are already at the top
            // if up    AND we are already at the bottom
            // if right AND we are already at the left
            // if left  AND we are already at the right

            if ((bolVertical && (
                    (jsnInitalMousePos.top < jsnMousePos.top && scrollTarget.scrollTop <= 0) ||
                    (jsnInitalMousePos.top > jsnMousePos.top &&
                        (scrollTarget.scrollTop + scrollTarget.clientHeight) >= scrollTarget.scrollHeight))) ||
                (bolHorizontal && (
                    (jsnInitalMousePos.left < jsnMousePos.left && scrollTarget.scrollLeft <= 0) ||
                    (jsnInitalMousePos.left > jsnMousePos.left &&
                        (scrollTarget.scrollLeft + scrollTarget.clientWidth) >= scrollTarget.scrollWidth)))) {
                event.preventDefault();
                event.stopPropagation();
            }
        };

        scrollProtectorMouseWheel = function (event) {
            var target = GS.scrollParent(event.target); //event.target;

            if (dialogElement.parentNode !== document.body) {
                dialogElement.removeEventListener('mousewheel', scrollProtectorMouseWheel);
                return true;
            }

            //console.log(event.deltaY, event.deltaX,
            //            target.scrollTop, target.scrollLeft,
            //            target.scrollHeight, target.scrollWidth,
            //            target.clientHeight, target.clientWidth);

            // if event.deltaY < 0 AND we are already at the top
            // if event.deltaY > 0 AND we are already at the bottom
            // if event.deltaX < 0 AND we are already at the left
            // if event.deltaX > 0 AND we are already at the right

            if ((event.deltaY < 0 && target.scrollTop <= 0) ||
                (event.deltaY > 0 && (target.scrollTop + target.clientHeight) >= target.scrollHeight) ||
                (event.deltaX < 0 && target.scrollLeft <= 0) ||
                (event.deltaX > 0 && (target.scrollLeft + target.clientWidth) >= target.scrollWidth)) {
                event.preventDefault();
                event.stopPropagation();
            }
        };

        if (evt.touchDevice) {
            window.addEventListener('touchstart', scrollProtectorTouchStart);
            window.addEventListener('touchmove', scrollProtectorTouchMove);
        }

        dialogElement.addEventListener('mousewheel', scrollProtectorMouseWheel);

        dialogElement.addEventListener('beforeclose', function (event) {
            if (typeof beforeCloseFunction === 'function') {
                beforeCloseFunction.apply(dialogElement, [event.originalEvent, event.data]);
            }
        });
        dialogElement.addEventListener('afterclose', function (event) {
            refocusElement.focus();
            if (typeof afterCloseFunction === 'function') {
                afterCloseFunction.apply(dialogElement, [event.originalEvent, event.data]);
            }
        });

        if (!template.hasAttribute('no-focus-lock')) {
            // focus autofocus element if there is one
            arrElements = xtag.query(dialogElement, '[autofocus]');

            if (arrElements.length > 0) {
                arrElements[0].focus();

            // else if there is a listen-for-return: focus that
            } else {
                arrElements = xtag.query(dialogElement, '[listen-for-return]');

                if (arrElements.length > 0) {
                    arrElements[0].focus();
                }
            }
        }

        // bind listening for return if there is an element with the "listen-for-return"
        arrElements = xtag.query(dialogElement, '[listen-for-return]');

        if (arrElements.length > 0) {
            returnTarget = arrElements[0];

            dialogElement.addEventListener('keydown', function (event) {
                if (event.target !== returnTarget && (event.keyCode === 13 || event.which === 13)) {
                    GS.triggerEvent(returnTarget, 'click');
                }
            });

            if (arrElements.length > 1) {
                console.warn('dialog Warning: Too many [listen-for-return] elements, defaulting to the first one. Please have only one [listen-for-return] element per dialog.');
            }
        }

        // if no direction was sent: set direction to down
        strDirectionRequest = strDirectionRequest || 'down';

        // make strDirectionRequest lowercase
        strDirectionRequest.toLowerCase();

        // if the direction does not match any valid direction: set direction to down and warn
        if (!strDirectionRequest.match(/^up$|^down$|^left$|^right$|^full$/)) {
            console.warn('GS.openDialogToElement Error: ' +
                                'Direction \'' + strDirectionRequest + '\' not recognized. ' +
                                'Please use \'up\', \'down\', \'left\', \'right\' or \'full\'.');
            strDirectionRequest = 'down';
        }

        positionHandlingFunction = function () {
            var intDialogTop = '', intDialogLeft = '', intDialogMarginTop = '', intDialogMarginLeft = '', strOldStyle,
                arrElements, arrScrollingElements, i, len, strOverflow;

            // if the dialog is not in the DOM: unbind and skip the contents of the function using return
            if (dialogElement.parentNode !== document.body) {
                window.removeEventListener('resize', positionHandlingFunction);
                window.removeEventListener('orientationchange', positionHandlingFunction);
                observer.disconnect();
                return;
            }

            // save old style attribute
            strOldStyle = dialogElement.getAttribute('style');

            // save scroll numbers
            arrElements = xtag.query(dialogElement, '*');
            arrScrollingElements = [];

            for (i = 0, len = arrElements.length; i < len; i += 1) {
                strOverflow = GS.getStyle(arrElements[i], 'overflow');

                if (strOverflow === 'scroll' ||
                    (strOverflow === 'auto' && arrElements[i].clientHeight < arrElements[i].scrollHeight)) {
                    arrScrollingElements.push(arrElements[i]);
                }
            }

            for (i = 0, len = arrScrollingElements.length; i < len; i += 1) {
                arrScrollingElements[i].oldScrollTop = arrScrollingElements[i].scrollTop;
                arrScrollingElements[i].oldScrollLeft = arrScrollingElements[i].scrollLeft;
            }

            // clear dialog CSS
            dialogElement.style.top        = '';
            dialogElement.style.left       = '';
            dialogElement.style.marginTop  = '';
            dialogElement.style.marginLeft = '';
            dialogElement.style.width      = '94%';
            dialogElement.style.height     = '';
            dialogElement.style.maxHeight  = '';

            //console.log(dialogElement.oldHeight, dialogElement.offsetHeight);

            // if height hasn't changed: restore style
            if (dialogElement.oldHeight === dialogElement.offsetHeight) {
                dialogElement.setAttribute('style', strOldStyle);

                for (i = 0, len = arrScrollingElements.length; i < len; i += 1) {
                    arrScrollingElements[i].scrollTop = arrScrollingElements[i].oldScrollTop;
                    arrScrollingElements[i].scrollLeft = arrScrollingElements[i].oldScrollLeft;
                }

            // else: recalculate style
            } else {
                dialogElement.oldHeight = dialogElement.offsetHeight;

                // resolve dialog width and height

                // if dialog is taller than: window height - (intMargin * 2): add max-height and height
                if (dialogElement.clientHeight > ((window.innerHeight / 100) * 94)) {
                    dialogElement.style.height = '94%';
                    dialogElement.style.maxHeight = strMaxHeight;
                }

                intDialogResolvedWidth  = dialogElement.offsetWidth;
                intDialogResolvedHeight = dialogElement.offsetHeight + 1; // + 1 added to fix occasional scrollbar issue

                // set dialog width and height to resolved width and height
                dialogElement.style.width  = intDialogResolvedWidth  + 'px';
                dialogElement.style.height = intDialogResolvedHeight + 'px';

                // get target position data
                jsnPositionData = GS.getElementPositionData(elementTarget);

                // order of tests depending on direction
                if (strDirectionRequest === 'up') { // up: up, down, left, right, full
                    arrTests = ['up', 'down', 'left', 'right'];

                } else if (strDirectionRequest === 'down') { // down: down, up, left, right, full
                    arrTests = ['down', 'up', 'left', 'right'];

                } else if (strDirectionRequest === 'left') { // left: left, right, down, up, full
                    arrTests = ['left', 'right', 'down', 'up'];

                } else if (strDirectionRequest === 'right') { // right: right, left, down, up, full
                    arrTests = ['right', 'left', 'down', 'up'];

                } else { // full: no tests (just go to full)
                    arrTests = [];
                }

                // up: compare room above to dialog resolved height
                //      pass: display
                //      fail: next test
                for (i = 0, len = arrTests.length; i < len; i += 1) {
                    if ((arrTests[i] ===    'up' && (intDialogResolvedHeight + intMargin) <= jsnPositionData.intRoomAbove) ||
                        (arrTests[i] ===  'down' && (intDialogResolvedHeight + intMargin) <= jsnPositionData.intRoomBelow) ||
                        (arrTests[i] ===  'left' && (intDialogResolvedWidth  + intMargin) <=  jsnPositionData.intRoomLeft) ||
                        (arrTests[i] === 'right' && (intDialogResolvedWidth  + intMargin) <= jsnPositionData.intRoomRight)) {
                        strResolvedDirection = arrTests[i];
                        break;
                    }
                }

                // if we could not resolve to a particular direction: set direction to full screen
                strResolvedDirection = strResolvedDirection || 'full';
                //console.log(strResolvedDirection);

                // if up or down: get as close to horizontally centered on the element as possible
                if (strResolvedDirection === 'up' || strResolvedDirection === 'down') {
                    intElementMidPoint = (jsnPositionData.intElementLeft + (jsnPositionData.intElementWidth / 2));
                    intDialogMidPoint = (intDialogResolvedWidth / 2);
                    //console.log(intElementMidPoint, jsnPositionData.left, jsnPositionData.intElementWidth);

                    // if centered goes past intMargin of the left edge of the screen: go to intMargin from the bottom
                    if (intElementMidPoint - intDialogMidPoint < intMargin) {
                        intDialogLeft = intMargin;
                        //console.log('1***', intMargin);

                    // else if centered goes past intMargin of the right edge of the screen: go to intMargin less than the width of the viewport
                    } else if (intElementMidPoint + intDialogMidPoint > window.innerWidth - intMargin) {
                        intDialogLeft = ((window.innerWidth - intDialogResolvedWidth) - intMargin);
                        //console.log('2***', window.innerWidth, intDialogResolvedWidth, intMargin);

                    // else centered does not go past intMargin of either edge of the screen: center
                    } else {
                        intDialogLeft = (intElementMidPoint - intDialogMidPoint);
                        //console.log('3***', intElementMidPoint, intDialogMidPoint, (intElementMidPoint - intDialogMidPoint) + 'px');
                    }

                // else if left or right: get as close to vertically centered next to the element as possible
                } else if (strResolvedDirection === 'left' || strResolvedDirection === 'right') {
                    intElementMidPoint = (jsnPositionData.intElementTop + (jsnPositionData.intElementHeight / 2));
                    intDialogMidPoint = (intDialogResolvedHeight / 2);

                    //console.log('0***', intElementMidPoint, intDialogMidPoint, window.innerHeight, intMargin, intDialogResolvedHeight);

                    // if centered goes past intMargin of the top edge of the screen: go to intMargin from the bottom
                    if (intElementMidPoint - intDialogMidPoint < intMargin) {
                        intDialogTop = intMargin;
                        //console.log('1***', intMargin);

                    // else if centered goes past intMargin of the bottom edge of the screen: go to intMargin less than the height of the viewport
                    } else if (intElementMidPoint + intDialogMidPoint > window.innerHeight - intMargin) {
                        intDialogTop = ((window.innerHeight - intDialogResolvedHeight) - intMargin);
                        //console.log('2***', window.innerHeight, intDialogResolvedHeight, intMargin);

                    // else centered does not go past intMargin of either edge of the screen: center
                    } else {
                        intDialogTop = (intElementMidPoint - intDialogMidPoint);
                        //console.log('3***', intElementMidPoint, intDialogMidPoint, (intElementMidPoint - intDialogMidPoint) + 'px');
                    }

                // else full: use dialog logic to get width and height and center both vertically and horizontally
                } else {
                    intDialogTop        = '50%';
                    intDialogLeft       = '50%';
                    intDialogMarginTop  = '-' + (intDialogResolvedHeight / 2) + 'px';
                    intDialogMarginLeft = '-' + (intDialogResolvedWidth / 2) + 'px';
                }

                // if direction is up: connect the bottom of the dialog to the top of the element
                if (strResolvedDirection === 'up') {
                    intDialogTop = (jsnPositionData.intElementTop - intDialogResolvedHeight);

                // if direction is down: connect the top of the dialog to the bottom of the element
                } else if (strResolvedDirection === 'down') {
                    intDialogTop = (jsnPositionData.intElementTop + jsnPositionData.intElementHeight);

                // if direction is left: connect the right of the dialog to the left of the element
                } else if (strResolvedDirection === 'left') {
                    intDialogLeft = (jsnPositionData.intElementLeft - intDialogResolvedWidth);

                // if direction is right: connect the left of the dialog to the right of the element
                } else if (strResolvedDirection === 'right') {
                    intDialogLeft = (jsnPositionData.intElementLeft + jsnPositionData.intElementWidth);
                }

                // prevent the dialog from vertically going outside the viewport
                if (intDialogTop + intDialogResolvedHeight > window.innerHeight) {
                    intDialogTop -= (intDialogTop + intDialogResolvedHeight) - window.innerHeight;

                }

                // prevent the dialog from horizontally going outside the viewport
                if (intDialogLeft + intDialogResolvedWidth > window.innerWidth) {
                    intDialogLeft -= (intDialogLeft + intDialogResolvedWidth) - window.innerWidth;
                }

                // apply CSS to the dialog
                dialogElement.style.top        = intDialogTop + 'px';
                dialogElement.style.left       = intDialogLeft + 'px';
                dialogElement.style.marginTop  = intDialogMarginTop + 'px';
                dialogElement.style.marginLeft = intDialogMarginLeft + 'px';
            }
        };

        positionHandlingFunction();
        window.addEventListener('resize', positionHandlingFunction);
        window.addEventListener('orientationchange', positionHandlingFunction);

        // observer: on childlist update: recalculate positioning/sizing
        observer = new MutationObserver(positionHandlingFunction);

        // the observer is on "dialogElement.children[0]" because when we refresh the position of the dialog:
        //      the "style" attribute is changed which causes the observer to run again ergo: infinite loop
        observer.observe(dialogElement.children[0], {childList: true, subtree: true, attributes: true});


        var elementReadyCallback = function () {
            if (!template.hasAttribute('no-focus-lock')) {
                // focus autofocus element if there is one
                arrElements = xtag.query(dialogElement, '[autofocus]');

                if (arrElements.length > 0) {
                    arrElements[0].focus();

                // else if there is a listen-for-return: focus that
                } else {
                    arrElements = xtag.query(dialogElement, '[listen-for-return]');

                    if (arrElements.length > 0) {
                        arrElements[0].focus();
                    }
                }
            }

            // bind listening for return if there is an element with the "listen-for-return"
            arrElements = xtag.query(dialogElement, '[listen-for-return]');

            if (arrElements.length > 0) {
                returnTarget = arrElements[0];

                dialogElement.addEventListener('keydown', function (event) { // keydown, keyup, keypress
                    if (event.target !== returnTarget && (event.keyCode === 13 || event.which === 13)) {
                        //event.stopPropagation();
                        GS.triggerEvent(returnTarget, 'click');
                    }
                });

                if (arrElements.length > 1) {
                    console.warn('dialog Warning: Too many [listen-for-return] elements, defaulting to the first one. Please have only one [listen-for-return] element per dialog.');
                }
            }

            if (typeof afterOpenFunction === 'function') {
                afterOpenFunction.apply(dialogElement, []);
            }
        };

        // if element registration is shimmed: we need to wait to run the callback
        //      until after the elements are ready. to do this we'll get a list of
        //      the current elements that are xtag-defined and on a 30ms loop we'll
        //      check their __upgraded__ property until they are all true
        if (shimmed.registerElement === true) {
            // build selector to get all xtag elements
            xtagSelector = '';
            for (strTag in xtag.tags) {
                xtagSelector += (xtagSelector ? ',' : '');
                xtagSelector += strTag;
            }

            // get all xtag elements
            var elem_wait = xtag.query(dialogElement, xtagSelector);
            var elem_i;
            var elem_len;

            // begin interval (max out at 1 second)
            intervalI = 0;
            intervalID = setInterval(function () {
                if (elem_wait.length === 0 || intervalI >= 30) {
                    clearInterval(intervalID);
                    elementReadyCallback();
                } else {
                    elem_i = 0;
                    elem_len = elem_wait.length;
                    while (elem_i < elem_len) {
                        if (elem_wait[elem_i].__upgraded__ === true) {
                            elem_wait.splice(elem_i, 1);
                            elem_i -= 1;
                            elem_len -= 1;
                        }
                        elem_i += 1;
                    }
                }
                intervalI += 1;
            }, 30);

        // else: element instantiation blocks JS execution until the elements
        //      are ready, so we don't need to wait to run the after open callback
        } else {
            elementReadyCallback();
        }

        //// after open function call
        //if (typeof afterOpenFunction === 'function') {
        //    afterOpenFunction.apply(dialogElement, []);
        //}

        return dialogElement;
    };
})();

(function () {
    'use strict';
    xtag.register('gs-dialog', {
        lifecycle: {
            created: function () {
                if (this.hasAttribute('focus-lock')) {
                    document.body.focus();
                }

                //document.body.parentNode.classList.add('no-scroll-except-for-dialog');
            },

            inserted: function () {
                if (this.inserted !== true) {
                    this.inserted = true;

                    if (!this.hasAttribute('no-window-listen')) {
                        this.bind();

                        this.windowResizeHandler();
                    }

                    this.addEventListener('click', function (event) {
                        var dialogcloseElement = GS.findParentElement(event.target, '[dialogclose]');

                        if (dialogcloseElement && event.target.hasAttribute('dialogclose')) {
                            GS.findParentTag(event.target, 'gs-dialog')
                                .destroy(dialogcloseElement.textContent, event);
                        }
                    });

                    GS.triggerEvent(this, 'dialog-inserted');
                }
            },

            removed: function () {
                this.unbind();
            }
        },
        events: {
            //'click:delegate([dialogclose])': function (event) {
            //    var dialogcloseElement = GS.findParentElement(event.target, '[dialogclose]');
            //    console.log('running...');
            //    GS.findParentTag(event.target, 'gs-dialog')
            //            .destroy(dialogcloseElement.textContent, event);
            //}
        },
        accessors: {},
        methods: {
            bind: function () {
                var element = this;

                if (!element.hasAttribute('no-window-listen')) {
                    element.windowResizeHandler = function () {
                        element.style.left = (window.innerWidth / 2) - (element.offsetWidth / 2) + 'px';
                    };

                    window.addEventListener('resize', element.windowResizeHandler);
                    window.addEventListener('orientationchange', element.windowResizeHandler);
                }
            },

            unbind: function () {
                window.removeEventListener('resize', this.windowResizeHandler);
                window.removeEventListener('orientationchange', this.windowResizeHandler);

                GS.triggerEvent(window, 'resize');
            },

            destroy: function (strAnswer, originalEvent) {
                var beforeCloseEvent;

                if (this.parentNode === document.body) {
                    beforeCloseEvent = GS.triggerEvent(this, 'beforeclose', {'data': strAnswer, 'originalEvent': originalEvent});

                    if (!beforeCloseEvent.defaultPrevented && (!originalEvent || !originalEvent.defaultPrevented)) {
                        document.body.removeChild(this.previousElementSibling);
                        document.body.removeChild(this);

                        GS.triggerEvent(this, 'afterclose', {'data': strAnswer, 'originalEvent': originalEvent});

                        if (document.getElementsByTagName('gs-dialog').length === 0) {
                            document.body.parentNode.classList.remove('no-scroll-except-for-dialog');
                        }
                    }
                }
            }
        }
    });

    xtag.register('gs-dialog-overlay', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {}
    });
})();window.addEventListener('design-register-element', function (event) {
    'use strict';

    registerDesignSnippet('<gs-envelope>', '<gs-envelope>', 'gs-envelope src="${1:test.tpeople}">\n' +
                                                            '    <template for="hud"></template>\n' +
                                                            '    <template for="table">\n' +
                                                            '        <table>\n' +
                                                            '            <tbody>\n' +
                                                            '                <tr>\n' +
                                                            '                    <th heading="#"><gs-static column="row_number"></gs-static></th>\n' +
                                                            '                    <td heading="">$0</td>\n' +
                                                            '                </tr>\n' +
                                                            '            </tbody>\n' +
                                                            '        </table>\n' +
                                                            '    </template>\n' +
                                                            '    <template for="insert"></template>\n' +
                                                            '</gs-envelope>');

    designRegisterElement('gs-envelope', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-envelope.html');

    window.designElementProperty_GSENVELOPE = function (selectedElement) {
        var intIdNumber = (Math.floor(Math.random() * 1000)) + (Math.floor(new Date().getTime() / (Math.random() * 100000)));

        addProp('Source', true,
                '<gs-memo class="target" autoresize rows="1" value="' + encodeHTML(decodeURIComponent(selectedElement.getAttribute('src') ||
                                                                        selectedElement.getAttribute('source') || '')) + '" mini></gs-memo>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'src', encodeURIComponent(this.value));
        });

        addProp('Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('cols') || '') + '" mini></gs-text>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'cols', this.value);
        });

        addProp('Where', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('where') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'where', this.value);
        });

        addProp('Order By', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('ord') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'ord', this.value);
        });

        addProp('Limit', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('limit') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'limit', this.value);
        });

        addProp('Offset', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('offset') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'offset', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Parent&nbsp;Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Line Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('child-column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'child-column', this.value);
        });

        addProp('Reflow At', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('reflow-at') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'reflow-at', this.value);
        });

        addProp('Scroll To Bottom', true, '<gs-checkbox class="target" value="' + encodeHTML(selectedElement.hasAttribute('scroll-to-bottom') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'scroll-to-bottom', (this.value === 'true'), true);
        });

        addProp('HUD Orderby', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-hudorderby')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-hudorderby', (this.value === 'true'), false);
        });

        addProp('HUD Limit', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-hudlimit')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-hudlimit', (this.value === 'true'), false);
        });

        addProp('HUD Refresh', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-hudrefresh')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-hudrefresh', (this.value === 'true'), false);
        });

        addProp('HUD Delete', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-huddelete')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-huddelete', (this.value === 'true'), false);
        });

        addProp('Expand&nbsp;To&nbsp;Content', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('expand-to-content')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'expand-to-content', (this.value === 'true'), true);
        });

        addProp('Primary Keys', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('primary-keys') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'primary-keys', this.value);
        });

        addProp('Select Action', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('action-select') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'action-select', this.value);
        });

        addProp('Insert Action', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('action-insert') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'action-insert', this.value);
        });

        addProp('Update Action', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('action-update') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'action-update', this.value);
        });

        addProp('Delete Action', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('action-delete') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'action-delete', this.value);
        });

        // Disable insert/update
        addProp('Disable Insert', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-insert') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-insert', this.value === 'true', true);
        });

        addProp('Disable Update', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-update') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-update', this.value === 'true', true);
        });

        // TEMPLATE attribute
        addProp('Record Template', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('template') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'template', this.value);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        addProp('Refresh On Querystring Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('refresh-on-querystring-values') || '') + '" mini></gs-text>', function () {
            this.removeAttribute('refresh-on-querystring-change');
            return setOrRemoveTextAttribute(selectedElement, 'refresh-on-querystring-values', this.value);
        });

        addProp('Refresh On Querystring Change', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('refresh-on-querystring-change')) + '" mini></gs-checkbox>', function () {
            this.removeAttribute('refresh-on-querystring-values');
            return setOrRemoveBooleanAttribute(selectedElement, 'refresh-on-querystring-change', this.value === 'true', true);
        });

        //// SUSPEND-CREATED attribute
        //addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
        //    return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        //});

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    // ####################################################################
    // ############################## LOADER ##############################
    // ####################################################################

    function addLoader(element, strText) {
        element.loaderContainer = GS.stringToElement('<div class="loader-container" style="top: ' + element.scrollContainerElement.scrollTop + 'px;"></div>');
        element.scrollContainerElement.appendChild(element.loaderContainer);

        GS.addLoader(element.loaderContainer, strText);
    }

    function removeLoader(element) {
        if (element.loaderContainer && element.loaderContainer.parentNode === element.scrollContainerElement) {
            element.scrollContainerElement.removeChild(element.loaderContainer);
        }
        GS.removeLoader(element.loaderContainer);
    }

    // ###################################################################
    // ########################## DRAG HANDLING ##########################
    // ###################################################################

    function selectHandler(element, dragOrigin, dragCurrentCell, dragMode) {
        var bolThead, bolFirstTh, arrRecords, arrCells, arrRecordsToAffect = [], arrCellsToAffect = [],
            arrNewSelection = [], arrCellsToRemoveFromSelection = [], i, len, intFrom, intTo;

        arrRecords = xtag.query(element.scrollContainerElement, 'tr');
        arrCells = xtag.query(element.scrollContainerElement, 'td, th');

        if (arrRecords.length > 0) {
            bolThead = Boolean(element.theadElement);

            if ((bolThead && arrRecords.length > 1) || (!bolThead && arrRecords > 0)) {
                if (bolThead) {
                    bolFirstTh = arrRecords[1].children[0].nodeName === 'TH';
                } else {
                    bolFirstTh = arrRecords[0].children[0].nodeName === 'TH';
                }
            }

            // if origin & currentCell are both the top-left cell and the cell is a heading: select all cells
            if (bolThead && bolFirstTh &&
                dragOrigin.parentNode.rowIndex === 0 && dragCurrentCell.parentNode.rowIndex === 0 &&
                dragOrigin.cellIndex === 0 && dragCurrentCell.cellIndex === 0) {
                arrCellsToAffect = arrCells;

            // else if origin & currentCell are both first ths: select the records from origin to currentCell
            } else if (bolFirstTh && dragOrigin.cellIndex === 0 && dragCurrentCell.cellIndex === 0) {
                arrRecordsToAffect =
                    arrRecords.slice(Math.min(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex),
                                     Math.max(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex) + 1);

                for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
                    Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children));
                }

            // else if origin & currentCell are both headings: select the columns from origin to currentCell
            } else if (bolThead && dragOrigin.parentNode.rowIndex === 0 && dragCurrentCell.parentNode.rowIndex === 0) {
                intFrom = Math.min(dragOrigin.cellIndex, dragCurrentCell.cellIndex);
                intTo   = Math.max(dragOrigin.cellIndex, dragCurrentCell.cellIndex) + 1;

                for (i = 0, len = arrRecords.length; i < len; i += 1) {
                    Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecords[i].children).slice(intFrom, intTo));
                }

            //// else if origin & currentCell are the same cell: select the record
            //} else if (dragOrigin === dragCurrentCell) {
            //    arrRecordsToAffect = arrRecords.slice(dragOrigin.parentNode.rowIndex, dragOrigin.parentNode.rowIndex + 1);
            //
            //    for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
            //        Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children));
            //    }

            // else select cells from origin to currentCell
            } else {
                arrRecordsToAffect =
                    arrRecords.slice(Math.min(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex),
                                     Math.max(dragOrigin.parentNode.rowIndex, dragCurrentCell.parentNode.rowIndex) + 1);

                intFrom = Math.min(dragOrigin.cellIndex, dragCurrentCell.cellIndex);
                intTo   = Math.max(dragOrigin.cellIndex, dragCurrentCell.cellIndex) + 1;

                for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
                    Array.prototype.push.apply(arrCellsToAffect, xtag.toArray(arrRecordsToAffect[i].children).slice(intFrom, intTo));
                }
            }

            if (dragOrigin !== dragCurrentCell) {
                element.scrollContainerElement.removeAttribute('allow-text-selection');
                element.copyFocusTargetElement.focus();
                GS.setInputSelection(element.copyFocusTargetElement, 0, 'firefox...'.length);
            } else {
                element.scrollContainerElement.setAttribute('allow-text-selection', '');
            }

            if (dragMode === 'select') {

                // add new cells to element.selectionSelectedCells
                for (i = 0, len = element.selectionSelectedCells.length; i < len; i += 1) {
                    if (arrCellsToAffect.indexOf(element.selectionSelectedCells[i]) === -1) {
                        arrCellsToRemoveFromSelection.push(element.selectionSelectedCells[i]);
                    }
                }
                element.selectionSelectedCells = arrCellsToAffect;

                // add new cells to element.selectedCells
                arrNewSelection = element.selectedCells;
                for (i = 0, len = arrCellsToAffect.length; i < len; i += 1) {
                    GS.listAdd(arrNewSelection, arrCellsToAffect[i]);
                }
                for (i = 0, len = arrCellsToRemoveFromSelection.length; i < len; i += 1) {
                    arrNewSelection.splice(arrNewSelection.indexOf(arrCellsToRemoveFromSelection[i]), 1);
                }
                element.selectedCells = arrNewSelection;

                //element.selectionSelectedCells = arrCellsToAffect;
                //element.selectedCells = arrCellsToAffect;

            } else { // implied if: dragMode === 'deselect'
                // deselect cells from arrCellsToAffect
                arrNewSelection = element.selectedCells;

                for (i = 0, len = arrCellsToAffect.length; i < len; i += 1) {
                    if (arrNewSelection.indexOf(arrCellsToAffect[i]) > -1) {
                        arrNewSelection.splice(arrNewSelection.indexOf(arrCellsToAffect[i]), 1);
                    }
                }
                element.selectedCells = arrNewSelection;
            }
        }
    }

    // #######################################################################
    // ############################ DATA HANDLING ############################
    // #######################################################################


    // get data and send it off to be templated
    function getData(element) {
        element.refreshing = true;
        var strSrc     = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') || element.getAttribute('source') || ''))
          , srcParts   = strSrc[0] === '(' ? [strSrc, ''] : strSrc.split('.')
          , strSchema  = srcParts[0]
          , strObject  = srcParts[1]
          , strWhere   = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('where') || ''))
          , strOrd     = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('ord') || ''))
          , strLimit   = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('limit') || ''))
          , strOffset  = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('offset') || ''))
          , response_i = 0, response_len = 0, arrTotalRecords = [], strWhereColumn
          , i, len;

        // if there is a column attribute on element: combine the where attribute with a where generated by value
        if ((element.getAttribute('column') || element.getAttribute('qs')) && element.value) {
            strWhereColumn = element.getAttribute('child-column') || element.getAttribute('column') || element.getAttribute('qs');

            if (isNaN(element.value)) {
                strWhere =  'CAST(' + strWhereColumn + ' AS ' + GS.database.type.text + ') = ' +
                            'CAST($WhereQUOTE$' + (element.value) + '$WhereQUOTE$ AS ' + GS.database.type.text + ')' +
                            (strWhere !== '' ? ' AND (' + strWhere + ')' : '');
            } else {
                strWhere = strWhereColumn + '=' + (element.value) + (strWhere !== '' ? ' AND (' + strWhere + ')' : '');
            }

        // else: just use the where attribute
        }

        // if the user has set an order by: use the user order bys
        if (element.user_order_bys && element.user_order_bys.columns.length > 0) {
            for (i = 0, len = element.user_order_bys.columns.length, strOrd = ''; i < len; i += 1) {
                strOrd += (strOrd !== '' ? ', ' : '') + element.user_order_bys.columns[i] + ' ' + element.user_order_bys.directions[i].toUpperCase();
            }

        // else: use the order by attribute
        }

        // save the old scrolltop (so that we can scroll back to it)
        element.oldScrollTop = element.scrollContainerElement.scrollTop;

        addLoader(element, 'Loading...');
        GS.requestCachingSelect(GS.envSocket, strSchema, strObject, '*'
                                 , strWhere, strOrd, strLimit, strOffset
                                 , function (data, error) {
            element.refreshing = false;
            var arrRecords, arrCells, envData
              , i, len, cell_i, cell_len;

            if (!error) {
                if (data.strMessage !== 'TRANSACTION COMPLETED') {
                    arrRecords = GS.trim(data.strMessage, '\n').split('\n');

                    for (i = 0, len = arrRecords.length; i < len; i += 1) {
                        arrCells = arrRecords[i].split('\t');

                        for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                            arrCells[cell_i] = arrCells[cell_i] === '\\N' ? null : GS.decodeFromTabDelimited(arrCells[cell_i]);
                        }

                        arrTotalRecords.push(arrCells);
                    }
                } else {
                    removeLoader(element);
                    element.arrColumnNames = data.arrColumnNames;

                    envData = {'arr_column': element.arrColumnNames, 'dat': arrTotalRecords};

                    handleData(element, envData);
                }
            } else {
                handleData(element, data, error);
                //GS.removeLoader(element);
            }
        }, true);
    }

    function handleData(element, data, error) {
        var strHeaderHTML, strFixedHeaderHTML, tableElement, theadElement, tbodyElement,
            strBodyHTML, tableTemplateElement, arrCells, i, len,
            bolHeaderTextFound = false, strCurrentHeadingText, bolInitalSuccess;

        if (!error) {
            bolInitalSuccess = !element.lastSuccessData;

            // remove old error class
            element.classList.remove('error');

            // save data
            element.lastSuccessData = data;

            // create HTMl for header
            tableTemplateElement = document.createElement('template');
            tableTemplateElement.innerHTML = element.tableTemplate;

            tableElement = xtag.query(tableTemplateElement.content, 'table')[0];
            theadElement = xtag.queryChildren(tableElement, 'thead')[0];
            tbodyElement = xtag.queryChildren(tableElement, 'tbody')[0];

            // if there is a limit button
            if (element.limitButtonElement) {
                element.limitButtonElement.textContent = data.dat.length + ' records';
                element.limitButtonElement.setAttribute('class', 'row_count_btn');
            }

            //console.log(tableTemplateElement, element.tableTemplate, theadElement, tbodyElement);

            if (!theadElement) {
                arrCells = tbodyElement.getElementsByTagName('tr')[0].children;

                for (i = 0, len = arrCells.length, strHeaderHTML = '', strFixedHeaderHTML = ''; i < len; i += 1) {
                    strCurrentHeadingText = encodeHTML(GS.templateWithQuerystring(arrCells[i].getAttribute('heading') || ''));

                    if (strCurrentHeadingText) {
                        bolHeaderTextFound = true;
                    }

                    strHeaderHTML += '<th gs-dynamic>' + strCurrentHeadingText + '</th>';
                    strFixedHeaderHTML += '<div class="fixed-header-cell" gs-dynamic>' + strCurrentHeadingText + '</div>';
                }

                if (bolHeaderTextFound) {
                    strHeaderHTML = '<thead gs-dynamic><tr gs-dynamic>' + strHeaderHTML + '</tr></thead>';

                } else {
                    strHeaderHTML = '';
                    strFixedHeaderHTML = '';
                }
            } else {
                strHeaderHTML = theadElement.outerHTML;
                arrCells = theadElement.getElementsByTagName('tr')[0].children;

                for (i = 0, len = arrCells.length, strFixedHeaderHTML = ''; i < len; i += 1) {
                    strFixedHeaderHTML += '<div class="fixed-header-cell" gs-dynamic>' + encodeHTML(arrCells[i].textContent || '') + '</div>';
                }
            }

            element.fixedHeaderContainerElement.innerHTML = strFixedHeaderHTML;

            // create HTMl for body using the templated data
            strBodyHTML = '<tbody gs-dynamic>' + dataTemplateRecords(element, data) + '</tbody>';



            // this following observer code was added so that firefox would adjust it's headers at the right time
            //      I belive that the problem firefox had was that comboboxes were changing their width after
            //      refreshFixedHeader was being called, so this observer will call it after the childlist of the
            //      scrollcontainer changes
            // if there is already an observer: disconnect it
            if (element.headerRefreshObserver) {
                element.headerRefreshObserver.disconnect();
                element.headerRefreshObserver = undefined;
            }

            // fixed header mutation observer
            element.headerRefreshObserver = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    //console.log('1***');
                    element.refreshFixedHeader();
                });
            });

            // pass in the target node, as well as the observer options
            element.headerRefreshObserver.observe(element.scrollContainerElement, {'childList': true});


            // set scroll container html
            element.scrollContainerElement.innerHTML = '<table gs-dynamic>' +
                                                        strHeaderHTML +
                                                        strBodyHTML +
                                                    '</table>';

            element.theadElement = xtag.query(element.scrollContainerElement, 'thead')[0];
            element.tbodyElement = xtag.query(element.scrollContainerElement, 'tbody')[0];

            element.refreshFixedHeader();

            // refresh height and reflow status
            element.refreshHeight();
            element.refreshReflow();

            // set scrolltop to the old scrolltop
            element.scrollContainerElement.scrollTop = element.oldScrollTop;

            if (element.hasAttribute('scroll-to-bottom')) {
                element.scrollContainerElement.scrollTop = element.scrollContainerElement.scrollHeight;
            }

            // this is triggered after the scrolling is set so that if someone wants to scroll
            // to a record after select they aren't going to encounter a problem
            GS.triggerEvent(element, 'after_select');

        } else {
            // add error class
            element.classList.add('error');

            // error dialog
            GS.ajaxErrorDialog(data, function () {
                getData(element);
            });
        }
    }


    function updateRecord(element, record, strColumn, newValue) {
        var srcParts   = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') || element.getAttribute('source') || '')).split('.')
          , strSchema  = srcParts[0]
          , strObject  = srcParts[1]
          , strHashCols = ''
          , strHashData = ''
          , strUpdateData =
            'pk\tset\thash\n' +
            'id\t' + GS.encodeForTabDelimited(strColumn) + '\thash\n' +
            GS.encodeForTabDelimited(record.getAttribute('data-id')) + '\t' + GS.encodeForTabDelimited(newValue) + '\t'
          , i, len, arrTotalRecords = [], callbackFunction;

        for (i = 0, len = element.arrWhereColumns.length; i < len; i += 1) {
            if (element.arrWhereColumns[i] != 'id') {
                if (strHashCols.length > 0) {
                    strHashCols += '\t';
                    strHashData += '\t';
                }
                strHashCols += GS.encodeForTabDelimited(element.arrWhereColumns[i]);

                strHashData += GS.encodeForTabDelimited(record.getAttribute('data-' + element.arrWhereColumns[i]));
            }
        }

        strUpdateData += CryptoJS.MD5(strHashData);

        addLoader(element, 'Updating Record...');
        GS.requestUpdateFromSocket(GS.envSocket, strSchema, strObject, '*', strHashCols, strUpdateData, function (data, error, transactionID) {
            if (error) {
                removeLoader(element);
                GS.webSocketErrorDialog(data);
            }
        }, function (data, error, transactionID, commitFunction, rollbackFunction) {
            var arrRecords, arrCells, envData
              , i, len, cell_i, cell_len;

            if (!error) {
                if (data !== 'TRANSACTION COMPLETED') {
                    arrRecords = GS.trim(data, '\n').split('\n');

                    for (i = 0, len = arrRecords.length; i < len; i += 1) {
                        arrCells = arrRecords[i].split('\t');

                        for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                            arrCells[cell_i] = arrCells[cell_i] === '\\N' ? null : GS.decodeFromTabDelimited(arrCells[cell_i]);
                        }

                        arrTotalRecords.push(arrCells);
                    }

                } else {
                    commitFunction();
                }

            } else {
                removeLoader(element);
                rollbackFunction();
                GS.webSocketErrorDialog(data);
            }
        }, function (strAnswer, data, error) {
            var arrElements, i, len;

            if (!error) {
                if (strAnswer === 'COMMIT') {
                    callbackFunction({
                        detail: {
                            response: arrTotalRecords[0],
                            error: error
                        }
                    });
                }

            } else {
                getData(element);
                GS.webSocketErrorDialog(data);
            }
        });

        callbackFunction = function (event) {
            var jsnData, i, len, idIndex, tbodyElement, recordIndex, focusElement = document.activeElement
              , focusElementTag, focusElementRecord, focusElementCell, focusElementRecordIndex, focusElementCellIndex
              , focusElementIndex, focusElementCell, elementWalkResult, arrElements, arrSelection, newRecord, jsnTextSelection
              , newRecordData;
            //console.log(event);

            removeLoader(element);

            focusElementCell = getCellFromTarget(focusElement);

            if (focusElementCell) {
                focusElementTag = focusElement.nodeName.toLowerCase();
                focusElementRecord = GS.findParentTag(focusElementCell, 'tr'); // getParentRecord(focusElementCell);

                focusElementRecordIndex = focusElementRecord.rowIndex;
                focusElementCellIndex = focusElementCell.cellIndex;
                focusElementIndex = xtag.query(focusElementRecord, focusElement.nodeName.toLowerCase()).indexOf(focusElement);

                //console.log(focusElementRecord,
                //            xtag.query(focusElementRecord, '*'),
                //            xtag.query(focusElementRecord, '*').indexOf(focusElement),
                //            xtag.query(focusElementRecord, focusElement.nodeName.toLowerCase()).indexOf(focusElement));
            }

            // if no error: refresh just the updated record
            if (!event.detail.error) {
                GS.triggerEvent(element, 'after_update');
                newRecordData = JSON.parse(JSON.stringify(event.detail.response));

                if (newRecordData.length > 0) {
                    // refresh record in lastSuccessData
                    idIndex = element.lastSuccessData.arr_column.indexOf('id');

                    for (i = 0, len = element.lastSuccessData.dat.length; i < len; i += 1) {
                        if (String(element.lastSuccessData.dat[i][idIndex]) === String(record.getAttribute('data-id'))) {
                            recordIndex = i;
                            element.lastSuccessData.dat[i] = JSON.parse(JSON.stringify(event.detail.response));

                            break;
                        }
                    }

                    // save text selection status
                    if (document.activeElement.nodeName === 'INPUT' || document.activeElement.nodeName === 'TEXTAREA') {
                        jsnTextSelection = GS.getInputSelection(document.activeElement);
                    }

                    // save selection status of the cells in "record"
                    arrElements = xtag.query(record, 'td, th');
                    arrSelection = [];

                    for (i = 0, len = arrElements.length; i < len; i += 1) {
                        if (arrElements[i].hasAttribute('selected-secondary')) {
                            arrSelection.push('selected-secondary');
                        } else if (arrElements[i].hasAttribute('selected')) {
                            arrSelection.push('selected');
                        } else {
                            arrElements.push('');
                        }
                    }

                    // replace "record" with new templated record
                    tbodyElement = document.createElement('tbody');
                    tbodyElement.innerHTML = dataTemplateRecords(element, element.lastSuccessData, recordIndex, 1); // jsnData // dataTemplate
                    newRecord = xtag.queryChildren(tbodyElement, 'tr')[0];
                    record.parentNode.replaceChild(newRecord, record);

                    // use saved selection status to select the cells in the new record
                    arrElements = xtag.query(newRecord, 'td, th');

                    for (i = 0, len = arrElements.length; i < len; i += 1) {
                        if (arrSelection[i]) {
                            arrElements[i].setAttribute(arrSelection[i], '');
                        }
                    }

                    // refocus
                    if (focusElementCell) {
                        elementWalkResult = xtag.query(element.scrollContainerElement, 'tr')[focusElementRecordIndex];

                        if (elementWalkResult) {
                            elementWalkResult = xtag.query(elementWalkResult, focusElementTag)[focusElementIndex];

                            if (elementWalkResult) {
                                elementWalkResult.focus();
                            }

                            //elementWalkResult = xtag.queryChildren(elementWalkResult, 'th, td')[focusElementCellIndex];
                            //
                            //if (elementWalkResult) {
                            //    elementWalkResult = xtag.query(elementWalkResult, '*')[1];
                            //
                            //    if (elementWalkResult) {
                            //        elementWalkResult.focus();
                            //    }
                            //}
                        }
                    }

                    // use saved text selection status to select active element
                    if (jsnTextSelection) {
                        GS.setInputSelection(document.activeElement, jsnTextSelection.start, jsnTextSelection.end);
                    }
                } else {
                    element.selectedCells = [];
                    record.parentNode.removeChild(record);
                }

                element.refreshFixedHeader();
                element.refreshHeight();

            // else: errorDialog
            } else {
                // create addin to error response
                event.detail.response.error_addin = '<b gs-dynamic>Your Unsaved Value:</b> "' + newValue + '"';

                GS.ajaxErrorDialog(event.detail.response, function () {
                    updateRecord(element, record, strColumn, newValue);
                }, function () {
                    // revert
                    idIndex = element.lastSuccessData.arr_column.indexOf('id');

                    for (i = 0, len = element.lastSuccessData.dat.length; i < len; i += 1) {
                        if (String(element.lastSuccessData.dat[i][idIndex]) === String(record.getAttribute('data-id'))) {
                            recordIndex = i;
                            break;
                        }
                    }

                    tbodyElement = document.createElement('tbody');
                    tbodyElement.innerHTML = dataTemplateRecords(element, element.lastSuccessData, recordIndex, 1);
                    record.parentNode.replaceChild(xtag.queryChildren(tbodyElement, 'tr')[0], record);
                });
            }
        };
    }

    function deleteRecords(element, arrID, arrRecord) {
        var srcParts   = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') || element.getAttribute('source') || '')).split('.')
          , strSchema  = srcParts[0]
          , strObject  = srcParts[1]
          , strHashCols = ''
          , strHashData = ''
          , strDeleteData =
            'pk\thash\n' +
            'id\thash\n'
          , i, len, j, len2, arrTotalRecords = [], callbackFunction;

        for (j = 0, len2 = element.arrWhereColumns.length; j < len2; j += 1) {
            if (element.arrWhereColumns[j] != 'id') {
                if (strHashCols.length > 0) {
                    strHashCols += '\t';
                }
                strHashCols += GS.encodeForTabDelimited(element.arrWhereColumns[j]);
            }
        }

        for (i = 0, len = arrID.length; i < len; i += 1) {
            for (j = 0, len2 = element.arrWhereColumns.length; j < len2; j += 1) {
                if (element.arrWhereColumns[j] != 'id') {
                    if (strHashData.length > 0) {
                        strHashData += '\t';
                    }

                    strHashData += GS.encodeForTabDelimited(arrRecord[i].getAttribute('data-' + element.arrWhereColumns[j]));
                } else {
                    strDeleteData += GS.encodeForTabDelimited(arrRecord[i].getAttribute('data-id'));
                }
            }
            //console.log(strHashData);
            strDeleteData += '\t' + CryptoJS.MD5(strHashData) + '\n';
            strHashData = '';
        }

        addLoader(element, 'Creating Delete Transaction...');
        GS.requestDeleteFromSocket(
            GS.envSocket, strSchema, strObject, strHashCols, strDeleteData
            , function (data, error, transactionID) {
                if (error) {
                    removeLoader(element);
                    GS.webSocketErrorDialog(data);
                }
            }
            , function (data, error, transactionID, commitFunction, rollbackFunction) {
                var arrElements, i, len, templateElement;
                if (!error) {
                    if (data === 'TRANSACTION COMPLETED') {
                        // We have already confimed with the user that we are going to delete
                        commitFunction();
                    }

                } else {
                    rollbackFunction();
                    GS.webSocketErrorDialog(data);
                }
            }
            , function (strAnswer, data, error) {
                var i, len, idColIndex, deleteIndex;
                removeLoader(element);

                if (!error) {
                    if (strAnswer === 'COMMIT') {
                        GS.triggerEvent(element, 'after_delete');

                        for (i = 0, len = arrRecord.length; i < len; i += 1) {
                            arrRecord[i].parentNode.removeChild(arrRecord[i]);
                        }

                        idColIndex = element.lastSuccessData.arr_column.indexOf('id');

                        if (element.hasAttribute('limit') || element.lastSuccessData.dat.length === arrID.length) {
                            element.refresh();

                        } else {
                            // remove the record data from our stored data and
                            //      stop looping when we have deleted all the ones we are supposed to
                            for (i = 0, len = element.lastSuccessData.dat.length; i < len; i += 1) {
                                // (arrID should only have strings so we cast the current id to string)
                                deleteIndex = arrID.indexOf(String(element.lastSuccessData.dat[i][idColIndex]));

                                if (deleteIndex > -1) {
                                    element.lastSuccessData.dat.splice(i, 1);
                                    arrID.splice(deleteIndex, 1);
                                    len -= 1;
                                    i -= 1;
                                }

                                if (arrID.length === 0) {
                                    break;
                                }
                            }

                            handleData(element, element.lastSuccessData);
                        }
                    }

                } else {
                    getData(element);
                    GS.webSocketErrorDialog(data);
                }
            }
        );
    }

    function insertRecord(element, dialog, strInsertString) {
        var srcParts   = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') || element.getAttribute('source') || '')).split('.')
          , strSchema  = srcParts[0]
          , strObject  = srcParts[1]
          , arrInsertKeys
          , arrInsertValues
          , strWSInsertColumns
          , strWSInsertData
          , i, len;

        // if there is a column attribute on this element: append child column (or column) and the value to the insert string
        if (element.getAttribute('column') || element.getAttribute('qs')) {
            strInsertString += (strInsertString ? '&' : '') + (element.getAttribute('child-column') || element.getAttribute('column') || element.getAttribute('qs')) + '=' + (element.value);
        }

        //console.log(strInsertString);

        arrInsertKeys = GS.qryGetKeys(strInsertString);
        arrInsertValues = GS.qryGetVals(strInsertString);

        for (i = 0, len = arrInsertKeys.length, strWSInsertColumns = ''; i < len; i += 1) {
            strWSInsertColumns += arrInsertKeys[i] + ((i + 1) === len ? '\n' : '\t');
        }
        for (i = 0, len = arrInsertValues.length, strWSInsertData = ''; i < len; i += 1) {
            strWSInsertData += arrInsertValues[i] + ((i + 1) === len ? '\n' : '\t');
        }

        addLoader(element, 'Inserting Record...');

        GS.requestInsertFromSocket(GS.envSocket, strSchema, strObject, strWSInsertColumns, 'id', '', strWSInsertColumns + strWSInsertData, function (data, error, transactionID) {
            if (error) {
                removeLoader(element);
                GS.webSocketErrorDialog(data);
            }
        }, function (data, error, transactionID, commitFunction, rollbackFunction) {
            var arrElements, i, len, templateElement;

            if (!error) {
                if (data === 'TRANSACTION COMPLETED') {
                    commitFunction();
                }

            } else {
                removeLoader(element);
                rollbackFunction();
                GS.webSocketErrorDialog(data);
            }
        }, function () {
            removeLoader(element);
            GS.triggerEvent(element, 'after_insert');
            GS.closeDialog(dialog, 'Ok');
            getData(element, true);
        });
    }


    // ##################################################################
    // ########################### UI REFRESH ###########################
    // ##################################################################


    function refreshHud(element) {
        var elementHudTopContainer, elementHudBottomContainer, divElement = document.createElement('div'),
            hudInsertButton, hudRefreshButton, hudDeleteButton, hudOrderbyButton, hudLimitButton, intOffset, intLimit,
            jsnOrderByCopy, i, len, customHudTemplate, customHudElements;

        elementHudTopContainer    = element.hudTopElement;
        elementHudBottomContainer = element.hudBottomElement;

        elementHudTopContainer.innerHTML = '';
        elementHudBottomContainer.innerHTML = '';

        // insert hud button
        if (element.insertTemplate && !element.hasAttribute('no-insert')) {
            divElement.innerHTML = '<gs-button inline icononly icon="plus" no-focus gs-dynamic>Insert</gs-button>';

            hudInsertButton = divElement.childNodes[0];

            elementHudTopContainer.appendChild(hudInsertButton);
        }

        // refresh hud button
        if (!element.hasAttribute('no-hudrefresh')) {
            divElement.innerHTML = '<gs-button inline icononly icon="refresh" no-focus gs-dynamic>Refresh</gs-button>';

            hudRefreshButton = divElement.childNodes[0];

            elementHudTopContainer.appendChild(hudRefreshButton);
        }

        // delete hud button
        if (!element.hasAttribute('no-huddelete')) {
            divElement.innerHTML = '<gs-button inline icononly icon="times" no-focus gs-dynamic>Delete</gs-button>';

            hudDeleteButton = divElement.childNodes[0];

            elementHudTopContainer.appendChild(hudDeleteButton);
        }

        // custom hud buttons (trim so that just whitespace doesn't count)
        if (element.hudTemplate && element.hudTemplate.trim()) {
            customHudTemplate = document.createElement('template');
            customHudTemplate.innerHTML = element.hudTemplate;

            elementHudTopContainer.appendChild(customHudTemplate.content.cloneNode(true));

            // V------ you can't use .children on a template.content
            //customHudElements = customHudTemplate.content.childNodes;
            //
            //for (i = 0, len = customHudElements.length; i < len; i += 1) {
            //    //customHudElements[i].setAttribute('inline', '');
            //    elementHudTopContainer.appendChild(customHudElements[0]);
            //}
            //elementHudTopContainer.innerHTML += element.hudTemplate; <-- this causes events to be lost in the hud-top container
        }

        // order by hud button
        if (!element.hasAttribute('no-hudorderby')) {
            divElement.innerHTML = '<gs-button inline icononly icon="sort-amount-asc" no-focus gs-dynamic>Order By</gs-button>';

            hudOrderbyButton = divElement.childNodes[0];

            elementHudBottomContainer.appendChild(hudOrderbyButton);
        }

        // limit hud button
        element.limitButtonElement = '';
        if (!element.hasAttribute('no-hudlimit')) {
            //console.log(element, element.lastSuccessData);
            divElement.innerHTML = '<span flex></span><gs-button inline no-focus>Limit</gs-button>';

            hudLimitButton = divElement.childNodes[1];

            element.limitButtonElement = hudLimitButton;

            elementHudBottomContainer.appendChild(divElement.childNodes[0]);
            elementHudBottomContainer.appendChild(divElement.childNodes[0]);
        }

        if (elementHudTopContainer.innerHTML === '') {
            elementHudTopContainer.style.display = 'none';
        } else {
            elementHudTopContainer.style.display = '';
        }

        if (elementHudBottomContainer.innerHTML === '') {
            elementHudBottomContainer.style.display = 'none';
        } else {
            elementHudBottomContainer.style.display = '';
        }


        // bind hud buttons
        if (hudInsertButton) {
            hudInsertButton.addEventListener('click', function (event) {
                var templateElement = document.createElement('template');

                templateElement.innerHTML = ml(function () {/*
                    <gs-page gs-dynamic>
                        <gs-header gs-dynamic><center gs-dynamic><h3 gs-dynamic>Insert</h3></center></gs-header>
                        <gs-body padded gs-dynamic>
                            <div id="insert-dialog-content-container" gs-dynamic>{{HTML}}</div>
                        </gs-body>
                        <gs-footer gs-dynamic>
                            <gs-grid gs-dynamic widths="1,1" class="width-2">
                                <gs-block gs-dynamic width="1">
                                    <gs-button dialogclose gs-dynamic>Cancel</gs-button>
                                </gs-block>
                                <gs-block gs-dynamic width="1">
                                    <gs-button class="dialog-envelope-insert" listen-for-return bg-primary gs-dynamic>Ok</gs-button>
                                </gs-block>
                            </gs-grid>
                        </gs-footer>
                    </gs-page>
                */}).replace('{{HTML}}', element.insertTemplate);

                GS.openDialog(templateElement, function () {
                    var dialog = this;

                    GS.triggerEvent(element, 'insert_dialog_open');

                    xtag.query(dialog, '.dialog-envelope-insert')[0].addEventListener('click', function () {
                        var insertContainer = document.getElementById('insert-dialog-content-container'),
                            controls, i, len, strInsertString, currentValue;

                        controls = xtag.query(insertContainer, '[column]');

                        for (i = 0, len = controls.length, strInsertString = ''; i < len; i += 1) {
                            currentValue = controls.checked !== undefined ? controls.checked : controls[i].value;

                            if (currentValue === undefined || currentValue === null) {
                                currentValue = '';
                            }

                            currentValue = encodeURIComponent(currentValue);

                            if (currentValue !== undefined && currentValue !== null && currentValue !== '') {
                                strInsertString += (strInsertString === '' ? '' : '&') +
                                                    controls[i].getAttribute('column') + '=' + currentValue;
                            }
                        }

                        insertRecord(element, dialog, strInsertString);
                    });
                });
            });
        }

        if (hudRefreshButton) {
            element.hudRefreshButton = hudRefreshButton;
            hudRefreshButton.addEventListener('click', function (event) {
                getData(element, true);
            });
        }

        if (hudDeleteButton) {
            element.hudDeleteButton = hudDeleteButton;
            //console.log('binding click on', hudDeleteButton);
            hudDeleteButton.addEventListener('click', function (event) {
                var i, len, arrRecord = element.selectedRecords, arrID = [];

                // loop through the selected cells and create an array of ids
                for (i = 0, len = arrRecord.length; i < len; i += 1) {
                    arrID.push(String(arrRecord[i].dataset.id));
                }

                if (arrID.length > 0) {
                    GS.msgbox(  'Are you sure...',
                                    '<br gs-dynamic />' +
                                    '<center gs-dynamic>' +
                                        'Are you sure you want to delete ' + (arrID.length > 1 ? 'these records' : 'this record') + '?' +
                                    '</center>' +
                                    '<br gs-dynamic />',
                                ['No', 'Yes'],
                                function (strAnswer) {
                                    if (strAnswer === 'Yes') {
                                        deleteRecords(element, arrID, arrRecord);
                                    }
                                });

                } else {
                    GS.msgbox('Nothing Selected.',
                              '<br gs-dynamic /><center gs-dynamic>Nothing is selected. Please select something to delete.</center><br />',
                              ['Ok']);
                }
            });
        }

        if (hudOrderbyButton) {
            element.hudOrderbyButton = hudOrderbyButton;
            hudOrderbyButton.addEventListener('click', function (event) {
                var templateElement = document.createElement('template');

                jsnOrderByCopy = JSON.parse(JSON.stringify(element.user_order_bys));

                // TESTING LINE!!! COMMENT OUT WHEN NOT IN USE!!!
                //jsnOrderByCopy = {'columns': ['billable', 'taxable', 'id', 'user_name'], 'directions': ['asc', 'desc', 'asc', 'asc']};
                // TESTING LINE!!! COMMENT OUT WHEN NOT IN USE!!!

                templateElement.setAttribute('data-mode', 'touch');
                templateElement.innerHTML = ml(function () {/*
                    <gs-page gs-dynamic>
                        <gs-header gs-dynamic>
                            <center gs-dynamic><h3 gs-dynamic>Sorted Columns</h3></center>
                            <gs-button id="order-by-dialog-add-column" gs-dynamic>Add A Column To Sort</gs-button>
                        </gs-header>
                        <gs-body padded gs-dynamic>
                            <div id="order-by-dialog-ghost-container" gs-dynamic></div>
                            <div id="order-by-dialog-used-columns" gs-dynamic></div>
                        </gs-body>
                        <gs-footer gs-dynamic>
                            <gs-grid>
                                <gs-block><gs-button gs-dynamic dialogclose>Cancel</gs-button></gs-block>
                                <gs-block><gs-button gs-dynamic dialogclose>Ok</gs-button></gs-block>
                            </gs-grid>
                        </gs-footer>
                    </gs-page>
                */});

                GS.openDialog(templateElement, function () {
                    document.getElementById('order-by-dialog-add-column').addEventListener('click', function (event) {
                        var dialog, dialogButtons, templateElement = document.createElement('template');

                        templateElement.innerHTML = ml(function () {/*
                            <gs-page gs-dynamic>
                                <gs-header gs-dynamic>
                                    <center gs-dynamic><h3 gs-dynamic>Unsorted Columns</h3></center>
                                </gs-header>
                                <gs-body padded gs-dynamic>
                                    <div id="order-by-dialog-unused-columns" gs-dynamic></div>
                                </gs-body>
                                <gs-footer gs-dynamic>
                                    <gs-button dialogclose gs-dynamic>Cancel</gs-button>
                                </gs-footer>
                            </gs-page>
                        */});

                        dialog = GS.openDialog(templateElement, function () {
                                    var unusedColumnsContainer = document.getElementById('order-by-dialog-unused-columns'),
                                        unusedColumnTapHandler, columnElements, i, len, strHTML;

                                    for (i = 0, len = element.lastSuccessData.arr_column.length, strHTML = ''; i < len; i += 1) {
                                        if (jsnOrderByCopy.columns.indexOf(element.lastSuccessData.arr_column[i]) === -1) {
                                            strHTML +=  '<div class="order_by_column" dialogclose data-column="' + element.lastSuccessData.arr_column[i] + '" gs-dynamic>' +
                                                            '<div class="column_name" gs-dynamic>' + GS.strToTitle(element.lastSuccessData.arr_column[i]) + '</div>' +
                                                        '</div>';
                                        }
                                    }

                                    unusedColumnsContainer.innerHTML = strHTML;

                                    unusedColumnTapHandler = function (event) {
                                        if (event.target.classList.contains('column_name')) {
                                            jsnOrderByCopy.columns.push(event.target.parentNode.getAttribute('data-column'));
                                        } else {
                                            jsnOrderByCopy.columns.push(event.target.getAttribute('data-column'));
                                        }
                                        jsnOrderByCopy.directions.push('asc');

                                        // refresh the column list
                                        refreshOrderBys();
                                    };

                                    columnElements = unusedColumnsContainer.getElementsByClassName('order_by_column');

                                    for (i = 0, len = columnElements.length; i < len; i += 1) {
                                        columnElements[i].addEventListener('click', unusedColumnTapHandler);
                                    }
                                });

                        dialogButtons = dialog.getElementsByTagName('gs-button');
                    });

                    var refreshOrderBys = function () {
                        var usedColumnsElement = document.getElementById('order-by-dialog-used-columns'),
                            ghostContainerElement = document.getElementById('order-by-dialog-ghost-container'),
                            strHTML, i, len, sortButtons, sortMousedownHandler, deleteButtons,
                            deleteTapHandler, directionButtons, directionTapHandler;


                        for (i = 0, len = jsnOrderByCopy.columns.length, strHTML = ''; i < len; i += 1) {
                            strHTML +=  '<div class="order_by_column" flex-horizontal data-column="' + jsnOrderByCopy.columns[i] + '" data-direction="' + jsnOrderByCopy.directions[i] + '" gs-dynamic>' +
                                            '<gs-button inline remove-all icononly icon="bars" class="sort" gs-dynamic></gs-button>' +
                                            '<div class="column_name" flex gs-dynamic>' + GS.strToTitle(jsnOrderByCopy.columns[i]) + '</div>' +
                                            '<gs-button inline remove-all icononly icon="times" class="delete" gs-dynamic></gs-button>' +
                                            '<gs-button inline remove-all icononly icon="sort-amount-' + jsnOrderByCopy.directions[i] + '" class="direction" gs-dynamic></gs-button>' +
                                        '</div>';
                        }

                        usedColumnsElement.innerHTML = strHTML;

                        // bind sort buttons
                        sortMousedownHandler = function () {
                            var columns = usedColumnsElement.getElementsByClassName('order_by_column'), offsetsCache = [], i, len,
                                currentElement = this.parentNode, currentlyMarkedElement, markerElement, bolLast = false, intToIndex,
                                currentElementClone, intCloneoffset, intFromIndex, sortMousemoveHandler, sortMouseupHandler,
                                strColumn = currentElement.getAttribute('data-column'),
                                strDirection = currentElement.getAttribute('data-direction');

                            markerElement = document.createElement('div');
                            markerElement.classList.add('drop_marker');
                            markerElement.setAttribute('gs-dynamic', '');

                            currentElementClone = currentElement.cloneNode(true);
                            ghostContainerElement.appendChild(currentElementClone);
                            intCloneoffset = GS.getElementOffset(ghostContainerElement).top + (currentElementClone.offsetHeight / 2);


                            for (i = 0, len = columns.length; i < len; i += 1) {
                                offsetsCache.push({
                                    'element': columns[i],
                                    'top': GS.getElementOffset(columns[i]).top,
                                    'height': columns[i].offsetHeight//, 'iscurrentelement': columns[i] === currentElement
                                });

                                if (columns[i] === currentElement) {
                                    intFromIndex = i;
                                }
                            }

                            sortMousemoveHandler = function (event) {
                                var i, len, matchedElement, bolNewLast, intTop;

                                event.preventDefault();
                                event.stopPropagation();

                                if (event.which === 0 && !evt.touchDevice) {
                                    sortMouseupHandler();

                                } else {
                                    intTop = GS.mousePosition(event).top + usedColumnsElement.parentNode.scrollTop;

                                    currentElementClone.style.top = (intTop - intCloneoffset) + 'px';

                                    //console.log('mousemove', GS.mousePosition(event).top, usedColumnsElement.parentNode.scrollTop);

                                    if (offsetsCache[0].top > intTop) {
                                        matchedElement = offsetsCache[0].element;
                                        bolNewLast = false;

                                    } else {
                                        for (i = 0, len = offsetsCache.length; i < len; i += 1) {
                                            if (offsetsCache[i + 1]) {
                                                if (offsetsCache[i].top <= intTop &&
                                                    offsetsCache[i].top + ((offsetsCache[i + 1].top - offsetsCache[i].top) / 2) > intTop) {

                                                    matchedElement = offsetsCache[i].element;
                                                    bolNewLast = false;
                                                    intToIndex = i;
                                                    break;

                                                } else if (offsetsCache[i].top <= intTop &&
                                                            offsetsCache[i].top + ((offsetsCache[i + 1].top - offsetsCache[i].top) / 2) <= intTop &&
                                                            offsetsCache[i + 1].top > intTop) {

                                                    matchedElement = offsetsCache[i + 1].element;
                                                    bolNewLast = false;
                                                    intToIndex = i + 1;
                                                    break;
                                                }
                                            } else {
                                                if (offsetsCache[i].top + (offsetsCache[i].height / 2) >= intTop) {
                                                    matchedElement = offsetsCache[i].element;
                                                    bolNewLast = false;
                                                    intToIndex = i;
                                                    break;

                                                } else if (offsetsCache[i].top + (offsetsCache[i].height / 2) <= intTop) {
                                                    matchedElement = offsetsCache[i].element;
                                                    bolNewLast = true;
                                                    intToIndex = i;
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                    if (matchedElement !== currentlyMarkedElement || bolNewLast !== bolLast) {
                                        if (bolNewLast === true) {
                                            if (markerElement) {
                                                markerElement.parentNode.removeChild(markerElement);
                                            }
                                            matchedElement.parentNode.appendChild(markerElement);

                                        } else {
                                            matchedElement.parentNode.insertBefore(markerElement, matchedElement);
                                        }

                                        currentlyMarkedElement = matchedElement;
                                        bolLast = bolNewLast;

                                        //console.log(currentlyMarkedElement, bolLast);
                                    }

                                    //console.log('mousemove', intTop);
                                }
                            };

                            document.body.addEventListener(evt.mousemove, sortMousemoveHandler);

                            sortMouseupHandler = function (event) {
                                intToIndex = (intToIndex > intFromIndex ? intToIndex - 1: intToIndex);

                                // if we have valid to and from indexes:
                                if (intFromIndex !== intToIndex && intToIndex !== undefined) {

                                    if (intFromIndex !== undefined && intFromIndex !== '') {
                                        jsnOrderByCopy.columns.splice(intFromIndex, 1);
                                        jsnOrderByCopy.directions.splice(intFromIndex, 1);
                                    }

                                    jsnOrderByCopy.columns.splice(intToIndex, 0, strColumn);
                                    jsnOrderByCopy.directions.splice(intToIndex, 0, strDirection);

                                    // refresh the column list
                                    refreshOrderBys();
                                } else {
                                    markerElement.parentNode.removeChild(markerElement);
                                }

                                //console.log(intFromIndex, intToIndex);
                                ghostContainerElement.innerHTML = '';
                                document.body.removeEventListener(evt.mousemove, sortMousemoveHandler);
                                document.body.removeEventListener(evt.mouseup, sortMouseupHandler);
                            };

                            document.body.addEventListener(evt.mouseup, sortMouseupHandler);

                            //console.log('sortMousedownHandler');
                        };
                        sortButtons = usedColumnsElement.getElementsByClassName('sort');

                        for (i = 0, len = sortButtons.length; i < len; i += 1) {
                            sortButtons[i].addEventListener(evt.mousedown, sortMousedownHandler);
                        }
                        //console.log(usedColumnsElement.getElementsByClassName('sort'));

                        // bind delete buttons
                        deleteTapHandler = function () {
                            var indexToDelete = jsnOrderByCopy.columns.indexOf(this.parentNode.getAttribute('data-column'));

                            jsnOrderByCopy.columns.splice(indexToDelete, 1);
                            jsnOrderByCopy.directions.splice(indexToDelete, 1);

                            refreshOrderBys();
                            //console.log('deleteTapHandler');
                        };
                        deleteButtons = usedColumnsElement.getElementsByClassName('delete');

                        for (i = 0, len = deleteButtons.length; i < len; i += 1) {
                            deleteButtons[i].addEventListener('click', deleteTapHandler);
                        }
                        //console.log(usedColumnsElement.getElementsByClassName('delete'));


                        // bind direction buttons
                        directionTapHandler = function () {
                            var indexToFlip = jsnOrderByCopy.columns.indexOf(this.parentNode.getAttribute('data-column'));

                            if (jsnOrderByCopy.directions[indexToFlip] === 'asc') {
                                jsnOrderByCopy.directions[indexToFlip] = 'desc';
                            } else {
                                jsnOrderByCopy.directions[indexToFlip] = 'asc';
                            }

                            refreshOrderBys();
                            //console.log('directionTapHandler');
                        };
                        directionButtons = usedColumnsElement.getElementsByClassName('direction');

                        for (i = 0, len = directionButtons.length; i < len; i += 1) {
                            directionButtons[i].addEventListener('click', directionTapHandler);
                        }
                        //console.log(usedColumnsElement.getElementsByClassName('direction'));
                    }

                    refreshOrderBys();
                }, function (event, strAnswer) {
                    if (strAnswer === 'Ok') {
                        element.user_order_bys = JSON.parse(JSON.stringify(jsnOrderByCopy));
                        getData(element, true);
                    }
                });
            });
        }

        if (hudLimitButton) {
            element.hudLimitButton = hudLimitButton;
            hudLimitButton.addEventListener('click', function (event) {
                var intLimit, intOffset, bolShowAll, fromValue, toValue,
                    templateElement = document.createElement('template');

                if (element.getAttribute('limit') && element.getAttribute('offset')) {
                    intOffset = parseInt(element.getAttribute('offset'), 10);
                    intLimit = parseInt(element.getAttribute('limit'), 10);

                    fromValue = intOffset;
                    toValue = intOffset + intLimit;
                    bolShowAll = false;

                } else if (element.getAttribute('limit')) {
                    fromValue = '0';
                    toValue = element.getAttribute('limit');
                    bolShowAll = false;

                } else if (element.old_offset && element.old_limit) {
                    intOffset = parseInt(element.old_offset, 10);
                    intLimit = parseInt(element.old_limit, 10);

                    fromValue = intOffset;
                    toValue = intOffset + intLimit;
                    bolShowAll = true;

                } else if (element.old_limit) {
                    fromValue = '0';
                    toValue = element.old_limit;
                    bolShowAll = true;

                } else {
                    fromValue = '0';
                    toValue = '';
                    bolShowAll = true;
                }

                templateElement.setAttribute('id', 'template-envelope-limit');
                templateElement.innerHTML = ml(function () {/*
                    <gs-page gs-dynamic>
                        <gs-header><center><h3>Limit</h3></center></gs-header>
                        <gs-body padded>
                            <gs-optionbox id="limit-dialog-choice" value="{{OPTION}}">
                                <gs-option value="range">
                                    Show Range:
                                    <gs-grid gutter>
                                        <gs-block>
                                            <b>From:</b>
                                            <gs-text id="limit-dialog-from" value="{{FROM}}" {{DISABLE}}></gs-text>
                                        </gs-block>
                                        <gs-block>
                                            <b>To:</b>
                                            <gs-text id="limit-dialog-to" value="{{TO}}" {{DISABLE}}></gs-text>
                                        </gs-block>
                                    </gs-grid>
                                </gs-option>
                                <gs-option value="all">Show All</gs-option>
                            </gs-optionbox>
                        </gs-body>
                        <gs-footer>
                            <gs-grid>
                                <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
                                <gs-block><gs-button dialogclose listen-for-return bg-primary>Ok</gs-button></gs-block>
                            </gs-grid>
                        </gs-footer>
                    </gs-page>
                */}).replace('{{OPTION}}', (bolShowAll === true ? 'all' : 'range'))
                    .replace(/\{\{DISABLE\}\}/gim, (bolShowAll === true ? 'disabled' : ''))
                    .replace('{{FROM}}', fromValue)
                    .replace('{{TO}}', toValue);

                GS.openDialog(templateElement, function () {
                    var choiceElement, showAllElement, fromElement, toElement, intLimit, intOffset, bolShowAll, fromValue, toValue;

                    choiceElement = document.getElementById('limit-dialog-choice');
                    fromElement = document.getElementById('limit-dialog-from');
                    toElement = document.getElementById('limit-dialog-to');

                    choiceElement.addEventListener('change', function (event) {
                        if (this.value === 'all') {
                            fromElement.setAttribute('disabled', '');
                            toElement.setAttribute('disabled', '');
                            GS.closeDialog('template-envelope-limit', 'Ok');
                        } else {
                            fromElement.removeAttribute('disabled');
                            toElement.removeAttribute('disabled');
                        }
                    });

                }, function (event, strAnswer) {
                    var dialog = this, choiceElement, showAllElement, fromElement, toElement, intLimit, intOffset;

                    if (strAnswer === 'Ok') {
                        choiceElement = document.getElementById('limit-dialog-choice');
                        showAllElement = document.getElementById('limit-dialog-show-all');
                        fromElement = document.getElementById('limit-dialog-from');
                        toElement = document.getElementById('limit-dialog-to');

                        if (choiceElement.value === 'all') {
                            if (element.getAttribute('limit')) {
                                element.old_limit = element.getAttribute('limit');
                                element.removeAttribute('limit');
                            }
                            if (element.getAttribute('offset')) {
                                element.old_offset = element.getAttribute('offset');
                                element.removeAttribute('offset');
                            }

                        } else {
                            if (fromElement.value) {
                                element.setAttribute('offset', fromElement.value);
                            }
                            if (toElement.value) {
                                element.setAttribute('limit', parseInt(toElement.value, 10) - parseInt(fromElement.value, 10));
                            }
                        }

                        getData(element);
                    }
                });
            });
        }
    }


    // #################################################################
    // ########################### UTILITIES ###########################
    // #################################################################

    function handleClipboardData(event, strCopyString) {
        var clipboardData = event.clipboardData || window.clipboardData, strMime;

        if (!clipboardData) {
            return;
        }
        if (!clipboardData.setData) {
            return;
        }

        if (window.clipboardData && window.clipboardData.getData) { // IE
            strMime = 'Text';
        } else if (event.clipboardData && event.clipboardData.getData) {
            strMime = 'text/plain';
        }

        if (strCopyString) {
            return clipboardData.setData(strMime, strCopyString) !== false;
        } else {
            return clipboardData.getData(strMime);
        }
    }

    function dataTemplateRecords(element, data, intStartRecordNumber, intNumberOfRecords) {
        var tableTemplateElement = document.createElement('template'), jsnTemplate, strRet, strStart, strEnd;

        tableTemplateElement.innerHTML = element.tableTemplate;

        //strStart = '<table><tbody>';
        //strEnd = '</tbody></table>';
        //jsnTemplate = GS.templateHideSubTemplates(strStart + xtag.query(tableTemplateElement.content, 'tbody')[0].innerHTML + strEnd);
        jsnTemplate = GS.templateHideSubTemplates(xtag.query(tableTemplateElement.content, 'tbody')[0].innerHTML, true);

        //jsnTemplate.templateHTML = jsnTemplate.templateHTML.substring(strStart.length, jsnTemplate.templateHTML.length - strEnd.length);
        //console.log(jsnTemplate.templateHTML);

        strRet = GS.templateWithEnvelopeData(jsnTemplate.templateHTML, data, intStartRecordNumber, intStartRecordNumber + intNumberOfRecords);

        strRet = GS.templateShowSubTemplates(strRet, jsnTemplate);

        return strRet;
    }



    // ########################################################################################
    // ########################################################################################
    // ########################################################################################
    // ########################################################################################
    // ########################################################################################
    // ########################################################################################
    // ########################################################################################
    // ########################################################################################
    // ########################################################################################

    function getCellFromTarget(element) {
        var currentElement = element;

        while (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH' && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }

        if (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH') {
            return undefined;
        }

        return currentElement;
    }

    //function pushReplacePopHandler(element) {
    //    var i, len, arrPopKeys, bolRefresh = false, currentValue, strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //
    //    if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //
    //    if (element.hasAttribute('refresh-on-querystring-values')) {
    //        arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(',');
    //
    //        for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
    //            currentValue = GS.qryGetVal(strQueryString, arrPopKeys[i]);
    //
    //            if (element.popValues[arrPopKeys[i]] !== currentValue) {
    //                bolRefresh = true;
    //            }
    //
    //            element.popValues[arrPopKeys[i]] = currentValue;
    //        }
    //    } else if (element.hasAttribute('refresh-on-querystring-change')) {
    //        bolRefresh = true;
    //    }
    //
    //    if (bolRefresh) {
    //        element.refresh();
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var arrPopKeys;
        var currentValue;
        var bolRefresh;
        var strOperator;

        if (strQSCol) {
            if (strQSCol.indexOf('=') !== -1) {
                arrAttrParts = strQSCol.split(',');
                i = 0;
                len = arrAttrParts.length;
                while (i < len) {
                    strQSCol = arrAttrParts[i];

                    if (strQSCol.indexOf('!=') !== -1) {
                        strOperator = '!=';
                        arrQSParts = strQSCol.split('!=');
                    } else {
                        strOperator = '=';
                        arrQSParts = strQSCol.split('=');
                    }

                    strQSCol = arrQSParts[0];
                    strQSAttr = arrQSParts[1] || arrQSParts[0];

                    // if the key is not present or we've got the negator: go to the attribute's default or remove it
                    if (strOperator === '!=') {
                        // if the key is not present: add the attribute
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            element.setAttribute(strQSAttr, '');
                        // else: remove the attribute
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    } else {
                        // if the key is not present: go to the attribute's default or remove it
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                            } else {
                                element.removeAttribute(strQSAttr);
                            }
                        // else: set attribute to exact text from QS
                        } else {
                            element.setAttribute(strQSAttr, (
                                GS.qryGetVal(strQS, strQSCol) ||
                                element.internal.defaultAttributes[strQSAttr] ||
                                ''
                            ));
                        }
                    }
                    i += 1;
                }
            } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                strQSValue = GS.qryGetVal(strQS, strQSCol);

                if (element.internal.bolQSFirstRun !== true) {
                    if (strQSValue !== '' || !element.getAttribute('value')) {
                        element.setAttribute('value', strQSValue);
                    }
                } else {
                    element.value = strQSValue;
                }
            }
        }

        // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
        if (element.internal.bolQSFirstRun === true) {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);

                    if (element.popValues[arrPopKeys[i]] !== currentValue) {
                        bolRefresh = true;
                    }

                    element.popValues[arrPopKeys[i]] = currentValue;
                }
            } else if (element.hasAttribute('refresh-on-querystring-change')) {
                bolRefresh = true;
            }

            if (bolRefresh && element.hasAttribute('src')) {
                console.log('pushReplacePopHandler: getData', element);
                getData(element);
            } else if (bolRefresh && !element.hasAttribute('src')) {
                console.warn('gs-combo Warning: element has "refresh-on-querystring-values" or "refresh-on-querystring-change", but no "src".', element);
            }
        } else {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                }
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    //
    function elementInserted(element) {
        var hudTemplateElement, tableTemplateElement, tableTemplateElementCopy, insertTemplateElement,
            recordElement, divElement, oldRootElement, i, len, arrElement, arrColumnElement, arrTemplates, arrWhereColumns,
            strQueryString = GS.getQueryString(), currentElement, strQSValue;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                GS.addBeforeUnloadEvent(function () {
                    document.activeElement.blur();
                });

                // handle "qs" attribute
                if (element.getAttribute('qs') ||
                        element.getAttribute('refresh-on-querystring-values') ||
                        element.hasAttribute('refresh-on-querystring-change')) {
                    element.popValues = {};
                    //strQSValue = GS.qryGetVal(strQueryString, element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.setAttribute('value', strQSValue);
                    //}
                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                }

                // primary keys attribute and defaulting
                if (element.getAttribute('primary-keys')) {
                    arrWhereColumns = element.getAttribute('primary-keys').split(/\s*,\s*/gim);
                    if (arrWhereColumns.length === 0) {
                        arrWhereColumns = ['id', 'change_stamp'];
                    }
                } else {
                    arrWhereColumns = ['id', 'change_stamp'];
                }
                element.arrWhereColumns = arrWhereColumns;

                // set user order bys to default to empty
                element.user_order_bys = {
                    'columns': [],
                    'directions': []
                };

                // if there is an old root element: delete it
                oldRootElement = xtag.queryChildren(element, '.root');

                if (oldRootElement.length > 0) {
                    for (i = 0, len = oldRootElement.length; i < len; i += 1) {
                        element.removeChild(oldRootElement[i]);
                    }
                }

                // selecting for template elements
                hudTemplateElement    = xtag.queryChildren(element, 'template[for="hud"]')[0];
                tableTemplateElement  = xtag.queryChildren(element, 'template[for="table"]' + (element.hasAttribute('template') ? '[id="' + element.getAttribute('template') + '"': ''))[0];
                if (!tableTemplateElement && element.hasAttribute('template')) {
                    console.warn('ENVELOPE WARNING: Hey! You used the name of a non-existant record template!');
                    tableTemplateElement  = xtag.queryChildren(element, 'template[for="table"]')[0];
                }
                insertTemplateElement = xtag.queryChildren(element, 'template[for="insert"]')[0];

                if (
                    hudTemplateElement &&
                    (
                        hudTemplateElement.innerHTML.indexOf('&gt;') > -1 ||
                        hudTemplateElement.innerHTML.indexOf('&lt;') > -1
                    )
                ) {
                    console.warn('GS-ENVELOPE WARNING: &gt; or &lt; detected in HUD template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                }
                if (
                    tableTemplateElement &&
                    (
                        tableTemplateElement.innerHTML.indexOf('&gt;') > -1 ||
                        tableTemplateElement.innerHTML.indexOf('&lt;') > -1
                    )
                ) {
                    console.warn('GS-ENVELOPE WARNING: &gt; or &lt; detected in table template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                }
                if (
                    insertTemplateElement &&
                    (
                        insertTemplateElement.innerHTML.indexOf('&gt;') > -1 ||
                        insertTemplateElement.innerHTML.indexOf('&lt;') > -1
                    )
                ) {
                    console.warn('GS-ENVELOPE WARNING: &gt; or &lt; detected in insert template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                }

                element.templates = {};
                xtag.queryChildren(element, 'template[for="table"]').forEach(function (cur, i) {
                    if (i === 0) {
                        element.templates['default'] = cur;
                    }
                    if (cur.hasAttribute('id')) {
                        element.templates[cur.getAttribute('id')] = cur;
                    }
                });

                // checking/saving template elements
                if (hudTemplateElement) {
                    element.hudTemplate = hudTemplateElement.innerHTML;
                }

                if (tableTemplateElement) {
                    tableTemplateElementCopy = document.createElement('template');
                    tableTemplateElementCopy.innerHTML = tableTemplateElement.innerHTML;

                    recordElement = xtag.query(xtag.query(tableTemplateElementCopy.content, 'tbody')[0], 'tr')[0];

                    if (recordElement) {
                        // add a data- attribute for all where columns (most of the time: id and change_stamp)
                        for (i = 0, len = element.arrWhereColumns.length; i < len; i += 1) {
                            recordElement.setAttribute('data-' + element.arrWhereColumns[i], '{{! row.' + element.arrWhereColumns[i] + ' }}');
                        }

                        // add a doT.js coded "value" attribute to any element with a "column" attribute but no "value" attribute
                        element.tableTemplate = GS.templateColumnToValue(tableTemplateElementCopy.innerHTML);
                    }
                } else {
                    throw 'Envelope error: table template is required.';
                }
                if (insertTemplateElement) {
                    element.insertTemplate = insertTemplateElement.innerHTML;
                }

                // clear element content
                element.innerHTML = '';

                // creating/setting root
                divElement = document.createElement('div');
                divElement.classList.add('root');
                divElement.setAttribute('flex-fill', '');
                divElement.setAttribute('flex-vertical', '');
                divElement.setAttribute('gs-dynamic', '');

                element.appendChild(divElement);
                element.root = divElement;

                // filling root with containers
                element.root.innerHTML = '<div class="hud-container-top" gs-dynamic></div>' +
                                         '<div class="fixed-header-container" gs-dynamic></div>' +
                                         '<div class="scroll-container" flex gs-dynamic></div>' +
                                         '<div class="hud-container-bottom" flex-horizontal gs-dynamic></div>' +
                                         '<input class="gs-envelope-copy-focus-target" value="Firefox compatibility input" gs-dynamic />';

                element.hudTopElement =                 xtag.queryChildren(element.root, '.hud-container-top')[0];
                element.fixedHeaderContainerElement =   xtag.queryChildren(element.root, '.fixed-header-container')[0];
                element.scrollContainerElement =        xtag.queryChildren(element.root, '.scroll-container')[0];
                element.hudBottomElement =              xtag.queryChildren(element.root, '.hud-container-bottom')[0];
                element.copyFocusTargetElement =        xtag.queryChildren(element.root, '.gs-envelope-copy-focus-target')[0];

                element.scrollContainerElement.setAttribute('allow-text-selection', '');

                ////REFPOINT
                //element.addEventListener('focus', function (event) {
                //    //console.log(document.activeElement, element, event.target, element.copyFocusTargetElement);
                //    if (document.activeElement === element) { // event.target
                //        element.copyFocusTargetElement.focus();
                //        GS.setInputSelection(element.copyFocusTargetElement, 0, 'firefox...'.length);
                //    }
                //});

                // binding events
                element.scrollContainerElement.addEventListener('change', function (event) {
                    var newValue, parentTr;

                    if (event.target.getAttribute('column')) {
                        if (event.target.value !== null) {
                            newValue = event.target.value;
                        } else {
                            newValue = event.target.checked;
                        }

                        parentTr = GS.findParentTag(event.target, 'tr');

                        // if the control is a direct child of this envelope (fixes sub envelope update)
                        if (
                            parentTr.parentNode.parentNode.parentNode === element.scrollContainerElement &&
                            !element.hasAttribute('no-update')
                        ) {
                            updateRecord(element, parentTr, event.target.getAttribute('column'), newValue);
                        }
                    }
                });

                // META-SHIFT-CLICK
                if (!evt.touchDevice) {
                    element.addEventListener('click', function (event) {
                        var templateElement;

                        if (event.metaKey && event.shiftKey) {
                            templateElement = document.createElement('template');


                            var strOrderBy = '', strRelWhere = '', strElemWhere, strWhereColumn, strUserOrderBy = '', strLimit, strOffset,
                                strSource = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('src') || '')),
                                strCols = GS.templateWithQuerystring(element.getAttribute('cols') || ''), strElemOrderBy;

                            // if there is a column attribute on element element: combine the where attribute with a where generated by value
                            if ((element.getAttribute('column') || element.getAttribute('qs')) && element.value) {
                                strWhereColumn = element.getAttribute('child-column') || element.getAttribute('column') || element.getAttribute('qs');

                                if (isNaN(element.value)) {
                                    strRelWhere =
                                        'CAST(' + strWhereColumn + ' AS ' + GS.database.type.text + ') = ' +
                                        'CAST($WhereQUOTE$' + (element.value) + '$WhereQUOTE$ AS ' + GS.database.type.text + ')';
                                } else {
                                    strRelWhere = strWhereColumn + '=' + (element.value);
                                }
                            }

                            strElemWhere = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('where') || ''));
                            strLimit = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('limit') || ''));
                            strOffset = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('offset') || ''));

                            // if the user has set an order by: use the user order bys
                            if (element.user_order_bys && element.user_order_bys.columns.length > 0) {
                                for (i = 0, len = element.user_order_bys.columns.length, strUserOrderBy; i < len; i += 1) {
                                    strUserOrderBy += (strUserOrderBy !== '' ? ', ' : '') + element.user_order_bys.columns[i] + ' ' + element.user_order_bys.directions[i].toUpperCase();
                                }
                            }

                            strElemOrderBy = GS.templateWithQuerystring(decodeURIComponent(element.getAttribute('ord') || ''));


                            templateElement.innerHTML = ml(function () {/*
                                <gs-page>
                                    <gs-header><h3>GS-Envelope Details</h3></gs-header>
                                    <gs-body padded>
                                        <b>Source: </b>{{SOURCE}}<br />
                                        <b>Columns: </b>{{COLS}}<br />
                                        <b>Element Where: </b>{{ELEMWHERE}}<br />
                                        <b>Relationship Where: </b>{{RELWHERE}}<br />
                                        <b>Limit: </b>{{LIMIT}}<br />
                                        <b>Offset: </b>{{OFFSET}}<br />
                                        <b>Element Order By: </b>{{ELEMORD}}<br />
                                        <b>User Order By: </b>{{USERORD}}
                                    </gs-body>
                                    <gs-footer>
                                        <gs-button dialogclose>Done</gs-button>
                                    </gs-footer>
                                </gs-page>
                            */}).replace(/\{\{SOURCE\}\}/gi, strSource)
                                .replace(/\{\{COLS\}\}/gi, strCols)
                                .replace(/\{\{ELEMWHERE\}\}/gi, strElemWhere)
                                .replace(/\{\{RELWHERE\}\}/gi, strRelWhere)
                                .replace(/\{\{LIMIT\}\}/gi, strLimit)
                                .replace(/\{\{OFFSET\}\}/gi, strOffset)
                                .replace(/\{\{ELEMORD\}\}/gi, strElemOrderBy)
                                .replace(/\{\{USERORD\}\}/gi, strUserOrderBy);

                            GS.openDialog(templateElement);
                        }
                    });
                }

                // if we are not on a touch device: cell by cell selection
                if (!evt.touchDevice) {
                    // mousedown (on selected and unselected) + drag
                    //      clear previous selection(s)
                    //      select cells from origin cell to current cell
                    //
                    // shift + mousedown (on selected and unselected) + drag
                    //      alter previous selection
                    //      select cells from previous origin cell to current cell
                    //
                    // command + mousedown (on unselected) + drag
                    //      maintain previous selection(s)
                    //      select cells from origin cell to current cell
                    //
                    // command + mousedown (on selected) + drag
                    //      maintain previous selection(s)
                    //      deselect cells from origin cell to current cell
                    //
                    // collision handling
                    //      when colliding with previous selections: dont treat them different
                    //
                    // copy handling
                    //      selection ("X" marks selected cells (imagine all cells contain the letter "a")):
                    //          1  2  3  4  5
                    //          -------------
                    //          a  a  a  a  a
                    //          a  X  X  a  a
                    //          a  a  X  X  a
                    //          a  a  a  a  a
                    //
                    //      yields ("'" marks an empty cell):
                    //          2  3  4
                    //          --------
                    //          a  a  '
                    //          '  a  a

                    element.addEventListener(evt.mousedown, function (event) {
                        var target = event.target, cellFromTarget = getCellFromTarget(target), closestCell, arrSelectedCells, i, len;

                        if (GS.findParentTag(event.target, 'table') || target.classList.contains('fixed-header-cell')) {
                            if (cellFromTarget) {
                                closestCell = cellFromTarget;
                            } else if (target.classList.contains('fixed-header-cell')) {
                                closestCell = element.theadElement.children[0].children[xtag.toArray(target.parentNode.children).indexOf(target)];
                            }

                            if (closestCell) {
                                element.dragAllowed = true;
                                element.dragCurrentCell = closestCell;
                                element.selectionSelectedCells = [];

                                // if shift is down and there is a previous origin: use previous origin for current origin
                                if (event.shiftKey && element.selectionPreviousOrigin) {

                                    // if there are previously selected cells: deselect the previous selected cells
                                    if (element.selectionPreviousSelectedCells) {
                                        arrSelectedCells = element.selectedCells;

                                        for (i = 0, len = element.selectionPreviousSelectedCells.length; i < len; i += 1) {
                                            arrSelectedCells.splice(arrSelectedCells.indexOf(element.selectionPreviousSelectedCells[i]), 1);
                                        }

                                        element.selectedCells = arrSelectedCells;
                                    }

                                    element.dragOrigin = element.selectionPreviousOrigin;
                                    element.dragMode = 'select';

                                // else if ctrl or cmd is down and the target cell is not selected: select cells from target cell to current cell
                                } else if (!event.shiftKey && (event.metaKey || event.ctrlKey) && !closestCell.hasAttribute('selected')) {
                                    element.dragOrigin = closestCell;
                                    element.dragMode = 'select';

                                // else if ctrl or cmd is down and the target cell is selected: deselect cells from target cell to current cell
                                } else if (!event.shiftKey && (event.metaKey || event.ctrlKey) && closestCell.hasAttribute('selected')) {
                                    element.dragOrigin = closestCell;
                                    element.dragMode = 'deselect';

                                // else: deselect all cells and start new selection
                                } else {
                                    element.selectedCells = [];
                                    element.dragOrigin = closestCell;
                                    element.dragMode = 'select';
                                }

                                selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                            }
                        }
                    });
                    element.addEventListener(evt.mousemove, function (event) {
                        var target, closestCell, cellFromTarget;

                        // if mouse is down
                        if (event.which !== 0) {
                            target = event.target;
                            cellFromTarget = getCellFromTarget(target);

                            if (cellFromTarget) {
                                closestCell = cellFromTarget;
                            } else if (target.classList.contains('fixed-header-cell')) {
                                closestCell =
                                    element.theadElement.children[0].children[xtag.toArray(target.parentNode.children).indexOf(target)];
                            }

                            // if selection is allowed at this point and closestCell is different from element.dragCurrentCell
                            if (closestCell && element.dragAllowed && element.dragCurrentCell !== closestCell) {
                                element.dragCurrentCell = getCellFromTarget(closestCell);
                                selectHandler(element, element.dragOrigin, element.dragCurrentCell, element.dragMode);
                            }
                        } else {
                            element.dragAllowed = false;
                            element.selectionPreviousOrigin = element.dragOrigin;
                            element.selectionPreviousSelectedCells = element.selectionSelectedCells;
                        }
                    });
                    element.addEventListener(evt.mouseup, function (event) {
                        element.dragAllowed = false;

                        if (element.dragMode === 'select') {
                            element.selectionPreviousOrigin = element.dragOrigin;
                            element.selectionPreviousSelectedCells = element.selectionSelectedCells;
                        }
                    });

                // else we are on a touch device: record selection
                } else {
                    element.root.addEventListener(evt.mousedown, function (event) {
                        if (event.target.nodeName === 'TD' || event.target.nodeName === 'TH' || getCellFromTarget(event.target)) {
                            element.selectedCells = [];

                            // if there is a parent record to the target: select all of the cells in the record
                            if (GS.findParentTag(event.target, 'tr')) {
                                element.selectedCells = GS.findParentTag(event.target, 'tr').children;
                            }
                        }
                    });
                }

                window.addEventListener('resize', function () {
                    element.refreshFixedHeader();
                    element.refreshHeight();
                    element.refreshReflow();
                });
                window.addEventListener('orientationchange', function () {
                    element.refreshFixedHeader();
                    element.refreshHeight();
                    element.refreshReflow();
                });
                element.addEventListener('size-changed', function (event) {
                    element.refreshFixedHeader();
                    element.refreshHeight();
                    //element.refreshReflow();
                });

                // key navigation
                element.addEventListener('keydown', function (event) {
                    var target = event.target, intKeyCode = event.which || event.keyCode, jsnSelection, bolCursorElement, i, len,
                        focusElement, tbodyElement, recordElement, cellElement, cellElements, tempElement;

                    if (target !== element) {
                        bolCursorElement = target.nodeName === 'INPUT' || target.nodeName === 'TEXTAREA';

                        if (bolCursorElement) {
                            jsnSelection = GS.getInputSelection(target);
                        } else {
                            jsnSelection = {};
                        }

                        // up arrow
                        if (intKeyCode === 38) {
                            //console.log('if there is a record before this one: focus the same column in the previous record');

                            cellElement = getCellFromTarget(target);
                            recordElement = cellElement.parentNode;
                            tbodyElement = recordElement.parentNode;

                            if (recordElement.rowIndex > 1) { // recordIndex > 0
                                recordElement = tbodyElement.children[recordElement.rowIndex - 2];

                                focusElement = xtag.query(recordElement.children[cellElement.cellIndex], '[column]')[0];
                            }

                        // down arrow
                        } else if (intKeyCode === 40) {
                            //console.log('if there is another record after this one: focus the same column in the next record');

                            cellElement = getCellFromTarget(target);
                            recordElement = cellElement.parentNode;
                            tbodyElement = recordElement.parentNode;

                            if (recordElement.rowIndex < tbodyElement.children.length) {
                                recordElement = tbodyElement.children[recordElement.rowIndex];

                                //focusElement = recordElement.children[cellElement.cellIndex].children[0];
                                focusElement = xtag.query(recordElement.children[cellElement.cellIndex], '[column]')[0];
                            }

                        // if left or right arrow
                        } else if (intKeyCode === 37 || intKeyCode === 39) {
                            // left arrow and (at the beginning of the target OR target has no selected)
                            if (intKeyCode === 37 && (bolCursorElement === false || jsnSelection.start === 0)) {
                                //console.log('previous control if possible');

                                cellElement = getCellFromTarget(target);
                                recordElement = cellElement.parentNode;
                                tbodyElement = recordElement.parentNode;

                                cellElements = xtag.query(tbodyElement, 'tr > td, tr > th');

                                // loop through previous cells looking for something focusable
                                for (i = cellElements.indexOf(cellElement) - 1; i > -1; i -= 1) {
                                    //console.log(i);

                                    tempElement = xtag.query(cellElements[i], '[column]')[0];

                                    if (tempElement && GS.isElementFocusable(tempElement)) { // tempElement.control
                                        focusElement = tempElement; // tempElement.control

                                        break;
                                    }
                                }

                            // right arrow and (at the end of the target OR target has no selected)
                            } else if (intKeyCode === 39 && (bolCursorElement === false || jsnSelection.end === target.value.length)) {
                                cellElement = getCellFromTarget(target);
                                recordElement = cellElement.parentNode;
                                tbodyElement = recordElement.parentNode;

                                cellElements = xtag.query(tbodyElement, 'tr > td, tr > th');

                                // loop through previous cells looking for something focusable
                                for (i = cellElements.indexOf(cellElement) + 1, len = cellElements.length; i < len; i += 1) { // - 1
                                    tempElement = xtag.query(cellElements[i], '[column]')[0];

                                    if (tempElement && GS.isElementFocusable(tempElement)) { // tempElement.control
                                        focusElement = tempElement; // tempElement.control

                                        break;
                                    }
                                }
                            }
                        }

                        if (focusElement && GS.isElementFocusable(focusElement)) {
                            event.preventDefault();

                            focusElement.focus();

                            if (document.activeElement.nodeName === 'INPUT' || document.activeElement.nodeName === 'TEXTAREA') {
                                GS.setInputSelection(document.activeElement, 0, document.activeElement.value.length);
                            }

                            element.selectedRecords = GS.findParentTag(focusElement, 'TR');
                        }
                    }
                });

                // copy event
                element.tabIndex = 0;
                document.body.addEventListener('copy', function (event) {//console.log('test');
                    var elementClosestEnvelope = GS.findParentTag(document.activeElement, 'gs-envelope'), strCopyString,
                        i, len, cell_i, cell_len, arrSelected, intFromRecord = 9999999, intFromCell = 9999999, intToRecord = 0, intToCell = 0,
                        strCellText, arrRecords, arrCells, strRecordString;

                    if (elementClosestEnvelope === element &&
                        (
                            document.activeElement.classList.contains('gs-envelope-copy-focus-target') ||
                            document.activeElement.selectionStart === document.activeElement.selectionEnd
                        )) {
                        arrSelected = element.selectedCells;

                        // loop through the selected cells and create a tsv string using the text of the cell
                        if (arrSelected.length > 0) {
                            for (i = 0, len = arrSelected.length; i < len; i += 1) {
                                if (arrSelected[i].parentNode.rowIndex < intFromRecord) {
                                    intFromRecord = arrSelected[i].parentNode.rowIndex;
                                }
                                if (arrSelected[i].cellIndex < intFromCell) {
                                    intFromCell = arrSelected[i].cellIndex;
                                }
                                if (arrSelected[i].parentNode.rowIndex + 1 > intToRecord) {
                                    intToRecord = arrSelected[i].parentNode.rowIndex + 1;
                                }
                                if (arrSelected[i].cellIndex + 1 > intToCell) {
                                    intToCell = arrSelected[i].cellIndex + 1;
                                }
                            }

                            arrRecords = xtag.query(element.scrollContainerElement, 'tr');
                            strCopyString = '';

                            for (i = intFromRecord, len = intToRecord; i < len; i += 1) {
                                arrCells = arrRecords[i].children;

                                for (cell_i = intFromCell, cell_len = intToCell, strRecordString = ''; cell_i < cell_len; cell_i += 1) {
                                    if (arrCells[cell_i].hasAttribute('selected')) {
                                        if (arrCells[cell_i].lastElementChild) {
                                            strCellText = arrCells[cell_i].lastElementChild.textValue ||
                                                          arrCells[cell_i].lastElementChild.value ||
                                                          (arrCells[cell_i].lastElementChild.checked || '').toString();
                                        } else {
                                            strCellText = arrCells[cell_i].textContent.trim();
                                        }
                                    } else {
                                        strCellText = '';
                                    }

                                    strRecordString += (cell_i !== intFromCell ? '\t' : '') + (strCellText || '');
                                }
                                if (strRecordString.trim()) {
                                    strCopyString += strRecordString;
                                }
                                if (i + 1 !== len && strRecordString.trim()) {
                                    strCopyString += '\n';
                                }
                            }
                        }

                        if (strCopyString) {
                            if (handleClipboardData(event, strCopyString)) {
                                event.preventDefault(event);
                            }
                        }
                    }
                });

                // getData
                refreshHud(element);
                getData(element);
            }
        }
    }

    xtag.register('gs-envelope', {
        lifecycle: {
            created: function () {
                //console.log(this.outerHTML);
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (strAttrName === 'template') {
                    var tableTemplateElement, tableTemplateElementCopy, recordElement, element = this, i, len;
                    tableTemplateElement  = element.templates[element.getAttribute('template') || 'default'];
                    //console.log(tableTemplateElement);
                    if (!tableTemplateElement && element.hasAttribute('template')) {
                        console.warn('ENVELOPE WARNING: Hey! You used the name of a non-existant record template!');
                        tableTemplateElement = element.templates['default'];
                    }
                    //console.log(tableTemplateElement);

                    if (tableTemplateElement) {
                        //console.log(tableTemplateElement);
                        tableTemplateElementCopy = document.createElement('template');
                        tableTemplateElementCopy.innerHTML = tableTemplateElement.innerHTML;

                        recordElement = xtag.query(xtag.query(tableTemplateElementCopy.content, 'tbody')[0], 'tr')[0];

                        if (recordElement) {
                            // add a data- attribute for all where columns (most of the time: id and change_stamp)
                            for (i = 0, len = element.arrWhereColumns.length; i < len; i += 1) {
                                recordElement.setAttribute('data-' + element.arrWhereColumns[i], '{{! row.' + element.arrWhereColumns[i] + ' }}');
                            }

                            // add a doT.js coded "value" attribute to any element with a "column" attribute but no "value" attribute
                            element.tableTemplate = GS.templateColumnToValue(tableTemplateElementCopy.innerHTML);
                        }
                    } else {
                        throw 'Envelope error: table template is required.';
                    }
                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'no-hudlimit' ||
                        strAttrName === 'no-hudorderby' ||
                        strAttrName === 'no-huddelete' ||
                        strAttrName === 'no-hudrefresh') {
                        refreshHud(this);

                    // this.root is here becuase of an issue where refresh was called before the envelope was initialized
                    } else if (strAttrName === 'value' && this.root) {
                        this.refresh();
                    }
                }
            }
        },
        events: {},
        accessors: {
            value: {
                get: function () {
                    return this.getAttribute('value');
                },

                set: function (newValue) {
                    this.setAttribute('value', newValue);
                    getData(this);
                }
            },
            selectedCells: {
                get: function () {
                    return xtag.query(this.scrollContainerElement, '[selected]');
                },

                set: function (newValue) {
                    var i, len, intIdIndex, arrCells = xtag.query(this.scrollContainerElement, '[selected]'), arrRecords, cell_i, cell_len,
                        fixedHeaderCells = xtag.queryChildren(this.fixedHeaderContainerElement, '.fixed-header-cell');

                    //console.log(arrRecords);

                    // clear old selection
                    for (i = 0, len = fixedHeaderCells.length; i < len; i += 1) {
                        fixedHeaderCells[i].removeAttribute('selected');
                    }
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected');
                    }

                    arrCells = xtag.query(this.scrollContainerElement, '[selected-secondary]');
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected-secondary');
                    }

                    // if newValue is not an array: make it an array
                    if (typeof newValue === 'object' && newValue.length === undefined) {
                        arrCells = [newValue];
                    } else {
                        arrCells = newValue;
                    }

                    // set new selection
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].setAttribute('selected', '');

                        if (arrCells[i].parentNode.parentNode.nodeName === 'THEAD') {
                            fixedHeaderCells[arrCells[i].cellIndex].setAttribute('selected', '');
                        }
                    }

                    arrRecords = this.selectedRecords;

                    for (i = 0, len = arrRecords.length; i < len; i += 1) {
                        arrCells = arrRecords[i].children;

                        for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                            if (!arrCells[cell_i].hasAttribute('selected')) {
                                arrCells[cell_i].setAttribute('selected-secondary', '');
                            }
                        }
                    }

                    GS.triggerEvent(this, 'after_selection');
                }
            },
            selectedRecords: {
                get: function () {
                    var i, len, intRecordIndex = -1, arrRecord = [], selected = this.selectedCells;

                    // loop through the selected cells and create an array of trs
                    for (i = 0, len = selected.length; i < len; i += 1) {
                        if (selected[i].parentNode.rowIndex > intRecordIndex && selected[i].parentNode.parentNode.nodeName !== 'THEAD') {
                            intRecordIndex = selected[i].parentNode.rowIndex;

                            arrRecord.push(selected[i].parentNode);
                        }
                    }

                    return arrRecord;
                },

                set: function (newValue) {
                    var i, len, cell_i, cell_len, intIdIndex, arrCells = this.selectedCells, arrRecords, arrCellChildren,
                        fixedHeaderCells = xtag.queryChildren(this.fixedHeaderContainerElement, '.fixed-header-cell');

                    // clear old selection
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected');

                        if (arrCells[i].parentNode.parentNode.nodeName === 'THEAD') {
                            fixedHeaderCells[arrCells[i].cellIndex].removeAttribute('selected', '');
                        }
                    }

                    arrCells = xtag.query(this.scrollContainerElement, '[selected-secondary]');
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected-secondary');
                    }

                    // if newValue is not an array: make it an array
                    if (typeof newValue === 'object' && newValue.length === undefined) {
                        arrRecords = [newValue];
                    } else {
                        arrRecords = newValue;
                    }

                    // set new selection
                    for (i = 0, len = arrRecords.length, arrCells = []; i < len; i += 1) {
                        arrCellChildren = arrRecords[i].children;

                        for (cell_i = 0, cell_len = arrCellChildren.length; cell_i < cell_len; cell_i += 1) {
                            arrCells.push(arrCellChildren[cell_i]);
                        }
                    }

                    this.selectedCells = arrCells;

                    GS.triggerEvent(this, 'after_selection');
                }
            },
            selectedIds: {
                get: function () {
                    var i, len, arrID = [], selected = this.selectedRecords;

                    // loop through the selected records and create an array of ids
                    for (i = 0, len = selected.length; i < len; i += 1) {
                        arrID.push(String(selected[i].dataset.id));
                        //arrID.push(String(selected[i].parentNode.dataset.id));
                    }

                    return arrID;
                },

                set: function (newValue) {
                    var i, len, cell_i, cell_len, arrCells = this.selectedCells, // intIdIndex,
                        arrRecords = xtag.query(this.scrollContainerElement, 'tbody > tr');

                    //console.log(arrRecords);

                    // clear old selection
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected');
                    }

                    arrCells = xtag.query(this.scrollContainerElement, '[selected-secondary]');
                    for (i = 0, len = arrCells.length; i < len; i += 1) {
                        arrCells[i].removeAttribute('selected-secondary');
                    }

                    // if newValue is not an array: make it an array
                    if (typeof newValue !== 'object') {
                        newValue = [String(newValue)];

                    // else: cast all new values to strings
                    } else {
                        for (i = 0, len = newValue.length; i < len; i += 1) {
                            newValue[i] = String(newValue[i]);
                        }
                    }

                    // set new selection
                    for (i = 0, len = arrRecords.length; i < len; i += 1) {

                        if (newValue.indexOf(arrRecords[i].getAttribute('data-id')) > -1) {//String(.dataset.id) === String()
                            arrCells = arrRecords[i].children;

                            for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                                arrCells[cell_i].setAttribute('selected', '');
                            }
                        }
                    }

                    GS.triggerEvent(this, 'after_selection');
                }
            }
        },
        methods: {
            // just a semantic alias to the getData function
            refresh: function () {
                getData(this);
            },

            refreshReflow: function () {
                var intEnvelopeWidth = this.scrollContainerElement.clientWidth + 1,
                    bolCurrentlyReflowed,
                    intWindowWidth = window.innerWidth,
                    intReflowAt = parseInt(this.getAttribute('reflow-at'), 10);

                if (this.reflowBreakPoint === undefined) {
                    this.reflowBreakPoint = 0;
                }

                //console.log('check for reflow', window.innerWidth, this.reflowBreakPoint,
                // this.scrollContainerElement.clientWidth < this.scrollContainerElement.scrollWidth);

                bolCurrentlyReflowed = this.classList.contains('reflow');
                this.classList.remove('reflow');

                //console.log(intEnvelopeWidth, this.scrollContainerElement.scrollWidth);
                //console.log('envWidth    ', intEnvelopeWidth);
                //console.log('scrollWidth ', this.scrollContainerElement.scrollWidth);
                //console.log('reflowAt    ', this.hasAttribute('reflow-at'));
                //console.log('intReflowAt ', intReflowAt);

                //if (intWindowWidth > this.reflowBreakPoint) {
                if ((
                        intEnvelopeWidth < this.scrollContainerElement.scrollWidth &&
                        !this.hasAttribute('reflow-at')
                    ) ||
                    (
                        !isNaN(intReflowAt) &&
                        intEnvelopeWidth < intReflowAt
                    )) {
                    if (!bolCurrentlyReflowed) {
                        this.selectedCells = [];
                    }

                    this.reflowBreakPoint = intWindowWidth;
                    this.classList.add('reflow');

                } else {
                    if (bolCurrentlyReflowed) {
                        this.selectedCells = [];
                    }

                    this.reflowBreakPoint = 0;
                    this.classList.remove('reflow');
                }
            },

            refreshFixedHeader: function () {
                var elementFixedHeaderCells = xtag.queryChildren(this.fixedHeaderContainerElement, '.fixed-header-cell'),
                    theadCellElements, i, len, intLeft;

                if (this.theadElement && GS.getStyle(this.theadElement, 'display') !== 'none') {
                    //Why isn't this after we set the widths of the fixed header? -Joseph 10-01-15
                    this.fixedHeaderContainerElement.removeAttribute('hidden');
                    theadCellElements = xtag.query(this.theadElement, 'th, td');

                    for (i = 0, len = theadCellElements.length, intLeft = 0; i < len; i += 1) {
                        elementFixedHeaderCells[i].style.height = (theadCellElements[i].offsetHeight + 1) + 'px';
                        elementFixedHeaderCells[i].style.width = theadCellElements[i].offsetWidth + 'px';
                        elementFixedHeaderCells[i].style.left = (intLeft - this.scrollContainerElement.scrollLeft) + 'px';

                        intLeft += theadCellElements[i].offsetWidth;
                    }
                } else {
                    this.fixedHeaderContainerElement.setAttribute('hidden', '');
                }
            },

            refreshHeight: function () {
                var intHeight = 0;

                //console.log('1*** refreshHeight');

                // if this envelope is zero height: add expand to content automatically
                if (this.clientHeight === 0) {
                    this.setAttribute('expand-to-content', '');
                }

                //console.log('1-1*', this);
                //console.log('1-2*', this.hasAttribute('expand-to-content'));
                if (this.hasAttribute('expand-to-content')) {
                    //console.log('2***');
                    this.style.height = '';

                    intHeight += this.hudTopElement.scrollHeight;
                    //console.log('3***');
                    //intHeight += this.fixedHeaderContainerElement.scrollHeight;
                    intHeight += this.scrollContainerElement.scrollHeight;
                    intHeight += this.hudBottomElement.scrollHeight;
                    //console.log('4***', intHeight);

                    this.style.height = (intHeight + 5) + 'px'; // used to add 2
                    //console.log('5***', this.style.height);
                }
            }
        }
    });
});//jslint white:true, multivar:true


window.addEventListener('design-register-element', function () {
    window.designElementProperty_GSFOLDER = function(selectedElement) {
        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Path', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('path') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'path', this.value);
        });

        addProp('Hide Folders', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-folders')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-folders', (this.value === 'true'), true);
        });

        addProp('Hide Files', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-files')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-files', (this.value === 'true'), true);
        });

        addProp('Side-By-Side', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('horizontal')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'horizontal', (this.value === 'true'), true);
        });

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', (this.value === 'true'), true);
        });
    };

    registerDesignSnippet('<gs-folder>', '<gs-folder>', 'gs-folder path="${0:/}" folder="${1:role}"></gs-folder>');

    designRegisterElement('gs-folder', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-folder.html');
});

(function () {
    'use strict';

    // #################################################################################################
    // ############################################ UTILITY ############################################
    // #################################################################################################

    function getPath(element) {
        var strAttributePath = GS.trim(GS.templateWithQuerystring(element.getAttribute('path') || ''), '/')
          , strInnerPath = element.arrPath.join('/'), strRet;

        if (strAttributePath && strInnerPath) {
            strRet = '/' + strAttributePath + '/' + strInnerPath + '/';
        } else if (strAttributePath) {
            strRet = '/' + strAttributePath + '/';
        } else if (strInnerPath) {
            strRet = '/' + strInnerPath + '/';
        }

        return strRet || '/';
    }

    function getRealPath(element) {
        var strAttributePath = GS.trim(GS.templateWithQuerystring(element.getAttribute('path') || ''), '/')
          , arrPath = element.arrPath, strInnerPath, strRet, strPrefix;

        if (element.arrPath[0] === 'app' || strAttributePath.indexOf('app') === 0) {
            strPrefix = '/env';
        } else if (element.arrPath[0] === 'role' || strAttributePath.indexOf('role') === 0) {
            strPrefix = '/env';
        } else if (element.arrPath[0] === 'web_root' || strAttributePath.indexOf('web_root') === 0) {
            strPrefix = '';
            arrPath.splice(0, 1);
        }

        strInnerPath = arrPath.join('/');

        if (strAttributePath && strInnerPath) {
            strRet = '/' + strAttributePath + '/' + strInnerPath + '/';
        } else if (strAttributePath) {
            strRet = '/' + strAttributePath + '/';
        } else if (strInnerPath) {
            strRet = '/' + strInnerPath + '/';
        }

        return (strPrefix || '') + (strRet || '/');
    }

    function getData(element) {
        var strPath = getPath(element)
          , bolFolders = !element.hasAttribute('no-folders')
          , bolFiles = !element.hasAttribute('no-files')
          , strHeader
          , intResponseNumber;

        element.folderList.innerHTML = '';
        element.fileList.innerHTML = '';

        strHeader = GS.trim('/' + element.arrPath.join('/'), '/');

        // if there is something in the header: wrap it with slashes
        if (strHeader) {
            strHeader = '/' + strHeader + '/';
        }

        element.pathTitle.textContent = strHeader;

        if (element.arrPath.length > 0) {
            element.backButton.removeAttribute('disabled');
        } else {
            element.backButton.setAttribute('disabled', '');
        }
        element.arrFile = [];
        element.arrFolder = [];
        intResponseNumber = 0;
        GS.requestFromSocket(GS.envSocket, 'FILE\tLIST\t' + GS.encodeForTabDelimited(strPath), function (data, error, errorData) {
            var arrPaths, strName, strType, arrCells, i, len, divElement
              , arrFiles = [], arrFolders = [];

            if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                if (data !== 'TRANSACTION COMPLETED') {
                    arrPaths = GS.trim(data, '\n').split('\n');
                    if (intResponseNumber === 0) {
                        element.folderList.innerHTML = '';
                        element.fileList.innerHTML = '';
                    }

                    for (i = 0, len = arrPaths.length; i < len; i += 1) {
                        arrCells = arrPaths[i].split('\t');
                        strType = GS.decodeFromTabDelimited(arrCells[1]);
                        strName = GS.trim(GS.decodeFromTabDelimited(arrCells[0]), '/');

                        if ((strType === 'folder' && bolFolders) || (strType === 'file' && bolFiles)) {
                            divElement = document.createElement('div');
                            divElement.setAttribute('flex-horizontal', '');
                            divElement.setAttribute('flex-fill', '');
                            divElement.setAttribute('class', strType + '-line');
                            divElement.setAttribute('data-name', strName);

                            if (strType === 'file') {
                                arrFiles.push(element.arrPath.join('/') + '/' + strName);
                                divElement.innerHTML =
                                    '<gs-button class="more-file" icononly icon="bars" remove-right></gs-button>'
                                  + '<gs-button class="open-file" flex remove-left>' + encodeHTML(strName) + '</gs-button>';

                                element.fileList.appendChild(divElement);
                            }

                            if (strType === 'folder') {
                                arrFolders.push(element.arrPath.join('/') + '/' + strName);
                                divElement.innerHTML =
                                    '<gs-button class="more-folder" icononly icon="bars" remove-right></gs-button>'
                                  + '<gs-button class="open-folder" flex remove-left>' + encodeHTML(strName) + '</gs-button>';

                                element.folderList.appendChild(divElement);
                            }
                        }
                    }

                    element.arrFile = arrFiles;
                    element.arrFolder = arrFolders;
                    GS.triggerEvent(element, 'change');

                } else {
                    if (element.folderList.innerHTML === '') {
                        element.folderList.innerHTML = '<center prevent-text-selection><h4><small>No Folders.</small></h4></center>';
                    }

                    if (element.fileList.innerHTML === '') {
                        element.fileList.innerHTML = '<center prevent-text-selection><h4><small>No Files.</small></h4></center>';
                    }
                }
            } else if (error) {
                if (!element.hasAttribute('no-list-error')) {
                    GS.webSocketErrorDialog(errorData);
                }
            }

            intResponseNumber += 1;
        });
    }

    function prepareElement(element) {
        var bolFolders = !element.hasAttribute('no-folders')
          , bolFiles = !element.hasAttribute('no-files');

        element.innerHTML = ml(function () {/*
            <div class="root" flex-vertical flex-fill gs-dynamic>
                <span class="path-title"></span>
                <div class="list-container" flex-fill>
                    <div class="folder-list-container" flex-vertical flex-fill flex>
                        <div class="folder-list-header" flex-horizontal>
                            <b flex prevent-text-selection>Folders:</b>
                            <gs-button class="button-back-folder" icon="long-arrow-left" icononly remove-bottom disabled no-focus></gs-button>
                            <gs-button class="button-new-folder" icon="plus" icononly remove-bottom no-focus></gs-button>
                        </div>
                        <div class="folder-list" flex></div>
                    </div>
                    <div class="file-list-container" flex-vertical flex-fill flex>
                        <div class="file-list-header" flex-horizontal>
                            <b flex prevent-text-selection>Files:</b>
                            <gs-button class="button-new-file" icon="plus" icononly remove-bottom no-focus></gs-button>
                            <gs-button class="button-upload-file" icon="upload" icononly remove-bottom no-focus></gs-button>
                        </div>
                        <div class="file-list" flex></div>
                    </div>
                </div>
            </div>
        */});
        //remove-right
        //remove-left

        element.root             = xtag.queryChildren(element, '.root')[0];
        element.folderListHeader = xtag.query(element.root, '.folder-list-header')[0];
        element.fileListHeader   = xtag.query(element.root, '.file-list-header')[0];

        element.folderList       = xtag.query(element.root, '.folder-list')[0];
        element.fileList         = xtag.query(element.root, '.file-list')[0];

        element.newFolderButton  = xtag.query(element.root, '.button-new-folder')[0];
        element.newFileButton    = xtag.query(element.root, '.button-new-file')[0];
        element.uploadFileButton = xtag.query(element.root, '.button-upload-file')[0];
        element.backButton       = xtag.query(element.root, '.button-back-folder')[0];

        element.pathTitle        = xtag.query(element.root, '.path-title')[0];

        element.arrPath = [];
    }

    //function pushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //
    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        getData(element);
    //    }
    //}

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol && strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun === true && GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                //console.trace(element, 'test');
                getData(element);
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    function bindElement(element) {
        if (element.hasAttribute('qs')) {
            pushReplacePopHandler(element);
            window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
            window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
            window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
        }

        element.addEventListener('click', function (event) {
            var target = event.target;

            if (target.classList.contains('button-new-folder')) {
                newFolder(element, target);

            } else if (target.classList.contains('button-new-file')) {
                newFile(element, target);

            } else if (target.classList.contains('open-file')) {
                fileOpen(element, target);

            } else if (target.classList.contains('open-folder')) {
                folderOpen(element, target);

            } else if (target.classList.contains('button-back-folder')) {
                backFolder(element, target);

            } else if (target.classList.contains('more-folder')) {
                folderMenu(element, target);

            } else if (target.classList.contains('more-file')) {
                fileMenu(element, target);

            } else if (target.classList.contains('button-upload-file')) {
                fileUpload(element, target);
            }
        });
    }


    // ################################################################################################
    // ####################################### FOLDER FUNCTIONS #######################################
    // ################################################################################################

    function folderMenu(element, target) {
        'use strict';
        var lineElement = GS.findParentElement(target, '.folder-line')
          , strFolderName = lineElement.getAttribute('data-name')
          , strPath = (getPath(element) + strFolderName)
          , templateElement = document.createElement('template');

        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                <gs-button dialogclose remove-bottom style="border-bottom: 0 none;">Rename Folder</gs-button>
                <gs-button dialogclose remove-top>Delete Folder</gs-button>
                <hr />
                <gs-button dialogclose>Cancel</gs-button>
            </gs-body>
        */});

        GS.openDialogToElement(target, templateElement, 'right', '', function (event, strAnswer) {
            if (strAnswer === 'Rename Folder') {
                folderRename(element, target, strPath, strFolderName);

            } else if (strAnswer === 'Delete Folder') {
                folderDelete(element, target, strPath, strFolderName);
            }
        });
    }

    function folderRename(element, target, strOldPath, strFolderName) {
        'use strict';
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                <label for="gs-file-manager-text-folder-name">Folder Name:</label>
                <gs-text id="gs-file-manager-text-folder-name"></gs-text>
                <hr />
                <gs-grid>
                    <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right>Cancel</gs-button></gs-block>
                    <gs-block><gs-button dialogclose remove-left>Rename</gs-button></gs-block>
                </gs-grid>
            </gs-body>
        */});

        GS.openDialogToElement(target, templateElement, 'right', function () {
            document.getElementById('gs-file-manager-text-folder-name').value = strFolderName;

        }, function (event, strAnswer) {
            var strNewPath;

            if (strAnswer === 'Rename') {
                strNewPath = getPath(element) + document.getElementById('gs-file-manager-text-folder-name').value;

                //console.log('strOldPath:', strOldPath);
                //console.log('strNewPath:', strNewPath);

                GS.requestFromSocket(GS.envSocket
                                   , 'FILE\tMOVE\t' + GS.encodeForTabDelimited(strOldPath) + '\t' +
                                                      GS.encodeForTabDelimited(strNewPath) + '\n'
                                   , function (data, error, errorData) {
                    if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                        if (data === 'TRANSACTION COMPLETED') {
                            getData(element);
                        }
                    } else if (error) {
                        GS.webSocketErrorDialog(errorData);
                    }
                });
            }
        });
    }

    function folderDelete(element, target, strPath, strFolderName) {
        'use strict';
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                Are you sure you want to delete the folder: "<b>{{STRPATH}}</b>"?
                <hr />
                <gs-grid>
                    <gs-block><gs-button dialogclose remove-right style="border-right: 0 none;">No</gs-button></gs-block>
                    <gs-block><gs-button dialogclose remove-left>Yes</gs-button></gs-block>
                </gs-grid>
            </gs-body>
        */}).replace(/\{\{STRPATH\}\}/gi, strFolderName);

        GS.openDialogToElement(target, templateElement, 'right', '', function (event, strAnswer) {
            if (strAnswer === 'Yes') {
                //console.log('Delete:', strPath);

                GS.requestFromSocket(GS.envSocket
                                   , 'FILE\tDELETE\t' + GS.encodeForTabDelimited(strPath) + '\n'
                                   , function (data, error, errorData) {
                    if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                        if (data === 'TRANSACTION COMPLETED') {
                            getData(element);
                        }
                    } else if (error) {
                        GS.webSocketErrorDialog(errorData);
                    }
                });
            }
        });
    }

    function newFolder(element, target) {
        'use strict';
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                <label for="gs-file-manager-text-folder-name">New Folder Name:</label>
                <gs-text id="gs-file-manager-text-folder-name"></gs-text>
                <hr />
                <gs-grid>
                    <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right>Cancel</gs-button></gs-block>
                    <gs-block><gs-button dialogclose remove-left>Create</gs-button></gs-block>
                </gs-grid>
            </gs-body>
        */});

        GS.openDialogToElement(target, templateElement, 'down', '', function (event, strAnswer) {
            var strPath;

            if (strAnswer === 'Create') {
                strPath = getPath(element) + document.getElementById('gs-file-manager-text-folder-name').value;
                //console.log('Create:', strPath);

                GS.requestFromSocket(GS.envSocket
                                   , 'FILE\tCREATE_FOLDER\t' + GS.encodeForTabDelimited(strPath) + '\n'
                                   , function (data, error, errorData) {
                    if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                        if (data === 'TRANSACTION COMPLETED') {
                            getData(element);
                        }
                    } else if (error) {
                        GS.webSocketErrorDialog(errorData);
                    }
                });
            }
        });
    }

    function folderOpen(element, target) {
        'use strict';
        var lineElement = GS.findParentElement(target, '.folder-line');

        element.arrPath.push(lineElement.getAttribute('data-name'));
        getData(element);
    }

    function backFolder(element, target) {
        'use strict';
        element.arrPath.pop();
        getData(element);
    }

    // ################################################################################################
    // ######################################## FILE FUNCTIONS ########################################
    // ################################################################################################

    function fileMenu(element, target) {
        'use strict';
        var lineElement = GS.findParentElement(target, '.file-line')
          , strFileName = lineElement.getAttribute('data-name')
          //, intPeriodIndex = strFileName.indexOf('.')
          //, strFileExtension = strFileName.substring(intPeriodIndex)
          , strPath = getPath(element) + strFileName
          , templateElement = document.createElement('template');

        //console.log(strFileExtension);

        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                <gs-button dialogclose remove-bottom style="border-bottom: 0 none;">Rename File</gs-button>
                <gs-button dialogclose remove-all style="border-bottom: 0 none;">Delete File</gs-button>
                <gs-button dialogclose remove-top>Edit File</gs-button>
                <hr />
                <gs-button dialogclose>Cancel</gs-button>
            </gs-body>
        */});

        GS.openDialogToElement(target, templateElement, 'right', '', function (event, strAnswer) {
            if (strAnswer === 'Rename File') {
                fileRename(element, target, strPath, strFileName);

            } else if (strAnswer === 'Delete File') {
                fileDelete(element, target, strPath, strFileName);

            } else if (strAnswer === 'Edit File') {
                fileEdit(element, target, strPath, strFileName);
            }
        });
    }

    function fileRename(element, target, strOldPath, strFileName) {
        'use strict';
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                <label for="gs-file-manager-text-file-name">File Name:</label>
                <gs-text id="gs-file-manager-text-file-name"></gs-text>
                <hr />
                <gs-grid>
                    <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right>Cancel</gs-button></gs-block>
                    <gs-block><gs-button dialogclose remove-left>Rename</gs-button></gs-block>
                </gs-grid>
            </gs-body>
        */});

        GS.openDialogToElement(target, templateElement, 'right', function () {
            document.getElementById('gs-file-manager-text-file-name').value = strFileName;

        }, function (event, strAnswer) {
            var strNewPath;

            if (strAnswer === 'Rename') {
                strNewPath = getPath(element) + document.getElementById('gs-file-manager-text-file-name').value;

                //console.log('strOldPath:', strOldPath);
                //console.log('strNewPath:', strNewPath);

                GS.requestFromSocket(GS.envSocket
                                   , 'FILE\tMOVE\t' + GS.encodeForTabDelimited(strOldPath) + '\t' +
                                                      GS.encodeForTabDelimited(strNewPath) + '\n'
                                   , function (data, error, errorData) {
                    if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                        if (data === 'TRANSACTION COMPLETED') {
                            getData(element);
                        }
                    } else if (error) {
                        GS.webSocketErrorDialog(errorData);
                    }
                });
            }
        });
    }

    function fileDelete(element, target, strPath, strFileName) {
        'use strict';
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                Are you sure you want to delete the file: "<b>{{STRPATH}}</b>"?
                <hr />
                <gs-grid>
                    <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right>No</gs-button></gs-block>
                    <gs-block><gs-button dialogclose remove-left>Yes</gs-button></gs-block>
                </gs-grid>
            </gs-body>
        */}).replace(/\{\{STRPATH\}\}/gi, strFileName);

        GS.openDialogToElement(target, templateElement, 'right', '', function (event, strAnswer) {
            if (strAnswer === 'Yes') {
                //console.log('Delete:', strPath);

                GS.requestFromSocket(GS.envSocket
                                   , 'FILE\tDELETE\t' + GS.encodeForTabDelimited(strPath) + '\n'
                                   , function (data, error, errorData) {
                    if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                        if (data === 'TRANSACTION COMPLETED') {
                            getData(element);
                        }
                    } else if (error) {
                        GS.webSocketErrorDialog(errorData);
                    }
                });
            }
        });
    }

    function fileEdit(element, target, strPath, strFileName) {
        'use strict';
        window.open('/env/app/all/file_manager/file_edit.html?socket=true&link=' + encodeURIComponent(strPath));
    }

    function newFile(element, target) {
        'use strict';
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.setAttribute('data-max-width', '250px');
        templateElement.innerHTML = ml(function () {/*
            <gs-body padded>
                <label for="gs-file-manager-text-file-name">New File Name:</label>
                <gs-text id="gs-file-manager-text-file-name"></gs-text>
                <hr />
                <gs-grid>
                    <gs-block><gs-button dialogclose style="border-right: 0 none;" remove-right>Cancel</gs-button></gs-block>
                    <gs-block><gs-button dialogclose remove-left>Create</gs-button></gs-block>
                </gs-grid>
            </gs-body>
        */});

        GS.openDialogToElement(target, templateElement, 'down', '', function (event, strAnswer) {
            var strPath;
            var strName = document.getElementById('gs-file-manager-text-file-name').value || '';

            //console.log('Name:', strName);

            if (strAnswer === 'Create' && strName) {
                strPath = getPath(element) + strName;
                //console.log('Create:', strPath);

                if (document.getElementById('gs-file-manager-text-file-name').value.trim()) {
                    GS.requestFromSocket(GS.envSocket
                                       , 'FILE\tCREATE_FILE\t' + GS.encodeForTabDelimited(strPath) + '\n'
                                       , function (data, error, errorData) {
                        if (!error && data.trim() && data.indexOf('Failed to get canonical path') === -1) {
                            if (data === 'TRANSACTION COMPLETED') {
                                getData(element);
                            }
                        } else if (error) {
                            GS.webSocketErrorDialog(errorData);
                        }
                    });
                }
            }
        });
    }

    function fileOpen(element, target) {
        'use strict';
        var lineElement = GS.findParentElement(target, '.file-line');

        window.open(location.protocol + '//' + location.host + getRealPath(element) + '' + lineElement.getAttribute('data-name'));
    }


    // ################################################################################################
    // ############################################# XTAG #############################################
    // ################################################################################################

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                prepareElement(element);
                bindElement(element);

                //// if no "qs" set or "qs" key set in query string <- non-standard behaviour, you could want
                //if ((!element.hasAttribute('qs') || GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs')))) {
                //    getData(element);
                //}

                getData(element);
                //pushReplacePopHandler(element);
            }
        }
    }

    xtag.register('gs-folder', {
        lifecycle: {
            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {

                }
            }
        },
        events: {},
        accessors: {},
        methods: {}
    });
}());
window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('<gs-font>', '<gs-font>', 'gs-font min-width="${1}">\n' +
                                                    '    ${0}\n' +
                                                    '</gs-font>');

    designRegisterElement('gs-font', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-font.html');

    window.designElementProperty_GSFONT = function (selectedElement) {
        addProp('Min-Width Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('min-width') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'min-width', this.value);
        });

        addProp('Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('media') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'media', this.value);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var arrTakenFonts = [];

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    //
    function elementInserted(element) {
        var styleElement;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                // if the style element for the container CSS doesn't exist: create it
                if (!document.getElementById('gs-dynamic-css')) {
                    styleElement = document.createElement('style');
                    styleElement.setAttribute('id', 'gs-dynamic-css');
                    styleElement.setAttribute('gs-dynamic', '');
                    document.head.appendChild(styleElement);
                }

                if (element.getAttribute('min-width')) {
                    element.handleMinWidthCSS();
                } else if (element.getAttribute('media')) {
                    element.handleMediaCSS();
                }
            }
        }
    }

    xtag.register('gs-font', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // if the "min-width" attribute changed
                    if (strAttrName === 'min-width') {
                        this.handleMinWidthCSS();

                    // if the "media" attribute changed
                    } else if (strAttrName === 'media') {
                        this.handleMediaCSS();
                    }
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            handleMinWidthCSS: function () {
                var strMinWidth = this.getAttribute('min-width'), arrMinWidths, strCSS, i, len, arrClassesToRemove, intContainerID,
                    arrParts, strMedia, strResult;

                // remove old classes
                arrClassesToRemove = String(this.classList).match(/font-id-[0-9]*/g) || [];

                for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                    this.classList.remove(arrClassesToRemove[i]);
                }

                // all {15px}; lrg {25px};
                // all {15px}; lrg {25px};
                // all {20px}; sml {25px}; med {30px}; lrg {35px};

                // all close curly braces, remove all whitespace, lowercase, trim off semicolons
                strMinWidth = GS.trim(strMinWidth.replace(/\}/g, '').replace(/\s+/g, '').toLowerCase(), ';');

                // replace shortcuts (lrg => 1200px)
                strMinWidth = strMinWidth.replace(/all/g, '0px')
                                         .replace(/small|sml/g, '768px')
                                         .replace(/medium|med/g, '992px')
                                         .replace(/large|lrg/g, '1200px');

                arrMinWidths = strMinWidth.split(';'); // seperate out layouts

                //console.log(strMinWidth, arrMinWidths);

                if (arrTakenFonts.indexOf(strMinWidth) === -1) {
                    arrTakenFonts.push(strMinWidth);
                    intContainerID = arrTakenFonts.length - 1;
                    strCSS = '';

                    for (i = 0, len = arrMinWidths.length; i < len; i += 1) {
                        arrParts = arrMinWidths[i].split('{');
                        strMedia = arrParts[0];
                        strResult = arrParts[1];

                        strCSS +=   '\n@media (min-width:' + strMedia + ') {\n' +
                                    '    gs-font.font-id-' + intContainerID + ' { font-size:' + strResult + '; }\n' +
                                    '}\n';
                    }

                    //console.log(strCSS);

                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* font #' + intContainerID + ' */\n' + strCSS;

                } else {
                    intContainerID = arrTakenFonts.indexOf(strMinWidth);
                }

                this.classList.add('font-id-' + intContainerID);
            },

            handleMediaCSS: function () {
                var strMedia = this.getAttribute('media'), arrMedias, strCSS, i, len,
                    arrClassesToRemove, arrParts, strCurrentMedia, strWidth, intContainerID;

                // remove old classes
                arrClassesToRemove = String(this.classList).match(/font-id-[0-9]*/g) || [];

                for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                    this.classList.remove(arrClassesToRemove[i]);
                }

                // print {20px}; all and (max-width: 500px) {20px}; (min-width: 500px) {25px};

                // trim, remove all close curly braces, lowercase, trim off semicolons
                strMedia = GS.trim(strMedia.trim().replace(/\}/g, '').toLowerCase(), ';');

                // replace shortcuts (lrg => 1200px)
                strMedia = strMedia.replace(/all/g, '0px')
                                   .replace(/small|sml/g, '768px')
                                   .replace(/medium|med/g, '992px')
                                   .replace(/large|lrg/g, '1200px');

                arrMedias = strMedia.split(';'); // seperate out layouts

                //console.log(strMedia, arrMedias);

                if (arrTakenFonts.indexOf(strMedia) === -1) {
                    arrTakenFonts.push(strMedia);
                    intContainerID = arrTakenFonts.length - 1;
                    strCSS = '';


                    for (i = 0, len = arrMedias.length; i < len; i += 1) {
                        arrParts = arrMedias[i].split('{');
                        strCurrentMedia = arrParts[0].trim() || 'all';
                        strWidth = arrParts[1].trim() || '900px';

                        strCSS +=   '\n@media ' + strCurrentMedia + ' {\n' +
                                    '    gs-font.font-id-' + intContainerID + ' ' +
                                                '{ font-size: ' + strWidth + '; }\n' +
                                    '}\n';
                    }

                    //console.log(strCSS);

                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* font #' + intContainerID + ' */\n' + strCSS;

                } else {
                    intContainerID = arrTakenFonts.indexOf(strMinWidth);
                }

                this.classList.add('font-id-' + intContainerID);
            }
        }
    });
});//global registerDesignSnippet, designRegisterElement, window, addProp, addFlexContainerProps, addFlexProps, document, xtag

window.addEventListener('design-register-element', function () {
    'use strict';
    registerDesignSnippet('<gs-footer>', '<gs-footer>', 'gs-footer>$0</gs-footer>');

    designRegisterElement('gs-footer', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-page.html');

    window.designElementProperty_GSFOOTER = function (selectedElement) {
        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility', true,
                '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                '    <option value="">Visible</option>' +
                '    <option value="hidden">Invisible</option>' +
                '    <option value="hide-on-desktop">Invisible at desktop size</option>' +
                '    <option value="hide-on-tablet">Invisible at tablet size</option>' +
                '    <option value="hide-on-phone">Invisible at phone size</option>' +
                '    <option value="show-on-desktop">Visible at desktop size</option>' +
                '    <option value="show-on-tablet">Visible at tablet size</option>' +
                '    <option value="show-on-phone">Visible at phone size</option>' +
                '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        addFlexContainerProps(selectedElement);
        //addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    xtag.register('gs-footer', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {}
    });
});//jslint white:true miltivar:true
window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('<gs-form>', '<gs-form>', 'gs-form src="${1:test.tpeople}">\n' +
                                                    '    <template>\n' +
                                                    '        ${2}\n' +
                                                    '    </template>\n' +
                                                    '</gs-form>');

    designRegisterElement('gs-form', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-form.html');

    window.designElementProperty_GSFORM = function (selectedElement) {
        addProp('Source', true, '<gs-memo class="target" value="' + encodeHTML(decodeURIComponent(selectedElement.getAttribute('src') ||
                                                                                        selectedElement.getAttribute('source') || '')) + '" mini></gs-memo>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'src', encodeURIComponent(this.value));
        });

        addProp('Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('cols') || '') + '" mini></gs-text>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'cols', this.value);
        });

        addProp('Where', true, '<gs-text class="target" value="' + encodeHTML(decodeURIComponent(selectedElement.getAttribute('where') || '')) + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'where', encodeURIComponent(this.value));
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Lock', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('lock') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'lock', this.value);
        });

        addProp('Order By', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('ord') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'ord', this.value);
        });

        addProp('Limit', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('limit') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'limit', this.value);
        });

        addProp('Offset', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('offset') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'offset', this.value);
        });

        addProp('Save&nbsp;While&nbsp;Typing', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('save-while-typing')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'save-while-typing', (this.value === 'true'), true);
        });

        addProp('Suppress<br />"No&nbsp;Record&nbsp;Found"<br />Error', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suppress-no-record-found')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suppress-no-record-found', (this.value === 'true'), true);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        addProp('Refresh On Querystring Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('refresh-on-querystring-values') || '') + '" mini></gs-text>', function () {
            this.removeAttribute('refresh-on-querystring-change');
            return setOrRemoveTextAttribute(selectedElement, 'refresh-on-querystring-values', this.value);
        });

        addProp('Refresh On Querystring Change', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('refresh-on-querystring-change')) + '" mini></gs-checkbox>', function () {
            this.removeAttribute('refresh-on-querystring-values');
            return setOrRemoveBooleanAttribute(selectedElement, 'refresh-on-querystring-change', this.value === 'true', true);
        });

        addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    function triggerAfterUpdate(element) {
        GS.triggerEvent(element, 'after_update');
        if (element.hasAttribute('afterupdate')) {
            new Function(element.getAttribute('afterupdate')).apply(element);
        }
    }

    // ##################################################################
    // ######################## UPDATE FUNCTIONS ########################
    // ##################################################################

    function emergencyUpdate(element) {
        if (element.currentSaveAjax) {
            element.currentSaveAjax.abort();
        }
        element.bolCurrentlySaving = false;
        updateDataWithoutTemplate(element, false);
    }

    function updateData(element, updateElement, strColumn, newValue) {
        var data, parentRecord, strID, strHash
          , srcParts = GS.templateWithQuerystring(element.getAttribute('src')).split('.')
          , strSchema = srcParts[0]
          , strObject = srcParts[1]
          , strReturnCols = element.arrColumns.join('\t')
          , strHashCols = element.lockColumn
          , updateFrameData, strRoles, strColumns, arrTotalRecords = [];

        parentRecord = GS.findParentElement(updateElement, '.form-record');

        strID = parentRecord.getAttribute('data-id');
        strHash = CryptoJS.MD5(parentRecord.getAttribute('data-' + element.lockColumn)).toString();

        strRoles   = 'pk\thash\tset';
        strColumns = 'id\thash\t' + GS.encodeForTabDelimited(strColumn);
        updateFrameData = strID + '\t' + strHash + '\t' + GS.encodeForTabDelimited(newValue);

        updateFrameData = (strRoles + '\n' + strColumns + '\n' + updateFrameData);
        GS.triggerEvent(element, 'before_update');

        GS.requestUpdateFromSocket(
            GS.envSocket, strSchema, strObject
          , strReturnCols, strHashCols, updateFrameData

          , function (data, error, transactionID) {
                if (error) {
                    getData(element);
                    GS.removeLoader(element);
                    GS.webSocketErrorDialog(data);
                }
            }
          , function (data, error, transactionID, commitFunction, rollbackFunction) {
                GS.removeLoader(element);

                if (!error) {
                    if (data === 'TRANSACTION COMPLETED') {
                        commitFunction();
                    } else {
                        var arrRecords, arrCells, i, len, cell_i, cell_len;

                        arrRecords = GS.trim(data, '\n').split('\n');

                        for (i = 0, len = arrRecords.length; i < len; i += 1) {
                            arrCells = arrRecords[i].split('\t');

                            for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                                arrCells[cell_i] = arrCells[cell_i] === '\\N' ? null : GS.decodeFromTabDelimited(arrCells[cell_i]);
                            }

                            arrTotalRecords.push(arrCells);
                        }
                    }

                } else {
                    rollbackFunction();
                    getData(element);
                    GS.webSocketErrorDialog(data);
                }
            }
          , function (strAnswer, data, error) {
                GS.removeLoader(element);

                if (!error) {
                    if (strAnswer === 'COMMIT') {
                        var idIndex, i, len;

                        idIndex = element.lastSuccessData.arr_column.indexOf('id');

                        for (i = 0, len = element.lastSuccessData.dat.length; i < len; i += 1) {
                            if (String(element.lastSuccessData.dat[i][idIndex]) === strID) {
                                element.lastSuccessData.dat[i] = arrTotalRecords[0];
                                break;
                            }
                        }

                        triggerAfterUpdate(element);
                        handleData(element, element.lastSuccessData);

                        GS.triggerEvent(element, 'after_update');
                    } else {
                        getData(element);
                    }
                } else {
                    getData(element);
                    GS.webSocketErrorDialog(data);
                }
            }
        );
    }

    function updateDataWithoutTemplate(element, bolErrorHandling) {
        if (element.bolCurrentlySaving === false && !element.bolErrorOpen) {
            var data, parentRecord, strID, strHash
              , srcParts = GS.templateWithQuerystring(element.getAttribute('src')).split('.')
              , strSchema = srcParts[0]
              , strObject = srcParts[1]
              , strReturnCols = element.arrColumns.join('\t')
              , strHashCols = element.lockColumn
              , updateFrameData, strRoles, strColumns, arrTotalRecords = [], functionUpdateRecord, col_key, key, strColumn, newValue, idIndex, i, len;

            functionUpdateRecord = function (strID, strColumn, recordIndex, strParameters) {
                var strWhere, strChangeStamp, strValue;

                element.bolCurrentlySaving = true;
                element.jsnUpdate[strID][strColumn] = undefined;

                // run ajax
                removeMessage(element, 'waiting');
                addMessage(element, 'saving');
                element.state = 'saving';

                strWhere        = GS.qryGetVal(strParameters, 'where');
                strColumn       = GS.qryGetVal(strParameters, 'column');
                strValue        = GS.qryGetVal(strParameters, 'value');

                strID           = GS.qryGetVal(strWhere,      'id');
                strChangeStamp  = GS.qryGetVal(strWhere,      element.lockColumn);

                strHash = CryptoJS.MD5(strChangeStamp).toString();

                //parentRecord = GS.findParentElement(updateElement, '.form-record');

                strRoles   = 'pk\thash\tset';
                strColumns = 'id\thash\t' + GS.encodeForTabDelimited(strColumn);
                updateFrameData = strID + '\t' + strHash + '\t' + GS.encodeForTabDelimited(strValue);

                updateFrameData = (strRoles + '\n' + strColumns + '\n' + updateFrameData);



                //console.log(strParameters);
                //console.log(updateFrameData);
                //console.log(strSchema, strObject, strReturnCols, strHashCols);

                GS.requestUpdateFromSocket(
                    GS.envSocket, strSchema, strObject
                  , strReturnCols, strHashCols, updateFrameData

                  , function (data, error, transactionID) {
                        if (error) {
                            getData(element);
                            GS.webSocketErrorDialog(data);
                        }
                    }
                  , function (data, error, transactionID, commitFunction, rollbackFunction) {
                        if (!error) {
                            if (data === 'TRANSACTION COMPLETED') {
                                commitFunction();
                            } else {
                                var arrRecords, arrCells, i, len, cell_i, cell_len;

                                arrRecords = GS.trim(data, '\n').split('\n');

                                for (i = 0, len = arrRecords.length; i < len; i += 1) {
                                    arrCells = arrRecords[i].split('\t');

                                    for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                                        arrCells[cell_i] = arrCells[cell_i] === '\\N' ? null : GS.decodeFromTabDelimited(arrCells[cell_i]);
                                    }

                                    arrTotalRecords.push(arrCells);
                                }
                            }

                        } else {
                            rollbackFunction();
                            getData(element);
                            GS.webSocketErrorDialog(data);
                        }
                    }
                  , function (strAnswer, data, error) {
                        var col_key, key, bolSaveWaiting;
                        removeMessage(element, 'saving');
                        element.state = 'saved';

                        GS.removeLoader(element);

                        if (!error) {
                            if (strAnswer === 'COMMIT') {
                                element.lastSuccessData.dat[recordIndex] = arrTotalRecords[0];
                                element.bolCurrentlySaving = false;

                                // if there is another save in the pipeline: bolSaveWaiting = true
                                for (key in element.jsnUpdate) {
                                    for (col_key in element.jsnUpdate[key]) {
                                        if (element.jsnUpdate[key][col_key] !== undefined) {
                                            bolSaveWaiting = true;
                                            break;
                                        }
                                    }
                                }

                                // if there is a save waiting: update again
                                if (bolSaveWaiting) {
                                    updateDataWithoutTemplate(element);

                                } else {
                                    triggerAfterUpdate(element);
                                }
                            } else {
                                getData(element);
                            }
                        } else {
                            GS.webSocketErrorDialog(data);
                        }
                    }
                );
            };

            // loop through the jsnUpdate variable and make one update for every record that needs an update
            console.log(JSON.stringify(element.jsnUpdate));

            for (key in element.jsnUpdate) {
                for (col_key in element.jsnUpdate[key]) {
                    if (element.jsnUpdate[key][col_key] !== undefined) {
                        strID = key;
                        strColumn = col_key;
                        newValue = element.jsnUpdate[key][col_key];
                        idIndex = element.lastSuccessData.arr_column.indexOf('id');

                        for (i = 0, len = element.lastSuccessData.dat.length; i < len; i += 1) {
                            if (String(element.lastSuccessData.dat[i][idIndex]) === strID) {
                                functionUpdateRecord(strID, strColumn, i,
                                            'where=' + encodeURIComponent(
                                                'id=' + strID +
                                                '&' + element.lockColumn + '=' + GS.envGetCell(element.lastSuccessData, i, element.lockColumn)
                                            ) +
                                            '&column=' + strColumn +
                                            '&value=' +  encodeURIComponent(newValue));

                                break;
                            }
                        }

                        break;
                    }
                }
            }
        }
    }


    // #################################################################
    // ######################### DATA HANDLING #########################
    // #################################################################

    // handles fetching the data
    //      if bolInitalLoad === true then
    //          use: initialize query COALESCE TO source query
    //      else
    //          use: source query
    function getData(element) { //bolClearPrevious
        var strSrc     = GS.templateWithQuerystring(element.getAttribute('src'))
          , srcParts   = strSrc[0] === '(' ? [strSrc, ''] : strSrc.split('.')
          , strSchema  = srcParts[0]
          , strObject  = srcParts[1]
          , strColumns = GS.templateWithQuerystring(element.getAttribute('cols') || '*').split(',').join('\t')
          , strWhere   = GS.templateWithQuerystring(element.getAttribute('where') || '')
          , strOrd     = GS.templateWithQuerystring(element.getAttribute('ord') || '')
          , strLimit   = GS.templateWithQuerystring(element.getAttribute('limit') || '1')
          , strOffset  = GS.templateWithQuerystring(element.getAttribute('offset') || '')
          , response_i = 0, response_len = 0, arrTotalRecords = [];

        GS.triggerEvent(element, 'before_select');
        GS.requestSelectFromSocket(GS.envSocket, strSchema, strObject, strColumns
                                 , strWhere, strOrd, strLimit, strOffset
                                 , function (data, error) {
            var arrRecords, arrCells, i, len, cell_i, cell_len;

            if (!error) {
                if (data.strMessage !== 'TRANSACTION COMPLETED') {
                    arrRecords = GS.trim(data.strMessage, '\n').split('\n');

                    for (i = 0, len = arrRecords.length; i < len; i += 1) {
                        arrCells = arrRecords[i].split('\t');

                        for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                            arrCells[cell_i] = arrCells[cell_i] === '\\N' ? null : GS.decodeFromTabDelimited(arrCells[cell_i]);
                        }

                        arrTotalRecords.push(arrCells);
                    }
                } else {
                    element.arrColumns = data.arrColumnNames;

                    handleData(element, {
                        "arr_column": data.arrColumnNames
                      , "dat": arrTotalRecords
                      , "row_count": arrTotalRecords.length
                    }, '', 'load');
                }
            } else {
                GS.webSocketErrorDialog(data);
            }
        });
    }

    // handles data result from method function: getData
    //      success:  template
    //      error:    add error classes
    function handleData(element, data, error, strAction, failCallback) {
        var arrElements, i, len, arrHeaders = [], intColumnElementFocusNumber, jsnSelection, matchElement,
            templateElement = document.createElement('template'), focusTimerID, focusToElement, timer_i;

        // clear any old error status
        element.classList.remove('error');

        if (!error && data.dat.length === 0 && !element.hasAttribute('limit') && !element.hasAttribute('suppress-no-record-found')) {
            templateElement.setAttribute('data-theme', 'error');
            templateElement.innerHTML = ml(function () {/*
                <gs-page>
                    <gs-header><center><h3>Error</h3></center></gs-header>
                    <gs-body padded>
                        <center>No record found</center>
                    </gs-body>
                    <gs-footer>
                        <gs-grid>
                            <gs-block><gs-button dialogclose>Cancel</gs-button></gs-block>
                            <gs-block><gs-button dialogclose listen-for-return bg-primary>Try Again</gs-button></gs-block>
                        </gs-grid>
                    </gs-footer>
                </gs-page>
            */});

            GS.openDialog(templateElement, '', function (event, strAnswer) {
                if (strAnswer === 'Try Again') {
                    element.refresh();
                }
            });
        }

        // if there was no error
        if (!error) {
            element.error = false;

            // save success data
            element.lastSuccessData = data;

            if (GS.findParentElement(document.activeElement, 'gs-form') === element) {
                //console.log('Hey');
                arrElements = xtag.query(element, '[column]');
                matchElement = GS.findParentElement(document.activeElement, '[column]');

                if (document.activeElement.nodeName === 'INPUT' || document.activeElement.nodeName === 'TEXTAREA') {
                    jsnSelection = GS.getInputSelection(document.activeElement);
                }

                if (matchElement) {
                    for (i = 0, len = arrElements.length; i < len; i += 1) {
                        if (arrElements[i] === matchElement) {
                            intColumnElementFocusNumber = i;
                            break;
                        }
                    }
                }
            }

            element.innerHTML = dataTemplateRecords(element, data);

            // if template is not native: handle templates inside the form
            if (shimmed.HTMLTemplateElement) {
                HTMLTemplateElement.bootstrap(element);
            }

            // handle autofocus
            arrElements = xtag.query(element, '[autofocus]');

            if (arrElements.length > 0 && !evt.touchDevice) {
                arrElements[0].focus();

                if (arrElements.length > 1) {
                    console.warn('dialog Warning: Too many [autofocus] elements, defaulting to the first one. Please have only one [autofocus] element per form.');
                }
            }

            // if there is a intColumnElementFocusNumber: restore focus
            if (intColumnElementFocusNumber) {
                arrElements = xtag.query(element, '[column]');

                //console.log(intColumnElementFocusNumber, jsnSelection);
                //
                //console.log('arrElements: ', arrElements);
                //console.log('intColumnElementFocusNumber: ', intColumnElementFocusNumber);
                //console.log('element: ', arrElements[intColumnElementFocusNumber]);
                //console.log('jsnSelection: ', jsnSelection);
                //
                //console.log('element upgrade: ', arrElements[intColumnElementFocusNumber].__upgraded__);

                //console.log('1***');
                if (arrElements.length > intColumnElementFocusNumber) {
                    //console.log('2***', document.activeElement);
                    focusToElement = arrElements[intColumnElementFocusNumber];

                    // if element registration is not shimmed, we can just focus into the target element
                    if (shimmed.registerElement === false) {
                        focusToElement.focus();
                        if (jsnSelection) {
                            GS.setInputSelection(document.activeElement, jsnSelection.start, jsnSelection.end);
                        }

                    // else, we have to check on a loop to see if the element has been upgraded,
                    //      the reason I need to use a loop here is because there is no event for
                    //      when an element is upgraded (if there was then 1000 custom elements
                    //      would emit 1000 events, which is a lot and we don't want to bog the
                    //      browser down)
                    } else {
                        timer_i = 0;
                        focusTimerID = setInterval(function () {
                            if (focusToElement.__upgraded__ || timer_i >= 10) {
                                clearTimeout(focusTimerID);
                            }
                            if (focusToElement.__upgraded__) {
                                focusToElement.focus();
                                if (jsnSelection) {
                                    GS.setInputSelection(document.activeElement, jsnSelection.start, jsnSelection.end);
                                }
                            }
                            timer_i += 1;
                        }, 5);
                    }
                }
            }

            //console.log('current element', document.activeElement);

            // trigger after_select
            GS.triggerEvent(element, 'after_select');
            //console.log(element, 'after_select');

        // else there was an error: add error class, title attribute
        } else {
            element.error = true;
            element.classList.add('error');

            element.innerHTML = 'This form encountered an error.'

            //GS.ajaxErrorDialog(event.detail.response);
            GS.ajaxErrorDialog(data);
        }
    }


    function dataTemplateRecords(element, data) {
        var jsnTemplate, strRet;

        jsnTemplate = GS.templateHideSubTemplates(element.templateHTML);

        //console.log(jsnTemplate.templateHTML);

        strRet = GS.templateWithEnvelopeData('<div class="form-record" ' + (data.dat.length === 1 ? 'style="height: 100%;" ' : '') +
                                                'data-id="{{! row.id }}" data-' + element.lockColumn + '="{{! row.' + element.lockColumn + ' }}" gs-dynamic>' +
                                                jsnTemplate.templateHTML +
                                            '</div>',
                                            data);

        strRet = GS.templateShowSubTemplates(strRet, jsnTemplate);

        //console.log(strRet);

        return strRet;
    }


    // #################################################################
    // ########################### UTILITIES ###########################
    // #################################################################

    function addMessage(element, strMessageName) {
        if (strMessageName === 'saving') {
            if (element.savingMessage) {
                removeMessage(element, 'saving');
            }
            element.savingMessage = document.createElement('div');
            element.savingMessage.classList.add('message');
            element.savingMessage.innerHTML = 'Saving...';

            element.appendChild(element.savingMessage);

        } else if (strMessageName === 'waiting') {
            if (element.waitingMessage) {
                removeMessage(element, 'waiting');
            }
            element.waitingMessage = document.createElement('div');
            element.waitingMessage.classList.add('message');
            element.waitingMessage.innerHTML = 'Waiting<br />to save...';

            element.appendChild(element.waitingMessage);
        }
    }

    function removeMessage(element, strMessageName) {
        if (strMessageName === 'saving' && element.savingMessage) {
            element.removeChild(element.savingMessage);
            element.savingMessage = undefined;

        } else if (strMessageName === 'waiting' && element.waitingMessage) {
            element.removeChild(element.waitingMessage);
            element.waitingMessage = undefined;
        }
    }

    function columnParentsUntilForm(form, element) {
        var intColumnParents = 0, currentElement = element, maxLoops = 50, i = 0;

        while (currentElement.parentNode !== form && currentElement.parentNode && i < maxLoops) {
            if (currentElement.parentNode.hasAttribute('column') === true //If something with a column attribute
                || currentElement.parentNode.hasAttribute('src') === true) { //or something with a src attribute
                intColumnParents += 1;
            }

            currentElement = currentElement.parentNode;
            i += 1;
        }

        return intColumnParents;
    }

    //function pushReplacePopHandler(element) {
    //    var i, len, arrPopKeys, bolRefresh = false, currentValue, strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //
    //    if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.setAttribute('where', 'id=' + GS.qryGetVal(strQueryString, strQSCol));
    //        bolRefresh = true;
    //
    //    } else if (element.hasAttribute('refresh-on-querystring-values')) {
    //        arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
    //
    //        for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
    //            currentValue = GS.qryGetVal(strQueryString, arrPopKeys[i]);
    //
    //            if (element.popValues[arrPopKeys[i]] !== currentValue) {
    //                bolRefresh = true;
    //            }
    //
    //            element.popValues[arrPopKeys[i]] = currentValue;
    //        }
    //
    //    } else if (element.hasAttribute('refresh-on-querystring-change')) {
    //        bolRefresh = true;
    //    }
    //
    //    if (bolRefresh) {
    //        element.refresh();
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var arrPopKeys;
        var currentValue;
        var bolRefresh;
        var strOperator;

        if (strQSCol) {
            if (strQSCol.indexOf('=') !== -1) {
                arrAttrParts = strQSCol.split(',');
                i = 0;
                len = arrAttrParts.length;
                while (i < len) {
                    strQSCol = arrAttrParts[i];

                    if (strQSCol.indexOf('!=') !== -1) {
                        strOperator = '!=';
                        arrQSParts = strQSCol.split('!=');
                    } else {
                        strOperator = '=';
                        arrQSParts = strQSCol.split('=');
                    }

                    strQSCol = arrQSParts[0];
                    strQSAttr = arrQSParts[1] || arrQSParts[0];

                    // if the key is not present or we've got the negator: go to the attribute's default or remove it
                    if (strOperator === '!=') {
                        // if the key is not present: add the attribute
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            element.setAttribute(strQSAttr, '');
                        // else: remove the attribute
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    } else {
                        // if the key is not present: go to the attribute's default or remove it
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                            } else {
                                element.removeAttribute(strQSAttr);
                            }
                        // else: set attribute to exact text from QS
                        } else {
                            element.setAttribute(strQSAttr, (
                                GS.qryGetVal(strQS, strQSCol) ||
                                element.internal.defaultAttributes[strQSAttr] ||
                                ''
                            ));
                        }
                    }
                    i += 1;
                }
            } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                strQSValue = GS.qryGetVal(strQS, strQSCol);

                if (element.internal.bolQSFirstRun !== true) {
                    console.log(element.getAttribute('value'));
                    if (strQSValue !== '' || !element.getAttribute('value')) {
                        element.setAttribute('where', 'id=' + (isNaN(strQSValue) ? '$WHEREQuoTE$' + strQSValue + '$WHEREQuoTE$' : strQSValue));
                        bolRefresh = true;
                    }
                } else {
                    element.setAttribute('where', 'id=' + (isNaN(strQSValue) ? '$WHEREQuoTE$' + strQSValue + '$WHEREQuoTE$' : strQSValue));
                    bolRefresh = true;
                }
            }
        }

        // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
        if (element.internal.bolQSFirstRun === true) {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);

                    if (element.popValues[arrPopKeys[i]] !== currentValue) {
                        bolRefresh = true;
                    }

                    element.popValues[arrPopKeys[i]] = currentValue;
                }
            } else if (element.hasAttribute('refresh-on-querystring-change')) {
                bolRefresh = true;
            }
        } else {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                }
            }

            if (GS.getQueryString() || element.hasAttribute('refresh-on-querystring-change') || element.hasAttribute('src')) {
                bolRefresh = true;
            }
        }

        if (bolRefresh && element.hasAttribute('src')) {
            getData(element);
        } else if (bolRefresh && !element.hasAttribute('src')) {
            console.warn('gs-combo Warning: element has "refresh-on-querystring-values" or "refresh-on-querystring-change", but no "src".', element);
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            if (element.children.length === 0) {
                throw 'GS-Form Error: No template provided';
            }
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                var //templateElement = document.createElement('template'),
                    //templateElementSubTemplateSafe = document.createElement('template'),
                    firstChildElement = element.children[0],
                    //arrElements, i, len, arrColumnElement, arrTemplates,
                    strQueryString = GS.getQueryString(), changeHandler;

                // if this form has the "save-while-typing" attribute
                if (element.hasAttribute('save-while-typing')) {
                    GS.addBeforeUnloadEvent(function () {
                        if (element.bolCurrentlySaving || element.saveTimerID) {
                            return 'The page has not finished saving.';
                        }
                    });
                } else {
                    // this prevents the issue where you type in a change but then unload
                    //      the page without causing a change event to fire, which means you lose your change
                    GS.addBeforeUnloadEvent(function () {
                        document.activeElement.blur();
                    });
                }

                // lock attribute and defaulting
                element.lockColumn = element.getAttribute('lock') || 'change_stamp';

                // if the first child is a template element: save its HTML
                if (firstChildElement.nodeName === 'TEMPLATE') {
                    element.templateHTML = firstChildElement.innerHTML;

                // else: save the innerHTML of the form and send a warning
                } else {
                    console.warn('Warning: gs-form is now built to use a template element. ' +
                                 'Please use a template element to contain the template for this form. ' + // this warning was added: March 12th 2015
                                 'A fix has been included so that it is not necessary to use the template element, but that code may be removed at a future date.');

                    element.templateHTML = element.innerHTML;
                }

                // if there is no HTML: throw an error
                if (!element.templateHTML.trim()) { throw 'GS-FORM error: no template HTML.'; }

                if (element.templateHTML.indexOf('&gt;') > -1 || element.templateHTML.indexOf('&lt;') > -1) {
                    console.warn('GS-FORM WARNING: &gt; or &lt; detected in record template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                }

                // add a doT.js coded "value" attribute to any element with a "column" attribute but no "value" attribute
                element.templateHTML = GS.templateColumnToValue(element.templateHTML);

                // handle "qs" attribute
                if (element.getAttribute('qs') ||
                        element.getAttribute('refresh-on-querystring-values') ||
                        element.hasAttribute('refresh-on-querystring-change')) {
                    element.popValues = {};

                    //if (element.getAttribute('qs')) {
                    //    if (GS.qryGetVal(strQueryString, element.getAttribute('qs'))) {
                    //        element.setAttribute('where', 'id=' + GS.qryGetVal(strQueryString, element.getAttribute('qs')));
                    //    } else {
                    //        element.setAttribute('where', 'false');
                    //    }
                    //}

                    //if (GS.getQueryString() || element.hasAttribute('refresh-on-querystring-change')) {
                    pushReplacePopHandler(element);
                    //}

                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                } else {
                    getData(element);
                }

                element.addEventListener('keydown', function (event) {
                    var intKeyCode = event.which || event.keyCode, jsnSelection;

                    if (document.activeElement.nodeName === 'INPUT' || document.activeElement.nodeName === 'TEXTAREA') {
                        jsnSelection = GS.getInputSelection(event.target);
                    }

                    if ((intKeyCode === 37 && (!jsnSelection || jsnSelection.start === 0)) ||
                        (intKeyCode === 39 && (!jsnSelection || jsnSelection.end === event.target.value.length))) {
                        var focusToElement, i, len, arrElementsFocusable, currentElement;
                        //Left
                        if (intKeyCode === 37 && (!jsnSelection || jsnSelection.start === 0)) {
                            arrElementsFocusable = xtag.query(document, 'input:not([disabled]), ' +
                                'select:not([disabled]), memo:not([disabled]), button:not([disabled]), ' +
                                '[tabindex]:not([disabled]), [column]');

                            for (i = 0,len = arrElementsFocusable.length;i < len;i++) {
                                currentElement = arrElementsFocusable[i];
                                //console.log(currentElement === event.target, currentElement, event.target);
                                if (currentElement === event.target ||
                                    ((event.target.nodeName === 'INPUT' || event.target.nodeName === 'TEXTAREA') &&
                                    currentElement === event.target.parentNode)) {
                                    if (i === 0) {
                                        focusToElement = currentElement;
                                    } else {
                                        focusToElement = arrElementsFocusable[i - 1];
                                    }
                                    break;
                                }
                            }
                            //console.log(focusToElement);
                        //Right
                        } else if (intKeyCode === 39 && (!jsnSelection || jsnSelection.end === event.target.value.length)) {
                            arrElementsFocusable = xtag.query(document, 'input:not([disabled]), ' +
                                'select:not([disabled]), memo:not([disabled]), button:not([disabled]), ' +
                                '[tabindex]:not([disabled]), [column]');

                            for (i = 0,len = arrElementsFocusable.length;i < len;i++) {
                                currentElement = arrElementsFocusable[i];
                                if (currentElement === event.target) {
                                    if (i === len) {
                                        focusToElement = currentElement;
                                    } else {
                                        focusToElement = arrElementsFocusable[i + 1];
                                    }
                                    break;
                                }
                            }
                        }

                        //console.log('focusable', GS.isElementFocusable(focusToElement));
                        if (focusToElement && GS.isElementFocusable(focusToElement)) {
                            //console.log('focus');
                            event.preventDefault();

                            focusToElement.focus();

                            if (document.activeElement.nodeName === 'INPUT' || document.activeElement.nodeName === 'TEXTAREA') {
                                GS.setInputSelection(document.activeElement, 0, document.activeElement.value.length);
                            }
                        }
                    }
                });

                // bind save code
                if (element.hasAttribute('save-while-typing')) {
                    element.bolCurrentlySaving = false;
                    element.jsnUpdate = {};
                    element.state = 'saved';
                    //element.currentSaveAjax = false;

                    // possible states:
                    //      'saved'
                    //      'waiting to save'
                    //      'saving'

                    // JSON object for holding columns to update
                    // on keydown, keyup, change add to JSON object
                    // keep updating until all columns have been saved (undefined marks an empty column)

                    changeHandler = function (event) {
                        var intKeyCode = event.which || event.keyCode, newValue,
                            targetColumnParent = GS.findParentElement(event.target, '[column]'),
                            parentRecordElement, strID;

                        //console.log(event.target, targetColumnParent);

                        if (targetColumnParent.getAttribute('column') && columnParentsUntilForm(element, targetColumnParent) === 0 &&
                            element.column(targetColumnParent.getAttribute('column')) !== targetColumnParent.value) {

                            //event.stopPropagation();
                            if (element.saveTimerID) {
                                clearTimeout(element.saveTimerID);
                                element.saveTimerID = undefined;
                            }

                            addMessage(element, 'waiting');
                            element.state = 'waiting to save';

                            if (targetColumnParent.value !== null && targetColumnParent.value !== null) {
                                newValue = targetColumnParent.value;
                            } else {
                                newValue = targetColumnParent.checked;
                            }

                            parentRecordElement = GS.findParentElement(targetColumnParent, '.form-record[data-id]');
                            strID = parentRecordElement.getAttribute('data-id');

                            if (!element.jsnUpdate[strID]) {
                                element.jsnUpdate[strID] = element.jsnUpdate[strID] = {};
                            }
                            element.jsnUpdate[strID][targetColumnParent.getAttribute('column')] = newValue;

                            element.saveTimerID = setTimeout(function () {
                                updateDataWithoutTemplate(element);
                                element.saveTimerID = undefined;
                            }, 300);
                        }
                    };

                    element.addEventListener('keydown', changeHandler);
                    element.addEventListener('keyup', changeHandler);
                    element.addEventListener('change', changeHandler);

                } else {
                    element.addEventListener('change', function (event) {
                        var newValue;

                        if (event.target.getAttribute('column')
                                && columnParentsUntilForm(element, event.target) === 0
                                && GS.findParentTag(event.target, 'gs-form') === element) {
                            //event.stopPropagation();

                            if (event.target.value !== null) {
                                newValue = event.target.value;
                            } else {
                                newValue = event.target.checked;
                            }

                            updateData(element, event.target, event.target.getAttribute('column'), newValue);
                        }
                    });
                }
            }
        }
    }

    xtag.register('gs-form', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // attribute code
                }
            },

            removed: function () {
                if (this.hasAttribute('save-while-typing') && this.saveTimerID) {
                    clearTimeout(this.saveTimerID);
                    emergencyUpdate(this);
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            refresh: function () {
                getData(this);
            },

            column: function (strColumn) {
                //console.log(this.lastSuccessData);
                return GS.envGetCell(this.lastSuccessData, 0, strColumn);
            },

            addMessage: function (strMessageName) {
                return addMessage(this, strMessageName);
            },
            removeMessage: function (strMessageName) {
                return removeMessage(this, strMessageName);
            }
        }
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';
    registerDesignSnippet('<gs-grid>', '<gs-grid>', 'gs-grid widths="${1}">\n' +
                                                    '    <gs-block>${2}</gs-block>\n' +
                                                    '</gs-grid>');

    designRegisterElement('gs-grid', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-grid.html');

    window.designElementProperty_GSGRID = function(selectedElement) {
        addProp('Min-Width Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('min-width') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'min-width', this.value);
        });

        addProp('Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('media') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'media', this.value);
        });

        addProp('Widths', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('widths') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'widths', this.value);
        });

        addProp('Padded', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('padded')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'padded', (this.value === 'true'), true);
        });

        addProp('Gutters', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('gutter')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'gutter', (this.value === 'true'), true);
        });

        addProp('Reflow At', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('reflow-at') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'reflow-at', this.value);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('<gs-block>', '<gs-block>', 'gs-block>${2}</gs-block>');

    designRegisterElement('gs-block', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-grid.html');

    window.designElementProperty_GSBLOCK = function(selectedElement) {
        addProp('Width:', true, '<gs-text class="target" value="' + (selectedElement.getAttribute('width') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'width', this.value);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + (selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        addFlexContainerProps(selectedElement);
        //addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var arrTakenGrids = [];

    function handleObserver(element) {
        var observer = new MutationObserver(function(mutations) {
            element.handleBlocks();
        });

        observer.observe(element, {childList: true});
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            handleObserver(element);
        }
    }

    //
    function elementInserted(element) {
        var styleElement;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                // if the style element for the grid column CSS doesn't exist: create it
                if (!document.getElementById('gs-dynamic-css')) {
                    styleElement = document.createElement('style');
                    styleElement.setAttribute('id', 'gs-dynamic-css');
                    styleElement.setAttribute('gs-dynamic', '');
                    document.head.appendChild(styleElement);
                }

                // if no width parameter is set: default
                if (!element.getAttribute('widths') && !element.getAttribute('min-width') && !element.getAttribute('media')) {
                    element.bolIgnoreAttribute = true;
                    element.setAttribute('widths', new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                    .join('1').split('').join(','));
                    element.bolIgnoreAttribute = false;
                }

                element.handleCSS();
                element.handleBlocks();
            }
        }
    }

    xtag.register('gs-grid', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // if the "widths" attribute changed
                    if (strAttrName === 'widths' && this.bolIgnoreAttribute !== true) {
                        this.handleCSS();
                        this.handleBlocks();

                    // if the "reflow-at" attribute changed
                    } else if (strAttrName === 'reflow-at') {
                        this.handleCSS();

                    // if the "min-width" attribute changed
                    } else if (strAttrName === 'min-width') {
                        this.handleCSS();
                        this.handleBlocks();

                    // if the "media" attribute changed
                    } else if (strAttrName === 'media') {
                        this.handleCSS();
                        this.handleBlocks();
                    }
                }
            }
        },
        events: {},
        accessors: {},
        methods: {

            getWidthsParameters: function (strWidths) {
                var arrWidths, intGridWidth, i, len;

                arrWidths = strWidths
                        .replace(/[^0-9,]/gim, '') // remove everything except commas and numbers
                        .replace(/,{1,}/gim, ',')  // replace multiple commas right next to each other with a single comma
                        .replace(/^,|,$/gim, '')   // remove commas at the end and the beginning of the line
                        .split(',');               // split on commas to make an array of numbers (which are currently type 'string')

                // if the array doesn't have content: error
                if (arrWidths.length === 0) {
                    throw 'gs-grid Error: no valid widths found. Please put a comma seperated list of widths in the "widths" attribute.';
                }

                // convert the array of strings to an array of integers
                for (i = 0, len = arrWidths.length; i < len; i += 1) {
                    arrWidths[i] = parseInt(arrWidths[i], 10);
                }

                // add up the array of integers to come up with a grid width
                for (i = 0, len = arrWidths.length, intGridWidth = 0; i < len; i += 1) {
                    intGridWidth += arrWidths[i];
                }

                return {
                    'arrWidths': arrWidths,
                    'intGridWidth': intGridWidth
                };
            },

            handleCSS: function () {
                var jsnWidthsParameters;

                if (this.getAttribute('widths')) {
                    jsnWidthsParameters = this.getWidthsParameters(this.getAttribute('widths'));

                    this.handleWidthsCSS(jsnWidthsParameters.arrWidths, jsnWidthsParameters.intGridWidth);

                } else if (this.getAttribute('min-width')) {
                    this.handleMinWidthCSS();

                } else if (this.getAttribute('media')) {
                    this.handleMediaCSS();
                }
            },

            handleBlocks: function () {
                var jsnWidthsParameters;

                if (this.getAttribute('widths')) {
                    jsnWidthsParameters = this.getWidthsParameters(this.getAttribute('widths'));

                    this.handleWidthsBlocks(jsnWidthsParameters.arrWidths, jsnWidthsParameters.intGridWidth);

                } else if (this.getAttribute('min-width')) {
                    this.handleMinWidthBlocks();

                } else if (this.getAttribute('media')) {
                    this.handleMediaBlocks();
                }
            },




            handleWidthsCSS: function (arrWidths, intGridWidth) {
                var styleElement = document.getElementById('gs-dynamic-css'),
                    i, len, strCurrentWidth, intCurrentWidth, widthIncreaseAmount, strCSS,
                    strReflowAt = this.getAttribute('reflow-at') || '', arrClassesToRemove;

                // reflow-at shortcuts
                strReflowAt = strReflowAt.replace(/small|sml/g,  '992px');
                strReflowAt = strReflowAt.replace(/medium|med/g, '1200px');
                strReflowAt = strReflowAt.replace(/large|lrg/g,  '10000px');

                // remove old classes
                arrClassesToRemove = String(this.classList).match(/width-[0-9]*/g) || [];

                for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                    this.classList.remove(arrClassesToRemove[i]);
                }

                // make sure that this grid hasn't been done before
                if (!styleElement.classList.contains('col-' + intGridWidth)) {
                    // column CSS

                    // calculate the amount to increase every block width setting by
                    widthIncreaseAmount = 100 / intGridWidth;

                    // create a style for every block
                    for (i = 0, len = intGridWidth, intCurrentWidth = 0, strCSS = ''; i < len; i += 1) {
                        intCurrentWidth += widthIncreaseAmount;
                        strCurrentWidth = String(parseFloat(intCurrentWidth.toFixed(5).toString(), 10));

                        strCSS += 'gs-grid.width-' + intGridWidth + ' > gs-block[width="' + (i + 1) + '"] { width: ' + strCurrentWidth + '%; }\n';
                    }

                    // add col-NUM to the styleElement's "class" attribute
                    styleElement.classList.add('col-' + intGridWidth);

                    // append the column CSS
                    styleElement.innerHTML += '\n/* grid width: ' + intGridWidth + ' */\n' +
                                              strCSS +
                                              'gs-grid.width-' + intGridWidth + ' > gs-block.first-of-row { padding-left: 0; }\n' +
                                              'gs-grid.width-' + intGridWidth + ' > gs-block.last-of-row { padding-right: 0; }\n';
                }

                // reflow CSS

                // remove class from the gs-grid that allowed the generated reflow CSS to apply
                this.classList.remove('reflow-' + this.strReflowAt);

                // clean reflow-at attribute variable
                strReflowAt = strReflowAt.replace(/[^0-9a-z]/gi, '');

                // if reflow-at contains anything
                if (strReflowAt) {
                    // if reflow-at doesn't have a unit specified: add 'px' to the end of it
                    if (strReflowAt.replace(/[0-9]/gi, '') === '') {
                        strReflowAt += 'px';
                    }

                    // save the current reflow width so that we can use it later
                    this.strReflowAt = strReflowAt;

                    // add class to the gs-grid so that the generated reflow CSS will apply
                    this.classList.add('reflow-' + strReflowAt);

                    // if the reflow CSS for this grid width doesn't already exist: append it
                    if (!styleElement.classList.contains('reflow-' + strReflowAt)) {

                        // add reflow-SIZE to the styleElement's "class" attribute
                        styleElement.classList.add('reflow-' + strReflowAt);

                        // append the reflow CSS
                        styleElement.innerHTML += '\n/* grid reflow width: ' + strReflowAt + ' */\n' +
                                                  '@media only all and (max-width: ' + strReflowAt + ') {\n' +
                                                  '    gs-grid.reflow-' + strReflowAt + '            { width: 100%; }\n' +
                                                  '    gs-grid.reflow-' + strReflowAt + ' > gs-block { width: auto !important; float: none; }\n' +
                                                  '    gs-grid.reflow-' + strReflowAt + ' > gs-block { padding-left: 0 !important; padding-right: 0 !important; }\n' +
                                                  '}\n';
                    }
                }

                // apply CSS for blocks
                this.classList.add('width-' + intGridWidth);
            },

            handleMinWidthCSS: function () {
                var strMinWidth = this.getAttribute('min-width'), arrMinWidths, strCSS, strCurrentCSS,
                    i, len, arrParts, strWidth, strResult, intCurrentGridID, bolMedia, intCurrentWidth,
                    strCurrentWidth, intGridWidth, widthIncreaseAmount, grid_i, grid_len, intLayout, arrArrGridWidths,
                    column_i, column_len, arrWidths = [], width_i, strNextWidth;

                // 0 {1,1}; 1000 {2,1}; 10000 {2,1}; 12000 {1,1}
                // all {reflow}; sml {1,1}; med {1,1,1}; lrg {reflow}

                strMinWidth = strMinWidth.replace(/\s+/g, ''); // remove all whitespace
                strMinWidth = strMinWidth.replace(/\}/g, ''); // remove all close curly braces
                strMinWidth = strMinWidth.toLowerCase(); // lowercase
                strMinWidth = GS.trim(strMinWidth, ';'); // trim off semicolons

                // replace shortcuts (lrg => 1200px)
                strMinWidth = strMinWidth.replace(/all/g,        '0px');
                strMinWidth = strMinWidth.replace(/small|sml/g,  '768px');
                strMinWidth = strMinWidth.replace(/medium|med/g, '992px');
                strMinWidth = strMinWidth.replace(/large|lrg/g,  '1200px');

                arrMinWidths = strMinWidth.split(';'); // seperate out layouts

                //console.log(strMinWidth, arrMinWidths);

                if (arrTakenGrids.indexOf(strMinWidth) === -1) {
                    arrTakenGrids.push(strMinWidth);
                    intCurrentGridID = arrTakenGrids.length - 1;
                    strCSS = '';
                    arrArrGridWidths = [];

                    for (i = 0, len = arrMinWidths.length, intLayout = 0; i < len; i += 1) {
                        arrParts = arrMinWidths[i].split('{');
                        strWidth = arrParts[0] || '0px';
                        strResult = arrParts[1] || new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                    .join('1').split('').join(',');
                        bolMedia = parseInt(strWidth) > 0;
                        strCurrentCSS = '';

                        if (strResult === 'reflow') {
                            intLayout += 1;
                            arrArrGridWidths.push('reflow');

                            // reflow css
                            strCurrentCSS +=
                                '    gs-grid.grid-id-' + intCurrentGridID + '            { width: 100%; }\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.reflow-layout-' + intLayout +
                                                                                            ' { width: auto; float: none; }\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.reflow-layout-' + intLayout +
                                                                                            ' { padding-left: 0; padding-right: 0; }\n';

                        } else {
                            intLayout += 1;
                            arrArrGridWidths.push(strResult.split(','));

                            // grid css
                            intGridWidth = this.getWidthsParameters(strResult).intGridWidth;

                            // calculate the amount to increase every block width setting by
                            widthIncreaseAmount = 100 / intGridWidth;

                            // create a style for every block
                            for (grid_i = 0, grid_len = intGridWidth, intCurrentWidth = 0; grid_i < grid_len; grid_i += 1) {
                                intCurrentWidth += widthIncreaseAmount;
                                strCurrentWidth = String(parseFloat(intCurrentWidth.toFixed(5).toString(), 10));

                                strCurrentCSS += '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.width-' + (grid_i + 1) + '-layout-' + intLayout + ' { ' +
                                                     'width: ' + strCurrentWidth + '%; float: left; ' +
                                                 '}\n';
                            }

                            strCurrentCSS =
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.clearfix-layout-' + intLayout +
                                            ' { clear: left; }\n\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + '[gutter] > gs-block { padding-left: 0.5em; padding-right: 0.5em; }\n\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.first-of-row-layout-' + intLayout +
                                            ' { padding-left: 0; }\n\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.last-of-row-layout-' + intLayout +
                                            ' { padding-right: 0; }\n\n' +
                                strCurrentCSS;
                        }

                        //if (bolMedia) {
                        strNextWidth = '';
                        if (arrMinWidths[i + 1]) {
                            strNextWidth = arrMinWidths[i + 1].split('{')[0];

                            // subtract 1 from the next width so that max-width doesn't allow the
                            //      media to apply at the same time as the next media
                            strNextWidth = (parseInt(strNextWidth) - 1) + strNextWidth.replace(/[0-9]/g, '');
                        }

                        strCurrentCSS = '\n@media (min-width:' + strWidth + ')' + (strNextWidth ? ' and (max-width:' + strNextWidth + ')' : '') + ' {\n' +
                                            strCurrentCSS +
                                        '}\n';
                        //}

                        strCSS += strCurrentCSS;
                    }
                    //console.log(strCSS);

                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* grid #' + intCurrentGridID + ' */\n' + strCSS;

                } else {
                    intCurrentGridID = arrTakenGrids.indexOf(strMinWidth);
                    arrArrGridWidths = [];

                    for (i = 0, len = arrMinWidths.length, intLayout = 0; i < len; i += 1) {
                        arrParts = arrMinWidths[i].split('{');
                        strWidth = arrParts[0] || '0px';
                        strResult = arrParts[1] || new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                    .join('1').split('').join(',');

                        intLayout += 1;

                        if (strResult !== 'reflow') {
                            arrArrGridWidths.push(strResult.split(','));
                        } else {
                            arrArrGridWidths.push('reflow');
                        }
                    }
                }

                //
                this.intLayouts = intLayout;
                this.arrArrWidths = arrArrGridWidths;

                for (i = 0, len = this.arrArrWidths.length; i < len; i += 1) {
                    if (this.arrArrWidths[i] !== 'reflow') {
                        arrWidths.push(0);
                        width_i = arrWidths.length - 1;

                        for (column_i = 0, column_len = this.arrArrWidths[i].length; column_i < column_len; column_i += 1) {
                            this.arrArrWidths[i][column_i] = parseInt(this.arrArrWidths[i][column_i], 10);
                            arrWidths[width_i] += 1;
                        }
                    } else {
                        arrWidths.push('reflow');
                    }
                }

                this.arrWidths = arrWidths;

                // add class so that the CSS can apply
                this.classList.add('grid-id-' + intCurrentGridID);
            },

            handleMediaCSS: function () {
                var strMinWidth = this.getAttribute('media'), arrMinWidths, strCSS, strCurrentCSS,
                    i, len, arrParts, strMedia, strResult, intCurrentGridID, bolMedia, intCurrentWidth,
                    strCurrentWidth, intGridWidth, widthIncreaseAmount, grid_i, grid_len, intLayout, arrArrGridWidths,
                    column_i, column_len, arrWidths = [], width_i;

                strMinWidth = strMinWidth.trim().replace(/\}/g, ''); // remove all close curly braces
                strMinWidth = strMinWidth.toLowerCase(); // lowercase
                strMinWidth = GS.trim(strMinWidth, ';'); // trim off semicolons

                // all {reflow}; all and (min-width: small) {2,2,2}; all and (min-width: med) {3,3}; all and (min-width: large) {reflow};

                // replace shortcuts (lrg => 1200px)
                strMinWidth = strMinWidth.replace(/small|sml/g,  '768px');
                strMinWidth = strMinWidth.replace(/medium|med/g, '992px');
                strMinWidth = strMinWidth.replace(/large|lrg/g,  '1200px');

                arrMinWidths = strMinWidth.split(';'); // seperate out layouts

                if (arrTakenGrids.indexOf(strMinWidth) === -1) {
                    arrTakenGrids.push(strMinWidth);
                    intCurrentGridID = arrTakenGrids.length - 1;
                    strCSS = '';
                    arrArrGridWidths = [];

                    //console.log(strMinWidth, arrMinWidths);

                    for (i = 0, len = arrMinWidths.length, intLayout = 0; i < len; i += 1) {
                        arrParts = arrMinWidths[i].split('{');
                        strMedia = arrParts[0].trim() || 'all';
                        strResult = arrParts[1].trim() || new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                    .join('1').split('').join(',');
                        strCurrentCSS = '';

                        if (strResult === 'reflow') {
                            intLayout += 1;
                            arrArrGridWidths.push('reflow');

                            // reflow css
                            strCurrentCSS +=
                                '    gs-grid.grid-id-' + intCurrentGridID + '            { width: 100%; }\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.reflow-layout-' + intLayout +
                                                                                            ' { width: auto; float: none; }\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.reflow-layout-' + intLayout +
                                                                                            ' { padding-left: 0; padding-right: 0; }\n';

                        } else {
                            intLayout += 1;
                            arrArrGridWidths.push(strResult.split(','));

                            // grid css
                            intGridWidth = this.getWidthsParameters(strResult).intGridWidth;

                            // calculate the amount to increase every block width setting by
                            widthIncreaseAmount = 100 / intGridWidth;

                            // create a style for every block
                            for (grid_i = 0, grid_len = intGridWidth, intCurrentWidth = 0; grid_i < grid_len; grid_i += 1) {
                                intCurrentWidth += widthIncreaseAmount;
                                strCurrentWidth = String(parseFloat(intCurrentWidth.toFixed(5).toString(), 10));

                                strCurrentCSS += '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.width-' + (grid_i + 1) + '-layout-' + intLayout + ' { ' +
                                                     'width: ' + strCurrentWidth + '%; float: left; ' +
                                                 '}\n';
                            }

                            strCurrentCSS =
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.clearfix-layout-' + intLayout +
                                            ' { clear: left; }\n\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + '[gutter] > gs-block { padding-left: 0.5em; padding-right: 0.5em; }\n\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.first-of-row-layout-' + intLayout +
                                            ' { padding-left: 0; }\n\n' +
                                '    gs-grid.grid-id-' + intCurrentGridID + ' > gs-block.last-of-row-layout-' + intLayout +
                                            ' { padding-right: 0; }\n\n' +
                                strCurrentCSS;
                        }

                        strCurrentCSS = '\n@media ' + strMedia + ' {\n' +
                                            strCurrentCSS +
                                        '}\n';

                        strCSS += strCurrentCSS;
                    }

                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* grid #' + intCurrentGridID + ' */\n' + strCSS;

                } else {
                    intCurrentGridID = arrTakenGrids.indexOf(strMinWidth);
                    arrArrGridWidths = [];

                    for (i = 0, len = arrMinWidths.length, intLayout = 0; i < len; i += 1) {
                        arrParts = arrMinWidths[i].split('{');
                        strWidth = arrParts[0] || '0px';
                        strResult = arrParts[1] || new Array(xtag.queryChildren(element, 'gs-block').length + 1)
                                                                    .join('1').split('').join(',');

                        intLayout += 1;

                        if (strResult !== 'reflow') {
                            arrArrGridWidths.push(strResult.split(','));
                        } else {
                            arrArrGridWidths.push('reflow');
                        }
                    }
                }

                //
                this.intLayouts = intLayout;
                this.arrArrWidths = arrArrGridWidths;

                for (i = 0, len = this.arrArrWidths.length; i < len; i += 1) {
                    if (this.arrArrWidths[i] !== 'reflow') {
                        arrWidths.push(0);
                        width_i = arrWidths.length - 1;

                        for (column_i = 0, column_len = this.arrArrWidths[i].length; column_i < column_len; column_i += 1) {
                            this.arrArrWidths[i][column_i] = parseInt(this.arrArrWidths[i][column_i], 10);
                            arrWidths[width_i] += 1;
                        }
                    } else {
                        arrWidths.push('reflow');
                    }
                }

                this.arrWidths = arrWidths;

                //
                this.classList.add('grid-id-' + intCurrentGridID);
            },





            handleWidthsBlocks: function (arrWidths, intGridWidth) {
                var i, len, unset_i, arrElements, intNumberOfWidths = arrWidths.length, intCurrentRowWidth = 0, intNextToAdd;

                // mark initally set blocks
                arrElements = xtag.queryChildren(this, 'gs-block[width]');

                for (i = 0, len = arrElements.length; i < len; i += 1) {
                    arrElements[i].initallySet = true;
                }

                // get all child blocks
                arrElements = xtag.queryChildren(this, 'gs-block');

                // loop through the blocks
                for (i = 0, unset_i = 0, len = arrElements.length; i < len; i += 1) {
                    intNextToAdd = parseInt(arrElements[i].getAttribute('width'), 10) || arrWidths[unset_i % intNumberOfWidths];

                    // if this block wasn't initally set: remove the width attribute
                    if (!arrElements[i].initallySet) {
                        arrElements[i].removeAttribute('width');
                    }
                    arrElements[i].classList.remove('first-of-row');
                    arrElements[i].classList.remove('last-of-row');
                    arrElements[i].style.clear = '';

                    // if this is the first block in the row
                    if (intCurrentRowWidth === 0) {
                        // set the clear to left, this fixes an issue where a tall cell will move a cell over to the right
                        arrElements[i].style.clear = 'left';
                        arrElements[i].classList.add('first-of-row');
                    }

                    // if this is the last block in the row
                    //console.log(intCurrentRowWidth, intNextToAdd, intGridWidth);
                    if ((intCurrentRowWidth + intNextToAdd) === intGridWidth) {
                        arrElements[i].classList.add('last-of-row');
                    }

                    // if this block doesn't have a set width: set its width (if there are more unset width blocks than widths: the widths repeat)
                    if (!arrElements[i].hasAttribute('width')) {
                        arrElements[i].setAttribute('width', arrWidths[unset_i % intNumberOfWidths]);
                        unset_i += 1;
                    }

                    intCurrentRowWidth += intNextToAdd;
                    intCurrentRowWidth = intCurrentRowWidth % intGridWidth;
                }
            },



            iterateBlocks: function (intLayouts, arrArrWidths, arrIntGridWidth) {
                var arrBlocks = xtag.queryChildren(this, 'gs-block'), i, len, block_i, block_len, width_i;

                for (i = 0, len = intLayouts; i < len; i += 1) {
                    width_i = 0;

                    //console.log(arrArrWidths[i]);
                    if (arrArrWidths[i] !== 'reflow') {
                        for (block_i = 0, block_len = arrBlocks.length; block_i < block_len; block_i += 1) {
                            // if this is the first block in the row:
                            //      set the clear to left, this fixes an issue where a tall cell will move a cell over to the right
                            if (width_i === 0) {
                                arrBlocks[block_i].classList.add('clearfix-layout-' + (i + 1));
                                arrBlocks[block_i].classList.add('first-of-row-layout-' + (i + 1));
                            } else if ((width_i + 1) === arrIntGridWidth[i]) {
                                arrBlocks[block_i].classList.add('last-of-row-layout-' + (i + 1));
                            }

                            arrBlocks[block_i].classList.add('width-' + arrArrWidths[i][width_i] + '-layout-' + (i + 1));

                            //console.log(width_i, arrArrWidths[i][width_i], arrIntGridWidth[i]);
                            width_i += 1;
                            width_i = width_i % arrIntGridWidth[i];
                        }
                    } else {
                        for (block_i = 0, block_len = arrBlocks.length; block_i < block_len; block_i += 1) {
                            arrBlocks[block_i].classList.add('reflow-layout-' + (i + 1));
                        }
                    }
                }


            },

            handleMinWidthBlocks: function () {
                this.iterateBlocks(this.intLayouts, this.arrArrWidths, this.arrWidths);
            },

            handleMediaBlocks: function () {
                this.iterateBlocks(this.intLayouts, this.arrArrWidths, this.arrWidths);
            }
        }
    });

    xtag.register('gs-block', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {}
    });
});window.addEventListener('design-register-element', function () {
    window.designElementProperty_GSGROUP = function (selectedElement) {
        // DISABLED attribute
        addProp('Padded', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('padded') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'padded', this.value === 'true', true);
        });
    };
});

//global xtag
//jslint browser:true
document.addEventListener("DOMContentLoaded", function () {
    "use strict";
    // fill gs-group based on current content
    function buildElement(element) {
        var rootBox = document.createElement("div");
        var innerBox = document.createElement("gs-groupborder");
        var titleBox = document.createElement("gs-grouptitle");

        // fill "innerBox" by transfering all of "element"'s child nodes to it (this includes text nodes)
        var arrElements = xtag.toArray(element.childNodes);
        var i = 0;
        var len = arrElements.length;

        while (i < len) {
            innerBox.appendChild(arrElements[i]);
            i += 1;
        }

        // fill "titleBox"
        titleBox.textContent = element.getAttribute("name");

        // give "rootBox" the class "root"
        rootBox.classList.add("root");

        // make "rootBox" flex it's content vertically, and make it fill horizontally
        rootBox.setAttribute("flex-vertical", "");
        rootBox.setAttribute("flex-fill", "");

        // make "innerBox" flex to fill height
        innerBox.setAttribute("flex", "");

        // mark "titleBox" and "innerBox" as dynamic elements
        //      because we want developers to know that these
        //      are generated
        innerBox.setAttribute("gs-dynamic", "");
        titleBox.setAttribute("gs-dynamic", "");

        // append "titleBox" and "innerBox" to "rootBox"
        rootBox.appendChild(innerBox);
        rootBox.appendChild(titleBox);

        // append "rootBox" to "element"
        element.appendChild(rootBox);
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute("suspend-created") && !element.hasAttribute("suspend-inserted")) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                if (!element.children[0].classList.contains('root')) {
                    buildElement(element);
                }
            }
        }
    }

    xtag.register("gs-groupborder", {});
    xtag.register("gs-grouptitle", {});
    xtag.register("gs-group", {
        lifecycle: {
            inserted: function () {
                elementInserted(this);
            },
            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;

                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === "suspend-created" && newValue === null) {
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === "suspend-inserted" && newValue === null) {
                    elementInserted(element);
                }
                // else if (!element.hasAttribute("suspend-created") && !element.hasAttribute("suspend-inserted")) {
                //    // attribute code
                //}
            }
        },
        events: {},
        accessors: {},
        methods: {}
    });
});
window.addEventListener('design-register-element', function () {
    registerDesignSnippet('Centered Header', '<gs-header>', '<gs-header><center><h3>$0</h3></center></gs-header>');
    registerDesignSnippet('Header', '<gs-header>', '<gs-header><h3>$0</h3></gs-header>');
    registerDesignSnippet('<gs-header>', '<gs-header>', 'gs-header><h3>$0</h3></gs-header>');

    designRegisterElement('gs-header', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-page.html');

    window.designElementProperty_GSHEADER = function(selectedElement) {
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        addFlexContainerProps(selectedElement);
        //addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    xtag.register('gs-header', {
        lifecycle: {
            /*inserted: function () {
                if (this.border_line) {
                    this.removeChild(this.border_line);
                }

                this.border_line = document.createElement('div');
                this.border_line.classList.add('border-line');
                this.border_line.setAttribute('gs-dynamic', '');

                this.appendChild(this.border_line);
            },
            removed: function () {
                if (this.border_line.parentNode === this) {
                    this.removeChild(this.border_line);
                }
            }*/
        },
        events: {},
        accessors: {},
        methods: {}
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('<gs-img>', '<gs-img>', 'gs-img src="${1}"></gs-img>');

    designRegisterElement('gs-img', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-image.html');

    window.designElementProperty_GSIMG = function(selectedElement) {
        addProp('Min-Width Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('min-width') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'min-width', this.value);
        });

        addProp('Media', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('media') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'media', this.value);
        });

        addProp('Source', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('src') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'src', this.value);
        });

        addProp('Alignment', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('align') || '') + '" mini>' +
                                   '    <option value="left">Left</option>' +
                                   '    <option value="">Center</option>' +
                                   '    <option value="right">Right</option>' +
                                   '</gs-select>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'align', this.value);
        });

        addProp('Image Cover', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('image-cover') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'image-cover', this.value === 'true', true);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var arrTakenlayouts = [];

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    //
    function elementInserted(element) {
        var styleElement;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                // if the style element for the grid column CSS doesn't exist: create it
                if (!document.getElementById('gs-dynamic-css')) {
                    styleElement = document.createElement('style');
                    styleElement.setAttribute('id', 'gs-dynamic-css');
                    styleElement.setAttribute('gs-dynamic', '');
                    document.head.appendChild(styleElement);
                }

                element.handleSrc();

                if (element.getAttribute('min-width')) {
                    element.handleMinWidthCSS();
                } else if (element.getAttribute('media')) {
                    element.handleMediaCSS();
                }
            }
        }
    }

    xtag.register('gs-img', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // if the "min-width" attribute changed
                    if (strAttrName === 'min-width') {
                        this.handleMinWidthCSS();

                    // if the "media" attribute changed
                    } else if (strAttrName === 'media') {
                        this.handleMediaCSS();

                    // if the "src" attribute changed
                    } else if (strAttrName === 'src') {
                        this.handleSrc();
                    }
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            handleSrc: function () {
                var strSrc = this.getAttribute('src');

                if (strSrc) {
                    this.style.backgroundImage = 'url("' + strSrc + '")';
                } else {
                    this.style.backgroundImage = '';
                }
            },

            handleMinWidthCSS: function () {
                var strMinWidth = this.getAttribute('min-width'), arrLayouts, strCSS, strCurrentMinWidth,
                    i, len, arrClassesToRemove, intImageID, arrParts, strDimensions, strWidth, strHeight;

                // remove old classes
                arrClassesToRemove = String(this.classList).match(/image-id-[0-9]*/g) || [];

                for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                    this.classList.remove(arrClassesToRemove[i]);
                }

                // all {150px}; lrg {75px};
                // all {150px, 75px}; lrg {75px, 150px};

                // remove all whitespace, remove all close curly braces, lowercase, trim off semicolons
                strMinWidth = GS.trim(strMinWidth.replace(/\s+/g, '').replace(/\}/g, '').toLowerCase(), ';');

                // replace shortcuts (lrg => 1200px)
                strMinWidth = strMinWidth.replace(/all/g, '0px')
                                         .replace(/small|sml/g, '768px')
                                         .replace(/medium|med/g, '992px')
                                         .replace(/large|lrg/g, '1200px');

                // seperate out layouts
                arrLayouts = strMinWidth.split(';');

                //console.log(strMinWidth, arrLayouts);

                if (arrTakenlayouts.indexOf(strMinWidth) === -1) {
                    arrTakenlayouts.push(strMinWidth);
                    intImageID = arrTakenlayouts.length - 1;
                    strCSS = '';

                    for (i = 0, len = arrLayouts.length; i < len; i += 1) {
                        arrParts = arrLayouts[i].split('{');
                        strCurrentMinWidth = arrParts[0] || '0px';
                        strDimensions = arrParts[1];

                        if (strDimensions.indexOf(',') === -1) {
                            strWidth = strDimensions;
                            strHeight = strDimensions;
                        } else {
                            arrParts = strDimensions.split(',');
                            strWidth = arrParts[0];
                            strHeight = arrParts[1];
                        }

                        strCSS +=   '\n@media (min-width:' + strCurrentMinWidth + ') {\n' +
                                    '    gs-img.image-id-' + intImageID + ' { width:' + strWidth + '; height: ' + strHeight + '; }\n' +
                                    '}\n';
                    }

                    //console.log(strCSS);

                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* image #' + intImageID + ' */\n' + strCSS;

                } else {
                    intImageID = arrTakenlayouts.indexOf(strMinWidth);
                }

                this.classList.add('image-id-' + intImageID);
            },

            handleMediaCSS: function () {
                var strMedia = this.getAttribute('media'), arrLayouts, strCSS, i, len,
                    arrClassesToRemove, arrParts, strCurrentMedia, strWidth, intImageID,
                    arrParts, strCurrentMedia, strDimensions, strWidth, strHeight;

                // remove old classes
                arrClassesToRemove = String(this.classList).match(/image-id-[0-9]*/g) || [];

                for (i = 0, len = arrClassesToRemove.length; i < len; i += 1) {
                    this.classList.remove(arrClassesToRemove[i]);
                }

                // print {200px}; all and (max-width: 500px) {500px}; (min-width 500px) {600px};

                // trim, remove all close curly braces, lowercase, trim off semicolons
                strMedia = GS.trim(strMedia.trim().replace(/\}/g, '').toLowerCase(), ';');

                // replace shortcuts (lrg => 1200px)
                strMedia = strMedia.replace(/small|sml/g, '768px').replace(/medium|med/g, '992px').replace(/large|lrg/g, '1200px');

                arrLayouts = strMedia.split(';'); // seperate out layouts

                //console.log(strMedia, arrLayouts);

                if (arrTakenlayouts.indexOf(strMedia) === -1) {
                    arrTakenlayouts.push(strMedia);
                    intImageID = arrTakenlayouts.length - 1;
                    strCSS = '';

                    for (i = 0, len = arrLayouts.length; i < len; i += 1) {
                        arrParts = arrLayouts[i].split('{');
                        strCurrentMedia = arrParts[0].trim() || 'all';
                        strDimensions = arrParts[1].trim();

                        if (strDimensions.indexOf(',') === -1) {
                            strWidth = strDimensions;
                            strHeight = strDimensions;
                        } else {
                            arrParts = strDimensions.split(',');
                            strWidth = arrParts[0];
                            strHeight = arrParts[1];
                        }

                        strCSS +=   '\n@media ' + strCurrentMedia + ' {\n' +
                                    '    gs-img.image-id-' + intImageID + ' { width:' + strWidth + '; height: ' + strHeight + '; }\n' +
                                    '}\n';
                    }

                    //console.log(strCSS);

                    // append the column CSS
                    document.getElementById('gs-dynamic-css').innerHTML += '\n/* image #' + intImageID + ' */\n' + strCSS;

                } else {
                    intImageID = arrTakenlayouts.indexOf(strMinWidth);
                }

                this.classList.add('image-id-' + intImageID);
            }
        }
    });
});//jslint white:true
window.addEventListener('design-register-element', function () {
    registerDesignSnippet('<gs-insert>', '<gs-insert>', 'gs-insert src="${1:test.tpeople}">\n' +
                                                        '    ${2}\n' +
                                                        '</gs-insert>');

    designRegisterElement('gs-insert', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-insert.html');

    window.designElementProperty_GSINSERT = function(selectedElement) {
        addProp('Source&nbsp;Query', true,
                        '<gs-memo rows="1" autoresize class="target" value="' + encodeHTML(selectedElement.getAttribute('src') ||
                                selectedElement.getAttribute('source') || '') + '" mini></gs-memo>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'src', this.value);
        });

        addProp('Additional&nbsp;Values', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('addin') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'addin', this.value);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        addProp('Primary Keys', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('pk') || '') + '" mini></gs-text>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'pk', this.value);
        });

        addProp('Sequences', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('seq') || '') + '" mini></gs-text>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'seq', this.value);
        });


        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    xtag.register('gs-insert', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {
            submit: function (callback) {
                var element = this
                  , srcParts    = GS.templateWithQuerystring(element.getAttribute('src') || '').split('.')
                  , strSchema   = srcParts[0]
                  , strObject   = srcParts[1]
                  , strSeqCols, strPkCols, strAddIn
                  , strColumns = '', strResponseColumns, strInsertRecord = '', strInsertData
                  , arrElement, arrKey, arrValue, i, len, strResponse, parentSrcElement;

                // addin insert data
                strAddIn = GS.templateWithQuerystring(element.getAttribute('addin'));
                if (strAddIn) {
                    arrKey = GS.qryGetKeys(strAddIn);
                    arrValue = GS.qryGetKeys(strAddIn);

                    for (i = 0, len = arrKey.length; i < len; i += 1) {
                        strColumns += (strColumns ? '\t' : '') + GS.encodeForTabDelimited(arrKey[i]);
                        strInsertRecord += (strInsertRecord ? '\t' : '') + GS.encodeForTabDelimited(arrValue[i]);
                    }
                }

                // control insert data
                arrElement = xtag.query(element, '[column]');
                for (i = 0, len = arrElement.length; i < len; i += 1) {
                    parentSrcElement = GS.findParentElement(arrElement[i].parentNode, '[src]');
                    if (
                        parentSrcElement === element &&
                        (
                            arrElement[i].value !== undefined &&
                            arrElement[i].value !== null &&
                            arrElement[i].value !== ''
                        )) {
                        strColumns += (strColumns ? '\t' : '') + GS.encodeForTabDelimited(arrElement[i].getAttribute('column'));
                        strInsertRecord += (strInsertRecord ? '\t' : '') + GS.encodeForTabDelimited(arrElement[i].value);
                    }
                }

                strPkCols = GS.templateWithQuerystring(element.getAttribute('pk') || 'id');
                strSeqCols = GS.templateWithQuerystring(element.getAttribute('seq') || '');
                strInsertData = (strColumns + '\n' + strInsertRecord);
                strResponseColumns = (strPkCols + (strPkCols ? '\t' : '') + strColumns);

                GS.requestInsertFromSocket(
                        GS.envSocket, strSchema, strObject, strResponseColumns, strPkCols, strSeqCols, strInsertData
                        // beginCallback
                      , function () {}

                        // confirmCallback
                      , function (data, error, transactionID, commitFunction, rollbackFunction) {
                            var arrCells, i, len, arrElements, jsnSelection, focusElement, focusColumnParent, focusColumnParentIndex;

                            if (data !== 'TRANSACTION COMPLETED') {
                                if (!error) {
                                    strResponse = data;
                                    commitFunction();

                                } else {
                                    GS.webSocketErrorDialog(data);
                                    rollbackFunction();
                                }
                            } else {
                                commitFunction();
                            }
                        }

                        // finalCallback
                      , function (strType, data, error) {
                            var arrColumns, arrCells, jsnRow = {}, i, len;

                            if (strType === 'COMMIT') {
                                arrColumns = strResponseColumns.split('\t');
                                arrCells = (strResponse || '').split('\n')[0].split('\t');

                                if (arrColumns.length !== arrCells.length) {
                                    throw 'gs-insert Error: Insert API call isn\'t returning correctly. (' + arrColumns.join(',') + ') -> (' + arrCells.join(',') + ')';
                                } else {
                                    for (i = 0, len = arrColumns.length; i < len; i += 1) {
                                        jsnRow[GS.decodeFromTabDelimited(arrColumns[i])] = GS.decodeFromTabDelimited(arrCells[i]);
                                    }

                                    GS.triggerEvent(element, 'after_insert');

                                    if (typeof callback === 'function') {
                                        callback(GS.decodeFromTabDelimited(arrCells[0]), jsnRow);
                                    }
                                }
                            }
                        }
                );
            }
        }
    });
});//global GS, window, document, xtag, evt, ml, encodeHTML, addFlexProps, setOrRemoveTextAttribute, setOrRemoveBooleanAttribute, addProp

window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('<gs-interval>', '<gs-interval>', 'gs-interval column="${1:complete_time}"></gs-interval>');
    registerDesignSnippet('<gs-interval> With Label', '<gs-interval>', 'label for="${1:interval-insert-complete_time}">${2:Time to complete}:</label>\n' +
                                                               '<gs-interval id="${1:interval-insert-complete_time}" column="${3:complete_time}"></gs-interval>');

    designRegisterElement('gs-interval', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-interval.html');

    window.designElementProperty_GSINTERVAL = function (selectedElement) {
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        addProp('Time Picker', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-picker')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-picker', (this.value === 'true'), false);
        });

        addProp(
            'Unit',
            true,
            '        <gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('unit') || 'hours') + '" mini>' +
                    '    <option value="hours">Hours</option>' +
                    '    <option value="minutes">Minutes</option>' +
                    '    <option value="seconds">Seconds</option>' +
                    '</gs-select>',
            function () {
                return setOrRemoveTextAttribute(selectedElement, 'unit', this.value);
            }
        );

        addProp('Hour Places', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('hour-places') || '3') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'hour-places', this.value);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });


        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility',
                true,
                '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                '    <option value="">Visible</option>' +
                '    <option value="hidden">Invisible</option>' +
                '    <option value="hide-on-desktop">Invisible at desktop size</option>' +
                '    <option value="hide-on-tablet">Invisible at tablet size</option>' +
                '    <option value="hide-on-phone">Invisible at phone size</option>' +
                '    <option value="show-on-desktop">Visible at desktop size</option>' +
                '    <option value="show-on-tablet">Visible at tablet size</option>' +
                '    <option value="show-on-phone">Visible at phone size</option>' +
                '</gs-select>',
                function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        addFlexProps(selectedElement);

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
        });
    };
});


document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    //x attributes:
    //x      disabled:      copy to control element
    //x      tabindex:      move to control element
    //x      qs:            fill value from querystring, update value as querystring changes
    //x      value:         affects control value
    //x      no-picker:     affects innerHTML because it removes the picker button
    //x      unit
    //x      hour-places
    //x      minute-places
    //x      second-places

    //x accessors:
    //x      value:     returns text value
    //x      state:     returns text representation of state: "open" or "closed"

    //x methods:
    //x      open:   opens popup
    //x      close:  closes popup
    //x      toggle: toggles open and closed methods

    //x text editing behaviours:
    //x      text is divided by colons into portions
    //x      if value is deleted or empty, it displays with zeros

    //x events:
    //x      picker button click: runs "toggle" method
    //x      control keydown:
    //x          up arrow:    increase currently selected portion
    //x          down arrow:  previous minute
    //x          left arrow:  select previous portion
    //x          right arrow: select next portion

    //x dropdown behaviours:
    //x          if from control to bottom has enough room: popup below
    //x          else: popup above

    /*
        unit:
            hours: shows hours only
            minutes: shows minutes and hours
            seconds: shows seconds, minutes and hours
        hour-places: allows the dev to choose the maximum places in the hours
    */


    // #####################################################################################
    // ################################## EVENT  TRIGGERING ################################
    // #####################################################################################

    function handleChange(element) {
        element.close();
        if (element.lastChangeValue !== element.getAttribute('value')) {
            GS.triggerEvent(element, 'change');
            element.lastChangeValue = element.getAttribute('value');
        }
    }

    // #####################################################################################
    // ################################## EVENT RETARGETING ################################
    // #####################################################################################

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();

        event.target.parentNode.setAttribute('value', event.target.value);
        handleChange(event.target.parentNode);
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
        event.target.parentNode.classList.add('focus');
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'blur');
        event.target.parentNode.classList.remove('focus');
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseout);
        event.target.parentNode.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseover);
        event.target.parentNode.classList.add('hover');
    }


    // #####################################################################################
    // ######################################## VALUE ######################################
    // #####################################################################################

    //console.log('1***', translateValue(GS.stringToElement('<gs-interval unit="hours"></gs-interval>'), '5.255')); // 5 hours, 15 mins, 30 seconds
    //console.log('2***', translateValue(GS.stringToElement('<gs-interval unit="minutes"></gs-interval>'), '500.25')); // 8 hours, 20 mins, 15 seconds
    //console.log('3***', translateValue(GS.stringToElement('<gs-interval unit="seconds"></gs-interval>'), '5000')); // 1 hour, 23 mins, 20 seconds
    //console.log('4***', translateValue(GS.stringToElement('<gs-interval unit="seconds"></gs-interval>'), '0.03333333333333333')); // 2 mins

    function valueGetCurrentNumber(element) {
        var intValue = 0;

        if (element.internal.unit === 'minutes') {
            intValue += (element.internal.value.hours * 60);
            intValue += element.internal.value.minutes;
            //intValue += (element.internal.value.seconds / 60);
        } else if (element.internal.unit === 'seconds') {
            intValue += ((element.internal.value.hours * 60) * 60);
            intValue += (element.internal.value.minutes * 60);
            intValue += element.internal.value.seconds;
        } else {//hours
            intValue += element.internal.value.hours;
            //intValue += parseFloat((element.internal.value.minutes / 60).toFixed(5));
            //intValue += parseFloat(((element.internal.value.seconds / 60) / 60).toFixed(5));
        }

        return String(intValue);
    }

    function valueGetCurrentDisplay(element) {
        var strValue = '';
        var intHours = element.internal.value.hours;
        var intMinutes = element.internal.value.minutes;
        var intSeconds = element.internal.value.seconds;

        if (element.internal.places.hours > 0) {
            strValue += GS.leftPad(intHours || '', '0', element.internal.places.hours);
        }

        if (element.internal.places.minutes > 0) {
            strValue += (strValue ? ':' : '');
            strValue += GS.leftPad(intMinutes || '', '0', element.internal.places.minutes);
        }

        if (element.internal.places.seconds > 0) {
            strValue += (strValue ? ':' : '');
            strValue += GS.leftPad(intSeconds || '', '0', element.internal.places.seconds);
        }

        return String(strValue);
    }

    function valueUpdatePicker(element) {
        var currentValue = valueGetCurrentDisplay(element);
        var i;
        var len;
        var arrElements;
        var intColons = 0;

        //console.log('currentValue:', currentValue);
        //console.log('PLACES: ', element.internal.places.hours, element.internal.places.minutes, element.internal.places.seconds);

        // set value of the select boxes
        i = 0;
        len = element.internal.places.hours;
        arrElements = xtag.query(element.internal.picker, '[data-hour]');
        while (i < len) {
            //console.log('SELECTBOX HR: ', arrElements[i]);
            arrElements[i].value = currentValue[i];
            i += 1;
        }
        if (len > 0) {
            intColons += 1;
        }

        i = 0;
        len = element.internal.places.minutes;
        arrElements = xtag.query(element.internal.picker, '[data-minute]');
        while (i < len) {
            //console.log('SELECTBOX MIN: ', arrElements[i]);
            arrElements[i].value =
                    currentValue[element.internal.places.hours + intColons + i];
            i += 1;
        }
        if (len > 0) {
            intColons += 1;
        }

        i = 0;
        len = element.internal.places.seconds;
        arrElements = xtag.query(element.internal.picker, '[data-second]');
        while (i < len) {
            //console.log('SELECTBOX SEC: ', arrElements[i]);
            arrElements[i].value =
                    currentValue[element.internal.places.hours + element.internal.places.minutes + intColons + i];
            i += 1;
        }
    }

    function valueUpdateDisplay(element) {
        if (element.control) {
            element.control.value = valueGetCurrentDisplay(element);
        } else {
            element.textContent = valueGetCurrentDisplay(element);
        }
    }

    function valueUpdateAttribute(element) {
        element.setAttribute('value', valueGetCurrentNumber(element));
    }


    // #####################################################################################
    // ####################################### CONTROL #####################################
    // #####################################################################################

    function refreshControl(element) {
        var i;
        var len;
        var arrPassThroughAttributes;
        var strHTML;

        // clear out HTML
        element.innerHTML = '';

        // clear out element variables
        element.control = '';
        element.button = '';

        // if we are not disabled:
        if (!element.hasAttribute('disabled')) {
            // build HTML
            strHTML =
                    '<input class="control" gs-dynamic type="text" ' +
                    'autocorrect="off" autocapitalize="off" ' +
                    'autocomplete="off" spellcheck="false" />';
            if (!element.hasAttribute('no-picker')) {
                strHTML += '<gs-button class="time-picker-button" gs-dynamic inline icononly icon="hourglass-o" no-focus></gs-button>';
            }

            // set control HTML
            element.innerHTML = strHTML;

            // fill element variables
            element.control = element.children[0];
            element.button = element.children[1];

            // handle passthrough attributes
            arrPassThroughAttributes = ['name', 'autofocus', 'spellcheck', 'readonly'];

            i = 0;
            len = arrPassThroughAttributes.length;
            while (i < len) {
                if (element.hasAttribute(arrPassThroughAttributes[i])) {
                    element.control.setAttribute(arrPassThroughAttributes[i], element.getAttribute(arrPassThroughAttributes[i]) || '');
                }
                i += 1;
            }

            // move tabindex, tabindex is special because tabindex affects any displayed element it's used on
            if (element.hasAttribute('tabindex')) {
                element.oldTabIndex = element.getAttribute('tabindex');
                element.removeAttribute('tabindex');
            }

            if (element.oldTabIndex) {
                element.control.tabIndex = element.oldTabIndex;
            }

            // bind control retargeting
            element.control.removeEventListener('change', changeFunction);
            element.control.addEventListener('change', changeFunction);

            element.control.removeEventListener('focus', focusFunction);
            element.control.addEventListener('focus', focusFunction);

            element.control.removeEventListener('blur', blurFunction);
            element.control.addEventListener('blur', blurFunction);

            element.control.removeEventListener(evt.mouseout, mouseoutFunction);
            element.control.addEventListener(evt.mouseout, mouseoutFunction);

            element.control.removeEventListener(evt.mouseout, mouseoverFunction);
            element.control.addEventListener(evt.mouseover, mouseoverFunction);
        }

        // display value
        valueUpdateDisplay(element);
        //displayValue(element);
        //setValueDisplay(element, element.getAttribute('value'));
    }

    function valueSiphonAttribute(element) {
        var fltValue = parseFloat(element.getAttribute('value') || '0');

        var intHours;
        var intMinutes;
        var intSeconds;

        if (element.internal.unit === 'minutes') {
            intHours = Math.floor(fltValue / 60);
            fltValue = fltValue - (intHours * 60); // remove the hours from fltValue

            intMinutes = Math.floor(fltValue);
            fltValue = fltValue - Math.floor(fltValue); // remove the minutes from fltValue

            intSeconds = 0; //Math.floor(fltValue);

        } else if (element.internal.unit === 'seconds') {
            intHours = Math.floor((fltValue / 60) / 60);
            fltValue = fltValue - ((intHours * 60) * 60); // remove the hours from fltValue

            intMinutes = Math.floor(fltValue / 60);
            fltValue = fltValue - (intMinutes * 60); // remove the minutes from fltValue

            intSeconds = Math.round(fltValue);
        } else {
            intHours = Math.floor(fltValue);
            //fltValue = fltValue - intHours; // remove the hours from fltValue

            intMinutes = 0;//Math.floor(fltValue * 60);
            //fltValue = fltValue - (intMinutes / 60);

            intSeconds = 0;//Math.round((fltValue * 100) * 60);
        }

        if (isNaN(intHours)) {
            intHours = 0;
        }
        if (isNaN(intMinutes)) {
            intMinutes = 0;
        }
        if (isNaN(intSeconds)) {
            intSeconds = 0;
        }

        //console.log('siphon: ', element);
        //console.log('intHours:   ', intHours);
        //console.log('intMinutes: ', intMinutes);
        //console.log('intSeconds: ', intSeconds);

        element.internal.value.hours = intHours;
        element.internal.value.minutes = intMinutes;
        element.internal.value.seconds = intSeconds;
    }


    // #####################################################################################
    // ##################################### QUERYSTRING ###################################
    // #####################################################################################

    //function pushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString();
    //    var strQSCol = element.getAttribute('qs');

    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.setAttribute('value', GS.qryGetVal(strQueryString, strQSCol));
    //    }
    //}


    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.setAttribute('value', strQSValue);
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    function handleQS(element) {
        //var strQSValue;

        if (!element.qsEventFunction) {
            element.qsEventFunction = function () {
                pushReplacePopHandler(element);
            };
        }

        window.removeEventListener('pushstate', element.qsEventFunction);
        window.removeEventListener('replacestate', element.qsEventFunction);
        window.removeEventListener('popstate', element.qsEventFunction);

        // handle "qs" attribute
        if (element.getAttribute('qs')) {
            pushReplacePopHandler(element);
            //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));

            //if (strQSValue !== '' || !element.getAttribute('value')) {
            //    element.setAttribute('value', strQSValue);
            //}

            window.addEventListener('pushstate', element.qsEventFunction);
            window.addEventListener('replacestate', element.qsEventFunction);
            window.addEventListener('popstate', element.qsEventFunction);
        }
    }

    // #####################################################################################
    // ################################### PARENT  ELEMENT #################################
    // #####################################################################################

    function prepElement(element) {
        element.internal = {};

        element.internal.value = {
            "hours": 0,
            "minutes": 0,
            "seconds": 0
        };

        element.internal.places = {
            "hours": 0,
            "minutes": 0,
            "seconds": 0
        };

        element.internal.unit = '';

        element.internal.picker = '';
    }

    function siphonElement(element) {
        // siphon the unit
        element.internal.unit = element.getAttribute('unit') || '';
        element.internal.unit = element.internal.unit.toLowerCase();
        element.internal.unit = element.internal.unit || 'minutes';

        if (element.internal.unit !== 'hours' &&
                element.internal.unit !== 'minutes' &&
                element.internal.unit !== 'seconds') {
            element.internal.unit = 'minutes';
            console.warn(
                'gs-interval Warning: invalid "unit" attribute. ' +
                        'Please use "hours", "minutes" or "seconds".  ' +
                        'Defaulting "unit" to "minutes"',
                element
            );
        }

        // get the place settings
        var intHourPlaces = parseInt(element.getAttribute('hour-places'), 10);
        var intMinutePlaces = 0;
        var intSecondPlaces = 0;

        // default place settings
        if (isNaN(intHourPlaces)) {
            intHourPlaces = 3;
        }
        if (element.internal.unit === 'minutes' || element.internal.unit === 'seconds') {
            intMinutePlaces = 2;
        }
        if (element.internal.unit === 'seconds') {
            intSecondPlaces = 2;
        }

        element.internal.places.hours = intHourPlaces;
        element.internal.places.minutes = intMinutePlaces;
        element.internal.places.seconds = intSecondPlaces;

        // siphon the value attribute
        // get hours/minutes/seconds from value
        valueSiphonAttribute(element);
    }

    // #####################################################################################
    // ###################################### LIFECYCLE ####################################
    // #####################################################################################

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value) {
                element.setAttribute('value', element.value);
                delete element.value;
            }
        }
    }

    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.innerState = 'closed';

                prepElement(element);
                siphonElement(element);
                saveDefaultAttributes(element);
                refreshControl(element);

                if (element.getAttribute('qs')) {
                    handleQS(element);
                }

                element.lastChangeValue = element.getAttribute('value');
            }
        }
    }

    // ######################################################################################
    // ##################################### REGISTRATION ###################################
    // ######################################################################################

    xtag.register('gs-interval', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(element);
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);

                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'disabled' || strAttrName === 'no-picker' || strAttrName === 'tabindex') {
                        siphonElement(element);
                        refreshControl(element);

                    } else if (strAttrName === 'qs') {
                        handleQS(element);

                    } else if (strAttrName === 'value' && element.inserted) {
                        ////displayValue(element);
                        //siphonElement(element);
                        //displayValue(element);
                        ////setValueDisplay(element, newValue);
                        valueSiphonAttribute(element);
                        valueUpdateDisplay(element);

                        if (element.innerState === 'open') {
                            valueUpdatePicker(element);
                        }
                    }
                }
            }
        },
        events: {
            'click': function (event) {
                var element = this;
                if (event.target === element.button) {
                    element.toggle();
                }
            },

            'mouseup': function (event) {
                var element = this;
                var strValue = element.control.value;
                var jsnTextSelection;
                var intCursor;
                var i;
                var len;
                var arrDelimiterIndexes;
                var intSection;

                if (!element.hasAttribute('readonly')) {
                    element.numberOfCharsTyped = 0;

                    jsnTextSelection = GS.getInputSelection(element.control);

                    i = 0;
                    len = strValue.length;
                    arrDelimiterIndexes = [0];
                    while (i < len) {
                        if (strValue[i] === ':') {
                            arrDelimiterIndexes.push(i);
                        }
                        i += 1;
                    }
                    arrDelimiterIndexes.push(strValue.length);

                    event.preventDefault();

                    intCursor = jsnTextSelection.start;

                    // find out what section the cursor is in
                    i = 1;
                    len = arrDelimiterIndexes.length;
                    while (i < len) {
                        if (intCursor >= arrDelimiterIndexes[i - 1] && intCursor <= arrDelimiterIndexes[i]) {
                            intSection = i;
                            break;
                        }
                        i += 1;
                    }

                    // select the section of the value that the cursor is in
                    if (intSection === 1) {
                        GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1], arrDelimiterIndexes[intSection]);
                    } else {
                        GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1] + 1, arrDelimiterIndexes[intSection]);
                    }
                }
            },

            'keydown': function (event) { // don't use the "input" event, doesn't work for this
                var element = this;
                var strValue = element.control.value;
                var intKeyCode = (event.keyCode || event.which);

                var jsnTextSelection;
                var arrDelimiterIndexes;
                var i;
                var len;
                var intCursor;
                var intSection;
                var strPlace;
                var strChar;
                var strSection;

                if (!element.hasAttribute('readonly')) {
                    jsnTextSelection = GS.getInputSelection(element.control);

                    i = 0;
                    len = strValue.length;
                    arrDelimiterIndexes = [0];
                    while (i < len) {
                        if (strValue[i] === ':') {
                            arrDelimiterIndexes.push(i);
                        }
                        i += 1;
                    }
                    arrDelimiterIndexes.push(strValue.length);

                    // get cursor position
                    intCursor = jsnTextSelection.start;

                    // find out what section the cursor is in
                    i = 1;
                    len = arrDelimiterIndexes.length;
                    while (i < len) {
                        if (intCursor >= arrDelimiterIndexes[i - 1] && intCursor <= arrDelimiterIndexes[i]) {
                            intSection = i;
                            break;
                        }
                        i += 1;
                    }

                    // if key was an arrow
                    if (intKeyCode >= 37 && intKeyCode <= 40) {
                        element.numberOfCharsTyped = 0;
                        event.preventDefault();

                        // left     37
                        // top      38
                        // right    39
                        // down     40

                        // handle/right arrows moving the cursor
                        if (intKeyCode === 37) {
                            intSection -= 1;
                            intSection = Math.max(intSection, 1);
                        } else if (intKeyCode === 39) {
                            intSection += 1;
                            intSection = Math.min(intSection, arrDelimiterIndexes.length - 1);
                        }

                        // select the section of the value that the cursor is in
                        if (intSection === 1) {
                            GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1], arrDelimiterIndexes[intSection]);
                        } else {
                            GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1] + 1, arrDelimiterIndexes[intSection]);
                        }

                        // find out what section that the cursor is in (hours, minutes or seconds)
                        if (intSection === 0 || intSection === 1) {
                            strPlace = 'hours';
                        } else if (intSection === 2) {
                            strPlace = 'minutes';
                        } else if (intSection === 3 || intSection === 4) {
                            strPlace = 'seconds';
                        }

                        // update text selection variable
                        jsnTextSelection = GS.getInputSelection(element.control);

                        // handle up and down arrows incrementing/decrementing
                        //      the value of the currently selected section
                        if (intKeyCode === 38) { // up
                            if (strPlace === 'hours') {
                                element.internal.value.hours += 1;
                            } else if (strPlace === 'minutes') {
                                element.internal.value.minutes += 1;
                            } else if (strPlace === 'seconds') {
                                element.internal.value.seconds += 1;
                            }

                            if (String(element.internal.value.hours).length > element.internal.places.hours) {
                                element.internal.value.hours = parseInt(
                                    '999999999999999'.substring(0, element.internal.places.hours),
                                    10
                                );
                            }
                            if (element.internal.value.seconds > 59) {
                                element.internal.value.minutes += 1;
                                element.internal.value.seconds = 0;
                            }
                            if (element.internal.value.minutes > 59) {
                                element.internal.value.hours += 1;
                                element.internal.value.minutes = 0;
                            }

                        } else if (intKeyCode === 40) { // down
                            if (strPlace === 'hours') {
                                element.internal.value.hours -= 1;
                            } else if (strPlace === 'minutes') {
                                element.internal.value.minutes -= 1;
                            } else if (strPlace === 'seconds') {
                                element.internal.value.seconds -= 1;
                            }

                            if (element.internal.value.seconds < 0) {
                                if (element.internal.value.minutes > 0) {
                                    element.internal.value.minutes -= 1;
                                    element.internal.value.seconds = 59;
                                } else if (element.internal.value.hours > 0) {
                                    element.internal.value.hours -= 1;
                                    element.internal.value.minutes = 59;
                                    element.internal.value.seconds = 59;
                                } else {
                                    element.internal.value.seconds = 0;
                                }
                            }
                            if (element.internal.value.minutes < 0) {
                                if (element.internal.value.hours > 0) {
                                    element.internal.value.minutes = 59;
                                    element.internal.value.hours -= 1;
                                } else {
                                    element.internal.value.minutes = 0;
                                }
                            }
                            if (element.internal.value.hours < 0) {
                                element.internal.value.hours = 0;
                            }
                        }

                        if (intKeyCode === 38 || intKeyCode === 40) {
                            //trinkleValueDown(element);
                            //displayValue(element);
                            valueUpdateAttribute(element);
                            GS.setInputSelection(element.control, jsnTextSelection.start, jsnTextSelection.end);
                        }

                    // if key was a number
                    } else if ((intKeyCode >= 48 && intKeyCode <= 57) || (intKeyCode >= 96 && intKeyCode <= 105)) {
                        element.numberOfCharsTyped = element.numberOfCharsTyped || 0;
                        event.preventDefault();

                        // get the character that was typed
                        strChar = String.fromCharCode(intKeyCode);
                        if (intKeyCode === 96) { strChar = '0'; }
                        if (intKeyCode === 97) { strChar = '1'; }
                        if (intKeyCode === 98) { strChar = '2'; }
                        if (intKeyCode === 99) { strChar = '3'; }
                        if (intKeyCode === 100) { strChar = '4'; }
                        if (intKeyCode === 101) { strChar = '5'; }
                        if (intKeyCode === 102) { strChar = '6'; }
                        if (intKeyCode === 103) { strChar = '7'; }
                        if (intKeyCode === 104) { strChar = '8'; }
                        if (intKeyCode === 105) { strChar = '9'; }

                        // select the section of the value that the cursor is in
                        if (intSection === 1) {
                            GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1], arrDelimiterIndexes[intSection]);
                        } else {
                            GS.setInputSelection(element.control, arrDelimiterIndexes[intSection - 1] + 1, arrDelimiterIndexes[intSection]);
                        }

                        // find out what section that the cursor is in (hours, minutes or seconds)
                        if (intSection === 0 || intSection === 1) {
                            strPlace = 'hours';
                        } else if (intSection === 2) {
                            strPlace = 'minutes';
                        } else if (intSection === 3 || intSection === 4) {
                            strPlace = 'seconds';
                        }

                        // update text selection variable
                        jsnTextSelection = GS.getInputSelection(element.control);

                        // when you type in a number,
                        //      if no data is set saying "this is where the typing begins":
                        //              insert the number as the first character of the section
                        //              after that set data to say where the typing begins
                        //      no matter what is typed: stay in the same section
                        strSection = strValue.substring(jsnTextSelection.start, jsnTextSelection.end);

                        strSection =
                                strSection.substring(0, element.numberOfCharsTyped) +
                                strChar +
                                strSection.substring(element.numberOfCharsTyped + 1);

                        strValue =
                                strValue.substring(0, jsnTextSelection.start) +
                                strSection +
                                strValue.substring(jsnTextSelection.end);

                        //console.log(element.numberOfCharsTyped);
                        element.numberOfCharsTyped += 1;

                        if (element.numberOfCharsTyped === strSection.length) {
                            element.numberOfCharsTyped = 0;
                        }

                        if (strPlace === 'hours') {
                            element.internal.value.hours = parseInt(strSection, 10);
                        }
                        if (strPlace === 'minutes') {
                            element.internal.value.minutes = parseInt(strSection, 10);
                        }
                        if (strPlace === 'seconds') {
                            element.internal.value.seconds = parseInt(strSection, 10);
                        }

                        //console.log(strValue, element.control.value, translateValueToNumber(element, strValue));

                        if (strValue !== element.control.value) {
                            //trinkleValueDown(element);
                            //displayValue(element);
                            valueUpdateAttribute(element);
                            GS.setInputSelection(element.control, jsnTextSelection.start, jsnTextSelection.end);
                        }
                    } else if (intKeyCode === 13) {
                        element.numberOfCharsTyped = 0;
                        event.preventDefault();
                        handleChange(element);
                    } else if (intKeyCode !== 9 && event.ctrlKey === false && event.metaKey === false) {
                        element.numberOfCharsTyped = 0;
                        event.preventDefault();
                    }
                }
            },
            'blur': function () {// don't use 'focusout', it doesn't work on firefox
                var element = this;
                if (element.innerState === 'closed') {
                    handleChange(element);
                }
            }
        },
        accessors: {
            value: {
                get: function () {
                    return this.getAttribute('value');
                },
                set: function (newValue) {
                    this.setAttribute('value', newValue);
                }
            },
            state: {
                get: function () {
                    return this.innerState;
                },
                set: function (newValue) {
                    var element = this;
                    if (newValue === 'open') {
                        element.open();
                    } else {
                        element.close();
                    }
                }
            }
        },
        methods: {
            focus: function () {
                this.control.focus();
            },

            open: function () {
                var element = this;
                var pickerContainerElement;
                var overlayElement;
                var pickerElement;
                var handleLook;
                var strHTML;
                var i;
                var len;
                var arrElements;

                if (element.innerState === 'closed') {
                    element.innerState = 'open';
                    element.lastClosedValue = element.getAttribute('value');

                    // if we are not on a touch device: focus control
                    if (!evt.touchDevice) {
                        element.control.focus();
                        GS.setInputSelection(element.control, 0, element.control.value.length);
                    }

                    // create picker elements
                    pickerContainerElement = document.createElement('div');
                    pickerContainerElement.classList.add('gs-interval-time-picker-container');

                    overlayElement = document.createElement('div');
                    overlayElement.classList.add('gs-interval-time-picker-overlay');

                    pickerElement = document.createElement('div');
                    pickerElement.classList.add('gs-interval-time-picker');
                    element.internal.picker = pickerElement;

                    // save picker container
                    element.pickerContainerElement = pickerContainerElement;

                    // append picker elements
                    pickerContainerElement.appendChild(overlayElement);
                    pickerContainerElement.appendChild(pickerElement);

                    document.body.appendChild(pickerContainerElement);

                    // fill picker popup
                    strHTML = '';
                    strHTML += '<div class="time-inner-container">';

                    i = 0;
                    len = element.internal.places.hours;
                    while (i < len) {
                        strHTML +=
                                '<select class="gs-interval-hour" data-hour="' + i + '">' +
                                '    <option value="0">&nbsp;0</option>' +
                                '    <option value="1">&nbsp;1</option>' +
                                '    <option value="2">&nbsp;2</option>' +
                                '    <option value="3">&nbsp;3</option>' +
                                '    <option value="4">&nbsp;4</option>' +
                                '    <option value="5">&nbsp;5</option>' +
                                '    <option value="6">&nbsp;6</option>' +
                                '    <option value="7">&nbsp;7</option>' +
                                '    <option value="8">&nbsp;8</option>' +
                                '    <option value="9">&nbsp;9</option>' +
                                '</select>';
                        i += 1;
                    }

                    if (element.internal.places.hours > 0 && element.internal.places.minutes > 0) {
                        strHTML += '<span class="colon">:</span>';
                    }

                    i = 0;
                    len = element.internal.places.minutes;
                    while (i < len) {
                        strHTML +=
                                '<select class="gs-interval-minute" data-minute="' + i + '">' +
                                '    <option value="0">&nbsp;0</option>' +
                                '    <option value="1">&nbsp;1</option>' +
                                '    <option value="2">&nbsp;2</option>' +
                                '    <option value="3">&nbsp;3</option>' +
                                '    <option value="4">&nbsp;4</option>' +
                                '    <option value="5">&nbsp;5</option>';

                        if (i > 0) {
                            strHTML +=
                                    '<option value="6">&nbsp;6</option>' +
                                    '<option value="7">&nbsp;7</option>' +
                                    '<option value="8">&nbsp;8</option>' +
                                    '<option value="9">&nbsp;9</option>';
                        }

                        strHTML +=
                                '</select>';
                        i += 1;
                    }

                    if (element.internal.places.minutes > 0 && element.internal.places.seconds > 0) {
                        strHTML += '<span class="colon">:</span>';
                    }

                    i = 0;
                    len = element.internal.places.seconds;
                    while (i < len) {
                        strHTML +=
                                '<select class="gs-interval-second" data-second="' + i + '">' +
                                '    <option value="0">&nbsp;0</option>' +
                                '    <option value="1">&nbsp;1</option>' +
                                '    <option value="2">&nbsp;2</option>' +
                                '    <option value="3">&nbsp;3</option>' +
                                '    <option value="4">&nbsp;4</option>' +
                                '    <option value="5">&nbsp;5</option>';

                        if (i > 0) {
                            strHTML +=
                                    '<option value="6">&nbsp;6</option>' +
                                    '<option value="7">&nbsp;7</option>' +
                                    '<option value="8">&nbsp;8</option>' +
                                    '<option value="9">&nbsp;9</option>';
                        }

                        strHTML +=
                                '</select>';
                        i += 1;
                    }

                    strHTML += '</div>';
                    pickerElement.innerHTML = strHTML;


                    // set picker value
                    valueUpdatePicker(element);

                    // bind picker click
                    overlayElement.addEventListener('click', function () {
                        element.close();
                    });

                    pickerElement.addEventListener('change', function () {//event
                        //var arrElements;
                        //var i;
                        //var len;
                        var newValue = 0;
                        var strCurrentValue;

                        if (element.internal.unit === 'hours') {
                            i = 0;
                            len = element.internal.places.hours;
                            arrElements = xtag.query(pickerElement, '[data-hour]');
                            strCurrentValue = '';
                            while (i < len) {
                                strCurrentValue += arrElements[i].value;
                                i += 1;
                            }
                            if (arrElements.length > 0) {
                                newValue += parseInt(strCurrentValue, 10);
                            }

                            //i = 0;
                            //len = element.internal.places.minutes;
                            //arrElements = xtag.query(pickerElement, '[data-minute]');
                            //strCurrentValue = '';
                            //while (i < len) {
                            //    strCurrentValue += arrElements[i].value;
                            //    i += 1;
                            //}
                            //if (arrElements.length > 0) {
                            //    newValue += (parseInt(strCurrentValue, 10) / 60);
                            //}

                            //i = 0;
                            //len = element.internal.places.seconds;
                            //arrElements = xtag.query(pickerElement, '[data-second]');
                            //strCurrentValue = '';
                            //while (i < len) {
                            //    strCurrentValue += arrElements[i].value;
                            //    i += 1;
                            //}
                            //if (arrElements.length > 0) {
                            //    newValue += ((parseInt(strCurrentValue, 10) / 60) / 60);
                            //}
                        }
                        if (element.internal.unit === 'minutes') {
                            i = 0;
                            len = element.internal.places.hours;
                            arrElements = xtag.query(pickerElement, '[data-hour]');
                            strCurrentValue = '';
                            while (i < len) {
                                strCurrentValue += arrElements[i].value;
                                i += 1;
                            }
                            if (arrElements.length > 0) {
                                newValue += parseInt(strCurrentValue, 10) * 60;
                            }

                            i = 0;
                            len = element.internal.places.minutes;
                            arrElements = xtag.query(pickerElement, '[data-minute]');
                            strCurrentValue = '';
                            while (i < len) {
                                strCurrentValue += arrElements[i].value;
                                i += 1;
                            }
                            if (arrElements.length > 0) {
                                newValue += parseInt(strCurrentValue, 10);
                            }

                            //i = 0;
                            //len = element.internal.places.seconds;
                            //arrElements = xtag.query(pickerElement, '[data-second]');
                            //strCurrentValue = '';
                            //while (i < len) {
                            //    strCurrentValue += arrElements[i].value;
                            //    i += 1;
                            //}
                            //if (arrElements.length > 0) {
                            //    newValue += ((parseInt(strCurrentValue, 10) * 60) * 60);
                            //}
                        }
                        if (element.internal.unit === 'seconds') {
                            i = 0;
                            len = element.internal.places.hours;
                            arrElements = xtag.query(pickerElement, '[data-hour]');
                            strCurrentValue = '';
                            while (i < len) {
                                strCurrentValue += arrElements[i].value;
                                i += 1;
                            }
                            if (arrElements.length > 0) {
                                newValue += ((parseInt(strCurrentValue, 10) * 60) * 60);
                            }

                            i = 0;
                            len = element.internal.places.minutes;
                            arrElements = xtag.query(pickerElement, '[data-minute]');
                            strCurrentValue = '';
                            while (i < len) {
                                strCurrentValue += arrElements[i].value;
                                i += 1;
                            }
                            if (arrElements.length > 0) {
                                newValue += parseInt(strCurrentValue, 10) * 60;
                            }

                            i = 0;
                            len = element.internal.places.seconds;
                            arrElements = xtag.query(pickerElement, '[data-second]');
                            strCurrentValue = '';
                            while (i < len) {
                                strCurrentValue += arrElements[i].value;
                                i += 1;
                            }
                            if (arrElements.length > 0) {
                                newValue += parseInt(strCurrentValue, 10);
                            }
                        }

                        element.setAttribute('value', newValue);
                        //trinkleValueDown(element);
                        //setValueDisplay(element, newValue);
                    });

                    // handle/bind positioning and look
                    handleLook = function () {
                        var positionData;
                        var intPopupHeight;
                        var intPopupWidth;

                        if (pickerContainerElement.parentNode !== document.body) {
                            window.removeEventListener('resize', handleLook);
                            window.removeEventListener('orientationchange', handleLook);
                            return;
                        }

                        // clear current styles
                        pickerElement.style.top = '';
                        pickerElement.style.left = '';
                        pickerElement.style.marginTop = '';
                        //pickerContainerElement.classList.remove('modal');

                        // get position/size data
                        positionData = GS.getElementPositionData(element);
                        intPopupHeight = pickerElement.offsetHeight;
                        intPopupWidth = pickerElement.offsetWidth;

                        // if from control to bottom has enough room: popup below
                        if (positionData.intRoomBelow > intPopupHeight) {
                            pickerElement.style.top = (positionData.objElementOffset.top + positionData.intElementHeight) + 'px';

                        // else: popup above
                        } else {
                            pickerElement.style.top = (positionData.objElementOffset.top - intPopupHeight) + 'px';
                        }

                        pickerElement.style.left =
                                (((positionData.objElementOffset.left + positionData.intElementWidth) - intPopupWidth) - 4) + 'px';
                    };

                    handleLook();

                    window.addEventListener('resize', handleLook);
                    window.addEventListener('orientationchange', handleLook);
                }
            },

            close: function () {
                var element = this;

                if (element.innerState === 'open') {
                    element.innerState = 'closed';
                    if (element.pickerContainerElement) {
                        document.body.removeChild(element.pickerContainerElement);
                        element.pickerContainerElement = '';
                    }
                    if (element.getAttribute('value') !== element.lastClosedValue) {
                        handleChange(element);
                    }
                }
            },

            toggle: function () {
                var element = this;

                if (element.innerState === 'open') {
                    element.close();
                } else {
                    element.open();
                }
            }
        }
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('<gs-jumbo>', '<gs-jumbo>', 'gs-jumbo>\n' +
                                                                '    ${0}\n' +
                                                                '</gs-jumbo>');

    designRegisterElement('gs-jumbo', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-container-jumbo.html');

    window.designElementProperty_GSJUMBO = function(selectedElement) {
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    xtag.register('gs-jumbo', {});
});
window.addEventListener('design-register-element', function () {
    registerDesignSnippet('Static Template <gs-listbox>', '<gs-listbox>', 'gs-listbox>\n'+
                                                                     '    <template>\n'+
                                                                     '        <table>\n'+
                                                                     '            <tbody>\n'+
                                                                     '                <tr value="${1}">\n'+
                                                                     '                    <td>${0}</td>\n'+
                                                                     '                </tr>\n'+
                                                                     '            </tbody>\n'+
                                                                     '        </table>\n'+
                                                                     '    </template>\n' +
                                                                     '</gs-listbox>');
    registerDesignSnippet('Custom Template <gs-listbox>', '<gs-listbox>', 'gs-listbox src="${1:test.tpeople}">\n'+
                                                                     '    <template>\n'+
                                                                     '        <table>\n'+
                                                                     '            <tbody>\n'+
                                                                     '                <tr value="{{! row.id }}">\n'+
                                                                     '                    <td>{{! row.${3:name} }}</td>\n'+
                                                                     '                </tr>\n'+
                                                                     '            </tbody>\n'+
                                                                     '        </table>\n'+
                                                                     '    </template>\n' +
                                                                     '</gs-listbox>');
    registerDesignSnippet('Dynamic Template <gs-listbox>', '<gs-listbox>', 'gs-listbox src="${1:test.tpeople}"></gs-listbox>');
    registerDesignSnippet('<gs-listbox>', '<gs-listbox>', 'gs-listbox src="${1:test.tpeople}"></gs-listbox>');

    designRegisterElement('gs-listbox', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-listbox.html');

    window.designElementProperty_GSLISTBOX = function(selectedElement) {
        addProp('Source', true, '<gs-memo class="target" value="' + encodeHTML(decodeURIComponent(selectedElement.getAttribute('src') ||
                                                                            selectedElement.getAttribute('source') || '')) + '" mini></gs-memo>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'src', encodeURIComponent(this.value));
        });

        addProp('Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('cols') || '') + '" mini></gs-text>',
                function () {
            return setOrRemoveTextAttribute(selectedElement, 'cols', this.value);
        });

        addProp('Hide Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('hide') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'hide', this.value);
        });

        addProp('Where', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('where') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'where', this.value);
        });

        addProp('Order By', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('ord') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'ord', this.value);
        });

        addProp('Limit', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('limit') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'limit', this.value);
        });

        addProp('Offset', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('offset') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'offset', this.value);
        });

        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        // NO-SELECT attribute
        addProp('Dissallow&nbsp;Select', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-select') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-select', this.value === 'true', true);
        });

        // LETTER-SCROLLBAR attribute
        addProp('Letter&nbsp;Scrollbar', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('letter-scrollbar') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'letter-scrollbar', this.value === 'true', true);
        });

        // LETTER-DIVIDERS attribute
        addProp('Letter Dividers', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('letter-dividers') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'letter-dividers', this.value === 'true', true);
        });

        addProp('Refresh On Querystring Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('refresh-on-querystring-values') || '') + '" mini></gs-text>', function () {
            this.removeAttribute('refresh-on-querystring-change');
            return setOrRemoveTextAttribute(selectedElement, 'refresh-on-querystring-values', this.value);
        });

        addProp('Refresh On Querystring Change', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('refresh-on-querystring-change')) + '" mini></gs-checkbox>', function () {
            this.removeAttribute('refresh-on-querystring-values');
            return setOrRemoveBooleanAttribute(selectedElement, 'refresh-on-querystring-change', this.value === 'true', true);
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    // removes selected class from old selected records adds class selected to record
    function highlightRecord(element, record) { //TODO: XLD
        var i, len, arrSelectedTrs;

        //console.log(record);

        if (element.tableElement && xtag.queryChildren(element.tableElement, 'tbody')[0]) {
            // clear previous selection
            arrSelectedTrs = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected]');

            for (i = 0, len = arrSelectedTrs.length; i < len; i += 1) {
                arrSelectedTrs[i].removeAttribute('selected');
            }
        }

        // select/highlight the record that was provided
        if (record) {
            if (record.length >= 0) {

                for (i = 0, len = record.length; i < len; i += 1) {
                    record[i].setAttribute('selected', '');
                }
            } else {
                record.setAttribute('selected', '');
            }
        }
    }

    // loops through the records and finds a record using the parameter
    function findRecordFromValue(element, searchValue) {
        var i, len, matchedRecord, arrTrs, strSearchString;

        if (element.tableElement && xtag.queryChildren(element.tableElement, 'tbody')[0]) {
            //console.log('1***', element.tableElement);
            //console.log('2***', xtag.queryChildren(element.tableElement, 'tbody')[0]);
            //console.log('3***', xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr'));
            arrTrs = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr');
            strSearchString = String(searchValue);

            // search exact text and search both the value attribute (if present) and the first td text
            for (i = 0, len = arrTrs.length; i < len; i += 1) {
                if (arrTrs[i].getAttribute('value') === strSearchString || xtag.queryChildren(arrTrs[i], 'td')[0].textContent === strSearchString) {
                    matchedRecord = arrTrs[i];
                    break;
                }
            }
        }

        return matchedRecord;
    }

    function getTRFromTarget(element) {
        var currentElement = element;

        while (currentElement.nodeName !== 'TR') {
            currentElement = currentElement.parentNode;
        }

        return currentElement;
    }
    //snapback

    //boladd should be true if event.metaKey is true

    //if boladd is true:
    //  selected records that were clicked become non-selected
    //  non-select records that were clicked become selected

    // if bolShift is true and not negative:
    //  select from element.lastClicked to the clicked record
    // if bolShift is true and negative:
    //  de-select from element.lastClicked to the clicked record
    //
    //

    function selectRecord(element, handle, bolChange, bolAdd, strType, bolShift) {
        if (!element.hasAttribute('no-select') && element.tableElement) {
            //console.log(element.secondLastClicked, element.lastClicked);
            var record, arrSelectedRecords = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected], tr[selected-secondary]');
            //console.log(handle, bolChange, bolAdd, strType, bolShift);
            //console.trace('A');
            if (!bolAdd && !bolShift) {
                var i, len, arrRecords = xtag.query(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr');
                element.secondLastClicked = null;
                for (i = 0, len = arrRecords.length; i < len; i += 1) {
                    arrRecords[i].removeAttribute('selected');
                    if (arrRecords[i].classList.contains('originTR')) {
                        arrRecords[i].classList.remove('originTR');
                    }
                }
            }

            if (typeof handle === 'string' || typeof handle === 'number') {
                record = findRecordFromValue(element, handle);
                if (!record && handle !== '') {
                    console.warn('Listbox warning: record not found' + (typeof handle === 'string' ? ': "' + handle + '"' : ''));
                }
            } else {
                record = handle;
            }

            if (element.hasAttribute('multi-select')) {
                if (handle.length >= 0) {
                    record = record;
                } else {
                    record = [record];
                }
            }

            if (bolShift && strType === 'down') {
                var clickFrom, newClicked, arrOrigins = xtag.query(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr.originTR')
                    , arrAllRecords = xtag.query(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr'), bolDeselect, intDistanceBetween = 0
                    , intSelected = 0, bolRemoveClicked = false;
                //if we have a lastClicked
                //    use that
                //else if we have an originTR
                //    use that
                //else if there is one selected record
                //    use that
                if (element.lastClicked) {
                    clickFrom = element.lastClicked
                } else if (arrOrigins.length === 1) {
                    clickFrom = arrOrigins[0].getAttribute('data-record_no');
                } else if (arrSelectedRecords.length === 1) {
                    clickFrom = arrSelectedRecords[0].getAttribute('data-record_no');
                }

                //get the record that was just clicked
                if (typeof handle === 'object' && handle.tagName) {
                    newClicked = parseInt(handle.getAttribute('data-record_no'), 10);
                }

                //console.log(clickFrom, newClicked);
                if (newClicked) {
                    //find how many are selected between clickFrom and newClicked
                    if (clickFrom < newClicked) {
                        for (var i = clickFrom, len = newClicked; i < len; i++) {
                            if (handle.hasAttribute('selected') || handle.hasAttribute('selected-secondary')) {
                                intSelected += 1;
                            }
                        }
                    } else {
                        for (var i = newClicked - 1, len = clickFrom - 1; i < len; i++) {
                            if (handle.hasAttribute('selected') || handle.hasAttribute('selected-secondary')) {
                                intSelected += 1;
                            }
                        }
                    }

                    if (clickFrom < newClicked) {
                        intDistanceBetween = newClicked - clickFrom;
                    } else {
                        intDistanceBetween = clickFrom - newClicked;
                    }

                    //if all of the records are selected
                    //    bolDeselect = true
                    //else
                    //    bolDeselect = false
                    if (intDistanceBetween <= intSelected) {
                        bolDeselect = true;
                    } else {
                        bolDeselect = false;
                    }


                    //console.log(bolDeselect, intDistanceBetween, intSelected);
                    //if clickFrom is higher in the list than newClicked
                    //    select down from clickFrom to newClicked
                    //else
                    //    select down from newClicked to clickFrom
                    if (clickFrom < newClicked) {
                        if (bolDeselect) {
                            clickFrom -= 1;
                            newClicked -= 1;
                        }
                        for (var i = clickFrom, len = newClicked; i < len; i++) {
                            if (bolDeselect) {
                                if (arrAllRecords[i].hasAttribute('selected')) {
                                    arrAllRecords[i].removeAttribute('selected');
                                }
                                if (arrAllRecords[i].hasAttribute('selected-secondary')) {
                                    arrAllRecords[i].removeAttribute('selected-secondary');
                                }
                            } else {
                                arrAllRecords[i].setAttribute('selected', '');
                            }
                            arrAllRecords[i].classList.remove('originTR');
                        }
                    } else {
                        if (bolDeselect) {
                            newClicked += 1;
                            clickFrom += 1
                        }
                        for (var i = newClicked - 1, len = clickFrom; i < len; i++) {
                            if (bolDeselect) {
                                if (arrAllRecords[i].hasAttribute('selected')) {
                                    arrAllRecords[i].removeAttribute('selected');
                                }
                                if (arrAllRecords[i].hasAttribute('selected-secondary')) {
                                    arrAllRecords[i].removeAttribute('selected-secondary');
                                }
                            } else {
                                arrAllRecords[i].setAttribute('selected', '');
                            }
                            arrAllRecords[i].classList.remove('originTR');
                        }
                    }
                }


                //if bolDeselect is false
                //    deselect from clickFrom to the first non-selected record
                if (!bolDeselect) {
                    if (clickFrom < newClicked) {
                        if (element.secondLastClicked > clickFrom && element.secondLastClicked < newClicked) {
                            bolRemoveClicked = true;
                        }
                    } else {
                        if (element.secondLastClicked < clickFrom && element.secondLastClicked > newClicked) {
                            bolRemoveClicked = true;
                        }
                    }

                    if (bolRemoveClicked) {
                        if (clickFrom < newClicked) {
                            for (var i = element.secondLastClicked - 2; i > 0; i--) {
                                    // console.log(arrAllRecords[i].outerHTML, arrAllRecords[i].hasAttribute('selected'), arrAllRecords[i].hasAttribute('selected-secondary'));
                                    arrAllRecords[i].classList.remove('originTR');

                                    if (arrAllRecords[i].hasAttribute('selected')) {
                                        arrAllRecords[i].removeAttribute('selected');
                                    } else if (arrAllRecords[i].hasAttribute('selected-secondary')) {
                                        arrAllRecords[i].removeAttribute('selected-secondary');
                                    } else {
                                        // console.log(arrAllRecords[i]);
                                        break;
                                    }
                            }
                        } else {
                            for (var i = element.secondLastClicked, len = arrAllRecords.length; i < len; i++) {
                                    arrAllRecords[i].classList.remove('originTR');
                                    if (arrAllRecords[i].hasAttribute('selected')) {
                                        arrAllRecords[i].removeAttribute('selected');
                                    } else if (arrAllRecords[i].hasAttribute('selected-secondary')) {
                                        arrAllRecords[i].removeAttribute('selected-secondary');
                                    } else {
                                        break;
                                    }
                            }
                        }
                    }
                    // console.log(bolRemoveClicked, i, len, bolDeselect, clickFrom < newClicked, element.secondLastClicked);
                }



                // var i_shift, len_shift, newNumber, arrOrigins = xtag.query(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr.originTR');
                // for (i_shift = 0, len_shift = arrOrigins.length; i_shift < len_shift; i_shift += 1) {
                //     arrOrigins[i_shift] = parseInt(arrOrigins[i_shift].getAttribute('data-record_no'),10);
                // }
                // newNumber = parseInt(handle.getAttribute('data-record_no'),10);

                // var currentNumber = arrOrigins[0];
                // var diff = Math.abs (newNumber - currentNumber);
                // for (var val = 0; val < arrOrigins.length; val++) {
                //     var newdiff = Math.abs (newNumber - arrOrigins[val]);
                //     if (newdiff < diff) {
                //         diff = newdiff;
                //         currentNumber = arrOrigins[val];
                //     }
                // }
                // // for (i_shift = 0, len_shift = arrOrigins.length; i_shift < len_shift; i_shift += 1) {
                // //     currentDiff = Math.abs(arrOrigins[i_shift] - newNumber);
                // //     //console.log(currentDiff, arrDiffs);
                // //     arrDiffs.push(currentDiff);
                // //     for (var i_diff = 0, len_diff = arrDiffs.length; i_diff < len_diff; i_diff += 1) {
                // //         if (currentDiff > arrDiffs[i_diff]) {
                // //             currentDiff = arrDiffs[i_diff];
                // //             currentNumber = arrOrigins[i_diff - 1];
                // //             // console.log(arrDiffs, i_diff);
                // //             //console.log(currentDiff, arrDiffs);
                // //         }
                // //     }
                // // }
                // var arrAllRecords = xtag.query(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr');
                // //console.log(newNumber, currentNumber);
                // //console.log(arrOrigins);
                // //console.log(handle.hasAttribute('selected') || handle.hasAttribute('selected-secondary'));
                // if (handle.hasAttribute('selected') || handle.hasAttribute('selected-secondary')) {
                //     if (arrOrigins.length === 1) {
                //         currentNumber = arrAllRecords.length;
                //     } else {
                //         if (newNumber > currentNumber) {
                //             if (arrOrigins[arrOrigins.indexOf(currentNumber) + 1]) {
                //                 currentNumber = arrOrigins[arrOrigins.indexOf(currentNumber) + 1] - 1;
                //             } else {
                //                 currentNumber = arrOrigins[arrOrigins.indexOf(currentNumber)];
                //             }
                //         } else {
                //             if (arrOrigins[arrOrigins.indexOf(currentNumber) - 1]) {
                //                 currentNumber = arrOrigins[arrOrigins.indexOf(currentNumber) - 1] - 1;
                //             } else {
                //                 currentNumber = arrOrigins[arrOrigins.indexOf(currentNumber)];
                //             }
                //         }
                //     }
                //     // console.log(newNumber, currentNumber);
                //     if (newNumber < currentNumber) {
                //         for (var i = newNumber - 1, len = currentNumber; i < len; i++) {
                //             arrAllRecords[i].removeAttribute('selected', '');
                //             arrAllRecords[i].classList.remove('originTR');
                //             //console.log(arrAllRecords[i]);
                //         }
                //     } else {
                //         for (var i = currentNumber, len = newNumber; i < len; i++) {
                //             arrAllRecords[i].removeAttribute('selected', '');
                //             arrAllRecords[i].classList.remove('originTR');
                //             //console.log(arrAllRecords[i]);
                //         }
                //     }

                // } else {
                //     if (newNumber < currentNumber) {
                //         for (var i = newNumber - 1, len = currentNumber; i < len; i++) {
                //             arrAllRecords[i].setAttribute('selected-secondary', '');
                //             //console.log(arrAllRecords[i]);
                //         }
                //     } else {
                //         for (var i = currentNumber, len = newNumber; i < len; i++) {
                //             arrAllRecords[i].setAttribute('selected-secondary', '');
                //             //console.log(arrAllRecords[i]);
                //         }
                //     }
                //     handle.classList.add('originTR');
                // }

            } else if (strType === 'down') {
                element.originTR = record[0];
                //console.log(arrSelectedRecords);//handle, handle.hasAttribute('selected'));
                if (bolAdd && handle.hasAttribute('selected') && arrSelectedRecords.length > 1) {
                    handle.removeAttribute('selected');
                    if (handle.classList.contains('originTR')) {
                        handle.classList.remove('originTR');
                    }
                } else {
                    element.originTR.setAttribute('selected-secondary', '');
                }
            } else if (strType === 'move' && !bolShift) {
                var arrSelectedTrs = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected-secondary]');

                // if (element.tableElement && xtag.queryChildren(element.tableElement, 'tbody')[0]) {
                //     // clear previous selection
                //     k
                //     for (i = 0, len = arrSelectedTrs.length; i < len; i += 1) {
                //         arrSelectedTrs[i].removeAttribute('selected-secondary');
                //     }
                // }

                var arrRecords = xtag.query(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr');
                var i, len, arrRecordsToAffect =
                    arrRecords.slice(Math.min(element.originTR.getAttribute('data-record_no')
                                        , record[0].getAttribute('data-record_no')) - 1
                                    , Math.max(element.originTR.getAttribute('data-record_no')
                                        , record[0].getAttribute('data-record_no')));

                for (i = 0, len = arrRecordsToAffect.length; i < len; i += 1) {
                    arrRecordsToAffect[i].setAttribute('selected-secondary', '');
                }

                //console.log('origin: ', element.originTR.rowIndex);
                //console.log('destination: ', record[0].rowIndex);
                //console.log('arrRecordsToAffect', arrRecordsToAffect);
                //console.log('arrRecordsToAffect.length', arrRecordsToAffect.length);
                //console.log('record', record);
            } else if (strType === 'up') {
                if (element.tableElement && xtag.queryChildren(element.tableElement, 'tbody')[0]) {
                    // clear previous selection
                    arrSelectedTrs = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected-secondary]');

                    for (i = 0, len = arrSelectedTrs.length; i < len; i += 1) {
                        arrSelectedTrs[i].removeAttribute('selected-secondary');
                        arrSelectedTrs[i].setAttribute('selected', '');
                    }
                }
                if (record[0]) {
                    //console.trace('triggerchange 1');
                    element.triggerChange();
                }
            } else if (record) {
                // highlightRecord has its own checking for no record supplied,
                // so this deselects any rows then selects the supplied record or none
                if (element.hasAttribute('multi-select')) {
                    for (i = 0, len = record.length; i < len; i += 1) {
                        record[i].setAttribute('selected', '');
                    }
                } else {
                    record.setAttribute('selected', '');
                }
                //highlightRecord(element, record);
                //console.trace('triggerchange 2');
                element.triggerChange();
            }

            if (element.originTR) {
                element.originTR.classList.add('originTR');
            }

            //Save last clicked tr no for Shift-selecting
            if (typeof handle === 'object' && handle.tagName && strType === 'down') {
                //console.log(typeof handle, handle);
                if (element.lastClicked) {
                    element.secondLastClicked = element.lastClicked;
                }
                element.lastClicked = parseInt(handle.getAttribute('data-record_no'), 10);
            }
            // console.log(record, 'record');
            //console.log('3***', element.selectedRecord, element.value);
        }
    }


    // #################################################################
    // ########################## USER EVENTS ##########################
    // #################################################################

    // handle behaviours on keydown
    function handleKeyDown(event) {
        var element = event.target.parentNode, intKeyCode = event.keyCode || event.which, selectedTr, trs, i, len, selectedRecordIndex;

        if (!element.hasAttribute('disabled')) {
            if (!element.hasAttribute('no-select')) {
                if ((intKeyCode === 40 || intKeyCode === 38) && (!event.shiftKey) && !event.metaKey && !event.ctrlKey && !element.error) {
                    //console.log(element.parentNode);
                    trs = xtag.query(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr:not(.divider)');

                    for (i = 0, len = trs.length; i < len; i += 1) {
                        if (trs[i].hasAttribute('selected')) {
                            selectedRecordIndex = i;
                            selectedTr = trs[i];
                            trs[i].removeAttribute('selected');

                            break;
                        }
                    }

                    if (intKeyCode === 40) {// next record or circle to first record or start selection at the first
                        if (!selectedTr || selectedRecordIndex === trs.length - 1) {
                            highlightRecord(element, trs[0]);
                            selectedTr = trs[0];

                        } else {
                            highlightRecord(element, trs[selectedRecordIndex + 1]);
                            selectedTr = trs[selectedRecordIndex + 1];
                        }

                    } else if (intKeyCode === 38) {// prev record or circle to last record or start selection at the last
                        if (!selectedTr || selectedRecordIndex === 0) {
                            highlightRecord(element, trs[trs.length - 1]);
                            selectedTr = trs[trs.length - 1];

                        } else {
                            highlightRecord(element, trs[selectedRecordIndex - 1]);
                            selectedTr = trs[selectedRecordIndex - 1];
                        }
                    }

                    //GS.scrollIntoView(selectedTr);
                    element.scrollToSelectedRecord();
                    event.preventDefault();
                    event.stopPropagation();

                } else if (event.keyCode === 13) {
                    selectedTr = xtag.query(xtag.query(element.tableElement, 'tbody')[0], 'tr[selected]')[0];

                    if (element.tableElement && selectedTr) {
                        selectRecord(element, selectedTr, true);
                    }
                }
            }
        } else {
            if (event.keyCode !== 9) {
                event.preventDefault();
                event.stopPropagation();
            }
        }

        //console.log('handleKeyDown', intKeyCode, event);
    }

    function handleFocusout(event) {
        //TODO: XLD
        /*
        var element = event.target, selectedTr;

        if (element.tableElement) {
            selectedTr = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected]')[0];

            if (selectedTr) {
                selectRecord(element, selectedTr, true);
            }
        }
        */
    }


    // #################################################################
    // ######################### DATA HANDLING #########################
    // #################################################################


    // handles fetching the data
    //      if bolInitalLoad === true then
    //          use: initialize query COALESCE TO source query
    //      else
    //          use: source query
    function getData(element, callback, bolInitalLoad, bolClearPrevious) {
        var strSrc     = GS.templateWithQuerystring(
                            (bolInitalLoad && element.getAttribute('initialize')
                                ? element.getAttribute('initialize')
                                : element.getAttribute('src')
                            )
                        )
          , srcParts   = strSrc[0] === '(' ? [strSrc, ''] : strSrc.split('.')
          , strSchema  = srcParts[0]
          , strObject  = srcParts[1]
          , strColumns = GS.templateWithQuerystring(element.getAttribute('cols') || '*').split(',').join('\t')
          , strWhere   = GS.templateWithQuerystring(element.getAttribute('where') || '')
          , strOrd     = GS.templateWithQuerystring(element.getAttribute('ord') || '')
          , strLimit   = GS.templateWithQuerystring(element.getAttribute('limit') || '')
          , strOffset  = GS.templateWithQuerystring(element.getAttribute('offset') || '')
          , response_i = 0, response_len = 0, arrTotalRecords = [];

        GS.addLoader(element, 'Loading...');
        GS.requestSelectFromSocket(GS.envSocket, strSchema, strObject, strColumns
                                 , strWhere, strOrd, strLimit, strOffset
                                 , function (data, error) {
            var arrRecords, arrCells, envData
              , i, len, cell_i, cell_len;

            //console.log(data);

            if (!error) {
                if (data.strMessage !== 'TRANSACTION COMPLETED') {
                    arrRecords = GS.trim(data.strMessage, '\n').split('\n');

                    for (i = 0, len = arrRecords.length; i < len; i += 1) {
                        arrCells = arrRecords[i].split('\t');

                        for (cell_i = 0, cell_len = arrCells.length; cell_i < cell_len; cell_i += 1) {
                            arrCells[cell_i] = arrCells[cell_i] === '\\N' ? null : GS.decodeFromTabDelimited(arrCells[cell_i]);
                        }

                        arrTotalRecords.push(arrCells);
                    }
                } else {
                    GS.removeLoader(element);
                    element.arrColumnNames = data.arrColumnNames;

                    envData = {'arr_column': element.arrColumnNames, 'dat': arrTotalRecords};

                    handleData(element, bolInitalLoad, envData);
                    GS.triggerEvent(element, 'after_select');
                    if (typeof callback === 'function') {
                        callback();
                    }
                }
            } else {
                handleData(element, bolInitalLoad, data, error);
                GS.removeLoader(element);
            }
        });
    }

    // handles data result from method function: getData
    //      success:  template
    //      error:    add error classes
    function handleData(element, bolInitalLoad, data, error) {
        var strTemplate, divElement, tableElement, theadElement, theadCellElements, tbodyElement, tbodyCellElements, lastRecordElement,
            recordElements, recordElement, currentCellLabelElement, template, i, len, arrHeaders = [], arrHide, intVisibleColumns, strHeaderCells, strRecordCells, jsnTemplate, strHTML;

        // clear any old error status
        element.classList.remove('error');
        element.setAttribute('title', '');

        //console.log(error, data, bolInitalLoad);

        // if there was no error
        if (!error) {
            element.error = false;

            if (element.tableTemplate) {// element.tableTemplateElement
                strTemplate = element.tableTemplate;// element.tableTemplateElement

            } else {
                // create an array of hidden column numbers
                arrHide = (element.getAttribute('hide') || '').split(/[\s]*,[\s]*/);

                // build up the header cells variable and the record cells variable
                for (i = 0, len = data.arr_column.length, strHeaderCells = '', strRecordCells = '', intVisibleColumns = 0; i < len; i += 1) {
                    // if this column is not hidden
                    if (arrHide.indexOf((i + 1) + '') === -1 && arrHide.indexOf(data.arr_column[i]) === -1) {
                        // append a new cell to each of the header cells and record cells variables
                        strHeaderCells += '<th gs-dynamic>' + encodeHTML(data.arr_column[i]) + '</th> ';
                        strRecordCells += '<td gs-dynamic>{{! row[\'' + data.arr_column[i] + '\'] }}</td> ';
                        intVisibleColumns += 1;
                    }
                }

                // put everything together
                strTemplate =   '<table gs-dynamic>';

                if (intVisibleColumns > 1) { // data.arr_column.length (didn't take into account hidden columns)
                    strTemplate +=  '<thead gs-dynamic>' +
                                        '<tr gs-dynamic>' +
                                            strHeaderCells +
                                        '</tr>' +
                                    '</thead>';
                }

                strTemplate +=      '<tbody gs-dynamic>' +
                                        '<tr data-record_no="{{! row.row_number }}" value="{{! row[\'' + data.arr_column[0] + '\'] }}" gs-dynamic>' +
                                            strRecordCells +
                                        '</tr>' +
                                    '</tbody>' +
                                '<table>';
            }

            divElement = document.createElement('div');
            divElement.innerHTML = strTemplate;

            tableElement = xtag.queryChildren(divElement, 'table')[0];
            theadElement = xtag.queryChildren(tableElement, 'thead')[0];
            tbodyElement = xtag.queryChildren(tableElement, 'tbody')[0];

            // if there is a tbody
            if (tbodyElement) {
                recordElement = xtag.queryChildren(tbodyElement, 'tr')[0];

                // if there is a record: template
                if (recordElement) {

                    // if there is a thead element: add reflow cell headers to the tds
                    if (theadElement) {
                        theadCellElements = xtag.query(theadElement, 'td, th');
                        tbodyCellElements = xtag.query(tbodyElement, 'td, th');

                        for (i = 0, len = theadCellElements.length; i < len; i += 1) {
                            currentCellLabelElement = document.createElement('b');
                            currentCellLabelElement.classList.add('cell-label');
                            currentCellLabelElement.setAttribute('data-text', (theadCellElements[i].textContent || '') + ':');

                            if (tbodyCellElements[i].childNodes) {
                                tbodyCellElements[i].insertBefore(currentCellLabelElement, tbodyCellElements[i].childNodes[0]);
                            } else {
                                tbodyCellElements[i].insertChild(currentCellLabelElement);
                            }
                        }
                    }

                    // template
                    jsnTemplate = GS.templateHideSubTemplates(tbodyElement.innerHTML, true);
                    strHTML = GS.templateWithEnvelopeData(jsnTemplate.templateHTML, data);
                    tbodyElement.innerHTML = GS.templateShowSubTemplates(strHTML, jsnTemplate);

                    element.tableElement = tableElement;
                    element.syncView();
                    element.internalData.records = data;
                }
            }

            //console.log('1***', bolInitalLoad, element.getAttribute('value'));

            //if (bolInitalLoad && element.getAttribute('value')) {
            //    //console.log('2***', bolInitalLoad, element.getAttribute('value'));
            //    selectRecord(element, element.getAttribute('value'), false);
            //    element.scrollToSelectedRecord();
            //
            //// select first record
            //} else

            if (bolInitalLoad && !element.getAttribute('value') && element.hasAttribute('select-first')) {
                selectRecord(element, xtag.query(element, 'tbody tr')[0].getAttribute('value'), false);
                element.scrollToSelectedRecord();
            }

        // else there was an error: add error class, title attribute
        } else {
            element.error = true;
            element.classList.add('error');
            element.setAttribute('title', 'This listbox has failed to load.');

            element.setAttribute('disabled', '');

            GS.ajaxErrorDialog(data);
        }
    }

    function getParentCell(element) {
        var currentElement = element;

        while (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH' && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }

        if (currentElement.nodeName !== 'TD' && currentElement.nodeName !== 'TH') {
            return undefined;
        }

        return currentElement;
    }

    function windowResizeHandler() {
        var i, len, arrElement;

        arrElement = document.getElementsByTagName('gs-listbox');

        for (i = 0, len = arrElement.length; i < len; i += 1) {
            if (GS.pxToEm(document.body, this.oldWidth) !== GS.pxToEm(document.body, this.offsetWidth) && // <== if the width (in ems) changes
                arrElement[i].hasAttribute('letter-scrollbar') &&
                arrElement[i].tableElement) {

                if (arrElement[i].hasAttribute('letter-dividers') || arrElement[i].hasAttribute('letter-scrollbar')) {
                    arrElement[i].refreshDividingPoints();
                }
                arrElement[i].letterScrollbarHandler();
                this.oldWidth = this.offsetWidth;
            }
        }
    }

    window.addEventListener('resize', windowResizeHandler);  // I want to debounce this event but that would require a timer -michael
    window.addEventListener('orientationchange', windowResizeHandler);

    //function pushReplacePopHandler(element) {
    //    var i, len, currentValue, bolRefresh = false, strQueryString = GS.getQueryString(), arrPopKeys, strQSCol = element.getAttribute('qs');
    //
    //    if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1 && element.value !== GS.qryGetVal(strQueryString, strQSCol)) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //
    //    // if this element has a refresh-on-querystring-values attribute: check for changes
    //    if (element.hasAttribute('refresh-on-querystring-values')) {
    //        arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
    //
    //        for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
    //            currentValue = GS.qryGetVal(strQueryString, arrPopKeys[i]);
    //
    //            if ((element.popValues[arrPopKeys[i]] || '') !== currentValue) {
    //                bolRefresh = true;
    //            }
    //
    //            element.popValues[arrPopKeys[i]] = currentValue;
    //        }
    //
    //    } else if (element.hasAttribute('refresh-on-querystring-change')) {
    //        bolRefresh = true;
    //    }
    //
    //    if (bolRefresh) {
    //        element.refresh();
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var arrPopKeys;
        var currentValue;
        var bolRefresh;
        var strOperator;

        element.supressChange = false;

        if (strQSCol) {
            if (strQSCol.indexOf('=') !== -1) {
                arrAttrParts = strQSCol.split(',');
                i = 0;
                len = arrAttrParts.length;
                while (i < len) {
                    strQSCol = arrAttrParts[i];

                    if (strQSCol.indexOf('!=') !== -1) {
                        strOperator = '!=';
                        arrQSParts = strQSCol.split('!=');
                    } else {
                        strOperator = '=';
                        arrQSParts = strQSCol.split('=');
                    }

                    strQSCol = arrQSParts[0];
                    strQSAttr = arrQSParts[1] || arrQSParts[0];

                    // if the key is not present or we've got the negator: go to the attribute's default or remove it
                    if (strOperator === '!=') {
                        // if the key is not present: add the attribute
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            element.setAttribute(strQSAttr, '');
                        // else: remove the attribute
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    } else {
                        // if the key is not present: go to the attribute's default or remove it
                        if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                            if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                                element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                            } else {
                                element.removeAttribute(strQSAttr);
                            }
                        // else: set attribute to exact text from QS
                        } else {
                            element.setAttribute(strQSAttr, (
                                GS.qryGetVal(strQS, strQSCol) ||
                                element.internal.defaultAttributes[strQSAttr] ||
                                ''
                            ));
                        }
                    }
                    i += 1;
                }
            } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
                strQSValue = GS.qryGetVal(strQS, strQSCol);

                if (element.internal.bolQSFirstRun !== true) {
                    if (strQSValue !== '' || !element.getAttribute('value')) {
                        element.supressChange = true;
                        element.setAttribute('value', strQSValue);
                    }
                } else if (element.value !== strQSValue) {
                    element.value = strQSValue;
                }
            }
        }

        // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
        if (element.internal.bolQSFirstRun === true) {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);

                    if (element.popValues[arrPopKeys[i]] !== currentValue) {
                        bolRefresh = true;
                    }

                    element.popValues[arrPopKeys[i]] = currentValue;
                }
            } else if (element.hasAttribute('refresh-on-querystring-change')) {
                bolRefresh = true;
            }

            if (bolRefresh && element.hasAttribute('src')) {
                getData(element);
            } else if (bolRefresh && !element.hasAttribute('src')) {
                console.warn('gs-combo Warning: element has "refresh-on-querystring-values" or "refresh-on-querystring-change", but no "src".', element);
            }
        } else {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                }
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value && !element.getAttribute('value')) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = null;
            }
        }
    }

    // ############# COPY EVENTS #############
    function unbindCopy(element) {
        element.removeEventListener(
            'copy',
            element.copySelection
        );
    }
    function bindCopy(element) {
        // console.log('running1');
        element.copySelection = function (event) {
            // console.log('running2');
            var jsnCopyString = {};
            var focusedElement;

            // saving the currently focused element for easy/quick access
            focusedElement = document.activeElement;

            // if the focus is on the hidden focus control of if the text
            //      selection of the currently focused element is not
            //      selecting multiple characters
            if (
                focusedElement.classList.contains('hidden-focus-control') ||
                focusedElement.selectionStart === focusedElement.selectionEnd
            ) {
                console.time('copy');

                // focus the hidden focus control and select all of it's text so
                //      that Firefox will allow us to override the clipboard
                focusedElement = element.hiddenFocusControl;
                focusedElement.focus();

                GS.setInputSelection(
                    focusedElement,
                    0,
                    focusedElement.value.length
                );

                jsnCopyString.text = '';
                jsnCopyString.html = '';

                // we want to override the text and HTML mime type clipboards,
                //      so we get the copy text for both types
                var selectedRecords = element.selectedRecord;
                if (selectedRecords[0]) {
                    for (var i = 0, len = selectedRecords.length; i < len; i++) {
                        if (i < 1) {
                            jsnCopyString.text += selectedRecords[i].innerText;
                            //jsnCopyString.html += selectedRecords[i].innerHTML;
                        } else {
                            jsnCopyString.text += '\n' + selectedRecords[i].innerText;
                            //jsnCopyString.html += '\n' + selectedRecords[i].innerHTML;
                        }
                    }
                //not multi-select
                } else {
                    jsnCopyString.text = selectedRecords.innerText;
                    //jsnCopyString.html = selectedRecords.innerHTML;
                    // console.log(selectedRecords);
                }
                // console.log(jsnCopyString);
                //jsnCopyString = getCopyStrings(element);

                // override clipboard (prevent event default if we are
                //      successful)
                if (handleClipboardData(event, jsnCopyString.text, 'text')) {
                    event.preventDefault(event);
                }
                // if (handleClipboardData(event, jsnCopyString.html, 'html')) {
                //     event.preventDefault(event);
                // }


                console.timeEnd('copy');
            }
        };

        element.hiddenFocusControl.addEventListener(
            'copy',
            element.copySelection
        );
    }

    function handleClipboardData(event, strCopyString, strType) {
        var clipboardData = event.clipboardData || window.clipboardData;
        var strMime;

        if (!clipboardData) {
            return;
        }
        if (!clipboardData.setData) {
            return;
        }

        if (strType === 'text') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = 'Text';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/plain';
            }
        } else if (strType === 'html') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = '';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/html';
            }
        } else {
            throw 'handleClipboardData Error: Type "' + strType + '" not ' +
                    'recognized, recognized types are "text" and "html".';
        }

        if (strMime) {
            if (strCopyString && strMime) {
                return clipboardData.setData(strMime, strCopyString) !== false;
            } else {
                return clipboardData.getData(strMime);
            }
        }
    }

    //
    function elementInserted(element) {
        var tableTemplateElement, arrElement, recordElement, tableTemplateElementCopy, strQSValue, i, len, currentElement;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.error = false;
                element.internal = {};
                element.internalData = {};
                saveDefaultAttributes(element);
                // handle "qs" attribute
                if (element.hasAttribute('qs') ||
                        element.hasAttribute('refresh-on-querystring-values') ||
                        element.hasAttribute('refresh-on-querystring-change')) {
                    element.popValues = {};
                    //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.setAttribute('value', strQSValue);
                    //}

                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                    //element.popValues = GS.qryToJSON(GS.getQueryString());
                }

                // allows the element to have focus
                if (!element.hasAttribute('tabindex')) {
                    element.setAttribute('tabindex', '0');
                }

                element.skipFocus = false;

                // select for template
                tableTemplateElement = xtag.queryChildren(element, 'template')[0];
                if (tableTemplateElement && (tableTemplateElement.innerHTML.indexOf('&gt;') > -1 || tableTemplateElement.innerHTML.indexOf('&lt;') > -1)) {
                    console.warn('GS-LISTBOX WARNING: &gt; or &lt; detected in table template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                }


                if (element.getAttribute('src') || element.getAttribute('source')) {
                    if (element.innerHTML.trim() !== '') {
                        var trSet = xtag.query(tableTemplateElement.content, 'tbody > tr');//:not(.divider)');
                        //console.log(trSet);
                        for (var i = 0, len = trSet.length; i < len; i++) {
                            trSet[i].setAttribute('data-record_no', '{{! row.row_number }}');
                            // console.log(trSet[i]);
                        }
                    }
                }

                if (tableTemplateElement) {
                    // add a doT.js coded "value" attribute to any element with a "column" attribute but no "value" attribute
                    element.tableTemplate = GS.templateColumnToValue(tableTemplateElement.innerHTML);
                }

                if (element.getAttribute('src') || element.getAttribute('source')) {
                    // if (element.innerHTML.trim() !== '') {
                    //     var trSet = xtag.query(tableTemplateElement.content, 'tbody > tr');//:not(.divider)');
                    //     //console.log(trSet);
                    //     for (var i = 0, len = trSet.length; i < len; i++) {
                    //         trSet[i].setAttribute('data-record_no', '{{! row.row_number }}');
                    //         // console.log(trSet[i]);
                    //     }
                    // }
                    getData(element, '', true);
                } else {
                    if (tableTemplateElement) {
                        //developer provided template
                        element.tableElement = xtag.query(tableTemplateElement.content, 'table')[0];
                    } else if (xtag.queryChildren(element, 'table')[0]) {
                        element.tableElement = xtag.queryChildren(element, 'table')[0];
                    } else {
                        element.tableElement = document.createElement('table');
                    }
                    //loop through and add the data-record_no attribute
                    //console.log(element.innerHTML);
                    var trSet = xtag.query(tableTemplateElement.content, 'tr');//:not(.divider)');
                    //console.log(trSet);
                    for (var i = 0, len = trSet.length; i < len; i++) {
                        //console.log(trSet[i]);
                        trSet[i].setAttribute('data-record_no', i);
                    }
                    element.syncView();
                }
            }
        }
    }

    xtag.register('gs-listbox', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value' && newValue !== oldValue) {
                        this.value = newValue;
                    }
                }
            }
        },
        events: {},
        accessors: {
            value: {
                get: function () {
                    var element = this;
                    if (element.tableElement) {
                        var arrRecords = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected]');//:not(.divider)
                        //console.log(arrRecords);
                        if (this.hasAttribute('multi-select')) {
                            var arrResult = [], i;
                            for (i = 0; i < arrRecords.length; i++) {
                                if (this.internalData.records.dat[arrRecords[i].getAttribute('data-record_no') - 1]) {
                                    arrResult.push(this.internalData.records.dat[arrRecords[i].getAttribute('data-record_no') - 1][0]);
                                }
                            }
                            return arrResult;
                        } else {
                            // console.trace('sonofagun');
                            if (arrRecords.length > 0) {
                                // console.log(arrRecords);
                                // console.log('test1', arrRecords[0].rowIndex);
                                // console.log('test2', this.internalData.records.dat[arrRecords[0].rowIndex]);
                                if (this.internalData.records.dat[arrRecords[0].getAttribute('data-record_no') - 1]) {
                                    return this.internalData.records.dat[arrRecords[0].getAttribute('data-record_no') - 1][0];
                                }
                            }
                        }
                    }
                },

                set: function (strNewValue) {
                    selectRecord(this, strNewValue);
                    this.scrollToSelectedRecord();
                }
            },

            selectedRecord: {
                get: function () {
                    var element = this;
                    if (element.tableElement) {
                        var arrRecords = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected]');
                        //console.log('arrRecords', arrRecords);
                        if (this.hasAttribute('multi-select')) {
                            return arrRecords;
                        } else {
                            return arrRecords[0];
                        }
                    }
                },

                set: function (newValue) {
                    selectRecord(this, newValue);
                    this.scrollToSelectedRecord();
                }
            },

            textValue: {
                get: function () {
                    var element = this;
                    if (element.tableElement) {
                        var arrRecords = xtag.queryChildren(xtag.queryChildren(element.tableElement, 'tbody')[0], 'tr[selected]');

                        if (this.hasAttribute('multi-select')) {
                            var strResult, i;
                            for (i = 0; i < arrRecords.length; i++) {
                                // console.log(arrRecords, i, xtag.queryChildren(arrRecords[i], 'td'));
                                if (xtag.queryChildren(arrRecords[i], 'td').length > 0) {
                                    strResult += xtag.queryChildren(arrRecords[i], 'td')[0].textContent;
                                }
                            }
                            return strResult;
                        } else {
                            return arrRecords[0].textContent;
                        }
                    }
                },

                set: function () {
                    selectRecord(this, strNewValue);
                    this.scrollToSelectedRecord();
                }
            }
        },
        methods: {
            // just a semantic alias to the getData function
            refresh: function (callback) {
                getData(this, callback);
            },

            column: function (strColumn) {
                //console.log('no', Number(this.innerSelectedRecord.rowIndex) - 1);
                //console.log('data', this.internalData.records);
                //console.log('return', this.internalData.records.dat[Number(this.innerSelectedRecord.rowIndex) - 1]);
                var element = this;
                if (this.hasAttribute('multi-select')) {
                    var arrStrResult = [], i;
                    for (i = 0; i < this.selectedRecord.length; i++) {
                        arrStrResult.push(this.internalData.records.dat[this.selectedRecord[i].rowIndex - 1][this.internalData.records.arr_column.indexOf(strColumn)]);
                    }
                    //console.log('this.selectedRecord', this.selectedRecord);
                    //console.log('arrStrResult', arrStrResult);
                    return arrStrResult;
                } else {
                    return this.internalData.records.dat[this.selectedRecord.rowIndex - 1][this.internalData.records.arr_column.indexOf(strColumn)];
                }
            },

            // #################################################################
            // ########### SELECTION / HIGHLIGHTING / RECORD / VALUE ###########
            // #################################################################

            // scroll the dropdown to the selected record
            scrollToSelectedRecord: function () {
                var selectedTr;

                if (this.tableElement) {
                    selectedTr = xtag.query(this.tableElement, 'tr[selected]')[0];

                    if (selectedTr) {
                        GS.scrollIntoView(selectedTr);
                    }
                }

                /*var scrollingContainer, arrTrs, i, len, intScrollTop, bolFoundSelected = false;

                if (this.tableElement) {
                    scrollingContainer = this;
                    arrTrs = xtag.query(this.tableElement, 'tr');

                    for (i = 0, intScrollTop = 0, len = arrTrs.length; i < len; i += 1) {
                        if (arrTrs[i].hasAttribute('selected')) {
                            intScrollTop += arrTrs[i].offsetHeight / 2;

                            bolFoundSelected = true;

                            break;
                        } else {
                            intScrollTop += arrTrs[i].offsetHeight;
                        }
                    }

                    if (bolFoundSelected) {
                        intScrollTop = intScrollTop - scrollingContainer.offsetHeight / 2;
                    } else {
                        intScrollTop = 0;
                    }

                    scrollingContainer.scrollTop = intScrollTop;
                }*/
            },

            // ################################################################
            // ####################### LETTER SCROLLBAR #######################
            // ################################################################

            letterScrollbarHandler: function () {
                var element = this, i, len, intTextHeight, intLettersDropped, intSkipperHeight,
                    intElementHeight, intDistance, strHTML, arrSkippers;

                // if there is no letter scrollbar container: create it
                if (xtag.queryChildren(element, '.letter-scrollbar-container').length === 0) {
                    element.letterScrollbarContainer = document.createElement('div');
                    element.letterScrollbarContainer.classList.add('letter-scrollbar-container');
                    element.letterScrollbarContainer.setAttribute('gs-dynamic', '');
                    element.appendChild(element.letterScrollbarContainer);

                // else: clear out the old letterScrollbarContainer
                } else {
                    element.letterScrollbarContainer.innerHTML = '';
                }

                if (element.clientHeight < element.scrollContainer.scrollHeight) {
                    intTextHeight = GS.getTextHeight(element.letterScrollbarContainer);
                    intSkipperHeight = intTextHeight * this.arrDividingPoints.length;
                    intElementHeight = element.clientHeight / this.arrDividingPoints.length;

                    if (intElementHeight < intTextHeight) {
                        intElementHeight = intTextHeight;
                    }

                    if (intSkipperHeight > element.clientHeight) {
                        intLettersDropped = 0;
                        while (intSkipperHeight > element.clientHeight && intLettersDropped < 100) {
                            intSkipperHeight -= intTextHeight;
                            intLettersDropped += 1;
                        }
                        intDistance = Math.ceil(this.arrDividingPoints.length / intLettersDropped);
                    }

                    for (i = 0, len = this.arrDividingPoints.length, strHTML = ''; i < len; i += 1) {
                        if (intLettersDropped === undefined || (intLettersDropped > 0 && i % intDistance !== 0)) {
                            strHTML += '<div class="skipper" gs-dynamic ' +
                                            'style="height: ' + intElementHeight + 'px; line-height: ' + intElementHeight + 'px;" ' +
                                            'data-target-offset="' + this.arrDividingPoints[i].offset + '">' +
                                            '<span gs-dynamic>' + this.arrDividingPoints[i].letter + '</span>' +
                                        '</div>';
                        }
                    }

                    element.letterScrollbarContainer.innerHTML = strHTML;

                    if (element.paddingElement && element.paddingElement.parentNode === element.scrollContainer) {
                        element.scrollContainer.removeChild(element.paddingElement);
                    }

                    element.paddingElement = document.createElement('div');
                    element.paddingElement.setAttribute('gs-dynamic', '');
                    if (this.arrDividingPoints.length > 0) {
                    element.paddingElement.style.height = (element.clientHeight -
                                                        (element.scrollContainer.scrollHeight - parseInt(this.arrDividingPoints[this.arrDividingPoints.length - 1].offset, 10))) + 'px';
                    }
                    element.scrollContainer.appendChild(element.paddingElement);

                    // bind skipper click, mousedown-then-drag
                    arrSkippers = element.letterScrollbarContainer.children;

                    if (element.mousedownHandler) {
                        window.removeEventListener(evt.mousedown, element.mousedownHandler);
                        window.removeEventListener(evt.mousemove, element.mousemoveHandler);
                        window.removeEventListener(evt.mouseup, element.mouseupHandler);
                    }

                    //element.clickHandler = function () {
                    //    //console.log('-webkit-overflow-scrolling: touch;',   element.scrollContainer.scrollTop);
                    //    element.style.webkitOverflowScrolling = 'initial';
                    //    //console.log('-webkit-overflow-scrolling: initial;', element.scrollContainer.scrollTop);
                    //    element.scrollContainer.scrollTop = parseInt(this.getAttribute('data-target-offset'), 10);
                    //    //console.log('-webkit-overflow-scrolling: initial;', element.scrollContainer.scrollTop);
                    //    element.style.webkitOverflowScrolling = 'touch';

                    element.clickHandler = function () {
                        //console.log('-webkit-overflow-scrolling: touch;',   element.scrollContainer.scrollTop);
                        element.style.webkitOverflowScrolling = 'initial';
                        //console.log('-webkit-overflow-scrolling: initial;', element.scrollContainer.scrollTop);
                        element.scrollContainer.scrollTop = parseInt(this.getAttribute('data-target-offset'), 10);
                        //console.log('-webkit-overflow-scrolling: initial;', element.scrollContainer.scrollTop);
                        element.style.webkitOverflowScrolling = 'touch';

                        //alert('Here I am');

                        //element.scrollContainer.className = element.scrollContainer.className;
                        //element.scrollContainer.style.outline = '1px solid #000000';
                        //element.scrollContainer.style.outline = '';
                        //console.log('-webkit-overflow-scrolling: touch;',   element.scrollContainer.scrollTop);
                        //console.log('test');
                    };
                    element.mousedownHandler = function (event) { // event
                        window.addEventListener(evt.mousemove, element.mousemoveHandler);
                        if (event.target.classList.contains('skipper') && evt.touchDevice) {
                            element.style.webkitOverflowScrolling = 'initial';
                        }
                        //element.mousemoveHandler(event);
                    };
                    element.mousemoveHandler = function (event) {
                        var jsnMousePosition, targetElement;

                        if (event.which !== 0 || evt.touchDevice) {
                            jsnMousePosition = GS.mousePosition(event);
                            targetElement = document.elementFromPoint(jsnMousePosition.left, jsnMousePosition.top);

                            if (targetElement) {
                                if (targetElement.nodeName === 'SPAN') {
                                    targetElement = targetElement.parentNode;
                                }

                                //console.log(targetElement, jsnMousePosition);

                                if (targetElement.classList.contains('skipper')) {
                                    element.style.webkitOverflowScrolling = 'initial';
                                    event.preventDefault();
                                    element.scrollContainer.scrollTop = parseInt(targetElement.getAttribute('data-target-offset'), 10);
                                }
                            }
                        } else {
                            window.removeEventListener(evt.mousemove, element.mousemoveHandler);
                        }
                    };
                    element.mouseupHandler = function () {
                        element.style.webkitOverflowScrolling = 'touch';
                        window.removeEventListener(evt.mousemove, element.mousemoveHandler);
                    };

                    //window
                    element.addEventListener(evt.mousedown, element.mousedownHandler);
                    //window
                    element.addEventListener(evt.mouseup, element.mouseupHandler);

                    for (i = 0, len = arrSkippers.length; i < len; i += 1) {
                        arrSkippers[i].addEventListener('click', element.clickHandler);
                    }
                    //}
                }
            },


            // #################################################################
            // ########################### UTILITIES ###########################
            // #################################################################

            refreshDividingPoints: function () {
                var tbodyElement, arrElement, arrLetter, dividerElement, strLetter, intOffset, numColumns, theadElement, i, len;

                tbodyElement = xtag.queryChildren(this.tableElement, 'tbody')[0];

                arrElement = xtag.queryChildren(tbodyElement, 'tr.divider');

                for (i = 0, len = arrElement.length; i < len; i += 1) {
                    tbodyElement.removeChild(arrElement[i]);
                }

                this.arrDividingPoints = [];

                arrElement = xtag.queryChildren(tbodyElement, 'tr');

                if (arrElement.length > 0) {
                    numColumns = arrElement[0].children.length;


                    //console.log(theadElement, (theadElement ? theadElement.offsetHeight : 0));
                    theadElement = xtag.queryChildren(this.tableElement, 'thead')[0];
                    intOffset = (theadElement ? theadElement.offsetHeight : 0);

                    for (i = 0, len = arrElement.length, arrLetter = []; i < len; i += 1) {
                        strLetter = xtag.queryChildren(arrElement[i], 'td')[0].textContent.substring(0, 1).toUpperCase();

                        if (arrLetter.indexOf(strLetter) === -1) {
                            this.arrDividingPoints.push({
                                'letter': strLetter,
                                'offset': intOffset
                            });

                            if (this.hasAttribute('letter-dividers')) {
                                dividerElement = document.createElement('tr');
                                dividerElement.classList.add('divider');
                                dividerElement.setAttribute('gs-dynamic', '');
                                dividerElement.setAttribute('data-target-offset', intOffset);
                                //if (!this.hasAttribute('letter-dividers')) { <== messed with odd and even record colors when letter-scrollbar but not letter-dividers -michael
                                //    dividerElement.setAttribute('hidden', '');
                                //}

                                dividerElement.innerHTML = '<td colspan="' + numColumns + '" gs-dynamic>' + encodeHTML(strLetter) + '</td>';

                                tbodyElement.insertBefore(dividerElement, arrElement[i]);

                                intOffset += dividerElement.offsetHeight;
                            }

                            arrLetter.push(strLetter);
                        }

                        intOffset += arrElement[i].offsetHeight;
                    }
                }
            },

            syncView: function () {
                var element = this, tbodyElement, i, len, arrElements, clickHandler, mousedownHandler, mousemoveHandler, mouseupHandler, mouseoutHandler, mouseoverHandler;

                element.removeEventListener('keydown', handleKeyDown);
                element.addEventListener('keydown', handleKeyDown);

                element.removeEventListener('focusout', handleFocusout);
                element.addEventListener('focusout', handleFocusout);

                element.innerHTML = '';

                element.scrollContainer = document.createElement('div');
                element.scrollContainer.setAttribute('gs-dynamic', '');
                element.scrollContainer.classList.add('root');
                element.scrollContainer.classList.add('scroll-container');
                element.scrollContainer.appendChild(element.tableElement);

                element.appendChild(element.scrollContainer);
                tbodyElement = xtag.queryChildren(element.tableElement, 'tbody')[0];

                // add dividers
                if (element.hasAttribute('letter-dividers') || element.hasAttribute('letter-scrollbar')) {
                    element.refreshDividingPoints();

                    // if we have the letter-scrollbar attribute: add the letter scrollbar
                    if (element.hasAttribute('letter-scrollbar')) {
                        element.letterScrollbarHandler();
                    }
                }

                // this fixes the fact that this function was clearing the selection
                if (this.getAttribute('value')) {
                    selectRecord(this, this.getAttribute('value'));
                    this.scrollToSelectedRecord();
                }

                // click handling code
                // get list of record elements
                arrElements = xtag.toArray(tbodyElement.children);

                if (element.hasAttribute('multi-select')) {
                    // if we are not on a touch device: hover and down events
                    if (!evt.touchDevice) {
                        var mouseIsDown = false;
                        mousedownHandler = function (event) {
                            mouseIsDown = true;
                            this.classList.add('down');
                            element.addEventListener(evt.mousemove, mousemoveHandler);
                            window.addEventListener(evt.mouseup, mouseupHandler);
                            selectRecord(element, this, true, (event.ctrlKey || event.metaKey), 'down', event.shiftKey);
                        };
                        mousemoveHandler = function (event) {
                            if (mouseIsDown) {
                                selectRecord(element, getTRFromTarget(event.target), true, (event.ctrlKey || event.metaKey), 'move', event.shiftKey);
                            }
                        };
                        mouseupHandler = function (event) {
                            mouseIsDown = false;
                            selectRecord(element, this, true, (event.ctrlKey || event.metaKey), 'up', event.shiftKey);
                            element.removeEventListener(evt.mousemove, mousemoveHandler);
                            window.removeEventListener(evt.mouseup, mouseupHandler);
                        };
                        mouseoutHandler = function () {
                            this.classList.remove('down');
                            this.classList.remove('hover');
                        };
                        mouseoverHandler = function () {
                            this.classList.remove('down');
                            this.classList.add('hover');
                        };

                        // add click event with click event function to all record elements that are not dividers
                        for (i = 0, len = arrElements.length; i < len; i += 1) {
                            if (!arrElements[i].classList.contains('divider')) {
                                arrElements[i].addEventListener(evt.mousedown, mousedownHandler);
                                arrElements[i].addEventListener(evt.mouseout, mouseoutHandler);
                                arrElements[i].addEventListener(evt.mouseover, mouseoverHandler);
                            }
                        }
                    } else {
                        //TODO: toggle
                        // create click event function
                        clickHandler = function (event) {
                            this.classList.remove('down');
                            selectRecord(element, this, true);
                        };
                    }
                } else {
                    // create click event function
                    clickHandler = function (event) {
                        this.classList.remove('down');
                        selectRecord(element, this, true);
                    };

                    // add click event with click event function to all record elements that are not dividers
                    for (i = 0, len = arrElements.length; i < len; i += 1) {
                        if (!arrElements[i].classList.contains('divider')) {
                            arrElements[i].addEventListener('click', clickHandler);
                        }
                    }

                    // if we are not on a touch device: hover and down events
                    if (!evt.touchDevice) {
                        mousedownHandler = function () {
                            this.classList.add('down');
                        };
                        mouseoutHandler = function () {
                            this.classList.remove('down');
                            this.classList.remove('hover');
                        };
                        mouseoverHandler = function () {
                            this.classList.remove('down');
                            this.classList.add('hover');
                        };

                        // add click event with click event function to all record elements that are not dividers
                        for (i = 0, len = arrElements.length; i < len; i += 1) {
                            if (!arrElements[i].classList.contains('divider')) {
                                arrElements[i].addEventListener(evt.mousedown, mousedownHandler);
                                arrElements[i].addEventListener(evt.mouseout, mouseoutHandler);
                                arrElements[i].addEventListener(evt.mouseover, mouseoverHandler);
                            }
                        }
                    }
                }

                //tbodyElement.addEventListener('click', function (event) {
                //    var parentRecord = GS.findParentTag(event.target, 'TR');
                //
                //    if (parentRecord && !parentRecord.classList.contains('divider')) {
                //        selectRecord(element, parentRecord, true);
                //    }
                //});
                var focusElement = document.createElement('textarea');
                focusElement.classList.add('hidden-focus-control');
                focusElement.setAttribute('value', 'text makes this textarea Firefox worthy');

                element.appendChild(focusElement);
                element.hiddenFocusControl = focusElement;

                element.addEventListener('focus', function (event) {
                    event.preventDefault();
                    event.stopPropagation
                    if (event.target !== element.hiddenFocusControl) {
                        element.hiddenFocusControl.focus();
                        GS.triggerEvent(element.hiddenFocusControl, 'focus');
                        // console.log(document.activeElement);
                        element.skipFocus = true;
                        // console.log(element.skipFocus);
                    }
                });
                bindCopy(element);
                //console.log(element.tableTemplate);


            },

            triggerChange: function () {
                if (this.supressChange === true) {
                    this.supressChange = false;
                } else {
                    xtag.fireEvent(this, 'change', {
                        bubbles: true,
                        cancelable: true
                    });
                }
            }
        }
    });
});//element.clientHeight < element.scrollHeight

window.addEventListener('design-register-element', function () {

    registerDesignSnippet('<gs-memo>', '<gs-memo>', 'gs-memo column="${1:name}"></gs-memo>');
    registerDesignSnippet('<gs-memo> With Label', '<gs-memo>', 'label for="${1:memo-insert-note}">${2:Notes}:</label>\n' +
                                                               '<gs-memo id="${1:memo-insert-note}" column="${3:note}"></gs-memo>');

    designRegisterElement('gs-memo', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-memo.html');

    window.designElementProperty_GSMEMO = function(selectedElement) {
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Rows', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('rows') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'rows', this.value);
        });

        addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
        });

        //console.log(selectedElement.hasAttribute('mini'));

        addProp('Autoresize', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('autoresize')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'autoresize', (this.value === 'true'), true);
        });

        addProp('Allow tab', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('allow-tab-char')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'allow-tab-char', (this.value === 'true'), true);
        });

        addProp('Resize Handle', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-resize-handle')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-resize-handle', (this.value === 'true'), false);
        });

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });

        addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
        });

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

// trigger resize to text on window resize
window.addEventListener('resize', function () {
    var i, len, arrElements = document.getElementsByTagName('gs-memo');

    for (i = 0, len = arrElements.length; i < len; i += 1) {
        //if (arrElements[i].control.clientHeight < arrElements[i].control.scrollHeight) {
        arrElements[i].handleResizeToText();
        //}
    }
});


if (!evt.touchDevice) {
    window.gsMemo = {};
    window.gsMemo.bolFirstMouseMoveWhileDown = true;
    window.gsMemo.currentMouseTarget = null;

    window.addEventListener('mousemove', function (event) {
        var mousePosition, intWhich;// = GS.mousePosition(event);

        // firefox sometimes doesn't permit access to "event.which"
        //      so this try/catch statement will prevent the error and nothing will run
        try {
            intWhich = event.which;
        } catch (e) {}

        if (window.bolFirstMouseMoveWhileDown === true && intWhich !== undefined && intWhich !== 0) {
            mousePosition = GS.mousePosition(event);

            window.bolFirstMouseMoveWhileDown = false;
            window.gsMemo.currentMouseTarget = document.elementFromPoint(mousePosition.x, mousePosition.y);

        } else if (intWhich !== undefined && intWhich === 0) {
            window.bolFirstMouseMoveWhileDown = true;
        }

        if (window.gsMemo.currentMouseTarget &&
            intWhich !== undefined && intWhich !== 0 &&
            window.gsMemo.currentMouseTarget.nodeName === 'TEXTAREA' &&
            window.gsMemo.currentMouseTarget.parentNode.nodeName === 'GS-MEMO' && //event.target === element.control &&
            window.bolFirstMouseMoveWhileDown === false &&
                (window.gsMemo.currentMouseTarget.lastWidth !== window.gsMemo.currentMouseTarget.clientWidth ||
                window.gsMemo.currentMouseTarget.lastHeight !== window.gsMemo.currentMouseTarget.clientHeight)) {// && //element.control === window.lastMouseDownElement) {

            //GS.triggerEvent(window.gsMemo.currentMouseTarget.parentNode, 'size-changed');

            window.gsMemo.currentMouseTarget.style.margin = '';
            window.gsMemo.currentMouseTarget.style.marginLeft = '';
            window.gsMemo.currentMouseTarget.style.marginRight = '';
            window.gsMemo.currentMouseTarget.style.marginTop = '';
            window.gsMemo.currentMouseTarget.style.marginBottom = '';
            window.gsMemo.currentMouseTarget.lastWidth  = window.gsMemo.currentMouseTarget.clientWidth;
            window.gsMemo.currentMouseTarget.lastHeight = window.gsMemo.currentMouseTarget.clientHeight;

            GS.triggerEvent(window.gsMemo.currentMouseTarget.parentNode, 'size-changed');

            //console.log('mousemove (' + new Date().getTime() + ')');
        }
    });

    window.addEventListener('mouseup', function (event) {
        //var mousePosition = GS.mousePosition(event);

        window.bolFirstMouseMoveWhileDown = true;
        //console.log('3***'); //, document.elementFromPoint(mousePosition.x, mousePosition.y)); //event.target);
        //window.lastMouseDownElement = element.control;
    });
}

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    var multiLineTemplateElement = document.createElement('template'),
        multiLineTemplate;

    multiLineTemplateElement.innerHTML = '<textarea class="control" gs-dynamic></textarea>';

    multiLineTemplate = multiLineTemplateElement.content;

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();

        GS.triggerEvent(event.target.parentNode, 'change');
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
        event.target.parentNode.classList.add('focus');
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'blur');
        event.target.parentNode.classList.remove('focus');
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseout);
        event.target.parentNode.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseover);
        event.target.parentNode.classList.add('hover');
    }

    // function focusFunction(event) {
    //     event.preventDefault();
    //     event.stopPropagation();
    //     if (event.target.parentNode.hasAttribute('first-value')) {
    //             console.log(event);
    //         //GS.triggerEvent(event.target.parentNode, 'focus');
    //     } else {
    //         event.target.parentNode.setAttribute('first-value', event.target.value);
    //         GS.triggerEvent(event.target.parentNode, 'focus');
    //         //console.log('test');
    //     }
    // }

    //
    function keydownFunction(event) {
        var element = event.target;
        if (!element.hasAttribute('readonly')) {
            if (element.getAttribute('disabled') !== null && !(event.keyCode === 122 && event.metaKey)) {
                event.preventDefault();
                event.stopPropagation();
            } else if (event.keyCode === 9 && element.parentNode.hasAttribute('allow-tab-char') === true) {
                event.preventDefault();
                event.stopPropagation();
                var cursor_pos_memo = parseInt(element.selectionStart, 10);
                element.value = element.value.substring(0, cursor_pos_memo) + '\t' + element.value.substring(cursor_pos_memo, element.value.length);
                GS.setInputSelection(element, parseInt(cursor_pos_memo, 10) + 1, parseInt(cursor_pos_memo, 10) + 1);
            } else {
                //this.parentNode.syncView();
                element.parentNode.setAttribute('value', element.value);
                element.parentNode.handleResizeToText();
            }
        }
    }

    //
    function keyupFunction(event) {
        var element = event.target;
        if (!element.hasAttribute('readonly')) {
            //this.parentNode.syncView();
            element.parentNode.setAttribute('value', element.value);
            element.parentNode.handleResizeToText();
        }
    }

    function insertFunction(event) {
        var element = event.target;
        element.parentNode.handleResizeToText();
    }

    ////
    //function createPushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //
    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function createPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.value = strQSValue;
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = null;
            }
        }
    }

    //
    function elementInserted(element) {
        //var strQSValue;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (element.hasAttribute('tabindex')) {
                    element.setAttribute('data-tabindex', element.getAttribute('tabindex'));
                    element.removeAttribute('tabindex');
                }

                element.appendChild(multiLineTemplate.cloneNode(true));
                if (element.hasAttribute('data-tabindex')) {
                    xtag.query(element, '.control')[0].setAttribute('tabindex', element.getAttribute('data-tabindex'));
                }
                // set a variable with the control element for convenience and speed
                element.control = xtag.queryChildren(element, '.control')[0];

                element.control.lastWidth = element.control.clientWidth;
                element.control.lastHeight = element.control.clientHeight;
                element.syncView();

                if (element.getAttribute('qs')) {
                    //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.value = strQSValue;
                    //}

                    createPushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                }
            }
        }
    }

    xtag.register('gs-memo', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    //console.log(this.getAttribute('id'), strAttrName, oldValue, newValue);
                    if (strAttrName === 'disabled' && newValue !== null) {
                        this.innerHTML = this.getAttribute('value') || this.getAttribute('placeholder');
                    } else if (strAttrName === 'disabled' && newValue === null) {
                        this.innerHTML = '';
                        this.appendChild(multiLineTemplate.cloneNode(true));
                        if (this.hasAttribute('data-tabindex')) {
                            xtag.query(this, '.control')[0].setAttribute('tabindex', this.getAttribute('data-tabindex'));
                        }
                        // set a variable with the control element for convenience and speed
                        this.control = xtag.queryChildren(this, '.control')[0];

                        this.control.lastWidth = this.control.clientWidth;
                        this.control.lastHeight = this.control.clientHeight;
                        this.syncView();
                    } else if (strAttrName === 'value' && newValue !== oldValue) {
                        this.value = newValue;
                    }
                }
            }
        },
        events: {},
        accessors: {
            value: {
                // get value straight from the input
                get: function () {
                    if (this.control) {
                        return this.control.value;
                    } else {
                        return this.innerHTML;
                    }
                },

                // set the value of the input and set the value attribute
                set: function (strNewValue) {
                    if (this.getAttribute('value') !== strNewValue) {
                        this.setAttribute('value', strNewValue);
                    }
                    if (this.control) {
                        this.control.value = strNewValue;
                    } else {
                        this.innerHTML = strNewValue;
                    }
                    this.syncView();
                }
            },
            textValue: {
                // get value straight from the input
                get: function () {
                    if (this.control) {
                        return this.control.value;
                    } else {
                        return this.innerHTML;
                    }
                },

                // set the value attribute
                set: function (newValue) {
                    //this.setAttribute('value', newValue);
                    this.value = newValue;
                }
            }
        },
        methods: {
            focus: function () {
                if (this.control) {
                    this.control.focus();
                }
            },

            // sync control and resize to text
            syncView: function () {
                var element = this, arrPassThroughAttributes, i, len;

                /*
                if (this.innerHTML === '') {
                    this.appendChild(multiLineTemplate.cloneNode(true));
                }
                */
                /*
                if ((! this.hasAttribute('disabled')) && (! this.control)) {
                    this.appendChild(multiLineTemplate.cloneNode(true));
                    // set a variable with the control element for convenience and speed
                    this.control = xtag.queryChildren(this, '.control')[0];

                    this.control.lastWidth = this.control.clientWidth;
                    this.control.lastHeight = this.control.clientHeight;
                }
                */

                if (this.hasAttribute('rows')) {
                    if (this.control) {
                        this.control.setAttribute('rows', this.getAttribute('rows'));
                    }
                }

                if (this.control) {
                    this.control.removeEventListener('change', changeFunction);
                    this.control.addEventListener('change', changeFunction);

                    this.control.removeEventListener('focus', focusFunction);
                    this.control.addEventListener('focus', focusFunction);

                    this.control.removeEventListener('blur', blurFunction);
                    this.control.addEventListener('blur', blurFunction);

                    this.control.removeEventListener(evt.mouseout, mouseoutFunction);
                    this.control.addEventListener(evt.mouseout, mouseoutFunction);

                    this.control.removeEventListener(evt.mouseout, mouseoverFunction);
                    this.control.addEventListener(evt.mouseover, mouseoverFunction);

                    this.control.removeEventListener('keydown', keydownFunction);
                    this.control.addEventListener('keydown', keydownFunction);

                    this.control.removeEventListener('insert', insertFunction);
                    this.control.addEventListener('insert', insertFunction);
                }

                if (this.control) {
                    this.control.value = this.getAttribute('value');
                } else {
                    this.innerHTML = this.getAttribute('value') || this.getAttribute('placeholder') || '';
                }

                if (this.getAttribute('value')) {
                    this.handleResizeToText();
                }

                if (this.control) {
                    arrPassThroughAttributes = [
                        'placeholder',
                        'name',
                        'maxlength',
                        'autocorrect',
                        'autocapitalize',
                        'autocomplete',
                        'autofocus',
                        'rows',
                        'spellcheck',
                        'readonly'
                    ];
                    for (i = 0, len = arrPassThroughAttributes.length; i < len; i += 1) {
                        if (this.hasAttribute(arrPassThroughAttributes[i])) {
                            this.control.setAttribute(arrPassThroughAttributes[i], this.getAttribute(arrPassThroughAttributes[i]) || '');
                        }
                    }
                }

                // copy passthrough attributes to control
            },

            // if element is multiline and autoresize is not turned off: resize the element to fit the content
            handleResizeToText: function () {
                var element = this, intMinHeight;

                if (element.control) {
                    if (element.hasAttribute('autoresize')) {
                        element.control.style.height = '';
                        intMinHeight = element.control.offsetHeight;
                        element.control.style.height = ''; // '0';

                        if (element.control.scrollHeight > intMinHeight) {
                            element.control.style.height = element.control.scrollHeight + 'px';
                        } else {
                            element.control.style.height = intMinHeight + 'px';
                        }
                    }


                    if (element.control.lastWidth !== element.control.clientWidth && element.control.lastHeight !== element.control.clientHeight) {
                        element.control.lastWidth = element.control.clientWidth;
                        element.control.lastHeight = element.control.clientHeight;

                        GS.triggerEvent(element, 'size-changed');
                    }
                }
            }
        }
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('<gs-scroller>', '<gs-scroller>', 'gs-scroller>\n' +
                                                        '    <gs-scroller-inner style="width: ${1:1000px}; height: ${2:1000px};">\n' +
                                                        '        ${0}\n' +
                                                        '    </gs-scroller-inner>\n' +
                                                        '</gs-scroller>');

    designRegisterElement('gs-scroller', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-scroller.html');

    window.designElementProperty_GSSCROLLER = function (selectedElement) {
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });
    };
});


Math.easeOutQuad = function (current_time, start_value, end_change, end_time) {
    'use strict';
    // Quadratic equation (produced by Robert Penner (www.robertpenner.com))
    current_time /= end_time;
    return -end_change * current_time * (current_time - 2) + start_value;
};

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    // using element, direction and X delta: move element using quadratic equation
    function easeOutX(dragElement, target, bolRight, intXDelta, intervalEaseXID) {
        var intFrames = Math.ceil(intXDelta / 0.25), intFrame = 0, intInterval = 20
          , intTotalTime = (intFrames * intInterval);

        //console.log(bolRight, intXDelta);

        if (intXDelta > 5) {
            intervalEaseXID = setInterval(function () {
                var intLeft;

                if (intFrame < intFrames) {
                    intLeft = parseInt(dragElement.style.left, 10);

                    if (bolRight) {
                        intLeft = intLeft - Math.easeOutQuad((intFrame * intInterval), intXDelta, -intXDelta, intTotalTime);
                    } else {
                        intLeft = intLeft + Math.easeOutQuad((intFrame * intInterval), intXDelta, -intXDelta, intTotalTime);
                    }

                    setElementLeft(dragElement, target, intLeft);
                } else {
                    clearTimeout(intervalEaseXID);
                }

                intFrame += 1;
            }, intInterval);
        }
        return intervalEaseXID;
    }

    // using element, direction and Y delta: move element using quadratic equation
    function easeOutY(dragElement, target, bolBottom, intYDelta, intervalEaseYID) {
        var intFrames = Math.ceil(intYDelta / 0.25), intFrame = 0, intInterval = 20
          , intTotalTime = (intFrames * intInterval);

        if (intYDelta > 5) {
            intervalEaseYID = setInterval(function () {
                var intTop;

                if (intFrame < intFrames) {
                    intTop = parseInt(dragElement.style.top, 10);

                    if (bolBottom) {
                        intTop = intTop - Math.easeOutQuad((intFrame * intInterval), intYDelta, -intYDelta, intTotalTime);
                    } else {
                        intTop = intTop + Math.easeOutQuad((intFrame * intInterval), intYDelta, -intYDelta, intTotalTime);
                    }

                    setElementTop(dragElement, target, intTop);
                } else {
                    clearTimeout(intervalEaseYID);
                }

                intFrame += 1;
            }, intInterval);
        }
        return intervalEaseYID;
    }

    // set left and respect boundries
    function setElementLeft(dragElement, target, intLeft) {
        var intWidth = dragElement.offsetWidth, minRight = target.offsetWidth;

        // target right edge must never get < container right edge
        if ((intLeft + intWidth) < minRight) {
            intLeft = (minRight - intWidth);
        }

        // target left edge must never get > container left edge
        if (intLeft > 0) {
            intLeft = 0;
        }

        dragElement.style.left = intLeft + 'px';
    }

    // set top and respect boundries
    function setElementTop(dragElement, target, intTop) {
        var intHeight = dragElement.offsetHeight, minBottom = target.offsetHeight;

        // target bottom edge must never get < container bottom edge
        if ((intTop + intHeight) < minBottom) {
            intTop = (minBottom - intHeight);
        }

        // target top edge must never get > container top edge
        if (intTop > 0) {
            intTop = 0;
        }

        dragElement.style.top = intTop + 'px';
    }

    function handleVerticalBoundries(dragElement, target) {
        var intTop = parseFloat(dragElement.style.top)
          , intHeight = dragElement.offsetHeight
          , minBottom = target.offsetHeight;

        // target bottom edge must never get < container bottom edge
        if ((intTop + intHeight) < minBottom) {
            intTop = (minBottom - intHeight);
        }

        // target top edge must never get > container top edge
        if (intTop > 0) {
            intTop = 0;
        }

        dragElement.style.top = intTop + 'px';
    }

    function handleHorizontalBoundries(dragElement, target) {
        var intLeft = parseFloat(dragElement.style.left)
          , intWidth = dragElement.offsetWidth
          , minRight = target.offsetWidth;

        // target right edge must never get < container right edge
        if ((intLeft + intWidth) < minRight) {
            intLeft = (minRight - intWidth);
        }

        // target left edge must never get > container left edge
        if (intLeft > 0) {
            intLeft = 0;
        }

        dragElement.style.left = intLeft + 'px';
    }

    function bindEvents(element) {
        var target = element, dragElement = element.children[0], intervalEaseXID
          , intervalEaseYID, lastClearTime, intScrollDelta = 0, minZoom = 0.5
          , maxZoom = 6;

        // zoom with mousewheel
        target.addEventListener('wheel', function (event) {
            var intDelta = event.deltaY, intNewZoom, currentTime
              , jsnMousePosition = GS.mousePosition(event), mouseEMX, mouseEMY, mousePXX, mousePXY
              , jsnOffsets = GS.getElementOffset(dragElement)
              , jsnTargetOffset
              , intCurrentZoom = (parseFloat(dragElement.style.fontSize) || 1)
              , intOldHeight = dragElement.offsetHeight
              , intOldWidth = dragElement.offsetWidth
              , intNewHeight, intNewWidth, intWidthDifference, intHeightDifference
              , intRelativeX, intRelativeY, intPercentX, intPercentY;

            event.preventDefault();
            event.stopPropagation();

            // get mouse position over dragElement in ems
            mousePXY = (jsnMousePosition.y - jsnOffsets.top);
            mousePXX = (jsnMousePosition.x - jsnOffsets.left);

            mouseEMY = GS.pxToEm(dragElement, mousePXY);
            mouseEMX = GS.pxToEm(dragElement, mousePXX);
            //console.log(jsnOffsets.top, jsnMousePosition.y, mouseEMY);
            //console.log(jsnOffsets.left, jsnMousePosition.x, mouseEMX);

            //console.log(event, event.deltaY, intDelta);
            if (lastClearTime) {
                currentTime = new Date().getTime();

                //console.log(currentTime - lastClearTime);
                if ((currentTime - lastClearTime) > 200) {
                    intScrollDelta = 0;
                    lastClearTime = new Date().getTime();
                }
            }

            // need to add clear if change direction

            lastClearTime = new Date().getTime();

            // if negative delta: increase custom delta by 0.1
            //      (unless we're at the maximum zoom, in which case: reset the delta)
            if (intDelta < 0) {
                intScrollDelta = (intScrollDelta > 0 ? intScrollDelta : 0);
                intScrollDelta = 0.05;
                if (intCurrentZoom < maxZoom) {
                    intScrollDelta += 0.05;
                } else {
                    intScrollDelta = 0;
                }

            // if positive delta: decrease custom delta by 0.1
            //      (unless we're at the minimum zoom, in which case: reset the delta)
            } else {
                intScrollDelta = (intScrollDelta < 0 ? intScrollDelta : 0);
                intScrollDelta = -0.05;
                if (intCurrentZoom > minZoom) {
                    intScrollDelta -= 0.05;
                } else {
                    intScrollDelta = 0;
                }
            }

            // add new delta to current zoom
            intNewZoom = (intCurrentZoom + intScrollDelta);

            // if the new zoom is above 6em: cap it off at 6em
            intNewZoom = (intNewZoom > maxZoom ? maxZoom : intNewZoom);

            // if the new zoom is below minZoom: cap it off at minZoom
            intNewZoom = (intNewZoom < minZoom ? minZoom : intNewZoom);

            //console.log('1:' + intNewZoom, '2:' + intScrollDelta, '3:' + intCurrentZoom);

            // apply new zoom
            dragElement.style.fontSize = intNewZoom + 'em';

            if (intCurrentZoom !== intNewZoom) {
                // get new height
                intNewWidth = dragElement.offsetWidth;
                intNewHeight = dragElement.offsetHeight;

                // adjust to mouse position

                // get full height difference
                intWidthDifference = (intNewWidth - intOldWidth);
                intHeightDifference = (intNewHeight - intOldHeight);

                // get relative x and y
                jsnTargetOffset = GS.getElementOffset(dragElement);
                intRelativeX = (jsnMousePosition.x - jsnTargetOffset.left);
                intRelativeY = (jsnMousePosition.y - jsnTargetOffset.top);

                // get percentage of x and y
                intPercentX = ((intRelativeX / intOldWidth) * 100);
                intPercentY = ((intRelativeY / intOldHeight) * 100);

                //console.log(intNewWidth, intOldWidth, intWidthDifference, intRelativeX, intPercentX);
                //console.log(intNewHeight, intOldHeight, intHeightDifference, intRelativeY, intPercentY);

                // percentage of height difference
                dragElement.style.left = (parseFloat(dragElement.style.left || '0') - ((intWidthDifference / 100) * intPercentX)) + 'px';
                dragElement.style.top = (parseFloat(dragElement.style.top || '0') - ((intHeightDifference / 100) * intPercentY)) + 'px';
            }

            // handle boundries
            handleVerticalBoundries(dragElement, target);
            handleHorizontalBoundries(dragElement, target);
        });

        // scrolling by dragging
        target.addEventListener(evt.mousedown, function (event) {
            var jsnMousePosition = GS.mousePosition(event)
              , jsnTargetOffsets = GS.getElementOffset(target)
              , jsnOffsets = GS.getElementOffset(dragElement)
              , startX = jsnMousePosition.x
              , startY = jsnMousePosition.y
              , offsetX = jsnOffsets.left - jsnTargetOffsets.left
              , offsetY = jsnOffsets.top - jsnTargetOffsets.top
              , lastX = 0, lastY = 0, currentX = 0, currentY = 0
              , deltaX, deltaY
              , mousemoveHandler, mouseupHandler;

            // stop text selection
            event.preventDefault();

            // stop easing functions
            clearTimeout(intervalEaseXID);
            clearTimeout(intervalEaseYID);

            // add "down" class
            dragElement.classList.add('down');

            mousemoveHandler = function (event) {
                var jsnMousePosition;

                if (event.which === 0 && !evt.touchDevice) {
                    mouseupHandler(event);

                } else {
                    // handle move
                    jsnMousePosition = GS.mousePosition(event);

                    // saving the current postition and the previous position for calculating the delta
                    lastX = currentX;
                    lastY = currentY;
                    currentX = jsnMousePosition.x;// - jsnTargetOffsets.left;
                    currentY = jsnMousePosition.y;// - jsnTargetOffsets.top;

                    // moving element
                    //console.log(offsetX, currentX, startX);//, jsnTargetOffsets.left);
                    //console.log(offsetY, currentY, startY);//, jsnTargetOffsets.top);
                    setElementLeft(dragElement, target, (offsetX + (currentX - startX)));
                    setElementTop(dragElement, target, (offsetY + (currentY - startY)));

                    event.preventDefault();
                }
            };

            mouseupHandler = function (event) {
                // calculate delta
                deltaX = lastX - currentX;
                deltaY = lastY - currentY;

                // ease out
                intervalEaseXID = easeOutX(dragElement, target, (deltaX > 0), Math.abs(deltaX), intervalEaseXID);
                intervalEaseYID = easeOutY(dragElement, target, (deltaY > 0), Math.abs(deltaY), intervalEaseYID);

                // remove "down" class
                dragElement.classList.remove('down');

                // unbind mousemove and mouseup
                document.body.removeEventListener(evt.mousemove, mousemoveHandler);
                document.body.removeEventListener(evt.mouseup, mouseupHandler);
            };

            document.body.addEventListener(evt.mousemove, mousemoveHandler);
            document.body.addEventListener(evt.mouseup, mouseupHandler);
        });
    }


    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                if (element.children.length > 1) {
                    throw 'gs-scroller Error: Too many children. gs-scroller elements must have one child and it must be a <gs-scroller-inner> element.';

                } else if (element.children.length === 0) {
                    throw 'gs-scroller Error: No children. gs-scroller elements must have one child and it must be a <gs-scroller-inner> element.';

                } else if (element.children[0].nodeName !== 'GS-SCROLLER-INNER') {
                    throw 'gs-scroller Error: Invalid child. gs-scroller elements must have one child and it must be a <gs-scroller-inner> element.';
                }

                // if we're not on a touch device: bind events and set the title text
                if (!evt.touchDevice) {
                    // bind events
                    bindEvents(element);

                    // title text
                    element.children[0].setAttribute('title', 'Click and drag to move around, scroll to zoom.');

                // else: make the element scrollable
                } else {
                    element.classList.add('scrollable');
                }
            }
        }
    }

    xtag.register('gs-scroller-inner', {});
    xtag.register('gs-scroller', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {

                }
            }
        },
        events: {},
        accessors: {},
        methods: {}
    });
});
window.addEventListener('design-register-element', function () {

    registerDesignSnippet('<gs-number>', '<gs-number>', 'gs-number column="${1:name}"></gs-number>');
    registerDesignSnippet('<gs-number> With Label', '<gs-number>', 'label for="${1:number-insert-qty}">${2:Quantity}:</label>\n' +
                                                                   '<gs-number id="${1:number-insert-qty}" column="${3:qty}"></gs-number>');

    designRegisterElement('gs-number', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-number.html');

    window.designElementProperty_GSNUMBER = function(selectedElement) {
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
        });

        //console.log(selectedElement.hasAttribute('mini'));

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });

        addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
        });

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var singleLineTemplateElement = document.createElement('template'),
        singleLineTemplate;

    singleLineTemplateElement.innerHTML = '<input class="control" gs-dynamic type="text" />';
    singleLineTemplate = singleLineTemplateElement.content;

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();

        GS.triggerEvent(event.target.parentNode, 'change');

        handleFormat(event.target.parentNode, event);
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
        event.target.parentNode.classList.add('focus');
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'blur');
        event.target.parentNode.classList.remove('focus');
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseout);
        event.target.parentNode.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseover);
        event.target.parentNode.classList.add('hover');
    }

    //function createPushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');

    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function createPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // sync control value and resize to text
    function syncView(element) {
        if (element.control) {
            if (element.getAttribute('value') !== element.control.value) {
                element.setAttribute('value', element.control.value);
            }
        } else {
            if (element.getAttribute('value') !== element.innerHTML) {
                element.setAttribute('value', element.innerHTML);
            }
        }
    }

    function handleFormat(element, event, bolAlertOnError) {
        var strFormat, intValue;

        if (element.hasAttribute('format')) {
            strFormat = element.getAttribute('format');

            intValue = element.value; // parseFloat(element.value.replace(/[^0-9.]*/g, ''), 10);

            if (isNaN(intValue)) {
                if (bolAlertOnError !== undefined && bolAlertOnError !== false) {
                    alert('Invalid Number: ' + element.value);
                }

                if (element.control) {
                    GS.setInputSelection(element.control, 0, element.value.length);
                }

                if (event) {
                    event.stopPropagation();
                    event.preventDefault();
                }

            } else {
                if (element.control) {
                    element.control.value = formatNumber(intValue, strFormat);
                } else {
                    element.innerHTML = formatNumber(intValue, strFormat);
                }
            }
        }
    }

    function formatNumber(intValue, strFormat) {
        /* (this function contains a (modified) substantial portion of code from another source
            here is the copyright for sake of legality) (Uses code by Matt Kruse)
        Copyright (c) 2006-2009 Rostislav Hristov, Asual DZZD

        Permission is hereby granted, free of charge, to any person obtaining a
        copy of this software and associated documentation files
        (the "Software"), to deal in the Software without restriction,
        including without limitation the rights to use, copy, modify, merge,
        publish, distribute, sublicense, and/or sell copies of the Software,
        and to permit persons to whom the Software is furnished to do so,
        subject to the following conditions:

        The above copyright notice and this permission notice shall be included
        in all copies or substantial portions of the Software.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
        IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
        CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
        TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
        SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/
        var groupingSeparator,
            groupingIndex,
            decimalSeparator,
            decimalIndex,
            roundFactor,
            result,
            i,
            locale = {
                groupingSeparator: ',',
                decimalSeparator: '.',
                currencySymbol: '$',
                percentSymbol: '%'
            };

        if (strFormat.toLowerCase() === 'currency') {
            strFormat = locale.currencySymbol + '0.00';
        } else if (strFormat.toLowerCase() === 'percent') {
            intValue = intValue * 100;
            strFormat = locale.percentSymbol + '0.00';
        }

        var integer = '',
            fraction = '',
            negative,
            minFraction,
            maxFraction,
            powFraction,
            bolCurrencySymbol = strFormat[0] === locale.currencySymbol,
            bolPercentSymbol = strFormat[0] === locale.percentSymbol;

        if (bolCurrencySymbol || bolPercentSymbol) {
            strFormat = strFormat.substring(1);
        }

        groupingSeparator = ',';
        groupingIndex = strFormat.lastIndexOf(groupingSeparator);
        decimalSeparator = '.';
        decimalIndex = strFormat.indexOf(decimalSeparator);

        negative = intValue < 0;
        minFraction = strFormat.substr(decimalIndex + 1).replace(/#/g, '').length;
        maxFraction = strFormat.substr(decimalIndex + 1).length;
        powFraction = 10;

        intValue = Math.abs(intValue);

        if (decimalIndex != -1) {
            fraction = locale.decimalSeparator;
            if (maxFraction > 0) {
                roundFactor = 1000;
                powFraction = Math.pow(powFraction, maxFraction);
                var tempRound = Math.round(parseInt(intValue * powFraction * roundFactor -
                            Math.round(intValue) * powFraction * roundFactor, 10) / roundFactor),
                    tempFraction = String(tempRound < 0 ? Math.round(parseInt(intValue * powFraction * roundFactor -
                            parseInt(intValue, 10) * powFraction * roundFactor, 10) / roundFactor) : tempRound),
                    parts = intValue.toString().split('.');
                if (typeof parts[1] != 'undefined') {
                    for (i = 0; i < maxFraction; i++) {
                        if (parts[1].substr(i, 1) == '0' && i < maxFraction - 1 &&
                                tempFraction.length != maxFraction) {
                            tempFraction = '0' + tempFraction;
                        } else {
                            break;
                        }
                    }
                }
                for (i = 0; i < (maxFraction - fraction.length); i++) {
                    tempFraction += '0';
                }
                var symbol, formattedFraction = '';

                for (i = 0; i < tempFraction.length; i++) {
                    symbol = tempFraction.substr(i, 1);
                    if (i >= minFraction && symbol == '0' && (/^0*$/).test(tempFraction.substr(i + 1))) {
                        break;
                    }
                    formattedFraction += symbol;
                }
                fraction += formattedFraction;
            }
            if (fraction == locale.decimalSeparator) {
                fraction = '';
            }
        }

        if (decimalIndex !== 0) {
            if (fraction !== '') {
                integer = String(parseInt(Math.round(intValue * powFraction) / powFraction, 10));
            } else {
                integer = String(Math.round(intValue));
            }
            var grouping = locale.groupingSeparator,
                groupingSize = 0;
            if (groupingIndex != -1) {
                if (decimalIndex != -1) {
                    groupingSize = decimalIndex - groupingIndex;
                } else {
                    groupingSize = strFormat.length - groupingIndex;
                }
                groupingSize--;
            }
            if (groupingSize > 0) {
                var count = 0,
                    formattedInteger = '';
                i = integer.length;
                while (i--) {
                    if (count !== 0 && count % groupingSize === 0) {
                        formattedInteger = grouping + formattedInteger;
                    }
                    formattedInteger = integer.substr(i, 1) + formattedInteger;
                    count++;
                }
                integer = formattedInteger;
            }
            var maxInteger, maxRegExp = /#|,/g;
            if (decimalIndex != -1) {
                maxInteger = strFormat.substr(0, decimalIndex).replace(maxRegExp, '').length;
            } else {
                maxInteger = strFormat.replace(maxRegExp, '').length;
            }
            var tempInteger = integer.length;
            for (i = tempInteger; i < maxInteger; i++) {
                integer = '0' + integer;
            }
        }
        result = integer + fraction;
        return (bolPercentSymbol ? locale.percentSymbol : '') +
               (bolCurrencySymbol ? locale.currencySymbol : '') +
               (negative ? '-' : '') + result;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = null;
            }
        }
    }

    function elementInserted(element) {
        //var strQSValue;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (element.hasAttribute('tabindex')) {
                    element.setAttribute('data-tabindex', element.getAttribute('tabindex'));
                    element.removeAttribute('tabindex');
                }
                if (element.hasAttribute('disabled')) {
                    element.innerHTML = element.getAttribute('value') || element.getAttribute('placeholder');
                } else {
                    element.innerHTML = '';
                    element.appendChild(singleLineTemplate.cloneNode(true));
                    if (element.hasAttribute('data-tabindex')) {
                        xtag.query(element, '.control')[0].setAttribute('tabindex', element.getAttribute('data-tabindex'));
                    }
                }

                if (element.getAttribute('qs')) {
                    //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.value = strQSValue;
                    //}

                    createPushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                }

                if (element.innerHTML === '') {
                    element.appendChild(singleLineTemplate.cloneNode(true));
                    if (element.hasAttribute('data-tabindex')) {
                        xtag.query(element, '.control')[0].setAttribute('tabindex', element.getAttribute('data-tabindex'));
                    }
                }
                element.refresh();
            }
        }
    }

    xtag.register('gs-number', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // attribute code
                    if (strAttrName === 'disabled') {
                        if (this.hasAttribute('tabindex')) {
                            this.setAttribute('data-tabindex', this.getAttribute('tabindex'));
                            this.removeAttribute('tabindex');
                        }
                        if (this.hasAttribute('disabled')) {
                            this.innerHTML = this.getAttribute('value') || this.getAttribute('placeholder');
                        } else {
                            this.innerHTML = '';
                            this.appendChild(singleLineTemplate.cloneNode(true));
                            if (this.hasAttribute('data-tabindex')) {
                                xtag.query(this, '.control')[0].setAttribute('tabindex', this.getAttribute('data-tabindex'));
                            }
                        }

                        this.refresh();
                    } else if (strAttrName === 'value' && newValue !== oldValue) {
                        this.value = newValue;
                    }
                }
            }
        },
        events: {
            // on keydown and keyup sync the value attribute and the control value
            keydown: function (event) {
                if (window.bolDesignMode !== true) {
                    if (this.getAttribute('disabled') !== null && event.keyCode !== 9) {
                        event.preventDefault();
                        event.stopPropagation();
                    } else {
                        syncView(this);
                    }
                }
            },
            keyup: function () {
                if (window.bolDesignMode !== true) {
                    syncView(this);
                }
            }//,
            //'change:delegate(.control)': function (event) {
            //    var element = this.parentNode;
            //
            //    event.preventDefault();
            //    event.stopPropagation();
            //
            //    xtag.fireEvent(element, 'change', {
            //        bubbles: true,
            //        cancelable: true
            //    });
            //}
        },
        accessors: {
            value: {
                // get value straight from the input
                get: function () {
                    if (this.control) {
                        return parseFloat(this.control.value.replace(/[^-0-9.]*/g, ''), 10); // this.control.value;
                    } else {
                        return parseFloat(this.innerHTML.replace(/[^-0-9.]*/g, ''), 10); // this.control.value;
                    }
                },

                // set the value of the input and set the value attribute
                set: function (strNewValue) {
                    var selection;
                    if (this.control) {
                        selection = GS.getInputSelection(this.control);
                        this.control.value = strNewValue;
                    } else {
                        this.innerHTML = strNewValue;
                    }
                    handleFormat(this);
                    syncView(this);
                    if (selection) {
                        GS.setInputSelection(this.control, selection.start, selection.end);
                    }
                }
            }
        },
        methods: {
            focus: function () {
                this.control.focus();
            },

            refresh: function () {
                var arrPassThroughAttributes, i, len;

                // set a variable with the control element for convenience and speed
                this.control = xtag.query(this, '.control')[0];

                if (this.control) {
                    this.control.removeEventListener('change', changeFunction);
                    this.control.addEventListener('change', changeFunction);

                    this.control.removeEventListener('focus', focusFunction);
                    this.control.addEventListener('focus', focusFunction);

                    this.control.removeEventListener('blur', blurFunction);
                    this.control.addEventListener('blur', blurFunction);

                    this.control.removeEventListener(evt.mouseout, mouseoutFunction);
                    this.control.addEventListener(evt.mouseout, mouseoutFunction);

                    this.control.removeEventListener(evt.mouseover, mouseoverFunction);
                    this.control.addEventListener(evt.mouseover, mouseoverFunction);
                }
                // if there is a value already in the attributes of the element: set the control value
                if (this.hasAttribute('value')) {
                    if (this.control) {
                        this.control.value = this.getAttribute('value') || this.getAttribute('placeholder');
                    } else {
                        this.innerHTML = this.getAttribute('value') || this.getAttribute('placeholder');
                    }
                    handleFormat(this, undefined, false);
                }

                if (this.control) {
                    // copy passthrough attributes to control
                    arrPassThroughAttributes = [
                        'placeholder',
                        'name',
                        'maxlength',
                        'autocorrect',
                        'autocapitalize',
                        'autocomplete',
                        'autofocus',
                        'spellcheck',
                        'readonly'
                    ];
                    for (i = 0, len = arrPassThroughAttributes.length; i < len; i += 1) {
                        if (this.hasAttribute(arrPassThroughAttributes[i])) {
                            this.control.setAttribute(arrPassThroughAttributes[i], this.getAttribute(arrPassThroughAttributes[i]) || '');
                        }
                    }
                }
            }
        }
    });
});
window.addEventListener('design-register-element', function () {
    registerDesignSnippet('<gs-optionbox>', '<gs-optionbox>', 'gs-optionbox column="${1}">\n' +
                                                              '    <gs-option value="${2}">${3}</gs-option>\n' +
                                                              '</gs-optionbox>');

    designRegisterElement('gs-optionbox', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-optionbox.html');

    window.designElementProperty_GSOPTIONBOX = function(selectedElement) {
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Clearable', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('clearable') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'clearable', this.value === 'true', true);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', this.value === 'true', true);
        });

        addProp('No Targets', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('no-target') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-target', this.value === 'true', true);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
    /*
    window.designElementProperty_GSOPTION = function(selectedElement) {
        addProp('Hidden Value:', true, '<gs-text class="target" value="' + (selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + (selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        addFlexContainerProps(selectedElement);
        //addFlexProps(selectedElement);
    };*/
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    // removes selected attribute from old selected option adds selected attribute to option
    function highlightOption(element, option) {
        var i, len, arrSelectedOptions, arrTempSelectedOptions;

        // clear previous selection
        arrSelectedOptions = xtag.query(element, 'gs-option[selected]');
        arrTempSelectedOptions = xtag.query(element, 'gs-option[tempselect]');
        for (i = 0, len = arrSelectedOptions.length; i < len; i += 1) {
            arrSelectedOptions[i].removeAttribute('selected');
        }

        for (i = 0, len = arrTempSelectedOptions.length; i < len; i += 1) {
            arrTempSelectedOptions[i].removeAttribute('tempselect');
        }

        // select/highlight the record that was provided
        if (option) {
            option.setAttribute('selected', '');
        }
    }

    // loops through the options and finds a option using the parameter
    function findOptionFromString(element, strSearchString) {
        var i, len, matchedOption, arrOptions = xtag.query(element, 'gs-option');

        // search exact text and search both the value attribute (if present) and the text content
        for (i = 0, len = arrOptions.length; i < len; i += 1) {
            if (arrOptions[i].getAttribute('value') === strSearchString || arrOptions[i].textContent === strSearchString) {
                matchedOption = arrOptions[i];
                break;
            }
        }

        return matchedOption;
    }

    function selectOption(element, handle, bolChange) {
        var option, strOptionValue, strOptionText;

        if (typeof handle === 'string') {
            option = findOptionFromString(element, handle);

            if (!option) {
                throw 'gs-optionbox Error: value: \'' + handle + '\' not found.';
            }
        } else {
            option = handle;
        }

        highlightOption(element, option);

        if (option) {
            strOptionValue = option.getAttribute('value');
            strOptionText = option.textContent;
        } else {
            strOptionValue = '';
            strOptionText = '';
        }

        if (element.value !== (strOptionValue || strOptionText)) {
            element.innerValue = strOptionValue || strOptionText;
            element.innerSelectedOption = option;

            if (bolChange) {
                xtag.fireEvent(element, 'change', {bubbles: true, cancelable: true});
            }
        }
    }

    // #################################################################
    // ########################## USER EVENTS ##########################
    // #################################################################
    /*
    // handle behaviours on keydown
    function handleKeyDown(event) {
        var element = event.target, intKeyCode = event.keyCode || event.which,
            selectedOption, selectedOptionIndex,
            tempSelectedOption, tempSelectedOptionIndex, arrOptions, i, len;

        if (!element.hasAttribute('disabled')) {
            if ((intKeyCode === 40 || intKeyCode === 38) && !event.shiftKey && !event.metaKey && !event.ctrlKey && !element.error) {
                arrOptions = xtag.query(element, 'gs-option');

                for (i = 0, len = arrOptions.length; i < len; i += 1) {
                    if (arrOptions[i].hasAttribute('tempselect')) {
                        tempSelectedOptionIndex = i;
                        tempSelectedOption = arrOptions[i];
                        arrOptions[i].removeAttribute('tempselect');
                    }

                    if (arrOptions[i].hasAttribute('selected')) {
                        selectedOptionIndex = i;
                        selectedOption = arrOptions[i];
                    }

                    if (selectedOption && tempSelectedOption) {
                        break;
                    }
                }

                //console.log(selectedOption, selectedOptionIndex, tempSelectedOption, tempSelectedOptionIndex, arrOptions.length);

                if (tempSelectedOption && tempSelectedOptionIndex !== arrOptions.length - 1 && intKeyCode === 40) {
                    if (!arrOptions[tempSelectedOptionIndex + 1].hasAttribute('selected')) {
                        arrOptions[tempSelectedOptionIndex + 1].setAttribute('tempselect', '');
                    }
                } else if (tempSelectedOption && tempSelectedOptionIndex !== 0 && intKeyCode === 38) {
                    if (!arrOptions[tempSelectedOptionIndex - 1].hasAttribute('selected')) {
                        arrOptions[tempSelectedOptionIndex - 1].setAttribute('tempselect', '');
                    }
                } else if (!tempSelectedOption && selectedOption && selectedOptionIndex !== arrOptions.length - 1 && intKeyCode === 40) {
                    if (!arrOptions[selectedOptionIndex + 1].hasAttribute('selected')) {
                        arrOptions[selectedOptionIndex + 1].setAttribute('tempselect', '');
                    }
                } else if (!tempSelectedOption && selectedOption && selectedOptionIndex !== 0 && intKeyCode === 38) {
                    if (!arrOptions[selectedOptionIndex - 1].hasAttribute('selected')) {
                        arrOptions[selectedOptionIndex - 1].setAttribute('tempselect', '');
                    }
                // tempselect first record
                } else if (intKeyCode === 40) {
                    if (!arrOptions[0].hasAttribute('selected')) {
                        arrOptions[0].setAttribute('tempselect', '');
                    }
                // tempselect last record
                } else if (intKeyCode === 38) {
                    if (!arrOptions[arrOptions.length - 1].hasAttribute('selected')) {
                        arrOptions[arrOptions.length - 1].setAttribute('tempselect', '');
                    }
                }
                event.preventDefault();
                event.stopPropagation();

            } else if (event.keyCode === 13 || event.keyCode === 32) {
                selectedOption = xtag.query(element, 'gs-option[selected]')[0];
                tempSelectedOption = xtag.query(element, 'gs-option[tempselect]')[0];

                if (tempSelectedOption) {
                    selectOption(element, tempSelectedOption, true);
                } else if (selectedOption) {
                    selectOption(element, selectedOption, true);
                }
            }
        } else {
            if (event.keyCode !== 9) {
                event.preventDefault();
                event.stopPropagation();
            }
        }

        //console.log('handleKeyDown', intKeyCode, event);
    }*/

    function getParentOption(element) {
        var currentElement = element;

        while (currentElement.nodeName !== 'GS-OPTION' && currentElement.nodeName !== 'HTML') {
            currentElement = currentElement.parentNode;
        }

        if (currentElement.nodeName !== 'GS-OPTION') {
            return undefined;
        }

        return currentElement;
    }

    //function createPushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //
    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function createPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    function enhanceChildren(element) {
        var arrElement, i, len;

        arrElement = xtag.query(element, 'gs-option');

        for (i = 0, len = arrElement.length; i < len; i += 1) {
            // this if allows the developer to define the icon position
            if (!arrElement[i].hasAttribute('icontop')
                    && !arrElement[i].hasAttribute('iconleft')
                    && !arrElement[i].hasAttribute('iconbottom')
                    && !arrElement[i].hasAttribute('iconright')) {
                arrElement[i].setAttribute('iconleft', '');
            }
            arrElement[i].setAttribute('icon', '');
        }
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value) {
                element.setAttribute('value', element.value);
                delete element.value;
                // element.value = null;
            }
        }
    }

    //
    function elementInserted(element) {
        var strQSValue, observer;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                //// allows the element to have focus
                //if (!element.hasAttribute('tabindex')) {
                //    element.setAttribute('tabindex', '0');
                //}

                if (element.getAttribute('value')) {
                    selectOption(element, element.getAttribute('value'), false);
                }

                if (element.getAttribute('qs')) {
                    //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));

                    //if (strQSValue !== '') {
                    //    selectOption(element, strQSValue, false);
                    //}
                    createPushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                }

                // if we are not [no-target]
                if (!element.hasAttribute('no-target')) {
                    enhanceChildren(element);

                    // put an observer on the option element to enhance new children

                    // create an observer instance
                    observer = new MutationObserver(function(mutations) {
                        var bolRefreshOptionList = true;

                        // check each mutation: if only option and optgroup tags were added: refersh option tags in select
                        mutations.forEach(function(mutation) {
                            var i, len;

                            for (i = 0, len = mutation.addedNodes.length; i < len; i += 1) {
                                if (mutation.addedNodes[i].nodeName !== 'GS-OPTION') {
                                    bolRefreshOptionList = false;
                                }
                            }
                        });

                        if (bolRefreshOptionList) {
                            enhanceChildren(element);
                        }
                    });

                    // pass in the element node, as well as the observer options
                    observer.observe(element, {childList: true});
                }
            }
        }
    }

    xtag.register('gs-optionbox', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value' && newValue !== oldValue) {
                        selectOption(this, newValue);
                    }
                }
            }
        },
        events: {
            //'keydown': function (event) {
            //    if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
            //        handleKeyDown(event);
            //    }
            //},

            'click': function (event) {
                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted') && !this.hasAttribute('readonly')) {
                    var parentOption = getParentOption(event.target);

                    //console.log(parentOption);

                    //  else if (this.hasAttribute('clearable') && newValue === oldValue) {
                    //     console.log('running');
                    //     selectOption(this, undefined);
                    // }

                    if (parentOption && !parentOption.hasAttribute('selected')) {
                        selectOption(this, parentOption, true);
                    } else if (this.hasAttribute('clearable')) {
                        selectOption(this, undefined);
                    }
                }
            }//,

            //'focusout': function () {
            //    if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
            //        var selectedOption = xtag.query(this, 'gs-option[selected]')[0],
            //            tempSelectedOption = xtag.query(this, 'gs-option[tempselect]')[0];
            //
            //        if (tempSelectedOption) {
            //            selectOption(this, tempSelectedOption, true);
            //
            //        } else if (selectedOption) {
            //            selectOption(this, selectedOption, true);
            //        }
            //    }
            //}
        },
        accessors: {
            value: {
                get: function () {
                    return this.innerValue;
                },

                set: function (strNewValue) {
                    selectOption(this, strNewValue);
                }
            },

            selectedOption: {
                get: function () {
                    return this.innerSelectedOption;
                },

                set: function (newValue) {
                    selectOption(this, newValue);
                }
            },

            textValue: {
                get: function () {
                    return this.innerSelectedOption.textContent;
                },

                set: function (newValue) {
                    selectOption(this, newValue);
                }
            }
        }
    });
});
window.addEventListener('design-register-element', function () {
    registerDesignSnippet('Empty <gs-page>', '<gs-page>', 'gs-page>\n' +
                                                          '    $0\n' +
                                                          '</gs-page>');
    registerDesignSnippet('<gs-page> With Header', '<gs-page>', 'gs-page>\n' +
                                                         '    <gs-header>\n' +
                                                         '        <center><h3>${1}</h3></center>\n' +
                                                         '    </gs-header>\n' +
                                                         '    <gs-body>\n' +
                                                         '        $0\n' +
                                                         '    </gs-body>\n' +
                                                         '</gs-page>');
    registerDesignSnippet('Full <gs-page>', '<gs-page>', 'gs-page>\n' +
                                                         '    <gs-header>\n' +
                                                         '        <center><h3>${1}</h3></center>\n' +
                                                         '    </gs-header>\n' +
                                                         '    <gs-body>\n' +
                                                         '        $0\n' +
                                                         '    </gs-body>\n' +
                                                         '    <gs-footer>${2}</gs-footer>\n' +
                                                         '</gs-page>');

    designRegisterElement('gs-page', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-page.html');

    window.designElementProperty_GSPAGE = function (selectedElement) {
        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            var observer,
                headerElement = xtag.queryChildren(element, 'gs-header')[0],
                footerElement = xtag.queryChildren(element, 'gs-footer')[0];

            // create an observer instance
            observer = new MutationObserver(function(mutations) {
                element.recalculatePadding();
                //console.log('mutation observed');
            });

            // pass in the element node, as well as the observer options
            if (headerElement) {
                observer.observe(headerElement, {childList: true, subtree: true});
            }
            if (footerElement) {
                observer.observe(footerElement, {childList: true, subtree: true});
            }
        }
    }

    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                element.recalculatePadding();

                window.addEventListener('load', function () {
                    element.recalculatePadding();
                });
                window.addEventListener('resize', function () {
                    element.recalculatePadding();
                });
                element.recalculatePadding();
            }
        }
    }

    xtag.register('gs-page', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // attribute code
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            recalculatePadding: function () {
                var headerElement = xtag.queryChildren(this, 'gs-header')[0],
                    footerElement = xtag.queryChildren(this, 'gs-footer')[0];

                if (headerElement) {
                    //console.log('1***', headerElement.offsetHeight);
                    this.style.paddingTop = headerElement.offsetHeight + 'px';
                } else {
                    this.style.paddingTop = '';
                }
                if (footerElement) {
                    //console.log('2***', footerElement.offsetHeight);
                    this.style.paddingBottom = footerElement.offsetHeight + 'px';
                } else {
                    this.style.paddingBottom = '';
                }
            }
        }
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';
    registerDesignSnippet('<gs-panel>', '<gs-panel>', 'gs-panel id="panel">\n' +
                                                      '    <gs-page id="${1:left-bar}" style="width: 17em;">\n' +
                                                      '        \n' +
                                                      '    </gs-page>\n' +
                                                      '    <gs-page>\n' +
                                                      '        \n' +
                                                      '    </gs-page>\n' +
                                                      '</gs-panel>');

    designRegisterElement('gs-panel', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-panel.html');

    window.designElementProperty_GSPANEL = function(selectedElement) {
        // no-shadow-dismiss attribute
        addProp('Dismissible By Clicking The Shadow', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-shadow-dismiss')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-shadow-dismiss', this.value === 'true', false);
        });

        // dismissible attribute
        addProp('Dismissible On Desktop', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('dismissible') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'dismissible', this.value === 'true', true);
        });

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    function pushReplacePopHandler(element) {
        var query = GS.getQueryString(), arrQueryKeys = GS.qryGetKeys(query),
            strID = element.getAttribute('id'), strAttributeName, i, len, strNewValue;

        for (i = 0, len = arrQueryKeys.length; i < len; i += 1) {
            if (arrQueryKeys[i].indexOf(strID + '.') === 0 &&
                element.panelIDs.indexOf(arrQueryKeys[i].split('.')[1]) > -1) {

                strAttributeName = arrQueryKeys[i].split('.')[1];
                strNewValue = GS.qryGetVal(query, arrQueryKeys[i]);

                if (element.getAttribute(strAttributeName) !== strNewValue) {
                    element.setAttribute(strAttributeName, strNewValue);
                }
            }
        }

        for (i = 0, len = element.arrQueryStringAttributes.length; i < len; i += 1) {
            if (arrQueryKeys.indexOf(element.arrQueryStringAttributes[i]) === -1) {
                element.removeAttribute(element.arrQueryStringAttributes[i].split('.')[1]);
            }
        }
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                var arrElement, i, len, blockerElement, blockerClickHandler;

                element.arrQueryStringAttributes = [];
                element.panelIDs = [];

                blockerClickHandler = function (event) {
                    var target = event.target;

                    if (target.classList.contains('gs-panel-page-blocker')) {
                        element.hide(target.getAttribute('blocking'));
                    }
                };

                arrElement = xtag.queryChildren(element, '*');

                for (i = 0, len = arrElement.length; i < len; i += 1) {
                    if (arrElement[i].style.width === '') {
                        arrElement[i].setAttribute('flex', '');
                    } else {
                        if (!arrElement[i].hasAttribute('id')) {
                            console.warn('gs-panel Warning: No ID attribute on side-page element:',
                                         GS.cloneElement(arrElement[i]),
                                         ', please set ID the attribute');

                            arrElement[i].setAttribute('id', 'side-' + GS.GUID().substring(0, 8));
                        }
                        element.panelIDs.push(arrElement[i].getAttribute('id'));

                        blockerElement = document.createElement('div');
                        blockerElement.classList.add('gs-panel-page-blocker');
                        blockerElement.setAttribute('gs-dynamic', '');
                        blockerElement.setAttribute('blocking', arrElement[i].getAttribute('id'));
                        blockerElement.setAttribute('id', arrElement[i].getAttribute('id') + '-blocker');

                        element.insertBefore(blockerElement, arrElement[i]);

                        arrElement[i].setAttribute('panel-set-width', '');

                        if (arrElement[i].hasAttribute('hidden')) {
                            arrElement[i].removeAttribute('hidden');
                            element.hide(arrElement[i].getAttribute('id'));

                        } else {
                            if (element.getAttribute(arrElement[i].getAttribute('id')) === 'hide') {
                                element.hide(arrElement[i].getAttribute('id'));
                            }
                        }

                        if (!element.hasAttribute('no-shadow-dismiss')) {
                            blockerElement.addEventListener('click', blockerClickHandler);
                        }
                    }
                }

                window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });

                if (element.hasAttribute('id')) {
                    pushReplacePopHandler(element);
                }
            }
        }
    }

    xtag.register('gs-panel', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (document.getElementById(strAttrName) &&
                        document.getElementById(strAttrName).parentNode === this) {
                        if (newValue === 'hide' || newValue === 'show') {
                            this[newValue](strAttrName);
                        }
                        /*if (newValue === 'hide') {
                            this.hide(strAttrName);
                        } else if (newValue === 'show') {
                            this.show(strAttrName);
                        }*/
                    }
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            'show': function (strID) {
                var strQueryString = GS.getQueryString(), strElementID = this.getAttribute('id');
                //document.getElementById(strID).setAttribute('shown', '');
                //document.getElementById(strID).removeAttribute('hidden');
                //document.getElementById(strID + '-blocker').setAttribute('shown', '');
                //document.getElementById(strID + '-blocker').removeAttribute('hidden');

                //document.getElementById(strID).style.display = '';
                //document.getElementById(strID + '-blocker').style.display = '';

                //if (window.innerWidth <= 768 || this.hasAttribute('dismissible')) {

                if ((strElementID && GS.qryGetKeys(strQueryString).indexOf(strElementID + '.' + strID) > -1) &&
                    GS.qryGetVal(strQueryString, strElementID + '.' + strID) === 'hide') {
                    GS.pushQueryString(strElementID + '.' + strID + '=show');

                } else if (this.getAttribute(strID) === 'show') {
                    //document.getElementById(strID).style.left = '';
                    //document.getElementById(strID).style.position = '';
                    //document.getElementById(strID + '-blocker').style.left = ''; // <-- works on a phone
                    document.getElementById(strID).removeAttribute('panel-hide');
                    document.getElementById(strID + '-blocker').removeAttribute('panel-hide');

                    //this.hiddenIDs.splice(this.hiddenIDs.indexOf(strID), 1);
                    //
                    GS.triggerEvent(document.getElementById(strID), 'show');
                    GS.triggerEvent(window, 'resize'); //, {'triggered': true});
                } else {
                    this.setAttribute(strID, 'show');
                }
                //}
            },

            'hide': function (strID) {
                var strQueryString = GS.getQueryString(), strElementID = this.getAttribute('id');
                //document.getElementById(strID).setAttribute('hidden', '');
                //document.getElementById(strID).removeAttribute('shown');
                //document.getElementById(strID + '-blocker').setAttribute('hidden', '');
                //document.getElementById(strID + '-blocker').removeAttribute('shown');

                //document.getElementById(strID).style.display = 'none';
                //document.getElementById(strID + '-blocker').style.display = 'none';

                if ((strElementID && GS.qryGetKeys(strQueryString).indexOf(strElementID + '.' + strID) > -1) &&
                    GS.qryGetVal(strQueryString, strElementID + '.' + strID) === 'show') {
                    GS.pushQueryString(strElementID + '.' + strID + '=hide');

                } else if (this.getAttribute(strID) === 'hide') {
                    document.getElementById(strID).setAttribute('panel-hide', '');
                    document.getElementById(strID + '-blocker').setAttribute('panel-hide', '');

                    //if (window.innerWidth <= 768 || this.hasAttribute('dismissible')) {
                    //    document.getElementById(strID).style.left = '-100%';
                    //    document.getElementById(strID).style.position = 'absolute';
                    //    document.getElementById(strID + '-blocker').style.left = '-100%'; // <-- works on a phone
                    //
                    //    this.hiddenIDs.push(strID);
                    //
                    GS.triggerEvent(document.getElementById(strID), 'hide');
                    GS.triggerEvent(window, 'resize'); //, {'triggered': true});
                    //}
                } else {
                    this.setAttribute(strID, 'hide');
                }
            },

            'toggle': function (strID) {
                var element = document.getElementById(strID);

                if (element.hasAttribute('shown') || !element.hasAttribute('panel-hide')) {
                    this.hide(strID);
                } else {
                    this.show(strID);
                }
            }
        }
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';
    registerDesignSnippet('Push Message', 'GS.pushMessage', 'pushMessage(\'${1:HTML}\', ${2:1500}, function () {${3}});');
});

GS.pushMessage = function (strHTML, intTime, callback) {
    var pushMessageElement, containerElement;

    // if there is no html to put in the pushmessage: throw an error
    if (strHTML === undefined) {
        throw 'GS.pushMessage Error: no HTML to display.';
    }

    // if there is no container: add it
    if (document.getElementsByTagName('gs-pushmessage-container').length === 0) {
        containerElement = document.createElement('gs-pushmessage-container');
        containerElement.setAttribute('gs-dynamic', '');
        document.body.appendChild(containerElement);
    } else {
        containerElement = document.getElementsByTagName('gs-pushmessage-container')[0];
    }

    // create the pushmessage
    pushMessageElement = document.createElement('gs-pushmessage');
    pushMessageElement.setAttribute('gs-dynamic', '');
    pushMessageElement.innerHTML = strHTML;

    // append the pushmessage to the container
    containerElement.appendChild(pushMessageElement);

    // if there is a callback: run it
    if (typeof callback === 'function') {
        callback.apply(pushMessageElement);
    }

    // if there is a time: set a timeout to close the message
    if (intTime) {
        setTimeout(function() {
            GS.closePushMessage(pushMessageElement);
        }, intTime);
    }

    // return the pushmessage
    return pushMessageElement;
};

window.addEventListener('design-register-element', function () {
    'use strict';
    registerDesignSnippet('GS.closePushMessage', 'GS.closePushMessage', 'GS.closePushMessage(${0:pushMessageElement});');
    registerDesignSnippet('Close Push Message',  'Close Push Message',  'GS.closePushMessage(${0:pushMessageElement});');
});

GS.closePushMessage = function (pushMessageElement) {
    var containerElement = document.getElementsByTagName('gs-pushmessage-container')[0];

    // fade the pushmessage out
    GS.animateStyle(pushMessageElement, 'opacity', '1', '0', function () {

        // if there is only one pushmessage element: remove the container
        if (document.getElementsByTagName('gs-pushmessage').length === 1) {
            document.body.removeChild(containerElement);

        // else: just remove the element
        } else {
            containerElement.removeChild(pushMessageElement);
        }
    }, 250, 100);
};


document.addEventListener('DOMContentLoaded', function () {
    xtag.register('gs-pushmessage', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {}
    });

    xtag.register('gs-pushmessage-container', {
        lifecycle: {},
        events: {},
        accessors: {},
        methods: {}
    });
});
window.addEventListener('design-register-element', function () {
    registerDesignSnippet('<gs-search>', '<gs-search>', 'gs-search id="${1}"></gs-search>');

    designRegisterElement('gs-search', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-search.html');

    window.designElementProperty_GSSEARCH = function(selectedElement) {
        addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
        });

        //console.log(selectedElement.hasAttribute('mini'));

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
        });

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var singleLineTemplateElement = document.createElement('template');
    var singleLineTemplate;

    singleLineTemplateElement.innerHTML = '<input class="control" gs-dynamic type="text" placeholder="Search..." />';
    singleLineTemplate = singleLineTemplateElement.content;

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();

        GS.triggerEvent(event.target.parentNode, 'change');
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
        event.target.parentNode.classList.add('focus');
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'blur');
        event.target.parentNode.classList.remove('focus');
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseout);
        event.target.parentNode.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseover);
        event.target.parentNode.classList.add('hover');
    }

    //function loadPushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString();
    //    var strQSCol = element.getAttribute('qs') || element.getAttribute('id');

    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function loadPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol && strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== element.getAttribute('value') && (strQSValue !== '' || !element.getAttribute('value'))) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                if (strQSValue !== element.getAttribute('value')) {
                    element.value = strQSValue;
                }
            }
        }

        element.internal.bolQSFirstRun = true;
    }



    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (element.hasAttribute('tabindex')) {
                    element.oldTabIndex = element.getAttribute('tabindex');
                    element.removeAttribute('tabindex');
                }

                element.refresh();

                loadPushReplacePopHandler(element);
                window.addEventListener('pushstate',    function () { loadPushReplacePopHandler(element); });
                window.addEventListener('replacestate', function () { loadPushReplacePopHandler(element); });
                window.addEventListener('popstate',     function () { loadPushReplacePopHandler(element); });
            }
        }
    }

    xtag.register('gs-search', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },
            inserted: function () {
                elementInserted(this);
            },
            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(element);
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);

                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'disabled') {
                        element.refresh();
                    } else if (strAttrName === 'value' && newValue !== oldValue) {
                        element.value = newValue;
                    }
                }
            }
        },
        events: {
            // on keydown and keyup sync the value attribute and the control value
            keydown: function (event) {
                if (!this.hasAttribute('readonly')) {
                    if (this.hasAttribute('disabled') && event.keyCode !== 9) {
                        event.preventDefault();
                        event.stopPropagation();
                    } else {
                        this.syncView();
                    }
                }
            },
            keyup: function () {
                if (!this.hasAttribute('readonly')) {
                    this.syncView();
                }
            },
            change: function () {
                var strQueryString = GS.getQueryString(), strColumn = (this.getAttribute('qs') || this.getAttribute('id'));

                if ((GS.qryGetVal(strQueryString, strColumn) || '') !== (this.control.value || '')) {
                    GS.pushQueryString(strColumn + '=' + encodeURIComponent(this.control.value));
                }
            }
        },
        accessors: {
            value: {
                // get value straight from the input
                get: function () {
                    if (this.control) {
                        return this.control.value;
                    } else {
                        return this.innerHTML;
                    }
                },

                // set the value of the input and set the value attribute
                set: function (strNewValue) {
                    var element = this;
                    if (element.control) {
                        if (element.control.value !== strNewValue) {
                            element.control.value = strNewValue;
                        }
                    } else {
                        element.innerHTML = strNewValue;
                    }
                    element.syncView();
                }
            }
        },
        methods: {
            focus: function () {
                if (this.control) {
                    this.control.focus();
                }
            },

            // adapt gs-input element to whatever control is in it and
            //      set the value of the control to the value attribute (if there is a value attribute) and
            //      resize the resize to text
            refresh: function () {
                var element = this;
                var arrPassThroughAttributes;
                var i;
                var len;

                element.innerHTML = '';
                element.appendChild(singleLineTemplate.cloneNode(true));
                if (element.oldTabIndex) {
                    xtag.query(element, '.control')[0].setAttribute('tabindex', element.oldTabIndex);
                }

                // set a variable with the control element for convenience and speed
                element.control = xtag.query(element, '.control')[0];

                element.control.removeEventListener('change', changeFunction);
                element.control.addEventListener('change', changeFunction);

                element.control.removeEventListener('focus', focusFunction);
                element.control.addEventListener('focus', focusFunction);

                element.control.removeEventListener('blur', blurFunction);
                element.control.addEventListener('blur', blurFunction);

                element.control.removeEventListener(evt.mouseout, mouseoutFunction);
                element.control.addEventListener(evt.mouseout, mouseoutFunction);

                element.control.removeEventListener(evt.mouseout, mouseoverFunction);
                element.control.addEventListener(evt.mouseover, mouseoverFunction);

                // if there is a value already in the attributes of the element: set the control value
                if (element.hasAttribute('value')) {
                    element.control.value = element.getAttribute('value');
                }

                // copy passthrough attributes to control
                arrPassThroughAttributes = [
                    'placeholder', 'name', 'type', 'maxlength', 'autocorrect',
                    'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                    'readonly'
                ];
                for (i = 0, len = arrPassThroughAttributes.length; i < len; i += 1) {
                    if (element.hasAttribute(arrPassThroughAttributes[i])) {
                        element.control.setAttribute(arrPassThroughAttributes[i], element.getAttribute(arrPassThroughAttributes[i]) || '');
                    }
                }
            },

            // sync control value and resize to text
            syncView: function () {
                if (this.control) {
                    if (this.getAttribute('value') !== this.control.value) {
                        this.setAttribute('value', this.control.value);
                    }
                } else {
                    this.innerHTML = this.control.value;
                }
            }
        }
    });
});window.addEventListener('design-register-element', function () {
    registerDesignSnippet('<gs-select>', '<gs-select>', 'gs-select>\n' +
                                                        '    <option>${0}</option>\n' +
                                                        '</gs-select>');

    designRegisterElement('gs-select', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-select.html');

    window.designElementProperty_GSSELECT = function(selectedElement) {
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))          { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop')) { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))  { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))   { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop')) { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))  { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))   { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var templateElement = document.createElement('template'), template;

    templateElement.innerHTML = '<select class="control" gs-dynamic></select>';
    template = templateElement.content;

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();

        GS.triggerEvent(event.target.parentNode, 'change');

        //return false;
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
        event.target.parentNode.classList.add('focus');
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'blur');
        event.target.parentNode.classList.remove('focus');
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseout);
        event.target.parentNode.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseover);
        event.target.parentNode.classList.add('hover');
    }


    //function createPushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');

    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function createPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.value = strQSValue;
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            var strValue = element.value, observer;

            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (strValue) {
                element.setAttribute('value', strValue);
                delete element.value;
            }

            // #############################################################
            // ##################### MUTATION OBSERVER #####################
            // #############################################################

            // create an observer instance
            observer = new MutationObserver(function(mutations) {
                var bolRefreshOptionList = true;

                // check each mutation: if only option and optgroup tags were added: refersh option tags in select
                mutations.forEach(function(mutation) {
                    var i, len;

                    for (i = 0, len = mutation.addedNodes.length; i < len; i += 1) {
                        if (mutation.addedNodes[i].nodeName !== 'OPTION' && mutation.addedNodes[i].nodeName !== 'OPTGROUP') {
                            bolRefreshOptionList = false;
                        }
                    }
                });

                if (bolRefreshOptionList) {
                    element.refreshOptionList();
                }
            });

            // pass in the element node, as well as the observer options
            observer.observe(element, {childList: true});
        }
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (element.hasAttribute('tabindex')) {
                    element.oldTabIndex = element.getAttribute('tabindex');
                    element.removeAttribute('tabindex');
                }

                element.refreshOptionList();

                //element.control.removeEventListener('change', changeFunction);
                element.control.addEventListener('change', changeFunction);

                //element.control.removeEventListener('focus', focusFunction);
                element.control.addEventListener('focus', focusFunction);

                //element.control.removeEventListener('blur', blurFunction);
                element.control.addEventListener('blur', blurFunction);

                //element.control.removeEventListener(evt.mouseout, mouseoutFunction);
                element.control.addEventListener(evt.mouseout, mouseoutFunction);

                //element.control.removeEventListener(evt.mouseover, mouseoverFunction);
                element.control.addEventListener(evt.mouseover, mouseoverFunction);

                // set the value from the value attribute (if it exists)
                if (element.getAttribute('value')) {
                    element.value = element.getAttribute('value');
                }

                //handle query-string
                if (element.getAttribute('qs')) {
                    //var strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.value = strQSValue;
                    //}
                    createPushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                }
            }
        }
    }

    xtag.register('gs-select', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value' && newValue !== oldValue) {
                        this.value = newValue;
                    }
                }
            }
        },
        events: {
            'keydown': function (event) {
                var intKeyCode = (event.keyCode || event.which);

                if (this.hasAttribute('readonly') &&
                        (
                            (
                                intKeyCode !== 9 && // if not tab and CMD, CTRL and SHFT are not down: prevent default
                                !event.metaKey &&
                                !event.ctrlKey &&
                                !event.shiftKey
                            ) ||
                            intKeyCode === 32 // if it's space: definitely prevent default
                        )) {
                    event.preventDefault();
                }
            },
            'keyup': function (event) {
                var intKeyCode = (event.keyCode || event.which);

                if (this.hasAttribute('readonly') &&
                        (
                            (
                                intKeyCode !== 9 && // if not tab and CMD, CTRL and SHFT are not down: prevent default
                                !event.metaKey &&
                                !event.ctrlKey &&
                                !event.shiftKey
                            ) ||
                            intKeyCode === 32 // if it's space: definitely prevent default
                        )) {
                    event.preventDefault();
                }
            },
            'mousedown': function (event) {
                if (this.hasAttribute('readonly')) {
                    if (evt.touchDevice === false) {
                        this.control.focus();
                    }
                    event.preventDefault();
                }
            },
            'mouseup': function (event) {
                if (this.hasAttribute('readonly')) {
                    event.preventDefault();
                }
            }
        },
        accessors: {
            value: {
                get: function () {
                    if (this.control) {
                        return this.control.value;
                    } else if (this.getAttribute('value')) {
                        return this.getAttribute('value');
                    }
                    return undefined;
                },

                set: function (newValue) {
                    if (this.getAttribute('value') !== newValue) {
                        this.setAttribute('value', newValue);
                    }
                    this.control.value = newValue;
                }
            },
            textValue: {
                get: function () {
                    return this.control.options[this.control.selectedIndex].text;
                },

                set: function (newValue) {
                    this.setAttribute('value', newValue);
                    this.control.value = newValue;
                }
            }
        },
        methods: {
            focus: function () {
                this.control.focus();
            },

            refreshOptionList: function () {
                var i, len, elementsToMove, oldvalue, arrChildren, controlElement;

                //console.log('refreshOptionList');

                // remove invalid elements from immediate children
                arrChildren = this.children;

                for (i = arrChildren.length - 1; i > -1; i -= 1) {
                    //console.log(arrChildren[i]);
                    if (arrChildren[i].nodeName !== 'OPTION' &&
                        arrChildren[i].nodeName !== 'OPTGROUP' &&
                        arrChildren[i].nodeName !== 'SELECT' &&
                        arrChildren[i].classList.contains('control')) {
                        this.removeChild(arrChildren[i]);
                    }
                }

                // if there is already a control
                controlElement = xtag.queryChildren(this, '.control')[0];

                if (controlElement) { //this.control && this.control.parentNode) {
                    // save the old value
                    oldvalue = controlElement.value;

                    // save the old control
                    this.oldcontrol = controlElement;

                    // remove the control class from the old control so that when
                    //      we select for the new control we dont get the old control
                    controlElement.classList.remove('control');
                }

                // append new control
                this.appendChild(template.cloneNode(true));

                // set a variable with the new control element for convenience and speed
                this.control = xtag.query(this, '.control')[0];

                // if there is an old control: get the options and optgroups out of it and move them to the new control
                if (this.oldcontrol) {
                    elementsToMove = xtag.queryChildren(this.oldcontrol, 'option, optgroup');

                    for (i = 0, len = elementsToMove.length; i < len; i += 1) {
                        elementsToMove[i].setAttribute('gs-hidden', '');

                        this.control.appendChild(elementsToMove[i]);
                    }
                }

                // fill the control with all of the option and optgroup tags that are direct descendents of the gs-select
                elementsToMove = xtag.queryChildren(this, 'option, optgroup');

                for (i = 0, len = elementsToMove.length; i < len; i += 1) {
                    this.control.appendChild(elementsToMove[i]);
                }

                // if there was an old control
                if (this.oldcontrol) {
                    // this if statement prevents an error when the gs-select shares and ID with another element
                    if (this.oldcontrol.parentNode === this) {
                        // remove the old control if it is currently a child of the select
                        this.removeChild(this.oldcontrol);
                    }

                    // set the oldcontrol variable to undefined so that the next time this function is run we dont get the old control
                    this.oldcontrol = undefined;

                    // set the value back to the old value
                    //console.log(this.getAttribute('value'));
                    this.control.value = this.getAttribute('value') || oldvalue;

                } else if (this.hasAttribute('value')) {
                    //alert(this.getAttribute('value'));
                    this.control.value = this.getAttribute('value');
                }

                if (this.oldTabIndex) {
                    this.control.setAttribute('tabindex', this.oldTabIndex);
                }
            }
        }
    });
});//global window, GS, addProp, registerDesignSnippet, designRegisterElement, setOrRemoveTextAttribute, setOrRemoveBooleanAttribute, encodeHTML, addFlexContainerProps, addFlexProps

window.addEventListener('design-register-element', function () {

    registerDesignSnippet('<gs-static>', '<gs-static>', 'gs-static column="${1:name}"></gs-static>');

    designRegisterElement('gs-static', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-static.html');

    window.designElementProperty_GSSTATIC = function (selectedElement) {
        addProp('Formatted&nbsp;Text', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('pre')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'pre', (this.value === 'true'), true);
        });

        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Inline', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('inline')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'inline', (this.value === 'true'), true);
        });

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility', true,
                '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                '    <option value="">Visible</option>' +
                '    <option value="hidden">Invisible</option>' +
                '    <option value="hide-on-desktop">Invisible at desktop size</option>' +
                '    <option value="hide-on-tablet">Invisible at tablet size</option>' +
                '    <option value="hide-on-phone">Invisible at phone size</option>' +
                '    <option value="show-on-desktop">Visible at desktop size</option>' +
                '    <option value="show-on-tablet">Visible at tablet size</option>' +
                '    <option value="show-on-phone">Visible at phone size</option>' +
                '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    //function createPushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //
    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function createPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value && !element.hasAttribute('value')) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = null;
            }
        }
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                //var strQSValue;
                element.refresh();

                if (element.getAttribute('qs')) {
                    //var strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.value = strQSValue;
                    //}
                    createPushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { createPushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { createPushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { createPushReplacePopHandler(element); });
                }
            }
        }
    }

    xtag.register('gs-static', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    this.refresh();
                }
            }
        },
        events: {},
        accessors: {
            value: {
                // get value straight from the input
                get: function () {
                    return this.getAttribute('value');
                },

                // set the value of the input and set the value attribute
                set: function (strNewValue) {
                    this.setAttribute('value', strNewValue);
                }
            }
        },
        methods: {
            refresh: function () {
                this.innerHTML = this.getAttribute('value');
            }
        }
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('<gs-sticky>', '<gs-sticky>', 'gs-sticky>\n' +
                                                        '    <gs-sticky-inner>\n' +
                                                        '        ${0}\n' +
                                                        '    </gs-sticky-inner>\n' +
                                                        '</gs-sticky>');

    designRegisterElement('gs-sticky', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-sticky.html');

    window.designElementProperty_GSSTICKY = function (selectedElement) {
        addProp('Direction', true,  '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('direction') || '') + '" mini>' +
                                        '<option value="">Up</option>' +
                                        '<option value="down">Down</option>' +
                                    '</gs-select>',
                                    function () {
            return setOrRemoveTextAttribute(selectedElement, 'direction', this.value);
        });

        addProp('Always Stuck', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('stuck') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'stuck', this.value === 'true', true);
        });

        addProp('Touch Devices Allowed', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('touch-device-allowed') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'touch-device-allowed', this.value === 'true', true);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    function stickHandler(element) {
        var bolTop = (element.getAttribute('direction') !== 'down'),
            intScrollPosition = document.body.scrollTop,
            jsnElementPositionData = GS.getElementPositionData(element),
            bolShouldBeStuck = (bolTop && jsnElementPositionData.intRoomAbove < 0) || (!bolTop && jsnElementPositionData.intRoomBelow < 0);

        if (bolShouldBeStuck && !element.hasAttribute('stuck')) {
            element.style.height = element.offsetHeight + 'px';
            element.setAttribute('stuck', '');

            //if (bolTop) {
            //    element.parentNode.style.paddingTop = element.offsetHeight + 'px';
            //} else {
            //    element.parentNode.style.paddingBottom = element.offsetHeight + 'px';
            //}

        } else if (!bolShouldBeStuck && element.hasAttribute('stuck')) {
            element.style.height = '';
            element.removeAttribute('stuck');
            //
            //if (bolTop) {
            //    element.parentNode.style.paddingTop = '';
            //} else {
            //    element.parentNode.style.paddingBottom = '';
            //}
        }

        //console.log(bolTop, intScrollPosition, jsnElementPositionData);
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    //
    function elementInserted(element) {
        var currentParent;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                if (element.children.length > 1) {
                    throw 'gs-sticky Error: Too many children. gs-sticky elements must have one child and it must be a <gs-sticky-inner> element.';

                } else if (element.children.length === 0) {
                    throw 'gs-sticky Error: No children. gs-sticky elements must have one child and it must be a <gs-sticky-inner> element.';

                } else if (element.children[0].nodeName !== 'GS-STICKY-INNER') {
                    throw 'gs-sticky Error: Invalid child. gs-sticky elements must have one child and it must be a <gs-sticky-inner> element.';
                }

                element.parentNode.style.height = 'auto';

                if (element.hasAttribute('stuck')) {
                    //console.log(element.children[0].offsetHeight, element.getAttribute('direction'));
                    if (element.getAttribute('direction') !== 'down') {
                        element.parentNode.style.paddingTop = element.children[0].offsetHeight + 'px';
                    } else {
                        element.parentNode.style.paddingBottom = element.children[0].offsetHeight + 'px';
                    }
                }

                if (!element.hasAttribute('stuck') && (!evt.touchDevice || element.hasAttribute('touch-device-allowed'))) {
                    stickHandler(element);
                    currentParent = element.parentNode;
                    if (currentParent.nodeName !== 'BODY') {
                        console.warn('gs-sticky Warning: Element not immediate child of BODY. This element was designed for being an immediate child of the BODY, doing otherwise may give unexpected results.');
                    }

                    window.addEventListener('resize', function () {
                        if (element.parentNode === currentParent) {
                            stickHandler(element);
                        }
                    });

                    window.addEventListener('scroll', function () {
                        if (element.parentNode === currentParent) {
                            stickHandler(element);
                        }
                    });

                    window.addEventListener('orientationchange', function () {
                        if (element.parentNode === currentParent) {
                            stickHandler(element);
                        }
                    });
                }
            }
        }
    }

    xtag.register('gs-sticky-inner', {});
    xtag.register('gs-sticky', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {

                }
            }
        },
        events: {},
        accessors: {},
        methods: {}
    });
});//global window, document, GS, ml, encodeHTML, addFlexContainerProps, addFlexProps, addProp, registerDesignSnippet, designRegisterElement, setOrRemoveTextAttribute, setOrRemoveBooleanAttribute, xtag, doT

window.addEventListener('design-register-element', function () {
    'use strict';
    registerDesignSnippet('<gs-switch>', '<gs-switch>', 'gs-switch>\n' +
                                                        '    <template for="${1:none}"></template>\n' +
                                                        '    <template for="${2:detail}"></template>\n' +
                                                        '</gs-switch>');

    designRegisterElement('gs-switch', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-switch.html');

    window.designElementProperty_GSSWITCH = function (selectedElement) {

        addProp('Template', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'template', this.value);
        });

        addProp('Refresh On Querystring Columns', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('refresh-on-querystring-values') || '') + '" mini></gs-text>', function () {
            this.removeAttribute('refresh-on-querystring-change');
            return setOrRemoveTextAttribute(selectedElement, 'refresh-on-querystring-values', this.value);
        });

        addProp('Refresh On Querystring Change', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('refresh-on-querystring-change')) + '" mini></gs-checkbox>', function () {
            this.removeAttribute('refresh-on-querystring-values');
            return setOrRemoveBooleanAttribute(selectedElement, 'refresh-on-querystring-change', this.value === 'true', true);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    function subsafeTemplate(strTemplate) {
        var templateElement = document.createElement('template');
        var strID;
        var arrTemplates;
        var i;
        var len;
        var jsnTemplates;
        var strRet;
        var arrTemplateNames;

        templateElement.innerHTML = strTemplate;

        // temporarily remove templates. recursively go through templates whose parents do not have the source attribute
        i = 0;
        arrTemplates = xtag.query(templateElement.content, 'template');

        jsnTemplates = {};
        arrTemplateNames = [];

        while (arrTemplates.length > 0 && i < 100) {
            //console.log(arrTemplates[0]);
            //console.log(arrTemplates[0].parentNode);
            //console.log(arrTemplates[0].parentNode.hasAttribute('src'));

            // if the current template has a source parent: remove temporarily
            if (
                arrTemplates[0].parentNode &&
                arrTemplates[0].parentNode.hasAttribute &&
                (
                    arrTemplates[0].parentNode.hasAttribute('src') ||
                    arrTemplates[0].parentNode.hasAttribute('source')
                )
            ) {
                strID = 'UNIqUE_PLaCEhOLDER-' + GS.GUID() + '-UNiQUE_PLaCEhOLdER';
                jsnTemplates[strID] = arrTemplates[0].outerHTML;
                arrTemplates[0].outerHTML = strID;
                arrTemplateNames.push(strID);

            // else: add to the arrTemplates array
            } else if (arrTemplates[0].content) {
                arrTemplates.push.apply(arrTemplates, xtag.query(arrTemplates[0].content, 'template'));
            }

            // remove the current template from the arrTemplates array
            arrTemplates.splice(0, 1);

            i += 1;
        }

        strRet = doT.template(
            '{{##def.snippet:\n' +
                    '    {{ var qs = GS.qryToJSON(GS.getQueryString()); }} {{# def.template }}\n' +
                    '#}}\n' +
                    '{{#def.snippet}}',
            null,
            {"template": templateElement.innerHTML}
        )();

        i = 0;
        len = arrTemplateNames.length;
        //for (strID in jsnTemplates) {
        while (i < len) {
            // DO NOT DELETE THE REPLACE, it allows single dollar signs to be inside dot notation
            strRet = strRet.replace(
                new RegExp(arrTemplateNames[i], 'g'),
                jsnTemplates[arrTemplateNames[i]].replace(/\$/g, '$$$$')
            );
            i += 1;
        }

        return strRet;
    }

    //function pushReplacePopHandler(element) { //, eventName
    //    var i;
    //    var len;
    //    var arrPopKeys = [];
    //    var bolRefresh = false;
    //    var strQS = GS.getQueryString();
    //    var currentValue;
    //    var strQSCol = element.getAttribute('qs');

    //    //console.log(eventName);

    //    if (element.hasAttribute('refresh-on-querystring-values') || element.hasAttribute('qs')) {
    //        if (element.hasAttribute('refresh-on-querystring-values')) {
    //            arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
    //        }
    //        if (strQSCol && GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
    //            GS.listAdd(arrPopKeys, strQSCol);
    //        }

    //        //for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
    //        i = 0;
    //        len = arrPopKeys.length;
    //        while (i < len) {
    //            currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);

    //            if (element.popValues[arrPopKeys[i]] !== currentValue) {
    //                //console.log(arrPopKeys[i], element.popValues[arrPopKeys[i]], currentValue);
    //                bolRefresh = true;
    //            }

    //            element.popValues[arrPopKeys[i]] = currentValue;
    //            i += 1;
    //        }
    //    } else {
    //        bolRefresh = true;
    //    }

    //    if (bolRefresh) {
    //        element.refresh();
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var arrPopKeys;
        var currentValue;
        var bolRefresh = false;
        var strOperator;

        if (strQSCol && strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        }

        // handle "refresh-on-querystring-values" and "refresh-on-querystring-change" attributes
        if (element.internal.bolQSFirstRun === true) {
            if (element.hasAttribute('refresh-on-querystring-values') || element.hasAttribute('qs')) {
                if (element.getAttribute('refresh-on-querystring-values')) {
                    arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                } else {
                    arrPopKeys = [];
                }

                if (strQSCol) {
                    GS.listAdd(arrPopKeys, strQSCol);
                }

                i = 0;
                len = arrPopKeys.length;
                //for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                while (i < len) {
                    currentValue = GS.qryGetVal(strQS, arrPopKeys[i]);

                    if (element.popValues[arrPopKeys[i]] !== currentValue) {
                        bolRefresh = true;
                    }

                    element.popValues[arrPopKeys[i]] = currentValue;
                    i += 1;
                }

            } else if (element.hasAttribute('refresh-on-querystring-change')) {
                bolRefresh = true;
            } else if (element.hasAttribute('template') || element.hasAttribute('value')) {
                bolRefresh = true;
            }

            if (bolRefresh) {
                element.refresh();
            }
        } else {
            if (element.hasAttribute('refresh-on-querystring-values')) {
                arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);

                i = 0;
                len = arrPopKeys.length;
                //for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                while (i < len) {
                    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQS, arrPopKeys[i]);
                    i += 1;
                }
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                // transfer 'value' attribute to 'template'
                if (element.hasAttribute('value')) {
                    element.setAttribute('template', element.getAttribute('value'));
                    console.warn('gs-switch Warning: "value" attribute is deprecated. Please use the "template" attribute to replace the "value" attribute.', element);
                }

                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                // Get templates and define some variables
                var arrTemplate = xtag.queryChildren(element, 'template');
                var i;
                var len;
                var attr_i;
                var attr_len;
                var arrAttrNames;
                var arrAttrValues;
                var strAttrName;
                var root;
                var template;
                var arrPopKeys;
                var strQueryString;
                var strQSCol;

                element.attributesFromTemplate = [];
                element.templates = {};

                //for (i = 0, len = arrTemplate.length; i < len; i += 1) {
                i = 0;
                len = arrTemplate.length;
                while (i < len) {
                    if (i === 0) {
                        element.firstTemplate = arrTemplate[i].getAttribute('for') || arrTemplate[i].getAttribute('id');
                    }

                    arrAttrNames = [];
                    arrAttrValues = [];

                    attr_i = 0;
                    attr_len = arrTemplate[i].attributes.length;
                    //for (attr_i = 0, attr_len = arrTemplate[i].attributes.length; attr_i < attr_len; attr_i += 1) {
                    while (attr_i < attr_len) {
                        strAttrName = arrTemplate[i].attributes[attr_i].nodeName;

                        if (strAttrName !== 'for' && strAttrName !== 'id') {
                            arrAttrNames.push(strAttrName);
                            arrAttrValues.push(arrTemplate[i].attributes[attr_i].value);
                        }
                        attr_i += 1;
                    }

                    template = arrTemplate[i];
                    element.templates[template.getAttribute('for') || template.getAttribute('id')] = {
                        'content': template.innerHTML,
                        'arrAttrNames': arrAttrNames,
                        'arrAttrValues': arrAttrValues,
                        'templated': !(element.hasAttribute('static') || template.hasAttribute('static'))
                    };
                    if (!(element.hasAttribute('static') || template.hasAttribute('static')) &&
                        (
                            element.templates[template.getAttribute('for') || template.getAttribute('id')].content.indexOf('&gt;') > -1 ||
                            element.templates[template.getAttribute('for') || template.getAttribute('id')].content.indexOf('&lt;') > -1
                        )) {
                        console.warn('GS-SWITCH WARNING: &gt; or &lt; detected in "' + (template.getAttribute('for') || template.getAttribute('id')) + '" template, this can have undesired effects on doT.js. Please use gt(x,y), gte(x,y), lt(x,y), or lte(x,y) to silence this warning.');
                    }

                    i += 1;
                }

                // Clear out the templates from the DOM
                element.innerHTML = '';

                element.arrQueryStringAttributes = [];
                element.popValues = {};

                if (
                    (
                        element.hasAttribute('template') &&
                        element.getAttribute('template').indexOf('{{') > -1
                    ) ||
                    element.hasAttribute('qs') ||
                    element.hasAttribute('refresh-on-querystring-values') ||
                    element.hasAttribute('refresh-on-querystring-change')
                ) {
                    //arrPopKeys = [];
                    //strQueryString = GS.getQueryString();
                    //strQSCol = element.getAttribute('qs');

                    //if (element.hasAttribute('refresh-on-querystring-values')) {
                    //    arrPopKeys = element.getAttribute('refresh-on-querystring-values').split(/\s*,\s*/gim);
                    //}
                    //if (strQSCol && GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
                    //    GS.listAdd(arrPopKeys, strQSCol);
                    //}

                    //i = 0;
                    //len = arrPopKeys.length;
                    ////for (i = 0, len = arrPopKeys.length; i < len; i += 1) {
                    //while (i < len) {
                    //    element.popValues[arrPopKeys[i]] = GS.qryGetVal(strQueryString, arrPopKeys[i]);
                    //    i += 1;
                    //}
                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate', function () {
                        pushReplacePopHandler(element);
                    });
                    window.addEventListener('replacestate', function () {
                        pushReplacePopHandler(element);
                    });
                    window.addEventListener('popstate', function () {
                        pushReplacePopHandler(element);
                    });
                }

                element.refresh();
            }
        }
    }

    xtag.register('gs-switch', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(element);
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);

                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value') { // && oldValue !== newValue
                        //element.refresh();
                        element.setAttribute('template', newValue);
                        console.warn('gs-switch Warning: "value" attribute is deprecated. Please use the "template" attribute to replace the "value" attribute.', element);

                    } else if (strAttrName === 'template' && element.inserted === true) {
                        element.refresh();
                    }
                }
            }
        },
        events: {},
        accessors: {
            value: {
                get: function () {
                    var element = this;
                    console.warn('gs-switch Warning: \'.value\' accessor is deprecated. Please use the \'.template\' accessor to replace the \'.value\' accessor.', element);
                    return element.getAttribute('template');
                },
                set: function (newValue) {
                    var element = this;
                    console.warn('gs-switch Warning: \'.value\' accessor is deprecated. Please use the \'.template\' accessor to replace the \'.value\' accessor.', element);
                    element.setAttribute('template', newValue);
                }
            },
            template: {
                get: function () {
                    return this.getAttribute('template');
                },
                set: function (newValue) {
                    this.setAttribute('template', newValue);
                }
            }
        },
        methods: {
            refresh: function () {
                var element = this;
                var strQueryString = GS.getQueryString();
                var strQSAttribute = element.getAttribute('qs');
                var strValueAttribute = element.getAttribute('template') || element.getAttribute('value');
                var templateName;
                var i;
                var len;

                if (strQSAttribute && GS.qryGetVal(strQueryString, strQSAttribute)) {
                    templateName = GS.qryGetVal(strQueryString, strQSAttribute);
                } else if (strValueAttribute) {
                    templateName = GS.templateWithQuerystring(strValueAttribute);
                }

                templateName = templateName || element.firstTemplate;

                if (element.templates[templateName] && element.templates[templateName].content) {
                    // if there are values in element.attributesFromTemplate
                    if (element.attributesFromTemplate.length > 0) {
                        // loop through them
                        i = 0;
                        len = element.attributesFromTemplate.length;
                        //for (i = 0, len = element.attributesFromTemplate.length; i < len; i += 1) {
                        while (i < len) {
                            // if attribute was initallySet: set it back to initalvalue
                            if (element.attributesFromTemplate[i].initallySet) {
                                element.setAttribute(element.attributesFromTemplate[i].name, element.attributesFromTemplate[i].initalValue);

                            // else: remove it
                            } else {
                                element.removeAttribute(element.attributesFromTemplate[i].name);
                            }
                            i += 1;
                        }
                    }

                    // clear element.attributesFromTemplate
                    element.attributesFromTemplate = [];

                    // if there are values in element.templates[templateName].arrAttrNames
                    if (element.templates[templateName].arrAttrNames.length > 0) {
                        // loop through them
                        i = 0;
                        len = element.templates[templateName].arrAttrNames.length;
                        //for (i = 0, len = element.templates[templateName].arrAttrNames.length; i < len; i += 1) {
                        while (i < len) {
                            // add to element.attributesFromTemplate
                            element.attributesFromTemplate.push({
                                'name': element.templates[templateName].arrAttrNames[i],
                                'initallySet': element.hasAttribute(element.templates[templateName].arrAttrNames[i]),
                                'initalValue': element.getAttribute(element.templates[templateName].arrAttrNames[i])
                            });

                            // set attribute
                            element.setAttribute(element.templates[templateName].arrAttrNames[i], GS.templateWithQuerystring(this.templates[templateName].arrAttrValues[i]));
                            i += 1;
                        }
                    }

                    if (element.templates[templateName].templated) {
                        element.innerHTML = subsafeTemplate(element.templates[templateName].content);
                    } else {
                        element.innerHTML = element.templates[templateName].content;
                    }

                    // if template is not native: handle templates inside the switch
                    if (shimmed.HTMLTemplateElement) {
                        window.HTMLTemplateElement.bootstrap(element);
                    }
                    //console.trace('trace this');
                    GS.triggerEvent(element, 'templatechange', {'templateName': templateName});
                    GS.triggerEvent(element, 'template_change', {'templateName': templateName});
                } else {
                    element.innerHTML = '';
                }
            }
        }
    });
});//global GS, xtag, document, window, ml, evt, doT, Worker
//jslint browser:true, maxlen:80, white:false, this:true


/*
new datasheet
    select, insert, update,
        delete, copy, paste and selection events (prevent default)
    programatic select, insert, update,
        delete, copy, paste and selection (events marked as programatic)

    fixed headers/record selectors
    ace scrolling
    insert record

    data source is not required (column list is required if no data source)

    header, record, insert record templating (dot.js)

    placeholder for null values
    value to set value as null

    headers, record selectors, insert record are all optional

    copy settings (
        headers always|never|whenselected
        record selectors always|never|whenselected
        quote char
        quote when never|strings|always
        record delim char
        cell delim char
        null value string
    )
    no more table element

    selection is stored as ranges
    backwards compatible attributes (transfer to new names and warn)


element name:
    <gs-table></gs-table>

helper elements:
    <gs-cell></gs-cell>

attributes:
    pk
    lock
    seq
    cols (required if no src)
    src
    where
    session-filter (where clause that can be overridden by the user)
    ord
    limit
    offset
    column
    child-column
    qs
    refresh-on-querystring-values
    refresh-on-querystring-change

    reflow-at (future)
    scroll-past-bottom
        (allows you to scroll until only the bottom record is seen)
    scroll-to-bottom (scrolls all the way down on initial load)
    expand-to-content

    no-hudpaginate
    no-hudrefresh
    no-huddelete
    no-filter

    suspend-created
    suspend-inserted

    no-header
    no-record-selector
    no-selection

    null-string (defaults to "")
    null-set-string (defaults to null-string attribute)

    no-resize-column
    no-resize-record

    default-record-height (pixels, defaults if not present)
    default-column-width (pixels, defaults if not present)
    column-border-width (pixels, defaults if not present)
    record-border-height (pixels, defaults if not present)

    socket (name of a property stored on the GS object, needs to be a socket)

    copy-header           always|never|selected
    copy-selectors        always|never|selected
    copy-quote-char       text
    copy-escape-char      text
    copy-quote-when       never|strings|always|delimiter-in-content
    copy-delimiter-record text
    copy-delimiter-cell   text
    copy-null-cell        text

templates: (all are dot.js templated before use)
    for="hud" (snippet contains default
                    insert/update/delete/refresh/filter/paginate elements)
    for="header-record"
        <gs-cell>HEADERTEXT</gs-cell>
    for="data-record"
        <gs-cell header="HEADERTEXT">
            <gs-text mini column="COLUMNNAME"></gs-text>
        </gs-cell>
    for="insert-record"
        <gs-cell header="HEADERTEXT" target="COLUMNNAME"></gs-cell>
    for="insert-dialog"

accessors:
    selection (contains JS array of selection ranges)
    data (contains TSV of all data)
    value (value attribute)

events:
    before_select (contains TSV of selection under "records" key)
    before_insert (contains TSV of insert under "records" key)
    before_update (contains TSV of old/new under "records" key ("old", "new"))
    before_delete (contains TSV of delete under "records" key)
    before_selection (contains TSV of selection ranges under "selection" key)

    after_select (contains TSV of selection under "records" key)
    after_insert (contains TSV of insert under "records" key)
    after_update (contains TSV of old/new under "records" key ("old", "new"))
    after_delete (contains TSV of delete under "records" key)
    after_selection (contains TSV of selection ranges under "selection" key)

    insert_dialog_open (event.relatedTarget = insert dialog)
    copy
    paste

methods:
    refresh
    render
    scrollToIndex(cell_number, record_number)
    clearSelection()
    addSelectionRange(
        fromCell_number,
        fromRecord_number,
        toCell_number,
        toRecord_number,
        bolNegate (default false)
    )
    getCopyString(
        strMimeType text|html
    )
    paste(paste_string)
    filter(
        filterColumn,
        filterType contains|starts|ends|equals|greaterthan|lessthan,
        showIfMatch true|false,
        filterValue
    )
    selectData
    insertData
    updateData
    deleteData

click behavior:
    if click results in focused input/textarea
            and start/end locations are in the same place:
        select all control contents
    if not no-filter and click results in focused control: filter popup tooltip

mousedown-drag:
    if shift:
        move latest selection range's endpoint
    if no shift:
        clear all selections
        start new selection
    if command/control:
        start new selection
        if selection started on an already selected cell:
            selection is a negator selection

selection behavior:
    if selection origin and end is on a record selector:
        select entire records
    if selection origin and end is on a header selector:
        select entire columns
    if selection origin starts and ends on the top-left selector:
        select all cells
    if selection endpoint is off-screen:
        scroll it to middle

focus behavior:
    cell/record focus location is saved
        (if cell is visible after a render, focus into it)
        (removed on blur)
    on selection with no focused control: focus hidden control
    on mousedown inside the element (on unfocusable element):
        focus hidden control
    on blur after cell change: cause update
    on focus of single cell: set selection to focused cell

copy behavior:
    never copy insert record
    on copy event and hidden focus control is focused:
        copy to html mime type (using applicable copy attributes)
        copy to text mime type (using applicable copy attributes)
    if a record is not selected: no space is made for it in the copy
    if a column is not selected: no space is made for it in the copy

key behavior:
    arrowing around selects the cell, doesn't focus the control
    return on selection focuses selection origin cell control
    "delete"/"forward delete" when no control is focused causes record delete
    on return after cell change: cause update

    if arrow:
        if shift:
            "selection" means selection end of latest selection range
        if no shift:
            clear all selection ranges
            "selection" means selection origin/end of new selection range

        if all contents selected because of arrow
            or
        if cursor is at boundary in the direction of the arrow:
            if there is a cell in the direction of the arrow:
                move selection in direction of arrow
            else:
                if right at last cell of record: first cell of next record
                if right at last cell of table: first cell of table
                if left at first cell of record: last cell of previous record
                if left at first cell of table: last cell of table
                if up at first cell of column: previous column of bottom record
                if down at last cell of column: next column of first record

scrollbar behavior:
    whenever the record count is changed: the scrollbar is rerendered
    the scrollbar has a maximum range, stop growing around this height
    if scrollbar is past max height, you'll need to translate the top
        into (1px of scroll height will = >1px of motion)
    after scroll: rerender location
    phone scroll: no scrollbar, needs elastic motion
    scroll render:
        if scrollTop is >0     header shadow
        if scrollLeft is >0    record selector shadow
        if scrollBottom is >0  insert record shadow
        if scrollRight is >0   right side shadow

loader behavior:
    when enabled: a small spinner shows at the top-right of the data area

delete behavior:
    always asks if you're sure
    after success:
        remove record from internal data,
        render current location,
        clear selection range if it's now out of bounds
    during delete: enable element loader
    after delete is initiated: record is no longer clickable

insert behavior:
    asks if you're sure only when inserting multiple records (using paste)
    after success:
        append new data to the end of internal data,
        scroll to bottom,
        render current location,
        clear selection range
    during insert: enable element loader

update behavior:
    asks if you're sure only when updating multiple records (using paste)
    after success:
        update whole record in internal data,
        render current location,
        clear selection range
    during update: enable element loader
    if an update is caused while another update is still resolving: add to queue

select behavior:
    first load: if scroll-to-bottom: scroll to reveal bottom record
    reload: always returns to previous scroll/focus/textselection situation
    during load: enable element loader
*/







// # CODE INDEX:
//          (use "find" (CTRL-f or CMD-f) to skip to a section)
//          ("PRE-RENDER" refers to a section of functions that do not depend
//                  on the viewport being rendered AND dont use any render
//                  functions)
//          ("POST-RENDER" refers to a section of functions that either depend
//                  on the viewport being rendered OR use render functions)
//      # TOP  (this just brings you back this index)
//      # ELEMENT CONFIG
//      # GLOBAL <STYLE></STYLE> ELEMENT SETUP
//      # SCROLLBAR WIDTH
//      # CELL DIMENSION DETECTOR
//      # EXTERIOR LIBRARIES
//          # GETPLAINTEXT
//      # PRE-RENDER UTILITY FUNCTIONS
//      # ELEMENT FUNCTIONS
//      # RENDER FUNCTIONS
//      # POST-RENDER UTILITY FUNCTIONS
//      # LOADER FUNCTIONS
//      # DATA FUNCTIONS
//      # COPY FUNCTIONS
//      # PASTE FUNCTIONS
//      # BUTTON FUNCTIONS
//      # EVENT FUNCTIONS
//          # FOCUS EVENTS
//          # SCROLL EVENTS
//          # SELECTION EVENTS
//          # COLUMN/ROW RESIZE EVENTS
//          # COLUMN REORDER EVENTS
//          # UPDATE EVENTS
//          # INSERT EVENTS
//          # HUD EVENTS
//          # KEY EVENTS
//          # COPY EVENTS
//          # PASTE EVENTS
//          # CUT EVENTS
//          # CONTEXTMENU EVENTS
//          # COLUMN DROPDOWN EVENTS
//          # DEVELOPER EVENTS
//          # HIGH LEVEL BINDING
//      # XTAG DEFINITION
//      # ELEMENT LIFECYCLE
//      # ELEMENT ACCESSORS
//      # ELEMENT METHODS

// for sections of code that need to be completed:
//      # NEED CODING


document.addEventListener('DOMContentLoaded', function () {
    'use strict';
// ############################################################################
// ############################## ELEMENT CONFIG ##############################
// ############################################################################

    var intDefaultRecordHeight = 27; // pixels
    var intDefaultColumnWidth = 75; // pixels

// ############################################################################
// ############################ GLOBAL ID SEQUENCE ############################
// ############################################################################

    var globalIDSeq = 0;

// ############################################################################
// ################### GLOBAL <STYLE></STYLE> ELEMENT SETUP ###################
// ############################################################################

    // we need to dynamically generate some CSS because of browser/OS
    //      differences, so here we create the global style element. This
    //      element may only have CSS appended to it at this global level, not
    //      after gs-table elements are instantiated.
    var globalStyleElement = document.createElement("style");
    globalStyleElement.setAttribute("id", "gs-table-style-container");
    document.head.appendChild(globalStyleElement);

// #############################################################################
// ############################## SCROLLBAR WIDTH ##############################
// #############################################################################

    // we need to handle scrollbar width dynamically because different operating
    //      systems have different scrollbar widths, this section deals with the
    //      scrollbar width for all gs-table elements at the same time.

    // return scrollbar width
    function getScrollBarWidth() {
        var container = document.createElement("div");
        var detector = document.createElement("div");
        var ret;

        document.body.appendChild(container);
        container.appendChild(detector);

        container.style.width = "100px";
        container.style.height = "100px";
        container.style.opacity = "0.2";
        container.style.overflow = "scroll";

        detector.style.display = "inline-block";
        detector.style.width = "10px";
        detector.style.height = "100%";
        //detector.style.background = "#F00";

        ret = 100 - detector.offsetHeight;
        document.body.removeChild(container);

        return ret;
    }

    // save scrollbar width to variable
    var intScrollbarWidth = getScrollBarWidth();

    // we need some CSS specifically to handle the scrollbar,
    //      this function returns that CSS
    function createGlobalScrollbarStyles() {
        var intScrollbarWidthPadded;

        // this variable creates 1px pixels of space in the green box in the
        //      bottom-right corner to make it look well sized and match up
        //      well with the borders around it.
        intScrollbarWidthPadded = (intScrollbarWidth + 1);

        // on an iPhone, scrollbars are hidden
        if (intScrollbarWidth === 0) {
            return 'gs-table > ' +
                    '        .table-root > ' +
                    '        .table-table-container > ' +
                    '        .table-data-container {\n' +
                    '    padding-bottom: 0px;\n' +
                    '    padding-right: 0px;\n' +
                    '}\n' +
                    // hide scrollbar containers
                    'gs-table > ' +
                    '        .table-root > ' +
                    '        .table-table-container > ' +
                    '        .table-v-scroll-bar-container {\n' +
                    '    width: 0px;\n' +
                    '    padding-bottom: 0px;\n' +
                    '    display: none;\n' +
                    '}\n' +
                    // hide scrollbar containers
                    'gs-table > ' +
                    '        .table-root > ' +
                    '        .table-table-container > ' +
                    '        .table-h-scroll-bar-container {\n' +
                    '    height: 0px;\n' +
                    '    padding-right: 0px;\n' +
                    '    display: none;\n' +
                    '}\n' +
                    // remove viewport border
                    'gs-table >\n' +
                    '        .table-root >\n' +
                    '        .table-table-container >\n' +
                    '        .table-data-container >\n' +
                    '        .table-data-viewport {\n' +
                    '    border-right: 0 none;\n' +
                    '    border-bottom: 0 none;\n' +
                    '}';
        }

        return 'gs-table > ' +
                '        .table-root > ' +
                '        .table-table-container > ' +
                '        .table-data-container {\n' +
                '    padding-bottom: ' + intScrollbarWidth + 'px;\n' +
                '    padding-right: ' + intScrollbarWidth + 'px;\n' +
                '}\n' +
                'gs-table > ' +
                '        .table-root > ' +
                '        .table-table-container > ' +
                '        .table-v-scroll-bar-container {\n' +
                '    width: ' + intScrollbarWidth + 'px;\n' +
                '    padding-bottom: ' + intScrollbarWidthPadded + 'px;\n' +
                '}\n' +
                'gs-table > ' +
                '        .table-root > ' +
                '        .table-table-container > ' +
                '        .table-h-scroll-bar-container {\n' +
                '    height: ' + intScrollbarWidth + 'px;\n' +
                '    padding-right: ' + intScrollbarWidthPadded + 'px;\n' +
                '}';
    }

    // append scrollbar-specific CSS to global style element
    globalStyleElement.innerHTML += createGlobalScrollbarStyles();

// #############################################################################
// ########################## CELL DIMENSION DETECTOR ##########################
// #############################################################################

    // we need to be able to detect the cell/border widths/heights dynamically
    //      so that the scrolling functionality can calculate true dimensions
    //      and so that records/columns (which may be dynamically resized) will
    //      have defaults
    function cellDimensionDetector(element) {
        var testDataCell = element.elems.testDataCell;
        var testHeader = element.elems.testHeader;
        var testInsert = element.elems.testInsert;
        var testRecordSelector = element.elems.testRecordSelector;

        // first, we'll look at data record/cell dimensions
        element.internalDisplay.columnBorderWidth = parseInt(
            (GS.getStyle(testDataCell, 'border-right-width') || '0'),
            10
        );
        element.internalDisplay.recordBorderHeight = parseInt(
            (GS.getStyle(testDataCell, 'border-bottom-width') || '0'),
            10
        );
        element.internalDisplay.defaultColumnWidth = parseInt(
            (GS.getStyle(testDataCell, 'width') || '0'),
            10
        );
        element.internalDisplay.defaultRecordHeight = parseInt(
            (GS.getStyle(testDataCell, 'height') || '0'),
            10
        );

        // next, we'll look at header dimensions
        element.internalDisplay.headerBorderHeight = parseInt(
            (GS.getStyle(testHeader, 'border-bottom-width') || '0'),
            10
        );

        // next, we'll look at insert cell dimensions
        element.internalDisplay.insertRecordBorderHeight = parseInt(
            (GS.getStyle(testInsert, 'border-bottom-width') || '0'),
            10
        );

        // next, we'll look at record selector cell dimensions
        element.internalDisplay.recordSelectorBorderWidth = parseInt(
            (GS.getStyle(testRecordSelector, 'border-right-width') || '0'),
            10
        );
    }

    // we need to know if headers, record selectors or the insert record is
    //      being used. this is so that we can determine the amount of space
    //      to put on each side of the viewport for the data
    function visibilityDetector(element) {
        // we reset everything to visible here so that the code is shorter
        // (innocent until proven guilty)
        element.internalDisplay.headerVisible = true;
        element.internalDisplay.recordSelectorVisible = true;
        element.internalDisplay.insertRecordVisible = true;

        // we are checking to see if the header template is empty or just all
        //      whitespace, if it is: we're setting headers to visibility=false
        if (
            !element.internalTemplates.header ||
            !element.internalTemplates.header.trim()
        ) {
            element.internalDisplay.headerVisible = false;
        }

        // we are checking to see if the "no-record-selector" attribute is
        //      present, if it is: we're setting the record selectors to
        //      visibility=false
        if (element.hasAttribute('no-record-selector')) {
            element.internalDisplay.recordSelectorVisible = false;
        }

        // we are checking to see if the insert record template is empty or
        //      just all whitespace, if it is: we're setting the insert record
        //      to visibility=false
        if (
            !element.internalTemplates.insertRecord ||
            !element.internalTemplates.insertRecord.trim()
        ) {
            element.internalDisplay.insertRecordVisible = false;
        }
    }

    // we need to calculate the amount of space to put on each side of the
    //      viewport depending on what features are visible (header, record
    //      selectors, insert record). so, if the insert record is visible
    //      we need to tell everything else that that space is not usable for
    //      anything else
    function offsetDetector(element) {
        // we reset all of the offsets to zero because the way we calculate
        //      the offsets is that we increment the offset if something is
        //      visible (increment/decrement only, no resets after this point)
        element.internalScrollOffsets.top = 0;
        element.internalScrollOffsets.left = 0;
        element.internalScrollOffsets.bottom = 0;
        element.internalScrollOffsets.right = 0;

        // if the header is visible, we want to add the height of the header
        //      (plus it's border) to the top offset
        if (
            element.internalDisplay.headerVisible &&
            element.internalDisplay.headerStick === 'top'
        ) {
            element.internalScrollOffsets.top += (
                element.internalDisplay.headerHeight +
                element.internalDisplay.headerBorderHeight
            );
        }

        // if the record selectors are visible, we want to add the width of
        //      the record selectors (plus the border) to the left offset
        if (
            element.internalDisplay.recordSelectorVisible &&
            element.internalDisplay.selectorStick === 'left'
        ) {
            element.internalScrollOffsets.left += (
                element.internalDisplay.recordSelectorWidth +
                element.internalDisplay.recordSelectorBorderWidth
            );
        }

        // if the insert record is visible, we want to add the height of the
        //      record (plus it's border) to the bottom offset
        if (
            element.internalDisplay.insertRecordVisible &&
            element.internalDisplay.insertRecordStick === 'bottom'
        ) {
            element.internalScrollOffsets.bottom += (
                element.internalDisplay.insertRecordHeight +
                element.internalDisplay.insertRecordBorderHeight
            );
        }
    }

// #############################################################################
// ############################ EXTERIOR LIBRARIES #############################
// #############################################################################

// ############ GETPLAINTEXT #############

    // original name:     getPlainText()
    // original author:   Mike Wilcox
    // original site:     http://clubajax.org
    // original support:  http://groups.google.com/group/clubajax
    //
    //    DESCRIPTION:
    //        Returns a line-break, properly spaced, normalized plain text
    //        representation of multiple child nodes which can't be done via
    //        textContent or innerText because those two methods are vastly
    //        different, and even innerText works differently across browsers.

    /*
    ORIGINAL LICENSE FOR getPlainText():

    This is free and unencumbered software released into the public domain.

    Anyone is free to copy, modify, publish, use, compile, sell, or
    distribute this software, either in source code form or as a compiled
    binary, for any purpose, commercial or non-commercial, and by any
    means.

    In jurisdictions that recognize copyright laws, the author or authors
    of this software dedicate any and all copyright interest in the
    software to the public domain. We make this dedication for the benefit
    of the public at large and to the detriment of our heirs and
    successors. We intend this dedication to be an overt act of
    relinquishment in perpetuity of all present and future rights to this
    software under copyright law.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
    OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.
    */

    // This software has been modified from it's original form and thus,
    //      because the original authors of the software relinquished control
    //      to the individual user of the software, we (Workflow Products)
    //      hereby license this modified version of getPlainText() under the
    //      same license as the javascript you find getPlainText() included in.

    function getPlainText(node, bolConsumable) {
        var plainText = "";

        // used for testing/comparison:
        //return node.innerText || node.textContent;

        // clean up double line breaks and spaces
        function normalize(a) {
            if (!a) {
                return "";
            }
            return a.replace(/\ +/g, " ")
                .replace(/[\t]+/gm, "")
                .replace(/[\ ]+$/gm, "")
                .replace(/^[\ ]+/gm, "")
                .replace(/\n+/g, "\n")
                .replace(/\n+$/, "")
                .replace(/^\n+/, "")
                .replace(/\nNEWLINE\n/g, "\n\n")
                .replace(/NEWLINE\n/g, "\n\n"); // IE
        }

        // because we format the text ourselves, we want to get rid of empty
        //      text nodes, they'll just get in the way
        function removeWhiteSpace(node) {
            var ws_i;
            var ws_len;
            var ws_node;
            var ws = [];

            // recursively find whitespace nodes and push them to "ws" array
            function findWhite(node) {
                var i = 0;
                var len = node.childNodes.length;
                var n;

                while (i < len) {
                    n = node.childNodes[i];
                    if (
                        // if node is a text node
                        n.nodeType === 3 &&
                        // if node contains only whitespace
                        !(/[^\t\n\r\ ]/).test(n.nodeValue)
                    ) {
                        // add node to whitespace node list
                        ws.push(n);

                    // else if node contains other nodes:
                    } else if (n.hasChildNodes()) {
                        // search node for more whitespace child nodes
                        findWhite(n);
                    }
                    i += 1;
                }
            }

            // start recursive search
            findWhite(node);

            // remove nodes that are in the "ws" array
            ws_i = 0;
            ws_len = ws.length;
            while (ws_i < ws_len) {
                ws_node = ws[ws_i];
                ws_node.parentNode.removeChild(ws_node);

                ws_i += 1;
            }
        }

        // we want to get the value of the CSS "white-space" and "display"
        //      properties (because they affect how we build the text), so this
        //      function will return CSS properties for a node
        // also, some elements have implied CSS settings (like SCRIPT is
        //      "display: none;") so, this function handles tag-specific
        //      settings
        function sty(n, prop) {
            var s;
            var bolAssumeBlock;

            // if the .style property is available, just use that
            if (n.style[prop]) {
                return n.style[prop];
            }

            // coalesce through a couple different ways of retrieving CSS values
            s = (
                n.currentStyle ||
                window.getComputedStyle(n, null)
                // ^ used to be n.ownerDocument.defaultView
            );

            if (n.tagName === "SCRIPT") {
                return "none";
            }
            if (!s[prop]) {
                bolAssumeBlock = "LI,P,TR".indexOf(n.tagName);

                // if element is an element we assume block for, return block
                if (bolAssumeBlock) {
                    return "block";
                }
                // else return actual style setting
                return n.style[prop];
            }
            if (s[prop] === "block" && n.tagName === "TD") {
                return "feaux-inline";
            }
            return s[prop];
        }

        var blockTypeNodes = "table-row,block,list-item";
        function isBlock(n) {
            // display:block or something else
            var s = sty(n, "display") || "feaux-inline";
            if (blockTypeNodes.indexOf(s) > -1) {
                return true;
            }
            return false;
        }

        // loop recursively through the nodes and build up the text string
        function recurse(n) {
            var strCSSWhite = sty(n, "whiteSpace");
            var strCSSDisplay = sty(n, "display");
            var gap;
            var i;
            var len;
            var c;

            // Loop through all the child nodes
            // and collect the text, noting whether
            // spaces or line breaks are needed.
            if (strCSSWhite.indexOf('pre') !== -1) {
                plainText += n.innerHTML
                    .replace(/\t/g, " ")
                    .replace(/\n/g, " "); // to match IE
                return "";
            }

            if (strCSSDisplay === "none") {
                return "";
            }

            gap = (
                isBlock(n)
                    ? "\n"
                    : " "
            );

            plainText += gap;
            i = 0;
            len = n.childNodes.length;
            while (i < len) {
                c = n.childNodes[i];

                // if the node is a text node, append the value to the text
                if (c.nodeType === 3) {
                    plainText += c.nodeValue;
                }

                // if the node has children, loop through them
                if (c.childNodes.length) {
                    recurse(c);
                }

                i += 1;
            }

            plainText += gap;
            return plainText;
        }

        // we alter elements within the node that was sent, so clone the
        //      node if it's not consumable
        if (bolConsumable !== true) {
            node = node.cloneNode(true);
        }

        // Line breaks aren't picked up by textContent
        node.innerHTML = node.innerHTML.replace(/<br>/g, "\n"); //</br>

        // we don't care about line breaks after P tags right now
        //// Double line breaks after P tags are desired, but would get
        //// stripped by the final RegExp. Using placeholder text.
        //var paras = node.getElementsByTagName("p");
        //var i;
        //var len;
        //i = 0;
        //len = paras.length;
        //while (i < len) {
        //    paras[i].innerHTML += "NEWLINE";
        //    i += 1;
        //}

        removeWhiteSpace(node);

        // Make the call!
        return normalize(recurse(node));
    }


// #############################################################################
// ####################### PRE-RENDER UTILITY FUNCTIONS ########################
// #############################################################################

    // we need a function to prevent html injection
    function encodeHTML(text) {
        var encode = {
            "&": "&#38;",
            "<": "&#60;",
            ">": "&#62;",
            '"': "&#34;",
            "'": "&#39;",
            "/": "&#47;"
        };

        if (text) {
            return text.toString().replace(
                /&|<|>|"|'|\//g,
                function (letter) {
                    return encode[letter] || letter;
                }
            );
        }
        return text;
    }

    // commented out because we no longer put the styling on the cell
    //// because we need to be able to add styles to an element inside of a
    ////      template string, we have this function take a template (while it's
    ////      still a template element) and add a token to the "style" attribute
    ////      that can be easily replaced
    //function templateCellAddStyleToken(templateElement) {
    //    var arrCell = xtag.query(templateElement.content, 'gs-cell');
    //    var i = 0;
    //    var len = arrCell.length;
    //    var strStyle;

    //    while (i < len) {
    //        strStyle = (arrCell[i].getAttribute('style') || '');
    //        strStyle = strStyle.trim();

    //        if (strStyle && strStyle[strStyle.length - 1] !== ';') {
    //            strStyle += ';';
    //        }

    //        arrCell[i].setAttribute(
    //            'style',
    //            '$$CSSREPLACETOKEN$$ ' + strStyle
    //        );

    //        i += 1;
    //    }
    //}

    // because we are using the gs-cell element for headers, data cells, insert
    //      cells, record selectors and the all selector: we need a way for the
    //      CSS to identify them differently, so this function takes a template
    //      element and adds a class to the gs-cell elements within it
    function templateCellAddClass(templateElement, strClass) {
        var arrCell = xtag.query(templateElement.content, 'gs-cell');
        var i = 0;
        var len = arrCell.length;

        while (i < len) {
            arrCell[i].classList.add(strClass);
            i += 1;
        }
    }

    // because we need to be able to target cells by record number, this
    //      function takes a template and adds an attribute to each cell that'll
    //      contain the record number (zero-based) after doT.js
    function templateCellAddRowNumber(templateElement, strOverride) {
        var arrCell = xtag.query(templateElement.content, 'gs-cell');
        var i = 0;
        var len = arrCell.length;

        while (i < len) {
            arrCell[i].setAttribute(
                'data-row-number',
                (strOverride || '{{! row_number - 1 }}')
            );
            i += 1;
        }
    }

    // because we need to be able to target cells by column number, this
    //      function takes a template and adds an attribute to each cell that'll
    //      contain the column number (zero-based)
    function templateCellAddColumnNumber(templateElement) {
        var arrCell = xtag.query(templateElement.content, 'gs-cell');
        var i = 0;
        var len = arrCell.length;

        while (i < len) {
            arrCell[i].setAttribute('data-col-number', i);
            i += 1;
        }
    }

    // commented out because it has been superceded by the new
    //      "templateExtractVisibleCellRange" function
    //// because we only render what is visible on the screen, we use this
    ////      function to take a template string and extract only the columns
    ////      that will be visible
    //function templateExtractCellRange(strTemplate, fromColumn, toColumn) {
    //    var templateElement = document.createElement('template');
    //    templateElement.innerHTML = strTemplate;

    //    var arrCell = xtag.query(templateElement.content, 'gs-cell');
    //    var i = fromColumn;
    //    var len = toColumn;
    //    var strCells = '';

    //    while (i < len) {
    //        strCells += arrCell[i].outerHTML;
    //        i += 1;
    //    }

    //    return strCells;
    //}

    // because we only render what is visible on the screen, we use this
    //      function to take a template string and extract only the columns that
    //      will be visible
    // since we've added the ability to hide columns, we need a template
    //      cell extractor that's aware of visibility.
    function templateExtractVisibleCellRange(
        element,
        strTemplate,
        fromColumn,
        toColumn
    ) {
        var jsnRange;

        // if no from and to column have been provided, extract whole visible
        //      range
        if (fromColumn === undefined || toColumn === undefined) {
            jsnRange = element.internalDisplay.currentRange;
            fromColumn = jsnRange.fromColumn;
            toColumn = jsnRange.toColumn;
        }

        var templateElement = document.createElement('template');
        templateElement.innerHTML = strTemplate;

        var arrCell = xtag.query(templateElement.content, 'gs-cell');
        var i = fromColumn;
        var len = toColumn;
        var strCells = '';
        var arrColumnWidths = element.internalDisplay.columnWidths;

        while (i < len) {
            if (arrColumnWidths[i] > 0) {
                strCells += arrCell[i].outerHTML;
            }
            i += 1;
        }

        return strCells;
    }


    // we need to be able to provide column headings when the user copies some
    //      data, so here we take a template element and we get the text of
    //      every cell and save it for that purpose
    function templateDetermineCopyHeaderList(element, templateElement) {
        var arrHeading = [];
        var arrCell = xtag.query(templateElement.content, 'gs-cell');
        var i = 0;
        var len = arrCell.length;
        var bolHeaderFound = false;
        var strHeading;

        while (i < len) {
            strHeading = arrCell[i].getAttribute('header') || '';
            arrHeading.push(strHeading);

            //console.log('cell: ', arrCell[i]);

            // we want to warn if the copy template has no "header" attributes
            //      so, if one of the cells has a "header" attribute: we'll
            //      prevent the warning code by setting "bolHeaderFound"
            if (arrCell[i].hasAttribute('header')) {
                bolHeaderFound = true;
            }

            i += 1;
        }

        //console.log('bolHeaderFound: ', bolHeaderFound);
        //console.log('copy-header:    ', element.getAttribute('copy-header'));

        // if no "header" attributes were found (and the "copy-header"
        //      attribute doesn't equal "never"), we want to warn the developer
        //      that when a user copies: they wont have any headers because
        //      none were defined
        if (
            !bolHeaderFound &&
            element.getAttribute('copy-header') !== 'Never'
        ) {
            console.warn('GS-TABLE Warning: No headers found in "copy" ' +
                    'template. Please define headers for the copy by using ' +
                    'the "header" attribute on the gs-cell elements of the ' +
                    '"copy" template. If no headers are defined: when a ' +
                    'user copies they will not get any headers. To dismiss ' +
                    'this warning and prevent users from copying the ' +
                    'header: set the "copy-header" attribute to "never."');
        }

        element.internalClip.headerList = arrHeading;
    }

    // we need to know what data column is used for each column, so here we
    //      take the record template and find out what column is associated
    //      with what column
    function templateDetermineCopyColumnList(element, templateElement) {
        var arrColumn = [];
        var arrCell = xtag.query(templateElement.content, 'gs-cell');
        var i = 0;
        var len = arrCell.length;

        //var strColumn;
        //var cell;
        //var strCell;
        //var columnElement;
        //var arrMatch;

        while (i < len) {
            arrColumn.push(arrCell[i].textContent);

            //// we clear out this variable so that if we don't find a column
            ////      name, we'll just add empty string to the column list
            //strColumn = '';

            //// we save the cell element to a variable for easy access
            //cell = arrCell[i];

            //// we'll look for:
            ////      "{{! rowSOMETHINGHERE }}" or "{{= rowSOMETHINGHERE }}" or
            ////      the first element with the "column" attribute
            ////      if we've found one a doT.js statement, we'll trim off the
            ////      braces, "!", "=" and "row" and we'll be left with either
            ////      "['columnname']" or ".columnname"
            ////      if we've found an element with the "column" attribute,
            ////      we'll use it straight as-is
            //columnElement = xtag.query(cell, '[column]')[0];

            //if (cell.hasAttribute('copy-column')) {
            //    strColumn = cell.getAttribute('copy-column') || '';
            //} else if (columnElement) {
            //    strColumn = columnElement.getAttribute('column') || '';
            //}
            ////else {
            ////    strCell = cell.innerHTML;
            ////    arrMatch = strCell.match(/\{\{(!|=)\s*row.*\}\}/g);
            ////    if (arrMatch) {
            ////        strCell = arrMatch[0];
            ////        strCell = strCell
            ////                    // removes "{{="
            ////                    // removes "}}"
            ////                    // removes two columns matched together
            ////                    .substring(3, strCell.indexOf('}}'))
            ////                    // removes extra whitespace
            ////                    .trim();
            ////
            ////        //console.log(strCell);
            ////        //console.log(arrMatch);
            ////        //console.log('########################');
            ////    } else {
            ////
            ////    }
            ////}
            //arrColumn.push(strColumn);
            i += 1;
        }

        element.internalClip.columnList = arrColumn;
    }

    // sometimes, we want to get a list of column names that are used in a
    //      template
    function templateGetColumnList(templateElement) {
        var arrColumn = [];
        var arrElement = xtag.query(templateElement.content, '[column]');
        var i = 0;
        var len = arrElement.length;
        var strColumn;

        while (i < len) {
            strColumn = arrElement[i].getAttribute('column');

            // if there is a column name in the "column" attribute and the
            //      column isn't already in the list of columns we've found:
            //      add it to the array
            if (strColumn && arrColumn.indexOf(strColumn) === -1) {
                arrColumn.push(strColumn);
            }
            i += 1;
        }

        return arrColumn;
    }

    // the user needs to be able to set a custom websocket for this element,
    //      so this function will use an attribute to find out what socket to
    //      use (and it'll default to "GS.envSocket")
    function getSocket(element) {
        if (element.getAttribute('socket')) {
            return GS[element.getAttribute('socket')];
        }
        return GS.envSocket;
    }

    // we need to be able to replace all occurences of a dynamic string with
    //      another dynamic string, and because javascript's .replace()
    //      function only replaces the first occurence (unless you send a
    //      regex), we use this function which takes the string to replace and
    //      creates a regex from it (escaping all regex special characters)
    //      then uses javascript's .replace()
    function stringReplaceAll(str, find, replace) {
        return str.replace(
            new RegExp(
                find.replace(
                    /([\.\*\+\?\^\=\!\:\$\{\}\(\)\|\[\]\/\\])/g,
                    '\\$1'
                ),
                'g'
            ),
            replace
        );
    }

    // both render partial and render full need to know the visible range
    //      of cells so this function serves them both, it returns the
    //      from/to column/record numbers and the origin top/left point
    function getCurrentCellRange(element) {
        var scrollTop;
        var scrollLeft;
        var arrColumnWidths;
        //var arrColumnBorders;
        var arrRecordHeights;
        var columnBorderWidth;
        var recordBorderHeight;

        var fromColumn;
        var toColumn;
        var fromRecord;
        var toRecord;

        var i;
        var len;
        var intTemp;
        var intPrev;

        var intViewportWidth;
        var intViewportHeight;
        var intCellOriginLeft;
        var intRecordOriginTop;

        var bolRecordSelector;
        var bolInsertRecord;
        var bolHeaderRecord;
        var bolRenderAllColumns;

        // we need the viewport dimensions because we need to include the
        //      viewport when choosing what cells to show
        intViewportWidth = element.elems.dataViewport.clientWidth;
        intViewportHeight = element.elems.dataViewport.clientHeight;

        // save column widths and record heights for easy access
        arrColumnWidths = element.internalDisplay.columnWidths;
        arrRecordHeights = element.internalDisplay.recordHeights;

        // we needs the border dimensions to calculate true locations
        columnBorderWidth = element.internalDisplay.columnBorderWidth;
        recordBorderHeight = element.internalDisplay.recordBorderHeight;

        // save scroll location and dimensions for easy access
        scrollTop = element.internalScroll.top;
        scrollLeft = element.internalScroll.left;

        // the developer can choose to not render hidden columns, this limits
        //      some small bits of functionality (the only example I can think
        //      of is selecting all the columns and double clicking to resize.
        //      when some of the columns are not rendered, they don't get
        //      affected by the resize.). This choice affects scrolling
        //      calculations so we need to find out what the developer wants.
        bolRenderAllColumns = !element.hasAttribute('skip-hidden-columns');

        // commented out because we are now going to allow overscrolling,
        //      eventually, it's possible we'll make overscrolling an option
        //      if that happens, we'll want this code back
        //// if we are scrolled all the way to the bottom and there is scroll
        ////      room, we don't want to show the bottom border of the last
        ////      cells, so we'll move the scroll up by the border size
        //if (
        //    scrollTop === element.internalScroll.maxTop &&
        //    element.internalScroll.maxTop > 0
        //) {
        //    scrollTop -= recordBorderHeight;
        //}

        // remove some width and height from the viewport because some of it
        //      will be covered by the header, insert and selector cells
        intViewportHeight -= (
            element.internalScrollOffsets.top +
            element.internalScrollOffsets.bottom
        );
        intViewportWidth -= (
            element.internalScrollOffsets.left +
            element.internalScrollOffsets.right
        );

        i = 0;
        len = arrColumnWidths.length;
        intTemp = 0;
        intCellOriginLeft = 0;
        while (i < len) {
            // when the column width is zero, it's hidden, so don't factor
            //      it into the calculations
            if (arrColumnWidths[i] > 0) {
                intPrev = intTemp;
                intTemp += arrColumnWidths[i];
                intTemp += columnBorderWidth;
            }

            if (fromColumn === undefined && intTemp > scrollLeft) {
                fromColumn = i;
                if (bolRenderAllColumns) {
                    intCellOriginLeft = -intPrev;
                } else {
                    intCellOriginLeft = (intCellOriginLeft - scrollLeft);
                }
            }
            if (
                toColumn === undefined &&
                intTemp > (scrollLeft + intViewportWidth)
            ) {
                toColumn = i;
                break;
            }
            if (fromColumn === undefined && bolRenderAllColumns) {
                intCellOriginLeft = intTemp;
            }
            i += 1;
        }
        fromColumn = Math.max(0, (fromColumn || 0));
        toColumn = (toColumn || i) + 1;

        intCellOriginLeft = intCellOriginLeft || 0;

        if (toColumn > arrColumnWidths.length) {
            toColumn = arrColumnWidths.length;
        }

        // At first, we forced hidden columns to not be rendered. Normally,
        //      we want all columns rendered, even if not every single one
        //      is visible. This allows us to commit operations on hidden
        //      columns. But, sometimes, speed is more important. So, we
        //      have an attribute to make it so that hidden columns are not
        //      rendered.
        if (bolRenderAllColumns) {
            fromColumn = 0;
            toColumn = arrColumnWidths.length;
        }

        //console.log(intCellOriginLeft);
        //console.log('columns: ', fromColumn, toColumn);

        // figure out start/end records
        i = 0;
        len = arrRecordHeights.length;
        intTemp = 0;
        intRecordOriginTop = 0;
        while (i < len) {
            intTemp += arrRecordHeights[i];
            intTemp += recordBorderHeight;

            if (fromRecord === undefined && intTemp > scrollTop) {
                fromRecord = i;
                intRecordOriginTop = (intRecordOriginTop - scrollTop);
            }
            if (
                toRecord === undefined &&
                intTemp > (scrollTop + intViewportHeight)
            ) {
                toRecord = i;
                break;
            }
            if (fromRecord === undefined) {
                intRecordOriginTop = intTemp;
            }
            i += 1;
        }
        toRecord = ((toRecord || i) + 1);
        intRecordOriginTop = (intRecordOriginTop || 0);

        //console.log(
        //    toRecord,
        //    arrRecordHeights.length,
        //    element.internalDisplay.insertRecordVisible,
        //    element.internalDisplay.insertRecordStick,
        //    fromRecord
        //);

        bolInsertRecord = false;
        if (toRecord > arrRecordHeights.length) {
            bolInsertRecord = (
                element.internalDisplay.insertRecordVisible &&
                element.internalDisplay.insertRecordStick === null
            );

            if (
                element.internalDisplay.insertRecordVisible &&
                element.internalDisplay.insertRecordStick === null &&
                fromRecord === undefined
            ) {
                toRecord = (arrRecordHeights.length + 1);
                fromRecord = toRecord;
            } else {
                toRecord = arrRecordHeights.length;
            }
        }

        fromRecord = Math.max(0, (fromRecord || 0));

        // right now, the gs-table assumes that the header is always
        //      affixed to the top side of the viewport.
        bolHeaderRecord = element.internalDisplay.headerVisible;

        // right now, the gs-table assumes that the record selectors are
        //      always affixed to the left side of the viewport.
        bolRecordSelector = element.internalDisplay.recordSelectorVisible;

        // because we scroll by forcing the leftmost column to stick to the
        //      left side, there is a discrepancy between the scroll and what
        //      the user sees that the scroll is, we need a variable to store
        //      what the user sees for the scroll
        element.internalScroll.displayTop = (
            scrollTop + intRecordOriginTop
        );
        element.internalScroll.displayLeft = (
            scrollLeft + intCellOriginLeft
        );

        //console.log(
        //    element.internalScroll.displayTop,
        //    scrollTop,
        //    intRecordOriginTop
        //);
        //console.log(
        //    element.internalScroll.displayLeft,
        //    scrollLeft,
        //    intCellOriginLeft
        //);

        // offset the record/cell origins by the amount that the header cells
        //      and record selectors offset the viewport
        if (bolRenderAllColumns) {
            intCellOriginLeft += element.internalScrollOffsets.left;
        } else {
            intCellOriginLeft = element.internalScrollOffsets.left;
        }
        intRecordOriginTop = element.internalScrollOffsets.top;

        // commented out and replaced by the two lines above, these two lines
        //      make scrolling smooth, the two lines above make the scrolling
        //      resolve to the top of the top record and the left of the
        //      leftmost column
        //intCellOriginLeft += element.internalScrollOffsets.left;
        //intRecordOriginTop += element.internalScrollOffsets.top;

        //console.log('element: ', element);
        //console.log('intRecordOriginTop: ', intRecordOriginTop);
        //console.log('intCellOriginLeft: ', intCellOriginLeft);
        //console.log('fromRecord: ', fromRecord);
        //console.log('fromColumn: ', fromColumn);
        //console.log('toRecord: ', toRecord);
        //console.log('toColumn: ', toColumn);

        return {
            "originTop": intRecordOriginTop,
            "originLeft": intCellOriginLeft,

            "fromRecord": fromRecord,
            "fromColumn": fromColumn,
            "toRecord": toRecord,
            "toColumn": toColumn,

            "headerRecord": bolHeaderRecord,
            "recordSelector": bolRecordSelector,
            "insertRecord": bolInsertRecord
        };
    }

    // in the case of header->line relationships, we need to be able to
    //      silently add in values to form the header->line link, so, here
    //      we generate the values for the link
    function getInsertAddin(element) {
        var jsnRet = {};

        if (element.getAttribute('column') || element.getAttribute('qs')) {
            jsnRet.link_column = (
                element.getAttribute('child-column') ||
                element.getAttribute('column') ||
                element.getAttribute('qs')
            );
            jsnRet.link_value = element.value;
        }

        return jsnRet;
    }

    function delimitedStringToHTML(
        element,
        valueText,
        fieldDelimiter,
        recordDelimiter,
        quoteChar,
        decodeFunction
    ) {
        var i = 0;
        var len = valueText.length;
        var col_i;
        var col_len;

        var arrRecords = [];
        var arrRecord = [];

        var bolInQuote = false;
        var strCell = '';
        var strRecord;
        var strHTML = '';
        var strPreviousChar;
        var strChar;
        var strNullString;

        // we want the null string to be configurable, so we'll read the
        //      "null-string" attribute to get the null string
        // if the "null-string" attribute is present, use the contents
        //      or coalesce to empty string
        if (element.hasAttribute('null-string')) {
            strNullString = element.getAttribute('null-string') || '';

        // else, null string is left up to the encoding function
        } else {
            strNullString = undefined;
        }

        // sometimes, there is an extra delimiter at the beginning of the first
        //      record. if there is: skip over it.
        if (valueText[0] === recordDelimiter) {
            i += 1;
        }

        // make sure there is a recordDelimiter at the end
        if (valueText[len - 1] !== recordDelimiter) {
            valueText += recordDelimiter;
            len = valueText.length;
        }

        // looper
        while (i < len) {
            strChar = valueText[i];
            if (
                strChar === quoteChar &&
                bolInQuote === false &&
                (
                    strPreviousChar === fieldDelimiter ||
                    strPreviousChar === recordDelimiter ||
                    strPreviousChar === undefined
                )
            ) {
                bolInQuote = true;

            } else if (strChar === quoteChar && bolInQuote === true) {
                bolInQuote = false;

            } else if (strChar === fieldDelimiter && bolInQuote === false) {
                arrRecord.push(decodeFunction(strCell, strNullString));
                strCell = '';

            } else if (strChar === recordDelimiter && bolInQuote === false) {
                arrRecord.push(decodeFunction(strCell, strNullString));
                strCell = '';

                arrRecords.push(arrRecord);
                arrRecord = [];

            } else {
                strCell += strChar;
            }

            strPreviousChar = strChar;
            i += 1;
        }

        // data structure to html
        i = 0;
        len = arrRecords.length;
        while (i < len) {
            strRecord = '';
            col_i = 0;
            col_len = arrRecords[i].length;
            while (col_i < col_len) {
                strRecord += (
                    '<td>' +
                        encodeHTML(arrRecords[i][col_i]) +
                    '</td>'
                );
                col_i += 1;
            }

            strHTML += '<tr>' + strRecord + '</tr>';
            i += 1;
        }

        return '<table>' + strHTML + '</table>';
    }

    // sometimes we need to have the selection object, but we don't want it to
    //      change when the selection of the table changes (and vice versa). one
    //      occurance of this is when we are about to update the selection,
    //      we'll copy the selection so that we have a backup and then we'll
    //      update the selection and then we trigger a "before_selection" event.
    //      if the "before_selection" event get's prevented than we'll revert
    //      to a copy.
    function getSelectionCopy(element) {
        var jsnOriginal;
        var jsnCopy;
        var jsnRange;
        var i;
        var len;

        jsnOriginal = element.internalSelection;

        jsnCopy = {
            "ranges": [],
            "insertRecord": jsnOriginal.insertRecord
        };

        // hold on a minute there, why can we just use .slice(0) on the
        //      selection range array?
        // well, my young grasshopper, .slice(0) does work for copying arrays.
        //      however, our selection ranges are stored as JSON objects and
        //      JSON objects within an array will not be copied, the copy array
        //      and the original array will both reference the same JSON object
        //      in memory. so, if I copied the selection range array using
        //      .slice(0) and then altered one of the range objects, the
        //      original would show the same changes. so, using .slice(0) would
        //      make this function useless if you're trying to back up the
        //      selection ranges.
        i = 0;
        len = jsnOriginal.ranges.length;
        while (i < len) {
            jsnRange = jsnOriginal.ranges[i];

            jsnCopy.ranges.push({
                "start": {
                    "row": jsnRange.start.row,
                    "column": jsnRange.start.column
                },
                "end": {
                    "row": jsnRange.end.row,
                    "column": jsnRange.end.column
                }
            });
            i += 1;
        }

        return jsnCopy;
    }

    // sometimes, we need to get the value of a cell. this function returns a
    //      cell in it's unencoded state
    function getCell(
        element,
        strColumn,
        intRow,
        bolDecode,
        strNullStringOverride
    ) {
        var strRecord;
        var rec_i;
        var rec_len;
        var strChar;
        var strCell;
        var strNullString;

        var intCurrentColumn;
        var intTargetColumn;

        // we need to know the index of the target column
        intTargetColumn = (
            element.internalData.columnNames.indexOf(strColumn)
        );

        // we'll iterate through each char until we get the text for the cell
        //      at the correct index
        strRecord = element.internalData.records[intRow];
        intCurrentColumn = 0;
        strCell = '';
        rec_i = 0;
        rec_len = strRecord.length;
        while (rec_i < rec_len) {
            strChar = strRecord[rec_i];

            // if the current character is not a tab: add it to the current
            //      cell variable
            if (strChar !== '\t') {
                strCell += strChar;
            }

            // if the current character is a tab or we are at the end of the
            //      record: handle current cell
            if (
                strChar === '\t' ||
                rec_i === (rec_len - 1)
            ) {
                // advance column number
                intCurrentColumn += 1;

                // if we've reached the start of the column after the desired
                //      column, stop the loop
                if (intCurrentColumn === (intTargetColumn + 1)) {
                    break;
                }

                // clear cell variable
                strCell = '';
            }

            rec_i += 1;
        }

        //console.log('RECORD:', strRecord);
        //console.log('COLUMN:', strColumn);
        //console.log('CELL:', strCell);
        //console.log('NULLSTRING:', strNullString);
        //console.log(
        //    'DECODED:',
        //    GS.decodeFromTabDelimited(strCell, strNullString)
        //);

        if (bolDecode !== false) {
            // we want the null string to be configurable, so we'll read the
            //      "null-string" attribute to get the null string
            // if the "null-string" attribute is present, use the contents
            //      or coalesce to empty string
            if (strNullStringOverride !== undefined) {
                strNullString = strNullStringOverride;

            } else if (element.hasAttribute('null-string')) {
                strNullString = element.getAttribute('null-string') || '';

            // else, null string is left up to the encoding function
            } else {
                strNullString = undefined;
            }

            return GS.decodeFromTabDelimited(strCell, strNullString);
        }

        return strCell;
    }

    function getConnectedSelectedColumns(element, intStartColumn) {
        var arrCurrentColumns;
        var arrSelection;
        var i;

        // get selected column list
        arrSelection = (
            element.internalSelection.columns
        );

        // clear current columns array so that we can start fresh
        arrCurrentColumns = [];

        // loop forwards until we run into a column that is not
        //      selected, each sequential column that is in the
        //      selected column list will be added to the current
        //      list
        i = intStartColumn;
        //console.log('forward start', i);
        while (i < 9999) {
            //console.log('forward', i, arrSelection.indexOf(i));
            if (arrSelection.indexOf(i) > -1) {
                arrCurrentColumns.push(i);
            } else {
                break;
            }
            i += 1;
        }

        // loop backwards until we run into a column that is not
        //      selected, each sequential column that is in the
        //      selected column list will be added to the current
        //      list
        i = (intStartColumn - 1);
        //console.log('backward start', i);
        while (i >= 0) {
            //console.log('backward', i, arrSelection.indexOf(i));
            if (arrSelection.indexOf(i) > -1) {
                arrCurrentColumns.push(i);
            } else {
                break;
            }
            i -= 1;
        }

        // we need to sort the column number list. this is because
        //      of how we find all of the column numbers to reorder
        arrCurrentColumns.sort();

        // ask and you shall receive
        return arrCurrentColumns;
    }

    // in partial and full rerender, we need to set the button icons
    //      and the tooltips of the header cells
    function handleHeaderTemplateTokens(
        element,
        strTemplate,
        fromColumn,
        toColumn
    ) {
        var col_i;
        var col_len;
        var filter_i;
        var filter_len;

        var columnIndex;
        var strDataColumn;
        var strTitle;
        var strClass;

        var arrColumnWidths;
        var arrColumnOrders;
        var arrColumnFilters;

        //console.log('1***', strTemplate);

        // save the order lists for easy access
        arrColumnOrders = element.internalData.columnOrders;

        // save the filter lists for easy access
        arrColumnFilters = element.internalData.columnFilters;

        // save column widths for easy access
        arrColumnWidths = element.internalDisplay.columnWidths;

        col_i = fromColumn;
        col_len = toColumn;
        while (col_i < col_len) {
            // if the column is not hidden
            if (arrColumnWidths[col_i] > 0) {
                strDataColumn = (
                    element.internalDisplay.dataColumnName[
                        col_i
                    ]
                );

                columnIndex = (
                    element.internalData.columnNames.indexOf(
                        strDataColumn
                    )
                );

                strClass = '';
                if (arrColumnOrders[columnIndex] !== 'neutral') {
                    strClass += (
                        ' sort-' +
                        arrColumnOrders[columnIndex]
                    );
                }
                if (
                    arrColumnFilters[columnIndex] &&
                    arrColumnFilters[columnIndex].length > 0
                ) {
                    strClass += ' filtered';
                }
                strTemplate = strTemplate.replace(
                    '$$HDRBTNCLASS_' + strDataColumn + '$$',
                    strClass
                );

                // we need to calculate the title attribute for this
                //      header cell
                strTitle = '';

                if (arrColumnFilters[columnIndex]) {
                    filter_i = 0;
                    filter_len = arrColumnFilters[columnIndex].length;
                    while (filter_i < filter_len) {
                        strTitle += (
                            strTitle
                                ? ' '
                                : ''
                        );
                        strTitle += (
                            arrColumnFilters[columnIndex][filter_i].name
                        );

                        filter_i += 1;
                    }
                }

                // sort in title attribute
                if (arrColumnOrders[columnIndex] === 'desc') {
                    strTitle += (
                        strTitle
                            ? ' '
                            : ''
                    );
                    strTitle += 'sorted descending';

                } else if (arrColumnOrders[columnIndex] === 'asc') {
                    strTitle += (
                        strTitle
                            ? ' '
                            : ''
                    );
                    strTitle += 'sorted ascending';
                }

                // replace title token
                strTemplate = strTemplate.replace(
                    '$$HDR_TITLE_' + strDataColumn + '$$',
                    encodeHTML(strTitle)
                );
            }
            col_i += 1;
        }

        //console.log('2***', strTemplate);

        return strTemplate;
    }

    // in multiple places we need to turn a direction string into useful
    //      booleans and a resolved direction string
    function directionStringBreakdown(strDirectionString) {
        var bolTop;
        var bolLeft;
        var bolBottom;
        var bolRight;

        // prevent uppercase characters
        strDirectionString = strDirectionString.toLowerCase();

        // multiple scroll directions could be sent, we need to parse and
        //      resolve the value to something consistent
        bolTop = (strDirectionString.indexOf('top') !== -1);
        bolLeft = (strDirectionString.indexOf('left') !== -1);
        bolBottom = (strDirectionString.indexOf('bottom') !== -1);
        bolRight = (strDirectionString.indexOf('right') !== -1);

        // warn if two scroll directions are contradictory
        if (bolTop && bolBottom) {
            console.warn('GS-TABLE Warning: Contradictory parameter sent' +
                    ' to directionStringBreakdown.' +
                    ' "Down" direction will be cancelled.' +
                    ' Parameter Text: "' + strDirectionString + '"');
            bolBottom = false;
        }
        if (bolLeft && bolRight) {
            console.warn('GS-TABLE Warning: Contradictory parameter sent' +
                    ' to directionStringBreakdown.' +
                    ' the left and the right at the same time.' +
                    ' "Right" direction will be cancelled.' +
                    ' Parameter Text: "' + strDirectionString + '"');
            bolRight = false;
        }

        // build up consistent scroll direction string
        strDirectionString = '';
        if (bolTop) {
            strDirectionString += 'top';
        }
        if (bolLeft) {
            strDirectionString += 'left';
        }
        if (bolBottom) {
            strDirectionString += 'bottom';
        }
        if (bolRight) {
            strDirectionString += 'right';
        }

        return {
            "bolTop": bolTop,
            "bolLeft": bolLeft,
            "bolBottom": bolBottom,
            "bolRight": bolRight,
            "resolvedString": strDirectionString
        };
    }

    // there are multiple times where we need to find a specific HUD element.
    //      Any HUD element is allowed to be in either the top or bottom HUD
    //      bar. this function looks for elements by class because HUD elements
    //      are identified by classes. this function will check both the top and
    //      bottom HUD bars.
    // in the future, we want to allow multiple buttons with the same class (for
    //      example, the developer may want a refresh button at the top and at
    //      the bottom).
    // ### NEED CODING ###
    function findHudElement(element, strClass) {
        var hudElement;

        // first, we'll try to find it in the bottom HUD
        hudElement = xtag.query(
            element.elems.bottomHudContainer,
            '.' + strClass
        )[0];

        // if we couldn't find the element in the bottom HUD,
        //      we'll try the top HUD
        if (!hudElement) {
            hudElement = xtag.query(
                element.elems.topHudContainer,
                '.' + strClass
            )[0];
        }

        // return whatever we found
        return hudElement;
    }

    // in multiple places, we care what data columns selected
    function getSelectedDataColumns(element) {
        var arrSelectedColumns;
        var arrDataColumns;
        var i;
        var len;
        var index;

        // we need an array of the selected data columns
        arrSelectedColumns = (
            element.internalSelection.columns
        );
        arrDataColumns = [];
        i = 0;
        len = arrSelectedColumns.length;
        while (i < len) {
            index = arrSelectedColumns[i];
            if (element.internalDisplay.dataColumnName[index]) {
                arrDataColumns.push(
                    element.internalData.columnNames.indexOf(
                        element.internalDisplay.dataColumnName[index]
                    )
                );
            }

            i += 1;
        }

        return arrDataColumns;
    }

    // we want the proper event to bubble up when the hidden focus control is
    //      focused. in order to do this, we've moved that code into this
    //      function so that we don't have to repeat it
    function focusHiddenControl(element) {
        element.elems.hiddenFocusControl.focus();
        GS.triggerEvent(element.elems.hiddenFocusControl, 'focus');
    }


    // sometimes, we need to know what cell the mouse is over
    function getCellFromMouseEvent(element, event) {
        var jsnMousePos;
        var jsnElementPos;
        var intMouseX;
        var intMouseY;
        var row;
        var column;
        var jsnRange;
        var arrColumnWidths;
        var arrRecordHeights;
        var i;
        var len;
        var intLeft;
        var intTop;
        var intColBorderWidth;
        var intRowBorderHeight;
        var intRowSelectorWidth;
        var intHeaderHeight;
        //var intInsertRecordHeight;
        var bolHeader;
        var bolInsertRecord;
        var bolRecordSelector;

        // gather display variables
        jsnRange = element.internalDisplay.currentRange;

        bolHeader = element.internalDisplay.headerVisible;
        bolInsertRecord = (
            element.internalDisplay.insertRecordVisible &&
            jsnRange.insertRecord
        );
        bolRecordSelector = element.internalDisplay.recordSelectorVisible;

        arrColumnWidths = element.internalDisplay.columnWidths;
        arrRecordHeights = element.internalDisplay.recordHeights;
        intColBorderWidth = element.internalDisplay.columnBorderWidth;
        intRowBorderHeight = element.internalDisplay.recordBorderHeight;
        intRowSelectorWidth = (
            bolRecordSelector
                ? (
                    element.internalDisplay.recordSelectorWidth +
                    element.internalDisplay.recordSelectorBorderWidth
                )
                : 0
        );
        intHeaderHeight = (
            bolHeader
                ? (
                    element.internalDisplay.headerHeight +
                    element.internalDisplay.headerBorderHeight
                )
                : 0
        );
        //intInsertRecordHeight = (
        //    bolInsertRecord
        //        ? (
        //            element.internalDisplay.insertRecordHeight +
        //            element.internalDisplay.insertRecordBorderWidth
        //        )
        //        : 0
        //);

        // we need the mouse position and the element position
        jsnMousePos = GS.mousePosition(event);
        jsnElementPos = GS.getElementOffset(
            element.elems.dataViewport
        );

        // we need the mouse X to be relative to the dataViewport
        intMouseX = (jsnMousePos.left - jsnElementPos.left);

        // we need the mouse Y to be relative to the dataViewport
        intMouseY = (jsnMousePos.top - jsnElementPos.top);

        // get column. careful, it could be the record selector

        // if record selector is visible and the mouse is above it
        if (bolRecordSelector && intMouseX <= intRowSelectorWidth) {
            column = 'selector';

        } else {
            intLeft = jsnRange.originLeft;//intRowSelectorWidth;
            i = jsnRange.fromColumn;
            len = jsnRange.toColumn;
            while (i < len) {
                if (intMouseX >= intLeft) {
                    column = i;
                } else {
                    break;
                }

                intLeft += arrColumnWidths[i];
                intLeft += intColBorderWidth;
                i += 1;
            }
        }

        // get record. careful, it could be the header or the insert record

        // if header is visible
        if (
            bolHeader &&
            intMouseY <= intHeaderHeight
        ) {
            row = 'header';

        } else {
            intTop = intHeaderHeight;
            i = jsnRange.fromRecord;
            len = jsnRange.toRecord;
            while (i < len) {
                if (intMouseY >= intTop) {
                    row = i;
                } else {
                    break;
                }

                intTop += arrRecordHeights[i];
                intTop += intRowBorderHeight;
                i += 1;
            }

            if (bolInsertRecord && intMouseY >= intTop) {
                row = 'insert';
            }
        }

        //console.log(intMouseX, intMouseY, row, column);

        return {
            "row": row,
            "column": column
        };
    }

    // we need a way to compare the selection ranges, this function turns a
    //      selection range array into a string
    function selectionArrayToString(arr) {
        var i;
        var len;
        var strString;
        var jsnRange;

        strString = '';
        i = 0;
        len = arr.length;
        while (i < len) {
            jsnRange = arr[i];
            strString += (
                (
                    jsnRange.negator
                        ? 't'
                        : 'f'
                ) +
                String(jsnRange.start.column) +
                String(jsnRange.start.row) +
                String(jsnRange.end.column) +
                String(jsnRange.end.row)
            );

            i += 1;
        }

        return strString;
    }

    // Thanks SO User "Cambium"!
    function roundToNearestMultiple(intNum, intDivisor) {
        if (intNum > 0) {
            return Math.ceil(intNum / intDivisor) * intDivisor;
        }
        if (intNum < 0) {
            return Math.floor(intNum / intDivisor) * intDivisor;
        }

        return intDivisor;
    }


// #############################################################################
// ############################# ELEMENT FUNCTIONS #############################
// #############################################################################

    // this section deals with the generation of the gs-table's non-cell HTML

    // some attributes can't be used in their normal, dev-friendly format,
    //      this function translates those attributes to their final formats
    // some attributes need to be defaulted, even if they're not present
    function resolveElementAttributes(element) {
        var arrParts;

        // GS-TABLE elements that are connected to Envelope need to have "pk"
        //      and "lock" attributes
        if (element.getAttribute('src')) {
            // split "src" into "schema" and "object" attributes
            arrParts = GS.templateWithQuerystring(
                element.getAttribute('src')
            ).split('.');

            // I don't know who added this. I don't inderstand why someone
            //      would put something like "biz.bar.foo" in the "src"
            //      attribute. That's the case that this code handles. If
            //      you added this code: PUT A COMMENT!!!! We have comments
            //      for a reason. Don't ruin this beautiful code. Only YOU
            //      can prevent spaghetti code.
            //  ~Michael
            // It appears to be a solution to quote idented object names that
            //      contain a period like this: test."test.asdf"
            //      The problem with this solution (other than being unclear)
            //      is that it wont work for schema names that contain a period.
            //      We need a better solution for this. Perhaps it's time to
            //      create a function that understands ident quoted names for
            //      real, using actual parsing.
            //  ~Also Michael
            if (arrParts[2]) {
                arrParts[1] = arrParts[1] + '.' + arrParts[2];
            }

            // put the split sections of the object name into separate
            //      attributes
            element.setAttribute('schema', arrParts[0]);
            element.setAttribute('object', arrParts[1]);

            // default "pk" and "lock" attributes
            element.setAttribute(
                'pk',
                (element.getAttribute('pk') || 'id')
            );
            element.setAttribute(
                'lock',
                (element.getAttribute('lock') || 'change_stamp')
            );
        }

        // default null string attribute
        element.setAttribute(
            'null-string',
            (
                element.getAttribute('null-string') ||
                ''
            )
        );
    }

    // replace element HTML with the new HTML
    function prepareElement(element) {
        var rootElement;
        var i;

        // all gs-table elements must have an ID attribute
        if (!element.getAttribute('id')) {
            // loop through IDs using the ID sequence until we get to one
            //      that isn't used
            globalIDSeq += 1; // global to the gs-table x-tag definition scope
            i = 0;
            while (
                i < 500 &&
                document.getElementById('table-dynamic-id-' + globalIDSeq)
            ) {
                globalIDSeq += 1;
                i += 1;
            }

            element.setAttribute('id', 'table-dynamic-id-' + globalIDSeq);

            // warn the developer
            console.warn('GS-TABLE Warning: All gs-table elements must have' +
                    ' an ID. Adding dynamic ID:' +
                    ' "table-dynamic-id-' + globalIDSeq + '". Do not use' +
                    ' this ID for anything. Do not use it for HTML, CSS or' +
                    ' JS or anything else as it can change between page' +
                    ' loads.');
        }

        // the root is created as a variable so that we can append it to the
        //      gs-table without destrying the templates because the next step
        //      of this element's initalization is the "siphon" (where we
        //      extract the info out of the templates)
        rootElement = document.createElement('div');
        rootElement.classList.add('table-root');
        element.appendChild(rootElement);

        // create standard gs-table html
        rootElement.innerHTML =
                // we need a container to hold the HUD, this container will be
                //      absolutely positioned to the top of the gs-table
                '<div class="table-hud-container hud-top"></div>' +
                // we need a container to hold the viewport container and the
                //      scrollbars
                '<div class="table-table-container">' +
                // we need a container for the viewport that will automatically
                //      size the viewport correctly
                '    <div class="table-data-container">' +
                // we need a viewport that will hide anything that doesn't fit
                //      and won't scroll. the scrolling will be handled by the
                //      renderer.
                '        <div class="table-data-viewport"></div>' +
                '    </div>' +
                '    <div class="table-v-scroll-bar-container">' +
                '        <div class="table-v-scroll-bar">' +
                '            <div class="table-scroll-causer"></div>' +
                '        </div>' +
                '    </div>' +
                '    <div class="table-h-scroll-bar-container">' +
                '        <div class="table-h-scroll-bar">' +
                '            <div class="table-scroll-causer"></div>' +
                '        </div>' +
                '    </div>' +
                '</div>' +
                // we need a textarea that is hidden so that we can intercept
                //      keyboard events even if none of the controls have been
                //      focused into. one case where this occurs is when you
                //      select a range of cells, when selecting a range you
                //      don't want one of the cells to be focused, and yet, you
                //      want to be able to press "delete" and delete the
                //      records.
                // we also need a dependable focus target for when we handle
                //      copy/paste events.
                // this control also need to be after the rest of the cells to
                //      make tabbing out of the gs-table easier to code. to tab
                //      out we'll just have to not prevent default
                '<textarea class="hidden-focus-control"' +
                '    value="text makes this textarea Firefox worthy">' +
                '</textarea>' +
                // we need a static container to hold our loader elements
                '<div class="table-loader-container"></div>' +
                // we need a place to hold an example of each type of cell so
                //      that we can read their style dynamically without causing
                //      a "Forced Reflow", this will be a speed benefit
                '<div class="table-cell-test-container">' +
                '    <gs-cell class="table-cell"></gs-cell>' +
                '    <gs-cell class="table-header"></gs-cell>' +
                '    <gs-cell class="table-insert"></gs-cell>' +
                '    <gs-cell class="table-record-selector"></gs-cell>' +
                '</div>' +
                // we need a container to hold the HUD, this container will be
                //      absolutely positioned to the bottom of the gs-table
                '<div class="table-hud-container hud-bottom"></div>' +
                // we need a style tag for dynamic CSS, MS Edge is slow when it
                //      comes to changing style attributes for a bunch of cells,
                //      we're going to try not using style attributes and
                //      instead using a dynamic CSS style element
                // if it doesn't speed up Edge we may still come up with a new
                //      use for it so keep it around
                '<style class="cell-position" style="display:none;"></style>' +
                // we need to know when the font size changes so that we can
                //      re-render. this element will always be 1em wide and 1em
                //      tall. when this element changes pixel size, we'll know
                //      that the font size has changed.
                '<div class="table-font-size-detector"></div>';

        // we want to easily/quickly be able to get elements without
        //      using selectors
        element.elems = {};

        element.elems.root = rootElement;

        element.elems.topHudContainer = element.elems.root.children[0];
        element.elems.tableViewport = element.elems.root.children[1];
        element.elems.hiddenFocusControl = element.elems.root.children[2];
        element.elems.loaderContainer = element.elems.root.children[3];
        element.elems.cellTestContainer = element.elems.root.children[4];
        element.elems.bottomHudContainer = element.elems.root.children[5];
        element.elems.cellPositionStyle = element.elems.root.children[6];
        element.elems.fontSizeDetector = element.elems.root.children[7];

        element.elems.dataContainer =
                element.elems.tableViewport.children[0];
        element.elems.yScrollContainer =
                element.elems.tableViewport.children[1];
        element.elems.xScrollContainer =
                element.elems.tableViewport.children[2];

        element.elems.dataViewport = element.elems.dataContainer.children[0];

        element.elems.yScrollBar = element.elems.yScrollContainer.children[0];
        element.elems.xScrollBar = element.elems.xScrollContainer.children[0];
        element.elems.yScrollBarCauser = element.elems.yScrollBar.children[0];
        element.elems.xScrollBarCauser = element.elems.xScrollBar.children[0];

        element.elems.testDataCell = (
            element.elems.cellTestContainer.children[0]
        );
        element.elems.testHeader = (
            element.elems.cellTestContainer.children[1]
        );
        element.elems.testInsert = (
            element.elems.cellTestContainer.children[2]
        );
        element.elems.testRecordSelector = (
            element.elems.cellTestContainer.children[3]
        );

        // because the resize handles aren't always in the DOM, we'll create
        //      them virtually and store them
        element.elems.handleColumn = document.createElement('div');
        element.elems.handleColumn.classList.add('resize-column-handle');
        element.elems.handleRecord = document.createElement('div');
        element.elems.handleRecord.classList.add('resize-record-handle');

        // because the reorder indicator isn't always in the DOM, we'll create
        //      it virtually and store them
        element.elems.handleReorder = document.createElement('div');
        element.elems.handleReorder.classList.add('reorder-column-handle');

        // sometimes, we want to open a dialog to a particular pixel instead
        //      of a particular element. so, we'll create an element what for
        //      putting it at a particular pixel an then just use the
        //      standard openDialogToElement function.
        element.elems.pixel = document.createElement('div');
        element.elems.pixel.classList.add('pixel-element');
        element.elems.root.appendChild(element.elems.pixel);

        // we want a place to look to for data
        element.internalData = {
            "records": [],
            "columnFilterStatuses": [],
            "columnFilters": [],
            "columnListFilters": [],
            "columnOrders": [],
            "columnNames": [],
            "columnTypes": [],
            "insertRecord": {},
            "insertRecordRetainedColumns": [],
            "bolFirstLoadFinished": false
        };

        // we need to be able to make room for fixed objects when scrolling
        //      (like the fixed headers), so we'll define these properties
        //      so that we have a single place to look for them
        element.internalScrollOffsets = {
            "top": 0,
            "bottom": 0,
            "left": 0,
            "right": 0
        };

        // we need a place to store event functions because, to unbind a
        //      specific event javascript requires that you have the
        //      original function that was bound to that event
        element.internalEvents = {};

        // some events are triggered by something that the gs-table does,
        //      so event code needs to have a place to look to see if
        //      it's been cancelled for one execution
        element.internalEventCancelled = {
            "scrollbarY": false,
            "scrollbarX": false
        };

        // we need to manually store the scroll location somewhere because
        //      scrollbars can only cover so much area before breaking
        element.internalScroll = {
            "top": 0,
            "left": 0,
            "maxTop": 0,
            "maxLeft": 0,
            "displayTop": 0,
            "displayLeft": 0,
            "prevTop": 0,
            "prevLeft": 0
        };

        // we need to manually store timer IDs so that we can do throttling
        element.internalTimerIDs = {
            "scrollIntervalID": null,
            "visibilityIntervalID": null
        };

        // we need a place to store our templates, so we'll create an
        //      element.internalTemplates JSON object and store each
        //      template under a unique name
        element.internalTemplates = {
            "topHUD": "",
            "bottomHUD": "",
            "header": "",
            "originalRecord": "",
            "record": {},
            "insertRecord": "",
            "insertDialog": "",
            "updateDialog": ""
        };

        // we need a place to store cell dimensions and other display
        //      related info
        // anything in here set to "undefined" is set that way because the dev
        //      may set it to 0 or [] and we need to be able to tell that it
        //      hasn't been set yet
        element.internalDisplay = {
            "columnPlainTextNames": [],
            "dataColumnName": [],

            "columnWidths": [],
            "minColumnWidths": [],
            "maxColumnWidth": 999,

            "recordHeights": [],
            "maxRecordHeight": 999,

            "columnHandles": [],
            "recordHandles": [],

            "currentRange": {},
            "prevRange": {},

            // not used yet, null will mean "doesn't stick".
            //      only "top", "bottom" and null allowed.
            "headerStick": "top",

            "headerVisible": false,
            "headerHeight": undefined,
            "headerBorderHeight": 0,

            // not used yet, null will mean "doesn't stick".
            //      only "left", "right" and null allowed.
            "selectorStick": "left",

            "recordSelectorVisible": false,
            "recordSelectorWidth": 0,
            "recordSelectorBorderWidth": 0,

            // only "top", "bottom" and null allowed.
            "insertRecordStick": null, //"bottom"

            "insertRecordVisible": false,
            "insertRecordHeight": undefined,
            "insertRecordBorderHeight": 0,

            "fullRenderRequired": true,

            "defaultColumnWidths": [],
            "defaultColumnWidth": 0,
            "defaultRecordHeight": 0,
            "defaultRecordSelectorWidth": 27,
            "defaultHeaderHeight": 27,
            "defaultInsertRecordHeight": 27,

            "focus": {
                "column": null,
                "row": null,
                "nodeName": null,
                "columnAttribute": null,
                "latest": null,
                "selectionRange": {}
            }
        };

        // we need to default the record selector width
        element.internalDisplay.recordSelectorWidth = (
            element.internalDisplay.defaultRecordSelectorWidth
        );

        // we need a place to store selection ranges
        element.internalSelection = {
            "ranges": [],
            "rangeCache": null,
            "insertRecord": false,
            "originRecord": null,
            "resolvedSelection": [],
            "columns": [],
            "rows": [],
            "currentlySelecting": false
        };

        // we need a place to store the parameters for copy
        element.internalClip = {
            "columnList": [],
            "headerList": []
        };

        // we need a place to store the web worker and it's
        //      associated data
        element.internalWorker = {
            "worker": "",
            "ready": false
        };

        // we need a place to store the loader data
        element.internalLoaders = {
            "loaderIDs": [],
            "loaderElements": []
        };

        // we need a place to store info for column resizing
        element.internalResize = {
            "currentlyResizing": false,
            "showThrottleID": null,
            "resizeStarted": false,
            "cellOriginX": 0,
            "cellOriginY": 0,

            "resizeColumn": false,
            "resizeRecord": false,

            "resizeColumnHandleIndex": 0,
            "resizeRecordHandleIndex": 0,

            "resizeColumnIndex": null,
            "resizeRecordIndex": null,

            "resizingRecordSelectors": false,
            "resizingHeader": false,
            "resizingInsert": false,

            "scrollOriginTop": null,
            "scrollOriginLeft": null,

            "lastX": 0,
            "lastY": 0,
            "lastWidth": 0,
            "lastHeight": 0
        };

        // we need a place to store info for column reorder
        element.internalReorder = {
            "currentlyReordering": false,
            "reorderStarted": false,
            "currentColumns": [],
            "dropLocation": 0,
            "scrollIntervalID": null,
            "scrollDirection": null,
            "scrolling": false,
            "originColumn": null
        };

        // we need a place to cache visibility information so that if we
        //      detect a change, we can trigger a re-render
        element.internalPollingCache = {
            "elementWidth": null,
            "elementHeight": null,
            "elementVisibility": null,
            "fontSize": null
        };

        // we want to know the cell dimensions so that we can make elements
        //      default and so that scrolling will reflect the correct
        //      dimensions, so we'll detect them here (and during scroll
        //      location renders)
        cellDimensionDetector(element);
    }

    // get a gs-table's templates and translate them for future templating
    function siphonElement(element) {
        var topHudTemplate;
        var bottomHudTemplate;
        var headerRecordTemplate;
        var dataRecordTemplate;
        var copyTemplate;
        var insertRecordTemplate;
        var insertDialogTemplate;
        var updateDialogTemplate;

        var strHTML;
        var arrColumnPlainTextNames;
        var arrColumnDataNames;
        var arrColumnElements;
        var columnElement;
        var intColumnWidth;
        var buttonElement;
        var i;
        var len;

        // get each template element and save them to each their own variable,
        //      for easy access
        topHudTemplate = xtag.queryChildren(
            element,
            '[for="top-hud"]'
        )[0];

        bottomHudTemplate = xtag.queryChildren(
            element,
            '[for="bottom-hud"]'
        )[0];

        headerRecordTemplate = xtag.queryChildren(
            element,
            '[for="header-record"]'
        )[0];

        dataRecordTemplate = xtag.queryChildren(
            element,
            '[for="data-record"]'
        )[0];

        copyTemplate = xtag.queryChildren(
            element,
            '[for="copy"]'
        )[0];

        insertRecordTemplate = xtag.queryChildren(
            element,
            '[for="insert-record"]'
        )[0];

        insertDialogTemplate = xtag.queryChildren(
            element,
            '[for="insert-dialog"]'
        )[0];

        updateDialogTemplate = xtag.queryChildren(
            element,
            '[for="update-dialog"]'
        )[0];

        // remove all templates from the dom to prevent reflows
        if (topHudTemplate) {
            //console.log(element, topHudTemplate);
            element.removeChild(topHudTemplate);
        }
        if (bottomHudTemplate) {
            element.removeChild(bottomHudTemplate);
        }
        if (headerRecordTemplate) {
            element.removeChild(headerRecordTemplate);
        }
        if (dataRecordTemplate) {
            element.removeChild(dataRecordTemplate);
        }
        if (copyTemplate) {
            element.removeChild(copyTemplate);
        }
        if (insertRecordTemplate) {
            element.removeChild(insertRecordTemplate);
        }
        if (insertDialogTemplate) {
            element.removeChild(insertDialogTemplate);
        }
        if (updateDialogTemplate) {
            element.removeChild(updateDialogTemplate);
        }

        if (
            topHudTemplate &&
            (
                topHudTemplate.innerHTML.indexOf('&gt;') > -1 ||
                topHudTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn('GS-TABLE WARNING: &gt; or &lt; detected in ' +
                        'top HUD template, this can have undesired ' +
                        'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                        'lt(x,y), or lte(x,y) to silence this warning.');
        }
        if (
            bottomHudTemplate &&
            (
                bottomHudTemplate.innerHTML.indexOf('&gt;') > -1 ||
                bottomHudTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn('GS-TABLE WARNING: &gt; or &lt; detected in ' +
                        'bottom HUD template, this can have undesired ' +
                        'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                        'lt(x,y), or lte(x,y) to silence this warning.');
        }
        if (
            headerRecordTemplate &&
            (
                headerRecordTemplate.innerHTML.indexOf('&gt;') > -1 ||
                headerRecordTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn('GS-TABLE WARNING: &gt; or &lt; detected in ' +
                        'header record template, this can have undesired ' +
                        'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                        'lt(x,y), or lte(x,y) to silence this warning.');
        }
        if (
            dataRecordTemplate &&
            (
                dataRecordTemplate.innerHTML.indexOf('&gt;') > -1 ||
                dataRecordTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn('GS-TABLE WARNING: &gt; or &lt; detected in ' +
                        'data record template, this can have undesired ' +
                        'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                        'lt(x,y), or lte(x,y) to silence this warning.');
        }
        if (
            copyTemplate &&
            (
                copyTemplate.innerHTML.indexOf('&gt;') > -1 ||
                copyTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn('GS-TABLE WARNING: &gt; or &lt; detected in ' +
                        'copy template, this can have undesired ' +
                        'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                        'lt(x,y), or lte(x,y) to silence this warning.');
        }
        if (
            insertRecordTemplate &&
            (
                insertRecordTemplate.innerHTML.indexOf('&gt;') > -1 ||
                insertRecordTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn('GS-TABLE WARNING: &gt; or &lt; detected in ' +
                        'insert record template, this can have undesired ' +
                        'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                        'lt(x,y), or lte(x,y) to silence this warning.');
        }
        if (
            insertDialogTemplate &&
            (
                insertDialogTemplate.innerHTML.indexOf('&gt;') > -1 ||
                insertDialogTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn('GS-TABLE WARNING: &gt; or &lt; detected in ' +
                        'insert dialog template, this can have undesired ' +
                        'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                        'lt(x,y), or lte(x,y) to silence this warning.');
        }
        if (
            updateDialogTemplate &&
            (
                updateDialogTemplate.innerHTML.indexOf('&gt;') > -1 ||
                updateDialogTemplate.innerHTML.indexOf('&lt;') > -1
            )
        ) {
            console.warn('GS-TABLE WARNING: &gt; or &lt; detected in ' +
                        'update dialog template, this can have undesired ' +
                        'effects on doT.js. Please use gt(x,y), gte(x,y), ' +
                        'lt(x,y), or lte(x,y) to silence this warning.');
        }

        // if there's no "data-record" template: error
        if (!dataRecordTemplate) {
            throw 'GS-TABLE Error: no "data-record" template found. ' +
                    'The "data-record" must be a immediate child in ' +
                    'order to be found.';
        }

        // if there's no "data-record" template: error
        if (!copyTemplate) {
            console.warn('GS-TABLE Warning: no "copy" template found. ' +
                    'The "copy" template enables copying a selection ' +
                    'from the gs-table. The "copy" template must be a ' +
                    'immediate child in order to be found.');
        }

        // get column widths
        if (
            headerRecordTemplate ||
            dataRecordTemplate ||
            insertRecordTemplate
        ) {
            if (headerRecordTemplate) {
                arrColumnElements = xtag.query(
                    headerRecordTemplate.content,
                    'gs-cell'
                );
            } else if (dataRecordTemplate) {
                arrColumnElements = xtag.query(
                    dataRecordTemplate.content,
                    'gs-cell'
                );
            } else if (insertRecordTemplate) {
                arrColumnElements = xtag.query(
                    insertRecordTemplate.content,
                    'gs-cell'
                );
            }

            i = 0;
            len = arrColumnElements.length;
            intColumnWidth = (
                parseInt(element.getAttribute('default-column-width'), 10) ||
                intDefaultColumnWidth
            );
            while (i < len) {
                element.internalDisplay.columnWidths.push(
                    parseInt(arrColumnElements[i].style.width, 10) ||
                    intColumnWidth
                );

                // we need to be able to restore the column widths after the
                //      user resizes them, so this array contains the column
                //      widths and cannot be updated by column resizing
                element.internalDisplay.defaultColumnWidths.push(
                    parseInt(arrColumnElements[i].style.width, 10) ||
                    intColumnWidth
                );

                // if there is a width, remove it. we do this because the width
                //      is added dynamically when the header is rendered. if
                //      someone resizes a cell, we need to set the width with
                //      the new value
                if (arrColumnElements[i].style.width) {
                    arrColumnElements[i].style.width = '';
                }

                i += 1;
            }
        }

        // get header height
        if (headerRecordTemplate) {
            arrColumnElements = xtag.query(
                headerRecordTemplate.content,
                'gs-cell'
            );

            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                // if we run into a column with a height defined, use that
                //      height for the header height and break out of the loop
                if (arrColumnElements[i].style.height) {
                    element.internalDisplay.headerHeight = (
                        parseInt(arrColumnElements[i].style.height, 10)
                    );
                }
                i += 1;
            }

            // default
            if (element.internalDisplay.headerHeight === undefined) {
                element.internalDisplay.headerHeight = (
                    element.internalDisplay.defaultHeaderHeight
                );
            }
        }

        // get insert record height
        if (insertRecordTemplate) {
            arrColumnElements = xtag.query(
                insertRecordTemplate.content,
                'gs-cell'
            );

            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                // if we run into a column with a height defined, use that
                //      height for the header height and break out of the loop
                if (arrColumnElements[i].style.height) {
                    element.internalDisplay.insertRecordHeight = (
                        parseInt(arrColumnElements[i].style.height, 10)
                    );
                }
                i += 1;
            }

            // default to 27 pixels
            if (element.internalDisplay.insertRecordHeight === undefined) {
                element.internalDisplay.insertRecordHeight = (
                    element.internalDisplay.defaultInsertRecordHeight
                );
            }
        }

        // get plain text column names
        arrColumnPlainTextNames = [];

        // if there is a copy template and we still haven't found
        //      plain text column names
        if (
            copyTemplate && (
                arrColumnPlainTextNames.length === 0 ||
                arrColumnPlainTextNames.indexOf(null) !== -1
            )
        ) {
            arrColumnElements = xtag.query(
                copyTemplate.content,
                'gs-cell'
            );

            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                if (!arrColumnPlainTextNames[i]) {
                    arrColumnPlainTextNames[i] = (
                        // if there's no header attribute, we'll set the
                        //      column name to null
                        arrColumnElements[i].getAttribute('header')
                    );
                }
                i += 1;
            }
        }

        // if there is a record template and we still haven't found
        //      plain text column names
        if (
            dataRecordTemplate && (
                arrColumnPlainTextNames.length === 0 ||
                arrColumnPlainTextNames.indexOf(null) !== -1
            )
        ) {
            arrColumnElements = xtag.query(
                dataRecordTemplate.content,
                'gs-cell'
            );

            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                if (!arrColumnPlainTextNames[i]) {
                    arrColumnPlainTextNames[i] = (
                        // if there's no header attribute, we'll set the
                        //      column name to null
                        arrColumnElements[i].getAttribute('header')
                    );
                }
                i += 1;
            }
        }

        // if there is an insert record template and we still haven't
        //      found plain text column names
        if (
            insertRecordTemplate && (
                arrColumnPlainTextNames.length === 0 ||
                arrColumnPlainTextNames.indexOf(null) !== -1
            )
        ) {
            arrColumnElements = xtag.query(
                insertRecordTemplate.content,
                'gs-cell'
            );

            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                if (!arrColumnPlainTextNames[i]) {
                    arrColumnPlainTextNames[i] = (
                        // if there's no header attribute, we'll set the
                        //      column name to null
                        arrColumnElements[i].getAttribute('header')
                    );
                }
                i += 1;
            }
        }

        // if there is a header template and we still haven't found
        //      plain text column names
        if (
            headerRecordTemplate && (
                arrColumnPlainTextNames.length === 0 ||
                arrColumnPlainTextNames.indexOf(null) !== -1
            )
        ) {
            arrColumnElements = xtag.query(
                headerRecordTemplate.content,
                'gs-cell'
            );

            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                if (!arrColumnPlainTextNames[i]) {
                    arrColumnPlainTextNames[i] = (
                        // if there's no text, we'll set the
                        //      column name to null
                        arrColumnElements[i].textContent.trim() || null
                    );
                }
                i += 1;
            }
        }

        // store plain text column names for future use
        element.internalDisplay.columnPlainTextNames = arrColumnPlainTextNames;



        // we need to associate the display columns with their associated data
        //      columns
        arrColumnDataNames = [];

        // if there is an insert record template and we still haven't
        //      all of the found data column associations
        if (
            insertRecordTemplate && (
                arrColumnDataNames.length === 0 ||
                arrColumnDataNames.indexOf(null) !== -1
            )
        ) {
            arrColumnElements = xtag.query(
                insertRecordTemplate.content,
                'gs-cell'
            );

            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                if (!arrColumnDataNames[i]) {
                    columnElement = xtag.query(
                        arrColumnElements[i],
                        '[column]'
                    )[0];

                    if (columnElement) {
                        arrColumnDataNames[i] = (
                            // if there's no column attribute, we'll set the
                            //      column name to null
                            columnElement.getAttribute('column')
                        );
                    } else {
                        arrColumnDataNames[i] = null;
                    }
                }
                i += 1;
            }
        }

        // if there is an insert record template and we still haven't
        //      all of the found data column associations
        if (
            dataRecordTemplate && (
                arrColumnDataNames.length === 0 ||
                arrColumnDataNames.indexOf(null) !== -1
            )
        ) {
            arrColumnElements = xtag.query(
                dataRecordTemplate.content,
                'gs-cell'
            );

            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                if (!arrColumnDataNames[i]) {
                    columnElement = xtag.query(
                        arrColumnElements[i],
                        '[column]'
                    )[0];

                    if (columnElement) {
                        arrColumnDataNames[i] = (
                            // if there's no column attribute, we'll set the
                            //      column name to null
                            columnElement.getAttribute('column')
                        );
                    } else {
                        arrColumnDataNames[i] = null;
                    }
                }
                i += 1;
            }
        }

        // store our associations internally
        element.internalDisplay.dataColumnName = arrColumnDataNames;

        // if present, siphon "top-hud" template
        if (topHudTemplate) {
            element.internalTemplates.topHUD = topHudTemplate.innerHTML;
        }

        // if present, siphon "bottom-hud" template
        if (bottomHudTemplate) {
            element.internalTemplates.bottomHUD = bottomHudTemplate.innerHTML;
        }

        // the header template (if there is one) needs dropdown buttons for
        //      the column dropdown
        if (headerRecordTemplate) {
            // create the button element so we can clone it
            buttonElement = document.createElement('div');

            // loop through cells and append buttons
            arrColumnElements = xtag.query(
                headerRecordTemplate.content,
                'gs-cell'
            );
            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                // a column only get's a column button if there is a data
                //      column associated with that column
                if (arrColumnDataNames[i]) {
                    buttonElement.setAttribute(
                        'class',
                        'header-button ' +
                                '$$HDRBTNCLASS_' + arrColumnDataNames[i] + '$$'
                    );

                    arrColumnElements[i].classList.add('right-button');
                    arrColumnElements[i].appendChild(
                        buttonElement.cloneNode(true)
                    );
                }
                i += 1;
            }
        }

        // if a display column is associated with a data column, we want
        //      to have sort and filter related info in the tooltip
        if (headerRecordTemplate) {
            // loop through header cells and add tokens to the title
            //      attributes
            arrColumnElements = xtag.query(
                headerRecordTemplate.content,
                'gs-cell'
            );
            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                // a column only get's a column button if there is a data
                //      column associated with that column
                if (arrColumnDataNames[i]) {
                    arrColumnElements[i].setAttribute(
                        'title',
                        '$$HDR_TITLE_' + arrColumnDataNames[i] + '$$'
                    );
                }
                i += 1;
            }
        }

        // if there is a header template, get column min widths
        if (headerRecordTemplate) {
            arrColumnElements = xtag.query(
                headerRecordTemplate.content,
                'gs-cell'
            );

            i = 0;
            len = arrColumnElements.length;
            while (i < len) {
                // all of these values are tested in the test header
                //      element, this element is in a different location
                //      so the CSS that the user sets may not apply to
                //      it. we need to transition to a temporary cell
                //      element in the viewport
                // ### NEED CODING ###

                // get text width using test header element
                element.elems.testHeader.innerHTML = (
                    arrColumnElements[i].innerHTML
                );

                intColumnWidth = (
                    //GS.getTextWidth(
                    //    element.elems.testHeader,
                    //    arrColumnElements[i].textContent,
                    //    true // preserve whitespace
                    //) +

                    element.elems.testHeader.offsetWidth +
                    // for some reason, a few pixels are missing
                    3
                );

                element.elems.testHeader.innerHTML = '';

                //console.log(arrColumnElements[i].textContent);

                // if there is a data column associated, we need to
                //      add the width of the header button
                if (arrColumnDataNames[i]) {
                    intColumnWidth += (
                        // em value is hard coded for now
                        GS.emToPx(element.elems.testHeader, 1.25)
                    );
                }

                //console.log(intColumnWidth);

                element.internalDisplay.minColumnWidths.push(
                    intColumnWidth
                );

                //console.log(
                //    intColumnWidth,
                //    element.internalDisplay.columnWidths[i]
                //);
                if (
                    intColumnWidth >
                        element.internalDisplay.columnWidths[i]
                ) {
                    element.internalDisplay.columnWidths[i] = (
                        intColumnWidth
                    );
                }

                i += 1;
            }
        }


        // if present, siphon "header-record" template
        if (headerRecordTemplate) {
            // commented out because we no longer put the styling on the cell
            //// append a token to the end of the style attribute of each
            ////      gs-cell (so that we can dynamically add CSS definitions)
            //templateCellAddStyleToken(headerRecordTemplate);

            // add a class of "table-header" to each gs-cell for styling
            templateCellAddClass(headerRecordTemplate, 'table-header');

            // add column numbers to the header cells so that we can target
            //      these cells using column precision
            templateCellAddColumnNumber(headerRecordTemplate);

            // save the template
            element.internalTemplates.header = (
                headerRecordTemplate.innerHTML.trim()
            );

            //// remove the template element now that it's been siphoned
            //element.removeChild(headerRecordTemplate);
        }

        // if present, siphon "data-record" template
        if (dataRecordTemplate) {
            // commented out because we no longer put the styling on the cell
            //// append a token to the end of the style attribute of each
            ////      gs-cell (so that we can dynamically add CSS definitions)
            //templateCellAddStyleToken(dataRecordTemplate);

            // add a class of "table-cell" to each gs-cell for styling
            templateCellAddClass(dataRecordTemplate, 'table-cell');

            // add column numbers to the record cells so that we can target
            //      these cells using column precision
            templateCellAddColumnNumber(dataRecordTemplate);

            // add a record number attribute on each of the cells so that we can
            //      target specific records for deletion, rerender, movement
            //      etc...
            templateCellAddRowNumber(dataRecordTemplate);

            // save the template
            strHTML = GS.templateColumnToValue(
                dataRecordTemplate.innerHTML.trim()
            );

            // let's save the original record template text so that we can
            //      modify it in the future
            element.internalTemplates.originalRecord = strHTML;

            // we're going run the record template through a function to
            //      turn all of the "column" attributes into "value" attributes
            //      with the proper templating
            element.internalTemplates.record = (
                GS.templateHideSubTemplates(strHTML, false)
            );

            //// remove the template element now that it's been siphoned
            //element.removeChild(dataRecordTemplate);
        }

        // if present, siphon "copy" template
        if (copyTemplate) {
            // we want to save the copy template so that we'll always have
            //      access to it's original innerHTML (right now, only for
            //      debugging purposes)
            element.internalTemplates.copy = (
                copyTemplate.innerHTML
            );

            // determine the record copy columns from the "copy" template
            //      so that we can use them when we copy and we need to get data
            templateDetermineCopyColumnList(element, copyTemplate);

            // determine the copy headers from the "copy" template so
            //      that we can use them for when we copy and we need to use
            //      the headers
            templateDetermineCopyHeaderList(element, copyTemplate);

            //// remove the template element now that it's been siphoned
            //element.removeChild(copyTemplate);
        }

        // if present, siphon "insert-record" template
        if (insertRecordTemplate) {
            // commented out because we no longer put the styling on the cell
            //// append a token to the end of the style attribute of each
            ////      gs-cell (so that we can dynamically add CSS definitions)
            //templateCellAddStyleToken(insertRecordTemplate);

            // add a class of "table-insert" to each gs-cell for styling
            templateCellAddClass(insertRecordTemplate, 'table-insert');

            // add column numbers to the insert cells so that we can target
            //      these cells using column precision
            templateCellAddColumnNumber(insertRecordTemplate);

            // add row attributes so that the javascript can look at the cell
            //      and determine that it's an "insert" type cell
            templateCellAddRowNumber(insertRecordTemplate, 'insert');

            // save the template
            element.internalTemplates.insertRecord = (
                insertRecordTemplate.innerHTML.trim()
            );

            //// remove the template element now that it's been siphoned
            //element.removeChild(insertRecordTemplate);
        }

        // if present, siphon "insert-dialog" template
        if (insertDialogTemplate) {
            element.internalTemplates.insertDialog = (
                insertDialogTemplate.innerHTML.trim()
            );

            // remove the template element now that it's been siphoned
            element.removeChild(insertDialogTemplate);
        }

        // if present, siphon "update-dialog" template
        if (updateDialogTemplate) {
            // save the template
            strHTML = GS.templateColumnToValue(
                updateDialogTemplate.innerHTML.trim()
            );

            // let's save the original dialog template text so that we can
            //      modify it in the future
            element.internalTemplates.originalUpdateDialog = strHTML;

            // we're going run the dialog template through a function to
            //      turn all of the "column" attributes into "value" attributes
            //      with the proper templating
            element.internalTemplates.updateDialog = (
                GS.templateHideSubTemplates(strHTML, false)
            );

            //// remove the template element now that it's been siphoned
            //element.removeChild(updateDialogTemplate);
        }
    }

    // we need to use a web worker so that we can move processor expensive
    //      operations to another thread so that we dont freeze the UI
    function createWebWorker(element) {
        //var waitingFunction;
        //var handlerFunction;

        //// if no web worker support: throw error so that the developer knows
        ////      that the gs-table element requires web workers
        //if (window.Worker === undefined) {
        //    throw 'GS-TABLE Error: Web Workers are not supported by this ' +
        //            'browser. The GS-TABLE element requires the use of a ' +
        //            'Web Worker.';
        //}

        //// get web worker and store it
        //element.internalWorker.worker = new Worker('worker-gs-table.js');

        //// this function listens to the web worker after the web worker has
        ////      given the signal that it's ready
        //handlerFunction = function (event) {
        //    var jsnMessage = event.data;
        //    //console.log('handler received', jsnMessage);
        //};

        //// this function listens to the web worker until the worker gives the
        ////      signal that it's ready for use
        //waitingFunction = function (event) {
        //    var jsnMessage = event.data;
        //    //console.log('handler received', jsnMessage);

        //    if (jsnMessage.content === 'ready') {
                //// mark the worker as ready so that any code that can only run
                ////      while the worker is ready will now be able to run
                //element.internalWorker.ready = true;

                //// re-bind worker lister to the main listener code
                //element.internalWorker.worker.onmessage = handlerFunction;

        // run first select now that the worker is ready
        dataSELECT(element);

                ////console.log('worker ready');
        //    }
        //};

        ////element.internalWorker.worker.postMessage({"first": value});

        //// bind web worker message event so that we can begin using the worker
        //element.internalWorker.worker.onmessage = waitingFunction;
    }

// ############################################################################
// ############################## COPY FUNCTIONS ##############################
// ############################################################################

    // there are multiple places where we need to get the copy parameters, so
    //      we use this function so that we can have things like defaults and
    //      we don't need to update multiple sections of code to keep things in
    //      sync
    function getCopyParameters(element) {
        var headerMode;
        var selectorMode;
        var quoteChar;
        var escapeChar;
        var quoteMode;
        var recordDelimiter;
        var cellDelimiter;
        var nullString;

        // we need the user to be able to override the copy parameters so that
        //      they can format the copy in the way they need
        // if the attribute is present for a parameter, fill the variable with
        //      the attribute (and default to empty string) else default to
        //      parameter default
        if (element.getAttribute('copy-header')) {
            headerMode = element.getAttribute('copy-header') || '';
        } else {
            headerMode = 'selected';
        }
        if (element.getAttribute('copy-selectors')) {
            selectorMode = element.getAttribute('copy-selectors') || '';
        } else {
            selectorMode = 'selected';
        }
        if (element.getAttribute('copy-quote-char')) {
            quoteChar = element.getAttribute('copy-quote-char') || '';
        } else {
            quoteChar = '"';
        }
        if (element.getAttribute('copy-escape-char')) {
            escapeChar = element.getAttribute('copy-escape-char') || '';
        } else {
            escapeChar = quoteChar;
        }
        if (element.getAttribute('copy-quote-when')) {
            quoteMode = element.getAttribute('copy-quote-when') || '';
        } else {
            quoteMode = 'delimiter-in-content';
        }
        if (element.getAttribute('copy-delimiter-record')) {
            recordDelimiter =
                    element.getAttribute('copy-delimiter-record') || '';
        } else {
            recordDelimiter = '\n';
        }
        if (element.getAttribute('copy-delimiter-cell')) {
            cellDelimiter = element.getAttribute('copy-delimiter-cell') || '';
        } else {
            cellDelimiter = '\t';
        }
        if (element.getAttribute('copy-null-cell')) {
            nullString = element.getAttribute('copy-null-cell') || '';
        } else {
            nullString = '';
        }

        // we need to return multiple variables but return only allows one
        //      return value, so we'll return in JSON
        return {
            "headerMode": headerMode,
            "selectorMode": selectorMode,
            "quoteChar": quoteChar,
            "escapeChar": escapeChar,
            "quoteMode": quoteMode,
            "recordDelimiter": recordDelimiter,
            "cellDelimiter": cellDelimiter,
            "nullString": nullString
        };
    }

    // we need to know that we're working with valid copy attributes, so
    //      we use this function to throw an error if there is an invalid
    //      copy attribute
    // this function returns the copy parameters in JSON format if they
    //      are all valid
    function validateCopyParameters(element) {
        var jsnCopyParameters;

        // we need the user to be able to override the copy parameters so that
        //      they can format the copy in the way they need so here, we gather
        //      the copy parameters
        jsnCopyParameters = getCopyParameters(element);

        // we need to verify that the copy parameters are valid
        //console.log('headerMode:      ', jsnCopyParameters.headerMode);
        //console.log('selectorMode:    ', jsnCopyParameters.selectorMode);
        //console.log('quoteChar:       ', jsnCopyParameters.quoteChar);
        //console.log('escapeChar:      ', jsnCopyParameters.escapeChar);
        //console.log('quoteMode:       ', jsnCopyParameters.quoteMode);
        //console.log('recordDelimiter: ', jsnCopyParameters.recordDelimiter);
        //console.log('cellDelimiter:   ', jsnCopyParameters.cellDelimiter);
        //console.log('nullString:      ', jsnCopyParameters.nullString);

        //copy-header: always|never|selected
        if (
            !(/^(always|never|selected)$/gi)
                .test(jsnCopyParameters.headerMode)
        ) {
            throw 'GS-TABLE Error: Copy parameter "copy-header" invalid, ' +
                    'valid values are "always", "never" or "selected" ';
        }
        //copy-selectors: always|never|selected
        if (
            !(/^(always|never|selected)$/gi)
                .test(jsnCopyParameters.selectorMode)
        ) {
            throw 'GS-TABLE Error: Copy parameter "copy-selectors" invalid, ' +
                    'valid values are "always", "never" or "selected" ';
        }
        //copy-quote-when: never|strings|always|delimiter-in-content
        if (
            !(/^(never|strings|always|delimiter-in-content)$/gi)
                .test(jsnCopyParameters.quoteMode)
        ) {
            throw 'GS-TABLE Error: Copy parameter "copy-quote-when" invalid, ' +
                    'valid values are "never", "strings", "always" or ' +
                    '"delimiter-in-content".';
        }
        //copy-delimiter-record: not empty
        if (jsnCopyParameters.recordDelimiter.length === 0) {
            throw 'GS-TABLE Error: Copy parameter "copy-delimiter-record" ' +
                    'cannot be empty.';
        }
        //copy-delimiter-cell: not empty
        if (jsnCopyParameters.cellDelimiter.length === 0) {
            throw 'GS-TABLE Error: Copy parameter "copy-delimiter-cell" ' +
                    'cannot be empty.';
        }

        // this function gets the copy parameters on it's own, so if a function
        //      were to call this function, we wouldn't want to have to re-get
        //      the copy parameters in that function, so we return the copy
        //      parameters
        return jsnCopyParameters;
    }

    // we need to be able to override the clipbard for specific mime types on a
    //      copy event, this function accepts the copy event, the copy string
    //      and the mime type to override
    function handleClipboardData(event, strCopyString, strType) {
        var clipboardData = event.clipboardData || window.clipboardData;
        var strMime;

        if (!clipboardData) {
            return;
        }
        if (!clipboardData.setData) {
            return;
        }

        if (strType === 'text') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = 'Text';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/plain';
            }
        } else if (strType === 'html') {
            if (window.clipboardData && window.clipboardData.getData) { // IE
                strMime = '';
            } else if (event.clipboardData && event.clipboardData.getData) {
                strMime = 'text/html';
            }
        } else {
            throw 'handleClipboardData Error: Type "' + strType + '" not ' +
                    'recognized, recognized types are "text" and "html".';
        }

        if (strMime) {
            if (strCopyString && strMime) {
                return clipboardData.setData(strMime, strCopyString) !== false;
            } else {
                return clipboardData.getData(strMime);
            }
        }
    }

    function getCopyStrings(element) {
        var strTextCopyString;
        var strHTMLCopyString;
        var strHTMLRecordCopyString;
        var row_i;
        var row_len;
        var col_i;
        var col_len;
        var cell;
        var row;
        var char;
        var record_i;
        var record_len;
        var cell_i;

        var jsnCopyParameters;
        var quoteChar;
        var escapeChar;
        var quoteMode;
        var selectorMode;
        var headerMode;
        var recordDelimiter;
        var cellDelimiter;
        var nullString;

        var arrColumns;
        var arrRows;
        var bolHeader;
        var bolSelector;
        var arrHeaders;
        var arrColumnTemplates;
        var arrColumnNames;
        var arrSelection;
        var intRow;
        var intCol;
        var intSel;

        var handleCell;
        var jsnQS;
        var jsnRow;
        var arrRow;
        var strRow;
        var strHeader;

        var arrSelectedStates = ['B', 'D', 'F', 'H', 'J', 'L'];

        var cell_len;
        var delim;

        // define the text copy string as empty string so that we can just
        //      append to it without causing an issue where "undefined" is
        //      at the beginning of the string
        strTextCopyString = '';

        // define the HTML copy string as a beginning table tag, so that
        //      we only have to append to the string
        strHTMLCopyString =
                '<' + 'style>' +
                'br { mso-data-placement:same-cell; } ' +
                'th, td { white-space: pre-wrap; }' +
                '<' + '/style>' +
                '<' + 'table border="0" cellpadding="0" cellspacing="0">';

        strHTMLRecordCopyString = '';

        // cache copy column template stringss for speed
        arrColumnTemplates = element.internalClip.columnList.slice(0);

        // convert the column template strings into dot.js functions for speed
        col_i = 0;
        col_len = arrColumnTemplates.length;
        while (col_i < col_len) {
            arrColumnTemplates[col_i] =
                    '{{ var qs = jo.qs' +
                    ', row = jo.row' +
                    ', arrRow = jo.arrRow' +
                    ', i = jo.i' +
                    ', len = jo.len; }}' +
                    arrColumnTemplates[col_i];

            arrColumnTemplates[col_i] = doT.template(
                arrColumnTemplates[col_i]
            );

            col_i += 1;
        }

        // we need the user to be able to override the copy parameters so that
        //      they can format the copy in the way they need so here, we gather
        //      the copy parameters
        jsnCopyParameters = getCopyParameters(element);
        quoteChar = jsnCopyParameters.quoteChar;
        escapeChar = jsnCopyParameters.escapeChar;
        quoteMode = jsnCopyParameters.quoteMode;
        selectorMode = jsnCopyParameters.selectorMode;
        headerMode = jsnCopyParameters.headerMode;
        recordDelimiter = jsnCopyParameters.recordDelimiter;
        cellDelimiter = jsnCopyParameters.cellDelimiter;
        nullString = jsnCopyParameters.nullString;

        // we dont want to recalculate the Query String JSON once for every
        //      cell, so here we calculate it once (in JSON format)
        jsnQS = GS.qryToJSON(GS.getQueryString());

        // bring copy variables in for easy access
        arrColumnNames = element.internalData.columnNames;
        arrSelection = element.internalSelection.resolvedSelection.slice(0);
        arrColumns = element.internalSelection.columns.slice(0);
        arrRows = element.internalSelection.rows.slice(0);
        arrHeaders = element.internalClip.headerList.slice(0);

        // if the header is selected, remove it from the list and save it
        //  in another location
        if (
            (
                headerMode === 'selected' &&
                arrRows[0] === 'header'
            ) ||
            (
                headerMode === 'always'
            )
        ) {
            bolHeader = true;
        }
        if (arrRows[0] === 'header') {
            arrRows.shift();
        }
        if (element.internalDisplay.headerVisible) {
            strHeader = arrSelection[0]; //.shift();
        }

        // if a selector is selected and we don't copy those, remove it from
        //      the list
        if (
            (
                selectorMode === 'selected' &&
                arrColumns[0] === 'selector'
            ) ||
            (
                selectorMode === 'always'
            )
        ) {
            bolSelector = true;
        }
        if (arrColumns[0] === 'selector') {
            arrColumns.shift();
        }

        // if the insert record is selected, remove it from the list
        if (arrRows[arrRows.length - 1] === 'insert') {
            arrRows.pop();
        }

        // convert the header template strings into dot.js functions for speed
        col_i = 0;
        col_len = arrHeaders.length;
        while (col_i < col_len) {
            arrHeaders[col_i] = doT.template(
                '{{ var qs = jo.qs; }}' +
                arrHeaders[col_i]
            );
            col_i += 1;
        }

        //console.log(
        //    arrColumns,
        //    arrRows
        //);

        // to handle different quoting policies, we define the "handleCell"
        //      function differently depending on the "quoteMode" variable
        // the "handleCell" function handles quoting, querystring template
        //      and row templating
        // defining the "handleCell" function conditionally is going to make
        //      the "handleCell" function faster because it doesn't have to
        //      recalculate the quote policy once fo reach cell
        //copy-quote-when: never|strings|always|delimiter-in-content
        if (quoteMode === 'never') {
            // no quoting,
            //      template cell with querystring and row
            //      append cell to strTextCopyString
            handleCell = function (cellTemplate, i, len, jsnRow, arrRow) {
                // template cell with querystring and row
                var strCell = cellTemplate({
                    'qs': jsnQS,
                    'row': jsnRow,
                    'arrRow': arrRow,
                    'i': i,
                    'len': len
                });

                // append cell to the HTML copy string
                strHTMLRecordCopyString +=
                        '<' + 'td rowspan="1" colspan="1">' +
                        strCell +
                        '</td>';

                // append cell to the text copy string
                strTextCopyString += strCell;
            };
        } else if (quoteMode === 'strings') {
            // string quoting,
            //      template cell with querystring and row
            //      if escapeChar !== quoteChar: double up every escapeChar
            //      put an escapeChar behind every quoteChar
            //      if NaN: wrap cell with quoteChar
            //      append cell to strTextCopyString
            handleCell = function (cellTemplate, i, len, jsnRow, arrRow) {
                // template cell with querystring and row
                var strCell = cellTemplate({
                    'qs': jsnQS,
                    'row': jsnRow,
                    'arrRow': arrRow,
                    'i': i,
                    'len': len
                });

                // before we do any quoting, we need to add the HTML to the
                //      HTML copy string
                strHTMLRecordCopyString +=
                        '<' + 'td rowspan="1" colspan="1">' +
                        strCell +
                        '</td>';

                // if escapeChar !== quoteChar: double up every escapeChar
                if (escapeChar !== quoteChar) {
                    strCell = stringReplaceAll(
                        strCell,
                        escapeChar,
                        escapeChar + escapeChar
                    );
                }

                // put an escapeChar behind every quoteChar
                strCell = stringReplaceAll(
                    strCell,
                    quoteChar,
                    escapeChar + quoteChar
                );

                // if NaN: wrap cell with quoteChar
                if (isNaN(strCell)) {
                    strCell = quoteChar + strCell + quoteChar;
                }

                // append cell to copy string
                strTextCopyString += strCell;
            };
        } else if (quoteMode === 'always') {
            // string quoting,
            //      template cell with querystring and row
            //      if escapeChar !== quoteChar: double up every escapeChar
            //      put an escapeChar behind every quoteChar
            //      wrap cell with quoteChar
            //      append cell to strTextCopyString
            handleCell = function (cellTemplate, i, len, jsnRow, arrRow) {
                // template cell with querystring and row
                var strCell = cellTemplate({
                    'qs': jsnQS,
                    'row': jsnRow,
                    'arrRow': arrRow,
                    'i': i,
                    'len': len
                });

                // before we do any quoting, we need to add the HTML to the
                //      HTML copy string
                strHTMLRecordCopyString +=
                        '<' + 'td rowspan="1" colspan="1">' +
                        strCell +
                        '</td>';

                // if escapeChar !== quoteChar: double up every escapeChar
                if (escapeChar !== quoteChar) {
                    strCell = stringReplaceAll(
                        strCell,
                        escapeChar,
                        escapeChar + escapeChar
                    );
                }

                // put an escapeChar behind every quoteChar
                strCell = stringReplaceAll(
                    strCell,
                    quoteChar,
                    escapeChar + quoteChar
                );

                // wrap cell with quoteChar
                strCell = quoteChar + strCell + quoteChar;

                // append cell to copy string
                strTextCopyString += strCell;
            };
        } else if (quoteMode === 'delimiter-in-content') {
            // string quoting,
            //      template cell with querystring and row
            //      if escapeChar !== quoteChar: double up every escapeChar
            //      if quoteChar inside cell
            //          put an escapeChar behind every quoteChar
            //          wrap cell with quoteChar
            //      append cell to strTextCopyString
            handleCell = function (cellTemplate, i, len, jsnRow, arrRow) {
                // template cell with querystring and row
                var strCell = cellTemplate({
                    'qs': jsnQS,
                    'row': jsnRow,
                    'arrRow': arrRow,
                    'i': i,
                    'len': len
                });

                // before we do any quoting, we need to add the HTML to the
                //      HTML copy string
                strHTMLRecordCopyString += (
                    '<' + 'td rowspan="1" colspan="1">' +
                    strCell +
                    '</td>'
                );

                // if escapeChar !== quoteChar: double up every escapeChar
                if (escapeChar !== quoteChar) {
                    strCell = stringReplaceAll(
                        strCell,
                        escapeChar,
                        escapeChar + escapeChar
                    );
                }

                // if quoteChar is inside cell
                if (strCell.indexOf(quoteChar) !== -1) {
                    // put an escapeChar behind every quoteChar
                    strCell = stringReplaceAll(
                        strCell,
                        quoteChar,
                        escapeChar + quoteChar
                    );

                    // wrap cell with quoteChar
                    strCell = quoteChar + strCell + quoteChar;
                }

                // append cell to copy string
                strTextCopyString += strCell;
            };
        }

        //console.log(
        //    bolHeader,
        //    bolSelector,
        //    strHeader,
        //    arrRows,
        //    arrColumns
        //);

        // if the header has selected cells, we need to build the header
        if (bolHeader && headerMode !== 'never') {
            // if there are selectors selected, because the header also
            //      has selected columns we need the all selector to fill
            //      in the space to the left of the header that's made
            //      when there are selectors present
            if (bolSelector && selectorMode !== 'never') {
                // if the "quoteMode" is "always": we need to add a pair
                //      of quotes where this extra cell is
                if (quoteMode === 'always') {
                    strTextCopyString += quoteChar + quoteChar;
                }

                // and finally, add the delimiter
                strTextCopyString += cellDelimiter;

                // add an empty cell to the HTML copy string to make room
                //      for the record selector column
                strHTMLRecordCopyString += (
                    '<td rowspan="1" colspan="1"></td>'
                );
            }

            //console.log(arrSelectedStates);
            //console.log(arrHeaders.slice(0));

            // loop to add the rest of the headers
            col_i = 0;
            col_len = arrColumns.length;
            while (col_i < col_len) {
                // we want to put a delimiter between each cell
                if (col_i > 0) {
                    strTextCopyString += cellDelimiter;
                }

                intSel = arrColumns[col_i];
                intCol = intSel;
                if (element.internalDisplay.recordSelectorVisible) {
                    intSel = (arrColumns[col_i] + 1);
                    intCol = (intSel - 1);
                }

                //console.log(
                //    col_i,
                //    intSel,
                //    intCol,
                //    strHeader[intSel],
                //    arrHeaders[intCol]
                //);

                // template, quote and append cell to copy string
                if (
                    headerMode === 'always' ||
                    arrSelectedStates.indexOf(strHeader[intSel]) > -1
                ) {
                    handleCell(arrHeaders[intCol], 0, 0);

                } else {
                    strHTMLRecordCopyString += (
                        '<' + 'td rowspan="1" colspan="1"></td>'
                    );

                    if (quoteMode === 'always') {
                        strTextCopyString += quoteChar + quoteChar;
                    }
                }

                col_i += 1;
            }

            // append record to HTML copy string, clear current record variable
            strHTMLCopyString += '<tr>' + strHTMLRecordCopyString + '</tr>';
            strHTMLRecordCopyString = '';

            // if there are records selected, we want to seperate the header
            //      and the first row using the record delimiter
            if (arrRows.length > 0) {
                strTextCopyString += recordDelimiter;
            }
        }

        // <br />
        //console.log(arrHeaders.slice(0));

        // we cache the number of columns because it doesn't change
        col_len = arrColumns.length;

        // we need to get the range
        row_i = 0;
        row_len = arrRows.length;

        // loop through the rows
        while (row_i < row_len) {
            intSel = arrRows[row_i];
            intRow = intSel;
            if (element.internalDisplay.headerVisible) {
                intSel = (arrRows[row_i] + 1);
                intRow = (intSel - 1);
            }

            // we need to know the selection status of this record
            row = arrSelection[intSel];

            // generate record JSON for template
            jsnRow = {};
            arrRow = [];
            strRow = element.internalData.records[intRow] + '\t';

            cell_i = 0;
            cell_len = 9999;
            while (cell_i < cell_len) {// remember, requires \t at
                                       //       the end of the record
                delim = strRow.indexOf('\t');
                cell = strRow.substring(0, delim);
                strRow = strRow.substring(delim + 1);

                //console.log(arrColumnNames[cell_i], cell);
                if (cell !== '' || strRow !== '') {
                    jsnRow[arrColumnNames[cell_i]] = (
                        GS.decodeFromTabDelimited(cell, nullString)
                    );
                    arrRow.push(jsnRow[arrColumnNames[cell_i]]);
                } else {
                    break;
                }

                cell_i += 1;
            }
            //console.log(jsnRow);
            //console.log(strRow);
            //console.log(arrRow);

            // version 1, broken: last cell has one char missing, replaced
            //      with faster solution
            //record_i = 0;
            //record_len = strRow.length;
            //cell_i = 0;
            //cell = "";
            //while (record_i < record_len) {
            //    char = strRow[record_i];

            //    if (char === "\t" || record_i === (record_len - 1)) {
            //        jsnRow[arrColumnNames[cell_i]] = (
            //            GS.decodeFromTabDelimited(cell, nullString)
            //        );

            //        cell = "";
            //        cell_i += 1;
            //    } else {
            //        cell += char;
            //    }
            //    record_i += 1;
            //}

            //console.log(
            //    row_i,
            //    intSel,
            //    intRow,
            //    strRow,
            //    jsnRow
            //);

            // if record selectors are allowed: add record number
            if (
                bolSelector &&
                (
                    selectorMode === 'always' ||
                    (
                        selectorMode === 'selected' &&
                        arrSelectedStates.indexOf(row[0]) > -1
                    )
                )
            ) {
                strTextCopyString += (intRow + 1);

                strHTMLRecordCopyString += (
                    '<td rowspan="1" colspan="1">' + (intRow + 1) + '</td>'
                );
            }

            // no matter if we copied the record selector or not,
            //      we need the delimiter if we are copying some
            //      selectors
            if (bolSelector && col_len > 0) {
                strTextCopyString += cellDelimiter;
            }

            col_i = 0;
            while (col_i < col_len) {
                // we want to put a delimiter between each cell
                if (col_i > 0) {
                    strTextCopyString += cellDelimiter;
                }

                intSel = arrColumns[col_i];
                intCol = intSel;
                if (element.internalDisplay.recordSelectorVisible) {
                    intSel = (arrColumns[col_i] + 1);
                    intCol = (intSel - 1);
                }

                //console.log(
                //    col_i,
                //    intSel,
                //    intCol,
                //    strHeader[intSel],
                //    arrHeaders[intCol]
                //);

                // template, quote and append cell to copy string
                if (arrSelectedStates.indexOf(row[intSel]) > -1) {
                    handleCell(
                        arrColumnTemplates[arrColumns[col_i]],
                        row_i,
                        row_len,
                        jsnRow,
                        arrRow
                    );

                } else {
                    strHTMLRecordCopyString += (
                        '<' + 'td rowspan="1" colspan="1"></td>'
                    );

                    if (quoteMode === 'always') {
                        strTextCopyString += quoteChar + quoteChar;
                    }
                }

                col_i += 1;
            }

            // append record to HTML copy string, clear current record variable
            strHTMLCopyString += '<tr>' + strHTMLRecordCopyString + '</tr>';
            strHTMLRecordCopyString = '';

            // add record delimiter (unless we're on the last record)
            if ((row_i + 1) < row_len) {
                strTextCopyString += recordDelimiter;
            }
            row_i += 1;
        }

        // add the ending table tag to the HTML copy string
        strHTMLCopyString += '</table>';

        // now we'll take our column and row arrays and convert them to a
        //      text MIME type copy string
        //console.log('arrColumns: ', arrColumns);
        //console.log('arrRows: ', arrRows);
        //console.log('arrSelection: ', arrSelection);
        //console.log('HTML:\n' + strHTMLCopyString);
        //console.log('TEXT:\n' + strTextCopyString);




//
//
//            // loop through columns and template
//            col_i = 0;
//            while (col_i < col_len) {
//                intCol = col_i;
//
//                // if record selectors are visible, we need to offset
//                //      where we look for the column select state
//                if (element.internalDisplay.recordSelectorVisible) {
//                    intCol = arrColumns[col_i] + 1;
//                }
//
//                // we want to put a delimiter between each cell NEEDS WORK
//                if (
//                    arrColumns[col_i - 1] !== 'selector' &&
//                    arrColumns[col_i - 1] !== undefined
//                ) {
//                    strTextCopyString += cellDelimiter;
//                }
//
//                // if this cell is selected: template, quote and
//                //      append cell to copy string
//                if (arrSelectedStates.indexOf(row[intCol]) > -1) {
//                    handleCell(
//                        arrColumnTemplates[arrColumns[col_i]],
//                        row_i,
//                        row_len,
//                        jsnRow
//                    );
//                }
//
//                col_i += 1;
//            }
//
//        //console.log(strTextCopyString);

        return {
            "text": strTextCopyString,
            "html": strHTMLCopyString
        };
    }

// ############################################################################
// ############################# RENDER FUNCTIONS #############################
// ############################################################################

    function updateHUD(element) {
        var arrDataColumns;
        var sortASCButton;
        var sortDESCButton;
        var sortClearButton;
        var statusElement;
        var intOriginRecord;

        // I don't know who put this here but it wasn't commented. If you put
        //      this here: explain yourself. This is the HUD button status
        //      updating function, this has nothing to do with selection.
        //      I suppose this function is called after a selection so someone
        //      thought they were being clever and decided that this was the
        //      place to trigger such an event. But, I should remind you that
        //      we have a selection render function that may have worked the
        //      same but would have been more consistent and clear.
        //  ~Michael
        GS.triggerEvent(element, 'selection_change');

        // disable/enable hud sorting buttons
        sortASCButton = findHudElement(element, 'button-sort-asc');
        sortDESCButton = findHudElement(element, 'button-sort-desc');
        sortClearButton = findHudElement(element, 'button-sort-clear');

        // we need an array of the selected data columns
        arrDataColumns = getSelectedDataColumns(element);

        //console.log(arrDataColumns);

        // if there are data columns selected, enable sort buttons
        if (arrDataColumns.length > 0) {
            if (sortASCButton) {
                sortASCButton.removeAttribute('disabled');
            }
            if (sortDESCButton) {
                sortDESCButton.removeAttribute('disabled');
            }
            if (sortClearButton) {
                sortClearButton.removeAttribute('disabled');
            }

        // else, no data columns selected, disable sort buttons
        } else {
            if (sortASCButton) {
                sortASCButton.setAttribute('disabled', '');
            }
            if (sortDESCButton) {
                sortDESCButton.setAttribute('disabled', '');
            }
            if (sortClearButton) {
                sortClearButton.setAttribute('disabled', '');
            }
        }
    }

    function renderSelection(element) {//<br />
        var bolHeaders;
        var bolSelectors;
        var bolInsert;
        var col_i;
        var col_len;
        var rec_i;
        var rec_len;
        var strRecord;
        var arrSelection;
        var range_i;
        var range_len;
        var range;
        var arrRanges;
        var arrColumnWidths;
        var rangeStartRow;
        var rangeStartColumn;
        var rangeEndRow;
        var rangeEndColumn;
        var intOriginRecord;
        var jsnSelectedToDeselected;
        var jsnDeselectedToSelected;
        var jsnTranslationMatrix;
        var intRecord;
        var intColumn;
        var intChar;
        var intHeaderIndex;
        var intSelectorIndex;
        var intInsertIndex;
        var jsnRange;
        var strCompareString;

        var arrElements;
        var i;
        var len;
        var cell;
        var strRow;
        var strCol;
        var intRow;
        var intCol;
        var arrSelectedStates;
        //var arrDeselectedStates;

        var arrColumns;
        var arrRows;
        var intMaxColumns;
        var arrSelectionRows;
        var arrSelectionCols;
        var pushValue;

        //console.time('selection total');

        // first, we should gather some helper variables.
        bolHeaders = (element.internalDisplay.headerVisible);
        bolSelectors = (!element.hasAttribute('no-record-selector'));
        bolInsert = (element.internalDisplay.insertRecordVisible);
        arrSelection = [];

        strCompareString = selectionArrayToString(
            element.internalSelection.ranges
        );

        // create the blank slate for the resolved selection
        //      Type:              Unselected:   Selected:
        //      HEADER CELL        A             B
        //      RECORD CELL        C             D
        //      INSERT CELL        E             F
        //      ALL SELECTOR       G             H
        //      RECORD SELECTOR    I             J
        //      INSERT SELECTOR    K             L
        arrSelectedStates = ['B', 'D', 'F', 'H', 'J', 'L'];
        //arrDeselectedStates = ['A', 'C', 'E', 'G', 'I', 'K'];

        if (strCompareString === element.internalSelection.rangeCache) {
            arrSelection = element.internalSelection.resolvedSelection;
            arrSelectionRows = element.internalSelection.rows;
            arrSelectionCols = element.internalSelection.columns;
            arrRanges = element.internalSelection.ranges;
            arrColumnWidths = element.internalDisplay.columnWidths;
            arrRows = arrSelectionRows;
            arrColumns = arrSelectionCols;

        } else {
            element.internalSelection.rangeCache = strCompareString;

            col_len = element.internalDisplay.columnWidths.length;

            if (bolHeaders) {
                strRecord = '';
                if (bolSelectors) {
                    strRecord += 'G';
                }

                col_i = 0;
                while (col_i < col_len) {
                    strRecord += 'A';
                    col_i += 1;
                }
                arrSelection.push(strRecord);
            }

            strRecord = '';
            if (bolSelectors) {
                strRecord = 'I';
            }

            col_i = 0;
            while (col_i < col_len) {
                strRecord += 'C';
                col_i += 1;
            }

            rec_i = 0;
            rec_len = element.internalData.records.length;
            while (rec_i < rec_len) {
                arrSelection.push(strRecord);
                rec_i += 1;
            }

            if (bolInsert) {
                strRecord = '';
                if (bolSelectors) {
                    strRecord += 'K';
                }

                col_i = 0;
                while (col_i < col_len) {
                    strRecord += 'E';
                    col_i += 1;
                }
                arrSelection.push(strRecord);
            }

            //console.log(arrSelection);

            // because of the vast array of column types, we'll (for simplicity
            //      and for brevity) use one of two matrices, a matrix that
            //      translates a selected cell to a deselected cell and one to
            //      do the opposite
            jsnSelectedToDeselected = {
                "A": "A",
                "B": "A",
                "C": "C",
                "D": "C",
                "E": "E",
                "F": "E",
                "G": "G",
                "H": "G",
                "I": "I",
                "J": "I",
                "K": "K",
                "L": "K"
            };
            jsnDeselectedToSelected = {
                "A": "B",
                "B": "B",
                "C": "D",
                "D": "D",
                "E": "F",
                "F": "F",
                "G": "H",
                "H": "H",
                "I": "J",
                "J": "J",
                "K": "L",
                "L": "L"
            };

            // because math is faster that string comparison, we need to convert
            //      the special values inside the ranges to numbers. but, we
            //      don't want to recalculate those numbers every time, so,
            //      we'll calculate them here and just reuse them
            intHeaderIndex = -1;
            intSelectorIndex = -1;
            intInsertIndex = (
                bolInsert
                    ? (arrSelection.length - 1)
                    : null
            );
            if (bolHeaders) {
                intInsertIndex -= 1;
            }

            //console.log(intInsertIndex);
            //console.time('selection resolve');

            // loop through each selection and flip the states of the
            //      affected cells
            arrRanges = element.internalSelection.ranges;
            arrColumnWidths = element.internalDisplay.columnWidths;
            range_i = 0;
            range_len = arrRanges.length;
            while (range_i < range_len) {
                range = arrRanges[range_i];

                // we want to copy the range element so that when we modify it
                //      we don't modify the original
                range = {
                    "start": {
                        "row": range.start.row,
                        "column": range.start.column
                    },
                    "end": {
                        "row": range.end.row,
                        "column": range.end.column
                    },
                    "negator": range.negator
                };

                //console.log(range);

                // gotta convert special values so that we can use math
                if (range.start.row === 'header') {
                    range.start.row = intHeaderIndex;
                } else if (range.start.row === 'insert') {
                    range.start.row = intInsertIndex;
                }
                if (range.end.row === 'header') {
                    range.end.row = intHeaderIndex;
                } else if (range.end.row === 'insert') {
                    range.end.row = intInsertIndex;
                }
                if (range.start.column === 'selector') {
                    range.start.column = intSelectorIndex;
                }
                if (range.end.column === 'selector') {
                    range.end.column = intSelectorIndex;
                }

                // because the end of the selection may be above and to the left
                //      of the start of the selection, we need to be sure that:
                //          the start row/column is the top-left
                //          the end row/column is the bottom-right
                rangeStartRow = Math.min(range.start.row, range.end.row);
                rangeEndRow = Math.max(range.start.row, range.end.row);
                rangeStartColumn = Math.min(
                    range.start.column,
                    range.end.column
                );
                rangeEndColumn = Math.max(range.start.column, range.end.column);

                // if this is the first selection, save the origin record
                //      number for future reference
                if (range_i === 0) {
                    intOriginRecord = rangeStartRow;

                    // the header can't be the origin record
                    if (intOriginRecord === -1) {
                        intOriginRecord += 1;
                    }

                    // save origin record internally
                    element.internalSelection.originRecord = intOriginRecord;
                }

                // if we are dealing with a non-negation selection, use the
                //      jsnDeselectedToSelected translation matrix
                if (range.negator === false) {
                    jsnTranslationMatrix = jsnDeselectedToSelected;

                // else, use the jsnSelectedToDeselected translation matrix
                } else {
                    jsnTranslationMatrix = jsnSelectedToDeselected;
                }

                rec_i = 0;
                rec_len = arrSelection.length;
                while (rec_i < rec_len) {
                    strRecord = arrSelection[rec_i];
                    intRecord = rec_i;

                    if (bolHeaders) {
                        intRecord -= 1;
                    }

                    // if the row is in range or all rows are in the range:
                    //      iterate through cells in the row
                    //console.log(intRecord, rangeStartRow, rangeEndRow);
                    if (
                        (
                            intRecord >= rangeStartRow &&
                            intRecord <= rangeEndRow
                        ) ||
                        (
                            rangeStartRow === -1 &&
                            rangeEndRow === -1
                        )
                    ) {
                        col_i = 0;
                        col_len = strRecord.length;
                        while (col_i < col_len) {
                            intChar = col_i;
                            intColumn = col_i;

                            if (bolSelectors) {
                                intColumn = (col_i - 1);
                            }

                            //if (rec_i === 0) {
                            //    //console.log(
                            //        'intChar:',
                            //        intChar,
                            //        'intColumn:',
                            //        intColumn,
                            //        'rangeStartColumn:',
                            //        rangeStartColumn,
                            //        'rangeEndColumn:',
                            //        rangeEndColumn
                            //    );
                            //}

                            // testing to see if th cell is in the current
                            //      selection range or that the whole record is
                            //      selected
                            if (
                                (
                                    (
                                        intColumn >= rangeStartColumn &&
                                        intColumn <= rangeEndColumn
                                    ) ||
                                    (
                                        rangeStartColumn === -1 &&
                                        rangeEndColumn === -1
                                    )
                                ) &&
                                // we don't want to copy hidden columns
                                (
                                    intColumn === null ||
                                    intColumn === -1 ||
                                    arrColumnWidths[intColumn] > 0
                                )
                            ) {
                                // set cell to "Y" because it is in the
                                //      selection range
                                strRecord = (
                                    strRecord.substr(0, intChar) +
                                    jsnTranslationMatrix[strRecord[intChar]] +
                                    strRecord.substr(intChar + 1)
                                );
                            }
                            col_i += 1;
                        }

                        arrSelection[rec_i] = strRecord;
                    }

                    rec_i += 1;
                }

                range_i += 1;
            }

            // now, we'll convert the array of rows to an array of record
            //      numbers that will be copied (arrRows)
            arrRows = [];
            arrSelectionRows = [];
            rec_i = 0;
            rec_len = arrSelection.length;
            while (rec_i < rec_len) {
                // if the row is selected, add it to the list
                if ((/[BDFHJL]/gi).test(arrSelection[rec_i])) {
                    if (bolHeaders && rec_i === 0) {
                        arrRows.push('header');

                    } else if (bolInsert && rec_i === (rec_len - 1)) {
                        arrRows.push('insert');

                    } else if (bolHeaders) {
                        arrRows.push(rec_i - 1);

                    } else {
                        arrRows.push(rec_i);
                    }
                    arrSelectionRows.push(rec_i);
                }
                rec_i += 1;
            }

            // we'll loop through every row that has a selected cell in it
            //      (arrRows) and for every "Y" we'll add the column number
            //      (if it's not already present) to our column array we'll
            //      break out of the loop if all columns are included
            arrColumns = [];
            arrSelectionCols = [];
            intMaxColumns = element.internalClip.columnList.length;
            rec_i = 0;
            rec_len = arrSelectionRows.length;
            while (rec_i < rec_len) {
                strRecord = arrSelection[arrSelectionRows[rec_i]];
                col_i = 0;
                col_len = strRecord.length;
                while (col_i < col_len) {
                    if (bolSelectors && col_i === 0) {
                        pushValue = ('selector');
                    } else if (bolSelectors) {
                        pushValue = (col_i - 1);
                    } else {
                        pushValue = col_i;
                    }

                    if (
                        arrSelectedStates.indexOf(strRecord[col_i]) !== -1 &&
                        arrColumns.indexOf(pushValue) === -1
                    ) {
                        arrColumns.push(pushValue);
                        arrSelectionCols.push(col_i);
                    }

                    col_i += 1;
                }

                if (arrColumns.length >= intMaxColumns) {
                    break;
                }

                rec_i += 1;
            }
        }

        //console.timeEnd('selection resolve');

        //var test = arrSelection.join('\n');
        //console.log(test.substring(test.length - 20));

        //console.time('selection render');

        // grab all visible cells
        arrElements = xtag.query(element.elems.dataViewport, 'gs-cell');

        // deselect all visible cells
        i = 0;
        len = arrElements.length;
        while (i < len) {
            arrElements[i].removeAttribute('selected');
            arrElements[i].removeAttribute('origin-record');
            arrElements[i].removeAttribute('auto-selected');
            i += 1;
        }

        // select all visible cells that are marked as such in the
        //      resolved selection
        i = 0;
        len = arrElements.length;
        while (i < len) {
            cell = arrElements[i];
            strRow = (
                cell.getAttribute('data-row-number') ||
                '-1'
            );
            strCol = (
                cell.getAttribute('data-col-number') ||
                cell.getAttribute('data-col') ||
                '-1'
            );

            intRow = parseInt(strRow, 10);
            intCol = parseInt(strCol, 10);

            if (bolHeaders) {
                intRow += 1;
            }
            if (bolSelectors) {
                intCol += 1;
            }

            if (strRow === 'insert') {
                intRow = (arrSelection.length - 1);
            }

            if (strCol === 'selector') {
                intCol = 0;
            }

            // highlight origin record
            if (
                //(
                (
                    !bolHeaders &&
                    intRow === intOriginRecord
                ) ||
                (
                    bolHeaders &&
                    intRow === (intOriginRecord + 1)
                )
                //) &&
                //(
                //    !cell.classList.contains('table-insert-selector') &&
                //    !cell.classList.contains('table-record-selector')
                //)
            ) {
                arrElements[i].setAttribute('origin-record', '');
            }

            strRecord = arrSelection[intRow];
            //console.log(intRow, intCol, strRecord);
            if (strRecord) {
                if (arrSelectedStates.indexOf(strRecord[intCol]) > -1) {
                    cell.setAttribute('selected', '');

                // sometimes, the user selects some cells without selecting the
                //      record selectors and/or headers. in this case, we want
                //      to highlight the record selectors and headers of the
                //      selected range
                } else if (
                    (
                        (
                            cell.classList.contains('table-insert-selector') ||
                            cell.classList.contains('table-record-selector')
                        ) &&
                        (
                            arrSelectionRows.indexOf(intRow) > -1
                        )
                    ) ||
                    (
                        (
                            cell.classList.contains('table-all-selector') ||
                            cell.classList.contains('table-header')
                        ) &&
                        (
                            arrSelectionCols.indexOf(intCol) > -1
                        )
                    )
                ) {
                    //console.log(strRow, intRow);
                    cell.setAttribute('auto-selected', '');
                }
            }

            i += 1;
        }

        //console.timeEnd('selection render');

        // store selection variables internally for future reference
        element.internalSelection.resolvedSelection = arrSelection;
        element.internalSelection.rows = arrRows;
        element.internalSelection.columns = arrColumns;

        // you are not allowed to deselect everything, if you have, we'll
        //      select what we can and then re-render the selection
        if (arrRows.length === 0 || arrColumns.length === 0) {
            // if there is data and the current range is not already selecting
            //      the first cell, select the first cell
            //console.log(element.internalSelection.ranges);
            jsnRange = element.internalSelection.ranges[0];

            if (
                element.internalData.records.length > 0 && (
                    element.internalSelection.ranges &&
                    (
                        element.internalSelection.ranges.length !== 1 ||
                        jsnRange.start.row !== 0 ||
                        jsnRange.start.column !== 0 ||
                        jsnRange.end.row !== 0 ||
                        jsnRange.end.column !== 0 ||
                        jsnRange.negator !== false
                    )
                )
            ) {
                element.internalSelection.ranges = [
                    {
                        "start": {
                            "row": 0,
                            "column": 0
                        },
                        "end": {
                            "row": 0,
                            "column": 0
                        },
                        "negator": false
                    }
                ];

                // if we are currently selecting with the mouse, stop the
                //      selection
                if (element.internalSelection.currentlySelecting) {
                    element.internalEvents.selectDragEnd();
                }

                // rerender the selection so that the user can see it
                renderSelection(element);

                // stop execution because we'll be re-running this function
                //      anyway
                return;
            }
        }

        //console.timeEnd('selection total');

        // update hud, because it uses the selection
        updateHUD(element);
    }

    //We had an issue where if the viewport was to small everything inside
    //  the viewport would break, this function removes everything inside
    //  the viewport so there's nothing inside there to break, Genius right?
    function renderEmpty(element) {
        element.elems.dataViewport.innerhtml = '';
    }

    function renderLocationFull(element) {
        //var arrColumnWidths;
        //var arrRecordHeights;
        //var columnBorderWidth;
        //var recordBorderHeight;

        var jsnRange;
        var fromColumn;
        var toColumn;
        var fromRecord;
        var toRecord;

        var i;
        var len;
        var col_i;
        var col_len;
        //var record_i;
        //var record_len;

        //var intCellLeft;
        //var intCellOriginLeft;
        //var intRecordTop;
        //var intRecordOriginTop;

        var arrColumnNames;
        var strHeaderTemplate;
        var strDataTemplate;
        var strInsertTemplate;

        var arrElements;
        var strColumn;
        var strValue;

        var strRecord;
        var arrRecord;
        var jsnRecord;
        var jsnQS;
        var intTotalRecords;
        var strNullString;
        //var strChar;
        var strCell;
        var strHTML;
        //var strCSS;
        var delim;

        //var intRecordSelectorBorderWidth;
        //var intInsertRecordBorderHeight;
        //var intHeaderBorderHeight;

        var bolOneCellSelected;
        var selectedCellControl;
        var textSelection;
        var textSelectionStart;
        var textSelectionEnd;

        //console.log(element.internalSelection.ranges.length, 1);
        //if (element.internalSelection.ranges.length === 1){
            //console.log(element.internalSelection.ranges[0].start.column);
            //console.log(element.internalSelection.ranges[0].end.column);
            //console.log(element.internalSelection.ranges[0].start.row);
            //console.log(element.internalSelection.ranges[0].end.row);
        //}

        // get the first range, we need to know if only one cell is selected
        jsnRange = element.internalSelection.ranges[0];
        bolOneCellSelected = (
            element.internalSelection.ranges.length === 1 &&
            jsnRange.start.column === jsnRange.end.column &&
            jsnRange.start.row === jsnRange.end.row
        );

        // if only one cell is selected, we want to save the text selection
        //      so that we can restore it. this is because this function
        //      destroys all cells so the text selection of any of those
        //      cells will be lost.
        if (bolOneCellSelected) {
            selectedCellControl = xtag.query(
                element,
                (
                    'gs-cell' +
                        '[data-col-number="' + jsnRange.start.column + '"]' +
                        '[data-row-number="' + jsnRange.start.row + '"]' +
                        ' input'
                )
            )[0];
            textSelectionStart = 0;
            textSelectionEnd = 0;

            //console.log('one cell is selected, save text selection');

            if (selectedCellControl) {
                //console.log(
                //    selectedCellControl.selectionStart,
                //    selectedCellControl.selectionEnd
                //);
                //textSelectionStart = selectedCellControl.selectionStart;
                //textSelectionEnd = selectedCellControl.selectionEnd;

                textSelection = GS.getInputSelection(selectedCellControl);
                textSelectionStart = textSelection.start;
                textSelectionEnd = textSelection.end;

                //console.log(textSelection);
            }
        }


        // some code adds classes to the viewport. these need to be removed on
        //      a full re-render
        element.elems.dataViewport.setAttribute('class', 'table-data-viewport');

        //// save column widths and record heights for easy access
        //arrColumnWidths = element.internalDisplay.columnWidths;
        //arrRecordHeights = element.internalDisplay.recordHeights;

        // we needs the border dimensions to calculate true locations
        //columnBorderWidth = element.internalDisplay.columnBorderWidth;
        //recordBorderHeight = element.internalDisplay.recordBorderHeight;

        // save the column name array for quick and easy access
        arrColumnNames = element.internalData.columnNames;

        // we want the records to have access to the "qs" variable, so we'll
        //      save the query string JSON to a variable so that we only have
        //      to get it once
        jsnQS = GS.qryToJSON(GS.getQueryString());

        // we want the user to be able to have access to the total number of
        //      records in their template so we'll save it to a variable so
        //      that we don't need to recalculate
        intTotalRecords = element.internalData.records.length;

        // we want the null string to be configurable, so we'll read the
        //      "null-string" attribute to get the null string
        strNullString = element.getAttribute('null-string');
        //snapback
        // get visible range
        jsnRange = element.internalDisplay.currentRange;
        //intCellOriginLeft = jsnRange.originLeft;
        //intRecordOriginTop = jsnRange.originTop;
        fromColumn = jsnRange.fromColumn;
        toColumn = jsnRange.toColumn;
        fromRecord = jsnRange.fromRecord;
        toRecord = jsnRange.toRecord;

        //// we need to know the border sizes so that we can calculate cell
        ////      dimensions
        //intRecordSelectorBorderWidth = (
        //    element.internalDisplay.recordSelectorBorderWidth
        //);
        //intInsertRecordBorderHeight = (
        //    element.internalDisplay.insertRecordBorderHeight
        //);
        //intHeaderBorderHeight = (
        //    element.internalDisplay.headerBorderHeight
        //);

        //console.log('element: ', element);
        //console.log('jsnRange: ', jsnRange);
        //console.log('intCellOriginLeft: ', intCellOriginLeft);
        //console.log('intRecordOriginTop: ', intRecordOriginTop);
        //console.log('fromColumn: ', fromColumn);
        //console.log('toColumn: ', toColumn);
        //console.log('fromRecord: ', fromRecord);
        //console.log('toRecord: ', toRecord);

        // define strHTML as empty so that we can append to it without
        //      the 'undefinedTEXT THAT YOU APPENDED' issue
        strHTML = '';

        // we only want to template the columns that fall into the range of
        //      fromColumn->toColumn, so we'll stick the record template HTML
        //      into a template element, yank out the desired cells and
        //      that'll be the html we template with (and we'll repeat this
        //      process for the header and insert columns)
        if (element.internalTemplates.header.trim()) {
            strHeaderTemplate = templateExtractVisibleCellRange(
                element,
                element.internalTemplates.header,
                fromColumn,
                toColumn
            );
        }
        if (element.internalTemplates.record.templateHTML.trim()) {
            strDataTemplate = templateExtractVisibleCellRange(
                element,
                element.internalTemplates.record.templateHTML,
                fromColumn,
                toColumn
            );
        }
        if (element.internalTemplates.insertRecord.trim()) {
            strInsertTemplate = templateExtractVisibleCellRange(
                element,
                element.internalTemplates.insertRecord,
                fromColumn,
                toColumn
            );
        }

        //console.log('strHeaderTemplate: ', strHeaderTemplate);
        //console.log('strDataTemplate:   ', strDataTemplate);
        //console.log('strInsertTemplate: ', strInsertTemplate);

        // if there is a record template: build cell elements (first so that
        //      they're below everything)
        if (strDataTemplate) {
            var templateFunc = doT.template(
                '{{ ' +
                    'var row_number = jo.index + 1;' +
                    'var qs = jo.qs;' +
                    'var row = jo.row;' +
                    'var arrRow = jo.arrRow;' +
                    'var i = jo.index;' +
                    'var len = jo.len;' +
                '}}' +
                strDataTemplate
            );

            //console.log(fromRecord, toRecord);
            i = fromRecord;
            len = toRecord;
            //intRecordTop = intRecordOriginTop;
            while (i < len) {
                // create cell array for this record
                strRecord = element.internalData.records[i] + '\t';
                arrRecord = [];
                col_i = 0;
                col_len = element.internalData.columnNames.length;//9999;
                while (col_i < col_len) {
                    delim = strRecord.indexOf('\t');
                    strCell = strRecord.substring(0, delim);
                    strRecord = strRecord.substring(delim + 1);

                    arrRecord.push(
                        GS.decodeFromTabDelimited(strCell, strNullString)
                    );

                    col_i += 1;
                }

                //record_i = 0;
                //record_len = strRecord.length;
                //strCell = "";
                //arrRecord = [];
                //while (record_i < record_len) {
                //    strChar = strRecord[record_i];

                //    if (strChar === "\t") {
                //        arrRecord.push(
                //            GS.decodeFromTabDelimited(strCell, strNullString)
                //        );
                //        strCell = "";
                //    } else {
                //        strCell += strChar;
                //    }
                //    record_i += 1;
                //}
                //arrRecord.push(strCell);

                // create record JSON from the cell array
                col_i = 0;
                col_len = arrRecord.length;
                jsnRecord = {};
                while (col_i < col_len) {
                    jsnRecord[arrColumnNames[col_i]] = arrRecord[col_i];
                    col_i += 1;
                }

                strRecord = strDataTemplate;

                // template with JSON
                strRecord = templateFunc({
                    'qs': jsnQS,
                    'row': jsnRecord,
                    'arrRow': arrRecord,
                    'index': i,
                    'len': intTotalRecords
                });
                //console.log(strRecord)
                //// replace the css tokens so the cells are in the right place
                //col_i = fromColumn;
                //col_len = toColumn;
                //intCellLeft = intCellOriginLeft;
                //while (col_i < col_len) {
                //    // if the column is not hidden
                //    if (arrColumnWidths[col_i] > 0) {
                //        //strCSS = (
                //        //    'top:' + intRecordTop + 'px;' +
                //        //    'left:' + intCellLeft + 'px;' +
                //        //    'width:' + (
                //        //        arrColumnWidths[col_i] +
                //        //        columnBorderWidth
                //        //    ) + 'px;' +
                //        //    'height:' + (
                //        //        arrRecordHeights[i] +
                //        //        recordBorderHeight
                //        //    ) + 'px;'
                //        //);
                //        strCSS = '';

                //        strRecord = strRecord.replace(
                //            '$$CSSREPLACETOKEN$$',
                //            strCSS
                //        );

                //        intCellLeft += arrColumnWidths[col_i];
                //        intCellLeft += columnBorderWidth;
                //    }
                //    col_i += 1;
                //}

                // append record to html
                strHTML += strRecord;

                //// increment record top so that the next record
                ////      shows below this one
                //intRecordTop += arrRecordHeights[i];
                //intRecordTop += recordBorderHeight;
                i += 1;
            }
        }

        // because we prevent templating into other element's templates (the
        //      ones with a "src" attribute) by "hiding" (by replacing them
        //      with a random token and storing the token-template relationship)
        //      them, we have to "show" them (by replacing the token with the
        //      original template strings) at this step
        GS.templateShowSubTemplates(strHTML, element.internalTemplates.record);

        //// we need to use the dimensions of the header, record selectors and
        ////      the insert record, so we'll stick them in these variables for
        ////      easy access
        //var intHeaderHeight;
        //var intRecordSelectorWidth;
        //var intInsertRecordHeight;

        //intHeaderHeight = element.internalDisplay.headerHeight;
        //intRecordSelectorWidth = element.internalDisplay.recordSelectorWidth;
        //intInsertRecordHeight = element.internalDisplay.insertRecordHeight;

        // if there's a header: build column headings (second so that they're
        //      above cells)
        if (strHeaderTemplate) {
            strRecord = strHeaderTemplate;

            //col_i = fromColumn;
            //col_len = toColumn;
            //intCellLeft = intCellOriginLeft;
            //while (col_i < col_len) {
            //    // if the column is not hidden
            //    if (arrColumnWidths[col_i] > 0) {
            //        //strCSS = (
            //        //    'top:0;' +
            //        //    'left:' + intCellLeft + 'px;' +
            //        //    'width:' + (
            //        //        arrColumnWidths[col_i] +
            //        //        columnBorderWidth
            //        //    ) + 'px;' +
            //        //    'height:' + (
            //        //        intHeaderHeight +
            //        //        intHeaderBorderHeight
            //        //    ) + 'px;'
            //        //);
            //        strCSS = '';

            //        strRecord = strRecord.replace(
            //            '$$CSSREPLACETOKEN$$',
            //            strCSS
            //        );

            //        intCellLeft += arrColumnWidths[col_i];
            //        intCellLeft += columnBorderWidth;
            //    }
            //    col_i += 1;
            //}

            strRecord = handleHeaderTemplateTokens(
                element,
                strRecord,
                fromColumn,
                toColumn
            );

            strHTML += strRecord;
        }

        // because we prevent templating into other element's templates (the
        //      ones with a "src" attribute) by "hiding" (by replacing them
        //      with a random token and storing the token-template relationship)
        //      them, we have to "show" them (by replacing the token with the
        //      original template strings) at this step
        GS.templateShowSubTemplates(strHTML, element.internalTemplates.record);

        // if there's a insert record: build it and append to HTML
        if (strInsertTemplate) {
            strRecord = strInsertTemplate;

            //col_i = fromColumn;
            //col_len = toColumn;
            //intCellLeft = intCellOriginLeft;
            //while (col_i < col_len) {
            //    // if the column is not hidden
            //    if (arrColumnWidths[col_i] > 0) {
            //        //strCSS = (
            //        //    'top:' + intRecordTop + 'px;' +
            //        //    'left:' + intCellLeft + 'px;' +
            //        //    'width:' + (
            //        //        arrColumnWidths[col_i] +
            //        //        columnBorderWidth
            //        //    ) + 'px;' +
            //        //    'height:' + (
            //        //        intInsertRecordHeight +
            //        //        intInsertRecordBorderHeight
            //        //    ) + 'px;'
            //        //);
            //        strCSS = '';

            //        strRecord = strRecord.replace(
            //            '$$CSSREPLACETOKEN$$',
            //            strCSS
            //        );

            //        intCellLeft += arrColumnWidths[col_i];
            //        intCellLeft += columnBorderWidth;
            //    }
            //    col_i += 1;
            //}

            strHTML += strRecord;
        }

        // if record selectors haven't been disabled: build record selectors
        //      (third so that they're above cells)
        if (!element.hasAttribute('no-record-selector')) {
            if (element.getAttribute('update-dialog') === 'show') {
                i = fromRecord;
                len = toRecord;
                //intRecordTop = intRecordOriginTop;
                while (i < len) {
                    //strCSS = '';

                    strHTML += (
                        '<gs-cell class="table-record-selector multi-update" ' +
                        //'    style="' + strCSS + '" ' +
                        '    data-row-number="' + i + '" ' +
                        '    data-col="selector" ' +
                        '    title="Record #' + (i + 1) + '">' +
                        '    <div class="table-multi-update-button"></div>' +
                        '</gs-cell>'
                    );

                    //intRecordTop += arrRecordHeights[i];
                    //intRecordTop += recordBorderHeight;
                    i += 1;
                }
            } else {
                i = fromRecord;
                len = toRecord;
                //intRecordTop = intRecordOriginTop;
                while (i < len) {
                    //strCSS = (
                    //    'top:' + intRecordTop + 'px;' +
                    //    'left:0;' +
                    //    'width:' + (
                    //        intRecordSelectorWidth +
                    //        intRecordSelectorBorderWidth
                    //    ) + 'px;' +
                    //    'height:' + (
                    //        arrRecordHeights[i] +
                    //        recordBorderHeight
                    //    ) + 'px;'
                    //);

                    strHTML += (
                        '<gs-cell class="table-record-selector" ' +
                        //'    style="' + strCSS + '" ' +
                        '    data-row-number="' + i + '" ' +
                        '    data-col="selector" ' +
                        '    title="Record #' + (i + 1) + '">' +
                        (i + 1) +
                        '</gs-cell>'
                    );

                    //intRecordTop += arrRecordHeights[i];
                    //intRecordTop += recordBorderHeight;
                    i += 1;
                }
            }
        }

        // if there's an insert record and record selectors haven't been
        //      disabled: build top-left/select all cell (forth so that it's
        //      above record selectors)
        if (strInsertTemplate && !element.hasAttribute('no-record-selector')) {
            //strCSS = (
            //    'top:' + intRecordTop + 'px;' +
            //    'left:0;' +
            //    'width:' + (
            //        intRecordSelectorWidth +
            //        intRecordSelectorBorderWidth
            //    ) + 'px;' +
            //    'height:' + (
            //        intInsertRecordHeight +
            //        intInsertRecordBorderHeight
            //    ) + 'px;'// +
            //    //'line-height:' + (   <-- used with &gt;
            //    //    intInsertRecordHeight +
            //    //    intInsertRecordBorderHeight
            //    //) + 'px;'
            //);

            strHTML += (
                '<gs-cell class="table-insert-selector"' +
                    //' style="' + strCSS + '"' +
                    ' data-row-number="insert"' +
                    ' data-col="selector">*</gs-cell>' //&gt;
            );
        }

        // if there's a header and record selectors haven't been disabled: build
        //      top-left/select all cell (last so that it's above all)
        if (strHeaderTemplate && !element.hasAttribute('no-record-selector')) {
            //strCSS = (
            //    'top:0;' +
            //    'left:0;' +
            //    'width:' + (
            //        intRecordSelectorWidth +
            //        intRecordSelectorBorderWidth
            //    ) + 'px;' +
            //    'height:' + (
            //        intHeaderHeight +
            //        intHeaderBorderHeight
            //    ) + 'px;' +
            //    'line-height:' + (
            //        intHeaderHeight +
            //        intHeaderBorderHeight
            //    ) + 'px;'
            //);

            strHTML += (
                '<gs-cell class="table-all-selector"' +
                    //' style="' + strCSS + '"' +
                    ' data-col="selector">#</gs-cell>'
            );
        }

        // if there's no data, lets tell the user
        if (element.internalData.records.length === 0) {
            strHTML += '<div class="no-data-label">No Data</div>';
        }

        // we want to give the user some feedback about their scrolling position
        //      so, we'll add shadows on sides that have room to scroll in how
        //      this'll need to work is we'll need to add a shadow element at a
        //      z-index above cells but below record selectors, the all selector
        //      and header cells
        //// ### NEED CODING ###
        //strHTML += window.separate1js_html(element);

        // fill the data viewport with the rendered cells

        // version 1
        //element.elems.dataViewport.innerHTML = strHTML;

        // version 2
        //element.elems.dataContainer.removeChild(element.elems.dataViewport);
        //element.elems.dataViewport = '';
        //element.elems.dataViewport.innerHTML = strHTML;
        //element.elems.dataContainer.appendChild(
        //    element.elems.dataViewport
        //);

        // version 3
        element.elems.dataContainer.removeChild(element.elems.dataViewport);
        i = 0;
        len = element.elems.dataViewport.children.length;
        while (i < len) {
            element.elems.dataViewport.removeChild(
                element.elems.dataViewport.lastChild
            );
            i += 1;
        }
        element.elems.dataViewport.innerHTML = strHTML;
        element.elems.dataContainer.appendChild(
            element.elems.dataViewport
        );

        //// version 4
        //var newViewport = element.elems.dataViewport.cloneNode(false);

        //newViewport.innerHTML = strHTML;
        //element.elems.dataContainer.replaceChild(
        //    newViewport,
        //    element.elems.dataViewport
        //);


        //element.elems.dataViewport = newViewport;

        // fill insert columns with retained values
        arrElements = xtag.query(
            element.elems.dataViewport,
            '.table-insert [column]'
        );
        col_i = 0;
        col_len = arrElements.length;
        while (col_i < col_len) {
            strColumn = arrElements[col_i].getAttribute('column');
            strValue = element.internalData.insertRecord[strColumn];

            // if a value was retained for the current column
            if (strValue) {
                // fill control with retained value
                arrElements[col_i].value = strValue;
            }
            col_i += 1;
        }

        // render cell selection
        renderSelection(element);

        // if there is only one cell control selected and there is a text
        //      selection that has been saved: restore the text selection
        //      in the new control
        if (
            selectedCellControl &&
            (
                textSelectionStart > 0 ||
                textSelectionEnd > 0
            )
        ) {
            jsnRange = element.internalSelection.ranges[0];

            if (jsnRange) {
                selectedCellControl = xtag.query(
                    element,
                    (
                        'gs-cell' +
                            '[data-col-number="' + jsnRange.start.column + '"]' +
                            '[data-row-number="' + jsnRange.start.row + '"]' +
                            ' input'
                    )
                )[0];

                //console.log(selectedCellControl);

                if (selectedCellControl) {
                    //selectedCellControl.setSelectionRange(
                    //    textSelectionStart,
                    //    textSelectionEnd
                    //);
                    GS.setInputSelection(
                        selectedCellControl,
                        textSelectionStart,
                        textSelectionEnd
                    );
                }
            }
        }
    }

    // when you are scrolling, a lot of elements don't leave the screen. So,
    //      this function removes the elements that are no longer visible and
    //      then creates elements that are not visible based on the viewport.
    function renderLocationPartial(element) {
        //var arrColumnWidths;
        //var arrRecordHeights;
        //var columnBorderWidth;
        //var recordBorderHeight;
        //var intRecordSelectorBorderWidth;
        //var intInsertRecordBorderHeight;
        //var intHeaderBorderHeight;

        var strRow;
        var strCol;

        var jsnOldRange;
        var jsnRange;
        var fromColumn;
        var toColumn;
        var fromRecord;
        var toRecord;
        var bolInsertRecord;

        //var intCellOriginLeft;
        //var intRecordOriginTop;
        //var intCellLeft;
        //var intCellTop;

        var arrColumnNames;
        var jsnQS;
        var intTotalRecords;
        var strNullString;

        var intRowNumber;
        var intColNumber;

        //var arrColumnLeft;
        //var arrRecordTop;

        var arrElements;
        var strColumn;
        var strValue;

        var bolUp;
        var bolDown;
        var bolInsert;
        var bolLeft;
        var bolRight;

        var i;
        var len;
        var arrCell;
        var cell;
        var cell_i;
        var cell_len;
        var col_i;
        var col_len;
        //var row_i;
        //var row_len;

        var strDownTemplate;
        var strUpTemplate;
        var strInsertTemplate;
        var strLeftHeaderTemplate;
        var strLeftRecordTemplate;
        var strLeftInsertTemplate;
        var strRightHeaderTemplate;
        var strRightRecordTemplate;
        var strRightInsertTemplate;

        var strHTML;
        var cellElement;

        //// save column widths and record heights for easy access
        //arrColumnWidths = element.internalDisplay.columnWidths;
        //arrRecordHeights = element.internalDisplay.recordHeights;

        //// we needs the border dimensions to calculate true locations
        //columnBorderWidth = element.internalDisplay.columnBorderWidth;
        //recordBorderHeight = element.internalDisplay.recordBorderHeight;

        //// we need to know the border sizes so that we can calculate cell
        ////      dimensions
        //intRecordSelectorBorderWidth = (
        //    element.internalDisplay.recordSelectorBorderWidth
        //);
        //intInsertRecordBorderHeight = (
        //    element.internalDisplay.insertRecordBorderHeight
        //);
        //intHeaderBorderHeight = (
        //    element.internalDisplay.headerBorderHeight
        //);

        // save the column name array for quick and easy access
        arrColumnNames = element.internalData.columnNames;

        // we want the records to have access to the "qs" variable, so we'll
        //      save the query string JSON to a variable so that we only have
        //      to get it once
        jsnQS = GS.qryToJSON(GS.getQueryString());

        // we want the user to be able to have access to the total number of
        //      records in their template so we'll save it to a variable so
        //      that we don't need to recalculate
        intTotalRecords = element.internalData.records.length;

        // we want the null string to be configurable, so we'll read the
        //      "null-string" attribute to get the null string
        strNullString = element.getAttribute('null-string');

        //// we need to use the dimensions of the header, record selectors and
        ////      the insert record, so we'll stick them in these variables for
        ////      easy access
        //var intHeaderHeight;
        //var intRecordSelectorWidth;
        //var intInsertRecordHeight;

        //intHeaderHeight = element.internalDisplay.headerHeight;
        //intRecordSelectorWidth = element.internalDisplay.recordSelectorWidth;
        //intInsertRecordHeight = element.internalDisplay.insertRecordHeight;

        // get old visible range
        jsnOldRange = element.internalDisplay.prevRange;

        // get visible range
        jsnRange = element.internalDisplay.currentRange;
        //intCellOriginLeft = jsnRange.originLeft;
        //intRecordOriginTop = jsnRange.originTop;
        fromColumn = jsnRange.fromColumn;
        toColumn = jsnRange.toColumn;
        fromRecord = jsnRange.fromRecord;
        toRecord = jsnRange.toRecord;
        bolInsertRecord = jsnRange.insertRecord;

        // we create a record selector in multiple places, so to prevent code
        //      duplication, we'll use a function
        var createRecordSelector;

        // sometimes, the developer decide that record selectors are not what
        //      they want, in that case, don't create them
        if (element.hasAttribute('no-record-selector')) {
            createRecordSelector = function () {};
        } else {
            createRecordSelector = function (index) {
                cellElement = document.createElement('gs-cell');
                //cellElement.style.width = (
                //    (
                //        intRecordSelectorWidth +
                //        intRecordSelectorBorderWidth
                //    ) + 'px'
                //);
                //cellElement.style.height = (
                //    (
                //        arrRecordHeights[index] +
                //        recordBorderHeight
                //    ) + 'px'
                //);
                cellElement.classList.add('table-record-selector');
                cellElement.setAttribute('data-row-number', index);
                cellElement.setAttribute('data-col', 'selector');
                cellElement.setAttribute('title', 'Record #' + (index + 1));

                if (element.getAttribute('update-dialog') === 'show') {
                    cellElement.classList.add('multi-update');
                    cellElement.innerHTML = (
                        '<div class="table-multi-update-button"></div>'
                    );
                } else {
                    cellElement.textContent = (index + 1);
                }

                element.elems.dataViewport.appendChild(cellElement);
            };
        }

        // we create a record in multiple places, so to prevent code
        //      duplication, we'll use a function
        var createRecord = function (strTemplate, index) {
            var strRecord;
            var arrRecord;
            var jsnRecord;
            //var strCell;
            //var strChar;
            //var record_i;
            //var record_len;
            var strCell;
            var delim;
            var cell_i;
            var cell_len;

            // get text of the record data
            strRecord = element.internalData.records[index] + '\t';

            // create cell array for this record
            arrRecord = [];
            //console.log(element.internalData.columnNames.length);
            cell_i = 0;
            cell_len = element.internalData.columnNames.length;//9999;
            while (cell_i < cell_len) {
                delim = strRecord.indexOf('\t');
                strCell = strRecord.substring(0, delim);
                strRecord = strRecord.substring(delim + 1);

                //if (strCell !== '' || strRecord !== '') {
                arrRecord.push(
                    GS.decodeFromTabDelimited(strCell, strNullString)
                );
                //} else {
                //    break;
                //}

                cell_i += 1;
            }

            //record_i = 0;
            //record_len = strRecord.length;
            //strCell = "";
            //arrRecord = [];
            //while (record_i < record_len) {
            //    strChar = strRecord[record_i];

            //    if (strChar === "\t") {
            //        arrRecord.push(
            //            GS.decodeFromTabDelimited(strCell, strNullString)
            //        );
            //        strCell = "";
            //    } else {
            //        strCell += strChar;
            //    }
            //    record_i += 1;
            //}
            //arrRecord.push(strCell);

            // create record JSON from the cell array
            // the reason we want JSON is so that the template can easily
            //      reference things by column name
            col_i = 0;
            col_len = arrRecord.length;
            jsnRecord = {};
            while (col_i < col_len) {
                jsnRecord[arrColumnNames[col_i]] = arrRecord[col_i];
                col_i += 1;
            }

            // template with JSON - in the future, we need to change this to
            //      use the dot.js once for all the cells because templating
            //      each record individually is slow ### NEED CODING ###
            strRecord = (
                '{{' +
                    'var row_number = jo.index + 1;' +
                    'var qs = jo.qs;' +
                    'var row = jo.row;' +
                    'var arrRow = jo.arrRow;' +
                    'var i = jo.index;' +
                    'var len = jo.len;' +
                '}}' +
                strTemplate
            );

            strRecord = doT.template(strRecord)({
                'qs': jsnQS,
                'row': jsnRecord,
                'arrRow': arrRecord,
                'index': index,
                'len': intTotalRecords
            });

            //console.log(strRecord);

            // return record html
            return strRecord;
        };

        var createNonDataCells = function (strTemplate) {
            var strRecord;

            //// replace the css tokens so the cells are in the right place
            //strRecord = strTemplate.replace(/\$\$CSSREPLACETOKEN\$\$/gi, '');
            strRecord = strTemplate;

            // template with JSON - in the future, we need to change this to
            //      use the dot.js once for all the cells because templating
            //      each record individually is slow ### NEED CODING ###
            strRecord = '{{ var qs = jo.qs; }}' + strRecord;

            strRecord = doT.template(strRecord)({'qs': jsnQS});

            //console.log(strRecord);

            // return record html
            return strRecord;
        };


        // steps:
        //      remove all cells that are not in the current range
        //      create data cells
        //      create headers
        //      create record selectors
        //      create insert record cells
        //      calculate left and top values
        //      reposition all the cells to their correct locations



        // loop through the cells, if the current cell is not in the current
        //      viewport range, delete it
        var arrDoomed = [];
        arrCell = xtag.queryChildren(
            element.elems.dataViewport,
            '[data-row-number], [data-col-number]'
        );
        cell_i = 0;
        cell_len = arrCell.length;
        while (cell_i < cell_len) {
            cell = arrCell[cell_i];
            strRow = cell.getAttribute('data-row-number');
            strCol = cell.getAttribute('data-col-number');
            intRowNumber = parseInt(strRow, 10);
            intColNumber = parseInt(strCol, 10);

            if (
                intColNumber < fromColumn ||
                intRowNumber < fromRecord ||
                // toColumn is the index of the column after the last visible
                //      column, hence the equal. This fixes the issue of the
                //      partial render not removing the last record
                //      occasionally while scrolling
                intColNumber >= toColumn ||
                // toRecord is the index of the record after the last visible
                //      record, hence the equal. This fixes the issue of the
                //      partial render not removing the last record
                //      occasionally while scrolling
                intRowNumber >= toRecord ||
                (
                    bolInsertRecord === false &&
                    strRow === 'insert'
                )
            ) {
                arrDoomed.push(arrCell[cell_i]);
                //element.elems.dataViewport.removeChild(arrCell[cell_i]);
            }

            cell_i += 1;
        }

        var deleteNext = function () {
            //element.elems.dataViewport.removeChild(arrDoomed.pop());
            //if (arrDoomed.length > 0) {
            //    requestAnimationFrame(deleteNext);
            //}

            cell_i = 0;
            cell_len = arrDoomed.length;
            while (cell_i < cell_len) {
                if (
                    arrDoomed[cell_i].parentNode === element.elems.dataViewport
                ) {
                    element.elems.dataViewport.removeChild(arrDoomed[cell_i]);
                }
                cell_i += 1;
            }
        };
        if (window.requestAnimationFrame) {
            window.requestAnimationFrame(deleteNext);
        } else {
            deleteNext();
        }

        // create data cells
        // create headers
        // create record selectors
        // create insert record cells

        // because you can scroll on the X and Y axis at the same time:
        //      we need to know what columns and what rows to create and in
        //      what directions
        // find out what directions to create cells in
        bolUp = (
            fromRecord < jsnOldRange.fromRecord
        );
        bolDown = (
            toRecord > jsnOldRange.toRecord
        );
        bolInsert = (
            bolInsertRecord === true &&
            bolInsertRecord !== jsnOldRange.insertRecord
        );
        bolLeft = (
            fromColumn < jsnOldRange.fromColumn
        );
        bolRight = (
            toColumn > jsnOldRange.toColumn
        );

        //console.log(jsnOldRange, jsnRange);
        //console.log(
        //    'Up: ' + bolUp,
        //    'Down: ' + bolDown,
        //    'Left: ' + bolLeft,
        //    'Right: ' + bolRight
        //);

        // if we need to create records, get a record template
        if (bolUp || bolDown) {
            // we only want to template the columns that fall into the range of
            //      fromColumn->toColumn, so we'll stick the record template
            //      HTML into a template element, yank out the desired cells and
            //      that'll be the html we template with
            if (element.internalTemplates.record.templateHTML.trim()) {
                strUpTemplate = templateExtractVisibleCellRange(
                    element,
                    element.internalTemplates.record.templateHTML,
                    fromColumn,
                    toColumn
                );

                //// replace the css tokens so that they don't interfere
                //strUpTemplate = (
                //    strUpTemplate
                //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                //);

                // for now, the down and up templates are exactly the same. we
                //      could use one variable for the down and up templates,
                //      but, in the future, there may be reason to separate
                //      them. so, I'm just going to copy the up template into
                //      the down template variable
                strDownTemplate = strUpTemplate;
            }

            //console.log(strDownTemplate, strUpTemplate);
        }

        // if we need columns on the left, get the template
        if (bolLeft) {
            // we only want to template the columns that fall into the range of
            //      fromColumn->toColumn, so we'll stick the record template
            //      HTML into a template element, yank out the desired cells and
            //      that'll be the html we template with (and we'll repeat this
            //      process for the header and insert columns)

            // header cells
            if (element.internalTemplates.header.trim()) {
                strLeftHeaderTemplate = templateExtractVisibleCellRange(
                    element,
                    element.internalTemplates.header,
                    jsnRange.fromColumn,
                    jsnOldRange.fromColumn
                );
                strLeftHeaderTemplate = handleHeaderTemplateTokens(
                    element,
                    strLeftHeaderTemplate,
                    jsnRange.fromColumn,
                    jsnOldRange.fromColumn
                );
                //// replace the css tokens so that they don't interfere
                //strLeftHeaderTemplate = (
                //    strLeftHeaderTemplate
                //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                //);
            }
            // record cells
            if (element.internalTemplates.record.templateHTML.trim()) {
                strLeftRecordTemplate = templateExtractVisibleCellRange(
                    element,
                    element.internalTemplates.record.templateHTML,
                    jsnRange.fromColumn,
                    jsnOldRange.fromColumn
                );
                //// replace the css tokens so that they don't interfere
                //strLeftRecordTemplate = (
                //    strLeftRecordTemplate
                //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                //);
            }
            // insert cells
            if (
                // if there is an insert template
                element.internalTemplates.insertRecord.trim() &&
                // if the insert record has already been added
                !bolInsert
            ) {
                strLeftInsertTemplate = templateExtractVisibleCellRange(
                    element,
                    element.internalTemplates.insertRecord,
                    jsnRange.fromColumn,
                    jsnOldRange.fromColumn
                );
                //// replace the css tokens so that they don't interfere
                //strLeftInsertTemplate = (
                //    strLeftInsertTemplate
                //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                //);
            }

            //console.log(
            //    strLeftHeaderTemplate,
            //    strLeftRecordTemplate,
            //    strLeftInsertTemplate
            //);
        }

        // if we need columns on the right, get the template
        if (bolRight) {
            // we only want to template the columns that fall into the range of
            //      fromColumn->toColumn, so we'll stick the record template
            //      HTML into a template element, yank out the desired cells and
            //      that'll be the html we template with (and we'll repeat this
            //      process for the header and insert columns)

            // header cells
            if (element.internalTemplates.header.trim()) {
                strRightHeaderTemplate = templateExtractVisibleCellRange(
                    element,
                    element.internalTemplates.header,
                    jsnOldRange.toColumn,
                    jsnRange.toColumn
                );
                strRightHeaderTemplate = handleHeaderTemplateTokens(
                    element,
                    strRightHeaderTemplate,
                    jsnOldRange.toColumn,
                    jsnRange.toColumn
                );
                //// replace the css tokens so that they don't interfere
                //strRightHeaderTemplate = (
                //    strRightHeaderTemplate
                //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                //);
            }
            // record cells
            if (element.internalTemplates.record.templateHTML.trim()) {
                strRightRecordTemplate = templateExtractVisibleCellRange(
                    element,
                    element.internalTemplates.record.templateHTML,
                    jsnOldRange.toColumn,
                    jsnRange.toColumn
                );
                //// replace the css tokens so that they don't interfere
                //strRightRecordTemplate = (
                //    strRightRecordTemplate
                //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                //);
            }
            // insert cells
            if (
                // if there is an insert template
                element.internalTemplates.insertRecord.trim() &&
                // if the insert record has already been added
                !bolInsert
            ) {
                strRightInsertTemplate = templateExtractVisibleCellRange(
                    element,
                    element.internalTemplates.insertRecord,
                    jsnOldRange.toColumn,
                    jsnRange.toColumn
                );
                //// replace the css tokens so that they don't interfere
                //strRightInsertTemplate = (
                //    strRightInsertTemplate
                //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
                //);
            }

            //console.log(
            //    strRightHeaderTemplate,
            //    strRightRecordTemplate,
            //    strRightInsertTemplate
            //);
        }

        // define strHTML as empty so that we can append to it without
        //      the 'undefinedTEXT THAT YOU APPENDED' issue
        strHTML = '';

        // if we need to add cells above the old visible range
        if (bolUp) {
            i = jsnRange.fromRecord;
            len = jsnOldRange.fromRecord;
            while (i < len) {
                // record selector cell
                createRecordSelector(i);

                // record cells
                strHTML += createRecord(strUpTemplate, i);

                i += 1;
            }
        }

        // if we need to add cells below the old visible range
        if (bolDown) {
            i = jsnOldRange.toRecord;
            len = jsnRange.toRecord;
            while (i < len) {
                // record selector cell
                createRecordSelector(i);

                // record cells
                strHTML += createRecord(strDownTemplate, i);

                i += 1;
            }
        }

        // if we need to add the insert record=
        if (bolInsert) {
            strInsertTemplate = '';

            if (!element.hasAttribute('no-record-selector')) {
                strInsertTemplate += (
                    '<gs-cell ' +
                            'class="table-insert-selector"' +
                            ' data-row-number="insert"' +
                            ' data-col="selector">*' + //&gt;
                    '</gs-cell>'
                );
            }

            strInsertTemplate += (
                templateExtractVisibleCellRange(
                    element,
                    element.internalTemplates.insertRecord,
                    jsnRange.fromColumn,
                    jsnRange.toColumn
                )
            );

            //// replace the css tokens so that they don't interfere
            //strInsertTemplate = (
            //    strInsertTemplate
            //        .replace(/\$\$CSSREPLACETOKEN\$\$/gi, '')
            //);

            strHTML += createNonDataCells(strInsertTemplate);
        }

        // if we need to add cells to the left of the old visible range
        //      one thing to note is that the up and down templating takes
        //      care of the left and right columns for those records, this
        //      code takes care of the left columns for the existing records
        if (bolLeft) {
            // header cells
            if (strLeftHeaderTemplate) {
                strHTML += createNonDataCells(strLeftHeaderTemplate);
            }

            // record cells
            if (strLeftRecordTemplate) {
                // loop through records that overlap from the old visible
                //      range and the new visible range

                if (bolUp) {
                    i = jsnOldRange.fromRecord;
                    len = jsnRange.toRecord;
                } else if (bolDown) {
                    i = jsnRange.fromRecord;
                    len = jsnOldRange.toRecord;
                } else {
                    i = jsnRange.fromRecord;
                    len = jsnRange.toRecord;
                }

                while (i < len) {
                    strHTML += createRecord(strLeftRecordTemplate, i);

                    i += 1;
                }
            }

            // insert cells
            if (strLeftInsertTemplate) {
                strHTML += createNonDataCells(strLeftInsertTemplate);
            }
        }

        // if we need to add cells to the right of the old visible range
        //      one thing to note is that the up and down templating takes
        //      care of the left and right columns for those records, this
        //      code takes care of the right columns for the existing records
        if (bolRight) {
            // header cells
            if (strRightHeaderTemplate) {
                strHTML += createNonDataCells(strRightHeaderTemplate);
            }

            // record cells
            if (strRightRecordTemplate) {
                // loop through records that overlap from the old visible
                //      range and the new visible range

                if (bolUp) {
                    i = jsnOldRange.fromRecord;
                    len = jsnRange.toRecord;
                } else if (bolDown) {
                    i = jsnRange.fromRecord;
                    len = jsnOldRange.toRecord;
                } else {
                    i = jsnRange.fromRecord;
                    len = jsnRange.toRecord;
                }

                while (i < len) {
                    strHTML += createRecord(strRightRecordTemplate, i);

                    i += 1;
                }
            }

            // insert cells
            if (strRightInsertTemplate) {
                strHTML += createNonDataCells(strRightInsertTemplate);
            }
        }

        // because we prevent templating into other element's templates (the
        //      ones with a "src" attribute) by "hiding" (by replacing them
        //      with a random token and storing the token-template relationship)
        //      them, we have to "show" them (by replacing the token with the
        //      original template strings) at this step
        strHTML = GS.templateShowSubTemplates(
            strHTML,
            element.internalTemplates.record
        );

        //console.log(strHTML);

        // we want to append the html and have the elements to initialize
        //      while in the DOM, so we'll use the recently discovered and
        //      compatible element.insertAdjacentHTML

        // version 2
        //element.elems.dataContainer.removeChild(element.elems.dataViewport);
        //element.elems.dataViewport.insertAdjacentHTML('beforeend', strHTML);
        //element.elems.dataContainer.appendChild(element.elems.dataViewport);

        // version 3
        //var test = document.createElement('div');
        //test.innerHTML = strHTML;
        //element.elems.dataViewport.appendChild(test);

        if (document.createDocumentFragment) {
            // version 4
            var divElement = document.createElement('div');
            var transferFragment = document.createDocumentFragment();
            divElement.innerHTML = strHTML;

            i = 0;
            len = divElement.children.length;
            while (i < len) {
                transferFragment.appendChild(divElement.lastChild);
                i += 1;
            }

            element.elems.dataViewport.appendChild(transferFragment);
        } else {
            // version 1
            element.elems.dataViewport.insertAdjacentHTML('beforeend', strHTML);
        }



        //// calculate left and top values
        //intCellLeft = intCellOriginLeft;
        //arrColumnLeft = [];
        //col_i = fromColumn;
        //col_len = toColumn;
        //while (col_i < col_len) {
        //    arrColumnLeft.push(intCellLeft);

        //    // we don't want the border width of 0 width columns to affect
        //    //      positioning
        //    if (arrColumnWidths[col_i] > 0) {
        //        intCellLeft += arrColumnWidths[col_i];
        //        intCellLeft += columnBorderWidth;
        //    }
        //    col_i += 1;
        //}

        //intCellTop = intRecordOriginTop;
        //arrRecordTop = [];
        //row_i = fromRecord;
        //row_len = toRecord;
        //while (row_i < row_len) {
        //    arrRecordTop.push(intCellTop);

        //    intCellTop += arrRecordHeights[row_i];
        //    intCellTop += recordBorderHeight;
        //    row_i += 1;
        //}

        //// if the insert record is visible, add it's top
        //if (bolInsertRecord === true) {
        //    arrRecordTop.push(intCellTop);

        //    intCellTop += element.internalDisplay.insertRecordHeight;
        //    intCellTop += element.internalDisplay.insertRecordBorderHeight;
        //}

        //// reposition all the cells to their correct locations
        //arrCell = xtag.queryChildren(
        //    element.elems.dataViewport,
        //    'gs-cell'
        //    //'[data-row-number], [data-col-number]'
        //    //      ^- this selector missed the insert and all selector cells
        //);
        //cell_i = 0;
        //cell_len = arrCell.length;
        //while (cell_i < cell_len) {
        //    cell = arrCell[cell_i];
        //    intRowNumber = parseInt(cell.getAttribute('data-row-number'), 10);
        //    intColNumber = parseInt(cell.getAttribute('data-col-number'), 10);

        //    // cell has a column number, set left. we can do this because (for
        //    //      example) header cells dont have a row attribute. the
        //    //      reason we do that is because those cells don't represent
        //    //      a row in the data.
        //    if (!isNaN(intColNumber)) {
        //        cell.style.left = (
        //            arrColumnLeft[intColNumber - fromColumn] + 'px'
        //        );
        //        cell.style.width = (
        //            (
        //                arrColumnWidths[intColNumber] +
        //                columnBorderWidth
        //            ) + 'px'
        //        );

        //    // right now, the only element that won't have a column number
        //    //      will be the record, insert and all selectors
        //    } else {
        //        cell.style.width = (
        //            intRecordSelectorWidth +
        //            intRecordSelectorBorderWidth
        //        ) + 'px';
        //    }

        //    // cell has a row number, set top. we can do this because (for
        //    //      example) header cells dont have a row attribute. the
        //    //      reason we do that is because those cells don't represent
        //    //      a row in the data.
        //    if (!isNaN(intRowNumber)) {
        //        cell.style.top = (
        //            arrRecordTop[intRowNumber - fromRecord] + 'px'
        //        );
        //        cell.style.height = (
        //            (
        //                arrRecordHeights[intRowNumber] +
        //                recordBorderHeight
        //            ) + 'px'
        //        );
        //        //cell.setAttribute(
        //        //    'style',
        //        //    (
        //        //        'top:' + (
        //        //            arrRecordTop[intRowNumber - fromRecord]
        //        //        ) + 'px;' +
        //        //        'height:' + (
        //        //            arrRecordHeights[intRowNumber] +
        //        //            recordBorderHeight
        //        //        ) + 'px;'
        //        //    )
        //        //);

        //    // if the cell is a header cell, set the height
        //    } else if (
        //        cell.classList.contains('table-header') ||
        //        cell.classList.contains('table-all-selector')
        //    ) {
        //        cell.style.height = (
        //            intHeaderHeight +
        //            intHeaderBorderHeight
        //        ) + 'px';
        //        //cell.setAttribute(
        //        //    'style',
        //        //    (
        //        //        'height:' + (
        //        //            intHeaderHeight +
        //        //            intHeaderBorderHeight
        //        //        ) + 'px;'
        //        //    )
        //        //);

        //    // if the cell is a insert cell, set the height
        //    } else if (
        //        cell.classList.contains('table-insert')
        //    ) {
        //        cell.style.top = (
        //            arrRecordTop[arrRecordTop.length - 1] + 'px'
        //        );
        //        cell.style.height = (
        //            intInsertRecordHeight +
        //            intInsertRecordBorderHeight
        //        ) + 'px';
        //        //cell.setAttribute(
        //        //    'style',
        //        //    (
        //        //        'top:' + (
        //        //            arrRecordTop[arrRecordTop.length - 1]
        //        //        ) + 'px;' +
        //        //        'height:' + (
        //        //            intInsertRecordHeight +
        //        //            intInsertRecordBorderHeight
        //        //        ) + 'px;'
        //        //    )
        //        //);

        //    // if the cell is the insert selector, set the height
        //    } else if (
        //        cell.classList.contains('table-insert-selector')
        //    ) {
        //        cell.style.top = (
        //            arrRecordTop[arrRecordTop.length - 1] + 'px'
        //        );
        //        cell.style.left = (0);
        //        cell.style.height = (
        //            intInsertRecordHeight +
        //            intInsertRecordBorderHeight
        //        ) + 'px';

        //        //cell.setAttribute(
        //        //    'style',
        //        //    (
        //        //        'top:' + (
        //        //            arrRecordTop[arrRecordTop.length - 1]
        //        //        ) + 'px;' +
        //        //        'left:0px;' +
        //        //        'height:' + (
        //        //            intInsertRecordHeight +
        //        //            intInsertRecordBorderHeight
        //        //        ) + 'px;'
        //        //    )
        //        //);
        //    }

        //    //if (cell.classList.contains('table-cell')) {
        //    //} else if (cell.classList.contains('table-all-selector')) {
        //    //} else if (cell.classList.contains('table-header')) {
        //    //} else if (cell.classList.contains('table-record-selector')) {
        //    //} else if (cell.classList.contains('table-insert')) {
        //    //} else if (cell.classList.contains('table-insert-selector')) {
        //    //}

        //    cell_i += 1;
        //}

        // fill insert columns with retained values
        arrElements = xtag.query(
            element.elems.dataViewport,
            '.table-insert [column]'
        );
        col_i = 0;
        col_len = arrElements.length;
        while (col_i < col_len) {
            strColumn = arrElements[col_i].getAttribute('column');
            strValue = element.internalData.insertRecord[strColumn];

            // if a value was retained for the current column
            if (strValue) {
                // fill control with retained value
                arrElements[col_i].value = strValue;
            }
            col_i += 1;
        }

        // we want to give the user some feedback about their scrolling position
        //      so, we'll add shadows on sides that have room to scroll in how
        //      this'll need to work is we'll need to add a shadow element at a
        //      z-index above cells but below record selectors, the all selector
        //      and header cells
        //// ### NEED CODING ###
        //window.separate1js_elements(element);

        // render cell selection
        renderSelection(element);
    }

    function renderLocation(element) {
        var i;
        var len;

        var intMaximum;
        var intTraversed;
        var intExtremeSide;

        var intViewportWidth;
        var intViewportHeight;

        var jsnOldRange;
        var jsnRange;

        var focusElement;

        // get old visible range so that we can decide if it's economical to do
        //      a full re-render
        jsnOldRange = element.internalDisplay.currentRange;

        // get current visible range so that we can decide if it's economical
        //      to do a full re-render
        jsnRange = getCurrentCellRange(element);

        // save visible range to internal display so that it is cached. the
        //      reason to cache it is so that we can be able to rapidly
        //      retrieve it many times in a row.
        element.internalDisplay.currentRange = jsnRange;

        // the partial render need to know the previous visible range, so here
        //      we cache it
        element.internalDisplay.prevRange = jsnOldRange;

        // we dont want to force a layout by re-rendering the contents and then
        //      asking for the viewport height/width. so we'll make a
        //      convenience variable
        intViewportWidth = (
            element.elems.dataViewport.clientWidth
        );
        intViewportHeight = (
            element.elems.dataViewport.clientHeight
        );

        // we want to either do a full re-render or a partial re-render
        if (intViewportHeight < 3 || intViewportWidth < 3) {
            //console.log('Empty');
            renderEmpty(element);
        } else if (
            // if the internal display says we need to do a full re-render
            element.internalDisplay.fullRenderRequired === true ||

            // or if there is no previous cell range
            jsnOldRange.fromRecord === undefined ||

            // or if the current range has no overlap with the old range
            jsnRange.fromRecord > jsnOldRange.toRecord ||
            jsnRange.fromColumn > jsnOldRange.toColumn ||
            jsnRange.toRecord < jsnOldRange.fromRecord ||
            jsnRange.toColumn < jsnOldRange.fromColumn
        ) {
            //console.log('Full');
            renderLocationFull(element);
        } else {
            //console.log('Partial');
            renderLocationPartial(element);
        }

        // reset full render indicator
        element.internalDisplay.fullRenderRequired = false;

        // generate positioning CSS
        // clear old CSS
        element.elems.cellPositionStyle.innerHTML = '';

        var intCellLeft = 0;
        var intCellTop = 0;
        var intColumnWidth;
        //var arrMinColumnWidths = element.internalDisplay.minColumnWidths;

        var arrColumnWidths = element.internalDisplay.columnWidths;
        var arrRecordHeights = element.internalDisplay.recordHeights;
        var columnBorderWidth = element.internalDisplay.columnBorderWidth;
        var recordBorderHeight = element.internalDisplay.recordBorderHeight;
        var strCSS = '';
        var strCell = (
            '#' + element.getAttribute('id') + ' .table-data-viewport gs-cell'
        );

        // calculate left and top values
        intCellLeft = jsnRange.originLeft;
        i = jsnRange.fromColumn;
        len = jsnRange.toColumn;
        while (i < len) {
            //if (arrColumnWidths[i] < 3) {
            //    //console.log(
            //        element.internalDisplay.defaultColumnWidths[i],
            //        element.internalDisplay.minColumnWidths[i],
            //        arrColumnWidths[i]
            //    );
            //    arrColumnWidths[i] = arrMinColumnWidths[i];
            //    element.internalDisplay.columnWidths[i] = (
            //        arrMinColumnWidths[i]
            //    );
            //}
            //console.log('col: ', arrColumnWidths[i]);
            intColumnWidth = arrColumnWidths[i];

            // only add to CSS and increment left variable if column is not
            //      hidden
            if (intColumnWidth > 0) {
                strCSS += (
                    strCell + '[data-col-number="' + i + '"] {' +
                    'left:' + intCellLeft + 'px;' +
                    'width:' + (
                        intColumnWidth + columnBorderWidth
                    ) + 'px;' +
                    '}'
                );
                // console.log(strCSS);

                // we don't want the border width of 0 width columns to affect
                //      positioning
                intCellLeft += (intColumnWidth + columnBorderWidth);
            }
            i += 1;
        }

        intCellTop = jsnRange.originTop;
        i = jsnRange.fromRecord;
        len = jsnRange.toRecord;
        while (i < len) {
            //if (arrRecordHeights[i] < 3) {
            //    arrRecordHeights[i] = (
            //        element.internalDisplay.defaultRecordHeight
            //    );
            //    element.internalDisplay.recordHeights[i] = (
            //        element.internalDisplay.defaultRecordHeight
            //    );
            //}
            //console.log('row: ', arrRecordHeights[i]);
            strCSS += (
                strCell + '[data-row-number="' + i + '"] {' +
                'top:' + intCellTop + 'px;' +
                'height:' + (
                    arrRecordHeights[i] + recordBorderHeight
                ) + 'px;' +
                '}'
            );

            intCellTop += (arrRecordHeights[i] + recordBorderHeight);
            i += 1;
        }

        // if the insert record is visible, add it's top
        if (element.internalDisplay.insertRecordVisible) {
            strCSS += (
                strCell + '[data-row-number="insert"] {' +
                'top:' + intCellTop + 'px;' +
                'height:' + (
                    element.internalDisplay.insertRecordHeight +
                    element.internalDisplay.insertRecordBorderHeight
                ) + 'px;' +
                '}'
            );

            //intCellTop += element.internalDisplay.insertRecordHeight;
            //intCellTop += element.internalDisplay.insertRecordBorderHeight;
        }

        strCSS += (
            strCell + '[data-col="selector"] {' +
            'left:0px;' +
            'width:' + (
                element.internalDisplay.recordSelectorWidth +
                element.internalDisplay.recordSelectorBorderWidth
            ) + 'px;' +
            '}' +

            strCell + '.table-all-selector,' +
            strCell + '.table-header {' +
            'top:0px;' +
            'height:' + (
                element.internalDisplay.headerHeight +
                element.internalDisplay.headerBorderHeight
            ) + 'px;' +
            '}'
        );

        //console.log('strCSS:', strCSS);

        element.elems.cellPositionStyle.innerHTML = strCSS;


        // turn the visible range into two arrays of drag handle points, one for
        //      horizontal, one for vertical. This is used by the cell resize
        //      code so that it can tell where the cell resize handles are.

        // we need to clear out any old values in the handle lists
        element.internalDisplay.columnHandles = [];
        element.internalDisplay.recordHandles = [];

        // find out the maximum position for a column resize handle
        intMaximum = (
            (
                intViewportWidth -
                element.internalScrollOffsets.right
            ) +
            // allow room for handle that's right at the right edge, this is
            //      useful when a column is full width
            3
        );

        // add record selector to column handle list if it's visible, the reason
        //      it's first is because the cell resize code depends it being
        //      first if recordSelectorVisible is true
        if (element.internalDisplay.recordSelectorVisible === true) {
            element.internalDisplay.columnHandles.push(
                element.internalScrollOffsets.left
            );
        }

        // add displayed columns to column handle list
        intTraversed = jsnRange.originLeft;//0;
        i = jsnRange.fromColumn;
        len = jsnRange.toColumn;
        while (i < len) {
            // we want to add the right side of the column unless the right side
            //      is off of the viewport or is obscured by the right offset
            //      so, we'll put the right side into a variable and we'll build
            //      up a record width variable that we can use to determine if
            //      the right side would be too far
            if (element.internalDisplay.columnWidths[i] === 0) {
                intExtremeSide = 0;
            } else {
                intExtremeSide = (
                    element.internalDisplay.columnWidths[i] +
                    element.internalDisplay.columnBorderWidth
                );
            }

            //if (intTraversed <= 0 && intExtremeSide > 0) {
            //    intExtremeSide += jsnRange.originLeft;
            //}
            intTraversed += intExtremeSide;

            //console.log(
            //    intTraversed,
            //    element.internalScrollOffsets.left,
            //    intExtremeSide,
            //    jsnRange.originLeft
            //);

            if (intTraversed < intMaximum) {
                // if column is hidden, push null handle so that the array
                //      indexes still line up with the column numbers
                if (
                    intExtremeSide === 0 ||
                    intTraversed <= element.internalScrollOffsets.left
                ) {
                    element.internalDisplay.columnHandles.push(null);
                } else {
                    element.internalDisplay.columnHandles.push(intTraversed);
                }
            } else {
                break;
            }

            i += 1;
        }

        // now, we add the records to the record handle list

        // find out the maximum position for a record resize handle
        intMaximum = (
            intViewportHeight -
            element.internalScrollOffsets.bottom
        );

        // add header to record handle list if it's visible, the reason it's
        //      first is because the cell resize code depends it being first
        //      if headerVisible is true
        if (element.internalDisplay.headerVisible === true) {
            element.internalDisplay.recordHandles.push(
                element.internalScrollOffsets.top
            );
        }

        // add displayed records to record handle list
        intTraversed = 0;
        i = jsnRange.fromRecord;
        len = jsnRange.toRecord;
        while (i < len) {
            // we want to add the bottom side of the record unless the bottom
            //      side is off of the viewport or is obscured by the bottom
            //      offset so, we'll put the bottom side into a variable and
            //      we'll build up a record width variable that we can use to
            //      determine if the bottom side would be too far
            intExtremeSide = (
                element.internalDisplay.recordHeights[i]
            );

            if (intTraversed <= 0) {
                intExtremeSide += (
                    jsnRange.originTop
                );
            }
            intTraversed += intExtremeSide;

            if (intTraversed < intMaximum) {
                element.internalDisplay.recordHandles.push(intTraversed);
            } else {
                break;
            }

            // we wanted the cursor to appear a little higher
            intTraversed += element.internalDisplay.recordBorderHeight;

            i += 1;
        }

        // add the insert record to record handle list if it's visible, the
        //      reason it's last is because the cell resize code depends it
        //      being last if insertRecordVisible is true
        if (
            element.internalDisplay.insertRecordVisible === true &&
            jsnRange
        ) {
            element.internalDisplay.recordHandles.push(
                element.internalDisplay.insertRecordHeight +
                intTraversed
            );
        }

        // commented out because throttling scrolling makes scrolling choppy,
        //      other avenues of speed improvement will need to be attempted
        //// we needed to throttle the location rendering to increase speed
        ////      next, we want to look into only replacing elements that
        ////      need to be replaced as and just moving the rest (and if
        ////      that improves the speed enough, we can remove the throttling)
        //if (element.internalTimerIDs.renderLocation) {
        //    clearTimeout(element.internalTimerIDs.renderLocation);
        //}
        //element.internalTimerIDs.renderLocation = setTimeout(function() {
        //    renderLocationFull(element);
        //    element.internalTimerIDs.renderLocation = null;
        //}, 5);

        // we maintain the last focused control, if the last focused control
        //      is in the DOM, we want to focus it
        if (
            // this does two things for us:
            //      "latest" starts out null so this prevents us trying to
            //              focus when we haven't ever had the focus
            //      "latest" is false when the control has lost it's focus
            //              so this prevents wasting effort on trying to
            //              focus if the control is already focused
            element.internalDisplay.focus.latest === false &&

            // we only want to try to re-focus if the cell is in the current
            //      range. in the future, we may end up adding the cell if
            //      it's not currently rendered.
            !isNaN(element.internalDisplay.focus.row) &&
            !isNaN(element.internalDisplay.focus.column) &&
            element.internalDisplay.focus.row >= jsnRange.fromRecord &&
            element.internalDisplay.focus.row <= jsnRange.toRecord &&
            element.internalDisplay.focus.column >= jsnRange.fromColumn &&
            element.internalDisplay.focus.column <= jsnRange.toColumn
        ) {
            focusElement = xtag.query(
                element.elems.dataViewport,
                (
                    'gs-cell' +
                    '[data-col-number="' +
                        element.internalDisplay.focus.column +
                    '"]' +
                    '[data-row-number="' +
                        element.internalDisplay.focus.row +
                    '"] ' +
                    (
                        element.internalDisplay.focus.nodeName ||
                        ''
                    ).toLowerCase()
                )
            )[0];

            if (focusElement) {
                focusElement.focus();

                if (element.internalDisplay.focus.selectionRange) {
                    GS.setInputSelection(
                        focusElement,
                        element.internalDisplay.focus.selectionRange.start,
                        element.internalDisplay.focus.selectionRange.end
                    );
                }
            }
        }
    }

    // we need to be able to update the scrollbar location programatically
    function renderScrollLocation(element) {
        var intViewportWidth;
        var intViewportHeight;
        var virtualScrollHeight;
        var virtualScrollWidth;
        var virtualScrollTop;
        var virtualScrollLeft;
        var trueScrollHeight;
        var trueScrollWidth;
        var trueScrollTop;
        var trueScrollLeft;

        // we need the viewport dimensions because true scroll dimensions
        //      include the viewport height, which messes with the caluculations
        intViewportWidth = element.elems.dataViewport.clientWidth;
        intViewportHeight = element.elems.dataViewport.clientHeight;

        // we are saving the max scroll dimensions for ease of access
        virtualScrollHeight = element.internalScroll.maxTop;
        virtualScrollWidth = element.internalScroll.maxLeft;

        // we are saving the current scroll location for ease of access
        virtualScrollTop = element.internalScroll.top;
        virtualScrollLeft = element.internalScroll.left;

        // we need the actual scroll height of the scrollbars because we limit
        //      their height and that causes a difference we need to account for
        trueScrollWidth = element.elems.xScrollBar.scrollWidth;
        trueScrollHeight = element.elems.yScrollBar.scrollHeight;
        trueScrollWidth -= intViewportWidth;
        trueScrollHeight -= intViewportHeight;

        // we need to translate the virtual top/left into true top/left for the
        //      physical scrollbars
        // we can only translate if the scroll height or width is > 0 because if
        //      we translate a 0, we end up with division by 0
        // if we can't translate: default to 0

        trueScrollTop = 0;
        if (virtualScrollHeight > 0) {
            trueScrollTop = (
                virtualScrollTop / (
                    virtualScrollHeight / trueScrollHeight
                )
            );
        }

        trueScrollLeft = 0;
        if (virtualScrollWidth > 0) {
            trueScrollLeft = (
                virtualScrollLeft / (
                    virtualScrollWidth / trueScrollWidth
                )
            );
        }

        // we need to cancel the scrollbar events for one iteration because the
        //      scroll we're about to do causes scrollbar events to emit. the
        //      events then get to their bound functions well after the
        //      execution of this thread. this means that if we run this
        //      function and then set focus to a cell: the bound scroll
        //      functions would cause another re-render, which will cause
        //      focus to be lost. that's why we can't set these cancel to true
        //      and then quickly set them back to false, they must be set to
        //      false in the bound function.
        // there is a small issue with this method, after this function if, for
        //      example, the Y scrollbar is triggered but not the X scrollbar:
        //      the user may use the X scrollbar and the first time the user
        //      triggers the X scrollbar: the event will be ignored. however,
        //      I've tested on Google Chrome and I didn't notice the effects of
        //      this downside
        //element.internalEventCancelled.scrollbarY = true;
        //element.internalEventCancelled.scrollbarX = true;

        // we need to update the scroll location of the physical scrollbars so
        //      that the user can see where they are
        // to prevent sub-pixel math issues from causing a loop (by moving the
        //      scrollbar 1 pixel which causes a scroll event to take place
        //      which causes this function to run again (moving the scrollbar
        //      another pixel etc...)): if the difference between current true
        //      and new true is <=1 pixel then the scrollbar will not be updated
        //      (to fix this issue I tried disabling the event before the update
        //      and enabling it after the update, this did not work)
        if (
            Math.abs(element.elems.yScrollBar.scrollTop - trueScrollTop) >= 1
        ) {
            element.elems.yScrollBar.scrollTop = trueScrollTop;
        }
        if (
            Math.abs(element.elems.xScrollBar.scrollLeft - trueScrollLeft) >= 1
        ) {
            element.elems.xScrollBar.scrollLeft = trueScrollLeft;
        }

        // render cells
        //console.trace('renderScrollLocation');
        //console.log('virtualScrollTop:  ', virtualScrollTop);
        //console.log('virtualScrollLeft: ', virtualScrollLeft);
        //console.log('trueScrollTop:     ', trueScrollTop);
        //console.log('trueScrollLeft:    ', trueScrollLeft);
        renderLocation(element);
        //renderLocation(element);
    }

    // we need to be able to update the scrollbar depending on the content
    //      height/width
    function renderScrollDimensions(element) {
        var i;
        var len;
        var arrColumnWidths;
        var arrRecordHeights;
        var columnBorderWidth;
        var recordBorderHeight;
        var intViewportWidth;
        var intViewportHeight;
        var intMaxColumnWidth;
        var intMaxRecordHeight;

        var intTotalDataWidth;
        var intTotalDataHeight;
        var intOverscrollWidth;
        var intOverscrollHeight;
        var intNoOverscrollHeight;
        var intNoOverscrollWidth;

        // we need to update the cell dimension numbers just in case some CSS
        //      has altered any of the dimensions
        cellDimensionDetector(element);

        // we need to update what features are visible (header, record
        //      selectors, insert record)
        visibilityDetector(element);

        // we need to update the scroll offsets so that we can make room for
        //      headers, insert records and record selectors in the viewport
        offsetDetector(element);

        // we're saving these to variables for quicker/easier access
        columnBorderWidth = element.internalDisplay.columnBorderWidth;
        recordBorderHeight = element.internalDisplay.recordBorderHeight;

        // we need to get column and record dimensions
        arrColumnWidths = element.internalDisplay.columnWidths;
        arrRecordHeights = element.internalDisplay.recordHeights;

        // we need to get the viewport dimensions
        intViewportWidth = element.elems.dataViewport.clientWidth;
        intViewportHeight = element.elems.dataViewport.clientHeight;

        // save max record height and column width
        intMaxColumnWidth = (
            intViewportWidth - (
                element.internalScrollOffsets.left +
                element.internalScrollOffsets.right +
                columnBorderWidth +
                5 // <-- added for extra room
            )
        );
        intMaxRecordHeight = (
            intViewportHeight - (
                element.internalScrollOffsets.top +
                element.internalScrollOffsets.bottom +
                recordBorderHeight +
                5 // <-- added for extra room
            )
        );

        // store the max cell dimensions internally
        element.internalDisplay.maxColumnWidth = intMaxColumnWidth;
        element.internalDisplay.maxRecordHeight = intMaxRecordHeight;

        // we need to add up column widths (including custom ones)
        intTotalDataWidth = 0;
        intOverscrollWidth = 0;
        i = 0;
        len = arrColumnWidths.length;
        while (i < len) {
            // make sure no column is wider than max
            if (
                intMaxColumnWidth > 3 &&
                arrColumnWidths[i] > intMaxColumnWidth
            ) {
                arrColumnWidths[i] = intMaxColumnWidth;
            }

            // increment total data width
            intTotalDataWidth += arrColumnWidths[i];
            intTotalDataWidth += columnBorderWidth;

            // we want to increase overscroll width until the last record
            if (i < (len - 1)) {
                intOverscrollWidth = intTotalDataWidth;
            }

            i += 1;
        }

        // we need to add up record heights (including custom ones)
        intTotalDataHeight = 0;
        intOverscrollHeight = 0;
        i = 0;
        len = arrRecordHeights.length;
        while (i < len) {
            // make sure no record is taller than max
            if (
                intMaxRecordHeight > 3 &&
                arrRecordHeights[i] > intMaxRecordHeight
            ) {
                arrRecordHeights[i] = intMaxRecordHeight;
            }

            // increment total data height
            intTotalDataHeight += arrRecordHeights[i];
            intTotalDataHeight += recordBorderHeight;

            // we want to increase overscroll height until the last record
            if (
                (
                    element.internalDisplay.insertRecordVisible &&
                    element.internalDisplay.insertRecordStick === null &&
                    i === (len - 1)
                ) ||
                (
                    (
                        !element.internalDisplay.insertRecordVisible ||
                        element.internalDisplay.insertRecordStick !== null
                    ) &&
                    i < (len - 1)
                )
            ) {
                // catch overscroll height up to total height
                intOverscrollHeight = intTotalDataHeight;
            }
            i += 1;
        }


        //if (
        //    element.internalDisplay.insertRecordVisible &&
        //    element.internalDisplay.insertRecordStick === null
        //) {
        //    intTotalDataHeight += (
        //        element.internalDisplay.insertRecordHeight +
        //        element.internalDisplay.insertRecordBorderHeight
        //    );
        //}

        //console.log('columnBorderWidth:  ', columnBorderWidth);
        //console.log('recordBorderHeight: ', recordBorderHeight);
        //console.log('Height:         ', intHeight);
        //console.log('ViewportHeight: ', intViewportHeight);
        //console.log('Width:          ', intWidth);
        //console.log('ViewportWidth:  ', intViewportWidth);
        //console.log('offsetTop:      ', element.internalScrollOffsets.top);
        //console.log('offsetBottom:   ', element.internalScrollOffsets.bottom);
        //console.log('offsetLeft:     ', element.internalScrollOffsets.left);
        //console.log('offsetRight:    ', element.internalScrollOffsets.right);

        //// add scroll offsets
        //intHeight += (
        //    element.internalScrollOffsets.top +
        //    element.internalScrollOffsets.bottom
        //);
        //intWidth += (
        //    element.internalScrollOffsets.left +
        //    element.internalScrollOffsets.right
        //);

        // save max scroll dimensions

        // we need to prevent vertical overscrolling if the
        //      "no-y-overscroll" attribute is present. the reason we can't
        //      just use the old maxTop value conditionally is because we
        //      make scrolling scroll by record, not pixel perfect. this
        //      means the last record will get cut off. so, in order to turn
        //      off overscrolling without this issue we need to calculate
        //      the amount to add to the maxTop in order to give enough room
        //      for the last record to clear the bottom of the viewport
        if (element.hasAttribute('no-y-overscroll')) {
            intNoOverscrollHeight = 0;
            i = 0;
            len = arrRecordHeights.length;
            while (i < len) {
                if (
                    (
                        intNoOverscrollHeight +
                        intViewportHeight
                    ) > (
                        intTotalDataHeight +
                        element.internalScrollOffsets.top +
                        element.internalScrollOffsets.bottom
                    )
                ) {
                    break;
                }

                // increment total data width
                intNoOverscrollHeight += arrRecordHeights[i];
                intNoOverscrollHeight += recordBorderHeight;

                i += 1;
            }

            if (
                element.internalDisplay.insertRecordVisible &&
                element.internalDisplay.insertRecordStick === null
            ) {
                intNoOverscrollHeight += (
                    element.internalDisplay.insertRecordHeight +
                    element.internalDisplay.insertRecordBorderHeight
                );
            }

            element.internalScroll.maxTop = Math.max(
                0,
                intNoOverscrollHeight
            );

            //console.log('1***');
            //console.log('   intTotalDataHeight: ', intTotalDataHeight);
            //console.log('  intOverscrollHeight: ', intOverscrollHeight);
            //console.log('intNoOverscrollHeight: ', intNoOverscrollHeight);
            //console.log('    intViewportHeight: ', intViewportHeight);

        } else {
            element.internalScroll.maxTop = Math.max(0, intOverscrollHeight);
        }

        // we need to prevent horizontal overscrolling if the
        //      "no-x-overscroll" attribute is present. the reason we can't
        //      just use the old maxLeft value conditionally is because we
        //      make scrolling scroll by column, not pixel perfect. this
        //      means the last column will get cut off. so, in order to turn
        //      off overscrolling without this issue we need to calculate
        //      the amount to add to the maxLeft in order to give enough
        //      room for the last column to clear the right of the viewport
        if (element.hasAttribute('no-x-overscroll')) {
            intNoOverscrollWidth = 0;
            i = 0;
            len = arrColumnWidths.length;
            while (i < len) {
                if (
                    (
                        intNoOverscrollWidth +
                        intViewportWidth
                    ) > (
                        intTotalDataWidth +
                        element.internalScrollOffsets.left +
                        element.internalScrollOffsets.right
                    )
                ) {
                    break;
                }

                // increment total data width
                intNoOverscrollWidth += arrColumnWidths[i];
                intNoOverscrollWidth += columnBorderWidth;

                i += 1;
            }

            element.internalScroll.maxLeft = Math.max(
                0,
                intNoOverscrollWidth
            );

            //console.log('2***');
            //console.log('   intTotalDataWidth: ', intTotalDataWidth);
            //console.log('  intOverscrollWidth: ', intOverscrollWidth);
            //console.log('intNoOverscrollWidth: ', intNoOverscrollWidth);
            //console.log('    intViewportWidth: ', intViewportWidth);

        } else {
            element.internalScroll.maxLeft = Math.max(0, intOverscrollWidth);
        }

        //console.log('maxTop:   ', element.internalScroll.maxTop);
        //console.log('maxLeft:  ', element.internalScroll.maxLeft);

        // sometimes, you may scroll to the right then widen your gs-table, this
        //      can cause you to get out of bounds
        // if the current scroll location is outside the max dimentions, set
        //      the scroll to the max allowed
        if (element.internalScroll.top > element.internalScroll.maxTop) {
            element.internalScroll.top = element.internalScroll.maxTop;
        }
        if (element.internalScroll.left > element.internalScroll.maxLeft) {
            element.internalScroll.left = element.internalScroll.maxLeft;
        }

        // move scrollbar causer elements to create scrollbars
        element.elems.yScrollBarCauser.style.top = (
            // scrollbars only work for a certain range that's why the max
            //      is 100000
            Math.min(
                (
                    (
                        element.internalScroll.maxTop +
                        intViewportHeight
                    ) - 1 // <-- the causer is px tall, this counteracts that
                ),
                100000
            ) + "px"
        );
        element.elems.xScrollBarCauser.style.left = (
            // scrollbars only work for a certain range that's why the max
            //      is 100000
            Math.min(
                (
                    (
                        element.internalScroll.maxLeft +
                        intViewportWidth
                    ) - 1 // <-- the causer is px wide, this counteracts that
                ),
                100000
            ) + "px"
        );

        // render scroll location
        renderScrollLocation(element);
    }

    function renderHUD(element) {
        var oldTopHUDHeight;
        var newTopHUDHeight;
        var oldBottomHUDHeight;
        var newBottomHUDHeight;


        // save the current hud height so that we can compare it to after the
        //      changes have been made
        oldTopHUDHeight = element.elems.topHudContainer.offsetHeight;

        // if we have a hud template: add hud class that makes the hud element
        //      visible and populate the hud element
        if (element.internalTemplates.topHUD.trim()) {
            element.elems.root.classList.add('show-top-hud');
            element.elems.topHudContainer.innerHTML = (
                element.internalTemplates.topHUD
            );

            // save new HUD height to a variable for clarity
            newTopHUDHeight = element.elems.topHudContainer.offsetHeight;

            // update padding to make room for the hud
            element.elems.root.style.paddingTop = newTopHUDHeight + 'px';

        // else, we have no template: make hud invisible and clear hud element
        } else {
            element.elems.root.classList.remove('show-top-hud');
            element.elems.topHudContainer.innerHTML = '';
            newTopHUDHeight = 0;
        }


        // save the current hud height so that we can compare it to after the
        //      changes have been made
        oldBottomHUDHeight = element.elems.bottomHudContainer.offsetHeight;

        // if we have a hud template: add hud class that makes the hud element
        //      visible and populate the hud element
        if (element.internalTemplates.bottomHUD.trim()) {
            element.elems.root.classList.add('show-bottom-hud');
            element.elems.bottomHudContainer.innerHTML = (
                element.internalTemplates.bottomHUD
            );

            // save new HUD height to a variable for clarity
            newBottomHUDHeight = element.elems.bottomHudContainer.offsetHeight;

            // update padding to make room for the hud
            element.elems.root.style.paddingBottom = newBottomHUDHeight + 'px';

        // else, we have no template: make hud invisible and clear hud element
        } else {
            element.elems.root.classList.remove('show-bottom-hud');
            element.elems.bottomHudContainer.innerHTML = '';
            newBottomHUDHeight = 0;
        }


        // if there is a difference in one of the HUD heights, we want to
        //      re-render the dataviewport because the HUD's height affects
        //      the viewport height
        if (
            oldTopHUDHeight !== newTopHUDHeight ||
            oldBottomHUDHeight !== newBottomHUDHeight
        ) {
            element.internalDisplay.fullRenderRequired = true;
            renderScrollDimensions(element);
        }
    }

    // sometimes, the user will resize the selected columns to their respective
    //      header widths. this function is a shortcut for that functionality.
    function resizeColumnsToHeader(element, arrColumnIndexes) {
        var i;
        var len;
        var intIndex;

        // loop through each selected column
        i = 0;
        len = arrColumnIndexes.length;
        while (i < len) {
            intIndex = arrColumnIndexes[i];

            // set the width the min width, which is the same as the header
            //      width
            element.internalDisplay.columnWidths[intIndex] = (
                element.internalDisplay.minColumnWidths[intIndex]
            );

            i += 1;
        }

        // re-render location
        renderLocation(element);
    }

    function resizeColumnsToContent(element, arrColumnIndexes) {
        var i;
        var len;
        var elem_i;
        var elem_len;
        var intIndex;
        var arrElements;
        var controlElement;
        var intWidth;
        var jsnRange;

        var scopeElement;
        var controlText;
        var intTextWidth;

        var intColumnWidth;
        var intScopeElementWidth;

        // we only resize content that is rendered. to do that we need to
        //      know the current rendered range.
        jsnRange = element.internalDisplay.currentRange;

        // loop through each selected column
        i = 0;
        len = arrColumnIndexes.length;
        while (i < len) {
            intIndex = arrColumnIndexes[i];

            // we only pay attention to the content that has been rendered.
            //      so, only do anything if the current column is rendered.
            if (
                intIndex >= jsnRange.fromColumn &&
                intIndex <= jsnRange.toColumn
            ) {
                // console.log(intIndex);

                // start with the min width, any future width settings must be
                //      larger than this
                intWidth = element.internalDisplay.minColumnWidths[intIndex];

                // we need the old column width for a calculation
                intColumnWidth = element.internalDisplay.columnWidths[intIndex];

                // get the rendered cell elements for this column
                arrElements = xtag.query(
                    element.elems.dataViewport,
                    'gs-cell.table-cell[data-col-number="' + intIndex + '"]'
                );

                // loop through every data cell for this column
                elem_i = 0;
                elem_len = arrElements.length;
                while (elem_i < elem_len) {
                    // the goal is the find text and an element. once we've
                    //      found both of those, we can use GS.getTextWidth
                    //      to determine the text width and if that's larger
                    //      than the current width, set the current width to
                    //      the text width.
                    // the question is how are we going to find the element
                    //      and it's text seein' as how we can put whatever
                    //      we want in a cell... we'll have four different
                    //      options and each cell will be in one of them.
                    //          option the 1st: input text and it's parent
                    //          option the 2nd: textarea text and it's parent
                    //          option the 3rd: select text and it's parent
                    //          option the 4th: textContent and the cell

                    controlElement = xtag.query(
                        arrElements[elem_i],
                        'input, textarea, select'
                    )[0];

                    if (
                        controlElement &&
                        (
                            controlElement.nodeName === 'INPUT' ||
                            controlElement.nodeName === 'TEXTAREA' ||
                            controlElement.nodeName === 'SELECT'
                        )
                    ) {
                        scopeElement = controlElement.parentNode;
                        controlText = controlElement.value;

                    } else {
                        scopeElement = (
                            // this fixes label-wrapped cells
                            arrElements[elem_i].children[0] ||
                            arrElements[elem_i]
                        );
                        controlText = arrElements[elem_i].textContent;
                    }

                    // get text width using the scope element and the control
                    //      text
                    intTextWidth = GS.getTextWidth(
                        scopeElement,
                        controlText,
                        true // preserve whitespace
                    );

                    // there may be some padding between the scope element
                    //      and the cell element. so, we want to account for
                    //      that.
                    intScopeElementWidth = Math.ceil(
                        scopeElement.clientWidth - (
                            parseFloat(
                                GS.getStyle(scopeElement, 'padding-left')
                            ) +
                            parseFloat(
                                GS.getStyle(scopeElement, 'padding-right')
                            )
                        )
                    );

                    //console.log('test0:', controlElement);
                    //console.log('test1:', scopeElement);
                    //console.log('test2:', controlText);
                    //console.log('test3:', intWidth);
                    //console.log('test4:', intTextWidth);
                    //console.log('test5:', intColumnWidth);
                    //console.log('test6:', intScopeElementWidth);
                    //console.log(
                    //    'test7:',
                    //    (intColumnWidth - intScopeElementWidth)
                    //);
                    //console.log(
                    //    'test8:',
                    //    GS.getStyle(scopeElement, 'padding-left')
                    //);
                    //console.log(
                    //    'test9:',
                    //    GS.getStyle(scopeElement, 'padding-right')
                    //);

                    // add padding to text width
                    intTextWidth += (intColumnWidth - intScopeElementWidth);

                    // add an arbituary amount to deal with small imperfections
                    intTextWidth += 10;

                    // if the new text width is greater than the currently
                    //      proposed width, set the currently proposed width
                    //      to the new text width
                    if (intTextWidth > intWidth) {
                        intWidth = intTextWidth;
                    }

                    elem_i += 1;
                }

                // set the width
                element.internalDisplay.columnWidths[intIndex] = intWidth;
            }

            i += 1;
        }

        // re-render location
        renderLocation(element);
    }

// ############################################################################
// ############################# LOADER FUNCTIONS #############################
// ############################################################################

    // loaders are appended to the end of the loader list, this is not where
    //      they belong. so, this function takes a loader element (which has
    //      already been appended) and moves it to the top of the loader
    //      container element
    function moveLoaderToTop(element, loaderElement) {
        // ### NEED CODING ###
    }

    // because of the way the loader container works, we need to set a margin
    //      so that the loader becomes visible
    function adjustLoaderWidth(element, loaderElement) {
        var loaderContent;

        // get the wrapped content
        loaderContent = loaderElement.children[0];

        // set the marginLeft to counteract the width
        loaderContent.style.marginLeft = (
            '-' + (loaderContent.offsetWidth + 10) + 'px'
        );

        // old, required getTextWidth which is slow
        //var intWidth;

        //// we calculate the width and store it in a variable
        //intWidth = GS.getTextWidth(element, loaderElement.textContent);

        //// let's add a little padding
        //intWidth += 25;

        //// set loader width and a reverse margin so that it moves to the left
        ////      the same amount
        //loaderElement.style.width = intWidth + 'px';
        //loaderElement.style.marginLeft = '-' + intWidth + 'px';
    }

    function addLoader(element, strID, strContent) {
        var loaderElement;

        // create loader element
        loaderElement = document.createElement('div');
        loaderElement.classList.add('table-loader-wrapper');
        loaderElement.innerHTML = (
            '<div class="table-loader">' + strContent + '</div>'
        );

        // append loader element to loader container
        element.elems.loaderContainer.appendChild(loaderElement);

        // append new loader imformation to a place where we can retrieve it
        element.internalLoaders.loaderIDs.push(strID);
        element.internalLoaders.loaderElements.push(loaderElement);

        // adjust loader width so that it displays all on one line
        adjustLoaderWidth(element, loaderElement);

        // move loader to top
        moveLoaderToTop(element, loaderElement);

        //console.log('added loader', loaderElement);
    }

    function removeLoader(element, strID, strFinishedContent) {
        var loaderIndex;
        var loaderElement;
        var fadeOut;
        var removeFunction;

        // get index of loader in loader array
        loaderIndex = element.internalLoaders.loaderIDs.indexOf(strID);

        // get loader element using index
        loaderElement = element.internalLoaders.loaderElements[loaderIndex];

        // remove loader from loader arrays immediately so that if another
        //      loader is removed with the same name, we won't remove the same
        //      one twice
        element.internalLoaders.loaderIDs.splice(loaderIndex, 1);
        element.internalLoaders.loaderElements.splice(loaderIndex, 1);

        // define a fade out function so that we only need to write the code
        //      once.
        fadeOut = function () {
            // add fade out class
            loaderElement.classList.add('table-fade-out');

            // we want to be able to remove this function to free the memory
            removeFunction = function () {
                // if the loader container is still in use
                if (
                    element.elems &&
                    element.elems.loaderContainer
                ) {
                    // remove the loader
                    element.elems.loaderContainer.removeChild(loaderElement);
                }

                // clear function to free up memory
                removeFunction = null;
            };

            // remove loader from loader container after fade out animation
            //      is complete
            setTimeout(removeFunction, 1000);

            // clear function to free up memory
            fadeOut = null;
        };

        // if there is strFinishedContent, we need to change the content then
        //      fade out
        if (strFinishedContent) {
            // switch content to loader content
            loaderElement.children[0].innerHTML = strFinishedContent;

            // adjust loader width so that it displays all on one line
            adjustLoaderWidth(element, loaderElement);

            // move loader to top
            moveLoaderToTop(element, loaderElement);

            // fade out after some time has passed to read the new content
            setTimeout(fadeOut, 1000);

        // else, just fade loader out
        } else {
            fadeOut();
        }
    }

// ############################################################################
// ############################## DATA FUNCTIONS ##############################
// ############################################################################

    function dataSELECTcallback(element) {
        var intDifference;
        var i;
        var len;
        var bolFirstLoad;

        // we need to know if this was the first load
        bolFirstLoad = (element.internalData.bolFirstLoadFinished === false);

        // we may need to add or remove some record heights
        intDifference = (
            element.internalDisplay.recordHeights.length -
                element.internalData.records.length
        );

        // sometimes a record disappears between selects, someone else might
        //      delete a record and then you refresh, in this case we need to
        //      remove a enough records heights to make up the difference
        if (intDifference > 0) {
            i = 0;
            len = intDifference;
            while (i < len) {
                element.internalDisplay.recordHeights.pop();
                i += 1;
            }

        // there's a possibility of a record being added without an accompanying
        //      record height, if that's happened we add enough record heights
        //      to make up the difference
        } else if (intDifference < 0) {
            i = 0;
            len = Math.abs(intDifference);
            while (i < len) {
                element.internalDisplay.recordHeights.push(
                    element.internalDisplay.defaultRecordHeight
                );
                i += 1;
            }
        }

        // make sure that everything knows the first load is over
        if (element.internalData.bolFirstLoadFinished === false) {
            element.internalData.bolFirstLoadFinished = true;
        }

        // re-render scroll location because adding records changes scroll
        //      heights, and so that we can show the new data
        element.internalDisplay.fullRenderRequired = true;
        renderScrollDimensions(element);

        // sometimes, developers want to have the gs-table select and focus
        //      after it first loads
        if (
            element.hasAttribute('focus-on-load') &&
            bolFirstLoad &&
            // if we are already focused, then ignore
            element.internalSelection.ranges.length === 0
        ) {
            // if there is data, select the first cell
            if (element.internalData.records.length > 0) {
                element.internalSelection.ranges = [
                    {
                        "start": {
                            "row": 0,
                            "column": 0
                        },
                        "end": {
                            "row": 0,
                            "column": 0
                        },
                        "negator": false
                    }
                ];

                focusIntoCell(
                    element,
                    0, // record
                    0  // column
                );

            // sometimes, there's no data to select, select the "all"
            //      selector if it's visible
            } else if (
                element.internalDisplay.recordSelectorVisible &&
                element.internalDisplay.headerVisible
            ) {
                element.internalSelection.ranges = [
                    {
                        "start": {
                            "row": "header",
                            "column": "selector"
                        },
                        "end": {
                            "row": "header",
                            "column": "selector"
                        },
                        "negator": false
                    }
                ];
            }

            renderSelection(element);
        }
        GS.triggerEvent(element, 'after_select');
    }
    function dataINSERTcallback(element) {
        // re-render scroll location because adding records changes scroll
        //      heights, and so that we can show the new data
        element.internalDisplay.fullRenderRequired = true;
        renderScrollDimensions(element);

        // scroll to the bottom so that the user can see the newly created
        //      records without having to scroll
        // element.internalScroll.top = (
        //     element.internalScroll.maxTop - (
        //         element.elems.dataViewport.clientHeight - (
        //             element.internalScrollOffsets.top +
        //             element.internalScrollOffsets.bottom +
        //             element.internalDisplay.defaultRecordHeight
        //         )
        //     )
        // );
        element.goToLine('last');

        // re-render scroll location because we changed the scrollTop
        renderScrollLocation(element);
    }
    function dataUPDATEcallback(element) {
        // re-render location so that if changing the data resulted in
        //      calculated columns changing or some other unknown change
        //      occurs: the user will see the changes
        element.internalDisplay.fullRenderRequired = true;
        renderLocation(element);
        //console.log('In here!!');
    }
    function dataDELETEcallback(element) {
        // clear selection because the stuff that the user selected has
        //      now been deleted
        element.internalSelection.ranges = [];

        // re-render scroll location because removing records changes scroll
        //      heights
        element.internalDisplay.fullRenderRequired = true;
        renderScrollDimensions(element);
    }

    function getWhereClause(element) {
        var i;
        var len;
        var arrFilter;
        var strColumn;
        var filter_i;
        var filter_len;
        var strFilter;
        var jsnFilter;
        var strListWhere;

        var arrOldColumnNames;
        var arrOldColumnTypes;
        var arrOldColumnFilterStatuses;
        var arrOldColumnFilters;
        var arrOldColumnListFilters;

        var strWhere;
        var strUserWhere;
        var strWhereColumn;

        // we need to include any where clauses added be the developer.
        //      this where clause is templated with the querystring.
        strWhere = GS.templateWithQuerystring(
            element.getAttribute('where') || '1=1'
        );

        // add in user filters, if any
        if (element.getAttribute('session-filter')) {
            strWhere = '(' + element.getAttribute('session-filter') + ')';
            strWhere += (
                strWhere
                    ? ' AND ' + strWhere
                    : ''
            );
        }

        // add in a column or qs where, if any

        // we need to be able to handle header-line relationships, this code
        //      uses the "column", "qs" and "value" attributes to formulate
        //      a where clause
        if (
            element.getAttribute('value') &&
            (
                element.getAttribute('column') ||
                element.getAttribute('qs')
            )
        ) {
            strWhereColumn = (
                element.getAttribute('child-column') ||
                element.getAttribute('column') ||
                element.getAttribute('qs')
            );

            // if the value is not a number, we need to do a string
            //      comparison in the where clause.
            if (isNaN(element.value)) {
                strWhere = (
                    'CAST(' +
                    strWhereColumn + ' AS ' +
                    GS.database.type.text +
                    ') = ' +
                    'CAST(' +
                    '$WhereQUOTE$' + (element.value) + '$WhereQUOTE$ AS ' +
                    GS.database.type.text +
                    ')'
                );
                strWhere += (
                    strWhere !== ''
                        ? ' AND (' + strWhere + ')'
                        : ''
                );

            // if the value is a number, we can do simpler, number comparison
            } else {
                strWhere = strWhereColumn + '=' + (element.value);
                strWhere += (
                    strWhere !== ''
                        ? ' AND (' + strWhere + ')'
                        : ''
                );
            }
        }

        arrOldColumnNames = element.internalData.columnNames;
        arrOldColumnTypes = element.internalData.columnTypes;
        arrOldColumnFilterStatuses = element.internalData.columnFilterStatuses;
        arrOldColumnFilters = element.internalData.columnFilters;
        arrOldColumnListFilters = element.internalData.columnListFilters;

        // we want the user to be able to filter a column, so here we'll look
        //      at what the user set for each column and prepend to the where
        //      clause
        strUserWhere = '';
        i = 0;
        len = arrOldColumnFilters.length;
        while (i < len) {
            arrFilter = arrOldColumnFilters[i];
            strColumn = arrOldColumnNames[i];

            // only filter if this column's filters haven't been toggled off
            if (arrOldColumnFilterStatuses[i] === 'on') {
                filter_i = 0;
                filter_len = arrFilter.length;
                while (filter_i < filter_len) {
                    strFilter = arrFilter[filter_i].text;
                    strUserWhere += (
                        strUserWhere
                            ? ' AND '
                            : ''
                    );

                    strUserWhere += strFilter;
                    filter_i += 1;
                }
            }

            i += 1;
        }

        //console.log('old filter:', arrOldColumnListFilters[0]);

        i = 0;
        len = arrOldColumnListFilters.length;
        while (i < len) {
            jsnFilter = arrOldColumnListFilters[i];
            strColumn = arrOldColumnNames[i];
            strListWhere = '';

            // only filter if this column's filters haven't been toggled off
            //      and there is a filter
            if (
                arrOldColumnFilterStatuses[i] === 'on' &&
                jsnFilter.type &&
                jsnFilter.values
                //jsnFilter.values.length > 0
                //  ^-- when nothing is chosen, we want nothing to match. this
                //      line was preventing the WHERE from being generated
            ) {
                if (jsnFilter.type === 'inclusion') {
                    filter_i = 0;
                    filter_len = jsnFilter.values.length;
                    while (filter_i < filter_len) {
                        strListWhere += (
                            strListWhere
                                ? ' OR '
                                : ''
                        );

                        strListWhere += (
                            strColumn +
                            ' = CAST($werequote$' +
                            jsnFilter.values[filter_i] +
                            '$werequote$ AS ' + arrOldColumnTypes[i] +
                            ')'
                        );
                        filter_i += 1;
                    }

                    //console.log(filter_i, filter_len);

                    if (filter_len === 0) {
                        strListWhere = '1=2';
                    }

                } else if (jsnFilter.type === 'exclusion') {
                    if (jsnFilter.values.length > 0) {
                        filter_i = 0;
                        filter_len = jsnFilter.values.length;
                        while (filter_i < filter_len) {
                            strListWhere += (
                                strListWhere
                                    ? ' AND '
                                    : ''
                            );

                            strListWhere += (
                                strColumn +
                                ' != CAST($werequote$' +
                                jsnFilter.values[filter_i] +
                                '$werequote$ AS ' + arrOldColumnTypes[i] +
                                ')'
                            );
                            filter_i += 1;
                        }
                    }
                }

                // if we are excluding nothing the blank code causes
                //      the where to just be "WHERE column is blank"
                if (
                    (
                        strListWhere &&
                        !(
                            jsnFilter.type === 'exclusion' &&
                            jsnFilter.values.length === 0
                        )
                    ) ||
                    jsnFilter.blanks === false
                ) {
                    // we need to handle blank values specially
                    if (strListWhere) {
                        strListWhere = '(' + strListWhere + ') ';
                    }

                    if (jsnFilter.blanks === true) {
                        if (strListWhere) {
                            strListWhere += ' OR';
                        }

                        strListWhere += (
                            ' NULLIF(' +
                                'CAST(' +
                                    strColumn + ' AS ' +
                                    GS.database.type.text +
                                '), \'\') IS NULL'
                        );
                    } else {
                        if (strListWhere) {
                            strListWhere += ' AND';
                        }

                        strListWhere += (
                            ' NULLIF(' +
                                'CAST(' +
                                    strColumn + ' AS ' +
                                    GS.database.type.text +
                                '), \'\') IS NOT NULL'
                        );
                    }

                    // console.log(
                    //     jsnFilter,
                    //     strListWhere
                    // );

                    strUserWhere += (
                        strUserWhere
                            ? ' AND '
                            : ''
                    );
                    strUserWhere += '(' + strListWhere + ')';
                }
            }

            i += 1;
        }

        // if a where is defined by the dev, put it after our new where
        if (strUserWhere && strWhere) {
            strWhere = strUserWhere + ' AND (' + strWhere + ')';

        // if there is no where set by the developer, our new where will be
        //      the only one
        } else if (strUserWhere) {
            strWhere = strUserWhere;
        }

        return strWhere;
    }

    function databaseWSSELECT(element) {
        var socket;
        var strSchema;
        var strObject;
        var strWhere;
        var strOrd;
        var strLimit;
        var strOffset;
        var strReturn;
        var strWhereColumn;
        var bolLoadNewRecordHeights;
        var intRecordHeight;

        var arrOldColumnNames;
        var arrOldColumnTypes;
        var arrOldColumnFilterStatuses;
        var arrOldColumnFilters;
        var arrOldColumnListFilters;
        var arrOldColumnOrders;
        var arrOldDisplayColumns;

        var i;
        var len;
        var strFilter;
        var strSort;
        var strColumn;
        var strUserOrd;
        var strUserWhere;
        var strListWhere;
        var filter_i;
        var filter_len;
        var arrFilter;
        var jsnFilter;
        var index;
        var arrRecords;
        var arrRecordHeights;

        socket = getSocket(element);
        strSchema = GS.templateWithQuerystring(
            element.getAttribute('schema') || ''
        );
        strObject = GS.templateWithQuerystring(
            element.getAttribute('object') || ''
        );
        strWhere = getWhereClause(element);
        strOrd = GS.templateWithQuerystring(
            element.getAttribute('ord') || ''
        );
        strLimit = GS.templateWithQuerystring(
            element.getAttribute('limit') || ''
        );
        strOffset = GS.templateWithQuerystring(
            element.getAttribute('offset') || '0'
        );
        strReturn = '*';

        //// disabled, hide or not the pageinate buttons
        //if (strLimit === '') {
        //    element.pageLeftButton.setAttribute('hidden', '');
        //    element.pageRightButton.setAttribute('hidden', '');
        //} else if (strOffset === '' || strOffset === '0') {
        //    element.pageLeftButton.setAttribute('disabled', '');
        //}

        // if no records heights exist: we need to load record heights
        bolLoadNewRecordHeights =
                (element.internalDisplay.recordHeights.length === 0);

        // we need to create records with the default record height attached to
        //      them, so we'll use the "default-record-height" attribute
        intRecordHeight = (
            parseInt(element.getAttribute('default-record-height'), 10) ||
            intDefaultRecordHeight
        );

        // we need to make sure that no old data persists across select calls,
        //      so we'll clear out the internal data object
        element.internalData.records = [];

        // we need to re-link the new column list with the old column sorts,
        //      filters and filter statuses
        arrOldColumnNames = element.internalData.columnNames;
        arrOldColumnTypes = element.internalData.columnTypes;
        arrOldColumnFilterStatuses = element.internalData.columnFilterStatuses;
        arrOldColumnFilters = element.internalData.columnFilters;
        arrOldColumnListFilters = element.internalData.columnListFilters;
        arrOldColumnOrders = element.internalData.columnOrders;
        arrOldDisplayColumns = element.internalDisplay.dataColumnName;

        // we want the user to be able to sort on a column, so here we'll look
        //      at what the user set for each column and prepend to the order
        //      by clause

        // we'll loop through the display column associations and see if any
        //      of those columns have been sorted
        strUserOrd = '';
        i = 0;
        len = arrOldDisplayColumns.length;
        while (i < len) {
            strColumn = arrOldDisplayColumns[i];

            if (strColumn) {
                index = arrOldColumnNames.indexOf(strColumn);
                strSort = arrOldColumnOrders[index];

                if (strSort === 'asc') {
                    strUserOrd += (
                        strUserOrd
                            ? ', '
                            : ''
                    );
                    strUserOrd += strColumn + ' ASC';

                } else if (strSort === 'desc') {
                    strUserOrd += (
                        strUserOrd
                            ? ', '
                            : ''
                    );
                    strUserOrd += strColumn + ' DESC';
                }
            }
            i += 1;
        }

        //  ,---- commented out because it did not take column order into
        //  V           account
        //strUserOrd = '';
        //i = 0;
        //len = arrOldColumnOrders.length;
        //while (i < len) {
        //    strSort = arrOldColumnOrders[i];
        //    strColumn = arrOldColumnNames[i];

        //    if (strSort === 'asc') {
        //        strUserOrd += (
        //            strUserOrd
        //                ? ', '
        //                : ''
        //        );
        //        strUserOrd += strColumn + ' ASC';

        //    } else if (strSort === 'desc') {
        //        strUserOrd += (
        //            strUserOrd
        //                ? ', '
        //                : ''
        //        );
        //        strUserOrd += strColumn + ' DESC';
        //    }

        //    i += 1;
        //}

        // if an order by is defined by the dev, put it after our new order by
        if (strUserOrd && strOrd) {
            strOrd = strUserOrd + ', ' + strOrd;

        // if there is no orderby set by the developer, our new order by will be
        //      the only one
        } else if (strUserOrd) {
            strOrd = strUserOrd;
        }

        console.time('data load');

        // storing references to the arrays for faster access
        arrRecords = element.internalData.records;
        arrRecordHeights = element.internalDisplay.recordHeights;

        // we need the user to know that the envelope is re-fetching data,
        //      so we'll put a loader on
        addLoader(element, 'data-select', 'Loading Data...');
        GS.requestSelectFromSocket(
            socket,
            strSchema,
            strObject,
            strReturn,
            strWhere,
            strOrd,
            strLimit,
            strOffset,
            function (data, error) {
                //var i;
                //var len;
                var col_i;
                var col_len;
                var strCol;
                //var index;
                var strRecord;
                var strMessage;
                //var strChar;

                if (!error) {
                    // if this is the first callback, we need to save
                    //      the column names and types and we need to
                    //      re-link the filters, sorts and filter statuses
                    //
                    // this was below in the else, but requestSelectFromSocket
                    //      will only callback once if there are no records
                    //      - Nunzio 5/29/2017
                    if (data.intCallback === 0) {
                        // clear old column arrays to make remove for any
                        //      changes to the column list
                        element.internalData.columnNames = [];
                        element.internalData.columnTypes = [];
                        element.internalData.columnFilterStatuses = [];
                        element.internalData.columnFilters = [];
                        element.internalData.columnListFilters = [];
                        element.internalData.columnOrders = [];

                        // future mike, you need to make is so that the
                        //      column name, filter and sort arrays are
                        //      retained across select calls.
                        // past mike, sounds good, I'll use the old column
                        //      list to get the old sorts filters, and
                        //      filter statuses
                        col_i = 0;
                        col_len = data.arrDecodedColumnNames.length;
                        while (col_i < col_len) {
                            strCol = data.arrDecodedColumnNames[col_i];
                            index = arrOldColumnNames.indexOf(strCol);

                            element.internalData.columnNames.push(
                                strCol
                            );
                            element.internalData.columnTypes.push(
                                data.arrDecodedColumnTypes[col_i]
                            );

                            // if we've got old values from the select,
                            //      bring them over to the new arrays
                            if (index > -1) {
                                element.internalData
                                    .columnFilterStatuses.push(
                                        arrOldColumnFilterStatuses[index]
                                    );
                                element.internalData
                                    .columnFilters.push(
                                        arrOldColumnFilters[index]
                                    );
                                element.internalData
                                    .columnListFilters.push(
                                        arrOldColumnListFilters[
                                            index
                                        ]
                                    );
                                element.internalData
                                    .columnOrders.push(
                                        arrOldColumnOrders[index]
                                    );

                            // else, add empty sort, filter and filter
                            //      status
                            } else {
                                element.internalData
                                    .columnFilterStatuses.push('on');
                                element.internalData
                                    .columnFilters.push([]);
                                element.internalData
                                    .columnListFilters.push({});
                                element.internalData
                                    .columnOrders.push('neutral');
                            }

                            col_i += 1;
                        }
                    }

                    // we need to remove the loader at some point, if we see
                    //      the last message of the select: remove loader and
                    //      render
                    if (data.strMessage === 'TRANSACTION COMPLETED') {
                        //// required for v3 test#1
                        //element.internalData.records = (
                        //    arrRecords
                        //);
                        //element.internalDisplay.recordHeights = (
                        //    arrRecordHeights
                        //);

                        // back to non-test code
                        console.timeEnd('data load');
                        console.log(
                            'record count:',
                            element.internalData.records.length
                        );
                        removeLoader(element, 'data-select', 'Data Loaded');
                        dataSELECTcallback(element);

                    // we need to capture the records and columns and store
                    //      them in the internal data
                    } else {
                        if (
                            data.intCallback === 3 &&
                            element.internalData.bolFirstLoadFinished === false
                        ) {
                            //// required for v3 test#1
                            //element.internalData.records = (
                            //    arrRecords
                            //);
                            //element.internalDisplay.recordHeights = (
                            //    arrRecordHeights
                            //);

                            // re-render scroll location because adding records
                            //      changes scroll heights, and so that we can
                            //      show the new data
                            element.internalDisplay.fullRenderRequired = true;
                            renderScrollDimensions(element);
                        }

                        // we need to parse the TSV into records and push them
                        //      to the internalData "records" array
                        // now, we have an advantage in that Envelope Websocket
                        //      data is already encoded in the correct format
                        //      and all we have to is split on \n
                        // also, Envelope Websocket data always ends in \n so
                        //      the loop doesn't need to do anything special
                        //      to get the last record
                        strMessage = data.strMessage;
                        strRecord = '';

                        //// splitter test#1 v3, slower than v2
                        //var arrRecord = strMessage.split('\n');
                        //arrRecord.pop();
                        //arrRecords = arrRecords.concat(arrRecord);
                        //if (bolLoadNewRecordHeights) {
                        //    i = 0;
                        //    len = (
                        //        (
                        //            arrRecords.length -
                        //            arrRecordHeights.length
                        //        ) +
                        //        1
                        //    );
                        //    while (i < len) {
                        //        arrRecordHeights.push(intRecordHeight);
                        //        i += 1;
                        //    }
                        //}

                        // splitter v2, faster than v1 by 1 third
                        //if (window.asdfasdf === true) {
                        //    //console.log(strMessage);
                        //}
                        i = 0;
                        while (i < 15) {
                            index = strMessage.indexOf('\n');
                            strRecord = strMessage.substring(0, index);
                            strMessage = strMessage.substring(index + 1);

                            if (strRecord !== '' || strMessage !== '') {
                                arrRecords.push(strRecord);

                                //if (window.asdfasdfasdf === true) {
                                //    //console.log(strRecord);
                                //}
                                if (bolLoadNewRecordHeights) {
                                    arrRecordHeights.push(intRecordHeight);
                                }
                            } else {
                                break;
                            }

                            i += 1;
                        }

                        //// splitter v1, replaced because it was slow
                        //strMessage = data.strMessage;
                        //strRecord = '';
                        //i = 0;
                        //len = strMessage.length;
                        //while (i < len) {
                        //    strChar = strMessage[i];

                        //    if (strChar === '\n') {
                        //        element.internalData.records.push(strRecord);

                        //        if (bolLoadNewRecordHeights) {
                        //            element.internalDisplay
                        //                .recordHeights
                        //                .push(intRecordHeight);
                        //        }

                        //        strRecord = '';
                        //    } else {
                        //        strRecord += strChar;
                        //    }

                        //    i += 1;
                        //}
                    }

                // we need to make sure that the user knows that the select
                //      failed and we need to prevent using any old select
                //      info, so we'll re-render, remove the loader and pop
                //      up an error
                } else {
                    dataSELECTcallback(element);
                    removeLoader(element, 'data-select', 'Data Failed To Load');
                    GS.webSocketErrorDialog(data);
                }
            }
        );
    }
    function databaseWSINSERT(element, strMode, jsnInsert) {
        var rec_i;
        var rec_len;
        var col_i;
        var col_len;
        var strColumn;

        var strPostfix;
        var insertStep;
        var beforeEvent;

        var arrPK;
        var arrSeq;
        var strPK;
        var strSeq;
        var strInsertColumns;
        var strInsertData;

        var strSchema;
        var strObject;
        var strReturn;
        var strNullString;
        var intRecordHeight;

        // get schema and object attributes and get the return column list
        strSchema = GS.templateWithQuerystring(
            element.getAttribute('schema') || ''
        );
        strObject = GS.templateWithQuerystring(
            element.getAttribute('object') || ''
        );

        // the return column list must be defined the same as the column list
        //      that we store the data with, so we define strReturn using the
        //      column list
        strReturn = '';
        col_i = 0;
        col_len = element.internalData.columnNames.length;
        while (col_i < col_len) {
            strReturn += (
                strReturn
                    ? '\t'
                    : ''
            );
            strReturn += element.internalData.columnNames[col_i].replace(/(\\)/g, '\\\\');
            col_i += 1;
        }

        // we need to know if the developer has specified any special primary
        //      key columns and/or sequence columns
        strPK = GS.templateWithQuerystring(
            element.getAttribute('pk') || ''
        );
        strSeq = GS.templateWithQuerystring(
            element.getAttribute('seq') || ''
        );
        arrPK = strPK.split(/[\s]*,[\s]*/);
        arrSeq = strSeq.split(/[\s]*,[\s]*/);

        // we want the null string to be configurable, so we'll read the
        //      "null-string" attribute to get the null string
        // if the "null-string" attribute is present, use the contents
        //      or coalesce to empty string
        if (element.hasAttribute('null-string')) {
            strNullString = element.getAttribute('null-string') || '';

        // else, null string is left up to the encoding function
        } else {
            strNullString = undefined;
        }

        // we need to create records with the default record height attached to
        //      them, so we'll use the "default-record-height" attribute
        intRecordHeight = (
            parseInt(element.getAttribute('default-record-height'), 10) ||
            intDefaultRecordHeight
        );

        // there are three different ways to insert records:
        //      1) typing into the insert record
        //      2) filling insert dialog
        //      3) pasting into the insert record.
        //      types 1 and 2 are "single-record" inserts
        //      type 3 is a "multi-record" insert

        // "single-record"
        if (strMode === 'single-record') {
            // if there is an addin value and that column was not already in the
            //      insert, add the value to the insert
            if (
                jsnInsert.data.addin &&
                jsnInsert.data.addin.link_column &&
                jsnInsert.data.addin.link_value &&
                jsnInsert
                    .data
                    .columns
                    .indexOf(jsnInsert.data.addin.link_column) === -1
            ) {
                strColumn = jsnInsert.data.addin.link_column;

                jsnInsert.data.columns.push(
                    jsnInsert.data.addin.link_column
                );
                jsnInsert.data.values[strColumn] = (
                    jsnInsert.data.addin.link_value
                );
            }

            strInsertColumns = '';
            strInsertData = '';
            col_i = 0;
            col_len = jsnInsert.data.columns.length;
            while (col_i < col_len) {
                strColumn = jsnInsert.data.columns[col_i].replace(/(\\)/g, '\\\\');

                strInsertColumns += (
                    strInsertColumns
                        ? '\t'
                        : ''
                );
                strInsertColumns += strColumn;

                strInsertData += (
                    strInsertData
                        ? '\t'
                        : ''
                );
                strInsertData += GS.encodeForTabDelimited(
                    (jsnInsert.data.values[strColumn] || 'NULL'),
                    strNullString
                );

                col_i += 1;
            }

            // append a return after the end of the insert data because
            //      the envelope expects it
            strInsertData += '\n';

        // "multi-record" assumes that:
        //      1) the data is a dump
        //      2) isn't stored anywhere
        //      3) only affects the currently selected insert record columns
        //              unless none are selected, in that case: all columns
        } else if (strMode === 'multi-record') {
            // if there is an addin value and that column was not already in the
            //      insert, add the value to the insert
            if (
                jsnInsert.data.addin &&
                jsnInsert.data.addin.link_column &&
                jsnInsert.data.addin.link_value &&
                jsnInsert
                    .data
                    .columns
                    .indexOf(jsnInsert.data.addin.link_column) === -1
            ) {
                strColumn = jsnInsert.data.addin.link_column;

                jsnInsert.data.columns.push(
                    jsnInsert.data.addin.link_column
                );

                rec_i = 0;
                rec_len = jsnInsert.data.columns.length;
                while (rec_i < rec_len) {
                    jsnInsert.data.values[rec_i] += '\t';
                    jsnInsert.data.values[rec_i] += GS.encodeForTabDelimited(
                        jsnInsert.data.addin.link_value
                    );
                    rec_i += 1;
                }
            }

            // build up insert column list
            strInsertColumns = '';
            col_i = 0;
            col_len = jsnInsert.data.columns.length;
            while (col_i < col_len) {
                strColumn = jsnInsert.data.columns[col_i].replace(/(\\)/g, '\\\\');

                strInsertColumns += (
                    strInsertColumns
                        ? '\t'
                        : ''
                );
                strInsertColumns += strColumn;

                col_i += 1;
            }

            // build up insert payload by appending each record with a \n in
            //      front of it
            strInsertData = '';
            rec_i = 0;
            rec_len = jsnInsert.data.values.length;
            while (rec_i < rec_len) {
                strInsertData += jsnInsert.data.values[rec_i];
                strInsertData += '\n';
                rec_i += 1;
            }

            // no need to append a return after the end of the insert data
            //      because the loop that builds up the record list above
            //      already appends the \n to the end

        } else {
            throw 'GS-TABLE Error: Invalid insert type: "' + strMode + '".';
        }

        // regardless of insert mode, we need a list of columns that uniquely
        //      identifies a record
        col_i = 0;
        col_len = arrSeq.length;
        while (col_i < col_len) {
            if (jsnInsert.data.columns.indexOf(arrSeq[col_i]) !== -1) {
                arrSeq[col_i] = '';
            }
            col_i += 1;
        }

        strPK = '';
        col_i = 0;
        col_len = arrPK.length;
        while (col_i < col_len) {
            strPK += (
                strPK
                    ? '\t'
                    : ''
            );
            strPK += GS.encodeForTabDelimited(arrPK[col_i], strNullString);
            col_i += 1;
        }

        strSeq = '';
        col_i = 0;
        col_len = arrSeq.length;
        while (col_i < col_len) {
            strSeq += (
                col_i === 0
                    ? ''
                    : '\t'
            );
            if (jsnInsert.data.columns.indexOf(arrPK[col_i]) === -1) {
                strSeq += arrSeq[col_i] || '';
            }
            col_i += 1;
        }

        // combine columns and data for the websocket call
        strInsertData = strInsertColumns + '\n' + strInsertData;

        // trigger a "before_insert" event so that the page has a
        //      chance to cancel the update using event.preventDefault()
        beforeEvent = GS.triggerEvent(element, 'before_insert', {
            "schema": strSchema,
            "object": strObject,
            "insertMode": strMode,
            "insertData": jsnInsert.data
        });

        // if the user prevents the default on the "before_update"
        //      event, prevent the execution of the following update code
        if (beforeEvent.defaultPrevented) {
            return;
        }

        // the insert step is defined as a sub function because if there
        //      are multiple records involved in this update, we want to open
        //      a dialog before we continue, else we want to immediately update
        insertStep = function () {
            var insertedRecords;

            // define "insertedRecords" as empty so that we can append to it
            //      without worrying about an "undefined" at the beginning of
            //      the string
            insertedRecords = '';

            // gotta let the user know that an insert is in progress
            addLoader(element, 'data-insert', 'Inserting Data...');
            console.log(strSchema,
                strObject,
                strReturn,
                strPK,
                strSeq,
                strInsertData);
            // begin the websocket insert
            GS.requestInsertFromSocket(
                getSocket(element),
                strSchema,
                strObject,
                strReturn,
                strPK,
                strSeq,
                strInsertData,
                // transaction start callback
                function (data, error) {
                    // insert failed, remove loader and popup error dialog
                    if (error) {
                        removeLoader(element, 'data-insert', 'Insert Failed');
                        GS.webSocketErrorDialog(data);
                    }
                },

                // transaction ready for commit/rollback callback
                // "ignore" is a placeholder for "transID" and it tells JSLINT
                //      that it is an unused variable
                function (data, error, ignore, commit, rollback) {
                    if (!error) {
                        // insert made it through: commit the update
                        if (data === 'TRANSACTION COMPLETED') {
                            commit();

                        // else: we've just received a data packet containing
                        //      the inserted records as they appear in the
                        //      database
                        } else {
                            // save this data so that we can use it to update
                            //      the internal data if the insert makes it
                            //      through
                            insertedRecords += data;
                        }
                    // insert failed: popup an error and rollback
                    } else {
                        GS.webSocketErrorDialog(data);
                        rollback();
                    }
                },

                // transaction commit/rollback finished callback
                function (strAnswer, data, error) {
                    var arrRecords;
                    var i;
                    var len;

                    // the over-the-network part of the update has finished,
                    //      remove the loader now so that if there is an
                    //      execution error below, the loader wont be stuck
                    //      visible
                    removeLoader(
                        element,
                        'data-insert',
                        (
                            error
                                ? 'Insert Failed'
                                : 'Insert Successful'
                        )
                    );

                    if (!error) {
                        // insert was successfully commited: update internal
                        //      data and re-render
                        if (strAnswer === 'COMMIT') {
                            // refresh internal data by replace each internal
                            //      record that was affected with it's new
                            //      version
                            arrRecords = insertedRecords.split('\n');
                            i = 0;
                            len = arrRecords.length - 1; // the - 1 is because
                                                         //   of the extra \n at
                                                         //   the end of the
                                                         //   returned records
                            while (i < len) {
                                element.internalData
                                    .records.push(arrRecords[i]);
                                element.internalDisplay
                                    .recordHeights.push(intRecordHeight);
                                i += 1;
                            }

                            // standard after-insert behaviour
                            dataINSERTcallback(element);

                            // trigger an after insert event
                            GS.triggerEvent(element, 'after_insert', {
                                "insertMode": strMode,
                                "insertData": jsnInsert.data
                            });
                        }
                    // insert failed: popup an error
                    } else {
                        GS.webSocketErrorDialog(data);
                    }
                }
            );
        };

        // we don't want to be able to insert of there's no insert data, so if
        //      we're doing a multi record insert with no records to insert OR
        //      any kind of insert with no columns: error
        if (
            (
                strMode !== 'single-record' &&
                jsnInsert.data.values.length === 0
            ) ||
            jsnInsert.data.columns.length === 0
        ) {
            GS.msgbox(
                'Nothing To Create',
                '<center>' +
                        'Please input data to create.' +
                        '</center>',
                ['Ok']
            );

        // sometimes, the insert has already been confirmed by the user. if it
        //      has, just carry on and insert
        } else if (jsnInsert.insertConfirmed === true) {
            insertStep();

        // else, we need to confirm with the user and then create the records
        } else {
            strPostfix = (
                (
                    strMode === 'single-record' ||
                    jsnInsert.data.values.length === 1
                )
                    ? 'this record'
                    : 'these records'
            );
            GS.msgbox(
                'Are you sure...',
                '<center>' +
                        'Are you sure you want to create ' + strPostfix + '?' +
                        '</center>',
                [
                    'No',
                    'Yes'
                ],
                function (strAnswer) {
                    if (strAnswer === 'Yes') {
                        insertStep();
                    }
                }
            );
        }
    }
    function databaseWSUPDATE(element, strMode, jsnUpdate) {
        var i;
        var len;
        var pk_i;
        var pk_len;
        var lock_i;
        var lock_len;
        var col_i;
        var col_len;

        var strPostfix;
        var beforeEvent;
        var updateStep;
        var jsnCurrentData;

        var strSchema;
        var strObject;
        var strReturn;
        var strHashColumns;
        var strRecord;
        var strUpdateData;

        var intUpdateColumnIndex;
        var arrPK;
        var arrLock;
        var startingIndex;
        var arrRecordIndexes;
        //var strTempRecord;

        var strRow;
        var jsnRow;
        var cell_i;
        var cell;
        var char;

        var strRoles;
        var strColumns;
        var arrColumnNames;
        var strHashString;
        var strTemp;

        // get schema and object attributes and get the return column list
        strSchema = GS.templateWithQuerystring(
            element.getAttribute('schema') || ''
        );
        strObject = GS.templateWithQuerystring(
            element.getAttribute('object') || ''
        );

        // the return column list must be defined the same as the column list
        //      that we store the data with, so we define strReturn using the
        //      column list
        strReturn = '';
        col_i = 0;
        col_len = element.internalData.columnNames.length;
        while (col_i < col_len) {
            strReturn += (
                strReturn
                    ? '\t'
                    : ''
            );
            strReturn += element.internalData.columnNames[col_i].replace(/(\\)/g, '\\\\');
            col_i += 1;
        }

        // save the column name array for speed and easy access
        arrColumnNames = element.internalData.columnNames;

        // if single cell update: we only need to gather the update info for
        //      one record
        if (strMode === 'single-cell') {
            jsnCurrentData = {
                "columnName": jsnUpdate.data.columnName.replace(/(\\)/g, '\\\\'),
                "recordNumber": jsnUpdate.data.recordNumber,
                "oldValue": ""
            };
            strHashColumns = '';
            strUpdateData = '';
            startingIndex = '';

            // turn the updated column name into a column index so that we can
            //      fetch the old data from the data
            intUpdateColumnIndex = (
                element
                    .internalData
                    .columnNames
                    .indexOf(jsnUpdate.data.columnName)
            );

            // get the index of the record that will be updated
            startingIndex = jsnUpdate.data.recordNumber;

            // get the cell's old value so that when we emit before_update
            //      and after_update events we can provide the old data
            jsnCurrentData.oldValue = GS.decodeFromTabDelimited(
                element.internalData
                    .records[startingIndex]
                    .split('\t')[intUpdateColumnIndex]
            );

            // get primary key and lock column names into arrays so that we can
            //      use them for getting the PK and LOCK data and so that we
            //      can tell the websocket the names of the PK and LOCK columns
            if (element.getAttribute('pk')) {
                arrPK = (
                    GS.templateWithQuerystring(
                        element.getAttribute('pk') || ''
                    )
                ).split(/[\s]*,[\s]*/);
            } else {
                arrPK = [];
            }
            if (element.getAttribute('lock')) {
                arrLock = (
                    GS.templateWithQuerystring(
                        element.getAttribute('lock') || ''
                    )
                ).split(/[\s]*,[\s]*/);
            } else {
                arrLock = [];
            }

            //console.log('arrPK: ', arrPK);
            //console.log('arrLock: ', arrLock);

            // define "strHashColumns", "strRoles" and strColumns as empty so
            //      that we can append to them without worrying about an
            //      "undefined" appearing
            strHashColumns = '';
            strHashString = '';
            strRoles = '';
            strColumns = '';
            strUpdateData = '';

            // create record json so that we can easily get column values
            //      we need
            strRow = element.internalData.records[startingIndex];
            jsnRow = {};

            i = 0;
            len = strRow.length;
            cell_i = 0;
            cell = "";
            while (i < len) {
                char = strRow[i];

                if (char === "\t") {
                    jsnRow[arrColumnNames[cell_i]] =
                            GS.decodeFromTabDelimited(cell, '\\N');

                    cell = "";
                    cell_i += 1;
                } else {
                    cell += char;
                }
                i += 1;
            }
            jsnRow[arrColumnNames[cell_i]] =
                    GS.decodeFromTabDelimited(cell, '\\N');

            // build up column name/role list for websocket update headers
            //      using the PK columns and append pk values
            i = 0;
            len = arrPK.length;
            while (i < len) {
                strRoles += (
                    strRoles
                        ? '\t'
                        : ''
                );
                strRoles += 'pk';
                strColumns += (
                    strColumns
                        ? '\t'
                        : ''
                );
                strColumns += arrPK[i];
                strUpdateData += (
                    strUpdateData
                        ? '\t'
                        : ''
                );
                strUpdateData += jsnRow[arrPK[i]];
                i += 1;
            }

            // build up hash column name list for websocket update headers
            //      using the LOCK columns
            i = 0;
            len = arrLock.length;
            while (i < len) {
                strHashColumns += (
                    strHashColumns
                        ? '\t'
                        : ''
                );
                strHashColumns += arrLock[i];

                strHashString += (
                    strHashString
                        ? '\t'
                        : ''
                );
                strTemp = jsnRow[arrLock[i]];

                // the C encodes null values as empty string in the hash portion
                strHashString += (
                    strTemp === '\\N'
                        ? ''
                        : GS.encodeForTabDelimited(strTemp, '\\N')
                );
                i += 1;
            }

            if (strHashString) {
                strRoles += (
                    strRoles
                        ? '\t'
                        : ''
                );
                strRoles += 'hash';

                strColumns += (
                    strColumns
                        ? '\t'
                        : ''
                );
                strColumns += 'hash';

                strUpdateData += (
                    strUpdateData
                        ? '\t'
                        : ''
                );
                strUpdateData += GS.utfSafeMD5(strHashString).toString();
            }

            // build up column name/role list for websocket update headers
            //      using the update column
            strRoles += (
                strRoles
                    ? '\t'
                    : ''
            );
            strRoles += 'set';
            strColumns += (
                strColumns
                    ? '\t'
                    : ''
            );
            strColumns += jsnUpdate.data.columnName.replace(/(\\)/g, '\\\\');

            // append new value
            strUpdateData += (
                strUpdateData
                    ? '\t'
                    : ''
            );
            strUpdateData += GS.encodeForTabDelimited(jsnUpdate.data.newValue);

            // append an extra return to the end so just in case the C needs it
            strUpdateData += '\n';

            // prepend columns and roles
            strUpdateData = (
                strRoles + '\n' +
                strColumns + '\n' +
                strUpdateData
            );

            // add record index to the array
            arrRecordIndexes = [jsnUpdate.data.recordNumber];

        // else if multiple cell update: we have to gather the update info for
        //      a dynamic range of columns and rows
        } else if (strMode === 'cell-range') {
            // {
            //     "data": {
            //         "columns": arrColumns,
            //         "records": arrUpdateIndexes,
            //         "values": arrTranslated
            //     },
            //     "updateConfirmed": false
            // }
            jsnCurrentData = {
                "columns": "",
                "records": "",
                "oldValues": "",
                "newValues": ""
            };
            strHashColumns = '';
            strUpdateData = '';
            strColumns = '';
            strRoles = '';

            // we need to save the old data and the new data in jsnCurrentData
            //      so that when we trigger the "before_selection" event, the
            //      "before_selection" event will show all the data the
            //      developer could need about the update
            // ### NEED CODING ###

            // get primary key and lock column names into arrays so that we can
            //      use them for getting the PK and LOCK data and so that we
            //      can tell the websocket the names of the PK and LOCK columns
            if (element.getAttribute('pk')) {
                arrPK = (
                    GS.templateWithQuerystring(
                        element.getAttribute('pk') || ''
                    )
                ).split(/[\s]*,[\s]*/);
            } else {
                arrPK = [];
            }
            if (element.getAttribute('lock')) {
                arrLock = (
                    GS.templateWithQuerystring(
                        element.getAttribute('lock') || ''
                    )
                ).split(/[\s]*,[\s]*/);
            } else {
                arrLock = [];
            }

            // build up hash column list
            i = 0;
            len = arrLock.length;
            while (i < len) {
                strHashColumns += (
                    strHashColumns
                        ? '\t'
                        : ''
                );
                strHashColumns += arrLock[i];
                i += 1;
            }

            // add pk columns to the list of updated column names
            i = 0;
            len = arrPK.length;
            while (i < len) {
                strColumns += (
                    strColumns
                        ? '\t'
                        : ''
                );
                strColumns += arrPK[i];
                i += 1;
            }

            // build up column names
            i = 0;
            len = jsnUpdate.data.columns.length;
            while (i < len) {
                strColumns += (
                    strColumns
                        ? '\t'
                        : ''
                );
                strColumns += jsnUpdate.data.columns[i].replace(/(\\)/g, '\\\\');
                i += 1;
            }

            // add the hash column to the list of column names
            strColumns += '\t';
            strColumns += 'hash';

            // build up column role list
            i = 0;
            len = arrPK.length;
            while (i < len) {
                strRoles += (
                    strRoles
                        ? '\tpk'
                        : 'pk'
                );
                i += 1;
            }
            i = 0;
            len = jsnUpdate.data.columns.length;
            while (i < len) {
                strRoles += (
                    strRoles
                        ? '\tset'
                        : 'set'
                );
                i += 1;
            }
            strRoles += '\t';
            strRoles += 'hash';

            // prepend pks to update records
            // append hashes to update records
            i = 0;
            len = jsnUpdate.data.records.length;
            while (i < len) {
                strRecord = '';

                // pk data
                pk_i = 0;
                pk_len = arrPK.length;
                while (pk_i < pk_len) {
                    strRecord += (
                        strRecord
                            ? '\t'
                            : ''
                    );
                    strRecord += getCell(
                        element,
                        arrPK[pk_i],
                        jsnUpdate.data.records[i],
                        false
                    );
                    pk_i += 1;
                }

                // new record data
                strRecord += (
                    strRecord
                        ? '\t'
                        : ''
                );
                strRecord += jsnUpdate.data.values[i];

                // hash data
                strHashString = '';
                lock_i = 0;
                lock_len = arrLock.length;
                while (lock_i < lock_len) {
                    strHashString += (
                        strHashString
                            ? '\t'
                            : ''
                    );
                    strTemp = getCell(
                        element,
                        arrLock[lock_i],
                        jsnUpdate.data.records[i],
                        false
                    );

                    // the C encodes null values as empty string
                    //      in the hash portion
                    strHashString += (
                        strTemp === '\\N'
                            ? ''
                            : GS.encodeForTabDelimited(strTemp, '\\N')
                    );
                    lock_i += 1;
                }

                strRecord += (
                    strRecord
                        ? '\t'
                        : ''
                );
                strRecord += GS.utfSafeMD5(strHashString).toString();

                // add record update to update data
                strUpdateData += strRecord;
                strUpdateData += '\n';

                //console.log('Record:', strRecord);
                i += 1;
            }

            // combine the data with the columns and roles
            strUpdateData = (
                strRoles + '\n' +
                strColumns + '\n' +
                strUpdateData
            );

            arrRecordIndexes = jsnUpdate.data.records;

            //console.log('hashcolumns: ', strHashColumns);
            //console.log('    columns: ', strColumns);
            //console.log('      roles: ', strRoles);
            //console.log('       data: ', jsnUpdate);

        // else: invalid update type: throw an error
        } else {
            throw 'GS-TABLE Error: Invalid update type. Update type "' +
                    strMode + '" is not valid, please use "single-cell" ' +
                    'or "cell-range".';
        }

        // trigger a "before_update" event so that the page has a
        //      chance to cancel the update using event.preventDefault()
        beforeEvent = GS.triggerEvent(element, 'before_update', {
            "schema": strSchema,
            "object": strObject,
            "updateMode": strMode,
            "oldData": jsnCurrentData,
            "newData": jsnUpdate.data
        });

        // if the user prevents the default on the "before_update"
        //      event, prevent the execution of the following update code
        if (beforeEvent.defaultPrevented) {
            return;
        }

        // the update step is defined as a sub function because if there
        //      are multiple cells involved in this update, we want to open
        //      a dialog before we continue, else we want to immediatly
        //      update
        updateStep = function () {
            var updatedRecords;

            // define "updatedRecords" as empty so that we can append to it
            //      without worrying about an "undefined" at the beginning of
            //      the string
            updatedRecords = '';

            // gotta let the user know that an update is in progress
            addLoader(element, 'data-update', 'Updating Data...');

            // begin the websocket update
            GS.requestUpdateFromSocket(
                getSocket(element),
                strSchema,
                strObject,
                strReturn,
                strHashColumns,
                strUpdateData,
                // transaction start callback
                function (data, error) { //transID
                    // update failed: remove loader, popup an error
                    //      and reverse changes
                    if (error) {
                        removeLoader(element, 'data-update', 'Change Failed');
                        GS.webSocketErrorDialog(data);
                        //getData(element);
                    }
                },
                // transaction ready for commit/rollback callback
                // "ignore" is a placeholder for "transID" and it tells JSLINT
                //      that it is an unused variable
                function (data, error, ignore, commit, rollback) {
                    if (!error) {
                        // update made it through: commit the update
                        if (data === 'TRANSACTION COMPLETED') {
                            commit();

                        // else: we've just received a data packet containing
                        //      the updated records current version
                        } else {
                            // save this data so that we can use it to update
                            //      the internal data if the update makes it
                            //      through
                            //  ,----- data already comes back with an extra \n
                            // v
                            //updatedRecords += (
                            //    updatedRecords
                            //        ? '\n'
                            //        : ''
                            //);
                            updatedRecords += data;
                            //console.log(updatedRecords, data);
                        }
                    // update failed: popup an error, rollback and
                    //      reverse change
                    } else {
                        GS.webSocketErrorDialog(data);
                        rollback();
                        //getData(element);
                    }
                },
                // transaction commit/rollback finished callback
                function (strAnswer, data, error) {
                    var arrRecords;
                    //var i;
                    //var len;

                    // the over-the-network part of the update has finished,
                    //      remove the loader now so that if there is an
                    //      execution error below, the loader wont be stuck
                    //      visible
                    removeLoader(
                        element,
                        'data-update',
                        (
                            error
                                ? 'Change Failed'
                                : 'Change Saved'
                        )
                    );

                    if (!error) {
                        // update was successfully commited: update internal
                        //      data and re-render
                        if (strAnswer === 'COMMIT') {
                            // refresh internal data by replace each internal
                            //      record that was affected with it's new
                            //      version
                            arrRecords = updatedRecords.split('\n');
                            i = 0;
                            len = arrRecords.length - 1; // the - 1 is because
                                                         //   of the extra \n at
                                                         //   the end of the
                                                         //   returned records
                            while (i < len) {
                                element.internalData
                                    .records[arrRecordIndexes[i]] = (
                                        arrRecords[i]
                                    );
                                i += 1;
                            }

                            dataUPDATEcallback(element);

                            // trigger an after update event
                            GS.triggerEvent(element, 'after_update', {
                                "updateMode": strMode,
                                "oldData": jsnCurrentData,
                                "newData": jsnUpdate.data
                            });
                        // transaction was rolled back: reverse change
                        } else {
                            //getData(element);
                        }
                    // update failed: popup an error and reverse change
                    } else {
                        GS.webSocketErrorDialog(data);
                        //getData(element);
                    }
                }
            );
        };

        // if the update has been confirmed: carry on and update
        if (jsnUpdate.updateConfirmed === true) {
            updateStep();

        // else, we need to confirm the update
        } else {
            strPostfix = (
                (
                    !jsnUpdate.data.records ||
                    jsnUpdate.data.records.length === 1
                )
                    ? 'this record'
                    : 'these records'
            );
            GS.msgbox(
                'Are you sure...',
                '<center>' +
                        'Are you sure you want to update ' + strPostfix + '?' +
                        '</center>',
                [
                    'No',
                    'Yes'
                ],
                function (strAnswer) {
                    if (strAnswer === 'Yes') {
                        updateStep();
                    }
                }
            );
        }

        // commented out in favor of "updateConfirmed" logic
        //// if multiple cells will be updated: confirm update
        //if (strMode === 'cell-range') {
        //    GS.msgbox(
        //        'Are you sure...',
        //        '<center>' +
        //                'Are you sure you want to update these records?' +
        //                '</center>',
        //        [
        //            'No',
        //            'Yes'
        //        ],
        //        function (strAnswer) {
        //            if (strAnswer === 'Yes') {
        //                updateStep();
        //            }
        //        }
        //    );

        //// else if single cell: update immediately
        //} else if (strMode === 'single-cell') {
        //    updateStep();
        //}
    }
    function databaseWSDELETE(element, jsnDelete) {
        var i;
        var len;
        var col_i;
        var col_len;
        var strSchema;
        var strObject;
        var strPostfix;

        var beforeEvent;
        var deleteStep;

        var strPK;
        var strLock;
        var arrPK;
        var arrLock;

        var intIndex;
        var arrColumns;

        var strColumnNames;
        var strColumnRoles;
        var strHashColumns;
        var strRecordToHash;
        var strTemp;
        var strDeleteData;
        var strDeleteRecords;
        var arrDeleteRecord;
        var strRecord;

        var strNullString;

        // get schema and object attributes and get the return column list
        strSchema = GS.templateWithQuerystring(
            element.getAttribute("schema") || ""
        );
        strObject = GS.templateWithQuerystring(
            element.getAttribute("object") || ""
        );

        // we want the null string to be configurable, so we'll read the
        //      "null-string" attribute to get the null string
        // if the "null-string" attribute is present, use the contents
        //      or coalesce to empty string
        if (element.hasAttribute('null-string')) {
            strNullString = element.getAttribute('null-string') || '';

        // else, null string is left up to the encoding function
        } else {
            strNullString = undefined;
        }

        // create variables for websocket delete call

        // we need to know the primary key columns and the lock columns
        strPK = (element.getAttribute("pk") || "");
        strLock = (element.getAttribute("lock") || "");
        arrPK = strPK.split(/[\s]*,[\s]*/);
        arrLock = strLock.split(/[\s]*,[\s]*/);

        // when we start getting the data for the records we need to delete,
        //      we're going to need to be able to grab the correct columns by
        //      name, so we'll save the currently selected column list to a
        //      local variable for convenience
        arrColumns = element.internalData.columnNames;

        // initialize column name and column role variables so that we
        //      can append to them safely
        strColumnRoles = '';
        strColumnNames = '';

        // append pk columns and roles
        i = 0;
        len = arrPK.length;
        while (i < len) {
            strColumnNames += (
                strColumnNames
                    ? "\t"
                    : ""
            );
            strColumnNames += arrPK[i];
            strColumnRoles += (
                strColumnRoles
                    ? "\t"
                    : ""
            );
            strColumnRoles += "pk";
            i += 1;
        }

        // append column and role for the hash column
        strColumnNames += (
            strColumnNames
                ? "\t"
                : ""
        );
        strColumnNames += "hash";
        strColumnRoles += (
            strColumnRoles
                ? "\t"
                : ""
        );
        strColumnRoles += "hash";

        // build up hash column list
        strHashColumns = '';
        i = 0;
        len = arrLock.length;
        while (i < len) {
            strHashColumns += (
                strHashColumns
                    ? "\t"
                    : ""
            );
            strHashColumns += arrLock[i];
            i += 1;
        }

        // now that we have the metadata taken care of, gather up the records
        strDeleteRecords = '';
        i = 0;
        len = jsnDelete.recordIndexes.length;


        //// create cell array for this record
        //strRecord = element.internalData.records[i] + '\t';
        //arrDeleteRecord = [];
        //col_i = 0;
        //col_len = element.internalData.columnNames.length;//9999;
        //while (col_i < col_len) {
        //    delim = strRecord.indexOf('\t');
        //    strCell = strRecord.substring(0, delim);
        //    strRecord = strRecord.substring(delim + 1);

        //    arrDeleteRecord.push(
        //        GS.decodeFromTabDelimited(strCell, strNullString)
        //    );

        //    col_i += 1;
        //}


        while (i < len) {
            strRecord = '';
            arrDeleteRecord = element.internalData.records[
                jsnDelete.recordIndexes[i]
            ].split("\t");

            // get PK columns
            col_i = 0;
            col_len = arrPK.length;
            while (col_i < col_len) {
                // get column index for this current PK
                intIndex = arrColumns.indexOf(arrPK[col_i]);

                // append cell to current delete record
                strRecord += (
                    strRecord
                        ? "\t"
                        : ""
                );
                strRecord += GS.encodeForTabDelimited(
                    arrDeleteRecord[intIndex],
                    strNullString
                );

                col_i += 1;
            }

            // get hash columns
            strRecordToHash = "";
            col_i = 0;
            col_len = arrLock.length;
            while (col_i < col_len) {
                //// get column index for this current hash column
                //intIndex = arrColumns.indexOf(arrLock[col_i]);

                // append cell to current hash record
                strRecordToHash += (
                    strRecordToHash
                        ? "\t"
                        : ""
                );
                //strTemp = arrDeleteRecord[intIndex];
                strTemp = getCell(
                                element,
                                arrLock[col_i],
                                jsnDelete.recordIndexes[i],
                                false
                            );

                // I saw this in the code I copied while making this:
                //      "I believe that this needs to
                //          use the null-string instead of 'NULL'"
                strRecordToHash += (
                    strTemp === "\\N"
                        ? ""
                        : strTemp
                );
                console.log(strTemp, strRecordToHash);

                col_i += 1;
            }

            // append record to deleteData
            strDeleteRecords += strRecord;
            strDeleteRecords += (
                strRecord
                    ? '\t'
                    : ''
            );
            strDeleteRecords += GS.utfSafeMD5(strRecordToHash).toString();
            strDeleteRecords += '\n';

            i += 1;
        }

        // combine the metadata with the delete records
        strDeleteData = (
            strColumnRoles + '\n' +
            strColumnNames + '\n' +
            strDeleteRecords
        );

        // trigger a "before_update" event so that the page has a
        //      chance to cancel the update using event.preventDefault()
        beforeEvent = GS.triggerEvent(element, 'before_delete', {
            "schema": strSchema,
            "object": strObject,
            "recordIndexes": jsnDelete.recordIndexes,
            "deleteConfirmed": jsnDelete.deleteConfirmed,
            "strColumnRoles": strColumnRoles,
            "strColumnNames": strColumnNames,
            "strDeleteRecords": strDeleteRecords
        });

        // if the user prevents the default on the "before_update"
        //      event, prevent the execution of the following update code
        if (beforeEvent.defaultPrevented) {
            return;
        }

        // the delete step is defined as a sub function because we only
        //      want to do the delete under certain circumstances
        deleteStep = function () {
            // gotta let the user know that an update is in progress
            addLoader(element, 'data-delete', 'Deleting Data...');

            // begin the websocket update
            GS.requestDeleteFromSocket(
                getSocket(element),
                strSchema,
                strObject,
                strHashColumns,
                strDeleteData,
                // transaction start callback
                function (data, error) { //transID
                    // delete failed: remove loader, popup an error
                    if (error) {
                        removeLoader(element, 'data-delete', 'Delete Failed');
                        GS.webSocketErrorDialog(data);
                    }
                },
                // transaction ready for commit/rollback callback
                // "ignore" is a placeholder for "transID" and it tells JSLINT
                //      that it is an unused variable
                function (data, error, ignore, commit, rollback) {
                    if (!error) {
                        // delete made it through: commit the delete
                        if (data === 'TRANSACTION COMPLETED') {
                            commit();
                        }
                    // delete failed: popup an error, rollback
                    } else {
                        GS.webSocketErrorDialog(data);
                        rollback();
                    }
                },
                // transaction commit/rollback finished callback
                function (strAnswer, data, error) {
                    var arrRecords;
                    var arrRecordHeights;

                    // the over-the-network part of the delete has finished,
                    //      remove the loader now so that if there is an
                    //      execution error below, the loader wont be stuck
                    //      visible
                    removeLoader(
                        element,
                        'data-delete',
                        (
                            error
                                ? 'Delete Failed'
                                : 'Delete Successful'
                        )
                    );

                    if (!error) {
                        // delete was successfully commited: update internal
                        //      data and re-render
                        if (strAnswer === 'COMMIT') {
                            // now that the delete was successful, we'll
                            //      recreate the record and record height
                            //      arrays and skip the records at the indexes
                            //      that were deleted
                            // Some of you may be asking:
                            //      "why doesn't he just use .splice()?".
                            //      That, young grasshopper, is because through
                            //      my travels I've found .splice() to be
                            //      significantly slower than simply rebuilding
                            //      the array. This is what I do in Postage's
                            //      tree code.
                            arrRecords = [];
                            arrRecordHeights = [];

                            i = 0;
                            len = element.internalData.records.length;
                            while (i < len) {
                                if (jsnDelete.recordIndexes.indexOf(i) === -1) {
                                    arrRecords.push(
                                        element.internalData.records[i]
                                    );
                                    arrRecordHeights.push(
                                        element.internalDisplay.recordHeights[i]
                                    );
                                }
                                i += 1;
                            }

                            // set the internal record and record heights to
                            //      the newly pruned arrays
                            element
                                .internalData
                                .records = arrRecords;
                            element
                                .internalDisplay
                                .recordHeights = arrRecordHeights;

                            // standard after delete procedure
                            dataDELETEcallback(element);

                            // trigger an after delete event
                            GS.triggerEvent(element, 'after_delete', {
                                "schema": strSchema,
                                "object": strObject,
                                "recordIndexes": jsnDelete.recordIndexes,
                                "strColumnRoles": strColumnRoles,
                                "strColumnNames": strColumnNames,
                                "strDeleteRecords": strDeleteRecords
                            });
                        }
                    // delete failed: popup an error
                    } else {
                        GS.webSocketErrorDialog(data);
                    }
                }
            );
        };

        // if no records have been sent to delete: error
        if (jsnDelete.recordIndexes.length === 0) {
            GS.msgbox(
                'No Records To Delete',
                '<center>' +
                        'Please choose a record to delete.' +
                        '</center>',
                ['Ok']
            );

        // else if the delete has been confirmed: carry on and delete
        } else if (jsnDelete.deleteConfirmed === true) {
            deleteStep();

        // else, we need to confirm the delete
        } else {
            strPostfix = (
                jsnDelete.recordIndexes.length === 1
                    ? 'this record'
                    : 'these records'
            );
            GS.msgbox(
                'Are you sure...',
                '<center>' +
                        'Are you sure you want to delete ' + strPostfix + '?' +
                        '</center>',
                [
                    'No',
                    'Yes'
                ],
                function (strAnswer) {
                    if (strAnswer === 'Yes') {
                        deleteStep();
                    }
                }
            );
        }
    }

    // sometimes, you dont want to save to the database, that's what these
    //      internal SELECT, INSERT, UPDATE and DELETE functions are for

    function internalSELECT(element) {
        var templateElement;
        var arrColumns;

        // on the first load, the GS-TABLE doesn't know what the column names
        //      are. so, here we'll scan the templates to come up with a column
        //      list
        if (element.internalData.columnNames.length === 0) {
            templateElement = document.createElement('template');

            // we'll check the insertDialog template for column names
            templateElement.innerHTML = element.internalTemplates.insertDialog;
            arrColumns = templateGetColumnList(templateElement);
            arrColumns.forEach(function (strColumn) {
                if (
                    element.internalData.columnNames.indexOf(strColumn) === -1
                ) {
                    element.internalData.columnNames.push(strColumn);
                    element.internalData.columnTypes.push('text');
                    element.internalData.columnFilterStatuses.push('on');
                    element.internalData.columnFilters.push([]);
                    element.internalData.columnListFilters.push({});
                    element.internalData.columnOrders.push('neutral');
                }
            });

            // we'll check the insertRecord template for column names
            templateElement.innerHTML = element.internalTemplates.insertRecord;
            arrColumns = templateGetColumnList(templateElement);
            arrColumns.forEach(function (strColumn) {
                if (
                    element.internalData.columnNames.indexOf(strColumn) === -1
                ) {
                    element.internalData.columnNames.push(strColumn);
                    element.internalData.columnTypes.push('text');
                    element.internalData.columnFilterStatuses.push('on');
                    element.internalData.columnFilters.push([]);
                    element.internalData.columnListFilters.push({});
                    element.internalData.columnOrders.push('neutral');
                }
            });

            // we'll check the record template for column names
            templateElement.innerHTML = element.internalTemplates.record;
            arrColumns = templateGetColumnList(templateElement);
            arrColumns.forEach(function (strColumn) {
                if (
                    element.internalData.columnNames.indexOf(strColumn) === -1
                ) {
                    element.internalData.columnNames.push(strColumn);
                    element.internalData.columnTypes.push('text');
                    element.internalData.columnFilterStatuses.push('on');
                    element.internalData.columnFilters.push([]);
                    element.internalData.columnListFilters.push({});
                    element.internalData.columnOrders.push('neutral');
                }
            });
        }

        // we need to re-render and all that jazz
        dataSELECTcallback(element);
    }

    function internalINSERT(element, strMode, jsnInsert) {
        var beforeEvent;
        var insertStep;
        var strPostfix;
        var strNullString;
        var intRecordHeight;
        var strRecord;
        var arrRecords;
        var arrRecord;
        var arrColumns;
        var strColumn;
        var strValue;
        var index;
        var i;
        var len;
        //var rec_i;
        //var rec_len;
        var col_i;
        var col_len;

        //console.log(element, strMode, jsnInsert); //multi-record

        // we want the null string to be configurable, so we'll read the
        //      "null-string" attribute to get the null string
        // if the "null-string" attribute is present, use the contents
        //      or coalesce to empty string
        if (element.hasAttribute('null-string')) {
            strNullString = element.getAttribute('null-string') || '';

        // else, null string is left up to the encoding function
        } else {
            strNullString = undefined;
        }

        // we need to create records with the default record height attached to
        //      them, so we'll use the "default-record-height" attribute
        intRecordHeight = (
            parseInt(element.getAttribute('default-record-height'), 10) ||
            intDefaultRecordHeight
        );

        // trigger a "before_insert" event so that the page has a
        //      chance to cancel the update using event.preventDefault()
        beforeEvent = GS.triggerEvent(element, 'before_insert', {
            "insertMode": strMode,
            "insertData": jsnInsert.data
        });

        // if the user prevents the default on the "before_update"
        //      event, prevent the execution of the following update code
        if (beforeEvent.defaultPrevented) {
            return;
        }

        // sometimes, we need to call the insert only after a confirmation.
        //      other times, we insert immediately. separating the insert
        //      code into a sub-function allows us to call it at different
        //      times under different circumstances
        insertStep = function () {
            // gotta let the user know that an insert is in progress
            addLoader(element, 'data-insert', 'Inserting Data...');

            // if single record insert:
            if (strMode === "single-record") {
                /*
                jsnInsert = {
                    "data": {
                        "addin": {
                            "link_column": "columnname4",
                            "link_value": "value"
                        },
                        "columns": [
                            "columnname1",
                            "columnname2",
                            "columnname3"
                            ...
                        ],
                        "values": {
                            "columnname1": "value",
                            "columnname2": "value",
                            "columnname3": "value"
                            ...
                        }
                    },
                    "insertConfirmed": boolean
                }
                */

                // loop through internal column list, build up new record
                //      ignoring columns that don't exist and adding nulls
                //      for columns that exist but weren't filled in
                strRecord = "";
                arrColumns = element.internalData.columnNames;
                i = 0;
                len = arrColumns.length;
                while (i < len) {
                    strColumn = arrColumns[i];

                    // separate columns with tab characters
                    if (i > 0) {
                        strRecord += "\t";
                    }

                    // get value for column
                    strValue = jsnInsert.data.values[strColumn];

                    // if column is defined in insert values
                    if (strValue !== undefined) {
                        strRecord += GS.encodeForTabDelimited(
                            strValue,
                            strNullString
                        );

                    // if column is defined in addin values
                    } else if (jsnInsert.data.addin.link_column === strColumn) {
                        strRecord += GS.encodeForTabDelimited(
                            jsnInsert.data.addin.link_value,
                            strNullString
                        );

                    // else, null the cell
                    } else {
                        strRecord += '\\N';
                    }

                    i += 1;
                }

                // append record text and record height to internal variables
                element.internalData.records.push(strRecord);
                element.internalDisplay.recordHeights.push(intRecordHeight);

            // else if multi record insert:
            } else if (strMode === "multi-record") {
                /*
                jsnInsert = {
                    "data": {
                        "addin": {
                            "link_column": "columnname4",
                            "link_value": "value"
                        },
                        "columns": [
                            "columnname1",
                            "columnname2"
                            ...
                        ],
                        "values": [
                            "value1\tvalue1",
                            "value2\tvalue2",
                            "value3\tvalue3"
                            ...
                        ]
                    },
                    "insertConfirmed": boolean
                }
                */

                // loop through internal column list, build up new record
                //      ignoring columns that don't exist and adding nulls
                //      for columns that exist but weren't filled in
                arrRecords = [];
                arrColumns = element.internalData.columnNames;
                // ### NEED CODING ###
                i = 0;
                len = jsnInsert.data.values.length;
                while (i < len) {

                    // split record
                    strRecord = jsnInsert.data.values[i];
                    arrRecord = strRecord.split('\t');
                    //rec_i = 0;
                    //rec_len = strRecord.length;
                    //while (rec_i < rec_len) {
                    //    rec_i += 1;
                    //}

                    // create full records
                    strRecord = "";
                    col_i = 0;
                    col_len = arrColumns.length;
                    while (col_i < col_len) {
                        strColumn = arrColumns[col_i];
                        index = jsnInsert.data.columns.indexOf(strColumn);
                        strValue = arrRecord[index];

                        // separate columns with tab characters
                        if (col_i > 0) {
                            strRecord += "\t";
                        }

                        // get value for current column
                        if (strValue) {
                            strRecord += arrRecord[index];

                        // if column is defined in addin values
                        } else if (
                            jsnInsert.data.addin.link_column === strColumn
                        ) {
                            strRecord += GS.encodeForTabDelimited(
                                jsnInsert.data.addin.link_value,
                                strNullString
                            );

                        // else, null the cell
                        } else {
                            strRecord += '\\N';
                        }

                        col_i += 1;
                    }

                    // push new record to expanded record list
                    arrRecords.push(strRecord);

                    i += 1;
                }

                // append record text and record height to internal variables
                i = 0;
                len = arrRecords.length;
                while (i < len) {
                    element.internalData.records.push(arrRecords[i]);
                    element.internalDisplay.recordHeights.push(intRecordHeight);
                    i += 1;
                }
            }

            // we need to let the user know the insert is finished
            removeLoader(element, 'data-insert', 'New Record Saved');

            // standard after-insert behaviour
            dataINSERTcallback(element);

            // trigger an after insert event
            GS.triggerEvent(element, 'after_insert', {
                "insertMode": strMode,
                "insertData": jsnInsert.data
            });
        };

        // we don't want to be able to insert of there's no insert data, so if
        //      we're doing a multi record insert with no records to insert OR
        //      any kind of insert with no columns: error
        if (
            (
                strMode !== 'single-record' &&
                jsnInsert.data.values.length === 0
            ) ||
            jsnInsert.data.columns.length === 0
        ) {
            GS.msgbox(
                'Nothing To Create',
                '<center>' +
                        'Please input data to create.' +
                        '</center>',
                ['Ok']
            );

        // sometimes, the insert has already been confirmed by the user. if it
        //      has, just carry on and insert
        } else if (jsnInsert.insertConfirmed === true) {
            insertStep();

        // else, we need to confirm with the user and then create the records
        } else {
            strPostfix = (
                (
                    strMode === 'single-record' ||
                    jsnInsert.data.values.length === 1
                )
                    ? 'this record'
                    : 'these records'
            );
            GS.msgbox(
                'Are you sure...',
                '<center>' +
                        'Are you sure you want to create ' + strPostfix + '?' +
                        '</center>',
                [
                    'No',
                    'Yes'
                ],
                function (strAnswer) {
                    if (strAnswer === 'Yes') {
                        insertStep();
                    }
                }
            );
        }
    }
    function internalUPDATE(element, strMode, jsnUpdate) {
        var i;
        var len;
        var row_i;
        var row_len;

        var strPostfix;
        var beforeEvent;
        var updateStep;
        var jsnCurrentData;

        var intUpdateColumnIndex;
        var arrUpdateColumnIndexes;
        var startingIndex;
        var arrUpdatePaste;

        var update_i;
        var cell_i;
        var cell;
        var char;

        var strOldRow;
        var strNewRow;
        var arrRecordIndexes;
        var arrRecordReplacements;

        //console.log(element, strMode, jsnUpdate);

        // we need to be able to have unupdatable columns
        // ### NEED CODING ###

        // we need to be able to use the data from a header-child relationship
        // ### NEED CODING ###

        // this function updates internal data and then re-renders. essentially,
        //      we'll be masking the new data over the old data.

        // if single cell update: we only need to gather the update info for
        //      one record
        if (strMode === 'single-cell') {
            jsnCurrentData = {
                "columnName": jsnUpdate.data.columnName,
                "recordNumber": jsnUpdate.data.recordNumber,
                "oldValue": ""
            };

            // turn the updated column name into a column index so that we can
            //      fetch the old data from the data
            intUpdateColumnIndex = (
                element
                    .internalData
                    .columnNames
                    .indexOf(jsnUpdate.data.columnName)
            );

            // get the index of the record that will be updated
            startingIndex = jsnUpdate.data.recordNumber;

            // get the old record and get the new record variable ready for
            //      masking
            strOldRow = element.internalData.records[startingIndex];
            strNewRow = '';

            // loop through each character of the record and begin masking
            i = 0;
            len = strOldRow.length;
            cell_i = 0;
            cell = "";
            while (i < len) {
                char = strOldRow[i];

                // if the cell end has been reached
                if (char === "\t" || i === (len - 1)) {
                    // we don't want to chop the last character off
                    if (i === (len - 1)) {
                        cell += char;
                    }

                    // if the cell number is the cell we want to replace,
                    //      insert new value instead of the old value
                    if (cell_i === intUpdateColumnIndex) {
                        strNewRow += GS.encodeForTabDelimited(
                            jsnUpdate.data.newValue
                        );

                        // save the old value for the developer in the
                        //      "before_update" and "after_update" events
                        jsnCurrentData.oldValue = cell;

                    // else, maintain old data
                    } else {
                        strNewRow += cell;
                    }

                    cell = "";
                    cell_i += 1;

                // else, keep building up the cell variable
                } else {
                    cell += char;
                }

                // we want to maintain the tab characters
                if (char === "\t") {
                    strNewRow += '\t';
                }

                i += 1;
            }

            // regardless of single or multi-record updates, we use the same
            //      code to make the change in the internal data. this code
            //      needs the record indexes of the update records and the new
            //      version of each of the records

            // add record index to the updated record list
            arrRecordIndexes = [startingIndex];

            // add new record to updated data array
            arrRecordReplacements = [strNewRow];

        // else if multiple cell update: we have to gather the update info for
        //      a dynamic range of columns and rows
        } else if (strMode === 'cell-range') {
            // {
            //     "data": {
            //         "columns": arrColumns,
            //         "records": arrUpdateIndexes,
            //         "values": arrTranslated
            //     },
            //     "updateConfirmed": false
            // }
            jsnCurrentData = {
                "columns": "",
                "records": "",
                "oldValues": "",
                "newValues": ""
            };

            // we need to save the old data and the new data in jsnCurrentData
            //      so that when we trigger the "before_selection" event, the
            //      "before_selection" event will show all the data the
            //      developer could need about the update
            // ### NEED CODING ###

            // we need to know the indexes of the columns we're updating
            arrUpdateColumnIndexes = [];
            i = 0;
            len = jsnUpdate.data.columns.length;
            while (i < len) {
                arrUpdateColumnIndexes.push(
                    element.internalData.columnNames
                        .indexOf(jsnUpdate.data.columns[i])
                );

                i += 1;
            }

            // loop through records and mask over old values for each
            i = 0;
            len = jsnUpdate.data.records.length;
            arrRecordReplacements = [];
            while (i < len) {
                // get the old record and get the new record variable ready for
                //      masking
                strOldRow = element.internalData.records[
                    jsnUpdate.data.records[i]
                ];
                strNewRow = '';
                arrUpdatePaste = jsnUpdate.data.values[i].split('\t');
                update_i = 0;

                // loop through each character of the record and begin masking
                row_i = 0;
                row_len = strOldRow.length;
                cell_i = 0;
                cell = "";
                while (row_i < row_len) {
                    char = strOldRow[row_i];

                    // if the cell end has been reached
                    if (char === "\t" || row_i === (row_len - 1)) {
                        // if the cell number is the cell we want to replace,
                        //      insert new value instead of the old value
                        if (arrUpdateColumnIndexes.indexOf(cell_i) > -1) {
                            strNewRow += arrUpdatePaste[update_i] || '\\N';
                            update_i += 1;

                        // else, maintain old data
                        } else {
                            strNewRow += cell;
                        }

                        cell = "";
                        cell_i += 1;

                    // else, keep building up the cell variable
                    } else {
                        cell += char;
                    }

                    // we want to maintain the tab characters
                    if (char === "\t") {
                        strNewRow += '\t';
                    }

                    row_i += 1;
                }

                //console.log(' strOldRow: ', strOldRow);
                //console.log(' strNewRow: ', strNewRow);

                arrRecordReplacements.push(strNewRow);

                i += 1;
            }

            arrRecordIndexes = jsnUpdate.data.records;

            //console.log('arrUpdateColumnIndexes: ', arrUpdateColumnIndexes);
            //console.log(' arrRecordReplacements: ', arrRecordReplacements);
            //console.log('      arrRecordIndexes: ', arrRecordIndexes);

        // else: invalid update type: throw an error
        } else {
            throw 'GS-TABLE Error: Invalid update type. Update type "' +
                    strMode + '" is not valid, please use "single-cell" ' +
                    'or "cell-range".';
        }

        // trigger a "before_update" event so that the page has a
        //      chance to cancel the update using event.preventDefault()
        beforeEvent = GS.triggerEvent(element, 'before_update', {
            "updateMode": strMode,
            "oldData": jsnCurrentData,
            "newData": jsnUpdate.data
        });

        // if the user prevents the default on the "before_update"
        //      event, prevent the execution of the following update code
        if (beforeEvent.defaultPrevented) {
            return;
        }

        // the update step is defined as a sub function because if there
        //      are multiple cells involved in this update, we want to open
        //      a dialog before we continue, else we want to immediatly
        //      update
        updateStep = function () {
            // gotta let the user know that an update is in progress
            addLoader(element, 'data-update', 'Updating Data...');

            // utilize the updated record and updated record index arrays to
            //      replace the old data with the new data
            i = 0;
            len = arrRecordIndexes.length;
            while (i < len) {
                element.internalData.records[
                    arrRecordIndexes[i]
                ] = (
                    arrRecordReplacements[i]
                );

                i += 1;
            }

            // re-render and do whatever standard after-update items need
            //      to be done
            dataUPDATEcallback(element);

            // trigger an after update event
            GS.triggerEvent(element, 'after_update', {
                "updateMode": strMode,
                "oldData": jsnCurrentData,
                "newData": jsnUpdate.data
            });

            // the update has finished, let the user know and remove the loader
            removeLoader(element, 'data-update', 'Change Saved');
        };

        // if the update has been confirmed: carry on and update
        if (jsnUpdate.updateConfirmed === true) {
            updateStep();

        // else, we need to confirm the update
        } else {
            strPostfix = (
                (
                    !jsnUpdate.data.records ||
                    jsnUpdate.data.records.length === 1
                )
                    ? 'this record'
                    : 'these records'
            );
            GS.msgbox(
                'Are you sure...',
                '<center>' +
                        'Are you sure you want to update ' + strPostfix + '?' +
                        '</center>',
                [
                    'No',
                    'Yes'
                ],
                function (strAnswer) {
                    if (strAnswer === 'Yes') {
                        updateStep();
                    }
                }
            );
        }
    }
    function internalDELETE(element, jsnDelete) {
        var strPostfix;

        var beforeEvent;
        var deleteStep;

        // trigger a "before_update" event so that the page has a
        //      chance to cancel the update using event.preventDefault()
        beforeEvent = GS.triggerEvent(element, 'before_delete', {
            "recordIndexes": jsnDelete.recordIndexes,
            "deleteConfirmed": jsnDelete.deleteConfirmed
        });

        // if the user prevents the default on the "before_update"
        //      event, prevent the execution of the following update code
        if (beforeEvent.defaultPrevented) {
            return;
        }

        // the delete step is defined as a sub function because we only
        //      want to do the delete under certain circumstances
        deleteStep = function () {
            var arrRecords;
            var arrRecordHeights;
            var i;
            var len;

            // gotta let the user know that an update is in progress
            addLoader(element, 'data-delete', 'Deleting Data...');

            // now that the delete was confirmed, we'll
            //      recreate the record and record height
            //      arrays and skip the records at the indexes
            //      that were deleted
            // Some of you may be asking:
            //      "why doesn't he just use .splice()?".
            //      That, young grasshopper, is because through
            //      my travels I've found .splice() to be
            //      significantly slower than simply rebuilding
            //      the array. This is what I do in Postage's
            //      tree code.
            arrRecords = [];
            arrRecordHeights = [];

            i = 0;
            len = element.internalData.records.length;
            while (i < len) {
                if (jsnDelete.recordIndexes.indexOf(i) === -1) {
                    arrRecords.push(
                        element.internalData.records[i]
                    );
                    arrRecordHeights.push(
                        element.internalDisplay.recordHeights[i]
                    );
                }
                i += 1;
            }

            // set the internal record and record heights to
            //      the newly pruned arrays
            element.internalData.records = arrRecords;
            element.internalDisplay.recordHeights = arrRecordHeights;

            // gotta let the user know that we finished
            removeLoader(element, 'data-delete', 'Delete Successful');

            // standard after delete procedure
            dataDELETEcallback(element);

            // trigger an after delete event
            GS.triggerEvent(element, 'after_delete', {
                "recordIndexes": jsnDelete.recordIndexes
            });
        };

        // if no records have been sent to delete: error
        if (jsnDelete.recordIndexes.length === 0) {
            GS.msgbox(
                'No Records To Delete',
                '<center>' +
                        'Please choose a record to delete.' +
                        '</center>',
                ['Ok']
            );

        // else if the delete has been confirmed: carry on and delete
        } else if (jsnDelete.deleteConfirmed === true) {
            deleteStep();

        // else, we need to confirm the delete
        } else {
            strPostfix = (
                jsnDelete.recordIndexes.length === 1
                    ? 'this record'
                    : 'these records'
            );
            GS.msgbox(
                'Are you sure...',
                '<center>' +
                        'Are you sure you want to delete ' + strPostfix + '?' +
                        '</center>',
                [
                    'No',
                    'Yes'
                ],
                function (strAnswer) {
                    if (strAnswer === 'Yes') {
                        deleteStep();
                    }
                }
            );
        }
    }



    function databaseWSSELECTcolumnUnique(
        element,
        uniqueFilterElement,
        valueListElement,
        strColumn
    ) {
        var socket = getSocket(element);
        var strSchema;
        var strObject;
        var strWhere;

        strSchema = GS.templateWithQuerystring(
            element.getAttribute('schema') || ''
        );
        strObject = GS.templateWithQuerystring(
            element.getAttribute('object') || ''
        );
        strWhere = element.getAttribute('where') || '1=1';
        // This way other filters apply to the current filter
        // TODO: Michael is this correct?
        // I think that the current filter that we are choosing should
        //      not be in this select

        var strSrc = (
            ml(function () {/*
                SELECT count(*) AS count
                     , COALESCE(
                            NULLIF(CAST("{{COLUMN}}" AS text), ''),
                            '(blanks)'
                       ) AS unique_value
                  FROM {{SCHEMA}}.{{OBJECT}}
                  WHERE {{WHERE}}
              GROUP BY NULLIF(CAST("{{COLUMN}}" AS text), '')
              ORDER BY NULLIF(CAST("{{COLUMN}}" AS text), '') ASC NULLS FIRST
            */
            })
                .replace(/\{\{WHERE\}\}/gi, strWhere)
                .replace(/\{\{COLUMN\}\}/gi, strColumn)
                .replace(/\{\{SCHEMA\}\}/gi, strSchema)
                .replace(/\{\{OBJECT\}\}/gi, strObject)
        );

        var bolUncheckedFound = false;
        var arrData;
        var jsnFilter;

        arrData = [
            '' // placeholder for "Select All" record
        ];
        jsnFilter = (
            element.internalData.columnListFilters[
                element.internalData.columnNames.indexOf(strColumn)
            ]
        );

        GS.requestArbitrarySelectFromSocket(
            socket,
            '(' + strSrc + ') unique_list',
            '',
            '',
            '',
            '',
            function (data, error) {
                var i;
                //var len;
                var tableElement;
                //var strCheck;
                var index;
                var strValue;
                //var strType;
                var strMessage = data.strMessage;
                var strRecord;
                //var arrRecords = [];
                var arrRecord = [];

                if (!error && data.strMessage === 'TRANSACTION COMPLETED') {
                    // we want the select all to only be checked if all
                    //      values are checked
                    if (bolUncheckedFound) {
                        arrData[0] = '0\t\tSelect All';
                    } else {
                        arrData[0] = '-1\t\tSelect All';
                    }

                    // we need to make the filter list container visible
                    uniqueFilterElement.removeAttribute('hidden');

                    valueListElement.addEventListener(
                        'initialized',
                        function () {
                            // we need to fill our new gs-table.
                            tableElement = valueListElement.children[0];

                            tableElement.internalData.records = arrData;
                            tableElement.internalData.columnNames = [
                                'active', 'count', 'value'
                            ];
                            tableElement.internalData.columnTypes = [
                                'text', 'text', 'text'
                            ];
                            tableElement.internalData.columnFilterStatuses = [
                                'on', 'on', 'on'
                            ];
                            tableElement.internalData.columnFilters = [
                                [], [], []
                            ];
                            tableElement.internalData.columnListFilters = [
                                {}, {}, {}
                            ];
                            tableElement.internalData.columnOrders = [
                                'neutral', 'neutral', 'neutral'
                            ];
                            tableElement.internalDisplay.columnWidths = [
                                27,
                                (valueListElement.clientWidth - 80),
                                49
                            ];

                            // refresh causes the record heights to be
                            //      calculated
                            tableElement.refresh();
                        }
                    );

                    // we need to create a gs-table to hold the unique list
                    //      because we need a local, updatable, wicked-fast
                    //      component to contain this potentially very long
                    //      list.
                    valueListElement.innerHTML = ml(function () {/*
    <gs-table style="width: 100%; height: 100%;"
                no-record-selector
                no-x-overscroll
                no-y-overscroll
                copy-header="always">
        <template for="data-record">
            <gs-cell>
                <label>
                    <gs-checkbox column="active" mini></gs-checkbox>
                </label>
            </gs-cell>
            <gs-cell>
                {{? row.value === 'Select All' || row.value === '(blanks)' }}
                    <span class="gs-table-text-grey">
                        {{! row.value }}
                    </span>
                {{??}}
                    <label>{{! row.value }}</label>
                {{?}}
            </gs-cell>
            <gs-cell>
                <center class="gs-table-text-grey">
                    {{! row.count }}
                </center>
            </gs-cell>
        </template>
        <template for="copy">
            <gs-cell header="Include?">{{? row.active==='-1' }}X{{?}}</gs-cell>
            <gs-cell header="Value">{{! row.value }} </gs-cell>
            <gs-cell header="Occurences">{{! row.count }}</gs-cell>
        </template>
    </gs-table>
                    */
                    });

                    tableElement.addEventListener(
                        'before_update',
                        function (event) {
                            var rec_i;
                            var rec_len;
                            var arrRecords;

                            // the only data change we make is to update the
                            //      checkbox. because of the limited nature of
                            //      the updates (0 to -1 and vice versa), we
                            //      can optimize two things: no need to encode
                            //      the update value and we're always replacing
                            //      everything before the first tab character.
                            var replaceValue = function (strRecord, strValue) {
                                return (
                                    strValue +
                                    strRecord.substring(
                                        strRecord.indexOf('\t')
                                    )
                                );
                            };

                            // when the user checks "Select All":
                            //      all checkboxes must be set to -1
                            if (
                                event.newData.columnName === 'active' &&
                                event.newData.recordNumber === 0 &&
                                event.newData.newValue === '-1'
                            ) {
                                //console.log('1***');
                                arrRecords = tableElement.internalData.records;
                                rec_i = 0;
                                rec_len = arrRecords.length;
                                while (rec_i < rec_len) {
                                    arrRecords[rec_i] = (
                                        replaceValue(arrRecords[rec_i], '-1')
                                    );
                                    rec_i += 1;
                                }

                            // when the user unchecks "Select All":
                            //      all checkboxes must be set to 0
                            } else if (
                                event.newData.columnName === 'active' &&
                                event.newData.recordNumber === 0 &&
                                event.newData.newValue === '0'
                            ) {
                                //console.log('2***');
                                arrRecords = tableElement.internalData.records;
                                rec_i = 0;
                                rec_len = arrRecords.length;
                                while (rec_i < rec_len) {
                                    arrRecords[rec_i] = (
                                        replaceValue(arrRecords[rec_i], '0')
                                    );
                                    rec_i += 1;
                                }

                            // when the user unchecks a checkbox:
                            //      the "Select All" checkbox must be set to 0
                            } else if (
                                event.newData.columnName === 'active' &&
                                event.newData.recordNumber > 0 &&
                                event.newData.newValue === '0'
                            ) {
                                //console.log('3***');
                                tableElement.internalData.records[0] = (
                                    replaceValue(
                                        tableElement.internalData.records[0],
                                        '0'
                                    )
                                );
                            }

                            //console.log(event);
                            //console.log(
                            //    'column: ' + event.newData.columnName,
                            //    'recordNumber: ' + event.newData.recordNumber,
                            //    'newValue: ' + event.newData.newValue
                            //);
                        }
                    );

                } else if (!error) {

                    i = 0;
                    while (i < 15) {
                        index = strMessage.indexOf('\n');
                        strRecord = strMessage.substring(0, index);
                        strMessage = strMessage.substring(index + 1);

                        // first load
                        if (strRecord !== '' || strMessage !== '') {
                            arrRecord = strRecord.split('\t');
                            strValue = arrRecord[1];

                            if (!jsnFilter || !jsnFilter.type) {
                                arrData.push('-1\t' + strRecord);

                            // nothing
                            } else if (
                                jsnFilter.type === 'inclusion' &&
                                jsnFilter.values.length === 0
                            ) {
                                if (
                                    jsnFilter.blanks &&
                                    strValue === '(blanks)'
                                ) {
                                    arrData.push('-1\t' + strRecord);

                                } else if (
                                    jsnFilter.blanks === false &&
                                    strValue === '(blanks)'
                                ) {
                                    arrData.push('0\t' + strRecord);
                                    bolUncheckedFound = true;

                                } else {
                                    arrData.push('0\t' + strRecord);
                                    bolUncheckedFound = true;
                                }

                            // everything
                            } else if (
                                jsnFilter.type === 'exclusion' &&
                                jsnFilter.values.length === 0
                            ) {
                                if (
                                    jsnFilter.blanks &&
                                    strValue === '(blanks)'
                                ) {
                                    arrData.push('-1\t' + strRecord);

                                } else if (
                                    jsnFilter.blanks === false &&
                                    strValue === '(blanks)'
                                ) {
                                    arrData.push('0\t' + strRecord);
                                    bolUncheckedFound = true;

                                } else {
                                    arrData.push('-1\t' + strRecord);
                                }

                            } else if (
                                jsnFilter &&
                                jsnFilter.type === 'inclusion'
                            ) {
                                if (
                                    jsnFilter.blanks &&
                                    strValue === '(blanks)'
                                ) {
                                    arrData.push('-1\t' + strRecord);

                                } else if (
                                    jsnFilter.blanks === false &&
                                    strValue === '(blanks)'
                                ) {
                                    arrData.push('0\t' + strRecord);
                                    bolUncheckedFound = true;

                                } else if (
                                    jsnFilter.values
                                        .indexOf(strValue) !== -1
                                ) {
                                    arrData.push('-1\t' + strRecord);

                                } else {
                                    arrData.push('0\t' + strRecord);
                                    bolUncheckedFound = true;
                                }

                            } else if (
                                jsnFilter &&
                                jsnFilter.type === 'exclusion'
                            ) {
                                if (
                                    jsnFilter.blanks &&
                                    strValue === '(blanks)'
                                ) {
                                    arrData.push('-1\t' + strRecord);

                                } else if (
                                    jsnFilter.blanks === false &&
                                    strValue === '(blanks)'
                                ) {
                                    arrData.push('0\t' + strRecord);
                                    bolUncheckedFound = true;

                                } else if (
                                    jsnFilter.values
                                        .indexOf(strValue) !== -1
                                ) {
                                    arrData.push('0\t' + strRecord);
                                    bolUncheckedFound = true;

                                } else {
                                    arrData.push('-1\t' + strRecord);
                                }
                            }
                        } else {
                            break;
                        }

                        i += 1;
                    }
                }
            }
        );
    }

    function internalSELECTcolumnUnique(
        //element,
        //uniqueFilterElement,
        //valueListElement,
        //strColumn
    ) {
        //
    }




    function dataSELECTcolumnUnique(
        element,
        uniqueFilterElement,
        valueListElement,
        strColumn
    ) {
        if (element.hasAttribute("src")) {
            databaseWSSELECTcolumnUnique(
                element,
                uniqueFilterElement,
                valueListElement,
                strColumn
            );
        } else {
            internalSELECTcolumnUnique(
                element,
                uniqueFilterElement,
                valueListElement,
                strColumn
            );
        }
    }
    function dataSELECT(element) {
        if (element.hasAttribute("src")) {
            databaseWSSELECT(element);
        } else {
            internalSELECT(element);
        }
    }
    function dataINSERT(element, strMode, jsnInsert) {
        if (element.hasAttribute("src")) {
            databaseWSINSERT(element, strMode, jsnInsert);
        } else {
            internalINSERT(element, strMode, jsnInsert);
        }
    }
    function dataUPDATE(element, strMode, jsnUpdate) {
        if (!element.hasAttribute('no-update')) {
            // we want to save the text selection of the current
            //      control before we do the update
            element.internalDisplay.focus.selectionRange = null;
            if (
                element.internalDisplay.focus.latest &&
                (
                    document.activeElement.nodeName === 'INPUT' ||
                    document.activeElement.nodeName === 'TEXTAREA'
                )
            ) {
                element.internalDisplay.focus.selectionRange = (
                    GS.getInputSelection(document.activeElement)
                );
            }

            if (element.hasAttribute("src")) {
                databaseWSUPDATE(element, strMode, jsnUpdate);
            } else {
                internalUPDATE(element, strMode, jsnUpdate);
            }
        }
    }
    function dataDELETE(element, jsnDeleteData) {
        if (element.hasAttribute("src")) {
            databaseWSDELETE(element, jsnDeleteData);
        } else {
            internalDELETE(element, jsnDeleteData);
        }
    }

// #############################################################################
// ####################### POST-RENDER UTILITY FUNCTIONS #######################
// #############################################################################

    // sometimes you need to know what records are selected, this function
    //      returns the selected record numbers
    function getSelectedRecordIndexes(element) {
        var arrRows = element.internalSelection.rows.slice(0);

        if (arrRows[0] === 'header') {
            arrRows.shift();
        }
        if (arrRows[arrRows.length - 1] === 'insert') {
            arrRows.pop();
        }

        return arrRows;
    }

    // this function takes the cell which is the endpoint of the latest
    //      selection, focuses into it and selects all text of possible
    function focusIntoCell(
        element,
        record,
        column,
        iterationNumber
    ) {
        var jsnViewportRange;

        var cellElement;
        var focusElement;

        var strTag;
        var strValue;

        // default iterationNumber so that if this is the first run
        //      iterationNumber will contain 0
        if (iterationNumber === undefined) {
            iterationNumber = 0;
        }

        // if cell is in the rendered range:
        //      warn and stop execution
        jsnViewportRange = element.internalDisplay.currentRange;
        //console.trace(jsnViewportRange, record, column);
        if (
            // if we're not in the insert record:
            //      test if cell is within the current record and column range
            (
                !jsnViewportRange.insertRecord &&
                (
                    record < jsnViewportRange.fromRecord ||
                    record > jsnViewportRange.toRecord ||
                    column < jsnViewportRange.fromColumn ||
                    column > jsnViewportRange.toColumn
                )
            ) ||
            // if we're in the insert record (and the insert record is visible):
            //      test if cell is within the current column range
            (
                jsnViewportRange.insertRecord && (
                    column < jsnViewportRange.fromColumn ||
                    column > jsnViewportRange.toColumn
                )
            )
        ) {
            console.warn('GS-TABLE Warning: "focusIntoCell" was called to' +
                    ' focus into a cell that is not rendered. Stopping' +
                    ' execution of "focusIntoCell".');
            return;
        }

        // we need to be able to do an element query inside the target cell, so
        //      here we get the cell element
        if (record === 'insert' && jsnViewportRange.insertRecord) {
            cellElement = xtag.query(
                element.elems.dataViewport,
                'gs-cell' +
                        '.table-insert' +
                        '[data-col-number="' + column + '"]'
            )[0];
        } else {
            cellElement = xtag.query(
                element.elems.dataViewport,
                'gs-cell' +
                        '.table-cell' +
                        '[data-row-number="' + record + '"]' +
                        '[data-col-number="' + column + '"]'
            )[0];
        }

        // if the cell was not found:
        //      warn
        //              because we checked and the cell is supposed to be in
        //                  the current viewport range
        //      re-render
        //              to put the element where it's supposed to be
        //      re-run this function
        //              because the re-render may cause the cell to go out of
        //                  range and therefore, we need to re-test
        //      stop execution
        //              because this function needs to run from the beginning
        if (!cellElement) {
            if (iterationNumber < 1) {
                // warn
                console.warn('GS-TABLE Warning: "focusIntoCell" was called to' +
                        ' focus into a cell that is not rendered. Stopping' +
                        ' execution of "focusIntoCell".');

                // re-render
                element.internalDisplay.fullRenderRequired = true;
                renderScrollDimensions(element);

                // re-run this function
                focusIntoCell(
                    element,
                    record,
                    column,
                    (iterationNumber + 1)
                );

            // infinite recursion detected, warn
            } else {
                // warn
                console.warn('GS-TABLE Warning: infinite loop detected' +
                        ' in "focusIntoCell". Stopping execution of' +
                        ' "focusIntoCell".');
            }

            // stop execution
            return;
        }

        // traverse into the cell and find first focusable element
        focusElement = xtag.query(
            cellElement,
            'input, textarea, select, [tabindex]'
        )[0];

        // if a focus element was found: focus into it
        if (focusElement) {
            focusElement.focus();

            // we want all the text selected, so if the focused element is an
            //      INPUT or TEXTAREA and it has a value: select all of the text
            strTag = focusElement.nodeName;
            strValue = (focusElement.value || '');
            if (
                (strTag === 'INPUT' || strTag === 'TEXTAREA') &&
                strValue.length > 0
            ) {
                GS.setInputSelection(focusElement, 0, strValue.length);
            }
        }
    }

    // sometimes we wan't a particular cell visible in the viewport, so this
    //      function moves the cell into view. if the cell is already in view,
    //      this function will just re-render the selection
    // strStickMode is a string that can contain one or more of these keywords:
    //          'top'
    //          'bottom'
    //          'left'
    //          'right'
    //      so, if you want the cell to be moved to the bottom-left
    //          you can send 'bottom-left' or 'bottomleft' or 'leftbottom' etc.
    //          however, you will get a warning if you send 'leftright' because
    //          those choices are contradictory
    function scrollCellIntoView(element, cellRecord, cellColumn, strStickMode) {
        var i;
        var len;

        var columnBorderWidth;
        var recordBorderHeight;
        var arrColumnWidths;
        var arrRecordHeights;

        var intCellWidth;
        var intCellHeight;
        var intCellTop;
        var intCellBottom;
        var intCellLeft;
        var intCellRight;

        var intViewportWidth;
        var intViewportHeight;
        var intViewportTop;
        var intViewportBottom;
        var intViewportLeft;
        var intViewportRight;

        var bolScrollMoved;

        var bolStickTop;
        var bolStickLeft;
        var bolStickBottom;
        var bolStickRight;

        // we're saving these to variables for quicker/easier access
        columnBorderWidth = element.internalDisplay.columnBorderWidth;
        recordBorderHeight = element.internalDisplay.recordBorderHeight;

        // we need to get column and record dimensions
        arrColumnWidths = element.internalDisplay.columnWidths;
        arrRecordHeights = element.internalDisplay.recordHeights;

        // we want shortcuts that turn strStickMode into boolean variables
        if (strStickMode) {
            bolStickTop = (strStickMode.indexOf('top') !== -1);
            bolStickLeft = (strStickMode.indexOf('left') !== -1);
            bolStickBottom = (strStickMode.indexOf('bottom') !== -1);
            bolStickRight = (strStickMode.indexOf('right') !== -1);

            // warn if two stick modes are contradictory
            if (bolStickTop && bolStickBottom) {
                console.warn('GS-TABLE Warning: Contradictory parameter sent' +
                        ' to scrollCellIntoView, you can\'t scroll a' +
                        ' cell to the top and the bottom of the viewport at' +
                        ' the same time. Stick to bottom will be cancelled.' +
                        ' Parameter Text: "' + strStickMode + '"');
                bolStickBottom = false;
            }
            if (bolStickLeft && bolStickRight) {
                console.warn('GS-TABLE Warning: Contradictory parameter sent' +
                        ' to scrollCellIntoView, you can\'t scroll a' +
                        ' cell to the left and the right of the viewport at' +
                        ' the same time. Stick to right will be cancelled.' +
                        ' Parameter Text: "' + strStickMode + '"');
                bolStickRight = false;
            }
        }

        // get location of the top, bottom, left and right of the record, we
        //      need these to calculate if we need to scroll to the cell

        // if the cell is in the header, we need to grab it's height from the
        //      internal display values
        if (cellRecord === 'header') {
            intCellHeight = element.internalDisplay.headerHeight;

        } else if (cellRecord === 'insert') {
            intCellHeight = element.internalDisplay.insertRecordHeight;

        // else, we can use the record height array
        } else {
            intCellHeight = arrRecordHeights[cellRecord];
        }

        // we want to get how far the record is from the top of the data, so
        //      if the record isn't the header,
        //          add up the record heights until the correct record
        //      else,
        //          default to 0
        intCellTop = 0;
        if (cellRecord === 'header') {
            intCellTop = 0;

        } else if (cellRecord === 'insert') {
            i = 0;
            len = arrRecordHeights.length;
            while (i < len) {
                intCellTop += arrRecordHeights[i];
                intCellTop += recordBorderHeight;
                i += 1;
            }

        } else {
            i = 0;
            len = cellRecord;
            while (i < len) {
                intCellTop += arrRecordHeights[i];
                intCellTop += recordBorderHeight;
                i += 1;
            }
        }

        // if the cell is a record selector, we need to grab it's width from the
        //      internal display values
        if (cellColumn === 'selector') {
            intCellWidth = element.internalDisplay.recordSelectorWidth;

        // else, we can use the column width array
        } else {
            intCellWidth = arrColumnWidths[cellColumn];
        }

        // we want to get how far the column is from the left of the data, so
        //      if the column isn't the record selector,
        //          add up the column widths until the correct column
        //      else,
        //          default to 0
        intCellLeft = 0;
        if (cellColumn !== 'selector') {
            i = 0;
            len = cellColumn;
            while (i < len) {
                intCellLeft += arrColumnWidths[i];
                intCellLeft += columnBorderWidth;
                i += 1;
            }
        }

        // calculate the cell bottom and right
        intCellBottom = (intCellTop + intCellHeight);
        intCellRight = (intCellLeft + intCellWidth);

        // get location of the top, bottom, left and right boundery lines of the
        //      viewport, we need these to calculate if we need to scroll to the
        //      cell
        intViewportWidth = (
            element.elems.dataViewport.clientWidth - (
                element.internalScrollOffsets.left +
                element.internalScrollOffsets.right
            )
        );
        intViewportHeight = (
            element.elems.dataViewport.clientHeight - (
                element.internalScrollOffsets.top +
                element.internalScrollOffsets.bottom
            )
        );
        intViewportTop = (element.internalScroll.top);
        intViewportLeft = (element.internalScroll.left);
        intViewportBottom = (intViewportTop + intViewportHeight);
        intViewportRight = (intViewportLeft + intViewportWidth);

        // we need a variable to say if we needed to scroll the viewport
        bolScrollMoved = false;

        // if the top of the cell is not visible, scroll it into view
        if (
            intCellTop < intViewportTop ||
            bolStickTop
        ) {
            element.internalScroll.top = intCellTop;
            bolScrollMoved = true;

        // if the bottom of the cell is not visible, scroll it into view
        } else if (
            intCellBottom > intViewportBottom ||
            bolStickBottom
        ) {
            element.internalScroll.top = (
                intCellBottom - intViewportHeight
            );
            bolScrollMoved = true;
        }

        // if the left of the cell is not visible, scroll it into view
        if (
            intCellLeft < intViewportLeft ||
            bolStickLeft
        ) {
            element.internalScroll.left = intCellLeft;
            bolScrollMoved = true;

        // if the right of the cell is not visible, scroll it into view
        } else if (
            intCellRight > intViewportRight ||
            bolStickRight
        ) {
            element.internalScroll.left = (intCellRight - intViewportWidth);
            bolScrollMoved = true;
        }

        // sometimes, using stick mode will cause this function to scroll too
        //      far in order to maintain that stick. so, here we handle
        //      scrolling past the max.
        // why not handle this in the renderScrollLocation function you ask?
        //      if a function touches a shared variable, it should be self
        //          contained when it comes to validation because we don't want
        //          someone to create a new function and forget to validate the
        //          shared variables (and therefore, cause errors). so if you
        //          write a function which touches some shared variable and you
        //          notice an error, make the function clean up it's own mess.

        // prevent scrolling past the max left scroll
        if (element.internalScroll.left > element.internalScroll.maxLeft) {
            element.internalScroll.left = element.internalScroll.maxLeft;

        // prevent scrolling behind the min left scroll
        } else if (element.internalScroll.left < 0) {
            element.internalScroll.left = 0;
        }

        // prevent scrolling past the max top scroll
        if (element.internalScroll.top > element.internalScroll.maxTop) {
            element.internalScroll.top = element.internalScroll.maxTop;

        // prevent scrolling behind the min top scroll
        } else if (element.internalScroll.top < 0) {
            element.internalScroll.top = 0;
        }

        // if the scroll moved: render location
        if (bolScrollMoved) {
            // render location so the user can see the cell
            renderScrollLocation(element);

        // else, just rerender the selection
        } else {
            renderSelection(element);
        }
    }

    // sometimes the selection is moved out of view, this function will scroll
    //      the last selection range's endpoint into view and re-render the
    //      scroll location
    // if the selected cell is already in view, this function will just
    //      re-render the selection
    // strStickMode is a string that can contain one or more of these keywords:
    //          'top'
    //          'bottom'
    //          'left'
    //          'right'
    //      so, if you want the selected endpoint to stick to the bottom-left
    //          you can send 'bottom-left' or 'bottomleft' or 'leftbottom' etc.
    //          however, you will get a warning if you send 'leftright' because
    //          those choices are contradictory
    function scrollSelectionIntoView(element, strStickMode) {
        var jsnRange;
        var cellColumn;
        var cellRecord;

        // we need to the latest selection range so that we know what cell to
        //      scroll into view
        jsnRange = element.internalSelection.ranges[
            element.internalSelection.ranges.length - 1
        ];

        // if there is no selection, there is nothing to scroll to,
        //      so, warn the dev and stop this function from running
        if (!jsnRange) {
            console.warn(
                'GS-TABLE Warning: scrollSelectionIntoView was ' +
                'called when there was no selection to scroll into view.'
            );
            return;
        }

        // get the cell's column and record number so that we can pass it along
        cellRecord = (jsnRange.end.row);
        cellColumn = (jsnRange.end.column);

        // send the cell's location to the scrollCellIntoView function
        scrollCellIntoView(element, cellRecord, cellColumn, strStickMode);
    }

    // this function takes the cell which is the endpoint of the latest
    //      selection, focuses into it and selects all text of possible
    function focusIntoSelectedCell(element) {
        var jsnRange;
        var bolReWriteSelection;

        // we use the latest range a lot, let's save a shortcut
        jsnRange = element.internalSelection.ranges[
            element.internalSelection.ranges.length - 1
        ];

        // if more than one selection: warn and move selection to endpoint of
        //      latest selection
        if (element.internalSelection.ranges.length > 1) {
            console.warn('GS-TABLE Warning: "focusIntoSelectedCell" called' +
                    ' when multiple selections were present. Now clearing all' +
                    ' selections and creating new selection at last' +
                    ' selection\'s endpoint.');
            // because this if block uses the same issue resolution as the
            //      "else if" block below, we'll just set a boolean variable and
            //      below this waterfall we'll add another if statement that
            //      handles this type of resolution
            bolReWriteSelection = true;

        // else if one selection that is more than one cell:
        //      warn and move selection to endpoint of latest selection
        } else if (
            jsnRange &&
            (
                jsnRange.start.column !== jsnRange.end.column ||
                jsnRange.start.row !== jsnRange.end.row
            )
        ) {
            console.warn('GS-TABLE Warning: "focusIntoSelectedCell" called' +
                    ' when the selection contained multiple cells. Now' +
                    ' clearing all selections and creating new selection at' +
                    ' last selection\'s endpoint.');
            // because this if block uses the same issue resolution as the
            //      "if" block above, we'll just set a boolean variable and
            //      below this waterfall we'll add another if statement that
            //      handles this type of resolution
            bolReWriteSelection = true;

        // else if no selections:
        //      warn, focus hiddenFocusControl so we can still listen to
        //      keypresses and stop execution
        } else if (!jsnRange) {
            console.warn('GS-TABLE Warning: "focusIntoSelectedCell" called' +
                    ' when there was no selection to focus into. Stopping' +
                    ' execution of "focusIntoSelectedCell".');

            focusHiddenControl(element);

            return;
        }

        // if there's more than one selection or the only selection contains
        //      multiple, the response is the same: change selection to only
        //      last cell of last selection range, so, instead of copying the
        //      code to resolve it into both cases in the waterfall, they set
        //      a boolean variable if this is what they need done.
        if (bolReWriteSelection) {
            // set the new list of selection ranges to the endpoint of the
            //      latest selection
            element.internalSelection.ranges = [
                {
                    "start": {
                        "row": jsnRange.end.row,
                        "column": jsnRange.end.column
                    },
                    "end": {
                        "row": jsnRange.end.row,
                        "column": jsnRange.end.column
                    },
                    "negator": false
                }
            ];

            // get the new selection range, this is a shortcut
            jsnRange = element.internalSelection.ranges[0];

            // re-render the selection because we've just changed it and
            //      the user needs to see the update
            renderSelection(element);
        }

        // pass the last selection's enpoint cell to focusIntoCell
        focusIntoCell(
            element,
            jsnRange.end.row,
            jsnRange.end.column
        );
    }

    // there are multiple places where we just want to delete the selected
    //      records. so, we'll make a function that handles all the error
    //      checking involved with using the selection to delete records
    function deleteSelectedRecords(element) {
        // if nothing is selected, open a dialog letting the user know that
        //      they need to choose something
        if (element.internalSelection.ranges.length === 0) {
            GS.msgbox(
                'No Records To Delete',
                '<center>' +
                        'Please choose a record to delete.' +
                        '</center>',
                ['Ok']
            );

        // else, everything is copacetic, let's initiate delete
        } else if (!element.hasAttribute('no-delete')) {
            dataDELETE(element, {
                "recordIndexes": getSelectedRecordIndexes(element),
                // we still need the user to confirm the delete
                "deleteConfirmed": false
            });
        }
    }

    // this function is used to stop the actions of the next function
    //      "dragScrollStart".
    function dragScrollEnd(element) {
        // we only want to run clearInterval if there is an interval to stop
        if (element.internalTimerIDs.scrollIntervalID !== null) {
            // stop scroll interval to stop the scrolling
            clearInterval(element.internalTimerIDs.scrollIntervalID);

            // clear scrolling ID to make it clear that that
            //      interval has been cancelled
            element.internalTimerIDs.scrollIntervalID = null;
        }

        // the rest of these commands are harmless even if the scroll was
        //      never started

        // clear scrolling direction because we've stopped
        //      scrolling
        element.internalScroll.dragScrollingDirection = null;

        // set scrolling status variable to false so that the
        //      element recognizes that scrolling is stopped
        element.internalScroll.dragScrolling = false;
    }

    // some actions use a dragging motion, this means that we need to be able
    //      to scroll the viewport if the mouse drags off of the gs-table's
    //      outer bounderies. there is more than one place where this behavior
    //      is desired. the first two that come to mind are column reordering
    //      and column resizing.
    // the way this function works is it kicks off an interval to scroll the
    //      viewport incrementally every iteration until the "dragScrollEnd"
    //      function is called
    // eventually, we'll probably add two parameters, one for vertical speed
    //      and one for horizontal speed. these parameters will need to
    //      default to a reasonable speed
    // ### NEED CODING ###
    function dragScrollStart(element, callback, strScrollDirection) {
        var jsnDirection;
        var bolScrollTop;
        var bolScrollLeft;
        var bolScrollBottom;
        var bolScrollRight;

        // set scrolling to true to prevent future mouse events
        //      from starting new scroll events
        element.internalScroll.dragScrolling = true;

        // parse direction string
        jsnDirection = directionStringBreakdown(strScrollDirection);

        // convenience variables
        bolScrollTop = jsnDirection.bolTop;
        bolScrollLeft = jsnDirection.bolLeft;
        bolScrollBottom = jsnDirection.bolBottom;
        bolScrollRight = jsnDirection.bolRight;

        // we need to be able to check of the direction string
        //      changed, so we'll save a copy to compare against
        strScrollDirection = jsnDirection.resolvedString;

        //console.log(
        //    'start',
        //    strScrollDirection,
        //    bolScrollTop,
        //    bolScrollLeft,
        //    bolScrollBottom,
        //    bolScrollRight
        //);

        // save the scroll direction internally so that other code can work
        //      appropriately for the scroll direction
        element.internalScroll.dragScrollingDirection = (
            strScrollDirection
        );

        // remember, we need to be able to scroll two directions at
        //      the same time

        // create scroll interval and save the interval ID so
        //      we can stop the interval later
        element.internalTimerIDs.scrollIntervalID = setInterval(
            function () {
                var newScrollingDirection;
                var intLeftScrollAmount;
                var intLeftScroll;
                var intLeftMax;
                var intTopScrollAmount;
                var intTopScroll;
                var intTopMax;

                // we need to know if the direction string was changed
                newScrollingDirection = (
                    element.internalScroll.dragScrollingDirection
                );

                // if the direction string was changed, recalculate
                //      the direction variables
                if (newScrollingDirection !== strScrollDirection) {
                    //console.log('SCROLL DIRECTION CHANGED');

                    jsnDirection = directionStringBreakdown(
                        newScrollingDirection
                    );

                    bolScrollTop = jsnDirection.bolTop;
                    bolScrollLeft = jsnDirection.bolLeft;
                    bolScrollBottom = jsnDirection.bolBottom;
                    bolScrollRight = jsnDirection.bolRight;

                    strScrollDirection = jsnDirection.resolvedString;

                    // save the scroll direction internally
                    element.internalScroll.dragScrollingDirection = (
                        strScrollDirection
                    );
                }

                // we want to adjust the speed of the scrolling
                //      depending on how far to the left or
                //      right the mouse is
                // ### NEED CODING ###
                if (bolScrollLeft || bolScrollRight) {
                    intLeftScrollAmount = 10;
                }
                if (bolScrollTop || bolScrollBottom) {
                    intTopScrollAmount = 10;
                }

                // we should also change to scrolling by column
                //      right now, the scrolling speed on the
                //      scrollbar is evenly paced but columns of
                //      different widths make the viewport
                //      scroll unevenly
                // ### NEED CODING ###

                // get current and max scroll for scroll
                //      direction
                if (bolScrollLeft || bolScrollRight) {
                    intLeftScroll = (element.internalScroll.left);
                    intLeftMax = (element.internalScroll.maxLeft);
                }
                if (bolScrollTop || bolScrollBottom) {
                    intTopScroll = (element.internalScroll.top);
                    intTopMax = (element.internalScroll.maxTop);
                }

                //console.log(
                //    strScrollDirection,
                //    bolScrollTop,
                //    bolScrollLeft,
                //    bolScrollBottom,
                //    bolScrollRight
                //);

                // if we are at the max of all directions that we
                //      are scrolling, stop scrolling interval
                // overscroll is handled in the else
                // underscroll is handled in the else
                if (
                    (
                        !bolScrollTop ||
                        intLeftScroll === 0
                    ) &&
                    (
                        !bolScrollLeft ||
                        intLeftScroll === 0
                    ) &&
                    (
                        !bolScrollBottom ||
                        intLeftScroll === intTopMax
                    ) &&
                    (
                        !bolScrollRight ||
                        intLeftScroll === intLeftMax
                    )
                ) {
                    //console.log('SCROLL STOPPED 1');
                    dragScrollEnd(element);

                } else if (
                    !bolScrollTop &&
                    !bolScrollLeft &&
                    !bolScrollBottom &&
                    !bolScrollRight
                ) {
                    //console.log('SCROLL STOPPED 2');
                    dragScrollEnd(element);

                // else, advance scroll in every direction we were
                //      told to
                } else {
                    if (bolScrollTop || bolScrollBottom) {
                        if (bolScrollTop) {
                            intTopScroll -= intTopScrollAmount;

                        } else if (bolScrollBottom) {
                            intTopScroll += intTopScrollAmount;
                        }

                        // prevent over/under scrolling

                        // prevent scrolling past the max
                        if (intTopScroll > intTopMax) {
                            intTopScroll = intTopMax;
                        }

                        // prevent scrolling behind the min
                        if (intTopScroll < 0) {
                            intTopScroll = 0;
                        }

                        // apply new scroll to correct direction
                        element.internalScroll.top = intTopScroll;
                    }

                    if (bolScrollLeft || bolScrollRight) {
                        if (bolScrollLeft) {
                            intLeftScroll -= intLeftScrollAmount;

                        } else if (bolScrollRight) {
                            intLeftScroll += intLeftScrollAmount;
                        }

                        // prevent scrolling past the max
                        if (intLeftScroll > intLeftMax) {
                            intLeftScroll = intLeftMax;
                        }

                        // prevent scrolling behind the min
                        if (intLeftScroll < 0) {
                            intLeftScroll = 0;
                        }

                        // apply new scroll to correct direction
                        element.internalScroll.left = intLeftScroll;
                    }

                    //console.log(
                    //    element.internalScroll.left,
                    //    element.internalScroll.top
                    //);

                    // render scroll
                    renderScrollLocation(element);

                    // the drag actions that use this function will sometimes
                    //      need to refresh something depending on the new
                    //      scroll position. the callback is for that purpose
                    if (callback) {
                        callback();
                    }
                }
            },
            50 // twentieth of a second refresh rate
        );
    }

// #############################################################################
// ############################## PASTE FUNCTIONS ##############################
// #############################################################################

    // when you paste for an insert, only some columns might be selected, this
    //      function takes the normalized paste data and trims out anything that
    //      would have been applied to an unseleted cell. after that, this
    //      function turns control over to the internal insert function
    function insertPasteString(element, arrPaste, intMaxPasteColumn) {
        var templateElement;
        var strSelection;
        var strOldRecord;
        var strNewRecord;
        var strCell;
        var strChar;

        var intStart;
        var intEnd;
        //var intMaxPasteColumn;
        var intMinPasteColumn;
        var intPastedColumn;
        var intColumn;

        var arrColumnElements;
        var arrColumns;

        var i;
        var len;
        var rec_i;
        var rec_len;

        // we need to know what columns of the insert record are selected
        strSelection = element.internalSelection.resolvedSelection[
            element.internalSelection.resolvedSelection.length - 1
        ];

        // if there is a record selector, remove that char from the selection
        //      string
        if (element.internalDisplay.recordSelectorVisible) {
            strSelection = strSelection.substring(1);
        }

        // the paste starts at the first selected cell
        intStart = strSelection.indexOf('F');
        intEnd = strSelection.lastIndexOf('F');

        // we want to paste the smaller of the selection or the available data,
        //      this is because we will not paste what we do not have and
        //      will not affect data that is not selected
        if ((intEnd - intStart) < intMaxPasteColumn) {
            intMaxPasteColumn = (intEnd - intStart);
        }

        intEnd = intStart + intMaxPasteColumn;

        // sometimes, an entire record is copied and pasted (including the
        //      record selector), we need to prevent this from being an
        //      issue
        if (element.internalSelection.columns[0] === 'selector') {
            intMinPasteColumn = 1;
        } else {
            intMinPasteColumn = 0;
        }

        //console.log('   intEnd:', intEnd);
        //console.log(' intStart:', intStart);
        //console.log('intMinCol:', intMinPasteColumn);
        //console.log('intMaxCol:', intMaxPasteColumn);

        // use the selected column list to filter the data of the paste
        i = 0;
        len = arrPaste.length;
        while (i < len) {
            strOldRecord = arrPaste[i];

            // null out any cells that would apply to an unselected column
            // remove any cells that go further than the last selected column
            intColumn = 0;
            intPastedColumn = 0;
            strNewRecord = '';
            strCell = '';
            rec_i = 0;
            rec_len = strOldRecord.length;
            while (rec_i < rec_len) {
                strChar = strOldRecord[rec_i];

                // if the current character is not a tab: add it to the current
                //      cell variable
                if (strChar !== '\t') {
                    strCell += strChar;
                }

                // if the current character is a tab or we are at the end of the
                //      record: handle current cell
                if (
                    strChar === '\t' ||
                    rec_i === (rec_len - 1)
                ) {
                    if (intColumn >= intMinPasteColumn) {
                        // if this isn't the first column: add a tab character
                        //      to separate the cells
                        if (intPastedColumn > 0) {
                            strNewRecord += '\t';
                        }

                        // if this column is selected: add cell to paste record
                        if (strSelection[intPastedColumn + intStart] === 'F') {
                            strNewRecord += strCell;

                        // else, replace the current cell with NULL
                        } else {
                            strNewRecord += '\\N';
                        }

                        intPastedColumn += 1;

                        if (intPastedColumn > intMaxPasteColumn) {
                            break;
                        }
                    }

                    // clear cell variable and advance column number
                    strCell = '';
                    intColumn += 1;
                }

                // if this column is past the last column we can paste to:
                //      stop adding cells from this record and move to the
                //      next record
                if (
                    intColumn > (
                        (intEnd - intStart) + intMinPasteColumn
                    )
                ) {
                    break;
                }
                rec_i += 1;
            }

            // update the paste data with the new record
            arrPaste[i] = strNewRecord;
            i += 1;
        }

        //console.log(arrPaste);

        // we need to say what columns we are inserting to, so here we take the
        //      start and end column numbers and turn that into an array of
        //      column names for the insert

        templateElement = document.createElement('template');
        templateElement.innerHTML = templateExtractVisibleCellRange(
            element,
            element.internalTemplates.insertRecord,
            intStart,
            (intEnd + 1)
            // the plus one is because the template extract function
            //      expects 0/1 to get the first column, not 0/0
        );

        arrColumnElements = xtag.query(
            templateElement.content,
            'gs-cell [column]'
        );
        arrColumns = [];
        i = 0;
        len = arrColumnElements.length;
        while (i < len) {
            arrColumns.push(arrColumnElements[i].getAttribute('column'));
            i += 1;
        }

        //console.log(
        //    intMinPasteColumn,
        //    intMaxPasteColumn,
        //    intStart,
        //    intEnd,
        //    //templateElement,
        //    //arrColumnElements,
        //    arrColumns
        //);

        // call the internal insert function, to be routed to the correct
        //      insert protocol
        dataINSERT(element, 'multi-record', {
            "data": {
                "values": arrPaste,
                "columns": arrColumns,
                "addin": getInsertAddin(element)
            },
            "insertConfirmed": false
        });
    }

    // when you paste for an update, only some cells might be selected, this
    //      function takes the normalized paste data and trims out anything that
    //      would have been applied to an unseleted cell. after that, this
    //      function turns control over to the internal update function
    function updatePasteString(element, arrPaste, intMaxPasteColumn) {
        var arrRecords;
        var arrColumns;
        var intStartColumn;
        var intEndColumn;
        var arrSelection;
        var strSelection;
        var arrUpdateIndexes = [];
        var arrTranslated = [];

        var paste_i;
        var update_i;
        var i;
        var len;
        var rec_i;
        var rec_len;

        var strOldRecord;
        var strNewRecord;
        var intColumn;
        var intMinPasteColumn;
        var strCell;
        var strChar;
        var intPasteColumn;
        var intColumnOffset;

        var templateElement;
        var arrInsertCellElements;
        var arrUpdateCellElements;
        var arrCellElements;
        var arrColumnElements;
        var arrColumnNames;

        var arrSelectedStates = ['B', 'D', 'F', 'H', 'J', 'L'];

        // save selection cache so that we can check if a particular cell is
        //      selected
        arrSelection = element.internalSelection.resolvedSelection;

        // you can't paste into the header
        if (element.internalDisplay.headerVisible) {
            arrSelection.shift();
        }

        // you can't paste into the insert from here
        if (element.internalDisplay.insertRecordVisible) {
            arrSelection.pop();
        }

        // save the indexes of the records that we're going to paste over
        arrRecords = element.internalSelection.rows;

        // you can't paste into the header
        if (arrRecords[0] === 'header') {
            arrRecords.shift();
        }

        // you can't paste into the insert from here
        if (arrRecords[arrRecords.length - 1] === 'insert') {
            arrRecords.pop();
        }

        // save the indexes of the columns that we're going to paste over
        arrColumns = element.internalSelection.columns;

        // you can't paste into the record selector
        if (arrColumns[0] === 'selector') {
            arrColumns.shift();
        }

        // get the first selected row and column number
        intStartColumn = arrColumns[0];

        // get the last selected row and column number
        intEndColumn = arrColumns[arrColumns.length - 1];

        // we want to paste the smaller of the selection or the available data,
        //      this is because we will not paste what we do not have and
        //      will not affect data that is not selected
        if ((intEndColumn - intStartColumn) < intMaxPasteColumn) {
            intMaxPasteColumn = (intEndColumn - intStartColumn);
        }

        intEndColumn = (intStartColumn + intMaxPasteColumn);

        //console.log(intStartColumn, intEndColumn, intMaxPasteColumn);

        // we need to know the offset in the row selection string caused by
        //      the record selectors
        intColumnOffset = 0;
        if (element.internalDisplay.recordSelectorVisible) {
            intColumnOffset = 1;
        }

        // we need to know what columns we are updating, so here we take the
        //      start and end column numbers and turn that into an array of
        //      column names for the update
        templateElement = document.createElement('template');

        templateElement.innerHTML = (
            element.internalTemplates.insertRecord
        );
        arrInsertCellElements = xtag.query(
            templateElement.content,
            'gs-cell'
        );

        templateElement.innerHTML = (
            element.internalTemplates.record.templateHTML
        );
        arrUpdateCellElements = xtag.query(
            templateElement.content,
            'gs-cell'
        );

        if (arrInsertCellElements.length > 0) {
            arrCellElements = arrInsertCellElements;
        } else {
            arrCellElements = arrUpdateCellElements;
        }

        // if we have an insert record, get the column names from there
        arrColumnNames = [];
        i = 0;
        len = arrColumns.length;
        while (i < len) {
            //console.log('test 1 1', arrColumns[i]);
            //console.log('test 1 2', arrCellElements[arrColumns[i]]);

            arrColumnElements = xtag.query(
                arrCellElements[arrColumns[i]],
                '[column]'
            );

            //console.log('test 1 3', arrColumnElements);

            if (arrColumnElements && arrColumnElements.length > 0) {
                arrColumnNames.push(
                    arrColumnElements[0].getAttribute('column')
                );

                //console.log(arrColumnNames.length, intMaxPasteColumn);
                if (arrColumnNames.length === (intMaxPasteColumn + 1)) {
                    break;
                }
            } else {
                arrColumns.splice(i, 1);
                i -= 1;
                len -= 1;
            }
            i += 1;
        }

        // loop through rows starting from start row
        paste_i = 0; // paste record index
        update_i = 0; // update record index
        len = arrPaste.length;

        // sometimes the paste is longer than the list of selected records, so
        //      if that's the case than we want to use the selection length
        if (len > arrRecords.length) {
            len = arrRecords.length;
        }

        // sometimes a header is selected, if it is, skip the first record
        if (element.internalSelection.rows[0] === 'header') {
            paste_i += 1;
        }

        // sometimes, an entire record is copied and pasted (including the
        //      record selector), we need to prevent this from being an
        //      issue
        if (element.internalSelection.columns[0] === 'selector') {
            intMinPasteColumn = 1;
        } else {
            intMinPasteColumn = 0;
        }

        while (update_i < len) {
            strOldRecord = arrPaste[paste_i];

            // we want the selection string for the current record
            strSelection = arrSelection[arrRecords[update_i]];

            // null out any cells that would apply to an unselected column
            // remove any cells that go further than the last selected column
            intColumn = 0;
            strNewRecord = '';
            strCell = '';
            intPasteColumn = 0;
            rec_i = 0;
            rec_len = strOldRecord.length;
            while (rec_i < rec_len) {
                strChar = strOldRecord[rec_i];

                // if the current character is not a tab: add it to the current
                //      cell variable
                if (strChar !== '\t') {
                    strCell += strChar;
                }

                // if the current character is a tab or we are at the end of the
                //      record: handle current cell
                if (
                    strChar === '\t' ||
                    rec_i === (rec_len - 1)
                ) {
                    if (intColumn >= intMinPasteColumn) {
                        // if this isn't the first column: add a tab character
                        //      to separate the cells
                        if (intPasteColumn > 0) {
                            strNewRecord += '\t';
                        }

                        // if this column is selected: add cell to paste record
                        if (
                            arrSelectedStates.indexOf(
                                strSelection[
                                    (
                                        arrColumns[intPasteColumn] +
                                        intColumnOffset
                                    )
                                ]
                            ) > -1
                        ) {
                            strNewRecord += strCell;

                        // else, replace the current cell with it's current
                        //      value
                        } else {
                            strNewRecord += getCell(
                                element,
                                arrColumnNames[intPasteColumn],
                                arrRecords[update_i],
                                false // not decoded
                            );
                        }
                        intPasteColumn += 1;

                        if (intPasteColumn > intMaxPasteColumn) {
                            break;
                        }
                    }

                    // clear cell variable and advance column number
                    strCell = '';
                    intColumn += 1;
                }

                // if this column is past the last column we can paste to:
                //      stop adding cells from this record and move to the
                //      next record
                if (
                    intColumn > (
                        (intEndColumn - intStartColumn) + intMinPasteColumn
                    )
                ) {
                    break;
                }
                rec_i += 1;
            }

            // add the new record to the translated record list
            arrUpdateIndexes.push(arrRecords[update_i]);
            arrTranslated.push(strNewRecord);
            paste_i += 1;
            update_i += 1;
        }

        //console.log('test1', arrColumns.length, arrColumns);
        //console.log('test2', arrColumnNames.length, arrColumnNames);
        //console.log('test3', arrUpdateIndexes.length, arrUpdateIndexes);
        //console.log('test4', arrTranslated.length, arrTranslated);

        // lets make the update
        dataUPDATE(element, 'cell-range', {
            "data": {
                "columns": arrColumnNames,
                "records": arrUpdateIndexes,
                "values": arrTranslated
            },
            "updateConfirmed": false
        });
    }

    // the goal of this function is to normalize the data from a paste. once
    //      that's done, this function will route the paste data to either the
    //      insert or update paste functions
    function usePasteString(element, strUnnormalizedPasteString) {
        var elementMaker = document.createElement('template');

        var tableElement;
        var tbodyElement;
        var arrRecord;
        var arrUpdateRecord;
        var arrInsertRecord;
        var arrCell;
        var strRecord;
        var strCell;
        var intMaxUpdateRecord;
        var arrSelectedRows;

        var rec_i;
        var rec_len;

        var col_i;
        var col_len;

        // because pasting a large amount of data takes time, add a
        //      loader to let the user know we've started, just in case
        addLoader(element, 'paste-parse', 'Parsing Pasted Data...');

        // if no HTML or no valid HTML: build HTML using plain text
        if (
            strUnnormalizedPasteString.indexOf('<' + 'table') === -1 &&
            strUnnormalizedPasteString.indexOf('<' + 'tr') === -1
        ) {
            strUnnormalizedPasteString = delimitedStringToHTML(
                element,
                strUnnormalizedPasteString,
                '\t',
                '\n',
                '"',
                GS.decodeFromTabDelimited
            );
        }

        // second, get record elements
        elementMaker.innerHTML = strUnnormalizedPasteString;

        // we don't want any header or footer records to be pasted
        tableElement = xtag.query(elementMaker.content, 'table')[0];
        tbodyElement = xtag.queryChildren(tableElement, 'tbody')[0];

        // if there's a TBODY, get records from within there
        if (tbodyElement) {
            arrRecord = xtag.queryChildren(tbodyElement, 'tr');

        // else (no TBODY), get immediate children of table
        } else {
            arrRecord = xtag.queryChildren(tableElement, 'tr');
        }

        // third, create an array of text records from the HTML, make
        //      sure to split the records up into insert and update records

        // we need to know how many of the records are for the update and
        //      how many are for the insert. to do this, we'll take the
        //      selection rows length, subtract one for 'insert' and/or
        //      'header' if their present.
        arrSelectedRows = element.internalSelection.rows;
        intMaxUpdateRecord = arrSelectedRows.length - 1;

        if (arrSelectedRows[intMaxUpdateRecord] === 'insert') {
            intMaxUpdateRecord -= 1;
        }
        if (arrSelectedRows[0] === 'header') {
            intMaxUpdateRecord -= 1;
        }

        //console.log(intMaxUpdateRecord);

        // begin the loop!
        arrUpdateRecord = [];
        arrInsertRecord = [];
        rec_i = 0;
        rec_len = arrRecord.length;
        col_len = arrRecord[0].children.length;
        while (rec_i < rec_len) {
            strRecord = '';
            arrCell = xtag.toArray(arrRecord[rec_i].children);
            col_i = 0;
            while (col_i < col_len) {
                strRecord += (
                    strRecord
                        ? '\t'
                        : ''
                );

                if (arrCell[col_i]) {
                    strCell = getPlainText(arrCell[col_i], true);

                    if (strCell && strCell.trim()) {
                        strRecord += GS.encodeForTabDelimited(strCell);
                    } else {
                        strRecord += '\\N';
                    }
                } else {
                    strRecord += '\\N';
                }

                col_i += 1;
            }

            // if we've normalized this record for update,
            //      stick it in the update array.
            if (rec_i <= intMaxUpdateRecord) {
                arrUpdateRecord.push(strRecord);

            // else, we've normalized this record for insert,
            //      stick it in the insert array.
            } else {
                arrInsertRecord.push(strRecord);
            }

            rec_i += 1;
        }

        //console.log('arrUpdateRecord:', arrUpdateRecord);
        //console.log('arrInsertRecord:', arrInsertRecord);

        // fourth, initiate insert and/or paste
        if (
            arrInsertRecord.length > 0 &&
            element.internalDisplay.insertRecordVisible &&
            arrSelectedRows[arrSelectedRows.length - 1] === 'insert'
        ) {
            insertPasteString(element, arrInsertRecord, (col_len - 1));
        }
        if (arrUpdateRecord.length > 0) {
            updatePasteString(element, arrUpdateRecord, (col_len - 1));
        }

        // remove pasting loader
        removeLoader(element, 'paste-parse', 'Paste Data Parsed');
    }

    // the goal of this function is to extract the data in a paste event. once
    //      that's done, this function will route the paste data to the
    //      function in charge of using a paste string.
    function usePasteEvent(element, event) {
        var clipboardData;
        var pastePlain;
        var pasteHTML;

        // we don't want to do any pasting if there is nothing selected
        if (
            element.internalSelection.columns.length === 0 &&
            element.internalSelection.rows.length === 0
        ) {
            addLoader(
                element,
                'paste-fail',
                'Can\'t paste, nothing selected...'
            );
            removeLoader(
                element,
                'paste-fail',
                'Can\'t paste, nothing selected...'
            );

        // else, there is something selected, initiate paste
        } else {
            // because pasting a large amount of data takes time, add a
            //      loader to let the user know we've started, just in case
            addLoader(element, 'paste-extract', 'Extracting Pasted Data...');

            // to handle IE differences without having to write a lot of code to
            //      handle IE vs non-IE, we'll have one variable for the
            //      clipboardData and it will either be from the event object
            //      (non-IE) or it will come from the window (IE), this will cut
            //      down on browser specific code
            clipboardData = (event.clipboardData || window.clipboardData);

            // first, extract the unnormalized text

            // this is the main difference for IE vs non-IE, in IE we only get
            //      the text MIME type (we don't even try for HTML), everywhere
            //      else we try to get HTML
            if (window.clipboardData) {
                pastePlain = clipboardData.getData('Text');
            } else {
                pasteHTML = clipboardData.getData('text/html');
                pastePlain = clipboardData.getData('Text');
            }

            // remove pasting loader
            removeLoader(element, 'paste-extract', 'Paste Data Extracted');

            //console.log('##########################################');
            //console.log('################## HTML ##################');
            //console.log('##########################################');
            //console.log('|' + pasteHTML + '|');

            //console.log('##########################################');
            //console.log('############### PLAIN TEXT ###############');
            //console.log('##########################################');
            //console.log('|' + pastePlain + '|');

            // send paste string to be utilized
            usePasteString(
                element,
                (pasteHTML || pastePlain)
            );
        }
    }

// #############################################################################
// ############################# BUTTON FUNCTIONS ##############################
// #############################################################################

    function openInsertDialog(element) {
        var strTemplate;
        var templateElement;
        var beforeEvent;

        // get the template string from internal storage
        strTemplate = element.internalTemplates.insertDialog;

        // we want a template element because that's what we're going to send to
        //      the dialog function
        templateElement = document.createElement("template");

        // fill template element
        templateElement.innerHTML = ml(function () {/*
            <gs-page gs-dynamic>
                <gs-header>
                    <center><h3>Create</h3></center>
                </gs-header>
                <gs-body padded>
                    {{HTML}}
                </gs-body>
                <gs-footer>
                    <gs-grid gutter>
                        <gs-block>
                            <gs-button dialogclose>Cancel</gs-button>
                        </gs-block>
                        <gs-block>
                            <gs-button dialogclose
                                       listen-for-return
                                       bg-primary>Create</gs-button>
                        </gs-block>
                    </gs-grid>
                </gs-footer>
            </gs-page>
        */
        }).replace("{{HTML}}", strTemplate);

        // send out a before insert dialog open event, so that the developer
        //      can cancel it
        beforeEvent = GS.triggerEvent(element, "before_insert_dialog_open");

        // if the user prevents the default on the "before_insert_dialog_open"
        //      event, prevent the execution of the insert dialog
        if (beforeEvent.defaultPrevented) {
            return;
        }

        // open the dialog
        GS.openDialog(
            templateElement,
            // after open callback
            function () {
                var dialog = this;
                var arrElements;
                var element_i;
                var element_len;
                var strColumn;
                var strValue;

                // if the user has started typing into the insert record and
                //      then clicked the insert button, show the values from
                //      the insert record
                arrElements = xtag.query(dialog, '[column]');
                element_i = 0;
                element_len = arrElements.length;
                while (element_i < element_len) {
                    strColumn = arrElements[element_i].getAttribute('column');
                    strValue = element.internalData.insertRecord[strColumn];

                    // if a value was retained for the current column
                    if (strValue) {
                        // fill control with retained value
                        arrElements[element_i].value = strValue;
                    }
                    element_i += 1;
                }

                // trigger after insert dialog open so the dev can run code
                GS.triggerEvent(element, "after_insert_dialog_open", {
                    "relatedTarget": dialog
                });
            },
            // before close callback
            // ignore is the placeholder for "event", jslint ignores unused
            //      parameters that are named "ignore"
            function (ignore, strAnswer) {
                var dialog = this;
                var arrElements;
                var element_i;
                var element_len;
                var strColumn;
                var strValue;

                // we want the data that the user has put into the insert
                //      dialog to be put into internal storage, gather the
                //      values
                arrElements = xtag.query(dialog, '[column]');
                element_i = 0;
                element_len = arrElements.length;
                while (element_i < element_len) {
                    strColumn = arrElements[element_i].getAttribute('column');
                    strValue = arrElements[element_i].value;

                    // we only want to retain the value if there's a value to
                    //      retain
                    if (strValue) {
                        // retain the value in the internalData
                        element.internalData.insertRecord[strColumn] = strValue;

                        // some insert fields may be changed twice before an
                        //      insert, so only add the column name to the
                        //      changed columns list if that column name isn't
                        //      already in the list
                        if (
                            element
                                .internalData
                                .insertRecordRetainedColumns
                                .indexOf(strColumn) === -1
                        ) {
                            element
                                .internalData
                                .insertRecordRetainedColumns
                                .push(strColumn);
                        }

                    // if the user clears out a field that was previously
                    //      retained, we want to remove that value from the
                    //      retained list
                    } else if (
                        !strValue &&
                        element
                            .internalData
                            .insertRecordRetainedColumns
                            .indexOf(strColumn) > -1
                    ) {
                        element
                            .internalData
                            .insertRecord[strColumn] = undefined;
                        element
                            .internalData
                            .insertRecordRetainedColumns
                            .splice(
                                element
                                    .internalData
                                    .insertRecordRetainedColumns
                                    .indexOf(strColumn)
                            );
                    }
                    element_i += 1;
                }

                // if the answer is to insert the record: do so
                if (strAnswer !== 'Cancel' || strAnswer === 'Create') {
                    dataINSERT(element, "single-record", {
                        "data": {
                            "values": (
                                element
                                    .internalData
                                    .insertRecord
                            ),
                            "columns": (
                                element
                                    .internalData
                                    .insertRecordRetainedColumns
                            ),
                            "addin": getInsertAddin(element)
                        },
                        "insertConfirmed": true
                    });

                    // the insert attempt has been made, so we clear out the
                    //      retained values
                    element.internalData.insertRecord = {};
                    element.internalData.insertRecordRetainedColumns = [];

                // else, re-render so that the internal storage is used to fill
                //      the insert controls
                } else {
                    element.internalDisplay.fullRenderRequired = true;
                    renderLocation(element);
                }
            }
        );
    }

    // after a column is hidden, there is no way to unhide it. we need a
    //      function that will open a dialog to give the user the option of
    //      showing or hiding any column
    function openColumnHideDialog(element, targetElement, callback) {
        var templateElement;
        var afterOpenCallback;
        var beforeCloseCallback;

        templateElement = document.createElement('template');
        templateElement.setAttribute('data-max-width', '15em');
        templateElement.setAttribute('no-background', '');
        templateElement.innerHTML = ml(function () {/*
            <gs-page gs-dynamic class="gs-table-contextmenu">
                <gs-header><h4>Unhide Columns</h4></gs-header>
                <gs-body class="gs-table-column-checklist-container" padded>
                </gs-body>
                <gs-footer>
                    <gs-grid gutter>
                        <gs-block>
                            <gs-button dialogclose>Cancel</gs-button>
                        </gs-block>
                        <gs-block>
                            <gs-button dialogclose bg-primary>Apply</gs-button>
                        </gs-block>
                    </gs-grid>
                </gs-footer>
            </gs-page>
        */
        });

        // because we open the dialog different ways depending on parameters,
        //      we'll put the callbacks in variables for convenience
        afterOpenCallback = function () {
            var dialog = this;
            var containerElement;
            var i;
            var len;
            var strHTML;
            var bolVisible;
            var arrColumnNames;
            var arrColumnWidths;

            // we want to know the column widths so that we can pre-check any
            //      hidden columns
            arrColumnWidths = element.internalDisplay.columnWidths;

            // we want to show the user column names that make sense.
            arrColumnNames = element.internalDisplay.columnPlainTextNames;

            // we want to fill the gs-body with the column list so that the
            //      user can check and uncheck columns
            containerElement = xtag.query(
                dialog,
                '.gs-table-column-checklist-container'
            )[0];

            strHTML = '';
            i = 0;
            len = arrColumnWidths.length;
            while (i < len) {
                bolVisible = (arrColumnWidths[i] > 0);
                strHTML += (
                    '<gs-checkbox ' +
                    '        data-col-number="' + i + '"' +
                    '        value="' + bolVisible.toString() + '">&nbsp;' +
                        encodeHTML(arrColumnNames[i]) +
                    '</gs-checkbox>'
                );

                i += 1;
            }

            containerElement.innerHTML = strHTML;

            // we want the top gs-page to have corner rounding
            dialog.classList.add('gs-table-contextmenu');
        };

        // event parameter ignored
        beforeCloseCallback = function (ignore, strAnswer) {
            var dialog = this;
            var arrCheckbox;
            var arrColumnWidths;
            var arrDefaultColumnWidths;
            var i;
            var len;
            var colIndex;

            if (strAnswer !== 'Cancel') {
                // we want a shortcut to the column widths
                arrColumnWidths = (
                    element.internalDisplay.columnWidths
                );

                // we want a shortcut to the default column widths
                arrDefaultColumnWidths = (
                    element.internalDisplay.defaultColumnWidths
                );

                // loop through each checkbox and show or hide the columns
                //      depending on the checkbox value
                arrCheckbox = xtag.query(dialog, 'gs-checkbox');
                i = 0;
                len = arrCheckbox.length;
                while (i < len) {
                    colIndex = parseInt(
                        arrCheckbox[i].getAttribute('data-col-number'),
                        10
                    );

                    if (
                        // if column is not hidden
                        arrColumnWidths[colIndex] > 0 &&
                        // and checkbox says to hide the column
                        arrCheckbox[i].value === 'false'
                    ) {
                        // hide the column
                        arrColumnWidths[colIndex] = 0;

                    } else if (
                        // if column is hidden
                        arrColumnWidths[colIndex] === 0 &&
                        // and checkbox says to show the column
                        arrCheckbox[i].value === 'true'
                    ) {
                        // restore the column to it's default width
                        arrColumnWidths[colIndex] = (
                            arrDefaultColumnWidths[colIndex]
                        );
                    }
                    i += 1;
                }

                // master, you updated arrColumnWidths but didn't update
                //      the internal storage!
                // that is correct, grasshopper, arrColumnWidths is a
                //      reference to the original array variable and
                //      therefore when we make changes to arrColumnWidths
                //      the changes will automatically be reflected in the
                //      internal storage.

                // partial re-render doesn't know how to insert columns
                //      into the middle of the viewport
                element.internalDisplay.fullRenderRequired = true;
                renderLocation(element);
            }

            if (callback) {
                callback(strAnswer);
            }
        };

        if (targetElement) {
            GS.openDialogToElement(
                targetElement,
                templateElement,
                'right',
                afterOpenCallback,
                beforeCloseCallback
            );
        } else {
            GS.openDialog(
                templateElement,
                afterOpenCallback,
                beforeCloseCallback
            );
        }
    }



    function openDataSettingsDialog(element, buttonElement) {
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-max-width', '20em');
        templateElement.setAttribute('no-background', '');
        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.innerHTML = ml(function () {/*
<gs-page class="gs-table-contextmenu">
    <gs-body class="gs-table-contextmenu" padded>
        <div class="context-menu-header">Show Rows:</div>
<table>
    <tbody>
        <tr>
            <td>From:</td>
            <td><gs-number class="pref-limit-from" mini></gs-number></td>
        </tr>
        <tr>
            <td>To:</td>
            <td><gs-number class="pref-limit-to" mini></gs-number></td>
        </tr>
    </tbody>
</table>
        <hr />
        <gs-grid gutter>
            <gs-block>
                <gs-button dialogclose>Cancel</gs-button>
            </gs-block>
            <gs-block>
                <gs-button dialogclose bg-primary>Apply</gs-button>
            </gs-block>
        </gs-grid>
    </gs-body>
</gs-page>
            */
        })
            .replace(/\{\{RETURN\}\}/gi, '\n')
            .replace(/\{\{TAB\}\}/gi, '\t');

        // the control elements are found in the "after open" callback.
        //      the reason these variables are defined here is so that
        //      the "before close" callback has access to them for free.
        var limitFromControl;
        var limitToControl;

        GS.openDialogToElement(
            buttonElement,
            templateElement,
            'down',
            function () {
                var dialog = this;
                var intLimit;
                var intOffset;

                // we want the top gs-page to have corner rounding
                dialog.classList.add('gs-table-contextmenu');

                // find all of the control elements
                limitFromControl = xtag.query(
                    dialog,
                    '.pref-limit-from'
                )[0];
                limitToControl = xtag.query(
                    dialog,
                    '.pref-limit-to'
                )[0];

                intLimit = parseInt(
                    element.getAttribute('limit'),
                    10
                );
                intOffset = parseInt(
                    (element.getAttribute('offset') || '0'),
                    10
                );

                // set the values of all the controls
                limitFromControl.value = (intOffset + 1);
                limitToControl.value = (
                    (intLimit + intOffset) ||
                    element.internalData.records.length
                );
            },
            // event parameter is ignored
            function (ignore, strAnswer) {
                var intLimitFrom;
                var intLimitTo;
                var intLimit;

                var strOldLimit;
                var strOldOffset;

                if (strAnswer === 'Apply') {
                    // gather the control values
                    intLimitFrom = parseInt(
                        (limitFromControl.value || '0'),
                        10
                    ) - 1;
                    intLimitTo = parseInt(
                        (limitToControl.value || '0'),
                        10
                    );
                    intLimit = (intLimitTo - intLimitFrom);

                    // save the old limit and offset so that we can know
                    //      if the limit or offset changed
                    strOldLimit = element.getAttribute('limit');
                    strOldOffset = element.getAttribute('offset');

                    // only set the limit and offset attribute if we could
                    //      calculate them. else, remove them.
                    if (!isNaN(intLimit)) {
                        element.setAttribute('limit', intLimit);
                    } else {
                        element.removeAttribute('limit');
                    }
                    if (!isNaN(intLimitFrom)) {
                        element.setAttribute('offset', intLimitFrom);
                    } else {
                        element.removeAttribute('offset');
                    }

                    // if the limit or the offset changed, refresh the table
                    if (
                        element.getAttribute('limit') !== strOldLimit &&
                        element.getAttribute('offset') !== strOldOffset
                    ) {
                        dataSELECT(element);
                    }
                }
            }
        );
    }

    function openClipboardSettingsDialog(element, buttonElement) {
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-max-width', '20em');
        templateElement.setAttribute('no-background', '');
        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.innerHTML = ml(function () {/*
<gs-page class="gs-table-contextmenu">
    <gs-body class="gs-table-contextmenu" padded>
        <div class="context-menu-header">Paste Format:</div>
        <table>
            <tbody>
<tr>
    <td>Headers?</td>
    <td>
        <gs-select class="pref-copy-headers" mini>
            <option value="always">Always</option>
            <option value="never">Never</option>
            <option value="selected">Only when selected</option>
        </gs-select>
    </td>
</tr>
<tr>
    <td>Row Numbers?</td>
    <td>
        <gs-select class="pref-copy-selectors" mini>
            <option value="always">Always</option>
            <option value="never">Never</option>
            <option value="selected">Only when selected</option>
        </gs-select>
    </td>
</tr>
<tr>
    <td>Quote Character:</td>
    <td>
        <gs-select class="pref-quote-char" mini>
            <option value="\">Backslash (\)</option>
            <option value="/">Forward Slash (/)</option>
            <option value="|">Pipe (|)</option>
            <option value="&quot;">Double Quote (&quot;)</option>
            <option value="'">Single Quote (')</option>
        </gs-select>
    </td>
</tr>
<tr>
    <td>Escape Character:</td>
    <td>
        <gs-select class="pref-escape-char" mini>
            <option value="\">Backslash (\)</option>
            <option value="/">Forward Slash (/)</option>
            <option value="|">Pipe (|)</option>
            <option value="&quot;">Double Quote (&quot;)</option>
            <option value="'">Single Quote (')</option>
        </gs-select>
    </td>
</tr>
<tr>
    <td>Quote?</td>
    <td>
        <gs-select class="pref-copy-quote" mini>
            <option value="always">Always</option>
            <option value="never">Never</option>
            <option value="strings">Only on strings</option>
            <option value="delimiter-in-content">
                Cell contains separator
            </option>
        </gs-select>
    </td>
</tr>
<tr>
    <td>Record Separator:</td>
    <td>
        <gs-select class="pref-delimiter-record" mini>
            <option value="{{RETURN}}">Newline</option>
            <option value="|">Vertical Bar (|)</option>
            <option value=",">Comma (,)</option>
            <option value="{{TAB}}">Tab</option>
        </gs-select>
    </td>
</tr>
<tr>
    <td>Cell Separator:</td>
    <td>
        <gs-select class="pref-delimiter-cell" mini>
            <option value="{{RETURN}}">Newline</option>
            <option value="|">Vertical Bar (|)</option>
            <option value=",">Comma (,)</option>
            <option value="{{TAB}}">Tab</option>
        </gs-select>
    </td>
</tr>
<tr>
    <td>Empty values:</td>
    <td>
        <gs-select class="pref-null-value" mini>
            <option value="">(nothing)</option>
            <option value="NULL">"NULL"</option>
            <option value="null">"null"</option>
            <option value="EMPTY">"EMPTY"</option>
            <option value="empty">"empty"</option>
            <option value="Nothing">"Nothing"</option>
        </gs-select>
    </td>
</tr>
            </tbody>
        </table>
        <hr />
        <gs-grid gutter>
            <gs-block>
                <gs-button dialogclose>Cancel</gs-button>
            </gs-block>
            <gs-block>
                <gs-button dialogclose bg-primary>Apply</gs-button>
            </gs-block>
        </gs-grid>
    </gs-body>
</gs-page>
            */
        })
            .replace(/\{\{RETURN\}\}/gi, '\n')
            .replace(/\{\{TAB\}\}/gi, '\t');

        // the control elements are found in the "after open" callback.
        //      the reason these variables are defined here is so that
        //      the "before close" callback has access to them for free.
        var copyHeadersControl;
        var copySelectorsControl;
        var copyQuoteCharControl;
        var copyEscapeCharControl;
        var copyQuoteWhenControl;
        var copyCellDelimiterControl;
        var copyRecordDelimiterControl;
        var copyNullControl;

        GS.openDialogToElement(
            buttonElement,
            templateElement,
            'down',
            function () {
                var dialog = this;
                var jsnCopy;

                // we want the top gs-page to have corner rounding
                dialog.classList.add('gs-table-contextmenu');

                // we need the current copy parameters
                jsnCopy = getCopyParameters(element);

                // find all of the control elements
                copyHeadersControl = xtag.query(
                    dialog,
                    '.pref-copy-headers'
                )[0];
                copySelectorsControl = xtag.query(
                    dialog,
                    '.pref-copy-selectors'
                )[0];
                copyQuoteCharControl = xtag.query(
                    dialog,
                    '.pref-quote-char'
                )[0];
                copyEscapeCharControl = xtag.query(
                    dialog,
                    '.pref-escape-char'
                )[0];
                copyQuoteWhenControl = xtag.query(
                    dialog,
                    '.pref-copy-quote'
                )[0];
                copyCellDelimiterControl = xtag.query(
                    dialog,
                    '.pref-delimiter-cell'
                )[0];
                copyRecordDelimiterControl = xtag.query(
                    dialog,
                    '.pref-delimiter-record'
                )[0];
                copyNullControl = xtag.query(
                    dialog,
                    '.pref-null-value'
                )[0];

                copyHeadersControl.value = jsnCopy.headerMode;
                copySelectorsControl.value = jsnCopy.selectorMode;
                copyQuoteCharControl.value = jsnCopy.quoteChar;
                copyEscapeCharControl.value = jsnCopy.escapeChar;
                copyQuoteWhenControl.value = jsnCopy.quoteMode;
                copyCellDelimiterControl.value = jsnCopy.cellDelimiter;
                copyRecordDelimiterControl.value = jsnCopy.recordDelimiter;
                copyNullControl.value = jsnCopy.nullString;
            },
            // event parameter is ignored
            function (ignore, strAnswer) {
                var strCopyHeaders;
                var strCopySelectors;
                var strQuoteChar;
                var strEscapeChar;
                var strQuoteMode;
                var strCellDelimiter;
                var strRecordDelimiter;
                var strNullValue;

                if (strAnswer === 'Apply') {
                    // gather the control values
                    strCopyHeaders = copyHeadersControl.value;
                    strCopySelectors = copySelectorsControl.value;
                    strQuoteChar = copyQuoteCharControl.value;
                    strEscapeChar = copyEscapeCharControl.value;
                    strQuoteMode = copyQuoteWhenControl.value;
                    strCellDelimiter = copyCellDelimiterControl.value;
                    strRecordDelimiter = copyRecordDelimiterControl.value;
                    strNullValue = copyNullControl.value;

                    // save the copy settings
                    element.setAttribute('copy-header', strCopyHeaders);
                    element.setAttribute('copy-selectors', strCopySelectors);
                    element.setAttribute('copy-quote-char', strQuoteChar);
                    element.setAttribute('copy-escape-char', strEscapeChar);
                    element.setAttribute('copy-quote-when', strQuoteMode);
                    element.setAttribute(
                        'copy-delimiter-cell',
                        strCellDelimiter
                    );
                    element.setAttribute(
                        'copy-delimiter-record',
                        strRecordDelimiter
                    );
                    element.setAttribute('copy-null-cell', strNullValue);
                }
            }
        );
    }

    // we want the user to have access to limit/offset and copy settings
    function openSettingsDialog(element, buttonElement) {
        var templateElement = document.createElement('template');

        templateElement.setAttribute('data-max-width', '15em');
        templateElement.setAttribute('no-background', '');
        templateElement.setAttribute('data-overlay-close', 'true');
        templateElement.innerHTML = ml(function () {/*
<gs-page class="gs-table-contextmenu">
    <gs-body class="gs-table-contextmenu" padded>
        <gs-button dialogclose iconleft remove-bottom
            icon="database"
            class="button-column-width">Data Settings</gs-button>
        <gs-button dialogclose iconleft remove-top
            icon="clipboard"
            class="button-column-width">Clipboard Settings</gs-button>
    </gs-body>
</gs-page>
            */
        });

        GS.openDialogToElement(
            buttonElement,
            templateElement,
            'down',
            function () {
                var dialog = this;

                // we want the top gs-page to have corner rounding
                dialog.classList.add('gs-table-contextmenu');
            },
            // event parameter is ignored
            function (ignore, strAnswer) {
                //var targetElement;
                //var targetButton;

                //// when you close the dialog by clicking on the
                ////      overlay, there is no event.
                //if (event && event.target) {
                //    targetElement = event.target;
                //}

                //// when you close the dialog by clicking on the
                ////      overlay, there is no target.
                //if (targetElement) {
                //    // we may need to position a second dialog to a
                //    //      button, so here we get the button that
                //    //      was clicked.
                //    if (targetElement.nodeName === 'GS-BUTTON') {
                //        targetButton = targetElement;
                //    } else {
                //        targetButton = GS.findParentTag(
                //            targetElement,
                //            'gs-button'
                //        );
                //    }
                //}

                if (strAnswer === 'Data Settings') {
                    openDataSettingsDialog(element, buttonElement);
                } else if (strAnswer === 'Clipboard Settings') {
                    openClipboardSettingsDialog(element, buttonElement);
                }
            }
        );

//
//Display:
//    no-record-selector (boolean)
//    header template (boolean)
//    insert record template (boolean)
//    column hide/show
//    theme (wait, we need to write some themes)
//
//Scrolling:
//    no-x-overscroll (boolean)
//    no-y-overscroll (boolean)
//

    }

// #############################################################################
// ############################## EVENT FUNCTIONS ##############################
// #############################################################################

    // ############# FOCUS EVENTS #############
    function unbindFocus(element) {
        element.removeEventListener(
            evt.mousedown,
            element.internalEvents.focusMouseDown
        );

        element.elems.dataViewport.removeEventListener(
            'focus',
            element.internalEvents.focusInViewport,
            true
        );
        window.removeEventListener(
            'focus',
            element.internalEvents.focusTracker
        );
        element.removeEventListener(
            'focus',
            element.internalEvents.focusTracker,
            true
        );
        window.removeEventListener(
            'blur',
            element.internalEvents.focusTracker
        );
        window.removeEventListener(
            'focusout',
            element.internalEvents.focusTracker
        );
    }
    function bindFocus(element) {
        element.internalEvents.focusMouseDown = function (event) {
            var blurEventFunction;
            var target = event.target;
            var parentCell;

            // when you put a control into a label, if you click on the label:
            //      it focuses the control. sometimes, people use a label
            //      element simply for the padding. we don't want this focus
            //      behaviour if people just want the label for the padding, so
            //      if the target is a label: prevent default
            parentCell = GS.findParentTag(target, 'gs-cell');
            if (
                parentCell &&
                parentCell.nodeName === 'GS-CELL' &&
                target.nodeName === 'LABEL' &&
                parentCell.children.length === 1 &&
                parentCell.children[0].nodeName === 'LABEL'
            ) {
                event.preventDefault();
                event.stopPropagation();
            }

            // if no focusable control was moused on: focus
            //      hiddenFocusControl
            //console.log(document.activeElement);
            //console.log(event.target);
            if (!GS.isElementFocusable(target) && !evt.touchDevice) {
                focusHiddenControl(element);

                //console.log('FOCUS:', document.activeElement);
                //setTimeout(function () {
                //    //console.log('FOCUS:', document.activeElement);
                //}, 1000);

                // some time after this mousedown event finishes, the
                //      hidden focus control gets "blur"ed, so we bind it
                //      to refocus after the "blur" event (only once though,
                //      we don't want the page to get stuck refocusing the
                //      hidden focus control)
                blurEventFunction = function () {
                    focusHiddenControl(element);
                    element.elems.hiddenFocusControl.removeEventListener(
                        'blur',
                        blurEventFunction
                    );
                };
                element.elems.hiddenFocusControl.addEventListener(
                    'blur',
                    blurEventFunction
                );
            }
        };

        element.addEventListener(
            evt.mousedown,
            element.internalEvents.focusMouseDown
        );

        // sometimes the user will click on a control to deselect one cell
        //      out of multiple selected cells. this causes the focus to be
        //      inside a non-selected cell
        element.internalEvents.focusInViewport = function () {
            var active = document.activeElement;
            var parentCell = GS.findParentTag(active, 'gs-cell');

            // if the focused element is inside a GS-CELL element
            if (parentCell && parentCell.nodeName === 'GS-CELL') {
                // if the GS-CELL is not selected
                if (!parentCell.hasAttribute('selected')) {
                    // focus hidden control
                    focusHiddenControl(element);
                }
            }
        };

        element.elems.dataViewport.addEventListener(
            'focus',
            element.internalEvents.focusInViewport,
            true
        );

        // we want to style the table depending on wheather or not the
        //      focus is inside the gs-table
        element.internalEvents.focusTracker = function () {//event
            var active = document.activeElement;
            var parentTable = GS.findParentElement(active, element);
            var parentCell;
            var parentColumn;

            element.internalDisplay.focus.latest = false;

            //console.log(active, event.type, parentTable);
            if (
                parentTable &&
                parentTable.nodeName === 'GS-TABLE'
            ) {
                element.classList.add('focus-in');
                element.classList.remove('focus-out');

                parentCell = GS.findParentTag(active, 'gs-cell');
                parentColumn = GS.findParentElement(active, '[column]');

                if (!parentColumn || parentColumn.nodeName === 'HTML') {
                    parentColumn = active;
                }

                // the render function needs to know what element is
                //      focused so that it can maintain that focus
                if (parentCell) {
                    element.internalDisplay.focus.column = (
                        parseInt(
                            (
                                parentCell.getAttribute('data-col-number') ||
                                parentCell.getAttribute('data-col') ||
                                ''
                            ),
                            10
                        )
                    );
                    element.internalDisplay.focus.row = (
                        parseInt(
                            (
                                parentCell.getAttribute('data-row-number') ||
                                ''
                            ),
                            10
                        )
                    );
                    element.internalDisplay.focus.columnAttribute = (
                        parentColumn.getAttribute('column')
                    );
                    element.internalDisplay.focus.nodeName = (
                        active.nodeName
                    );
                    element.internalDisplay.focus.latest = true;
                }
            } else {
                element.classList.add('focus-out');
                element.classList.remove('focus-in');
            }
        };

        window.addEventListener(
            'focus',
            element.internalEvents.focusTracker
        );
        element.addEventListener(
            'focus',
            element.internalEvents.focusTracker,
            true
        );
        window.addEventListener(
            'blur',
            element.internalEvents.focusTracker
        );
        window.addEventListener(
            'focusout',
            element.internalEvents.focusTracker
        );
    }

    // ############# SCROLL EVENTS #############
    function unbindScroll(element) {
        // because touch devices don't have scrollbars, we use a different set
        //      of code for scrolling
        if (evt.touchDevice) {
            element.elems.dataViewport.removeEventListener(
                evt.mousedown,
                element.internalEvents.scrollDragStartFunction
            );
        } else {
            // I tried "mousewheel", "MozMousePixelScroll" and "DOMMouseScroll"
            element.removeEventListener(
                'wheel',
                element.internalEvents.scrollWheelFunction
            );
        }

        window.removeEventListener(
            'resize',
            element.internalEvents.scrollResizeFunction
        );
        element.elems.yScrollBar.removeEventListener(
            'scroll',
            element.internalEvents.scrollBarYFunction
        );
        element.elems.xScrollBar.removeEventListener(
            'scroll',
            element.internalEvents.scrollBarXFunction
        );
    }
    function bindScroll(element) {
        // we need to manually move the scrollbar on a scroll event and then we
        //      need to rerender the cells

        // because touch devices don't have scrollbars, we use a different set
        //      of code for scrolling
        if (evt.touchDevice) {
            var intStartMouseLeft;
            var intStartMouseTop;
            var intStartScrollLeft;
            var intStartScrollTop;
            var intCurrentMouseLeft;
            var intCurrentMouseTop;
            var intCurrentScrollLeft;
            var intCurrentScrollTop;
            var dragStarted;

            element.internalEvents.scrollDragStartFunction = function (event) {
                var jsnMousePos = GS.mousePosition(event);
                dragStarted = false;
                intStartMouseLeft = jsnMousePos.left;
                intStartMouseTop = jsnMousePos.top;
                intStartScrollLeft = element.internalScroll.left;
                intStartScrollTop = element.internalScroll.top;

                event.preventDefault();
                event.stopPropagation();

                document.body.addEventListener(
                    evt.mousemove,
                    element.internalEvents.scrollDragMoveFunction
                );
                document.body.addEventListener(
                    evt.mouseup,
                    element.internalEvents.scrollDragEndFunction
                );
            };

            // on a phone you might want to click without scrolling a
            //      little bit, so we set here a minimum threshold of
            //      distance to before allowing scrolling
            var leftPlay = 10;
            var topPlay = 10;
            element.internalEvents.scrollDragMoveFunction = function (event) {
                var jsnMousePos;

                if (event.which === 0 && !evt.touchDevice) {
                    event.preventDefault();
                    event.stopPropagation();
                    element.internalEvents.scrollDragEndFunction();

                } else {
                    jsnMousePos = GS.mousePosition(event);
                    intCurrentMouseLeft = jsnMousePos.left;
                    intCurrentMouseTop = jsnMousePos.top;
                    intCurrentScrollLeft = element.internalScroll.left;
                    intCurrentScrollTop = element.internalScroll.top;

                    if (
                        dragStarted === false &&
                        (
                            Math.abs(
                                intCurrentMouseLeft - intStartMouseLeft
                            ) > leftPlay ||
                            Math.abs(
                                intCurrentMouseTop - intStartMouseTop
                            ) > topPlay
                        )
                    ) {
                        dragStarted = true;
                    }

                    if (dragStarted) {
                        event.preventDefault();
                        event.stopPropagation();

                        // we need to save the current top/left so that the
                        //      rerender function knows what direction we're
                        //      scrolling
                        element.internalScroll.prevTop =
                                element.internalScroll.top;
                        element.internalScroll.prevLeft =
                                element.internalScroll.left;

                        // scroll the difference
                        element.internalScroll.left -=
                                (intCurrentMouseLeft - intStartMouseLeft) +
                                (intCurrentScrollLeft - intStartScrollLeft);
                        element.internalScroll.top -=
                                (intCurrentMouseTop - intStartMouseTop) +
                                (intCurrentScrollTop - intStartScrollTop);

                        // we need to round the scroll so that we don't run into
                        //      type issues
                        element.internalScroll.top =
                                Math.round(element.internalScroll.top);
                        element.internalScroll.left =
                                Math.round(element.internalScroll.left);

                        // we need to prevent overscrolling
                        element.internalScroll.top = Math.min(
                            element.internalScroll.maxTop,
                            element.internalScroll.top
                        );
                        element.internalScroll.left = Math.min(
                            element.internalScroll.maxLeft,
                            element.internalScroll.left
                        );

                        // we need to prevent underscrolling
                        element.internalScroll.top = Math.max(
                            0,
                            element.internalScroll.top
                        );
                        element.internalScroll.left = Math.max(
                            0,
                            element.internalScroll.left
                        );

                        renderScrollLocation(element);
                    }
                }
            };

            element.internalEvents.scrollDragEndFunction = function () {
                // elastic scrolling
                //console.log('elastic scrolling');
                //renderScrollLocation(element);

                // unbind mousemove and mouseup
                document.body.removeEventListener(
                    evt.mousemove,
                    element.internalEvents.scrollDragMoveFunction
                );
                document.body.removeEventListener(
                    evt.mouseup,
                    element.internalEvents.scrollDragEndFunction
                );
            };

            element.elems.dataViewport.addEventListener(
                evt.mousedown,
                element.internalEvents.scrollDragStartFunction
            );
        // desktop scrolling
        } else {
            element.internalEvents.scrollWheelFunction = function (event) {
                var originalTop;
                var originalLeft;
                var jsnScroll;
                var intDeltaY;
                var intDeltaX;
                var intRecordHeight;

                // helper variable to help shorten the code
                jsnScroll = element.internalScroll;

                // we don't want to intercept overscrolling
                if (
                    // if we're at the top and we're scrolling up
                    (
                        jsnScroll.top === 0 &&
                        event.deltaY < 0
                    ) ||
                    // or we're at the bottom and we're scrolling down
                    (
                        jsnScroll.top === jsnScroll.maxTop &&
                        event.deltaY > 0
                    ) ||
                    // or we're at the left and we're scrolling left
                    (
                        jsnScroll.left === 0 &&
                        event.deltaX < 0
                    ) ||
                    // or we're at the right and we're scrolling right
                    (
                        jsnScroll.left === jsnScroll.maxLeft &&
                        event.deltaX > 0
                    )
                ) {
                    // stop execution
                    return;
                }

                // we need to prevent firefox from scrolling the window, Chrome
                //      automatically stops the scroll from bubbling up at this
                //      point
                event.preventDefault();

                // we need to save the original top and left so that we can have
                //      the element rerender only if the scroll actually changed
                originalTop = jsnScroll.top;
                originalLeft = jsnScroll.left;

                // we used to do smooth scrolling, this is the code you would
                //      use for that, it increments the scroll by the delta
                //      amount
                //// we need to increment the scroll with the event deltas
                ////      because calculating our own deltas is too much
                ////      trouble right now
                //intDeltaY = event.deltaY;
                //intDeltaX = event.deltaX;

                // because we scroll by the record, we need to find out the
                //      direction of the scroll and then round to nearest record
                //      in that direction
                intDeltaY = Math.round(event.deltaY);
                intDeltaX = Math.round(event.deltaX);

                intRecordHeight = (
                    (
                        element.internalDisplay.recordHeights[0] ||
                        element.internalDisplay.defaultRecordHeight
                    ) +
                    element.internalDisplay.recordBorderHeight
                );

                //var intTestOldScrollTop = jsnScroll.top;
                //var intTestSecondScrollTop;

                // up / down
                if (intDeltaY !== 0) {
                    jsnScroll.top = roundToNearestMultiple(
                        jsnScroll.top,
                        intRecordHeight
                    );
                    //intTestSecondScrollTop = jsnScroll.top;
                    jsnScroll.top += roundToNearestMultiple(
                        intDeltaY,
                        intRecordHeight
                    );
                }
                //jsnScroll.top += intDeltaY;

                // left / right
                if (intDeltaX !== 0) {
                    jsnScroll.left += intDeltaX;
                }

                //console.log(
                //    intTestOldScrollTop,
                //    intTestSecondScrollTop,
                //    jsnScroll.top
                //);

                // we need to save the current top/left so that the rerender
                //      function knows what direction we're scrolling
                jsnScroll.prevTop = jsnScroll.top;
                jsnScroll.prevLeft = jsnScroll.left;

                // we need to round the scroll so that we don't run into
                //      type issues
                jsnScroll.top = Math.round(jsnScroll.top);
                jsnScroll.left = Math.round(jsnScroll.left);

                // we need to prevent overscrolling
                element.internalScroll.top = Math.min(
                    jsnScroll.maxTop,
                    jsnScroll.top
                );
                element.internalScroll.left = Math.min(
                    jsnScroll.maxLeft,
                    jsnScroll.left
                );

                // we need to prevent underscrolling
                jsnScroll.top = Math.max(0, jsnScroll.top);
                jsnScroll.left = Math.max(0, jsnScroll.left);

                // we only need to rerender if the scroll actually changed
                //console.log('wheel');
                //console.log('internalTop:   ', element.internalScroll.top);
                //console.log('originalTop:   ', originalTop);
                //console.log('internalLeft:  ', element.internalScroll.left);
                //console.log('originalLeft:  ', originalLeft);
                if (
                    (jsnScroll.top !== originalTop) ||
                    (jsnScroll.left !== originalLeft)
                ) {
                    renderScrollLocation(element);
                }
            };
            // I tried "mousewheel", "MozMousePixelScroll" and "DOMMouseScroll"
            element.addEventListener(
                'wheel',
                element.internalEvents.scrollWheelFunction
            );
        }

        // we need to update the scrollbar dimensions if the window is resized
        element.internalEvents.scrollResizeFunction = function () {
            renderScrollDimensions(element);
        };
        window.addEventListener(
            'resize',
            element.internalEvents.scrollResizeFunction
        );

        // we need to update the scrollbar location from true scrollbar
        //      location to virtual scrollbar location
        element.internalEvents.scrollBarYFunction = function () {
            var intViewportHeight;
            var virtualScrollHeight;
            var trueScrollHeight;
            var trueScrollTop;

            var oldVirtualScrollTop;
            var newVirtualScrollTop;

            // sometimes, the gs-table triggeres a scrollbar event, so here we
            //      check to make sure the scrollbarY event has not been
            //      cancelled
            if (!element.internalEventCancelled.scrollbarY) {
                // we need the viewport dimensions because true scroll
                //      dimensions include the viewport height, which
                //      messes with the caluculations
                intViewportHeight = element.elems.dataViewport.clientHeight;

                // we are saving the max scroll dimensions for ease of access
                virtualScrollHeight = element.internalScroll.maxTop;

                // we need the actual scroll height of the scrollbars because
                //      we limit their height and that causes a difference we
                //      need to account for
                trueScrollHeight = element.elems.yScrollBar.scrollHeight;
                trueScrollHeight -= intViewportHeight;

                // we are saving the current true scroll location for ease
                //      of access
                trueScrollTop = element.elems.yScrollBar.scrollTop;

                // we want to know what direction we scrolled so that we can
                //      round to the next record in that direction. to do that,
                //      we're going to hold on to the old virtual scrollTop so
                //      that we can compare it to the new one.
                oldVirtualScrollTop = element.internalScroll.top;
                newVirtualScrollTop = (
                    trueScrollTop * (
                        virtualScrollHeight / trueScrollHeight
                    )
                );

                //// if we scrolled down, round to the next record down
                //if (newVirtualScrollTop > oldVirtualScrollTop) {

                //// else, we scrolled up, round to the next record up
                //} else {
                //}

                // we need to translate the true top into virtual top for the
                //      virtual scroll and save to internal location
                element.internalScroll.top = newVirtualScrollTop;

                // if this event gets triggered while the scrollbar doesn't have
                //      any room, trueScrollHeight will be 0 which means that
                //      (virtualScrollHeight / trueScrollHeight)
                //      would result in NaN (because of the division by 0),
                //      so, coalesce top to 0
                element.internalScroll.top = (
                    element.internalScroll.top || 0
                );

                // we need to round the scroll so that we don't run into
                //      any type issues
                element.internalScroll.top =
                        Math.round(element.internalScroll.top);

                // we need to prevent overscrolling
                element.internalScroll.top = Math.min(
                    element.internalScroll.maxTop,
                    element.internalScroll.top
                );

                // we need to prevent underscrolling
                element.internalScroll.top = Math.max(
                    0,
                    element.internalScroll.top
                );

                // render scroll location
                renderScrollLocation(element);
            }

            // if the scrollbarY was cancelled, we no longer want it to be
            //      cancelled. so, reset it to false
            element.internalEventCancelled.scrollbarY = false;
        };
        element.elems.yScrollBar.addEventListener(
            'scroll',
            element.internalEvents.scrollBarYFunction
        );

        // we need to update the scrollbar location from true scrollbar
        //      location to virtual scrollbar location
        element.internalEvents.scrollBarXFunction = function () {
            //console.log('scrollBarXFunction');
            var intViewportWidth;
            var virtualScrollWidth;
            var trueScrollWidth;
            var trueScrollLeft;

            // sometimes, the gs-table triggeres a scrollbar event, so here we
            //      check to make sure the scrollbarX event has not been
            //      cancelled
            //console.log(element.internalEventCancelled.scrollbarX);
            if (!element.internalEventCancelled.scrollbarX) {
                // we need the viewport dimensions because true scroll
                //      dimensions include the viewport width, which messes
                //      with the caluculations
                intViewportWidth = element.elems.dataViewport.clientWidth;

                // we are saving the max scroll dimensions for ease of access
                virtualScrollWidth = element.internalScroll.maxLeft;

                // we need the actual scroll width of the scrollbars because
                //      we limit their width and that causes a difference we
                //      need to account for
                trueScrollWidth = element.elems.xScrollBar.scrollWidth;
                trueScrollWidth -= intViewportWidth;

                // we are saving the current true scroll location for ease
                //      of access
                trueScrollLeft = element.elems.xScrollBar.scrollLeft;

                // we need to translate the true left into virtual left for the
                //      virtual scroll and save to internal location
                element.internalScroll.left = (
                    trueScrollLeft * (
                        virtualScrollWidth / trueScrollWidth
                    )
                );

                // if this event gets triggered while the scrollbar doesn't have
                //      any room, trueScrollWidth will be 0 which means that
                //      (virtualScrollWidth / trueScrollWidth)
                //      would result in NaN (because of the division by 0),
                //      so, coalesce left to 0
                element.internalScroll.left = (
                    element.internalScroll.left || 0
                );

                // we need to round the scroll so that we don't run into
                //      any type issues
                element.internalScroll.left =
                        Math.round(element.internalScroll.left);

                // we need to prevent overscrolling
                element.internalScroll.left = Math.min(
                    element.internalScroll.maxLeft,
                    element.internalScroll.left
                );

                // we need to prevent underscrolling
                element.internalScroll.left = Math.max(
                    0,
                    element.internalScroll.left
                );

                // render scroll location
                renderScrollLocation(element);
            }

            // if the scrollbarX was cancelled, we no longer want it to be
            //      cancelled. so, reset it to false
            element.internalEventCancelled.scrollbarX = false;
        };
        element.elems.xScrollBar.addEventListener(
            'scroll',
            element.internalEvents.scrollBarXFunction
        );
    }

    // ############# SELECTION EVENTS #############
    function unbindSelection(element) {
        if (evt.touchDevice) {
            // ### NEED CODING ###
        } else {
            element.elems.dataContainer.removeEventListener(
                evt.mousedown,
                element.internalEvents.selectDragStart
            );
        }
    }
    function bindSelection(element) {

        // #####################################################################
        // ############### SELECTION MODIFICATIONS of 2017-04-13 ###############
        // ##################### THIS HAST BEEN COMPLETED! #####################
        // #####################################################################
        //
        // hear ye! we'll be making some real changes to the selection
        //      functionality. this happened because towards the beginning of
        //      this project I made a some bad choices regarding selection and
        //      the insert record.
        //
        //      The bad choices stemmed from not checking the functionality of
        //      other capable datagrids designed by people who know what they're
        //      doing.
        //
        //      Dont panic, I'll e'splain.
        //
        //      Bad choice #1 was to make the insert record stick to the bottom
        //      of the viewport. While this seemed like a good idea because
        //      whenever you want to insert the insert record is right there,
        //      this makes it so that selection of data and/or the insert record
        //      needs to be mutually exclusive or else the selection will appear
        //      non-contiguous in some areas and give the idea that the
        //      selection ends prematurely in other areas.
        //
        //      Bad choice #2 was to make the internal representation of the
        //      selection not resolve the entire selection, instead, it resolves
        //      the data cell selections and has some other, awkward places to
        //      look for other selections. This approach also made it so that if
        //      you only had record selectors selected, some areas of the code
        //      wouldn't be able to tell because no data cells were selected.
        //
        //      To remedy choice #1, I had to modify the getCurrentCellRange
        //      function to make it determine if the insert record would be
        //      visible. After that, I made the full render and the partial
        //      render functions handle the visiblity. This remedied choice #1.
        //
        //      To remedy choice #2, I'm going to replace the -1 values in
        //      the selection range JSON and add some new values. Start and
        //      end points that are on a data cell will still use numbers.
        //      Here is the list of non-number values that will be able to
        //      be used:
        //          for rows:
        //              'header'
        //              'insert'
        //          for columns:
        //              'selector'
        //      For example, selection for a range that starts with the all
        //      selector and ends in the fifth column of the sixth row will
        //      look like this:
        //          {
        //              "start": {
        //                  "row": "header",
        //                  "column": "selector"
        //              },
        //              "end": {
        //                  "row": 5,   // zero-based
        //                  "column": 4 // zero-based
        //              },
        //              "negator": false
        //          }
        //
        //      In the resolved selection, we need to be able to determine
        //      the type of cell as well as it's selection using only one
        //      character. So, we'll use two letters per type, one for
        //      selected and one for unselected. Here are the various types
        //      and their characters:
        //          Type:              Unselected:   Selected:
        //          HEADER CELL        A             B
        //          RECORD CELL        C             D
        //          INSERT CELL        E             F
        //          ALL SELECTOR       G             H
        //          RECORD SELECTOR    I             J
        //          INSERT SELECTOR    K             L
        //
        //      Using our previous example of selection inside a table with
        //      eight records, eight columns, a header and an insert record.
        //      The resolved selection for internal lookup would look like
        //      this:
        //          [
        //              "HBBBBBAAA", // header
        //              "JDDDDDCCC", // data
        //              "JDDDDDCCC", // data
        //              "JDDDDDCCC", // data
        //              "JDDDDDCCC", // data
        //              "JDDDDDCCC", // data
        //              "JDDDDDCCC", // data
        //              "ICCCCCCCC", // data
        //              "ICCCCCCCC", // data
        //              "KEEEEEEEE"  // insert
        //          ]
        //
        //      Just like before, we'll include these:
        //          an array of columns that contain at lease one selected cell
        //              new values to be included:
        //                  'selector'
        //          an array of records that contain at lease one selected cell
        //              new values to be included:
        //                  'header'
        //                  'insert'
        //          the origin record number
        //
        //      Alright, we know what's wrong and what we want to end up with,
        //      how are we going to get they-ah from he-ah?
        //          1) We need to tag any sections of code that utilizes the old
        //                  selection format. The tag will be "OL' SELECTION"
        //          DONE
        //
        //          2) We need to comment out the selection renderer.
        //          DONE
        //
        //          3) We need the mouse events to generate the new format for
        //                  selection range JSON.
        //          DONE
        //
        //          4) We need to generate the new format of resolved
        //                  selection in the selection renderer.
        //          DONE
        //
        //          5) We need to loop through the visible cells and use
        //                  the resolved selection to style all of the
        //                  appropriate cells.
        //          DONE
        //
        //          6) We need to update any behaviour that utilizes the old
        //                  selection format.
        //          DONE
        //
        //          7) We need to make it so that if a paste is divided between
        //                  the insert record and some data records, we need to
        //                  do an update and an insert from that paste.
        //          DONE
        //
        //          8) We need to pat ourselves on the back about 4 times and
        //                  then slap ourselves on the face 4 times for having
        //                  screwed this up in the first place.
        //
        //          9) We need to pat ourselves on the back 4 more times for
        //                  having so thouroughly planned this recovery.
        //
        //          10) Finally, we need to inform papa of our success.
        //
        //          11) We should prolly stop referring to ourselves as two
        //                  seperate beings... My... precious...
        //
        //      This sub-document was authored by Michael.
        //
        // #####################################################################
        // ############### SELECTION MODIFICATIONS of 2017-04-13 ###############
        // ##################### THIS HAST BEEN COMPLETED! #####################
        // #####################################################################


        // touch devices have a different way to select, so here we bind the
        //      touch-friendly version of cell selection
        if (evt.touchDevice) {
            // ### NEED CODING ###

        // on a desktop, we bind this code for cell selection:
        } else {
            // we save a copy of the current ranges so that if the
            //      before_selection event gets prevented, we can revert the
            //      selection
            var selectionRangesCopy;

            // we may be altering the only selection range or the last range
            //      if a long list of ranges, so here we store what index in
            //      the selection range array we are editing
            var intCurrentSelectionIndex;

            element.internalEvents.selectDragStart = function (event) {
                var cell;
                var jsnRange;
                var newRange;
                var jsnLocation;

                //var classList;
                //var intRow;
                //var intColumn;

                //var bolIsDataCell;
                //var bolIsAllSelector;
                //var bolIsHeaderCell;
                //var bolIsRecordSelector;
                //var bolIsInsertCell;
                //var bolIsInsertSelector;

                element.bolFocusHiddenTextarea = false;

                // we need the cell that received the mousedown so that we
                //      can get it's row/column numbers (and of the case of
                //      adding a selection, wheather of not it's already
                //      selected)
                cell = GS.findParentElement(event.target, 'gs-cell');

                //console.log(cell, (element, event));
                //console.log(cell);
                //console.log(element.internalResize.currentlyResizing);
                //console.log(event.which);
                //console.log(!cell.hasAttribute('selected'));

                if (
                    // if we found a cell
                    cell.nodeName === 'GS-CELL' &&
                    // and we're not resizing a cell or record right now
                    element.internalResize.currentlyResizing === false &&
                    // and we're not reordering columns right now
                    element.internalReorder.currentlyReordering === false &&
                    // and the user used the left mouse button
                    // or the user right-clicked on a non-selected cell
                    (
                        event.which === 1 ||
                        !cell.hasAttribute('selected')
                    )
                ) {
                    // we need to let the other code know that we are currently
                    //      selecting
                    element.internalSelection.currentlySelecting = true;

                    // we define newRange here so that we can see the structure
                    //      and so that we can modify/use it
                    newRange = {
                        "start": {
                            "row": 0,
                            "column": 0
                        },
                        "end": {
                            "row": 0,
                            "column": 0
                        },
                        "negator": false
                    };

                    // save a copy of the current selection range so that we can
                    //      revert back to it if we need to
                    selectionRangesCopy = JSON.parse(
                        JSON.stringify(
                            element.internalSelection.ranges
                        )
                    );

                    //// header is attached to first row
                    //// record selector is attached to the first column
                    //// insert record is attached to last row or the header if
                    ////      there is no data

                    //// if the selected cell is a header
                    ////      row: 'header'
                    ////      column: cell column
                    //// if the selected cell is a data cell
                    ////      row: cell row
                    ////      column: cell column
                    //// if the selected cell is a record selector
                    ////      row: cell row
                    ////      column: 'selector'
                    //// if the selected cell is the all selector
                    ////      row: 'header'
                    ////      column: 'selector'
                    //// if the selected cell is a insert cell
                    ////      row: 'insert'
                    ////      column: cell column
                    //// if the selected cell is the insert selector
                    ////      row: 'insert'
                    ////      column: 'selector'
                    //intRow = parseInt(
                    //    cell.getAttribute('data-row-number'),
                    //    10
                    //);
                    //intColumn = parseInt(
                    //    cell.getAttribute('data-col-number'),
                    //    10
                    //);

                    //// we don't want to recalculate what type of a cell the
                    ////      target cell is, and we want shorter code. so,
                    ////      we'll create shortcut variables
                    //classList = cell.classList;
                    //bolIsDataCell = (
                    //    classList.contains('table-cell')
                    //);
                    //bolIsAllSelector = (
                    //    classList.contains('table-all-selector')
                    //);
                    //bolIsHeaderCell = (
                    //    classList.contains('table-header')
                    //);
                    //bolIsRecordSelector = (
                    //    classList.contains('table-record-selector')
                    //);
                    //bolIsInsertCell = (
                    //    classList.contains('table-insert')
                    //);
                    //bolIsInsertSelector = (
                    //    classList.contains('table-insert-selector')
                    //);

                    //if (bolIsDataCell) {
                    //    newRange.start.row = intRow;
                    //    newRange.start.column = intColumn;
                    //} else if (bolIsAllSelector) {
                    //    newRange.start.row = 'header';
                    //    newRange.start.column = 'selector';
                    //} else if (bolIsHeaderCell) {
                    //    newRange.start.row = 'header';
                    //    newRange.start.column = intColumn;
                    //} else if (bolIsRecordSelector) {
                    //    newRange.start.row = intRow;
                    //    newRange.start.column = 'selector';
                    //} else if (bolIsInsertCell) {
                    //    newRange.start.row = 'insert';
                    //    newRange.start.column = intColumn;
                    //} else if (bolIsInsertSelector) {
                    //    newRange.start.row = 'insert';
                    //    newRange.start.column = 'selector';
                    //}

                    // find out the cell location based on the mouse event
                    jsnLocation = getCellFromMouseEvent(element, event);

                    // replace the range start with the discovered location
                    newRange.start.row = jsnLocation.row;
                    newRange.start.column = jsnLocation.column;

                    // the end is the same as the start because we are only on
                    //      the first cell of the selection
                    newRange.end.row = newRange.start.row;
                    newRange.end.column = newRange.start.column;

                    //console.log('shiftKey : ', event.shiftKey);
                    //console.log('metaKey  : ', event.metaKey);
                    //console.log('ctrlKey  : ', event.ctrlKey);

                    // if the selection starts with no shift, CMD or CTRL
                    //      keys down: we clear all of the previous selections
                    //      and start with an new selection
                    if (!event.shiftKey && !event.metaKey && !event.ctrlKey) {
                        // clear all the old ranges and add the new range
                        element.internalSelection.ranges = [newRange];

                        // because our new selection is the first in the list,
                        //      the current selection index is 0
                        intCurrentSelectionIndex = 0;
                    } else {
                        // if the shift key is down (and the previous selection
                        //      was not negator selection), we need override the
                        //      previous selection's endpoint, so we'll just set
                        //      the intCurrentSelectionIndex to the index of the
                        //      latest selection
                        if (event.shiftKey) {
                            //console.log('OVER HERE');
                            intCurrentSelectionIndex = (
                                element.internalSelection.ranges.length - 1
                            );

                            // if the previous selection was not a negator
                            if (
                                element.internalSelection
                                    .ranges[intCurrentSelectionIndex]
                                    .negator === false
                            ) {
                                // we reset the endpoint of the latest range so
                                //      that the re-render that's coming up
                                //      shows the user that they've changed
                                //      their selection
                                element.internalSelection
                                    .ranges[intCurrentSelectionIndex]
                                    .end.row = newRange.start.row;
                                element.internalSelection
                                    .ranges[intCurrentSelectionIndex]
                                    .end.column = newRange.start.column;

                            // if the previous selection was a negator
                            //      selection, just add a new selection range
                            } else {
                                // add the new range to the end of the selection
                                //      range list
                                element.internalSelection.ranges.push(newRange);

                                // because we added our new selection to the end
                                //      of the selection range list, we need to
                                //      set the intCurrentSelectionIndex to end
                                //      end of the list
                                intCurrentSelectionIndex = (
                                    element.internalSelection.ranges.length - 1
                                );
                            }

                            // if the first selection range covers more than one
                            //      cell, focus the hidden textarea
                            jsnRange = element.internalSelection.ranges[0];
                            if (
                                jsnRange.start.row !== jsnRange.end.row ||
                                jsnRange.start.column !== jsnRange.end.column
                            ) {
                                //console.log('Focus, grasshopper');
                                element.bolFocusHiddenTextarea = true;
                            }

                        // else if the CMD of CTRL key is down, we create a new
                        //      selection and append it to the end
                        } else if (event.metaKey || event.ctrlKey) {
                            // if the new selection started on an already
                            //      selected cell, this selection becomes a
                            //      negator range (meaning that every cell in
                            //      it's range gets unselected)
                            if (cell.hasAttribute('selected')) {
                                newRange.negator = true;
                            }

                            // add the new range to the end of the selection
                            //      range list
                            element.internalSelection.ranges.push(newRange);

                            // because we added our new selection to the end of
                            //      the selection range list, we need to set the
                            //      intCurrentSelectionIndex to end end of the
                            //      list
                            intCurrentSelectionIndex = (
                                element.internalSelection.ranges.length - 1
                            );
                        }
                    }

                    // we re-render the selection because it has just been
                    //      changed
                    renderSelection(element);

                    //console.log(element.internalSelection.ranges);

                    // we add mousemove and mouseup events to the body because
                    //      if you're dragging to select and you mousemove off
                    //      of the element: we wan't to continue the selection,
                    //      and if you mouseup off of the element, we still want
                    //      to register that as a mouseup/end of selection
                    if (event.which === 1) {
                        document.body.addEventListener(
                            evt.mousemove,
                            element.internalEvents.selectDragMove
                        );
                        // TODO: firefox doesn't work with this and overflow
                        //      (event.target remains the origin cell)
                        document.body.addEventListener(
                            evt.mouseup,
                            element.internalEvents.selectDragEnd
                        );

                    // if the cell was right-clicked, we don't want to listen
                    //      to mouse drag. in fact, in order to have the
                    //      selection recalculate the selection cache in time
                    //      for the context menu we need to end the selection
                    //      now.
                    } else {
                        element.internalEvents.selectDragEnd();
                    }
                }
            };

            element.internalEvents.selectDragMove = function (event) {
                //var cell;
                //var classList;
                //var intRow;
                //var intColumn;
                var intOldEndRow;
                var intOldEndColumn;
                var currentRange;

                getCellFromMouseEvent(element, event);

                // if mouse is moving but no mouse button is down: finalize
                //      selection, unbind selectDragMove and unbind
                //      selectDragEnd
                if (event.which === 0 && !evt.touchDevice) {
                    element.internalEvents.selectDragEnd();

                } else {
                    // save the cell to a variable so that we can get it's
                    //      row/column
                    //console.log('event.target:', event.target);
                    // cell = GS.findParentElement(event.target, 'gs-cell');
                    // //console.log('cell:', cell);
                    // classList = cell.classList;

                    // // extract row/column from cell (if the cell has them)
                    // intRow = parseInt(
                    //     cell.getAttribute('data-row-number'),
                    //     10
                    // );
                    // intColumn = parseInt(
                    //     cell.getAttribute('data-col-number'),
                    //     10
                    // );


                    // find out the cell location based on the mouse event
                    var jsnLocation = getCellFromMouseEvent(element, event);

                    //console.log(cell, intRow, intColumn);
                    // get current selection range for easy access
                    currentRange = (
                        element.internalSelection
                            .ranges[intCurrentSelectionIndex]
                    );

                    // save old row and column so that we can later check if
                    //      a change was actually made (that way we only
                    //      re-render if the selection has changed)
                    intOldEndRow = currentRange.end.row;
                    intOldEndColumn = currentRange.end.column;



                    currentRange.end.row = jsnLocation.row;
                    currentRange.end.column = jsnLocation.column;
                    // // update the endpoint row and column
                    // // these if statments maintain the seperation of
                    // //      insert and non-insert selections and the
                    // //      inclusion of headers/record selectors in
                    // //      the selection
                    // if (classList.contains('table-cell')) {
                    //     currentRange.end.row = intRow;
                    //     currentRange.end.column = intColumn;

                    // } else if (classList.contains('table-all-selector')) {
                    //     currentRange.end.row = 'header';
                    //     currentRange.end.column = 'selector';

                    // } else if (classList.contains('table-header')) {
                    //     currentRange.end.row = 'header';
                    //     currentRange.end.column = intColumn;

                    // } else if (classList.contains('table-record-selector')) {
                    //     currentRange.end.row = intRow;
                    //     currentRange.end.column = 'selector';

                    // } else if (classList.contains('table-insert')) {
                    //     currentRange.end.row = 'insert';
                    //     currentRange.end.column = intColumn;

                    // } else if (classList.contains('table-insert-selector')) {
                    //     currentRange.end.row = 'insert';
                    //     currentRange.end.column = 'selector';
                    // }

                    //console.log(element.internalSelection.insertRecord);

                    // prevent text selection if selection is more than one cell
                    if (
                        currentRange.start.row !== currentRange.end.row ||
                        currentRange.start.column !== currentRange.end.column
                    ) {
                        event.preventDefault();
                        event.stopPropagation();
                    }

                    //console.log(document.activeElement);

                    // focus hidden focus control is not focused
                    //      and
                    //      if the selection just became
                    //          multiple cells with this selection (if selection
                    //          is more than one cell and previous endpoint was
                    //          the same as the starting point)
                    //      or
                    //      if the currently focused element is not a child
                    //          of this gs-table element
                    if (
                        document.activeElement !==
                            element.elems.hiddenFocusControl
                    ) {
                        if (
                            // if the current range encompasses more than one
                            //      cell
                            (
                                (
                                    currentRange.start.row !==
                                            currentRange.end.row ||
                                    currentRange.start.column !==
                                            currentRange.end.column
                                ) &&
                                (
                                    currentRange.start.row ===
                                            intOldEndRow &&
                                    currentRange.start.column ===
                                            intOldEndColumn
                                )
                            ) ||
                            // if the selection is not inside the gs-table
                            GS.findParentTag(
                                document.activeElement,
                                'gs-table'
                            ) !== element ||
                            // if there is more than one selection
                            element.internalSelection.ranges.length > 1
                        ) {
                            focusHiddenControl(element);
                        }
                    }

                    //console.log(currentRange.end.row,
                    //              intOldEndRow,
                    //              currentRange.end.column,
                    //              intOldEndColumn);

                    // re-render selection if selection ranges have been changed
                    if (
                        currentRange.end.row !== intOldEndRow ||
                        currentRange.end.column !== intOldEndColumn
                    ) {
                        renderSelection(element);
                    }
                }
            };
            element.internalEvents.selectDragEnd = function (/*event*/) {
                var beforeEvent;

                // trigger a "before_selection" event so that the page has a
                //      chance to cancel the selection
                beforeEvent = GS.triggerEvent(element, 'before_selection');

                // if the user prevents the default on the "before_selection"
                //      event, revert selection ranges to what they were before
                //      the latest selection started (and revert wheather or not
                //      the selection is in the insert record)
                if (beforeEvent.defaultPrevented) {
                    element.internalSelection.ranges = selectionRangesCopy;
                }

                // final re-render of the selection so that the selection is
                //      up to date
                renderSelection(element);

                // if the "before_selection" event is not prevented, we trigger
                //      "after_selection" so that the page can run code after a
                //      selection has been made
                if (beforeEvent.defaultPrevented) {
                    GS.triggerEvent(element, 'after_selection');
                }

                // unbind mousemove and mouseup
                document.body.removeEventListener(
                    evt.mousemove,
                    element.internalEvents.selectDragMove
                );
                document.body.removeEventListener(
                    evt.mouseup,
                    element.internalEvents.selectDragEnd
                );

                // we need to let the other code know that we are no longer
                //      selecting
                element.internalSelection.currentlySelecting = false;

                if (element.bolFocusHiddenTextarea) {
                    focusHiddenControl(element);
                    //console.log(document.activeElement);
                }
            };

            element.elems.dataContainer.addEventListener(
                evt.mousedown,
                element.internalEvents.selectDragStart
            );
        }
    }

    // ############# COLUMN/ROW RESIZE EVENTS #############
    function unbindCellResize(element) {
        if (!evt.touchDevice) {
            element.elems.dataViewport.removeEventListener(
                evt.mousemove,
                element.internalEvents.cellResizeStarter
            );

            element.elems.handleColumn.removeEventListener(
                evt.mousedown,
                element.internalEvents.cellResizeDragStart
            );
            element.elems.handleRecord.removeEventListener(
                evt.mousedown,
                element.internalEvents.cellResizeDragStart
            );

            element.elems.handleColumn.removeEventListener(
                'dblclick',
                element.internalEvents.cellResizeToDefault
            );
            element.elems.handleRecord.removeEventListener(
                'dblclick',
                element.internalEvents.cellResizeToDefault
            );
        }
    }
    function bindCellResize(element) {
        var showHandles;
        var setLineToMouse;

        // if we are not on a touch device
        if (!evt.touchDevice) {
            // we don't want to show the handles immediately, that'll mean
            //      that if the user moves the mouse across the viewport,
            //      there'll be resize handles popping up and disappearing
            //      rapidly. this effect would look bad and be distracting.
            //      to fix this, we'll throttle the function that detects if
            //      a handle should be show, but not the code that removes
            //      the handle.
            // ### NEED CODING ###
            showHandles = function (event) {
                if (element.internalResize.showThrottleID !== null) {
                    clearTimeout(element.internalResize.showThrottleID);
                    element.internalResize.showThrottleID = null;
                }

                element.internalResize.showThrottleID = setTimeout(
                    function () {
                        var intPreviousPoint;
                        var jsnElementPos;
                        var jsnMousePos;
                        var intMouseX;
                        var intMouseY;

                        var intPoint;

                        var i;
                        var len;

                        jsnElementPos = GS.getElementOffset(
                            element.elems.dataViewport
                        );
                        jsnMousePos = GS.mousePosition(event);

                        // we need the mouse X to be relative to the
                        //      dataViewport
                        intMouseX = (jsnMousePos.left - jsnElementPos.left);

                        // we need the mouse Y to be relative to the
                        //      dataViewport
                        intMouseY = (jsnMousePos.top - jsnElementPos.top);

                        //console.log(
                        //    '      intMouseX: ',
                        //    intMouseX
                        //);
                        //console.log(
                        //    '      intMouseY: ',
                        //    intMouseY
                        //);
                        //console.log(
                        //    'selectorVisible: ',
                        //    element.internalDisplay.recordSelectorVisible
                        //);
                        //console.log(
                        //    '  selectorWidth: ',
                        //    element.internalDisplay.recordSelectorWidth
                        //);
                        //console.log(
                        //    '  headerVisible: ',
                        //    element.internalDisplay.headerVisible
                        //);
                        //console.log(
                        //    '   headerHeight: ',
                        //    element.internalDisplay.headerHeight
                        //);

                        // see if the mouse collides with a column drag handle
                        //      point
                        element.internalResize.resizeColumn = false;
                        if (
                            element.internalDisplay.recordSelectorVisible &&
                            intMouseY <= (
                                element.internalDisplay.headerHeight
                            )
                        ) {
                            i = 0;
                            len = element.internalDisplay.columnHandles.length;
                            while (i < len) {
                                intPoint = (
                                    element.internalDisplay.columnHandles[i]
                                );

                                // sometimes a column will be hidden, hidden
                                //      columns have null for their handle
                                if (intPoint !== null) {
                                    if (Math.abs(intMouseX - intPoint) <= 5) {
                                        // we need to know what column we are
                                        //      resizing, so here we save the
                                        //      index of the column that we
                                        //      found
                                        element.internalResize
                                            .resizeColumnHandleIndex = i;

                                        // because we found a column to resize,
                                        //      set the resizeColumn in internal
                                        //      storage to true so that the drag
                                        //      code knows that it's going to
                                        //      resize in the X axis
                                        element.internalResize.resizeColumn = (
                                            true
                                        );

                                        // we need to be able to prevent the
                                        //      user from resizing a cell to
                                        //      negative dimensions, so here we
                                        //      decide the origin X (the cell
                                        //      resize code uses, this origin
                                        //      to stop the user)
                                        // if there is a previous handle point,
                                        //      use, that as the origin X
                                        if (intPreviousPoint !== undefined) {
                                            element.internalResize
                                                .cellOriginX = (
                                                    intPreviousPoint
                                                );
                                        // else, 0 is the origin X
                                        } else {
                                            element.internalResize
                                                .cellOriginX = 0;
                                        }

                                        // we want the minimum width to be 1
                                        element.internalResize.cellOriginX += 1;

                                        break;
                                    }
                                    if (intPoint > intMouseX) {
                                        break;
                                    }

                                    intPreviousPoint = intPoint;
                                }
                                i += 1;
                            }
                        }

                        // see if the mouse collides with a record drag handle
                        //      point
                        element.internalResize.resizeRecord = false;
                        if (
                            element.internalDisplay.headerVisible &&
                            intMouseX <= (
                                element.internalDisplay.recordSelectorWidth
                            )
                        ) {
                            i = 0;
                            len = element.internalDisplay.recordHandles.length;
                            while (i < len) {
                                intPoint = (
                                    element.internalDisplay.recordHandles[i]
                                );

                                if (Math.abs(intMouseY - intPoint) <= 5) {
                                    // we need to know what record we are
                                    //      resizing, so here we save the
                                    //      index of the record that we found
                                    element.internalResize
                                        .resizeRecordHandleIndex = i;

                                    // because we found a record to resize, set
                                    //      the resizeRecord in internal storage
                                    //      to true so that the drag code knows
                                    //      that it's going to resize in the Y
                                    //      axis
                                    element.internalResize.resizeRecord = true;

                                    // we need to be able to prevent the user
                                    //      from resizing a cell to negative
                                    //      dimensions, so here we decide the
                                    //      origin Y (the cell resize code uses
                                    //      this origin to stop the user)

                                    // if we found the insert record, origin is
                                    //      0
                                    if (
                                        i === (len - 1) &&
                                        element.internalDisplay
                                            .insertRecordVisible
                                    ) {
                                        element.internalResize.cellOriginY = (
                                            0
                                        );

                                    // if there is a previous handle point, use
                                    //      that as the origin Y
                                    } else if (i > 0) {
                                        element.internalResize.cellOriginY = (
                                            element.internalDisplay
                                                .recordHandles[i - 1]
                                        );

                                    // else, 0 is the origin Y
                                    } else {
                                        element.internalResize.cellOriginY = 0;
                                    }

                                    // we want the minimum height to be 1
                                    element.internalResize.cellOriginY += 1;

                                    break;
                                }
                                if (intPoint > intMouseY) {
                                    break;
                                }
                                i += 1;
                            }
                        }

                        //console.log(
                        //    element.internalResize.resizeRecordHandleIndex
                        //);

                        // append any handles that aren't already in the DOM

                        // if the mouse is over a column handle point, add the
                        //      column resize handle
                        if (
                            element.internalResize.resizeColumn &&
                            element.elems.handleColumn.parentNode !==
                                element.elems.dataViewport
                        ) {
                            // append handle element to the viewport
                            element.elems.dataViewport
                                .appendChild(element.elems.handleColumn);
                        }

                        // if the mouse is over a record handle point, add the
                        //      record resize handle
                        if (
                            element.internalResize.resizeRecord &&
                            element.elems.handleRecord.parentNode !==
                                element.elems.dataViewport
                        ) {
                            // append handle element to the viewport
                            element.elems.dataViewport
                                .appendChild(element.elems.handleRecord);
                        }

                        // move column handle to correct position
                        if (element.internalResize.resizeColumn) {
                            // move handle to correct position depending on the
                            //      column that was matched
                            element.elems.handleColumn.style.left = (
                                element.internalDisplay.columnHandles[
                                    element.internalResize
                                        .resizeColumnHandleIndex
                                ]
                            ) + 'px';
                        }

                        // move record handle to correct position
                        if (element.internalResize.resizeRecord) {
                            // move handle to correct position depending on the
                            //      record that was matched
                            element.elems.handleRecord.style.top = (
                                element.internalDisplay.recordHandles[
                                    element.internalResize
                                        .resizeRecordHandleIndex
                                ]
                            ) + 'px';
                        }

                        // if the mouse is over a column and record handle point
                        if (
                            element.internalResize.resizeColumn &&
                            element.internalResize.resizeRecord
                        ) {
                            // add a four-way arrow cursor
                            element.elems.dataViewport
                                .classList.add('table-cursor-all-resize');

                        // else if the mouse is over a column handle point
                        } else if (element.internalResize.resizeColumn) {
                            // add a two-way horizontal arrow cursor
                            element.elems.dataViewport
                                .classList.add('table-cursor-col-resize');

                        // else if the mouse is over a record handle point
                        } else if (element.internalResize.resizeRecord) {
                            // add a two-way vertical arrow cursor
                            element.elems.dataViewport
                                .classList.add('table-cursor-row-resize');
                        }

                        //console.log('X:' + intMouseX, 'Y:' + intMouseY);

                        element.internalResize.showThrottleID = null;
                    },
                    20  // 2 hundredths of a second, this is to prevent a really
                        //      quick selection from accidentally becoming a
                        //      resize because the user unintentionally hovered
                        //      over the resize area
                );
            };

            // we don't want a whole lot of elements for our drag handles, so
            //      instead we'll detect if the mouse is in the correct spot for
            //      a drag, if it is then we'll insert a drag element (so that
            //      we can change the cursor). This also makes it so that we can
            //      do a different cursor for column resizing, row resizing and
            //      column/row resizing.
            // when mouse is 1 or less away pixels away from a cell and/or
            //      record border: insert drag element
            element.internalEvents.cellResizeStarter = function (event) {
                var strUserAgent = window.navigator.userAgent;

                // this code only needs to run when the mouse is up. we don't
                //      want to be calculating this every mousemove during a
                //      cell selection
                // we also don't want to run this code if we are currently
                //      resizing cells already
                // we also don't want to run this code if we are currently
                //      reordering columns
                //console.log(
                //    'test',
                //    event.which,
                //    window.navigator.userAgent.indexOf("Edge"),
                //    event
                //);
                if (
                    (
                        (
                            (
                                strUserAgent.indexOf("Edge") > -1 ||
                                strUserAgent.indexOf("Firefox") > -1
                            ) &&
                            event.which === 1
                        ) ||
                        (
                            (
                                strUserAgent.indexOf("Edge") === -1 ||
                                strUserAgent.indexOf("Firefox") > -1
                            ) &&
                            event.which === 0
                        )
                    ) &&
                    element.internalResize.currentlyResizing !== true &&
                    element.internalResize.currentlyReordering !== true
                ) {
                    //console.log('lets do it');
                    // remove the column handle
                    if (
                        element.elems.handleColumn.parentNode ===
                            element.elems.dataViewport
                    ) {
                        element.elems.dataViewport
                            .removeChild(element.elems.handleColumn);
                    }

                    // remove the record handle
                    if (
                        element.elems.handleRecord.parentNode ===
                            element.elems.dataViewport
                    ) {
                        element.elems.dataViewport
                            .removeChild(element.elems.handleRecord);
                    }

                    // clear any classes that affect the cursor (that were
                    //      placed there by the cell resize code)
                    element.elems.dataViewport
                        .classList.remove('table-cursor-all-resize');
                    element.elems.dataViewport
                        .classList.remove('table-cursor-col-resize');
                    element.elems.dataViewport
                        .classList.remove('table-cursor-row-resize');

                    // show any handles we're over (THROTTLED FUNCTION)
                    showHandles(event);
                } else {
                    //console.log('lets NOT do it');
                    // cancel throttled execution of showHandles
                    if (element.internalResize.showThrottleID !== null) {
                        clearTimeout(element.internalResize.showThrottleID);
                        element.internalResize.showThrottleID = null;
                    }
                }
            };

            element.elems.dataViewport.addEventListener(
                evt.mousemove,
                element.internalEvents.cellResizeStarter
            );

            // when dragging, just show a line where you'll resize to, instead
            //      of changing the size and re-rendering multiple times in a
            //      row
            element.internalEvents.cellResizeDragStart = function () {
                var recordSelectorVisible;
                var headerVisible;
                //var insertRecordVisible;
                var intColumnHandle;
                var intRecordHandle;

                // we need to let everything know that we are resizing cells,
                //      this is used to prevent cell selection during cell
                //      resize
                element.internalResize.currentlyResizing = true;

                // there are some things in the drag end code that we only want
                //      to run if the mouse has moved (and therefore started
                //      resizing), so here we default the resizeStarted to false
                //      and after mousemove it'll be set to true
                element.internalResize.resizeStarted = false;

                // we need to know the record/column indexes at this stage and
                //      store them internally

                // reset column and row index variables
                element.internalResize.resizeColumnIndex = null;
                element.internalResize.resizeRecordIndex = null;
                element.internalResize.resizingRecordSelectors = false;
                element.internalResize.resizingHeader = false;
                element.internalResize.resizingInsert = false;

                // to get the record/column indexes, we need to know what's
                //      visible
                recordSelectorVisible = (
                    element.internalDisplay.recordSelectorVisible
                );
                headerVisible = (
                    element.internalDisplay.headerVisible
                );
                //insertRecordVisible = (
                //    element.internalDisplay.insertRecordVisible
                //);

                // if we're resizing a column, get column index or type
                if (element.internalResize.resizeColumn) {
                    // to get the record/column indexes, we need to know what
                    //      handles we're using
                    intColumnHandle = (
                        element.internalResize.resizeColumnHandleIndex
                    );

                    // if the column handle was the first one and the record
                    //      selector is visible, we need to update the record
                    //      selector width
                    if (
                        intColumnHandle === 0 &&
                        recordSelectorVisible === true
                    ) {
                        element.internalResize.resizingRecordSelectors = true;

                    // else, we are updating a column width
                    } else {
                        element.internalResize.resizeColumnIndex = (
                            // to get the column number, start with the handle
                            //      index
                            intColumnHandle +
                            // the handle index is relative to the visible
                            //      column range, so add the fromColumn of the
                            //      current range
                            element.internalDisplay.currentRange.fromColumn
                        ) - (
                            // if the record selector is visible, the column
                            //      handle index is going to be offset by one
                            //      because there is a handle to resize the
                            //      record selectors
                            recordSelectorVisible
                                ? 1
                                : 0
                        );
                    }
                }

                // if we're resizing a record, get record index or type
                if (element.internalResize.resizeRecord) {
                    // to get the record/column indexes, we need to know what
                    //      handles we're using
                    intRecordHandle = (
                        element.internalResize.resizeRecordHandleIndex
                    );

                    // if the record handle was the first one and the header
                    //      is visible, we need to update the header height
                    if (intRecordHandle === 0 && headerVisible === true) {
                        element.internalResize.resizingHeader = true;
                    }
                    //// if the record handle was the last one and the insert
                    ////      record is visible, we need to update the insert
                    ////      record height
                    //} else if (
                    //    intRecordHandle === (
                    //        element.internalDisplay.recordHandles.length - 1
                    //    ) &&
                    //    insertRecordVisible === true
                    //) {
                    //    element.internalResize.resizingInsert = true;
                    //
                    //} else {
                    //    element.internalResize.resizeRecordIndex = (
                    //        // to get the record number, start with the handle
                    //        //      index
                    //        intRecordHandle +
                    //        // the handle index is relative to the visible
                    //        //      record range, so add the fromRecord of the
                    //        //      current range
                    //        element.internalDisplay.currentRange.fromRecord
                    //    ) - (
                    //        // if the header is visible, the column
                    //        //      handle index is going to be offset by one
                    //        //      because there is a handle to resize the
                    //        //      header
                    //        headerVisible
                    //            ? 1
                    //            : 0
                    //    );
                    //}
                }

                // save original scroll location so that if the viewport is
                //      scrolled during a resize, we can do an accurate resize
                element.internalResize.scrollOriginTop = (
                    element.internalScroll.displayTop
                );
                element.internalResize.scrollOriginLeft = (
                    element.internalScroll.displayLeft
                );

                //console.log(
                //    element.internalResize.resizeColumnIndex,
                //    element.internalResize.resizeRecordIndex,
                //    element.internalResize.resizingRecordSelectors,
                //    element.internalResize.resizingHeader,
                //    element.internalResize.resizingInsert
                //);

                // we need to bind the mousemove and mouseup functionality to
                //      the body so that we can still use the mouse events even
                //      if the mouse is no longer over the gs-table
                document.body.addEventListener(
                    evt.mousemove,
                    element.internalEvents.cellResizeDragMove
                );
                document.body.addEventListener(
                    evt.mouseup,
                    element.internalEvents.cellResizeDragEnd
                );
            };

            // there are multiple places where we want to update the position of
            //      the resize lines
            setLineToMouse = function (event) {
                var jsnMousePos;
                var jsnElementPos;
                var intMouseX;
                var intMouseY;
                var viewportWidth;
                var viewportHeight;
                var cellOriginX;
                var cellOriginY;
                var intMaxColWidth;
                var intMaxRowHeight;
                var intMinColWidth;

                var intOriginScrollTop;
                var intOriginScrollLeft;
                var intCurrentScrollTop;
                var intCurrentScrollLeft;

                var intNewWidth;
                var intNewHeight;
                var intNewX;
                var intNewY;

                var intTopBoundery;

                // we need to know the origin and current scroll location in
                //      order to accurately place the resize handle
                intOriginScrollTop = (
                    element.internalResize.scrollOriginTop
                );
                intOriginScrollLeft = (
                    element.internalResize.scrollOriginLeft
                );
                intCurrentScrollTop = (
                    element.internalScroll.displayTop
                );
                intCurrentScrollLeft = (
                    element.internalScroll.displayLeft
                );

                // we need the mouse position and the element position
                jsnMousePos = GS.mousePosition(event);
                jsnElementPos = GS.getElementOffset(
                    element.elems.dataViewport
                );

                // we need to show the user where they'll be resizing to.
                //      so, move the column resize handle to where the
                //      mouse is.
                if (element.internalResize.resizeColumn) {
                    // because we've started the resize, we want the column
                    //      handle to become visible. we'll add the "active"
                    //      class.
                    element.elems.handleColumn.classList.add('active');

                    // we need the mouse X to be relative to the dataViewport
                    intMouseX = (jsnMousePos.left - jsnElementPos.left);

                    // we need to know the maximum column width
                    intMaxColWidth = (
                        element.internalDisplay.maxColumnWidth
                    );

                    // we need to know the minimum column width
                    intMinColWidth = (
                        element.internalDisplay.minColumnWidths[
                            element.internalResize.resizeColumnIndex
                        ]
                    );

                    // we need to know the original X of the column we're
                    //      resizing
                    cellOriginX = element.internalResize.cellOriginX;

                    // we need to know the viewport width
                    viewportWidth = element.elems.dataViewport.clientWidth;

                    // we need to calculate the distance from the original X
                    //      to the new X and then move the new X to an
                    //      appropriate location

                    // we need a width variable separate from the mouse, this'll
                    //      contain the new width and will be adjusted to
                    //      prevent width issues
                    intNewWidth = (
                        // the new true X
                        (
                            intMouseX +
                            intCurrentScrollLeft
                        ) -
                        // subtracted by the old true X
                        (
                            cellOriginX +
                            intOriginScrollLeft
                        )
                    );

                    //console.log(
                    //    cellOriginX, // relative to viewport and old scroll
                    //    intMouseX, // relative to viewport
                    //    intOriginScrollLeft, // old scroll
                    //    intCurrentScrollLeft, // current scroll
                    //    intNewWidth
                    //);

                    // prevent width from going negative the user can't see
                    //      it and shouldn't be able to resize to it
                    if (intNewWidth < 0) {
                        intNewWidth = 0;
                    }

                    // prevent width from going past the max width of the
                    //      viewport the scrolling always keeps the column
                    //      left to the left side of the viewport, so we
                    //      dont want to make the column bigger than the
                    //      viewport
                    if (intNewWidth > (viewportWidth - 10)) {
                        intNewWidth = (viewportWidth - 10);
                    }

                    // prevent column from going wider than max column width
                    if (intNewWidth > intMaxColWidth) {
                        intNewWidth = intMaxColWidth;
                    }

                    // prevent column from being thinner than 10px
                    if (intNewWidth < 10) {
                        intNewWidth = 10;
                    }

                    // prevent column from being thinner minimum column width
                    if (intNewWidth < intMinColWidth) {
                        intNewWidth = intMinColWidth;
                    }

                    // determine new handle X from new width
                    intNewX = (
                        // the new right side
                        (
                            cellOriginX +
                            intOriginScrollLeft +
                            intNewWidth
                        ) -
                        // subtracted by the new scrollLeft
                        (
                            intCurrentScrollLeft
                        )
                    );

                    // refresh handle location
                    element.elems.handleColumn.style.left = (intNewX) + 'px';

                    // save the last X so that the mouseup code doesn't need
                    //      to figure that out
                    element.internalResize.lastX = intNewX;

                    // save the last width so that we don't have to recalculate
                    //      it when the user let's go of the mouse
                    element.internalResize.lastWidth = intNewWidth;
                }

                // we need to show the user where they'll be resizing to.
                //      so, move the record resize handle to where the
                //      mouse is.
                if (element.internalResize.resizeRecord) {
                    // because we've started the resize, we want the record
                    //      handle to become visible. we'll add the "active"
                    //      class.
                    element.elems.handleRecord.classList.add('active');

                    // we need the mouse Y to be relative to the dataViewport
                    intMouseY = (jsnMousePos.top - jsnElementPos.top);

                    // we need to know the maximum record height
                    intMaxRowHeight = (
                        element.internalDisplay.maxRecordHeight
                    );

                    // we need to know the original Y of the record we're
                    //      resizing
                    cellOriginY = element.internalResize.cellOriginY;

                    // we need to know the viewport height
                    viewportHeight = element.elems.dataViewport.clientHeight;

                    // we need to calculate the distance from the original Y
                    //      to the new Y and then move the new Y to an
                    //      appropriate location

                    // we need a height variable separate from the mouse,
                    //      this'll contain the new height and will be
                    //      adjusted to prevent height issues
                    if (element.internalResize.resizingInsert) {
                        intNewHeight = (
                            viewportHeight -
                            intMouseY
                        );

                    } else {
                        intNewHeight = (
                            // the new true Y
                            (
                                intMouseY +
                                intCurrentScrollTop
                            ) -
                            // subtracted by the old true Y
                            (
                                cellOriginY +
                                intOriginScrollTop
                            )
                        );
                    }

                    //console.log(
                    //    cellOriginY, // relative to viewport and old scroll
                    //    intMouseY, // relative to viewport
                    //    intOriginScrollTop, // old scroll
                    //    intCurrentScrollTop, // current scroll
                    //    intNewHeight
                    //);

                    // prevent Y from going past 0,0 on the viewport
                    // the user can't see it and shouldn't be resize to it
                    if (intNewHeight < 0) {
                        intNewHeight = 0;
                    }

                    // prevent Y from going past the max Y of the viewport
                    // the user can't see it and shouldn't be resize to it
                    intTopBoundery = (
                        viewportHeight - (
                            element.internalScrollOffsets.top + 10
                        )
                    );

                    if (intNewHeight > intTopBoundery) {
                        intNewHeight = intTopBoundery;
                    }

                    // if we're not resizing the insert record
                    // prevent record from going taller than max record height
                    if (
                        !element.internalResize.resizingInsert &&
                        intNewHeight > intMaxRowHeight
                    ) {
                        intNewHeight = intMaxRowHeight;
                    }

                    // the user can't resize a record to less than 10px height
                    if (intNewHeight < 10) {
                        intNewHeight = 10;
                    }

                    // determine new handle Y from new height
                    if (element.internalResize.resizingInsert) {
                        //console.log(
                        //    intNewHeight,
                        //    viewportHeight,
                        //    intMaxRowHeight
                        //);
                        intNewY = (
                            viewportHeight -
                            intNewHeight
                        );

                    } else {
                        intNewY = (
                            // the new right side
                            (
                                cellOriginY +
                                intOriginScrollTop +
                                intNewHeight
                            ) -
                            // subtracted by the new scrollLeft
                            (
                                intCurrentScrollTop
                            )
                        );
                    }

                    element.elems.handleRecord.style.top = (intNewY) + 'px';

                    // save the last Y so that the mouseup code doesn't need
                    //      to figure that out
                    element.internalResize.lastY = intNewY;

                    // save the last height so that we don't have to recalculate
                    //      it when the user let's go of the mouse
                    element.internalResize.lastHeight = intNewHeight;
                }
            };

            element.internalEvents.cellResizeDragMove = function (event) {
                var jsnMousePos;
                var jsnElementPos;
                var bolScrollTop;
                var bolScrollLeft;
                var bolScrollRight;
                var bolScrollBottom;
                //var intViewportWidth;
                //var intViewportHeight;
                var colIndex;
                var rowIndex;
                var jsnRange;
                var strScrollDirection;

                // if the mouse moves off of the screen and then is moused up,
                //      we wont know it. so, if the mouse is up (and we're not
                //      on a touch device): preventDefault, stopPropagation and
                //      end the drag session
                if (event.which === 0 && !evt.touchDevice) {
                    event.preventDefault();
                    event.stopPropagation();
                    element.internalEvents.cellResizeDragEnd();

                } else {
                    // the resize has started, update resizeStarted to true so
                    //      that the drag end code knows that a change will be
                    //      made
                    element.internalResize.resizeStarted = true;

                    // we need to know the mouse position and the position of
                    //      the gs-table so that we can do calculations relative
                    //      to the gs-table element
                    jsnMousePos = GS.mousePosition(event);
                    jsnElementPos = GS.getElementOffset(
                        element.elems.dataViewport
                    );

                    //// convenience variables
                    //intViewportWidth = element.elems.dataViewport.clientWidth;
                    //intViewportHeight = (
                    //    element.elems.dataViewport.clientHeight
                    //);

                    // we need to know the column and/or row
                    //      number we are resizing from
                    colIndex = element.internalResize.resizeColumnIndex;
                    rowIndex = element.internalResize.resizeRecordIndex;

                    // we need to know the current visible range of cells
                    jsnRange = (
                        element.internalDisplay.currentRange
                    );

                    // find out what directions to scroll
                    bolScrollTop = (
                        jsnMousePos.top < (
                            // the mouse position is relative to the window
                            //      so we need to account for the left
                            //      offset of the gs-table element
                            jsnElementPos.top +
                            // anything we stick to the left cannot be ordered
                            //      to, so start scrolling at the right side of
                            //      the left offset
                            element.internalScrollOffsets.top
                        )
                    );
                    bolScrollLeft = (
                        jsnMousePos.left < (
                            // the mouse position is relative to the window
                            //      so we need to account for the left
                            //      offset of the gs-table element
                            jsnElementPos.left +
                            // anything we stick to the left cannot be ordered
                            //      to, so start scrolling at the right side of
                            //      the left offset
                            element.internalScrollOffsets.left
                        )
                    );
                    bolScrollRight = (
                        jsnMousePos.left > (
                            (
                                // the mouse position is relative to the window
                                //      so we need to account for the left
                                //      offset of the gs-table element
                                jsnElementPos.left +
                                // we want the right side so we need to take
                                //      into account the width of the gs-table
                                element.elems.dataViewport.clientWidth
                            ) -
                            // anything we stick to the right cannot be ordered
                            //      to, so start scrolling at the beginning of
                            //      the right offset
                            element.internalScrollOffsets.right
                        )
                    );
                    bolScrollBottom = (
                        jsnMousePos.top > (
                            (
                                // the mouse position is relative to the window
                                //      so we need to account for the top
                                //      offset of the gs-table element
                                jsnElementPos.top +
                                // we want the bottom side so we need to take
                                //      into account the height of the gs-table
                                element.elems.dataViewport.clientHeight
                            ) -
                            // anything we stick to the bottom cannot be resized
                            //      past, so start scrolling at the beginning of
                            //      the bottom offset
                            element.internalScrollOffsets.bottom
                        )
                    );

                    // you can't scroll vertically when you're not
                    //      resizing a record
                    if (!element.internalResize.resizeRecord) {
                        bolScrollTop = false;
                        bolScrollBottom = false;
                    }

                    // you can't scroll horizontally when you're not
                    //      resizing a column
                    if (!element.internalResize.resizeColumn) {
                        bolScrollLeft = false;
                        bolScrollRight = false;
                    }

                    // you can't scroll horizontally when you're
                    //      resizing the record selectors
                    if (element.internalResize.resizingRecordSelectors) {
                        bolScrollLeft = false;
                        bolScrollRight = false;
                    }

                    // you can't scroll vertically when you're
                    //      resizing the header or the insert record
                    if (
                        element.internalResize.resizingHeader ||
                        element.internalResize.resizingInsert
                    ) {
                        bolScrollTop = false;
                        bolScrollBottom = false;
                    }

                    // if we are scrolling up and the initial
                    //      record is the last visible record
                    //      (or second last)
                    if (
                        bolScrollTop &&
                        rowIndex === jsnRange.toRecord
                    ) {
                        bolScrollTop = false;
                    }

                    // if we're scrolling left and the initial
                    //      column is the last visible column
                    if (
                        bolScrollLeft &&
                        colIndex === jsnRange.toColumn
                    ) {
                        bolScrollLeft = false;
                    }

                    // if we're scrolling down and the initial
                    //      record is the first visible record
                    if (
                        bolScrollBottom &&
                        rowIndex === jsnRange.fromRecord
                    ) {
                        bolScrollBottom = false;
                    }

                    // if we're scrolling to the right and the
                    //      initial column is the first visible
                    //      column
                    if (
                        bolScrollRight &&
                        colIndex === jsnRange.fromColumn
                    ) {
                        bolScrollRight = false;
                    }

                    //console.log(
                    //    'X:' + jsnMousePos.left,
                    //    'Y:' + jsnMousePos.top,
                    //    bolScrollTop,
                    //    bolScrollLeft,
                    //    bolScrollRight,
                    //    bolScrollBottom
                    //);

                    // if the mouse is to the side of the viewport and scrolling
                    //      hasn't been started already: we want to start
                    //      scrolling on a timer
                    if (
                        (
                            bolScrollTop ||
                            bolScrollLeft ||
                            bolScrollRight ||
                            bolScrollBottom
                        ) &&
                        !element.internalScroll.dragScrolling
                    ) {
                        // start scroll
                        dragScrollStart(
                            element,
                            // drag move callback
                            function () {
                                var bolOldScrollTop;
                                var bolOldScrollLeft;
                                var bolOldScrollBottom;
                                var bolOldScrollRight;

                                // the scroll direction could be changed
                                //      anytime, we need to make sure we're
                                //      up to date
                                strScrollDirection = (
                                    element.internalScroll
                                        .dragScrollingDirection
                                );
                                bolScrollTop = (
                                    strScrollDirection.indexOf('top') !== -1
                                );
                                bolScrollLeft = (
                                    strScrollDirection.indexOf('left') !== -1
                                );
                                bolScrollBottom = (
                                    strScrollDirection.indexOf('bottom') !== -1
                                );
                                bolScrollRight = (
                                    strScrollDirection.indexOf('right') !== -1
                                );

                                // we want to know if a scroll direction was
                                //      changed, so we'll save the old scroll
                                //      booleans
                                bolOldScrollTop = bolScrollTop;
                                bolOldScrollLeft = bolScrollLeft;
                                bolOldScrollBottom = bolScrollBottom;
                                bolOldScrollRight = bolScrollRight;

                                // we need the user to see where the column or
                                //      row will be resized to
                                setLineToMouse(event);

                                // we need to know the current visible range
                                //      of cells
                                jsnRange = (
                                    element.internalDisplay.currentRange
                                );

                                //console.log(
                                //    bolScrollTop,
                                //    rowIndex,
                                //    jsnRange.toRecord
                                //);
                                //console.log(
                                //    bolScrollLeft,
                                //    colIndex,
                                //    jsnRange.toColumn
                                //);
                                //console.log(
                                //    bolScrollBottom,
                                //    rowIndex,
                                //    jsnRange.fromRecord
                                //);
                                //console.log(
                                //    bolScrollRight,
                                //    colIndex,
                                //    jsnRange.fromColumn
                                //);

                                // if we are scrolling up and the initial
                                //      record is the last visible record
                                //      (or second last)
                                if (
                                    bolScrollTop &&
                                    rowIndex === jsnRange.toRecord
                                ) {
                                    bolScrollTop = false;
                                }

                                // if we're scrolling left and the initial
                                //      column is the last visible column
                                if (
                                    bolScrollLeft &&
                                    colIndex === jsnRange.toColumn
                                ) {
                                    bolScrollLeft = false;
                                }

                                // if we're scrolling down and the initial
                                //      record is the first visible record
                                if (
                                    bolScrollBottom &&
                                    rowIndex === jsnRange.fromRecord
                                ) {
                                    bolScrollBottom = false;
                                }

                                // if we're scrolling to the right and the
                                //      initial column is the first visible
                                //      column
                                if (
                                    bolScrollRight &&
                                    colIndex === jsnRange.fromColumn
                                ) {
                                    bolScrollRight = false;
                                }

                               //console.log(
                               //    'bolScrollTop: ' + bolScrollTop
                               //);
                               //console.log(
                               //    'bolScrollLeft: ' + bolScrollLeft
                               //);
                               //console.log(
                               //    'bolScrollBottom: ' + bolScrollBottom
                               //);
                               //console.log(
                               //    'bolScrollRight: ' + bolScrollRight
                               //);

                                // if a scroll direction was stopped
                                if (
                                    bolScrollTop !== bolOldScrollTop ||
                                    bolScrollLeft !== bolOldScrollLeft ||
                                    bolScrollBottom !== bolOldScrollBottom ||
                                    bolScrollRight !== bolOldScrollRight
                                ) {
                                    // if there are any scroll directions left,
                                    //      restart scrolling in that direction
                                    if (
                                        bolScrollTop ||
                                        bolScrollLeft ||
                                        bolScrollRight ||
                                        bolScrollBottom
                                    ) {
                                        // reset scrolling direction
                                        element.internalScroll
                                            .dragScrollingDirection = (
                                                (
                                                    bolScrollTop
                                                        ? 'top'
                                                        : ''
                                                ) +
                                                (
                                                    bolScrollLeft
                                                        ? 'left'
                                                        : ''
                                                ) +
                                                (
                                                    bolScrollRight
                                                        ? 'right'
                                                        : ''
                                                ) +
                                                (
                                                    bolScrollBottom
                                                        ? 'bottom'
                                                        : ''
                                                )
                                            );
                                    } else {
                                        //console.log('RESIZE SCROLL STOPPED');
                                        dragScrollEnd(element);
                                    }
                                }

                                //element.internalResize.lastY
                                //element.internalResize.lastX
                                //element.internalResize.lastWidth
                                //element.internalResize.lastHeight
                                //dragScrollEnd(element);
                            },
                            (
                                (
                                    bolScrollTop
                                        ? 'top'
                                        : ''
                                ) +
                                (
                                    bolScrollLeft
                                        ? 'left'
                                        : ''
                                ) +
                                (
                                    bolScrollRight
                                        ? 'right'
                                        : ''
                                ) +
                                (
                                    bolScrollBottom
                                        ? 'bottom'
                                        : ''
                                )
                            )
                        );

                    // else if the scrolling has started and there are
                    //      directions we want to scroll
                    } else if (
                        element.internalScroll.dragScrolling &&
                        (
                            bolScrollTop ||
                            bolScrollLeft ||
                            bolScrollRight ||
                            bolScrollBottom
                        )
                    ) {
                        strScrollDirection = (
                            element.internalScroll.dragScrollingDirection
                        );

                        // if there is a direction that we want to scroll but
                        //      aren't scrolling right now, we need to add that
                        //      direction to the scroll direction
                        if (
                            bolScrollTop &&
                            strScrollDirection.indexOf('top') === -1
                        ) {
                            strScrollDirection += 'top';
                        }
                        if (
                            bolScrollLeft &&
                            strScrollDirection.indexOf('left') === -1
                        ) {
                            strScrollDirection += 'left';
                        }
                        if (
                            bolScrollRight &&
                            strScrollDirection.indexOf('right') === -1
                        ) {
                            strScrollDirection += 'right';
                        }
                        if (
                            bolScrollBottom &&
                            strScrollDirection.indexOf('bottom') === -1
                        ) {
                            strScrollDirection += 'bottom';
                        }

                        //console.log(
                        //    '1***',
                        //    strScrollDirection,
                        //    element.internalScroll.dragScrollingDirection
                        //);

                        // if we added a scroll direction, update the internal
                        //      storage
                        if (
                            strScrollDirection !==
                                element.internalScroll.dragScrollingDirection
                        ) {
                            //console.log(
                            //    '2***',
                            //    strScrollDirection,
                            //    element.internalScroll.dragScrollingDirection
                            //);
                            element.internalScroll.dragScrollingDirection = (
                                strScrollDirection
                            );
                        }

                        //console.log(
                        //    '3***',
                        //    strScrollDirection,
                        //    element.internalScroll.dragScrollingDirection
                        //);

                    // else if the mouse is NOT to the side of the viewport and
                    //      the scrolling has been started: we want to stop
                    //      scrolling
                    } else if (
                        !bolScrollTop &&
                        !bolScrollLeft &&
                        !bolScrollRight &&
                        !bolScrollBottom &&
                        element.internalScroll.dragScrolling
                    ) {
                        // stop scroll
                        dragScrollEnd(element);
                    }

                    // we need the user to see where the column or row will be
                    //      resized to
                    setLineToMouse(event);

                    //console.log('X:' + intMouseX, 'Y:' + intMouseY);
                }
            };

            element.internalEvents.cellResizeDragEnd = function () {
                var intNew;
                var intIndex;
                var i;
                var len;
                var arrRecordHeights;
                var arrSelectedColumns;
                var arrColumnWidths;
                var arrColumns;


                var colsToResize = [];
                var selectedBroken = false;
                //console.log(arrSelectedColumns);
                //console.log(
                //    element.internalSelection.rows[0]
                //    , ', header'
                //);
                if (element.internalSelection.rows[0] ===
                    'header'
                ) {
                    //console.log(
                    //    element.internalSelection.ranges.length
                    //    , ', > 0'
                   // );
                    if (element.internalSelection.ranges.length
                        > 0
                    ) {
                        var jsnFirstRange = (
                            element.internalSelection.ranges[0]
                        );
                        var intSelectionLength;
                        var strStartColumn = jsnFirstRange.start.column;
                        var strEndColumn = jsnFirstRange.end.column;
                        var intStartColumn = parseInt(
                            (
                                strStartColumn === 'selector'
                                    ? 0
                                    : strStartColumn
                            ),
                            10
                        );
                        var intEndColumn = parseInt(
                            (
                                strEndColumn === 'selector'
                                    ? 0
                                    : strEndColumn
                            ),
                            10
                        );

                        if (jsnFirstRange.start.row === 'header') {
                            if (
                                strStartColumn === 'selector' &&
                                strEndColumn === 'selector'
                            ) {
                                intSelectionLength = (
                                    element.internalSelection.columns.length - 2
                                );
                            } else if (intStartColumn < intEndColumn) {
                                selectedBroken = true;
                                intSelectionLength = (
                                    (intStartColumn + 1) - intEndColumn
                                );
                            } else {
                                selectedBroken = false;
                                intSelectionLength = (
                                    (intEndColumn + 1) - intStartColumn
                                );
                            }
                            if (intSelectionLength === 0) {
                                intSelectionLength = 1;
                            }

                            i = 0;
                            while (i < intSelectionLength) {
                                if (selectedBroken) {
                                    colsToResize.push(
                                        i + intEndColumn
                                    );
                                } else {
                                    colsToResize.push(
                                        i + intStartColumn
                                    );
                                }

                                i += 1;
                            }
                        }
                    }

                }
                colsToResize.push(element.internalResize.resizeColumnIndex);
                //console.log(colsToResize);

                // if scrolling is running, stop it because we are done with
                //      the mouse part of the resize action
                if (element.internalScroll.dragScrolling) {
                    dragScrollEnd(element);
                }

                // because we've ended the resize, we want the column
                //      handle to become invisible. we'll remove the
                //      "active" class.
                element.elems.handleColumn.classList.remove('active');

                // because we've ended the resize, we want the record
                //      handle to become invisible. we'll remove the
                //      "active" class.
                element.elems.handleRecord.classList.remove('active');

                // if the column resize handle exists and was moved:
                //      apply column resize
                if (
                    element.internalResize.resizeColumn &&
                    element.internalResize.resizeStarted
                ) {
                    // calculate the new width based on the origin X and the
                    //      last X the mouse was at
                    intNew = (element.internalResize.lastWidth);

                    // if we're resizing the record selector column
                    if (element.internalResize.resizingRecordSelectors) {
                        element.internalDisplay.recordSelectorWidth = intNew;

                    // else, we are updating a column width
                    } else {
                        // get the index of the column that was resized
                        intIndex = (
                            element.internalResize.resizeColumnIndex
                        );

                        // we need to know the selected columns so that we can
                        //      check to see if the resized column was selected
                        // convenience variable
                // // arrSelectedColumns = element.internalSelection.columns;
                        // // arrSelectedColumns = (
                        // //     arrSelectedColumns.slice(
                        // //         arrSelectedColumns[0] === 'selector'
                        // //             ? 1
                        // //             : 0
                        // //     )
                        // // );

                        // convenience variable
                        arrColumnWidths = (
                            element.internalDisplay.columnWidths
                        );
                        //console.log(colsToResize);
                        // if the column we resized was seleced, resize any
                        //      columns that are selected and connected to it
                        if (colsToResize.indexOf(intIndex) > -1) {
                            arrColumns = (
                                getConnectedSelectedColumns(element, intIndex)
                            );

                            i = 0;
                            len = colsToResize.length;
                            while (i < len) {
                                arrColumnWidths[colsToResize[i]] = intNew;
                                //[arrColumns[i]] = intNew;

                                i += 1;
                            }
                        } else {
                            // set new width
                            arrColumnWidths[intIndex] = intNew;
                        }
                    }
                }

                // if the record resize handle exists and was moved:
                //      apply record resize
                if (
                    element.internalResize.resizeRecord &&
                    element.internalResize.resizeStarted
                ) {
                    // calculate the new height based on the origin Y and the
                    //      last Y the mouse was at
                    intNew = (element.internalResize.lastHeight);

                    // if we're resizing the header
                    if (element.internalResize.resizingHeader) {
                        element.internalDisplay.headerHeight = intNew;

                    //// if we're resizing the insert record
                    //} else if (element.internalResize.resizingInsert) {
                    //    element.internalDisplay.insertRecordHeight = intNew;

                    // else, resizing a regular row
                    } else {
                        // resize all records
                        arrRecordHeights = (
                            element.internalDisplay.recordHeights
                        );
                        i = 0;
                        len = arrRecordHeights.length;
                        while (i < len) {
                            arrRecordHeights[i] = intNew;
                            i += 1;
                        }

                        if (element.internalDisplay.insertRecordVisible) {
                            element.internalDisplay.insertRecordHeight = intNew;
                        }
                    }
                }

                // if a handle drag occured:
                if (element.internalResize.resizeStarted) {
                    // re-render so that the user can see the cells in their
                    //      new sizes
                    // we re-render the scroll dimensions because the cell
                    //      resize might affect the scroll width or height
                    renderScrollDimensions(element);
                }

                // we need to let everything know that we are no longer
                //      resizing cells
                element.internalResize.currentlyResizing = false;

                // unbind mousemove and mouseup
                document.body.removeEventListener(
                    evt.mousemove,
                    element.internalEvents.cellResizeDragMove
                );
                document.body.removeEventListener(
                    evt.mouseup,
                    element.internalEvents.cellResizeDragEnd
                );
            };

            // bind the same drag start to the record and column elements so
            //      that if either one is mousedown'ed on, the cell resize
            //      starts
            element.elems.handleColumn.addEventListener(
                evt.mousedown,
                element.internalEvents.cellResizeDragStart
            );
            element.elems.handleRecord.addEventListener(
                evt.mousedown,
                element.internalEvents.cellResizeDragStart
            );

            // we want to resize the selected records/columns back to their
            //      default sizes if the handle is double-clicked
            element.internalEvents.cellResizeToDefault = function () {
                //var intIndex;
                var intNew;
                var i;
                var len;
                var arrRecordHeights;
                var arrSelectedColumns;
                //var arrColumnWidths;
                //var arrColumns;

                // we need to be able to resize all selected records/columns,
                //      if the handle you double click touches a selected
                //      cell: resize all selected cells to default
                // ### NEED CODING ###

                // if the column resize handle exists: apply column resize
                if (element.internalResize.resizeColumn) {
                    // if the column handle was the first one and the record
                    //      selector is visible, we need to update the record
                    //      selector width
                    if (element.internalResize.resizingRecordSelectors) {
                        element.internalDisplay.recordSelectorWidth = (
                            element.internalDisplay.defaultRecordSelectorWidth
                        );

                    // else, we are updating a column width
                    } else {
                        //// get the index of the column that was resized
                        //intIndex = (
                        //    element.internalResize.resizeColumnIndex
                        //);

                        // we need to know the selected columns so that we can
                        //      check to see if the resized column was selected
                        // convenience variable
                        arrSelectedColumns = element.internalSelection.columns;
                        arrSelectedColumns = (
                            arrSelectedColumns.slice(
                                arrSelectedColumns[0] === 'selector'
                                    ? 1
                                    : 0
                            )
                        );

                        var colsToResize = [];
                        var selectedBroken = false;
                        var jsnFirstRange;
                        var strStartColumn;
                        var strEndColumn;
                        var intStartColumn;
                        var intEndColumn;
                        var intSelectionLength;

                        if (element.internalSelection.rows[0] ===
                            'header'
                        ) {
                            if (
                                element.internalSelection.ranges.length > 0
                            ) {
                                jsnFirstRange = (
                                    element.internalSelection.ranges[0]
                                );
                                strStartColumn = jsnFirstRange.start.column;
                                strEndColumn = jsnFirstRange.end.column;
                                intStartColumn = (
                                    parseInt(
                                        (
                                            strStartColumn === 'selector'
                                                ? 0
                                                : strStartColumn
                                        ),
                                        10
                                    )
                                );
                                intEndColumn = (
                                    parseInt(
                                        (
                                            strEndColumn === 'selector'
                                                ? 0
                                                : strEndColumn
                                        ),
                                        10
                                    )
                                );

                                if (jsnFirstRange.start.row === 'header') {
                                    if (
                                        strStartColumn === 'selector' &&
                                        strEndColumn === 'selector'
                                    ) {
                                        intSelectionLength = (
                                            element.internalSelection
                                                .columns
                                                .length - 2
                                        );
                                    } else if (intStartColumn < intEndColumn) {
                                        selectedBroken = true;
                                        intSelectionLength = (
                                            (intStartColumn + 1) - intEndColumn
                                        );
                                    } else {
                                        selectedBroken = false;
                                        intSelectionLength = (
                                            (intEndColumn + 1) - intStartColumn
                                        );
                                    }
                                    if (intSelectionLength === 0) {
                                        intSelectionLength = 1;
                                    }

                                    i = 0;
                                    while (i < intSelectionLength) {
                                        if (selectedBroken) {
                                            colsToResize.push(
                                                i + intEndColumn
                                            );
                                        } else {
                                            colsToResize.push(
                                                i + intStartColumn
                                            );
                                        }

                                        i += 1;
                                    }
                                }
                            }
                        }
                        colsToResize.push(
                            element.internalResize.resizeColumnIndex
                        );

                        //console.log(colsToResize);
                        resizeColumnsToContent(element, colsToResize);



                        //// convenience variable
                        //arrColumnWidths = (
                        //    element.internalDisplay.columnWidths
                        //);

                        //// if the column we resized was seleced, resize any
                        ////      columns that are selected and connected to it
                        //if (arrSelectedColumns.indexOf(intIndex) > -1) {
                        //    arrColumns = (
                        //        getConnectedSelectedColumns(element, intIndex)
                        //    );

                        //    i = 0;
                        //    len = arrColumns.length;
                        //    while (i < len) {
                        //        arrColumnWidths[arrColumns[i]] = (
                        //            element.internalDisplay
                        //                .defaultColumnWidths[arrColumns[i]]
                        //        );
                        //        i += 1;
                        //    }
                        //} else {
                        //    // set new width
                        //    arrColumnWidths[intIndex] = (
                        //        element.internalDisplay
                        //            .defaultColumnWidths[intIndex]
                        //    );
                        //}
                    }
                }

                // if the record resize handle exists: apply record resize
                if (element.internalResize.resizeRecord) {
                    // if we double-clicked the header
                    if (element.internalResize.resizingHeader) {
                        element.internalDisplay.headerHeight = (
                            element.internalDisplay.defaultHeaderHeight
                        );

                    //// if we double-clicked the insert record
                    //} else if (element.internalResize.resizingInsert) {
                    //    element.internalDisplay.insertRecordHeight = (
                    //        element.internalDisplay.defaultInsertRecordHeight
                    //    );

                    } else {
                        // resize all records
                        intNew = (
                            element.internalDisplay.defaultRecordHeight
                        );
                        arrRecordHeights = (
                            element.internalDisplay.recordHeights
                        );
                        i = 0;
                        len = arrRecordHeights.length;
                        while (i < len) {
                            arrRecordHeights[i] = intNew;
                            i += 1;
                        }

                        if (element.internalDisplay.insertRecordVisible) {
                            element.internalDisplay.insertRecordHeight = (
                                element.internalDisplay
                                    .defaultInsertRecordHeight
                            );
                        }
                    }
                }

                // remove the handles from the viewport because a partial render
                //      doesn't remove them
                if (element.internalResize.resizeColumn) {
                    element.elems.dataViewport.removeChild(
                        element.elems.handleColumn
                    );
                }
                if (element.internalResize.resizeRecord) {
                    element.elems.dataViewport.removeChild(
                        element.elems.handleRecord
                    );
                }

                // re-render so that the user can see the cells in their new
                //      sizes
                // we re-render the scroll dimensions because the cell resize
                //      might affect the scroll width or height
                renderScrollDimensions(element);
            };

            // bind the same resize to default to the record and column handles
            //      so that if either one is double-clicked on, the cell resize
            //      is triggered
            element.elems.handleColumn.addEventListener(
                'dblclick',
                element.internalEvents.cellResizeToDefault
            );
            element.elems.handleRecord.addEventListener(
                'dblclick',
                element.internalEvents.cellResizeToDefault
            );
        }
    }

    // ############# COLUMN REORDER EVENTS #############
    function unbindColumnReorder(element) {
        if (!evt.touchDevice) {
            element.elems.dataViewport.removeEventListener(
                'mousedown',
                element.internalEvents.columnReorderDragStart
            );
        }
    }
    function bindColumnReorder(element) {
        var setLineToMouse;

        if (!evt.touchDevice) {
            // we want to take the mouse position and add a line to the closest
            //      column line, we do this on mousedown and on mousemove, so
            //      we'll create a function to handle that
            setLineToMouse = function (event) {
                var jsnMousePos;
                var jsnElementPos;
                var arrColumnHandles;
                var intMouse;
                var intPrevHandle;
                var intCurrentHandle;
                var intPrevIndex;
                var intCurrentIndex;
                var intHandleIndex;
                var intInsertionIndex;
                var i;
                var len;

                // we need the mouse position
                jsnMousePos = GS.mousePosition(event);

                // we need the element position because the mouse position is
                //      not relative to element
                jsnElementPos = GS.getElementOffset(
                    element.elems.dataViewport
                );

                // we need the locations where a column can be moved to
                arrColumnHandles = (
                    element.internalDisplay.columnHandles
                );

                // we need the mouse left position relative to the gs-table
                intMouse = (
                    jsnMousePos.left - jsnElementPos.left
                );

                // we need to find the correct insertion points
                if (
                    element.internalScroll.dragScrolling &&
                    element.internalScroll.dragScrollingDirection === 'left'
                ) {
                    // get first non-null handle
                    i = 0;
                    len = arrColumnHandles.length;
                    while (i < len) {
                        if (arrColumnHandles[i] !== null) {
                            intHandleIndex = i;
                            break;
                        }
                        i += 1;
                    }

                } else if (
                    element.internalScroll.dragScrolling &&
                    element.internalScroll.dragScrollingDirection === 'left'
                ) {
                    // get last non-null handle
                    i = (arrColumnHandles.length - 1);
                    while (i >= 0) {
                        if (arrColumnHandles[i] !== null) {
                            intHandleIndex = i;
                            break;
                        }
                        i -= 1;
                    }

                } else {
                    // we need to find out what handle the mouse is closest to
                    //      BEWARE, hidden columns have null as their handle.
                    //      we need to work around null column handles
                    intPrevHandle = null;
                    intCurrentHandle = null;
                    intPrevIndex = null;
                    intCurrentIndex = null;
                    intHandleIndex = null;
                    i = 0;
                    len = arrColumnHandles.length;
                    while (i < len) {
                        if (arrColumnHandles[i] !== null) {
                            intCurrentHandle = arrColumnHandles[i];
                            intCurrentIndex = i;
                        }

                        if (
                            intPrevHandle !== null &&
                            intCurrentHandle !== null
                        ) {
                            if (
                                intMouse >= intPrevHandle &&
                                intMouse <= intCurrentHandle
                            ) {
                                if (
                                    // if the mouse is closer to the right
                                    (intCurrentHandle - intMouse) <
                                        (intMouse - intPrevHandle)
                                ) {
                                    intHandleIndex = intCurrentIndex;

                                // else, the handle is the left handle
                                } else {
                                    intHandleIndex = intPrevIndex;
                                }
                            } else if (i === (len - 1)) {
                                if (intMouse >= intCurrentHandle) {
                                    intHandleIndex = intCurrentIndex;
                                } else {
                                    intHandleIndex = intPrevIndex;
                                }
                            }
                        } else if (
                            intCurrentHandle !== null &&
                            intMouse <= intCurrentHandle
                        ) {
                            intHandleIndex = intCurrentIndex;
                        }

                        if (intHandleIndex !== null) {
                            break;
                        }

                        if (intCurrentHandle !== null) {
                            intPrevHandle = intCurrentHandle;
                            intPrevIndex = intCurrentIndex;
                        }

                        i += 1;
                    }
                }
                //console.log(
                //    intMouse,
                //    intPrevHandle,
                //    intPrevIndex,
                //    intCurrentHandle,
                //    intCurrentIndex,
                //    intHandleIndex,
                //    element.internalDisplay.currentRange.fromColumn
                //);

                // the handle list only contains the visible column
                //      list so, we have to add the first visible
                //      column's number to the handle index
                intInsertionIndex = (
                    intHandleIndex +
                    element.internalDisplay.currentRange.fromColumn
                );

                //console.log(
                //    intScroll,
                //    intMouse,
                //    intViewportWidth,
                //    intHandleIndex,
                //    intInsertionIndex
                //);

                // sometimes, this function will be called while the reorder
                //      indicator is not in the DOM, if it isn't, append it to
                //      the dataViewport
                if (
                    element.elems.handleReorder.parentNode !==
                        element.elems.dataViewport
                ) {
                    element.elems.dataViewport.appendChild(
                        element.elems.handleReorder
                    );
                }

                // we need to update the position of the line
                element.elems.handleReorder.style.left = (
                    (
                        arrColumnHandles[intHandleIndex]
                    ) + 'px'
                );

                // we need to keep track of the drop location
                element.internalReorder.dropLocation = intInsertionIndex;
            };

            // when dragging, just show a line where you'll resize to, instead
            //      of changing the size and re-rendering multiple times in a
            //      row
            element.internalEvents.columnReorderDragStart = function (event) {
                var target;
                var parentCell;
                var intColNumber;
                var arrCurrentColumns;

                // we only want to reorder if the drag originates from a header
                //      cell that is selected
                target = event.target;
                if (parentCell && parentCell.nodeName !== 'GS-CELL') {
                    parentCell = GS.findParentElement(target, 'gs-cell');
                } else {
                    parentCell = target;
                }

                if (
                    parentCell &&
                    parentCell.nodeName === 'GS-CELL' &&
                    parentCell.classList.contains('table-header') &&
                    parentCell.hasAttribute('selected') &&
                    // only reorder when the left mouse button is down
                    event.which === 1
                ) {
                    // we need to let everything know that we are reordering,
                    //      this is used to prevent cell selection during column
                    //      reorder
                    element.internalReorder.currentlyReordering = true;

                    // there are some things in the drag end code that we only
                    //      want to run if the mouse has moved (and therefore
                    //      started reordering), so here we default the
                    //      reorderStarted to false and after mousemove it'll
                    //      be set to true
                    element.internalReorder.reorderStarted = false;

                    // we need to know what columns we're dragging, so we'll
                    //      take the column number and grab any column numbers
                    //      that are contiguous

                    // get number of the column we selected
                    intColNumber = parseInt(
                        parentCell.getAttribute('data-col-number'),
                        10
                    );
                    //console.log('column', intColNumber);

                    // clear current columns array so that we can start fresh
                    arrCurrentColumns = (
                        getConnectedSelectedColumns(element, intColNumber)
                    );

                    //console.log(arrSelection, arrCurrentColumns);

                    // we want the drag move and drag end functions to know what
                    //      columns are being reordered, so we'll save the array
                    //      to the internal storage
                    element.internalReorder.currentColumns = arrCurrentColumns;

                    // we want to know what column was the column that the user
                    //      initiated the drag on
                    element.internalReorder.originColumn = intColNumber;

                    // we want to know if a drop location was chosen, so we'll
                    //      clear out the old drop location and that way all
                    //      we'll have to do is test for null
                    element.internalReorder.dropLocation = null;

                    // sometimes, the user has other columns selected, let's
                    //      reset the selection to be the columns the user is
                    //      reordering
                    element.internalSelection.ranges = [
                        {
                            "start": {
                                "row": "header",
                                "column": arrCurrentColumns[0]
                            },
                            "end": {
                                "row": "header",
                                "column": arrCurrentColumns[
                                    arrCurrentColumns.length - 1
                                ]
                            },
                            "negator": false
                        }
                    ];

                    // re-render the select to show the user the change
                    renderSelection(element);

                    // we need the user to see where the column will be dropped
                    setLineToMouse(event);

                    // we need to bind the mousemove and mouseup functionality
                    //      to the body so that we can still use the mouse
                    //      events even if the mouse is no longer over the
                    //      gs-table
                    document.body.addEventListener(
                        evt.mousemove,
                        element.internalEvents.columnReorderDragMove
                    );
                    document.body.addEventListener(
                        evt.mouseup,
                        element.internalEvents.columnReorderDragEnd
                    );
                }
            };

            element.internalEvents.columnReorderDragMove = function (event) {
                var jsnMousePos;
                var jsnElementPos;
                var bolScrollLeft;
                var bolScrollRight;

                // if the mouse moves off of the screen and then is moused up,
                //      we wont know it. so, if the mouse is up (and we're not
                //      on a touch device): preventDefault, stopPropagation and
                //      end the drag session
                if (event.which === 0 && !evt.touchDevice) {
                    event.preventDefault();
                    event.stopPropagation();
                    element.internalEvents.columnReorderDragEnd();

                } else {
                    // the resize has started, update resizeStarted to true so
                    //      that the drag end code knows that a change will be
                    //      made
                    element.internalReorder.reorderStarted = true;

                    // we need to know the mouse position and the position of
                    //      the gs-table so that we can do calculations relative
                    //      to the gs-table element
                    jsnMousePos = GS.mousePosition(event);
                    jsnElementPos = GS.getElementOffset(
                        element.elems.dataViewport
                    );

                    // find out what directions to scroll
                    bolScrollLeft = (
                        jsnMousePos.left < (
                            // the mouse position is relative to the window
                            //      so we need to account for the left
                            //      offset of the gs-table element
                            jsnElementPos.left +
                            // anything we stick to the left cannot be ordered
                            //      to, so start scrolling at the right side of
                            //      the left offset
                            element.internalScrollOffsets.left
                        )
                    );
                    bolScrollRight = (
                        jsnMousePos.left > (
                            (
                                // the mouse position is relative to the window
                                //      so we need to account for the left
                                //      offset of the gs-table element
                                jsnElementPos.left +
                                // we want the right side so we need to take
                                //      into account the width of the gs-table
                                element.elems.dataViewport.clientWidth
                            ) -
                            // anything we stick to the right cannot be ordered
                            //      to, so start scrolling at the beginning of
                            //      the right offset
                            element.internalScrollOffsets.right
                        )
                    );

                    //console.log(
                    //    'X:' + intMouseX,
                    //    bolScrollLeft,
                    //    bolScrollRight
                    //);

                    // if the mouse is to the side of the viewport and scrolling
                    //      hasn't been started already: we want to start
                    //      scrolling on a timer
                    if (
                        (bolScrollLeft || bolScrollRight) &&
                        !element.internalScroll.dragScrolling
                    ) {
                        // start scroll
                        dragScrollStart(
                            element,
                            // drag move callback
                            function () {
                                // we need the user to see where the
                                //      column will be dropped
                                setLineToMouse(event);
                            },
                            (
                                bolScrollLeft
                                    ? 'left'
                                    : 'right'
                            )
                        );

                    // else if the mouse is NOT to the side of the viewport and
                    //      the scrolling has been started: we want to stop
                    //      scrolling
                    } else if (
                        !bolScrollLeft &&
                        !bolScrollRight &&
                        element.internalScroll.dragScrolling
                    ) {
                        // stop scroll
                        dragScrollEnd(element);
                    }

                    // we need the user to see where the column will be dropped
                    setLineToMouse(event);
                }
            };

            element.internalEvents.columnReorderDragEnd = function () {
                var arrOrderCols;
                var intDropIndex;
                var headerTemplate;
                var recordTemplate;
                var insertTemplate;
                var arrOldHeaderTemplate;
                var arrOldRecordTemplate;
                var arrOldInsertTemplate;
                var arrOldPlainText;
                var arrOldDataCol;
                var arrOldColWidths;
                var arrOldDefaultColWidths;
                var arrOldCopyHeaders;
                var arrOldCopyCol;
                var strNewHeaderTemplate;
                var strNewRecordTemplate;
                var strNewInsertTemplate;
                var arrNewPlainText;
                var arrNewDataCol;
                var arrNewColWidths;
                var arrNewDefaultColWidths;
                var arrNewCopyHeaders;
                var arrNewCopyCol;

                var i;
                var len;
                var intSeqIndex;
                var unmovedColumns;
                var pullIndex;

                var index;
                var strSort;
                var strColumn;
                var strOldSortOrder;
                var strNewSortOrder;

                // when reordering columns, we put a line into the viewport to
                //      indicate where the columns will be put. so, we need to
                //      remove the line
                if (
                    element.elems.handleReorder.parentNode ===
                        element.elems.dataViewport
                ) {
                    element.elems.dataViewport.removeChild(
                        element.elems.handleReorder
                    );
                }

                // if scrolling is running, stop it because we are done with
                //      the mouse part of the reorder action
                if (element.internalScroll.dragScrolling) {
                    dragScrollEnd(element);
                }

                // save drop index to a variable for convenience
                intDropIndex = (
                    element.internalReorder.dropLocation
                );

                // we need to know what columns we are moving to the
                //      drop index
                arrOrderCols = (
                    element.internalReorder.currentColumns
                );

                // if the user clicks instead of dragging, we'll select the
                //      column
                if (!element.internalReorder.reorderStarted) {
                    element.internalSelection.ranges = [
                        {
                            "start": {
                                // reorder functionality assumes the presence of
                                //      headers
                                "row": "header",
                                "column": element.internalReorder.originColumn
                            },
                            "end": {
                                // reorder functionality assumes the presence of
                                //      headers
                                "row": "header",
                                "column": element.internalReorder.originColumn
                            },
                            "negator": false
                        }
                    ];
                    renderSelection(element);
                }

                //console.log(
                //    'should we reorder?',
                //    element.internalReorder.reorderStarted,
                //    intDropIndex,
                //    arrOrderCols,
                //    arrOrderCols.length,
                //    element.internalDisplay.columnWidths.length
                //);
                if (
                    // if a drag occurred
                    element.internalReorder.reorderStarted &&
                    // and the drop index is not null, undefined or NaN
                    intDropIndex !== null &&
                    intDropIndex !== undefined &&
                    !isNaN(intDropIndex) &&
                    // and there are columns to order
                    arrOrderCols.length > 0 &&
                    // and the drop index is not past the max
                    intDropIndex <= (
                        element.internalDisplay.columnWidths.length
                    ) &&
                    // and the drop index is not at any of the indexes
                    //      the order columns are located at
                    arrOrderCols.indexOf(intDropIndex) === -1 &&
                    // and the drop index is not at the right side of
                    //      the last column in the order column list
                    arrOrderCols.indexOf(intDropIndex - 1) === -1
                ) {
                    // gotta reorder the templates, widths, and everything
                    //      else that we store about display columns

                    // here's the list of items to sort:
                    //      element.internalTemplates
                    //          header               <- element template
                    //          record               <- element template
                    //          insertRecord         <- element template
                    //      element.internalDisplay
                    //          columnPlainTextNames <- array
                    //          dataColumnName       <- array
                    //          columnWidths         <- array
                    //          defaultColumnWidths  <- array
                    //      element.internalClip
                    //          headerList           <- array
                    //          columnList           <- array


                    // we need to reorder the templates, in order to do
                    //      this we'll need access to their elements. the
                    //      templates are stored as strings and so we must
                    //      create template elements to put the content in
                    // put the template HTML into the template elements so
                    //      that we have access to the elements

                    if (element.internalTemplates.header) {
                        headerTemplate = document.createElement('template');
                        headerTemplate.innerHTML = (
                            element.internalTemplates.header
                        );
                        arrOldHeaderTemplate = (
                            xtag.query(headerTemplate.content, 'gs-cell')
                        );
                    }

                    if (element.internalTemplates.originalRecord) {
                        recordTemplate = document.createElement('template');
                        recordTemplate.innerHTML = (
                            element.internalTemplates.originalRecord
                        );
                        arrOldRecordTemplate = (
                            xtag.query(recordTemplate.content, 'gs-cell')
                        );
                    }

                    if (element.internalTemplates.insertRecord) {
                        insertTemplate = document.createElement('template');
                        insertTemplate.innerHTML = (
                            element.internalTemplates.insertRecord
                        );
                        arrOldInsertTemplate = (
                            xtag.query(insertTemplate.content, 'gs-cell')
                        );
                    }

                    // gather column arrays for easy access
                    arrOldPlainText = (
                        element.internalDisplay.columnPlainTextNames
                    );
                    arrOldDataCol = (
                        element.internalDisplay.dataColumnName
                    );
                    arrOldColWidths = (
                        element.internalDisplay.columnWidths
                    );
                    arrOldDefaultColWidths = (
                        element.internalDisplay.defaultColumnWidths
                    );

                    if (
                        element.internalClip.headerList &&
                        element.internalClip.headerList.length > 0
                    ) {
                        arrOldCopyHeaders = (
                            element.internalClip.headerList
                        );
                    }

                    if (
                        element.internalClip.columnList &&
                        element.internalClip.columnList.length > 0
                    ) {
                        arrOldCopyCol = (
                            element.internalClip.columnList
                        );
                    }

                    // create new arrays to hold the sorted lists
                    strNewHeaderTemplate = '';
                    strNewRecordTemplate = '';
                    strNewInsertTemplate = '';
                    arrNewPlainText = [];
                    arrNewDataCol = [];
                    arrNewColWidths = [];
                    arrNewDefaultColWidths = [];
                    arrNewCopyHeaders = [];
                    arrNewCopyCol = [];

                    // now begins the sort

                    // because all of the display column arrays must be the same
                    //      length, we can use one loop for all of the arrays

                    // we're going to loop through the column arrays and build
                    //      up the new, sorted arrays/strings

                    //console.log('##########################################');
                    //console.log('##########################################');
                    //console.log('##########################################');
                    //console.log('old header:    ', arrOldHeaderTemplate);
                    //console.log('old record:    ', arrOldRecordTemplate);
                    //console.log('old insert:    ', arrOldInsertTemplate);
                    //console.log('old plainTXT:  ', arrOldPlainText);
                    //console.log('old dataName:  ', arrOldDataCol);
                    //console.log('old width:     ', arrOldColWidths);
                    //console.log('old def width: ', arrOldDefaultColWidths);
                    //console.log('##########################################');
                    //console.log('##########################################');
                    //console.log('##########################################');

                    // we need a sequential number that is not tied to "i"
                    intSeqIndex = 0;

                    // we need a consumable column list so that we'll know we've
                    //      moved everything once the column list is empty
                    unmovedColumns = arrOrderCols.slice(0);

                    i = 0;
                    len = arrOldColWidths.length;
                    while (i < len) {
                        // because we are sorting by appending elements from
                        //      various points in the old array to the end of
                        //      the new arrays/strings, we need to determine
                        //      what index we are pulling from the old arrays.
                        //      this index will not be sequential like "i" will
                        //      be.
                        // there are two possibilities:
                        //      we sort the columns to the left
                        //      we sort the columns to the right
                        // in the case of a left sort:
                        //      we need to be sequential until we reach the drop
                        //      index, in which case we need to read the indexes
                        //      of the arrOrderCols array sequentially and then
                        //      we go back to where we left off until we reach
                        //      the first arrOrderCols value, in which case we
                        //      need to jump to the column after the last column
                        //      in arrOrderCols and continue until we reach the
                        //      end
                        // in the case of a right sort:
                        //      we need to be sequential until we reach the
                        //      first column in arrOrderCols, in which case we
                        //      skip to the column after the last column in
                        //      arrOrderCols and continue from there until we
                        //      reach the drop index, in which case we need to
                        //      read the indexes of the arrOrderCols array
                        //      sequentially and then we go back to where we
                        //      left off until we reach the end

                        //console.log(
                        //    '1***',
                        //    intSeqIndex,
                        //    intDropIndex,
                        //    unmovedColumns,
                        //    arrOrderCols
                        //);
                        // if we have reached the drop index and there
                        //      are order columns left
                        if (
                            intSeqIndex === intDropIndex &&
                            unmovedColumns.length > 0
                        ) {
                            //console.log('2.1*');
                            // grab and remove first order column index
                            pullIndex = unmovedColumns.shift();

                        // if we have reached the first column of
                        //      arrOrderCols
                        } else if (intSeqIndex === arrOrderCols[0]) {
                            //console.log('2.2*');
                            intSeqIndex += (arrOrderCols.length);
                            pullIndex = intSeqIndex;
                            intSeqIndex += 1;

                        // else, continue through column list
                        } else {
                            //console.log('2.3*');
                            pullIndex = intSeqIndex;
                            intSeqIndex += 1;
                        }
                        //console.log('3***', pullIndex);

                        // make the append to the new arrays/strings
                        if (arrOldHeaderTemplate) {
                            strNewHeaderTemplate += (
                                arrOldHeaderTemplate[pullIndex].outerHTML
                            );
                        }
                        if (arrOldRecordTemplate) {
                            strNewRecordTemplate += (
                                arrOldRecordTemplate[pullIndex].outerHTML
                            );
                        }
                        if (arrOldInsertTemplate) {
                            strNewInsertTemplate += (
                                arrOldInsertTemplate[pullIndex].outerHTML
                            );
                        }
                        arrNewPlainText.push(
                            arrOldPlainText[pullIndex]
                        );
                        arrNewDataCol.push(
                            arrOldDataCol[pullIndex]
                        );
                        arrNewColWidths.push(
                            arrOldColWidths[pullIndex]
                        );
                        arrNewDefaultColWidths.push(
                            arrOldDefaultColWidths[pullIndex]
                        );
                        arrNewCopyHeaders.push(
                            arrOldCopyHeaders[pullIndex]
                        );
                        arrNewCopyCol.push(
                            arrOldCopyCol[pullIndex]
                        );

                        i += 1;
                    }

                    // there's a lot of stuff that has to happen, so we need a
                    //      lot of logging
                    //console.log('##########################################');
                    //console.log('##########################################');
                    //console.log('##########################################');
                    //console.log(
                    //    'reorder columns:',
                    //    arrOrderCols
                    //);
                    //console.log(
                    //    'to location:',
                    //    intDropIndex,
                    //    '(resolved location: ' + intResolvedDropIndex + ')'
                    //);
                    //console.log('##########################################');
                    //console.log('##########################################');
                    //console.log('##########################################');
                    //console.log('old header:    ', arrOldHeaderTemplate);
                    //console.log('new header:    ', strNewHeaderTemplate);

                    //console.log('old record:    ', arrOldRecordTemplate);
                    //console.log('new record:    ', strNewRecordTemplate);

                    //console.log('old insert:    ', arrOldInsertTemplate);
                    //console.log('new insert:    ', strNewInsertTemplate);

                    //console.log('old plainTXT:  ', arrOldPlainText);
                    //console.log('new plainTXT:  ', arrNewPlainText);

                    //console.log('old dataName:  ', arrOldDataCol);
                    //console.log('new dataName:  ', arrNewDataCol);

                    //console.log('old width:     ', arrOldColWidths);
                    //console.log('new width:     ', arrNewColWidths);

                    //console.log('old def width: ', arrOldDefaultColWidths);
                    //console.log('new def width: ', arrNewDefaultColWidths);
                    //console.log('##########################################');
                    //console.log('##########################################');
                    //console.log('##########################################');

                    // we need to update the column numbers inside the templates
                    //      to account for the sort, the column numbers are
                    //      important for partial re-render
                    if (arrOldHeaderTemplate) {
                        headerTemplate.innerHTML = strNewHeaderTemplate;
                        templateCellAddColumnNumber(headerTemplate);
                        strNewHeaderTemplate = headerTemplate.innerHTML;

                        // save the new header template so that the render
                        //      function uses it
                        element.internalTemplates.header = (
                            strNewHeaderTemplate
                        );
                    }

                    if (arrOldRecordTemplate) {
                        recordTemplate.innerHTML = strNewRecordTemplate;
                        templateCellAddColumnNumber(recordTemplate);
                        strNewRecordTemplate = recordTemplate.innerHTML;

                        // let's save the original record template text so
                        //      that we can modify it in the future
                        element.internalTemplates.originalRecord = (
                            strNewRecordTemplate
                        );

                        // save the new record template so that the render
                        //      function uses it
                        // we're going run the record template through a
                        //      function to turn all of the "column"
                        //      attributes into "value" attributes with
                        //      the proper templating
                        element.internalTemplates.record = (
                            GS.templateHideSubTemplates(
                                strNewRecordTemplate,
                                false // not a TR element
                            )
                        );
                    }

                    if (arrOldInsertTemplate) {
                        insertTemplate.innerHTML = strNewInsertTemplate;
                        templateCellAddColumnNumber(insertTemplate);
                        strNewInsertTemplate = insertTemplate.innerHTML;

                        // save the new insert template so that the render
                        //      function uses it
                        element.internalTemplates.insertRecord = (
                            strNewInsertTemplate
                        );
                    }

                    // save column arrays to internal storage
                    element.internalDisplay.columnPlainTextNames = (
                        arrNewPlainText
                    );
                    element.internalDisplay.dataColumnName = (
                        arrNewDataCol
                    );
                    element.internalDisplay.columnWidths = (
                        arrNewColWidths
                    );
                    element.internalDisplay.defaultColumnWidths = (
                        arrNewDefaultColWidths
                    );
                    if (arrOldCopyHeaders) {
                        element.internalClip.headerList = (
                            arrNewCopyHeaders
                        );
                    }
                    if (arrOldCopyCol) {
                        element.internalClip.columnList = (
                            arrNewCopyCol
                        );
                    }

                    // adjust selection to new column locations
                    // ### NEED CODING ###
                    // temp, clear select
                    element.internalSelection.ranges = [];

                    // sometimes, the user has sorted some columns. in this
                    //      case, we need to refresh the table

                    // here, we construct two strings representing the old
                    //      and new sort column orders, that way we can compare
                    //      them and refresh of they are different
                    strOldSortOrder = '';
                    strNewSortOrder = '';
                    i = 0;
                    len = arrOldDataCol.length;
                    while (i < len) {
                        if (arrOldDataCol[i]) {
                            strColumn = arrOldDataCol[i];

                            index = (
                                element.internalData.columnNames.indexOf(
                                    strColumn
                                )
                            );

                            strSort = element.internalData.columnOrders[index];

                            if (index > -1 && strSort !== 'neutral') {
                                strOldSortOrder += strColumn;
                            }
                        }
                        if (arrNewDataCol[i]) {
                            strColumn = arrNewDataCol[i];

                            index = (
                                element.internalData.columnNames.indexOf(
                                    strColumn
                                )
                            );

                            strSort = element.internalData.columnOrders[index];

                            if (index > -1 && strSort !== 'neutral') {
                                strNewSortOrder += strColumn;
                            }
                        }
                        i += 1;
                    }

                    //console.log(
                    //    '"' + strOldSortOrder + '"',
                    //    '"' + strNewSortOrder + '"'
                    //);

                    if (strOldSortOrder !== strNewSortOrder) {
                        dataSELECT(element);

                    // else, we can just re-render
                    } else {
                        // re-render so that the user can see the cells in their
                        //      new order
                        element.internalDisplay.fullRenderRequired = true;
                        renderScrollDimensions(element);
                    }
                }

                // we need to let everything know that we are no longer
                //      reordering columns
                element.internalReorder.currentlyReordering = false;

                // unbind mousemove and mouseup
                document.body.removeEventListener(
                    evt.mousemove,
                    element.internalEvents.columnReorderDragMove
                );
                document.body.removeEventListener(
                    evt.mouseup,
                    element.internalEvents.columnReorderDragEnd
                );
            };

            // bind the same drag start to the record and column elements so
            //      that if either one is mousedown'ed on, the cell resize
            //      starts
            element.elems.dataViewport.addEventListener(
                'mousedown',
                element.internalEvents.columnReorderDragStart
            );
        }
    }

    // ############# UPDATE EVENTS #############
    function unbindUpdate(element) {
        element.removeEventListener(
            'change',
            element.internalEvents.cellUpdate
        );

        element.elems.dataViewport.removeEventListener(
            'click',
            element.internalEvents.updateDialog
        );
    }
    function bindUpdate(element) {
        element.internalEvents.cellUpdate = function (event) {
            var target;
            var columnElement;
            var cellElement;
            var newValue;
            var strColumn;
            var intRecord;

            // get event target and put it in a variable for clarity
            target = event.target;

            // we need the element (possibly a parent of "target") that has a
            //      "column" attribute so that we can get the name of the
            //      column that needs to be updated (if the "target" is the
            //      element with the "column" attribute: "findParentElement"
            //      will simply return the "target" as the result)
            columnElement = GS.findParentElement(target, '[column]');

            // we need the gs-cell parent so that we can verify that the change
            //      emanated from an updatable cell
            cellElement = GS.findParentElement(columnElement, 'gs-cell');

            // verify that this "columnElement" is an actual child of this
            //      gs-table and that it's an updatable cell and not an insert
            //      cell
            if (
                GS.findParentElement(columnElement, 'gs-table') === element &&
                cellElement.classList.contains('table-cell')
            ) {
                // if we found a "column" element, we'll try to find a value and
                //      then attempt an update call
                if (columnElement) {
                    // if the "columnElement" has a "value" accessor we'll use
                    //      that to get the value
                    if (
                        columnElement.value !== null &&
                        columnElement.value !== undefined
                    ) {
                        newValue = columnElement.value;

                    // else if the "target" has a "value" accessor we'll use
                    //      that to get the value
                    } else if (
                        target.value !== null &&
                        target.value !== undefined
                    ) {
                        newValue = target.value;

                    // else if the "columnElement" has a "checked" accessor
                    //      we'll use that to get the value
                    } else if (
                        columnElement.checked !== null &&
                        columnElement.checked !== undefined
                    ) {
                        newValue = columnElement.checked;

                    // else if the "target" has a "checked" accessor we'll use
                    //      that to get the value
                    } else if (
                        target.checked !== null &&
                        target.checked !== undefined
                    ) {
                        newValue = target.checked;

                    // else: throw an error for the developer
                    } else {
                        throw 'GS-TABLE Error: Found an element with a ' +
                                '"column" attribute, but could not find a ' +
                                'value. Please make sure that when a ' +
                                '"change" event is fired either the event ' +
                                'target or the "column" element has a ' +
                                '"value" or "checked" accessor.';
                    }

                    // get parent column name and record number and
                    //      store them in variables for clarity
                    strColumn = columnElement.getAttribute('column');
                    intRecord = parseInt(
                        cellElement.getAttribute('data-row-number'),
                        10
                    );

                    //console.log('strColumn:', strColumn);
                    //console.log('intRecord:', intRecord);
                    //console.log('newValue:', newValue);

                    // call the update function
                    dataUPDATE(element, 'single-cell', {
                        "data": {
                            "columnName": strColumn,
                            "recordNumber": intRecord,
                            "newValue": newValue
                        },
                        "updateConfirmed": true
                    });
                }
            }
        };

        element.addEventListener(
            'change',
            element.internalEvents.cellUpdate
        );

        // sometimes, the user needs to be able to update multiple columns
        //      at once. or they just want to see the record in a more
        //      focused way, with more room. so, we open the update dialog
        //      when an update dialog button is clicked.
        element.internalEvents.updateDialog = function (event) {
            var target = event.target;
            var arrCol;
            var intRow;
            var strRow;
            var arrRow;
            var jsnRow;
            var i;
            var len;
            var strNullString;
            var templateFunc;
            var strHTML;
            var templateElement;

            if (target.classList.contains('table-multi-update-button')) {
                // we want the null string to be configurable, so we'll read the
                //      "null-string" attribute to get the null string
                // if the "null-string" attribute is present, use the contents
                //      or coalesce to empty string
                if (element.hasAttribute('null-string')) {
                    strNullString = element.getAttribute('null-string') || '';

                // else, null string is left up to the encoding function
                } else {
                    strNullString = undefined;
                }

                // we need to know the column names
                arrCol = element.internalData.columnNames;

                // we need to get the record
                intRow = parseInt(
                    target.parentNode.getAttribute('data-row-number'),
                    10
                );

                strRow = element.internalData.records[intRow];

                // convert the record to our normal "row" and "arrRow"
                // decode values in the column array and build up the json
                arrRow = strRow.split('\t');
                jsnRow = {};
                i = 0;
                len = arrCol.length;
                while (i < len) {
                    arrRow[i] = (
                        GS.decodeFromTabDelimited(
                            arrRow[i],
                            strNullString
                        )
                    );
                    jsnRow[arrCol[i]] = arrRow[i];

                    i += 1;
                }

                //console.log('intRow:', intRow);
                //console.log('strRow:', strRow);
                //console.log('arrRow:', arrRow);
                //console.log('jsnRow:', jsnRow);

                // template the updateDialog with the record
                templateFunc = doT.template(
                    '{{ ' +
                        'var row_number = jo.index + 1;' +
                        'var qs = jo.qs;' +
                        'var row = jo.row;' +
                        'var arrRow = jo.arrRow;' +
                        'var i = jo.index;' +
                        'var len = jo.len;' +
                    '}}' +
                    element.internalTemplates.updateDialog.templateHTML
                );

                // template with JSON
                strHTML = templateFunc({
                    'qs': GS.qryToJSON(GS.getQueryString()),
                    'row': jsnRow,
                    'arrRow': arrRow,
                    'index': intRow,
                    'len': element.internalData.records.length
                });

                // because we prevent templating into other element's
                //      templates (the ones with a "src" attribute) by
                //      "hiding" (by replacing them with a random token
                //      and storing the token-template relationship)
                //      them, we have to "show" them (by replacing the
                //      token with the original template strings) at
                //      this step
                strHTML = GS.templateShowSubTemplates(
                    strHTML,
                    element.internalTemplates.updateDialog
                );

                // generate dialog
                templateElement = document.createElement('template');

                templateElement.innerHTML = ml(function () {/*
<gs-page>
    <gs-header>
        <center><h3>Update</h3></center>
    </gs-header>
    <gs-body padded>
        {{HTML}}
    </gs-body>
    <gs-footer>
        <gs-grid gutter>
            <gs-block>
                <gs-button dialogclose>Cancel</gs-button>
            </gs-block>
            <gs-block>
                <gs-button id="gs-table-update-record" bg-primary>
                    Save
                </gs-button>
            </gs-block>
        </gs-grid>
    </gs-footer>
</gs-page>
                */}).replace(/\{\{HTML\}\}/gi, strHTML);

                // open the dialog
                GS.openDialog(templateElement, function () {
                    var dialog = this;
                    var saveButtonClick;
                    var afterUpdateFunc;

                    saveButtonClick = function () {
                        var arrElement;
                        var elem_i;
                        var elem_len;
                        var elem;
                        var arrColumns;
                        var arrValues;
                        var parentSRCElement;
                        var strOldValue;
                        var strNewValue;

                        // when the save button is clicked, we need to check
                        //      every field to find out what changes have been
                        //      made
                        arrElement = xtag.query(dialog, '[column]');
                        arrColumns = [];
                        arrValues = [];
                        elem_i = 0;
                        elem_len = arrElement.length;
                        while (elem_i < elem_len) {
                            elem = arrElement[elem_i];

                            parentSRCElement = GS.findParentElement(
                                elem,
                                '[src]'
                            );

                            if (
                                !parentSRCElement ||
                                parentSRCElement.nodeName === 'HTML' ||
                                parentSRCElement.nodeName === 'BODY'
                            ) {
                                strOldValue = jsnRow[
                                    elem.getAttribute('column')
                                ];
                                strNewValue = elem.value;

                                if (strNewValue !== strOldValue) {
                                    arrColumns.push(
                                        elem.getAttribute('column')
                                    );
                                    arrValues.push(
                                        GS.encodeForTabDelimited(
                                            strNewValue,
                                            strNullString
                                        )
                                    );
                                }
                            }

                            elem_i += 1;
                        }

                        if (arrColumns.length > 0) {
                            afterUpdateFunc = function () {
                                GS.closeDialog(dialog, 'Ok');
                                element.removeEventListener(
                                    'after_update',
                                    afterUpdateFunc
                                );
                            };

                            element.addEventListener(
                                'after_update',
                                afterUpdateFunc
                            );

                            dataUPDATE(element, 'cell-range', {
                                "data": {
                                    "columns": arrColumns,
                                    "records": [intRow],
                                    "values": [arrValues.join('\t')]
                                },
                                "updateConfirmed": false
                            });
                        }
                    };

                    document.getElementById('gs-table-update-record')
                            .addEventListener('click', saveButtonClick);
                });
            }
        };

        element.elems.dataViewport.addEventListener(
            'click',
            element.internalEvents.updateDialog
        );
    }

    // ############# INSERT EVENTS #############
    function unbindInsert(element) {
        element.elems.dataViewport.removeEventListener(
            'keydown',
            element.internalEvents.insertRecordReturn
        );
        element.elems.dataViewport.removeEventListener(
            'change',
            element.internalEvents.insertRecordValueRetain
        );
        element.elems.dataViewport.removeEventListener(
            'keyup',
            element.internalEvents.insertRecordValueRetain
        );
    }
    function bindInsert(element) {
        // we only want to insert a new record if the user presses "return"
        element.internalEvents.insertRecordReturn = function (event) {
            var parentCell = GS.findParentTag(event.target, 'gs-cell');
            var keyCode = (event.keyCode || event.which);

            // we only want return to insert if the return occured inside
            //      an insert cell
            if (
                parentCell.classList.contains('table-insert') &&
                keyCode === 13
            ) {
                dataINSERT(element, 'single-record', {
                    "data": {
                        "values": (
                            element
                                .internalData
                                .insertRecord
                        ),
                        "columns": (
                            element
                                .internalData
                                .insertRecordRetainedColumns
                        ),
                        "addin": getInsertAddin(element)
                    },
                    "insertConfirmed": true
                });

                // we clear the retained values and columns here because
                //      if the user decides to override the insert with
                //      their own thing, we don't want to still be showing
                //      the old values.
                element.internalData.insertRecord = {};
                element.internalData.insertRecordRetainedColumns = [];

                // re-render so that the insert controls clear out in the DOM
                element.internalDisplay.fullRenderRequired = true;
                renderLocation(element);
                //element.goToLine('last');
            }
        };

        element.elems.dataViewport.addEventListener(
            'keydown',
            element.internalEvents.insertRecordReturn
        );

        // we want to be able to fill in some insert cells, scroll away,
        //      scroll back, and not lose the values that have been typed in
        // this event code saves the value of the target internally so that
        //      when we re-template the insert record on scroll, we can get
        //      the values back
        element.internalEvents.insertRecordValueRetain = function (event) {
            var target = event.target;
            var parentCell = GS.findParentTag(target, 'gs-cell');
            var parentColumn = GS.findParentElement(target, '[column]');
            var strColumn = parentColumn.getAttribute('column');
            var strValue = target.value;

            // we only want to retain the values of insert cells, so only do so
            //      if the parent cell has the insert cell class and has a
            //      [column=""] defined
            if (
                parentCell.classList.contains('table-insert') &&
                strColumn
            ) {
                if (strValue) {
                    // retain the value in the internalData
                    element.internalData.insertRecord[strColumn] = strValue;

                    // some insert fields may be changed twice before an insert,
                    //      so only add the column name to the changed columns
                    //      list if that column name isn't already in the list
                    if (
                        element
                            .internalData
                            .insertRecordRetainedColumns
                            .indexOf(strColumn) === -1
                    ) {
                        element
                            .internalData
                            .insertRecordRetainedColumns
                            .push(strColumn);
                    }
                // if the user clears out a field that was previously
                //      retained, we want to remove that value from the
                //      retained list
                } else if (
                    !strValue &&
                    element
                        .internalData
                        .insertRecordRetainedColumns
                        .indexOf(strColumn) > -1
                ) {
                    element
                        .internalData
                        .insertRecord[strColumn] = undefined;
                    element
                        .internalData
                        .insertRecordRetainedColumns
                        .splice(
                            element
                                .internalData
                                .insertRecordRetainedColumns
                                .indexOf(strColumn)
                        );
                }
            }
        };

        element.elems.dataViewport.addEventListener(
            'change',
            element.internalEvents.insertRecordValueRetain
        );
        element.elems.dataViewport.addEventListener(
            'keyup',
            element.internalEvents.insertRecordValueRetain
        );
    }

    // ############# HUD EVENTS #############
    function unbindHUD(element) {

    }
    function bindHUD(element) {

    }

    // ############# KEY EVENTS #############
    function unbindKey(element) {
        element.removeEventListener(
            'keydown',
            element.internalEvents.keyDown
        );
    }
    function bindKey(element) {
        element.internalEvents.keyDown = function (event) {
            var keyCode = (event.keyCode || event.which);
            var bolCMDorCTRL = (event.ctrlKey || event.metaKey);
            var bolShift = (event.shiftKey);
            var active = document.activeElement;
            var activeValue = document.activeElement.value;

            var jsnRange;
            var intOldRecord;
            var intOldColumn;
            var intNewRecord;
            var intNewColumn;

            var intMaxColumn;
            var intMaxRecord;
            var intMinColumn;
            var intMinRecord;

            var jsnCursorPos;
            var intCursorPos;
            var bolFullSelection;
            var bolCursorAtFirst;
            var bolCursorAtTop;
            var bolCursorAtLast;
            var bolCursorAtBottom;

            var bolMaintainSelection;
            var bolMoveSelectedToTop;
            var intSpaceToTraverse;
            var intHeight;
            var i;
            var len;

            var beforeEvent;
            var selectionCopy;

            // if the keydown took place inside the hidden focus control
            if (active === element.elems.hiddenFocusControl) {
                if (
                    keyCode === 8 || // backspace
                    keyCode === 46   // forward delete
                ) {
                    deleteSelectedRecords(element);

                // if you hit return in the hidden focus control, select all
                //      text inside the control that is the origin field of the
                //      latest selection
                } else if (keyCode === 13) {
                    focusIntoSelectedCell(element);

                // if you hit CMD/CTRL-A, select all
                } else if (bolCMDorCTRL && keyCode === 65) {
                    // we need functions to give the top-right and bottom-left
                    //      corners, this use case would be simplified and would
                    //      work no matter how musch data or header/selector and
                    //      would help fix a couple other unreliable areas in
                    //      this element
                    // ### NEED CODING ###
                    len = element.internalData.records.length;
                    element.internalSelection.ranges = [
                        {
                            "start": {
                                "row": (
                                    element.internalDisplay.headerVisible
                                        ? 'header'
                                        : 0
                                ),
                                "column": (
                                    element.internalDisplay
                                        .recordSelectorVisible
                                            ? 'selector'
                                            : 0
                                )
                            },
                            "end": {
                                "row": (
                                    len > 0
                                        ? (len - 1)
                                        : 'header'
                                ),
                                "column": (
                                    element.internalDisplay
                                        .columnWidths.length - 1
                                )
                            },
                            "negator": false
                        }
                    ];
                    renderSelection(element);
                }
            }

            // these keys will be listened for if the focus is in a control or
            //      in the hidden focus control. all of these keys will be
            //      overridden no matter the target. if you have a control that
            //      uses one of these keys or key combos and you don't want the
            //      gs-table to intercept it: stop propagation and/or prevent
            //      default when you hear the event inside your element
            if (
                (
                    keyCode === 38 ||
                    keyCode === 39 ||
                    keyCode === 40 ||
                    keyCode === 37 ||
                    keyCode === 33 ||
                    keyCode === 34 ||
                    keyCode === 36 ||
                    keyCode === 35 ||
                    keyCode === 9
                ) &&
                !event.defaultPrevented
            ) {
                // if the focused element is an input or textarea, get the text
                //      selection so that we can calculate if an arrow key
                //      escapes the field
                if (
                    (
                        active.nodeName === 'INPUT' ||
                        active.nodeName === 'TEXTAREA'
                    ) &&
                    active !== element.elems.hiddenFocusControl
                ) {
                    jsnCursorPos = GS.getInputSelection(active);

                // else, assume full selection. this can happen if the focused
                //      field is (for example) a checkbox
                } else {
                    jsnCursorPos = {
                        'start': 0,
                        'end': activeValue.length
                    };
                }

                // shortcut variable for wheather or not all the text is
                //      selected
                bolFullSelection = (
                    jsnCursorPos.start === 0 &&
                    jsnCursorPos.end === activeValue.length
                );

                // if we don't have a full selection and the selection is one
                //      character position, create some shortcut variables so
                //      that we know if the cursor is at a particular extreme.
                if (
                    jsnCursorPos &&
                    !bolFullSelection &&
                    jsnCursorPos.start === jsnCursorPos.end
                ) {
                    intCursorPos = jsnCursorPos.start;
                    bolCursorAtFirst = (
                        intCursorPos === 0
                    );
                    bolCursorAtTop = (
                        (
                            intCursorPos < (
                                activeValue.indexOf('\n') === -1
                                    ? activeValue.length + 1
                                    : activeValue.indexOf('\n') + 1
                            )
                        ) ||
                        (
                            intCursorPos === 0
                        )
                    );
                    bolCursorAtLast = (
                        intCursorPos === activeValue.length
                    );
                    bolCursorAtBottom = (
                        intCursorPos > activeValue.lastIndexOf('\n')
                    );
                }

                // save the latest selection range's endpoint
                jsnRange = element.internalSelection.ranges[
                    element.internalSelection.ranges.length - 1
                ];

                // if there is a selection range, save it's endpoint
                if (jsnRange) {
                    intOldRecord = jsnRange.end.row;
                    intOldColumn = jsnRange.end.column;

                    if (intOldRecord === 'header') {
                        intOldRecord = -1;
                    } else if (intOldRecord === 'insert') {
                        intOldRecord = element.internalData.records.length;
                    }

                    if (intOldColumn === 'selector') {
                        intOldColumn = -1;
                    }

                // else, assume the endpoint is the first cell
                // this occurs when you tab into a gs-table that has no
                //      focusable fields and press a navigation key
                } else {
                    intOldRecord = 0;
                    intOldColumn = 0;
                }

                // determine max column and max record and save as a shortcut
                intMaxColumn = (
                    // commented because the record selection is -1, not 0,
                    //      this means that the max column stays the same
                    //      regardless of record selectors or not.
                    //element.internalDisplay.recordSelectorVisible
                    //    ? element.internalDisplay.columnWidths.length
                    //    :
                    element.internalDisplay.columnWidths.length - 1
                );
                intMaxRecord = (
                    element.internalDisplay.insertRecordVisible
                        ? element.internalData.records.length
                        : element.internalData.records.length - 1
                );

                // determine min column and min record and save as a shortcut
                intMinColumn = (
                    element.internalDisplay.recordSelectorVisible
                        ? -1
                        : 0
                );
                intMinRecord = (
                    element.internalDisplay.headerVisible
                        ? -1
                        : 0
                );

                // here we waterfall to determine the new selection row and
                //      column. you can't arrow from records to insert record
                //      except under a special case (no shift, no command,
                //      arrow down from last record)
                // -1 in intNewRecord means header record
                // -1 in intNewColumn means record selector column


                // "home" -- first cell of record
                if (keyCode === 36) {
                    // after moving the selection into a single cell, the
                    //      text selection is overridden because of the
                    //      keyup event. so, here we preventDefault and
                    //      stopPropagation to prevent the keyup from
                    //      occuring.
                    event.preventDefault();
                    event.stopPropagation();

                    // go to first cell
                    intNewRecord = intOldRecord;
                    intNewColumn = intMinColumn;

                // "end" -- last cell of record
                } else if (keyCode === 35) {
                    // after moving the selection into a single cell, the
                    //      text selection is overridden because of the
                    //      keyup event. so, here we preventDefault and
                    //      stopPropagation to prevent the keyup from
                    //      occuring.
                    event.preventDefault();
                    event.stopPropagation();

                    intNewRecord = intOldRecord;
                    intNewColumn = intMaxColumn;

                // "up arrow"
                } else if (keyCode === 38) {
                    if (bolFullSelection || bolCursorAtTop) {
                        // after moving the selection into a single cell, the
                        //      text selection is overridden because of the
                        //      keyup event. so, here we preventDefault and
                        //      stopPropagation to prevent the keyup from
                        //      occuring.
                        event.preventDefault();
                        event.stopPropagation();

                        // if CMD or CTRL is held down: move to extreme
                        if (bolCMDorCTRL) {
                            intNewRecord = intMinRecord;
                            intNewColumn = intOldColumn;

                        // else, move to next immediate cell
                        } else if (intOldRecord > intMinRecord) {
                            intNewRecord = (intOldRecord - 1);
                            intNewColumn = intOldColumn;
                        }
                    }

                // "right arrow"
                } else if (keyCode === 39) {
                    if (bolFullSelection || bolCursorAtLast) {
                        // after moving the selection into a single cell, the
                        //      text selection is overridden because of the
                        //      keyup event. so, here we preventDefault and
                        //      stopPropagation to prevent the keyup from
                        //      occuring.
                        event.preventDefault();
                        event.stopPropagation();

                        // if CMD or CTRL is held down: move to extreme
                        if (bolCMDorCTRL) {
                            intNewRecord = intOldRecord;
                            intNewColumn = intMaxColumn;

                        // else if we are at the right-most cell of the record
                        //      and we are not at the bottom-most record:
                        //      move to next record, first cell
                        } else if (
                            intOldColumn === intMaxColumn &&
                            intOldRecord < intMaxRecord
                        ) {
                            intNewRecord = (intOldRecord + 1);
                            intNewColumn = intMinColumn;

                        // else, move to next immediate cell
                        } else if (intOldColumn < intMaxColumn) {
                            intNewRecord = intOldRecord;
                            intNewColumn = (intOldColumn + 1);
                        }
                    }

                // "down arrow"
                } else if (keyCode === 40) {
                    if (bolFullSelection || bolCursorAtBottom) {
                        // after moving the selection into a single cell, the
                        //      text selection is overridden because of the
                        //      keyup event. so, here we preventDefault and
                        //      stopPropagation to prevent the keyup from
                        //      occuring.
                        event.preventDefault();
                        event.stopPropagation();

                        // if CMD or CTRL is held down: move to extreme
                        if (bolCMDorCTRL) {
                            intNewRecord = intMaxRecord;
                            intNewColumn = intOldColumn;

                        // else, move to next immediate cell
                        } else if (intOldRecord < intMaxRecord) {
                            intNewRecord = (intOldRecord + 1);
                            intNewColumn = intOldColumn;
                        }
                    }

                // "left arrow"
                } else if (keyCode === 37) {
                    if (bolFullSelection || bolCursorAtFirst) {
                        // after moving the selection into a single cell, the
                        //      text selection is overridden because of the
                        //      keyup event. so, here we preventDefault and
                        //      stopPropagation to prevent the keyup from
                        //      occuring.
                        event.preventDefault();
                        event.stopPropagation();

                        // if CMD or CTRL is held down: move to extreme
                        if (bolCMDorCTRL) {
                            intNewRecord = intOldRecord;
                            intNewColumn = intMinColumn;

                        // else if we are at the left-most cell of the record
                        //      and we are not at the top-most record:
                        //      move to previous record, last cell
                        } else if (
                            intOldColumn === intMinColumn &&
                            intOldRecord > intMinRecord
                        ) {
                            intNewRecord = (intOldRecord - 1);
                            intNewColumn = intMaxColumn;

                        // else, move to next immediate cell
                        } else if (intOldColumn > intMinColumn) {
                            intNewRecord = intOldRecord;
                            intNewColumn = (intOldColumn - 1);
                        }
                    }

                // "page up"
                } else if (keyCode === 33) {
                    // after moving the selection into a single cell, the
                    //      text selection is overridden because of the
                    //      keyup event. so, here we preventDefault and
                    //      stopPropagation to prevent the keyup from
                    //      occuring.
                    event.preventDefault();
                    event.stopPropagation();

                    // move to a cell approx one page up
                    intSpaceToTraverse = (
                        element.elems.dataViewport.clientHeight - (
                            element.internalScrollOffsets.top +
                            element.internalScrollOffsets.bottom
                        )
                    );
                    i = (
                        element.internalDisplay.currentRange.fromRecord
                        //intOldRecord
                    );
                    while (i >= -1) {
                        intHeight = (
                            element.internalDisplay.recordHeights[i]
                        );

                        intSpaceToTraverse -= intHeight;

                        // if we've run into the header (of the first
                        //      record), select the highest we can
                        if (i === intMinRecord) {
                            intNewRecord = i;
                            break;
                        }
                        // if we've found a record a page up, select the
                        //      record that is partially hidden by scroll
                        if (intSpaceToTraverse < 0) {
                            intNewRecord = i;
                            break;
                        }
                        i -= 1;
                    }

                    // if we found a record: choose a column
                    if (intNewRecord !== undefined) {
                        // if shift is held down, maintain the old column
                        if (bolShift) {
                            intNewColumn = intOldColumn;

                        // else, select the whole record by choosing the
                        //      record selector (or select first cell)
                        } else {
                            intNewColumn = intMinColumn;
                        }
                    }

                    // we want page up/down to scroll the selected record to the
                    //      top of the viewport, so here we set a boolean
                    //      variable to tell the code below (which is where the
                    //      selection and scrolling happens) to scroll the
                    //      selected cell to the top
                    bolMoveSelectedToTop = true;

                // "page down"
                } else if (keyCode === 34) {
                    // after moving the selection into a single cell, the
                    //      text selection is overridden because of the
                    //      keyup event. so, here we preventDefault and
                    //      stopPropagation to prevent the keyup from
                    //      occuring.
                    event.preventDefault();
                    event.stopPropagation();

                    // move to a cell approx one page down
                    intSpaceToTraverse = (
                        element.elems.dataViewport.clientHeight - (
                            element.internalScrollOffsets.top +
                            element.internalScrollOffsets.bottom
                        )
                    );

                    i = (
                        element.internalDisplay.currentRange.fromRecord
                        //intOldRecord
                    );
                    len = (intMaxRecord + 1);
                    while (i < len) {
                        if (i === -1) {
                            intHeight = (
                                element.internalDisplay.headerHeight
                            );
                        } else {
                            intHeight = (
                                element.internalDisplay.recordHeights[i]
                            );
                        }

                        intSpaceToTraverse -= intHeight;

                        // if we've reached the bottom, select the last record
                        if (i === intMaxRecord) {
                            intNewRecord = i;
                            break;
                        }
                        // if we've found a record a page down, select the
                        //      record that is partially hidden by scroll
                        if (intSpaceToTraverse < 0) {
                            intNewRecord = i - 1;
                            break;
                        }
                        i += 1;
                    }

                    // if we found a record: choose a column
                    if (intNewRecord !== undefined) {
                        // if shift is held down, maintain the old column
                        if (bolShift) {
                            intNewColumn = intOldColumn;

                        // else, select the whole record by choosing the
                        //      record selector
                        } else {
                            intNewColumn = intMinColumn;
                        }
                    }

                    // we want page up/down to scroll the selected record to the
                    //      top of the viewport, so here we set a boolean
                    //      variable to tell the code below (which is where the
                    //      selection and scrolling happens) to scroll the
                    //      selected cell to the top
                    bolMoveSelectedToTop = true;

                // "tab" next cell in reading order
                } else if (keyCode === 9) {
                    // we need to be able to handle shift-tab because some users
                    //      know how to use shift-tab and would expect it from
                    //      any key-navigable interface
                    if (bolShift) {
                        // we need to be able to tab out of the gs-table if the
                        //      user presses tab while the first cell is the
                        //      selection anchor that we are moving from
                        // So, if the anchor point is at the first cell: do
                        //      nothing, this means that the event won't be
                        //      prevented and therefore will do what the browser
                        //      naturally want's it to do
                        // else, we want to move the selection to the previous
                        //      field in reading order
                        if (
                            intOldRecord !== intMinColumn ||
                            intOldColumn !== intMinRecord
                        ) {
                            // after moving the selection into a single cell,
                            //      the text selection is overridden because of
                            //      the keyup event. so, here we preventDefault
                            //      and stopPropagation to prevent the keyup
                            //      from occuring.
                            event.preventDefault();
                            event.stopPropagation();

                            // if we are at the min column:
                            //      go to the max column and the previous record
                            if (intOldColumn === intMinColumn) {
                                intNewRecord = (intOldRecord - 1);
                                intNewColumn = intMaxColumn;

                            // else, go to previous column
                            } else {
                                intNewRecord = intOldRecord;
                                intNewColumn = intOldColumn - 1;
                            }
                        }

                    // we need to handle standard tab as well
                    } else {
                        // we need to be able to tab out of the gs-table if the
                        //      user presses tab while the last cell is the
                        //      selection anchor that we are moving from
                        // So, if the anchor point is at the last cell: do
                        //      nothing, this means that the event won't be
                        //      prevented and therefore will do what the browser
                        //      naturally want's it to do
                        // else, we want to move the selection to the previous
                        //      field in reading order
                        if (
                            intOldRecord !== intMaxColumn ||
                            intOldColumn !== intMaxRecord
                        ) {
                            // after moving the selection into a single cell,
                            //      the text selection is overridden because of
                            //      the keyup event. so, here we preventDefault
                            //      and stopPropagation to prevent the keyup
                            //      from occuring.
                            event.preventDefault();
                            event.stopPropagation();

                            // if we are at the max column:
                            //      go to the min column and the next record
                            if (intOldColumn === intMaxColumn) {
                                intNewRecord = (intOldRecord + 1);
                                intNewColumn = intMinColumn;

                            // else, go to next column
                            } else {
                                intNewRecord = intOldRecord;
                                intNewColumn = intOldColumn + 1;
                            }
                        }
                    }
                }

                // if we found a place to put the selection anchor point
                if (intNewRecord !== undefined && intNewColumn !== undefined) {
                    //console.log('intOldRecord:', intOldRecord);
                    //console.log('intOldColumn:', intOldColumn);
                    //console.log('intNewRecord:', intNewRecord);
                    //console.log('intNewColumn:', intNewColumn);
                    //console.log('intMinRecord:', intMinRecord);
                    //console.log('intMinColumn:', intMinColumn);
                    //console.log('intMaxRecord:', intMaxRecord);
                    //console.log('intMaxColumn:', intMaxColumn);

                    // we don't want to stay focused on the original control
                    focusHiddenControl(element);

                    // we're going to do multiple if statements that test if the
                    //      previous selections will be maintained, so here
                    //      we'll save a shortcut variable
                    bolMaintainSelection = (
                        // shift is down
                        bolShift &&
                        // there is an old selection
                        jsnRange &&
                        // the key wasn't tab
                        keyCode !== 9
                    );

                    // if the user cancels the selection, we need to be able
                    //      to go back to the previous selection. so, here
                    //      we save a backup
                    selectionCopy = getSelectionCopy(element);

                    // when the before_selection event is triggered, we want the
                    //      gs-table to have the current selection available.
                    //      so we'll make the changes to the selection and then
                    //      trigger before_selection.

                    // convert the new record and column to special values
                    //      (if needed)
                    var intHeaderIndex;
                    var intSelectorIndex;
                    var intInsertIndex;
                    var newRecord;
                    var newColumn;

                    intHeaderIndex = -1;
                    intSelectorIndex = -1;
                    intInsertIndex = (element.internalData.records.length);

                    if (intNewRecord === intHeaderIndex) {
                        newRecord = 'header';
                    } else if (intNewRecord === intInsertIndex) {
                        newRecord = 'insert';
                    } else {
                        newRecord = intNewRecord;
                    }

                    //console.log(
                    //    newRecord,
                    //    intNewRecord,
                    //    intHeaderIndex,
                    //    intInsertIndex
                    //);

                    if (intNewColumn === intSelectorIndex) {
                        newColumn = 'selector';
                    } else {
                        newColumn = intNewColumn;
                    }

                    // if we're going to maintain selections
                    if (bolMaintainSelection) {
                        // maintain old selections and modify the most
                        //      recent one's endpoint
                        jsnRange.end.row = newRecord;
                        jsnRange.end.column = newColumn;

                    // else, set selection to only that cell
                    } else {
                        jsnRange = {
                            "start": {
                                "row": newRecord,
                                "column": newColumn
                            },
                            "end": {
                                "row": newRecord,
                                "column": newColumn
                            },
                            "negator": false
                        };
                        element.internalSelection.ranges = [jsnRange];
                    }

                    // trigger a "before_selection" event so that the page has a
                    //      chance to cancel the selection
                    beforeEvent = GS.triggerEvent(element, 'before_selection');

                    // if the user prevents the default on the
                    //      "before_selection" event, revert selection ranges
                    //      to what they were before the latest selection
                    //      started (and revert wheather or not the selection
                    //      is in the insert record)
                    if (beforeEvent.defaultPrevented) {
                        element.internalSelection.ranges = (
                            selectionCopy.ranges
                        );
                        return;
                    }

                    // if the before_selection event wasn't cancelled, we run
                    //      this code below

                    // sometimes, the focus is lost. so, focus the
                    //      hiddenFocusControl so that we can always listen for
                    //      keypresses
                    focusHiddenControl(element);

                    // sometimes we want to move the selected endpoint to the
                    //      top of the viewport, if that's what we want, send
                    //      the 'top' mode into the scrollSelectionIntoView
                    //      function
                    if (bolMoveSelectedToTop) {
                        // scroll selection into view and re-render
                        scrollSelectionIntoView(element, 'top');

                    } else {
                        // scroll selection into view and re-render
                        scrollSelectionIntoView(element);
                    }

                    // if we're not going to maintain old selections (which
                    //      also means that only one cell will be selected)
                    //      and we're not selecting a header or record selector
                    if (
                        !bolMaintainSelection &&
                        intNewRecord > -1 &&
                        intNewColumn > -1
                    ) {
                        // we want the user to be able to start typing and fill
                        //      the cell, so focus into the cell and select all
                        //      text if possible
                        focusIntoSelectedCell(element);
                    }

                    // if the "before_selection" event is not prevented, we
                    //      trigger "after_selection" so that the page can run
                    //      code after a selection has been made
                    if (beforeEvent.defaultPrevented) {
                        GS.triggerEvent(element, 'after_selection');
                    }
                }
            }
        };

        element.addEventListener(
            'keydown',
            element.internalEvents.keyDown
        );
    }

    // ############# COPY EVENTS #############
    function unbindCopy(element) {
        element.removeEventListener(
            'copy',
            element.internalEvents.copySelection
        );
    }
    function bindCopy(element) {
        element.internalEvents.copySelection = function (event) {
            var jsnCopyString;
            var focusedElement;

            // saving the currently focused element for easy/quick access
            focusedElement = document.activeElement;

            // if the focus is on the hidden focus control of if the text
            //      selection of the currently focused element is not
            //      selecting multiple characters
            if (
                focusedElement.classList.contains('hidden-focus-control') ||
                focusedElement.selectionStart === focusedElement.selectionEnd
            ) {
                console.time('copy');

                // because copying a large amount of data takes time, add a
                //      loader to let the user know we're copying, just in case
                addLoader(element, 'copy-loader', 'Copying Data...');

                // focus the hidden focus control and select all of it's text so
                //      that Firefox will allow us to override the clipboard
                focusedElement = element.elems.hiddenFocusControl;
                focusedElement.focus();

                GS.setInputSelection(
                    focusedElement,
                    0,
                    focusedElement.value.length
                );

                // we want to override the text and HTML mime type clipboards,
                //      so we get the copy text for both types
                jsnCopyString = getCopyStrings(element);
                // override clipboard (prevent event default if we are
                //      successful)
                if (handleClipboardData(event, jsnCopyString.text, 'text')) {
                    event.preventDefault(event);
                }
                if (handleClipboardData(event, jsnCopyString.html, 'html')) {
                    event.preventDefault(event);
                }

                // remove copying loader
                removeLoader(element, 'copy-loader', 'Data Copied');

                console.timeEnd('copy');
            }
        };

        element.addEventListener(
            'copy',
            element.internalEvents.copySelection
        );
    }

    // ############# PASTE EVENTS #############
    function unbindPaste(element) {
        element.removeEventListener(
            'paste',
            element.internalEvents.pasteSelection
        );
    }
    function bindPaste(element) {
        element.internalEvents.pasteSelection = function (event) {
            // we dont want to interfere with pasting inside a cell, so only
            //      use this paste event if the focused element is the
            //      hiddenFocusControl
            if (document.activeElement === element.elems.hiddenFocusControl) {
                // prevent default so that the hiddenFocusControl's value
                //      doesn't get overridden by the paste
                event.preventDefault();
                usePasteEvent(element, event);
            }
        };

        element.addEventListener(
            'paste',
            element.internalEvents.pasteSelection
        );
    }

    // ############# CUT EVENTS #############
    function unbindCut(element) {
        element.removeEventListener(
            'cut',
            element.internalEvents.cutSelection
        );
    }
    function bindCut(element) {
        element.internalEvents.cutSelection = function () {
            // we dont want to interfere with cutting inside a cell, so only
            //      use this cut event if the focused element is the
            //      hiddenFocusControl
            if (document.activeElement === element.elems.hiddenFocusControl) {
                // prevent default so that the hiddenFocusControl's value
                //      doesn't get overridden by the paste
                event.preventDefault();

                // let the user know that we don't support cut
                addLoader(element, 'cut-warn', 'Cut is not supported');
                removeLoader(element, 'cut-warn', 'Cut is not supported');
            }
        };

        element.addEventListener(
            'cut',
            element.internalEvents.cutSelection
        );
    }

    // ############# CONTEXTMENU EVENTS #############
    function unbindContextMenu(element) {
        element.elems.dataViewport.removeEventListener(
            'contextmenu',
            element.internalEvents.columnContextMenu
        );
    }
    function bindContextMenu(element) {
        element.internalEvents.columnContextMenu = function (event) {
            var target = event.target;
            var parentCell = GS.findParentTag(target, 'gs-cell');

            var templateElement;
            var strCellType;
            var bolRange;
            var arrDataColumns;
            var arrSelectedColumns;
            var bolFilterUnique;
            var bolFilterSelection;
            var bolColumnWidths;
            var bolHideAndShow;
            var bolSort;

            var intRecord;
            var intColumn;
            var strDataValue;
            var strControlValue;
            var strColumn;
            var columnElement;
            var focusElement;
            var jsnSelection;
            var strSelection;

            var i;
            var len;
            //var index;
            var strHTML;

            // there are multiple different contextmenus
            //      one for header cells
            //          column hide/show
            //          column sort
            //          unique list filter
            //      one for data cells
            //          column hide/show
            //          column sort
            //          selection filter
            //      one for calculated cells
            //          column hide/show
            //      one for insert cells
            //          column hide/show
            //          column sort
            //
            // overall, there are a few modules that we need to toggle
            //      unique list filter
            //      selection filter
            //      column hide/show
            //      column sort
            //
            // if your selection spans between the header and data:
            //      column hide/show
            //      column sort
            //
            // if your selection is a range containing data cells
            //      column hide/show
            //      column sort
            //
            // if your selection is a range with only calculated cells
            //      column hide/show

            // get parent gs-cell element
            parentCell = target;
            if (target.nodeName !== 'GS-CELL') {
                parentCell = GS.findParentTag(target, 'gs-cell');
            }

            // if the right-clicked cell is a data cell, header
            //      cell or insert cell
            if (
                parentCell &&
                parentCell.nodeName === 'GS-CELL' &&
                (
                    parentCell.classList.contains('table-cell') ||
                    parentCell.classList.contains('table-header') ||
                    parentCell.classList.contains('table-insert')
                )
            ) {
                // we need to find out what type of cell we right-clicked on
                if (parentCell.classList.contains('table-cell')) {
                    strCellType = 'data';

                } else if (parentCell.classList.contains('table-header')) {
                    strCellType = 'header';

                } else if (parentCell.classList.contains('table-insert')) {
                    strCellType = 'insert';
                }

                // we need to know the selected column list
                arrSelectedColumns = (
                    element.internalSelection.columns
                );
                if (arrSelectedColumns[0] === 'selector') {
                    arrSelectedColumns.shift();
                }

                // we need to know if more than one cell is selected
                bolRange = (
                    arrSelectedColumns.length > 1 ||
                    element.internalSelection.rows.length > 1
                );

                // we need to know the data columns within the selected range
                arrDataColumns = getSelectedDataColumns(element);

                // if we have one data cell selected and it is associated
                //      with a data column, we need to know the value of the
                //      cell
                if (
                    strCellType === 'data' &&
                    !bolRange &&
                    arrDataColumns.length === 1
                ) {
                    // we need to know the record number
                    intRecord = parseInt(
                        parentCell.getAttribute('data-row-number'),
                        10
                    );

                    // we need to know what record we're working with
                    intColumn = parseInt(
                        parentCell.getAttribute('data-col-number'),
                        10
                    );

                    // now that we associate display columns and their data
                    //      columns, we can get the value even if there's no
                    //      columnElement, but we do need a column number
                    strColumn = (
                        element.internalDisplay.dataColumnName[intColumn]
                    );

                    // we need to extract the cell value from the data
                    strDataValue = getCell(
                        element,
                        strColumn,
                        intRecord,
                        // cell value should be decoded from tab delimited
                        true,
                        // we need to know if we're dealing with NULL
                        'gsTAbleINTERNALNULLSTRING'
                    );

                    // we wan't to get the text selection of current cell,
                    //      so we need the column element
                    columnElement = xtag.query(parentCell, '[column]')[0];

                    // we can't get the text selection if there's no column
                    //      element or there's no value
                    if (
                        columnElement &&
                        strDataValue !== 'gsTAbleINTERNALNULLSTRING'
                    ) {
                        // we need to get the input or textarea (if there
                        //      is one) that'll contain the text selection
                        // sometimes, the developer will use an input or
                        //      textarea element as the column element, in
                        //      that case the column element is the focus
                        //      element
                        if (
                            // if the column element is an input[type="text"]
                            (
                                columnElement.nodeName === 'INPUT' &&
                                columnElement.getAttribute('type') === 'text'
                            ) ||
                            // or if the column element is a textarea
                            columnElement.nodeName === 'TEXTAREA'
                        ) {
                            focusElement = columnElement;

                        // else, we need to search inside the column element
                        //      for the focus element
                        } else {
                            focusElement = xtag.query(
                                columnElement,
                                'input[type="text"], textarea'
                            )[0];
                        }

                        // if strValue matches columnElement's value, use
                        //      the text selection (if availible) of the
                        //      columnElement's control and substring the
                        //      strValue
                        if (
                            focusElement &&
                            focusElement.value === strDataValue
                        ) {
                            strControlValue = focusElement.value;
                            jsnSelection = GS.getInputSelection(focusElement);

                            strSelection = strControlValue.substring(
                                jsnSelection.start,
                                jsnSelection.end
                            );

                            //console.log('substring', strSelection);
                        }
                    }
                }

                // innocent until proven guilty
                bolFilterUnique = true;
                bolFilterSelection = true;
                bolColumnWidths = true;
                bolHideAndShow = true;
                bolSort = true;

                // no unique value filter list
                if (
                    //// if the cell is not a header cell
                    //strCellType !== 'header' ||
                    //// or isn't the only column selected
                    //arrSelectedColumns.length !== 1 ||
                    //// or isn't a data column
                    //arrDataColumns.length !== 1
                    true // <-- filter unique is for the column dropdown
                ) {
                    bolFilterUnique = false;
                }

                // no filter by selection
                if (
                    // if the cell is not a data cell
                    strCellType !== 'data' ||
                    // or multiple cells are selected
                    bolRange ||
                    // or isn't the only column selected
                    arrSelectedColumns.length !== 1 ||
                    // or isn't a data column
                    arrDataColumns.length !== 1
                ) {
                    bolFilterSelection = false;
                }

                // right now, we always want the option of column widths
                if (false) {
                    bolColumnWidths = false;
                }

                // right now, we always want the option of show and hide
                if (false) {
                    bolHideAndShow = false;
                }

                // if there are no data columns in the current selection, we
                //      want no sorting options
                if (arrDataColumns.length === 0) {
                    bolSort = false;
                }

                // helps to debug
                //console.log('arrSelectedColumns: ', arrSelectedColumns);
                //console.log('arrDataColumns: ', arrDataColumns);
                //console.log('bolFilterUnique: ', bolFilterUnique);
                //console.log('bolFilterSelection: ', bolFilterSelection);
                //console.log('bolHideAndShow: ', bolHideAndShow);
                //console.log('bolSort: ', bolSort);

                // assemble the HTML
                strHTML = '';

                if (bolSort) {
                    strHTML += (
                        strHTML
                            ? '<hr />'
                            : ''
                    );
                    strHTML += (
                        '<div class="context-menu-header">Sorting:</div>' +
                        '<div class="context-menu-indent">' +
                        '    <gs-button dialogclose remove-bottom' +
                        '                iconleft icon="sort-alpha-asc"' +
                        '                class="button-sort-asc">' +
                        '        Sort A to Z' +
                        '    </gs-button>' +
                        '    <gs-button dialogclose remove-all' +
                        '                iconleft icon="sort-alpha-desc"' +
                        '                class="button-sort-desc">' +
                        '        Sort Z to A' +
                        '    </gs-button>' +
                        '    <gs-button dialogclose remove-top' +
                        '                iconleft icon="trash-o"' +
                        '                class="button-sort-clear">' +
                        '        Clear Sort' +
                        '    </gs-button>' +
                        '</div>'
                    );
                }

                if (bolHideAndShow) {
                    strHTML += (
                        strHTML
                            ? '<hr />'
                            : ''
                    );
                    strHTML += (
                        '<div class="context-menu-header">' +
                        'Hide/Unhide Columns:' +
                        '</div>' +
                        '<div class="context-menu-indent">' +
                        '    <gs-button dialogclose remove-bottom' +
                        '                iconleft icon="eye-slash"' +
                        '                class="button-column-hide">' +
                        '        Hide Column(s)' +
                        '    </gs-button>' +
                        '    <gs-button dialogclose remove-top' +
                        '                iconleft icon="eye"' +
                        '                class="button-column-unhide">' +
                        '        Unhide Columns' +
                        '    </gs-button>' +
                        '</div>'
                    );
                }

                // ### NEED CODING ###
                if (bolColumnWidths) {
                    strHTML += (
                        strHTML
                            ? '<hr />'
                            : ''
                    );
                    strHTML += (
                        '<div class="context-menu-header">Column Width:</div>' +
                        '<div class="context-menu-indent">' +
                        '    <gs-button dialogclose remove-bottom' +
                        '                iconleft icon="text-width"' +
                        '                class="button-column-width">' +
                        '        Fit To Header' +
                        '    </gs-button>' +
                        '    <gs-button dialogclose remove-top' +
                        '                iconleft icon="text-width"' +
                        '                class="button-column-width">' +
                        '        Fit To Content' +
                        '    </gs-button>' +
                        '</div>'
                    );
                }

                if (bolFilterSelection) {
                    strHTML += (
                        strHTML
                            ? '<hr />'
                            : ''
                    );
                    strHTML += (
                        '<div class="context-menu-header">Filtering:</div>' +
                        '<div class="context-menu-indent">' +
                        '    <gs-button dialogclose remove-bottom' +
                        '                iconleft icon="filter"' +
                        '                class="button-filter-include">' +
                        '        Filter By Selection' +
                        '    </gs-button>' +
                        '    <gs-button dialogclose remove-all' +
                        '                iconleft icon="filter"' +
                        '                class="button-filter-exclude">' +
                        '        Filter Excluding Selection' +
                        '    </gs-button>' +
                        '    <gs-button dialogclose remove-all' +
                        '                iconleft icon="search"' +
                        '                class="button-filter-text">' +
                        '        Text Filters' +
                        '    </gs-button>' +
                        '    <gs-button dialogclose remove-all' +
                        '                iconleft icon="toggle-off"' +
                        '                class="button-filter-toggle">' +
                        '        Toggle Filters' +
                        '    </gs-button>' +
                        '    <gs-button dialogclose remove-top' +
                        '                iconleft icon="trash-o"' +
                        '                class="button-filter-clear">' +
                        '        Clear Filters' +
                        '    </gs-button>' +
                        '</div>'
                    );
                }

                // ### NEED CODING ###
                if (bolFilterUnique) {
                    strHTML += (
                        strHTML
                            ? '<hr />'
                            : ''
                    );
                    strHTML += '<div class="gs-table-unique-value-list"></div>';
                }

                // create dialog template
                templateElement = document.createElement('template');
                templateElement.setAttribute('data-max-width', '15em');
                templateElement.setAttribute('data-overlay-close', 'true');
                templateElement.setAttribute('no-focus-lock', 'true');
                templateElement.setAttribute('no-background', '');
                templateElement.innerHTML = (
                    '<gs-page gs-dynamic class="gs-table-contextmenu">' +
                    '    <gs-body padded>' +
                    '        ' + strHTML +
                    '    </gs-body>' +
                    '</gs-page>'
                );

                // if we're going to open the dialog, we need to prevent
                //      the OS contextmenu
                event.preventDefault();

                // we want the context menu to be placed at a particular
                //      X/Y, so we'll stick a temporary element in to
                //      position to
                var jsnMousePos = GS.mousePosition(event);
                var jsnElementPos = GS.getElementOffset(
                    element.elems.root
                );

                element.elems.pixel.style.left = (
                    (
                        (
                            jsnMousePos.left -
                            jsnElementPos.left
                        ) +
                        (
                            GS.emToPx(document.body, 15) /
                            2
                        )
                    ) +
                    'px'
                );
                element.elems.pixel.style.top = (
                    (
                        jsnMousePos.top -
                        jsnElementPos.top
                    ) +
                    'px'
                );
                element.elems.pixel.style.bottom = '';
                element.elems.pixel.style.right = '';
                // element.elems.dataViewport.appendChild(
                //     element.elems.pixel
                // );

                // open dialog
                GS.openDialogToElement(
                    element.elems.pixel,
                    templateElement,
                    'down',
                    function () {
                        var dialog = this;
                        var filterToggleButton;
                        var strStatus;

                        // we want the top gs-page to have corner rounding
                        dialog.classList.add('gs-table-contextmenu');

                        // we want the "toggle filter" button to reflect
                        //      the current status of the column filter
                        //      on/off
                        if (bolFilterSelection) {
                            filterToggleButton = xtag.query(
                                dialog,
                                '.button-filter-toggle'
                            )[0];

                            strStatus = (
                                element.internalData
                                    .columnFilterStatuses[arrDataColumns[0]]
                            );

                            if (strStatus === 'on') {
                                filterToggleButton.textContent = (
                                    'Toggle Filters Off'
                                );
                                filterToggleButton.setAttribute(
                                    'icon',
                                    'toggle-on'
                                );
                            } else {
                                filterToggleButton.textContent = (
                                    'Toggle Filters On'
                                );
                                filterToggleButton.setAttribute(
                                    'icon',
                                    'toggle-off'
                                );
                            }
                        }
                    },
                    function (event, strAnswer) {
                        var dialog = this;
                        var targetElement;
                        var buttonElement;

                        var strWhere;
                        var strValue;

                        var strNewSort;

                        var col_i;
                        var col_len;

                        // when you close the dialog by clicking on the
                        //      overlay, there is no event.
                        if (event && event.target) {
                            targetElement = event.target;
                        }

                        // when you close the dialog by clicking on the
                        //      overlay, there is no target.
                        if (targetElement) {
                            // we may need to position a second dialog to a
                            //      button, so here we get the button that
                            //      was clicked.
                            if (targetElement.nodeName === 'GS-BUTTON') {
                                buttonElement = targetElement;
                            } else {
                                buttonElement = GS.findParentTag(
                                    targetElement,
                                    'gs-button'
                                );
                            }
                        }

                        //console.log(event, buttonElement, targetElement);

                        // there's extra whitespace around the answer
                        strAnswer = strAnswer.trim();

                        //console.log(
                        //    parentCell,
                        //    buttonElement,
                        //    strAnswer,
                        //    arrDataColumns,
                        //    strColumn
                        //);

                        if (
                            strAnswer === 'Sort A to Z' ||
                            strAnswer === 'Sort Z to A' ||
                            strAnswer === 'Clear Sort'
                        ) {
                            if (strAnswer === 'Sort A to Z') {
                                strNewSort = 'asc';
                            } else if (strAnswer === 'Sort Z to A') {
                                strNewSort = 'desc';
                            } else if (strAnswer === 'Clear Sort') {
                                strNewSort = 'neutral';
                            }

                            col_i = 0;
                            col_len = arrDataColumns.length;
                            while (col_i < col_len) {
                                element.internalData.columnOrders[
                                    arrDataColumns[col_i]
                                ] = strNewSort;

                                col_i += 1;
                            }

                            dataSELECT(element);

                        } else if (strAnswer === 'Fit To Header') {
                            resizeColumnsToHeader(element, arrSelectedColumns);

                        } else if (strAnswer === 'Fit To Content') {
                            var colsToResize = [];
                            //console.log(arrSelectedColumns);
                            if (element.internalSelection.rows[0] ===
                                'header'
                            ) {
                                var jsnFirstRange = (
                                    element.internalSelection.ranges[0]
                                );
                                var intSelectionLength;
                                if (
                                    jsnFirstRange &&
                                    jsnFirstRange.start.row === 'header'
                                ) {
                                    intSelectionLength = (
                                        jsnFirstRange.end.column -
                                        jsnFirstRange.start.column + 1
                                    );

                                    i = 0;
                                    while (i < intSelectionLength) {
                                        colsToResize.push(
                                            i + jsnFirstRange.start.column
                                        );

                                        i += 1;
                                    }
                                }

                            } else {
                                //no headers selected: resize the column
                                //  that was clicked
                                colsToResize = arrSelectedColumns;
                            }
                            //console.log(colsToResize);
                            resizeColumnsToContent(element, arrSelectedColumns);

                        } else if (strAnswer === 'Hide Column(s)') {
                            i = 0;
                            len = arrSelectedColumns.length;
                            while (i < len) {
                                // we don't want to hide the record selector
                                if (arrSelectedColumns[i] >= 0) {
                                    // hide the column by making it zero
                                    //      width
                                    element.internalDisplay.columnWidths[
                                        arrSelectedColumns[i]
                                    ] = 0;
                                }

                                i += 1;
                            }

                            // partial re-render might not know how to
                            //      remove columns in the middle of the
                            //      viewport
                            element.internalDisplay.fullRenderRequired = true;
                            renderLocation(element);

                        } else if (strAnswer === 'Unhide Columns') {
                            openColumnHideDialog(
                                element,
                                buttonElement,
                                // before dialog close callback
                                function (strAnswer) {
                                    // if the unhide dialog wasn't cancelled,
                                    //      close the contextmenu
                                    if (strAnswer !== 'Cancel') {
                                        GS.closeDialog(dialog, 'Force');
                                    }
                                }
                            );
                            event.preventDefault();

                        } else if (strAnswer === 'Filter By Selection') {
                            strValue = (strSelection || strDataValue);

                            // sometimes the user want's to filter for nulls
                            if (strValue === 'gsTAbleINTERNALNULLSTRING') {
                                strWhere = (strColumn + ' IS NULL');
                            } else {
                                strWhere = (
                                    'CAST(' +
                                        strColumn + ' AS ' +
                                        GS.database.type.text +
                                    ') = $$' + strValue + '$$'
                                );
                            }

                            element.internalData
                                .columnFilters[arrDataColumns[0]].push(
                                    {
                                        "text": strWhere,
                                        "name": 'equals "' + strValue + '"'
                                    }
                                );

                            dataSELECT(element);

                        } else if (
                            strAnswer === 'Filter Excluding Selection'
                        ) {
                            strValue = (strSelection || strDataValue);

                            // sometimes the user want's to filter out nulls
                            if (strValue === 'gsTAbleINTERNALNULLSTRING') {
                                strWhere = (strColumn + ' IS NOT NULL');
                            } else {
                                strWhere = (
                                    'CAST(' +
                                        strColumn + ' AS ' +
                                        GS.database.type.text +
                                    ') != $$' + strValue + '$$'
                                );
                            }

                            element.internalData
                                .columnFilters[arrDataColumns[0]].push(
                                    {
                                        "text": strWhere,
                                        "name": "doesn't equal " +
                                                "\"" + strValue + "\""
                                    }
                                );

                            dataSELECT(element);

                        } else if (strAnswer === 'Text Filters') {
                            strValue = (strSelection || strDataValue);

                            element.internalEvents.textFilterContextMenu(
                                buttonElement,
                                arrDataColumns[0],
                                strColumn,
                                strValue,
                                // before dialog close callback
                                function (strAnswer) {
                                    // if the unhide dialog wasn't cancelled,
                                    //      close the contextmenu
                                    if (strAnswer !== 'Cancel') {
                                        GS.closeDialog(dialog, 'Force');
                                    }
                                }
                            );

                            event.preventDefault();

                        } else if (strAnswer === 'Toggle Filters On') {
                            element.internalData.columnFilterStatuses[
                                arrDataColumns[0]
                            ] = (
                                'on'
                            );

                            dataSELECT(element);

                        } else if (strAnswer === 'Toggle Filters Off') {
                            element.internalData.columnFilterStatuses[
                                arrDataColumns[0]
                            ] = (
                                'off'
                            );

                            dataSELECT(element);

                        } else if (strAnswer === 'Clear Filters') {
                            element.internalData.columnFilters[
                                arrDataColumns[0]
                            ] = [];
                            element.internalData.columnListFilters[
                                arrDataColumns[0]
                            ] = {};

                            dataSELECT(element);
                        }

                        // we're done with the pixel element
                        // if (element.elems.pixel.parentNode ===
                        //      element.elems.dataViewport) {
                        //     element.elems.dataViewport.removeChild(
                        //         element.elems.pixel
                        //     );
                        // }
                    }
                );
            }
        };

        element.internalEvents.textFilterContextMenu = function (
            buttonElement,
            columnIndex,
            strColumn,
            strValue,
            callback
        ) {
            var templateElement;

            // we want a function specifically for contextmenus,
            //      however, currently we dont have one so we'll
            //      use the GS.openDialogToElement function
            templateElement = document.createElement('template');
            templateElement.setAttribute('data-max-width', '17em');
            templateElement.setAttribute('no-background', '');
            templateElement.setAttribute('data-overlay-close', 'true');
            templateElement.innerHTML = ml(function () {/*
                <gs-page gs-dynamic class="gs-table-contextmenu">
                    <gs-body padded>
                        <center>
                            <i>Check each filter you want to apply.</i><br />
                            <i>
                                Matching values must pass every<br />
                                filter you choose.
                            </i>
                        </center>
                        <table>
                            <tbody>
                                <tr class="fltr-row fltr-eq">
                                    <td>
                                        <gs-checkbox remove-all mini>
                                            &nbsp;Equals</gs-checkbox>
                                    </td>
                                    <td><gs-text mini></gs-text></td>
                                </tr>
                                <tr class="fltr-row fltrn-eq">
                                    <td>
                                        <gs-checkbox remove-all mini>
                                            &nbsp;Doesn't Equal</gs-checkbox>
                                    </td>
                                    <td><gs-text mini></gs-text></td>
                                </tr>
                                <tr class="fltr-row fltr-contain">
                                    <td>
                                        <gs-checkbox remove-all mini>
                                            &nbsp;Contains</gs-checkbox>
                                    </td>
                                    <td><gs-text mini></gs-text></td>
                                </tr>
                                <tr class="fltr-row fltrn-contain">
                                    <td>
                                        <gs-checkbox remove-all mini>
                                            &nbsp;Doesn't Contain</gs-checkbox>
                                    </td>
                                    <td><gs-text mini></gs-text></td>
                                </tr>
                                <tr class="fltr-row fltr-starts">
                                    <td>
                                        <gs-checkbox remove-all mini>
                                            &nbsp;Starts With</gs-checkbox>
                                    </td>
                                    <td><gs-text mini></gs-text></td>
                                </tr>
                                <tr class="fltr-row fltr-ends">
                                    <td>
                                        <gs-checkbox remove-all mini>
                                            &nbsp;Ends With</gs-checkbox>
                                    </td>
                                    <td><gs-text mini></gs-text></td>
                                </tr>
                            </tbody>
                        </table>

                        <!--
                        <gs-checkbox remove-bottom>
                            &nbsp;Equals
                        </gs-checkbox>
                        <gs-checkbox remove-all>
                            &nbsp;Doesn't Equal
                        </gs-checkbox>
                        <gs-checkbox remove-all>
                            &nbsp;Contains
                        </gs-checkbox>
                        <gs-checkbox remove-all>
                            &nbsp;Doesn't Contain
                        </gs-checkbox>
                        <gs-checkbox remove-all>
                            &nbsp;Starts With
                        </gs-checkbox>
                        <gs-checkbox remove-top>
                            &nbsp;Ends With
                        </gs-checkbox>
                        -->
                    </gs-body>
                    <gs-footer>
                        <gs-grid gutter>
                            <gs-block>
                                <gs-button dialogclose>
                                    Cancel
                                </gs-button>
                            </gs-block>
                            <gs-block>
                                <gs-button dialogclose bg-primary>
                                    Apply
                                </gs-button>
                            </gs-block>
                        </gs-grid>
                    </gs-footer>
                </gs-page>
            */
            });

            GS.openDialogToElement(
                buttonElement,
                templateElement,
                'right',
                function () {
                    var dialog = this;
                    var arrElements;
                    var i;
                    var len;

                    // we want save the user a little time, so we'll pre-fill
                    //      the filter value text control
                    arrElements = xtag.query(dialog, '.fltr-row gs-text');
                    i = 0;
                    len = arrElements.length;
                    while (i < len) {
                        arrElements[i].value = strValue;

                        i += 1;
                    }

                    //fltr-row fltr-eq
                    //fltr-row fltr-not-eq
                    //fltr-row fltr-contain
                    //fltr-row fltr-not-contain
                    //fltr-row fltr-starts
                    //fltr-row fltr-ends
                },
                // event parameter ignored
                function (ignore, strAnswer) {
                    var dialog = this;
                    var arrRows;
                    var rowClass;
                    var checkElement;
                    var valueElement;
                    var strWhere;
                    var strName;
                    var strWhereValue;
                    var i;
                    var len;

                    // there's extra whitespace around the answer
                    strAnswer = strAnswer.trim();

                    if (strAnswer === 'Apply') {
                        arrRows = xtag.query(dialog, '.fltr-row');
                        i = 0;
                        len = arrRows.length;
                        while (i < len) {
                            checkElement = (
                                arrRows[i].children[0].children[0]
                            );
                            valueElement = (
                                arrRows[i].children[1].children[0]
                            );
                            strWhereValue = valueElement.value;

                            // try to save some room in the code,
                            //      shortcut variable
                            rowClass = arrRows[i].classList;

                            strWhere = '';
                            if (checkElement.value === 'true') {
                                if (rowClass.contains('fltr-eq')) {
                                    strWhere = 'CAST(' +
                                            strColumn + ' AS ' +
                                            GS.database.type.text +
                                            ') ' +
                                            '= $$' + strWhereValue + '$$';
                                    strName = 'equals "' + strWhereValue + '"';

                                } else if (rowClass.contains('fltrn-eq')) {
                                    strWhere = 'CAST(' +
                                            strColumn + ' AS ' +
                                            GS.database.type.text +
                                            ') ' +
                                            '!= $$' + strWhereValue + '$$';
                                    strName = 'doesn\'t equal ' +
                                            '"' + strWhereValue + '"';

                                } else if (rowClass.contains('fltr-contain')) {
                                    strWhere = 'CAST(' +
                                            strColumn + ' AS ' +
                                            GS.database.type.text +
                                            ') ' +
                                            'LIKE $$%' + strWhereValue + '%$$';
                                    strName = 'contains ' +
                                            '"' + strWhereValue + '"';

                                } else if (rowClass.contains('fltrn-contain')) {
                                    strWhere = 'CAST(' +
                                            strColumn + ' AS ' +
                                            GS.database.type.text +
                                            ') ' +
                                            'NOT LIKE ' +
                                            '$$%' + strWhereValue + '%$$';
                                    strName = 'doesn\'t ' +
                                            '"' + strWhereValue + '"';

                                } else if (rowClass.contains('fltr-starts')) {
                                    strWhere = 'CAST(' +
                                            strColumn + ' AS ' +
                                            GS.database.type.text +
                                            ') ' +
                                            'LIKE $$' + strWhereValue + '%$$';
                                    strName = 'starts with ' +
                                            '"' + strWhereValue + '"';

                                } else if (rowClass.contains('fltr-ends')) {
                                    strWhere = 'CAST(' +
                                            strColumn + ' AS ' +
                                            GS.database.type.text +
                                            ') ' +
                                            'LIKE $$%' + strWhereValue + '$$';
                                    strName = 'ends ' +
                                            '"' + strWhereValue + '"';
                                }
                            }

                            // if we create a where clause
                            if (strWhere) {
                                element
                                    .internalData
                                    .columnFilters[columnIndex]
                                    .push(
                                        {"text": strWhere, "name": strName}
                                    );
                            }

                            i += 1;
                        }

                        dataSELECT(element);
                    }

                    if (callback) {
                        callback(strAnswer);
                    }
                }
            );
        };

        element.internalEvents.advancedFilterContextMenu = function (
            //parentCell,
            //buttonElement,
            //strAnswer,
            //columnIndex,
            //strColumn,
            //strValue
        ) {
            // version 2
            // ### NEED CODING ### (VERSION 2)
        };

        element.elems.dataViewport.addEventListener(
            'contextmenu',
            element.internalEvents.columnContextMenu
        );
    }

    // ############# COLUMN DROPDOWN EVENTS #############
    function unbindColumnDropdown(element) {
        element.removeEventListener(
            'click',
            element.internalEvents.columnDropDown
        );
    }
    function bindColumnDropdown(element) {
        element.internalEvents.columnDropDown = function (event) {
            var target = event.target;
            var parentCell;
            var templateElement;
            var columnNumber;
            var strColumn;
            var columnIndex;
            var strHTML;
            var jsnMousePos;
            var jsnElementPos;
            var intMouseX;
            var intMouseY;

            if (target.classList.contains('header-button')) {
                // we need the mouse position and the element position
                jsnMousePos = GS.mousePosition(event);
                jsnElementPos = GS.getElementOffset(
                    element.elems.root
                );

                // we need the mouse X to be relative to the root element
                intMouseX = (jsnMousePos.left - jsnElementPos.left);

                // we need the mouse Y to be relative to the root element
                intMouseY = (jsnMousePos.top - jsnElementPos.top);

                // move the pixel element to where the mouse is so that we can
                //      position the dialog to it
                element.elems.pixel.style.left = (intMouseX + 'px');
                element.elems.pixel.style.top = (intMouseY + 'px');

                // we need the parent cell to get the display column number
                parentCell = GS.findParentTag(target, 'gs-cell');

                // we need the display column number to get the data column name
                columnNumber = (
                    parseInt(
                        parentCell.getAttribute('data-col-number'),
                        10
                    )
                );

                // we need to know what data column we're dealing with so that
                //      we can get the data column index
                strColumn = (
                    element.internalDisplay.dataColumnName[columnNumber]
                );

                // we need to know what data column index we're dealing with
                //      so that we can apply the sorts and filters
                columnIndex = (
                    element.internalData.columnNames.indexOf(strColumn)
                );

                // build up menu html
                strHTML = '';

                //
                strHTML += (
                    '<gs-button dialogclose remove-bottom' +
                    '            iconleft icon="sort-alpha-asc"' +
                    '            class="button-sort-asc">' +
                    '    Sort A to Z' +
                    '</gs-button>'
                );

                strHTML += (
                    '<gs-button dialogclose remove-all' +
                    '            iconleft icon="sort-alpha-desc"' +
                    '            class="button-sort-desc">' +
                    '    Sort Z to A' +
                    '</gs-button>'
                );

                strHTML += (
                    '<gs-button dialogclose remove-top' +
                    '            iconleft icon="trash-o"' +
                    '            class="button-sort-clear">' +
                    '    Clear Sort' +
                    '</gs-button>'
                );

                strHTML += (
                    '<div class="gs-table-unique-filter-container" hidden>' +
                    '    <hr />' +
                    '    <small><i>Filter By Selection:</i></small>' +
                    '    <div class="gs-table-unique-value-list"></div>' +
                    '    <div class="gs-table-unique-value-list-toolbar">' +
                    (
                        '<gs-button dialogclose remove-right ' +
                                    'inline>Cancel</gs-button>' +
                        '<gs-button dialogclose remove-left ' +
                                    'inline bg-primary>Ok</gs-button>'
                    ) +
                    '    </div>' +
                    '</div>'
                );

                strHTML += '<hr />';

                strHTML += (
                    '<gs-button dialogclose' +
                    '            iconleft icon="trash-o"' +
                    '            class="button-sort-clear">' +
                    '    Clear Filters' +
                    '</gs-button>'
                );

                templateElement = document.createElement('template');
                templateElement.setAttribute('data-max-width', '17em');
                templateElement.setAttribute('data-overlay-close', 'true');
                templateElement.setAttribute('no-background', '');
                templateElement.innerHTML = (
                    '<gs-page gs-dynamic class="gs-table-contextmenu">' +
                    '    <gs-body padded>' +
                    '        ' + strHTML +
                    '    </gs-body>' +
                    '</gs-page>'
                );

                // open the dialog
                GS.openDialogToElement(
                    element.elems.pixel,
                    // element.elems.pixel replaced target.parentNode because
                    //      when the dataviewport rerendered, the element we
                    //      were positioning to disappeared. so, we'll use the
                    //      pixel because we can count on that.
                    templateElement,
                    'down',
                    function () {
                        var dialog = this;

                        var uniqueFilterElement = xtag.query(
                            dialog,
                            '.gs-table-unique-filter-container'
                        )[0];
                        var valueListElement = xtag.query(
                            dialog,
                            '.gs-table-unique-value-list'
                        )[0];

                        // we want users to be able to choose from a list
                        //      of unique values for the column they chose
                        if (
                            uniqueFilterElement &&
                            valueListElement
                        ) {
                            // we need to get the unique value list
                            dataSELECTcolumnUnique(
                                element,
                                uniqueFilterElement,
                                valueListElement,
                                strColumn
                            );
                        }
                    },
                    // event variable ignored
                    function (ignore, strAnswer) {
                        var dialog = this;
                        var tableElement;
                        var valueListElement = xtag.query(
                            dialog,
                            '.gs-table-unique-value-list'
                        )[0];
                        var arrRecords;
                        var arrIncluded;
                        var arrExcluded;
                        var strValue;
                        var bolBlanks;
                        var i;
                        var len;

                        // there is extra whitespace on the answer
                        strAnswer = strAnswer.trim();

                        // if there is a unique value filter list
                        tableElement = valueListElement.children[0];
                        if (
                            tableElement &&
                            tableElement.nodeName === 'GS-TABLE'
                        ) {
                            // if the user chose to commit their choices for
                            //      the table filter
                            if (strAnswer === 'Ok') {
                                // if there are any checked/unchecked values, we
                                //      need to save the changes
                                // because the filter list can get long, we want
                                //      to make sure we create the smallest
                                //      where clause possible. to do this,
                                //      if there are fewer checked items:
                                //          column = checked items
                                //      else (there are fewer unchecked items):
                                //          column != unchecked items
                                // chances are, the user will only include or
                                //      exclude a small number of items, there
                                //      could be a speed problem if the user
                                //      goes and unchecks ~half of the items in
                                //      a column with thousands of unique
                                //      values. but if the user does that,
                                //      there is something wrong with the
                                //      user's workflow, give the poor person
                                //      a search screen for cryin' out loud.
                                arrRecords = tableElement.internalData.records;
                                arrIncluded = [];
                                arrExcluded = [];
                                i = 1; // we want to skip over the "Select All"
                                       //      record
                                len = arrRecords.length;
                                while (i < len) {
                                    strValue = (
                                        arrRecords[i].substring(
                                            arrRecords[i]
                                                .lastIndexOf('\t') + 1
                                        )
                                    );

                                    // we treat the blanks value different
                                    if (strValue === '(blanks)') {
                                        bolBlanks = (arrRecords[i][0] === '-');

                                    } else {
                                        // if this record is unchecked
                                        if (arrRecords[i][0] === '0') {
                                            arrExcluded.push(strValue);

                                        // else, this record is checked
                                        } else {
                                            arrIncluded.push(strValue);
                                        }
                                    }

                                    i += 1;
                                }

                                // default the column filter object to an empty
                                //      state
                                if (
                                    !element.internalData
                                        .columnListFilters[columnIndex]
                                ) {
                                    element.internalData.columnListFilters[
                                        columnIndex
                                    ] = {};
                                }

                                // if inclusion would result in a smaller where
                                if (arrIncluded.length < arrExcluded.length) {
                                    element.internalData.columnListFilters[
                                        columnIndex
                                    ].type = 'inclusion';

                                    element.internalData.columnListFilters[
                                        columnIndex
                                    ].values = (
                                        arrIncluded
                                    );

                                // else, use exclusion where clause
                                } else if (arrExcluded.length > 0) {
                                    element.internalData.columnListFilters[
                                        columnIndex
                                    ].type = 'exclusion';

                                    element.internalData.columnListFilters[
                                        columnIndex
                                    ].values = (
                                        arrExcluded
                                    );
                                } else {
                                    element.internalData.columnListFilters[
                                        columnIndex
                                    ].type = 'exclusion';

                                    element.internalData.columnListFilters[
                                        columnIndex
                                    ].values = (
                                        []
                                    );
                                }

                                element.internalData
                                    .columnListFilters[columnIndex]
                                    .blanks = (bolBlanks || false);

                                // we don't want to delay Garbage Collection,
                                //      empty out the arrays and any unused
                                //      data will become like so much digital
                                //      nothingness.
                                arrRecords = [];
                                arrExcluded = [];
                                arrIncluded = [];

                                // get the new data
                                dataSELECT(element);
                            }

                            // after this callback, the dialog is closed. this
                            //      causes a window resize event. we don't want
                            //      the window event from affecting the table
                            //      after it's been removed from the DOM. so,
                            //      we destroy the element before the gs-table
                            //      is removed.
                            tableElement.destroy();
                        }

                        // waterfall to commit changes
                        if (strAnswer === 'Sort A to Z') {
                            element.internalData
                                .columnOrders[columnIndex] = 'asc';
                            dataSELECT(element);

                        } else if (strAnswer === 'Sort Z to A') {
                            element.internalData
                                .columnOrders[columnIndex] = 'desc';
                            dataSELECT(element);

                        } else if (strAnswer === 'Clear Sort') {
                            element.internalData
                                .columnOrders[columnIndex] = 'neutral';
                            dataSELECT(element);

                        } else if (strAnswer === 'Clear Filters') {
                            element.internalData
                                .columnFilters[columnIndex] = [];
                            element.internalData
                                .columnListFilters[columnIndex] = {};
                            dataSELECT(element);
                        }
                    }
                );
            }
        };

        element.addEventListener(
            'click',
            element.internalEvents.columnDropDown
        );
    }

    // ############# DEVELOPER EVENTS #############
    function unbindDeveloper(element) {
        element.removeEventListener(
            evt.mousedown,
            element.internalEvents.developerMouseDown
        );
    }
    function bindDeveloper(element) {
        element.internalEvents.developerMouseDown = function (event) {
            var bolCMDorCTRL = (event.ctrlKey || event.metaKey);
            var bolShift = (event.shiftKey);
            var strHTML;
            var arrAttr;
            var jsnAttr;
            var i;
            var len;

            if (bolCMDorCTRL && bolShift) {
                event.preventDefault();
                event.stopPropagation();

                strHTML = '';
                arrAttr = element.attributes;
                i = 0;
                len = arrAttr.length;
                while (i < len) {
                    jsnAttr = arrAttr[i];

                    strHTML += (
                        '<b>Attribute "' + encodeHTML(jsnAttr.name) + '":</b>' +
                        '<pre>' + encodeHTML(jsnAttr.value) + '</pre>'
                    );

                    i += 1;
                }

                GS.msgbox('Developer Info', strHTML, ['Ok']);
            }
        };

        element.addEventListener(
            evt.mousedown,
            element.internalEvents.developerMouseDown
        );
    }

    // ############# VISIBILITY POLLING #############
    function unbindVisibilityPolling(element) {
        clearInterval(element.internalTimerIDs.visibilityIntervalID);
    }
    function bindVisibilityPolling(element) {
        element.internalTimerIDs.visibilityIntervalID = setInterval(
            function () {
                var jsnCache;
                var intWidth;
                var intHeight;
                var intFontSize;

                jsnCache = element.internalPollingCache;
                intWidth = element.clientWidth;
                intHeight = element.clientHeight;
                intFontSize = element.elems.fontSizeDetector.clientWidth;

                if (
                    jsnCache.elementWidth !== intWidth ||
                    jsnCache.elementHeight !== intHeight ||
                    jsnCache.fontSize !== intFontSize
                ) {
                    //console.log('test');
                    renderScrollDimensions(element);
                    GS.triggerEvent(window, 'resize');
                }

                jsnCache.elementWidth = intWidth;
                jsnCache.elementHeight = intHeight;
                jsnCache.fontSize = intFontSize;
            },
            75
        );
    }


    // ############# HIGH LEVEL BINDING #############
    function unbindElement(element) {
        unbindFocus(element);
        unbindScroll(element);
        unbindSelection(element);
        unbindCellResize(element);
        unbindColumnReorder(element);
        unbindUpdate(element);
        unbindInsert(element);
        unbindKey(element);
        unbindHUD(element);
        unbindCopy(element);
        unbindPaste(element);
        unbindContextMenu(element);
        unbindColumnDropdown(element);
        unbindCut(element);
        unbindDeveloper(element);
        unbindVisibilityPolling(element);
    }
    function bindElement(element) {
        bindFocus(element);
        bindScroll(element);
        bindSelection(element);
        bindCellResize(element);
        bindColumnReorder(element);
        bindUpdate(element);
        bindInsert(element);
        bindKey(element);
        bindHUD(element);
        bindCopy(element);
        bindPaste(element);
        bindContextMenu(element);
        bindColumnDropdown(element);
        bindCut(element);
        bindDeveloper(element);
        bindVisibilityPolling(element);
    }

// #############################################################################
// ############################## XTAG DEFINITION ##############################
// #############################################################################

    function elementInserted(element) {
        // if "created"/"inserted" are not suspended: run inserted code
        if (
            !element.hasAttribute('suspend-created') &&
            !element.hasAttribute('suspend-inserted')
        ) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

                resolveElementAttributes(element);
                prepareElement(element);
                siphonElement(element);
                renderHUD(element);
                bindElement(element);
                createWebWorker(element);
                //dataSELECT(element);
                GS.triggerEvent(element, 'initialized');
            }
        }
    }

    xtag.register('gs-table', {

// #############################################################################
// ############################# ELEMENT LIFECYCLE #############################
// #############################################################################

        lifecycle: {
            'created': function () {},

            'inserted': function () {
                elementInserted(this);
            },

            'removed': function () {
                this.destroy();
            },

            'attributeChanged': function (strAttrName) {//, oldValue, newValue
                var element = this;

                // if suspend attribute: run inserted event
                if (
                    strAttrName === 'suspend-created' ||
                    strAttrName === 'suspend-inserted'
                ) {
                    elementInserted(element);

                // if the element is not suspended: handle attribute changes
                } else if (
                    !element.hasAttribute('suspend-created') &&
                    !element.hasAttribute('suspend-inserted')
                ) {
                    if (strAttrName === 'value' && element.root) {
                        element.refresh();
                    }
                }
            }
        },

// #############################################################################
// ############################# ELEMENT ACCESSORS #############################
// #############################################################################

        accessors: {
            'selection': {
                'get': function () {
                    return this.internalSelection.ranges;
                }
            },
            'selectedColumns': {
                'get': function () {
                    return this.internalSelection.columns;
                }
            },
            'selectedRecords': {
                'get': function () {
                    return this.internalSelection.rows;
                }
            },
            'data': {
                'get': function () {
                    return {
                        "columns": this.internalData.columnNames,
                        "types": this.internalData.columnTypes,
                        "records": this.internalData.records
                    };
                }
            },
            'value': {
                'get': function () {
                    return this.getAttribute('value');
                },
                'set': function (newValue) {
                    this.setAttribute('value', newValue);
                }
            }
        },

// #############################################################################
// ############################## ELEMENT METHODS ##############################
// #############################################################################

        methods: {
            'destroy': function () {
                var element = this;

                // sometimes, the gs-table gets destroyed multiple times.
                //      we don't want to cause any errors when this happens.
                if (element.elems.dataViewport) {
                    // prevent the element from recieving any events
                    unbindElement(element);

                    // destroy the web worker, if there is one
                    if (element.internalWorker.worker) {
                        element.internalWorker.worker.terminate();
                    }

                    // this is the fastest way to destroy all of the data
                    element.internalData = {};
                    element.internalScrollOffsets = {};
                    element.internalEvents = {};
                    element.internalEventCancelled = {};
                    element.internalScroll = {};
                    element.internalTimerIDs = {};
                    element.internalTemplates = {};
                    element.internalDisplay = {};
                    element.internalSelection = {};
                    element.internalClip = {};
                    element.internalWorker = {};
                    element.internalLoaders = {};
                    element.internalResize = {};
                    element.internalReorder = {};

                    // destroy element store
                    element.elems = {};

                    // empty innerHTML
                    element.innerHTML = '';
                }
            },
            'refresh': function () {
                dataSELECT(this);
            },
            'selectData': function () {
                dataSELECT(this);
            },
            'insertData': function (jsnInsert) {
                dataINSERT(this, jsnInsert);
            },
            'updateData': function (jsnUpdate) {
                dataUPDATE(this, jsnUpdate);
            },
            'deleteData': function (jsnDeleteData) {
                dataDELETE(this, jsnDeleteData);
            },
            'render': function () {
                renderScrollDimensions(this);
            },
            'toggleFullContainer': function (container, target) {
                var element = this;
                var containerElement;

                containerElement = document.getElementById(container);

                if (element.classList.contains('absolute')) {
                    GS.triggerEvent(element, 'closeFullContainer');
                    element.classList.remove('absolute');
                    containerElement.classList.remove('relative');
                    target.setAttribute('icon', 'expand');
                } else {
                    GS.triggerEvent(element, 'openFullContainer');
                    element.classList.add('absolute');
                    containerElement.classList.add('relative');
                    target.setAttribute('icon', 'compress');
                }

                renderScrollDimensions(element);
            },
            'openFullContainer': function (container, target) {
                var element = this;
                var containerElement;

                containerElement = document.getElementById(container);

                if (!element.classList.contains('absolute')) {
                    GS.triggerEvent(element, 'openFullContainer');
                    element.classList.add('absolute');
                    containerElement.classList.add('relative');
                    target.setAttribute('icon', 'compress');
                }

                renderScrollDimensions(element);
            },
            'closeFullContainer': function (container, target) {
                var element = this;
                var containerElement;

                containerElement = document.getElementById(container);

                if (element.classList.contains('absolute')) {
                    GS.triggerEvent(element, 'closeFullContainer');
                    element.classList.remove('absolute');
                    containerElement.classList.remove('relative');
                    target.setAttribute('icon', 'expand');
                }

                renderScrollDimensions(element);
            },
            //'scrollToColumn': function (columnNumber) {
            //},
            //'scrollToRow': function (rowNumber) {
            //},
            //'scrollToCell': function (rowNumber, columnNumber) {
            //},
            'deleteSelected': function () {
                deleteSelectedRecords(this);
            },
            'clearFilter': function () {
                var filter_i;
                var filter_len;

                filter_i = 0;
                filter_len = this.internalData.columnFilters.length;
                while (filter_i < filter_len) {
                    this.internalData.columnFilters[filter_i] = [];
                    this.internalData.columnListFilters[filter_i] = {};

                    filter_i += 1;
                }

                // refresh the table
                dataSELECT(this);
            },
            'toggleFullscreen': function (target) {
                var element = this;

                // using a class like this doesn't work on iOS (other things
                //      z-index over it), we need to move the element to the
                //      last element in the body and then apply the class.
                // ### NEED CODING ###
                if (element.classList.contains('table-fullscreen')) {
                    GS.triggerEvent(element, 'closeFullScreen');
                    element.classList.remove('table-fullscreen');

                    if (target.getAttribute('icon') === 'close') {
                        target.setAttribute('icon', 'arrows-alt');
                    }
                } else {
                    GS.triggerEvent(element, 'openFullscreen');
                    element.classList.add('table-fullscreen');

                    if (target.getAttribute('icon') === 'arrows-alt') {
                        target.setAttribute('icon', 'close');
                    }
                }
                renderScrollDimensions(element);
            },
            'openFullscreen': function (target) {
                var element = this;

                if (!element.classList.contains('table-fullscreen')) {
                    GS.triggerEvent(element, 'openFullscreen');
                    element.classList.add('table-fullscreen');
                    if (target.getAttribute('icon') === 'arrows-alt') {
                        target.setAttribute('icon', 'close');
                    }
                }
                renderScrollDimensions(element);
            },
            'closeFullscreen': function (target) {
                var element = this;

                if (element.classList.contains('table-fullscreen')) {
                    GS.triggerEvent(element, 'closeFullScreen');
                    element.classList.remove('table-fullscreen');

                    if (target.getAttribute('icon') === 'close') {
                        target.setAttribute('icon', 'arrows-alt');
                    }
                }
                renderScrollDimensions(element);
            },
            'openPrefs': function (target) {
                openSettingsDialog(this, target);
            },
            'sort': function (action) {
                var strNewSort;
                if (action === 'asc') {
                    strNewSort = 'asc';
                } else if (action === 'desc') {
                    strNewSort = 'desc';
                } else if (action === 'clear') {
                    strNewSort = 'neutral';
                } else {
                    strNewSort = 'neutral';
                }

                // we need the column orderby array
                var arrColumnOrders = (
                    this.internalData.columnOrders
                );

                // loop through each selected data column and set the orderby
                var arrDataColumns = getSelectedDataColumns(this);
                var i = 0;
                var len = arrDataColumns.length;
                while (i < len) {
                    arrColumnOrders[
                        arrDataColumns[i]
                    ] = strNewSort;

                    i += 1;
                }

                // refresh the table
                dataSELECT(this);
            },
            'openInsertDialog': function () {
                openInsertDialog(this);
            },
            'goToLine': function (action) {
                var intCurrentRecord = (
                    this.internalSelection.originRecord || 0
                );
                var intMaxRecord = (
                    this.internalData.records.length - 1
                );
                var intMinColumn = (
                    this.internalDisplay.recordSelectorVisible
                        ? -1
                        : 0
                );

                if (action === 'insert') {
                    scrollCellIntoView(this, 'insert', '0', 'top');
                } else {
                    // set current record based on which button was clicked
                    if (action === 'first') {
                        intCurrentRecord = 0;
                    } else if (action === 'previous') {
                        intCurrentRecord -= 1;
                    } else if (action === 'next') {
                        intCurrentRecord += 1;
                    } else if (action === 'plusten') {
                        intCurrentRecord += 10;
                    } else if (action === 'minusten') {
                        intCurrentRecord -= 10;
                    } else if (action === 'last') {
                        intCurrentRecord = intMaxRecord;
                    } else if (typeof action === 'number') {
                        intCurrentRecord = action - 1;
                    } else {
                        intCurrentRecord = parseInt(action, 10) - 1;
                    }

                    //if the new record is past the last record:
                    //      go to last record
                    if (intCurrentRecord > intMaxRecord) {
                        intCurrentRecord = intMaxRecord;
                    }

                    // if the new record is a negative number:
                    //      go to first record
                    if (intCurrentRecord < 0) {
                        intCurrentRecord = 0;
                    }

                    // if there are no records, clear new record
                    if (intMaxRecord === -1) {
                        intCurrentRecord = undefined;
                    }
                    // override all current ranges to select the new record
                    if (intCurrentRecord !== undefined) {
                        this.internalSelection.ranges = [
                            {
                                "start": {
                                    "row": intCurrentRecord,
                                    "column": intMinColumn
                                },
                                "end": {
                                    "row": intCurrentRecord,
                                    "column": intMinColumn
                                },
                                "negator": false
                            }
                        ];
                    } else {
                        this.internalSelection.ranges = [];
                    }
                    // render selection and scroll into view
                    renderSelection(this);
                    scrollSelectionIntoView(this, 'top');
                }
            },
            'clearSelection': function () {
                var element = this;

                // empty selection array
                element.internalSelection.ranges = [];

                // re-render selection
                renderSelection(element);
            },
            'addSelectionRange': function (
                fromRow,
                fromColumn,
                toRow,
                toColumn,
                bolNegate
            ) {
                var element = this;

                // bolNegate must be true or false, default to false
                if (
                    bolNegate === undefined ||
                    typeof bolNegate !== 'boolean'
                ) {
                    bolNegate = false;
                }

                // create range JSON and append to selections
                element.internalSelection.ranges.push({
                    "start": {
                        "row": fromRow,
                        "column": fromColumn
                    },
                    "end": {
                        "row": toRow,
                        "column": toColumn
                    },
                    "negator": false
                });

                // re-render selection
                renderSelection(element);
            },
            'getCopyStrings': function () {
                return getCopyStrings(this);
            },
            'paste': function (strPasteString) {
                usePasteString(this, strPasteString);
            },
            'resizeAllColumns': function () {
                var element = this;
                var arrIndexes = [];
                var i;
                var len;

                i = 0;
                len = element.internalDisplay.columnPlainTextNames.length;
                while (i < len) {
                    arrIndexes.push(i);
                    i += 1;
                }

                resizeColumnsToContent(element, arrIndexes);
            },
            'addFilter': function (filterColumn, filterType, filterValue) {
                var element = this;
                var columnIndex;
                var strWhere;
                var strName;

                // filterType must be one of these values: (defaults to equals)
                //      'contains', 'notcontains',
                //      'starts', 'notstarts',
                //      'ends', 'notends',
                //      'equals', 'notequals',
                //      'greaterthan', 'notgreaterthan',
                //      'lessthan', 'notlessthan'
                if (
                    !(/^(contains|starts|ends)$/gi).test(filterType) &&
                    !(/^(equals|greaterthan|lessthan)$/gi).test(filterType) &&
                    !(/^(notcontains|notstarts|notends)$/gi).test(filterType) &&
                    !(/^(notequals|notgreaterthan)$/gi).test(filterType) &&
                    !(/^(notlessthan)$/gi).test(filterType)
                ) {
                    throw 'GS-TABLE Error: invalid filter type given to ' +
                            'ELEMENT.addFilter(filterColumn, filterType, ' +
                            'filterValue). Given filter type was ' +
                            '"' + filterType + '", must be "contains", ' +
                            '"starts", "ends", "equals", "greaterthan", ' +
                            '"lessthan", "notcontains", "notstarts", ' +
                            '"notends", "notequals", "notgreaterthan" ' +
                            'or "notlessthan".';
                }

                // we want to use the filterType in an if statement, let's
                //      lowercase it to make comparisons easier
                filterType = filterType.toLowerCase();

                // filterValue must not be empty: error if nothing provided
                if (filterValue === undefined) {
                    throw 'GS-TABLE Error: no filter value given to ' +
                            'ELEMENT.addFilter(filterColumn, filterType, ' +
                            'filterValue)';
                }

                // if value provided: cast to JS string to prevent type issues
                filterValue = filterValue.toString();

                // equals (TEXT)
                if (filterType === 'equals') {
                    strWhere = 'CAST(' +
                            filterColumn + ' AS ' +
                            GS.database.type.text +
                            ') ' +
                            '= $$' + filterValue + '$$';
                    strName = 'equals' +
                            ' "' + filterValue + '"';

                // not equals (TEXT)
                } else if (filterType === 'notequals') {
                    strWhere = 'CAST(' +
                            filterColumn + ' AS ' +
                            GS.database.type.text +
                            ') ' +
                            '!= $$' + filterValue + '$$';
                    strName = 'doesn\'t equal' +
                            ' "' + filterValue + '"';

                // contains (TEXT)
                } else if (filterType === 'contains') {
                    strWhere = 'CAST(' +
                            filterColumn + ' AS ' +
                            GS.database.type.text +
                            ') ' +
                            'LIKE $$%' + filterValue + '%$$';
                    strName = 'contains' +
                            ' "' + filterValue + '"';

                // doesn't contain (TEXT)
                } else if (filterType === 'notcontains') {
                    strWhere = 'CAST(' +
                            filterColumn + ' AS ' +
                            GS.database.type.text +
                            ') ' +
                            'NOT LIKE ' +
                            '$$%' + filterValue + '%$$';
                    strName = 'doesn\'t contain' +
                            ' "' + filterValue + '"';

                // starts with (TEXT)
                } else if (filterType === 'starts') {
                    strWhere = 'CAST(' +
                            filterColumn + ' AS ' +
                            GS.database.type.text +
                            ') ' +
                            'LIKE $$' + filterValue + '%$$';
                    strName = 'starts with' +
                            ' "' + filterValue + '"';

                // doesn't start with (TEXT)
                } else if (filterType === 'notstarts') {
                    strWhere = 'CAST(' +
                            filterColumn + ' AS ' +
                            GS.database.type.text +
                            ') ' +
                            'NOT LIKE $$' + filterValue + '%$$';
                    strName = '' +
                            ' "' + filterValue + '"';

                // ends with (TEXT)
                } else if (filterType === 'ends') {
                    strWhere = 'CAST(' +
                            filterColumn + ' AS ' +
                            GS.database.type.text +
                            ') ' +
                            'LIKE $$%' + filterValue + '$$';
                    strName = 'ends with' +
                            ' "' + filterValue + '"';

                // doesn't end with (TEXT)
                } else if (filterType === 'notends') {
                    strWhere = 'CAST(' +
                            filterColumn + ' AS ' +
                            GS.database.type.text +
                            ') ' +
                            'NOT LIKE $$%' + filterValue + '$$';
                    strName = 'doesn\'t end with' +
                            ' "' + filterValue + '"';

                // greaterthan (INTEGER/NUMERIC)
                } else if (filterType === 'greaterthan') {
                    strWhere = (
                        filterColumn + ' > ' + filterValue
                    );
                    strName = 'greater than' +
                            ' "' + filterValue + '"';

                // not greaterthan (INTEGER/NUMERIC)
                } else if (filterType === 'notgreaterthan') {
                    strWhere = (
                        filterColumn + ' <= ' + filterValue
                    );
                    strName = 'not greater than' +
                            ' "' + filterValue + '"';

                // lessthan (INTEGER/NUMERIC)
                } else if (filterType === 'lessthan') {
                    strWhere = (
                        filterColumn + ' < ' + filterValue
                    );
                    strName = 'less than' +
                            ' "' + filterValue + '"';

                // not lessthan (INTEGER/NUMERIC)
                } else if (filterType === 'notlessthan') {
                    strWhere = (
                        filterColumn + ' >= ' + filterValue
                    );
                    strName = 'not less than' +
                            ' "' + filterValue + '"';
                }

                // turn the updated column name into a column index so that
                //      we can fetch the old data from the data
                columnIndex = (
                    element.internalData.columnNames.indexOf(filterColumn)
                );

                // if we were able to create a where, push it to the filter
                //      list
                if (strWhere) {
                    element.internalData
                        .columnFilters[columnIndex].push(
                            {
                                "text": strWhere,
                                "name": strName
                            }
                        );

                    // master, why didn't you refresh the table after a where
                    //      was created?
                    // young grasshopper, you must think of the developer who
                    //      will use this table, what if he were to add three
                    //      filters, one right after the other? in order to
                    //      prevent speed issues we must make him refresh the
                    //      table.

                // else, warn about invalid where
                } else {
                    console.warn('GS-TABLE Warning: Unable to create where' +
                            'clause.\n' +
                            'Here are the parameters that failed:\n' +
                            '\tfilterColumn:   "' + filterColumn + '"\n' +
                            '\tfilterType:     "' + filterType + '"\n' +
                            '\tfilterValue:    "' + filterValue + '"');
                }
            }
        }
    });
});
//global GS, window, document, registerDesignSnippet, designRegisterElement, addProp, encodeHTML, setOrRemoveTextAttribute, setOrRemoveBooleanAttribute, addFlexProps

window.addEventListener('design-register-element', function () {

    registerDesignSnippet('<gs-text>', '<gs-text>', 'gs-text column="${1:name}"></gs-text>');
    registerDesignSnippet('<gs-text> With Label', '<gs-text>',
            'label for="${1:text-insert-last_name}">${2:Last Name}:</label>\n' +
            '<gs-text id="${1:text-insert-last_name}" column="${3:last_name}"></gs-text>');

    designRegisterElement('gs-text', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-text.html');

    window.designElementProperty_GSTEXT = function (selectedElement) {
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
        });

        //console.log(selectedElement.hasAttribute('mini'));

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });

        addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
        });

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility', true,
                '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                '    <option value="">Visible</option>' +
                '    <option value="hidden">Invisible</option>' +
                '    <option value="hide-on-desktop">Invisible at desktop size</option>' +
                '    <option value="hide-on-tablet">Invisible at tablet size</option>' +
                '    <option value="hide-on-phone">Invisible at phone size</option>' +
                '    <option value="show-on-desktop">Visible at desktop size</option>' +
                '    <option value="show-on-tablet">Visible at tablet size</option>' +
                '    <option value="show-on-phone">Visible at phone size</option>' +
                '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();

        event.target.parentNode.syncGetters();//iphone sometimes doesn't do a key like with time wheels

        GS.triggerEvent(event.target.parentNode, 'change');

        return false;
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
        event.target.parentNode.classList.add('focus');
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'blur');
        event.target.parentNode.classList.remove('focus');
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseout);
        event.target.parentNode.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseover);
        event.target.parentNode.classList.add('hover');
    }

    //function createPushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');

    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function createPushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.value = strQSValue;
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = null;
            }
        }
    }

    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                //var strQSValue;

                // handle control
                element.handleContents();

                // fill control
                element.syncView();

                // bind/handle query string
                if (element.getAttribute('qs')) {
                    //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));

                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.value = strQSValue;
                    //}
                    createPushReplacePopHandler(element);
                    window.addEventListener('pushstate', function () {
                        createPushReplacePopHandler(element);
                    });
                    window.addEventListener('replacestate', function () {
                        createPushReplacePopHandler(element);
                    });
                    window.addEventListener('popstate', function () {
                        createPushReplacePopHandler(element);
                    });
                }

                // if this element is empty when it is inserted: initalize
                if (element.innerHTML.trim() === '') {
                    // handle control
                    element.handleContents();

                    // fill control
                    element.syncView();
                }
            }
        }
    }

    xtag.register('gs-text', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(element);
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);

                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    var currentValue;

                    if (strAttrName === 'disabled' || strAttrName === 'readonly') {
                        // handle control
                        element.handleContents();

                        // fill control
                        element.syncView();

                    } else if (strAttrName === 'value' && element.initalized) {
                        //if (element.hasAttribute('disabled')) {
                        //    currentValue = element.innerHTML;
                        //} else {
                            currentValue = element.control.value;
                        //}

                        // if there is a difference between the new value in the
                        //      attribute and the valued in the front end: refresh the front end
                        if (newValue !== currentValue) {
                            element.syncView();
                        }
                    }
                }
            }
        },
        events: {
            // on keydown and keyup sync the value attribute and the control value
            'keydown': function (event) {
                var element = this;
                if (!element.hasAttribute('readonly') && !element.hasAttribute('disabled')) {
                    //if (element.hasAttribute('disabled') && event.keyCode !== 9) {
                    //    event.preventDefault();
                    //    event.stopPropagation();
                    //} else {
                        element.syncGetters();
                    //}
                }
            },
            'keyup': function () {
                var element = this;
                if (!element.hasAttribute('readonly') && !element.hasAttribute('disabled')) {
                    element.syncGetters();
                }
            }
        },
        accessors: {
            value: {
                // get value straight from the input
                get: function () {
                    return this.getAttribute('value');
                },

                // set the value of the input and set the value attribute
                set: function (strNewValue) {
                    this.setAttribute('value', strNewValue);
                }
            }
        },
        methods: {
            focus: function () {
                var element = this;
                if (element.control) {
                    element.control.focus();
                }
            },

            handleContents: function () {
                var element = this;
                var arrPassThroughAttributes = [
                        'placeholder', 'name', 'maxlength', 'autocorrect',
                        'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                        'readonly', 'disabled'
                    ];
                var i;
                var len;

                // if the gs-text element has a tabindex: save the tabindex and remove the attribute
                if (element.hasAttribute('tabindex')) {
                    element.savedTabIndex = element.getAttribute('tabindex');
                    element.removeAttribute('tabindex');
                }

                // if the gs-text doesn't have a disabled attribute: use an input element
                // if (!element.hasAttribute('disabled')) {
                    // add control input and save it to a variable for later use
                    element.innerHTML = '<input class="control" gs-dynamic type="' + (element.getAttribute('type') || 'text') + '" />';
                    element.control = element.children[0];

                    // bind event re-targeting functions
                    element.control.removeEventListener('change', changeFunction);
                    element.control.addEventListener('change', changeFunction);

                    element.control.removeEventListener('focus', focusFunction);
                    element.control.addEventListener('focus', focusFunction);

                    element.control.removeEventListener('blur', blurFunction);
                    element.control.addEventListener('blur', blurFunction);

                    element.control.removeEventListener(evt.mouseout, mouseoutFunction);
                    element.control.addEventListener(evt.mouseout, mouseoutFunction);

                    element.control.removeEventListener(evt.mouseout, mouseoverFunction);
                    element.control.addEventListener(evt.mouseover, mouseoverFunction);

                    // copy passthrough attributes to control
                    i = 0;
                    len = arrPassThroughAttributes.length;
                    while (i < len) {
                        if (element.hasAttribute(arrPassThroughAttributes[i])) {
                            if (arrPassThroughAttributes[i] === 'disabled') {
                                element.control.setAttribute(
                                    'readonly',
                                    element.getAttribute(arrPassThroughAttributes[i]) || ''
                                );
                            } else {
                                element.control.setAttribute(
                                    arrPassThroughAttributes[i],
                                    element.getAttribute(arrPassThroughAttributes[i]) || ''
                                );
                            }
                        }
                        i += 1;
                    }

                    // if we saved a tabindex: apply the tabindex to the control
                    if (element.savedTabIndex !== undefined && element.savedTabIndex !== null) {
                        element.control.setAttribute('tabindex', element.savedTabIndex);
                    }

                // else if the gs-text is disabled: clear the control variable and empty the gs-text
                // } else {
                //     element.control = undefined;
                //     element.innerHTML = '';
                // }
            },

            syncView: function () {
                var element = this;
                //if (element.hasAttribute('disabled')) {
                //    element.textContent = element.getAttribute('value') || element.getAttribute('placeholder');
                //} else {
                    element.control.value = element.getAttribute('value') || '';
                //}
                element.initalized = true;
            },

            syncGetters: function () {
                this.setAttribute('value', this.control.value);
            }
        }
    });
});window.addEventListener('design-register-element', function () {

    registerDesignSnippet('<gs-time>', '<gs-time>', 'gs-time column="${1:name}"></gs-time>');
    registerDesignSnippet('<gs-time> With Label', '<gs-time>', 'label for="${1:time-insert-start_time}">${2:Start Time}:</label>\n' +
                                                               '<gs-time id="${1:time-insert-start_time}" column="${3:start_time}"></gs-time>');

    designRegisterElement('gs-time', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-time.html');

    window.designElementProperty_GSTIME = function(selectedElement) {
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('placeholder') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'placeholder', this.value);
        });

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        addProp('Time Picker', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-picker')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-picker', (this.value === 'true'), false);
        });

        addProp('Non-Empty', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('non-empty')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'non-empty', (this.value === 'true'), true);
        });

        addProp('Now Button', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-now-button')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-now-button', (this.value === 'true'), false);
        });

        addProp('Display Format', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('format') || '') + '" mini>' +
                                    '<option value="">Regular (1:30 PM)</option>' +
                                    '<option value="military">Military (13:30)</option>' +
                                '</gs-select>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'format', this.value);
        });

        addProp('Output Format', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('output-format') || '') + '" mini>' +
                                    '<option value="">Regular (1:30 PM)</option>' +
                                    '<option value="military">Military (13:30)</option>' +
                                '</gs-select>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'output-format', this.value);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });

        addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        // READONLY attribute
        addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';
    var currentErrorControl;

    window.addEventListener('focus', function (event) {
        if (currentErrorControl && event.target !== currentErrorControl.control) {
            currentErrorControl.control.focus();
            if (currentErrorControl.control) {
                GS.setInputSelection(currentErrorControl.control, 0, currentErrorControl.control.value.length);
            }
        }

        if (currentErrorControl && currentErrorControl.control && currentErrorControl.control.value) {
            currentErrorControl = '';
        }
    });

    //x attributes:
    //x      placeholder:   copy to control element
    //x      disabled:      copy to control element
    //x      tabindex:      move to control element
    //x      qs:            fill value from querystring, update value as querystring changes
    //x      non-empty:     prevent leaving the field if value is empty, console warn if value starts as empty
    //x      format:        affects value translation when filling control
    //x      no-now-button: affects dropdown html and "n" key
    //x      value:         affects control value
    //x      no-picker:     affects innerHTML because it removes the picker button

    //x accessors:
    //x      value:     returns text value
    //x      dateValue: returns value as a date object
    //x      state:     returns text representation of state: "open" or "closed"

    //x methods:
    //x      open:   opens popup
    //x      close:  closes popup
    //x      toggle: toggles open and closed methods

    //x events:
    //x      picker button click: runs "toggle" method
    //x      control keydown:
    //x          up arrow:    next minute
    //x          down arrow:  previous minute
    //x          left arrow:  previous minute
    //x          right arrow: next minute
    //x          "c":         clear (if allowed)
    //x          "n":         now (if allowed)

    //x dropdown behaviours:
    //x      if from control to bottom is too small and from control to top is too small: dialog
    //x      else if window width < 400px: dialog
    //x      else if window height < 550px: dialog
    //x      else:
    //x          if from control to bottom has enough room: popup below
    //x          else: popup above

    // #####################################################################################
    // ################################## EVENT RETARGETING ################################
    // #####################################################################################

    // re-target change event from control to element
    function changeFunction(event) {
        event.preventDefault();
        event.stopPropagation();

        event.target.parentNode.setAttribute('value', event.target.value);
        //console.log('this is a test', event.target);
        handleChange(event.target.parentNode);
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
        event.target.parentNode.classList.add('focus');
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'blur');
        event.target.parentNode.classList.remove('focus');
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseout);
        event.target.parentNode.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseover);
        event.target.parentNode.classList.add('hover');
    }


    // #####################################################################################
    // ####################################### CONTROL #####################################
    // #####################################################################################

    function refreshControl(element) {
        var i, len, arrPassThroughAttributes, strHTML;

        // clear out HTML
        element.innerHTML = '';

        // clear out element variables
        element.control = '';
        element.button = '';

        // if we are not disabled:
        if (!element.hasAttribute('disabled')) {
            // build HTML
            strHTML = '<input class="control" gs-dynamic type="text" />';
            if (!element.hasAttribute('no-picker')) {
                strHTML += '<gs-button class="time-picker-button" gs-dynamic inline icononly icon="clock-o" no-focus></gs-button>';
            }

            // set control HTML
            element.innerHTML = strHTML;

            // fill element variables
            element.control = element.children[0];
            element.button = element.children[1];

            // handle passthrough attributes
            arrPassThroughAttributes = [
                'placeholder', 'name', 'maxlength', 'autocorrect',
                'autocapitalize', 'autocomplete', 'autofocus', 'spellcheck',
                'readonly'
            ];

            i = 0;
            len = arrPassThroughAttributes.length;
            while (i < len) {
                if (element.hasAttribute(arrPassThroughAttributes[i])) {
                    element.control.setAttribute(
                        arrPassThroughAttributes[i],
                        element.getAttribute(arrPassThroughAttributes[i]) || ''
                    );
                }
                i += 1;
            }

            // move tabindex
            if (element.hasAttribute('tabindex')) {
                element.oldTabIndex = element.getAttribute('tabindex');
                element.removeAttribute('tabindex');
            }

            if (element.oldTabIndex) {
                element.control.tabIndex = element.oldTabIndex;
            }

            // bind control retargeting
            element.control.removeEventListener('change', changeFunction);
            element.control.addEventListener('change', changeFunction);

            element.control.removeEventListener('focus', focusFunction);
            element.control.addEventListener('focus', focusFunction);

            element.control.removeEventListener('blur', blurFunction);
            element.control.addEventListener('blur', blurFunction);

            element.control.removeEventListener(evt.mouseout, mouseoutFunction);
            element.control.addEventListener(evt.mouseout, mouseoutFunction);

            element.control.removeEventListener(evt.mouseover, mouseoverFunction);
            element.control.addEventListener(evt.mouseover, mouseoverFunction);
        }

        // display value
        setValueDisplay(element, element.getAttribute('value'));
    }

    function handleChange(element) {
        element.close();
        if (handleNonEmpty(element) && element.lastChangeValue !== element.getAttribute('value')) {
            GS.triggerEvent(element, 'change');
            element.lastChangeValue = element.getAttribute('value');
        }
    }

    function handleNonEmpty(element) {
        var bolAllClear = true;

        if (element.hasAttribute('non-empty') && !element.getAttribute('value')) {
            bolAllClear = false;
            currentErrorControl = element;
            alert('Error: Invalid Time. Please input a time.');
            element.open();
        }

        return bolAllClear;
    }


    // #####################################################################################
    // ######################################## VALUE ######################################
    // #####################################################################################

    // translate inputed value to a format that is allowed. no seconds as of yet, defaults to AM
    function translateValue(strFormat, newValue) {
        var translatedValue;
        var valueDate;
        var strHour;
        var strMinute;
        var strPeriod;
        var arrParts;
        var intHours;

        // coalesce value
        newValue = newValue || '';
        //console.log('newValue >' + newValue + '<');

        // if value is a string: parse
        if (typeof newValue === 'string') {
            // input types:
            //      "1530"          => "15:30"
            //      "0330"          => "03:30"
            //      "3:30"          => "3:30"
            //      "3:30PM"        => "3:30 PM" (all cases/variations of PM/AM) ('a', 'p', 'am', 'pm', 'Am', 'Pm', 'AM', 'PM')
            //      "330"           => "3:30"
            //      "3"             => "3:00"
            //      "12"            => "12:00"
            //      "12PM"          => "12:00 PM" (all cases/variations of PM/AM) ('a', 'p', 'am', 'pm', 'Am', 'Pm', 'AM', 'PM')
            //      "12:30:12 PM"   => "12:30 PM" (no seconds as of yet)
            //      "123012"        => "12:30" (no seconds as of yet)

            // extract period
            strPeriod = (newValue.match(/pm|am|a|p/gi) || [''])[0].toLowerCase();
            newValue  = newValue.replace(/[^0-9:]/gi, '');

            //console.log('before strPeriod>' + strPeriod + '<');
            if (strPeriod) {
                strPeriod = (strPeriod[0] === 'a' ? 'AM' : 'PM');
            }
            //console.log('after strPeriod>' + strPeriod + '<');

            if (newValue) {
                // if there are colon(s): split on colons
                if ((/:/).test(newValue)) {
                    arrParts = newValue.split(':');

                    strHour = arrParts[0];
                    strMinute = GS.leftPad(arrParts[1], '0', 2);

                    // if hour is greater than 12: subtract 12 and set period to PM
                    if (parseInt(strHour, 10) > 12) {
                        strHour = parseInt(strHour, 10) - 12;
                        strPeriod = 'PM';
                        //console.log('set strPeriod to PM');
                    }

                // else (if there are just numbers)
                } else {
                    newValue = newValue.substring(0, 4);

                    // if the new value is 3 or 4 characters long: last 2 are minute and the rest is hour
                    if (newValue.length >= 3) {
                        strMinute = newValue.substring(newValue.length - 2);
                        strHour = newValue.substring(0, newValue.length - 2);

                        // if hour is greater than 12: subtract 12 and set period to PM
                        if (parseInt(strHour, 10) > 12) {
                            strHour = parseInt(strHour, 10) - 12;
                            strPeriod = 'PM';
                            //console.log('set strPeriod to PM');
                        }

                    // else:
                    } else {
                        newValue = parseInt(newValue, 10);

                        // if (format is military AND number > 24) OR (format isn't military AND number > 12): newValue is minute
                        if ((strFormat === 'military') && newValue > 24 || (strFormat !== 'military') && newValue > 12) {
                            strHour = '12';
                            strMinute = String(newValue);
                        } else {
                            strHour = String(newValue);
                            strMinute = '00';
                        }
                    }
                }
            }

            if (strHour && strMinute) {
                if (!strPeriod) {
                    //console.log('strHour>' + strHour + '<');
                    //console.log('parseInt(strHour, 10)>' + parseInt(strHour, 10) + '<');
                    if (parseInt(strHour, 10) >= 12) {
                    //if (parseInt(strHour, 10) < 6 || parseInt(strHour, 10) === 12) {//Who did this? -Joseph
                        strPeriod = 'PM';
                        //console.log('set strPeriod to PM');
                    } else {
                        strPeriod = 'AM';
                        //console.log('set strPeriod to AM');
                    }
                }
                valueDate = new Date('1/1/1111 ' + strHour + ':' + strMinute + ' ' + strPeriod);
            }
        // else: just copy date object
        } else {
            valueDate = new Date(newValue);
        }

        //console.log(strHour, strMinute, strPeriod);

        // if we have enough data to make a value
        if (valueDate) {
            // output types:
            //      regular time:  "3:30 PM"
            //      military time: "15:30"

            if (strFormat === 'military') {
                translatedValue = GS.leftPad(valueDate.getHours(), '0', 2) + ':' +
                                  GS.leftPad(valueDate.getMinutes(), '0', 2);
            } else {
                intHours = valueDate.getHours();

                if (intHours >= 12) {
                    intHours = intHours - 12;
                }
                if (intHours === 0) {
                    intHours = 12;
                }

                translatedValue = intHours + ':' +
                                  GS.leftPad(valueDate.getMinutes(), '0', 2) + ' ' +
                                  (valueDate.getHours() >= 12 ? 'PM' : 'AM');
            }
        } else {
            translatedValue = '';
        }

        return translatedValue;
    }

    function setValueDisplay(element, newValue) {
        var translatedOutputValue = translateValue((element.getAttribute('output-format') === 'military' ? 'military' : 'regular'), newValue);
        var translatedDisplayValue = translateValue((element.getAttribute('format') === 'military' ? 'military' : 'regular'), newValue);

        element.setAttribute('value', translatedOutputValue);

        if (!element.hasAttribute('disabled')) {
            element.control.value = translatedDisplayValue;
        } else {
            element.textContent = translatedDisplayValue || element.getAttribute('placeholder') || '';
        }

        if (element.innerState === 'open') {
            refreshPickerValue(element);
        }
    }

    function refreshPickerValue(element) {
        var arrElements;
        var strTranslatedValue;
        var dteTranslatedValue;
        var i;
        var len;
        var intHours;

        if (element.innerState === 'open') {
            strTranslatedValue = translateValue((element.getAttribute('format') === 'military' ? 'military' : 'regular'), element.getAttribute('value'));
            dteTranslatedValue = new Date('1/1/1111 ' + strTranslatedValue);

            element.pickerModalControlElement.setAttribute('value', strTranslatedValue);

            arrElements = xtag.query(element.pickerContainerElement, '.selected');

            i = 0;
            len = arrElements.length;
            while (i < len) {
                arrElements[i].classList.remove('selected');
                i += 1;
            }


            intHours = dteTranslatedValue.getHours();

            if (intHours >= 12) {
                intHours = intHours - 12;
            }
            if (intHours === 0) {
                intHours = 12;
            }

            xtag.query(element.pickerContainerElement,
                '.clock-hour[data-value="' + intHours + '"]')[0].classList.add('selected');
            xtag.query(element.pickerContainerElement,
                '.clock-minute[data-value="' + (Math.floor(dteTranslatedValue.getMinutes() / 5) * 5) + '"]')[0].classList.add('selected');
            xtag.query(element.pickerContainerElement,
                '.clock-period-switch.' + (dteTranslatedValue.getHours() >= 12 ? 'pm' : 'am'))[0].classList.add('selected');
        }
    }


    // #####################################################################################
    // ##################################### QUERYSTRING ###################################
    // #####################################################################################

    function handleQS(element) {
        var strQSValue;

        if (!element.qsEventFunction) {
            element.qsEventFunction = function () {
                pushReplacePopHandler(element);
            };
        }

        window.removeEventListener('pushstate',    element.qsEventFunction);
        window.removeEventListener('replacestate', element.qsEventFunction);
        window.removeEventListener('popstate',     element.qsEventFunction);

        // handle "qs" attribute
        if (element.getAttribute('qs')) {
            //strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));

            //if (strQSValue !== '' || !element.getAttribute('value')) {
            //    element.setAttribute('value', strQSValue);
            //}
            pushReplacePopHandler(element);
            window.addEventListener('pushstate',    element.qsEventFunction);
            window.addEventListener('replacestate', element.qsEventFunction);
            window.addEventListener('popstate',     element.qsEventFunction);
        }
    }


    //function pushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString();
    //    var strQSCol = element.getAttribute('qs');

    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.setAttribute('value', GS.qryGetVal(strQueryString, strQSCol));
    //    }
    //}

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }


    // #####################################################################################
    // ###################################### LIFECYCLE ####################################
    // #####################################################################################

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value) {
                element.setAttribute('value', element.value);
                delete element.value;
            }
        }
    }

    //
    function elementInserted(element) {
        console.warn('GS-TIME WARNING: this element is deprecated, please use the gs-datetime instead.');
        var now;
        var strQSValue;

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.innerState = 'closed';
                element.internal = {};
                saveDefaultAttributes(element);

                // if value attribute = now: set value attribute to the current time
                if (element.getAttribute('value') === 'now') {
                    now = new Date();

                    if (now.getHours() > 12) {
                        now = GS.leftPad(now.getHours() - 12, '0', 2) + ':' + GS.leftPad(now.getMinutes(), '0', 2) + ' PM';
                    } else {
                        now = GS.leftPad(now.getHours(), '0', 2) + ':' + GS.leftPad(now.getMinutes(), '0', 2) + ' AM';
                    }

                    element.setAttribute('value', now);
                }

                element.inserted = true;

                refreshControl(element);

                if (element.getAttribute('qs')) {
                    handleQS(element);
                }

                element.lastChangeValue = element.getAttribute('value');

                if (element.hasAttribute('non-empty') && !element.getAttribute('value')) {
                    console.warn('gs-time Warning: No value provided on "non-empty" gs-time control. Defaulting to "12:00 PM". Please provide a default value.');
                    element.setAttribute('value', '12:00 PM');
                }
            }
        }
    }


    // ######################################################################################
    // ##################################### REGISTRATION ###################################
    // ######################################################################################

    xtag.register('gs-time', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                var element = this;
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(element);
                    elementInserted(element);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(element);

                } else if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'placeholder' ||
                        strAttrName === 'disabled' ||
                        strAttrName === 'format' ||
                        strAttrName === 'no-picker' ||
                        strAttrName === 'tabindex') {
                        refreshControl(element);

                    } else if (strAttrName === 'qs') {
                        handleQS(element);

                    } else if (strAttrName === 'value' && element.inserted) {// && this.control
                        setValueDisplay(element, newValue);
                    }
                }
            }
        },
        events: {
            'click': function (event) {
                var element = this;
                if (event.target === element.button) {
                    element.toggle();
                }
            },
            'keydown:': function (event) {
                var element = this;
                var intKeyCode = (event.keyCode || event.which);
                var newControlValue;

                if (!element.hasAttribute('no-keys') && !element.hasAttribute('readonly')) {
                    if (element.getAttribute('value') && (intKeyCode === 38 || intKeyCode === 39 || intKeyCode === 40 || intKeyCode === 37)) {
                        newControlValue = new Date('1/1/1111 ' + element.getAttribute('value'));
                        event.preventDefault();
                        event.stopPropagation();

                        // up arrow:    next minute
                        // right arrow: next minute
                        if (intKeyCode === 38 || intKeyCode === 39) {
                            newControlValue = newControlValue.setMinutes(newControlValue.getMinutes() + 1);

                        // down arrow: previous minute
                        // left arrow: previous minute
                        } else if (intKeyCode === 40 || intKeyCode === 37) {
                            newControlValue = newControlValue.setMinutes(newControlValue.getMinutes() - 1);
                        }
                    }

                    // "c": clear (if allowed)
                    if (intKeyCode === 67 && !event.ctrlKey && !event.metaKey && !element.hasAttribute('non-empty')) {
                        newControlValue = '';
                        event.preventDefault();
                        event.stopPropagation();

                    // "n": now (if allowed)
                    } else if (intKeyCode === 78 && !event.ctrlKey && !event.metaKey && !element.hasAttribute('no-now-button')) {
                        newControlValue = new Date();
                        event.preventDefault();
                        event.stopPropagation();
                    }

                    if (newControlValue !== undefined) {
                        setValueDisplay(element, newControlValue);
                        GS.setInputSelection(element.control, 0, element.control.value.length);
                    }

                    if (intKeyCode === 13) {
                        handleNonEmpty(element);
                    }
                }
            },
            'focusout': function (event) {
                var element = this;
                if (element.innerState === 'open') {
                    element.close();
                } else {
                    handleChange(element);
                }
            }
        },
        accessors: {
            value: {
                get: function () {
                    // return this.getAttribute('value');
                    if (!this.getAttribute('value') || this.getAttribute('value').trim() === '') {
                        return 'NULL';
                    } else {
                        return this.getAttribute('value');
                    }
                },
                set: function (newValue) {
                    this.setAttribute('value', newValue);
                }
            },
            dateValue: {
                get: function () {
                    return new Date('1/1/1111 ' + this.getAttribute('value'));
                },
                set: function (newValue) {
                    setValueDisplay(this, newValue);
                }
            },
            state: {
                get: function () {
                    return this.innerState;
                },
                set: function (newValue) {
                    var element = this;
                    if (newValue === 'open') {
                        element.open();
                    } else {
                        element.close();
                    }
                }
            }
        },
        methods: {
            focus: function () {
                this.control.focus();
            },

            open: function () {
                var element = this;
                var pickerContainerElement;
                var overlayElement;
                var pickerElement;
                var handleLook;
                var strHTML;

                if (element.innerState === 'closed') {
                    element.innerState = 'open';
                    element.lastClosedValue = element.getAttribute('value');

                    // if we are not on a touch device: focus control
                    if (!evt.touchDevice) {
                        element.control.focus();
                        GS.setInputSelection(element.control, 0, element.control.value.length);

                    } else {
                        //this.control.focus()
                        //this.control.blur();
                    }

                    // create picker elements
                    pickerContainerElement = document.createElement('div');
                    pickerContainerElement.classList.add('gs-time-time-picker-container');

                    overlayElement = document.createElement('div');
                    overlayElement.classList.add('gs-time-time-picker-overlay');

                    pickerElement = document.createElement('div');
                    pickerElement.classList.add('gs-time-time-picker');

                    // save picker container
                    element.pickerContainerElement = pickerContainerElement;

                    // append picker elements
                    pickerContainerElement.appendChild(overlayElement);
                    pickerContainerElement.appendChild(pickerElement);

                    document.body.appendChild(pickerContainerElement);

                    // fill picker popup
                    strHTML = ml(function () {/*
                        <div class="time-modal-control-container" flex-horizontal>
                            <gs-text class="time-modal-control" flex></gs-text>
                            <gs-button class="modal-done">Done</gs-button>
                        </div>
                        <div class="time-inner-container">
                            <div class="time-top-toolbar">
                                <div flex-horizontal align-bottom>
                                    <gs-button class="decrement-time" icononly icon="arrow-left"></gs-button>
                                    <div flex></div>
                                    <gs-button class="increment-time" icononly icon="arrow-right"></gs-button>
                                </div>
                            </div>
                            <div class="gs-time-clock-container" prevent-text-selection>
                                <div class="gs-time-bezel">
                                    <div class="clock-face-layer layer-1">
                                        <div class="clock-line" style="top: 0%;"><div class="clock-button clock-hour" data-value="12"><span class="content">12</span></div></div><div class="clock-line" style="top: 5.9%;"><div class="clock-split" style="width: 45.25%;
left: 4.5%;"><div class="clock-button clock-hour" data-value="11"><span class="content">11</span></div></div><div class="clock-split" style="width: 45.25%;
left: 46.75%;"><div class="clock-button clock-hour" data-value="1">&nbsp;<span class="content">1</span></div></div></div><div class="clock-line" style="top: 22.5%;"><div class="clock-split" style="width: 22%;
left: 0%;"><div class="clock-button clock-hour" data-value="10"><span class="content">10</span></div></div><div class="clock-split" style="width: 22%;
left: 78%;"><div class="clock-button clock-hour" data-value="2">&nbsp;<span class="content">2</span></div></div></div><div class="clock-line" style="top: 45.3%;"><div class="clock-split" style="width: 14%;
left: 0%;"><div class="clock-button clock-hour" data-value="9"><span class="content">9</span>&nbsp;</div></div><div class="clock-split" style="width: 14%;
left: 86%;"><div class="clock-button clock-hour" data-value="3">&nbsp;<span class="content">3</span></div></div></div><div class="clock-line" style="top: 67.8%;"><div class="clock-split" style="width: 22%;
left: 0%;"><div class="clock-button clock-hour" data-value="8"><span class="content">8</span>&nbsp;</div></div><div class="clock-split" style="width: 22%;
left: 78%"><div class="clock-button clock-hour" data-value="4">&nbsp;<span class="content">4</span></div></div></div><div class="clock-line" style="top: 83.5%;"><div class="clock-split" style="width: 45.25%;
left: 4.5%;"><div class="clock-button clock-hour" data-value="7"><span class="content">7</span>&nbsp;</div></div><div class="clock-split" style="width: 45.25%;
left: 46.75%;"><div class="clock-button clock-hour" data-value="5">&nbsp;<span class="content">5</span></div></div></div><div class="clock-line" style="top: 90%;"><div class="clock-button clock-hour" data-value="6"><span class="content">6</span></div></div>
                                    </div>
                                    <div class="clock-face-layer layer-2">
                                        <div class="clock-line" style="top: 0%;"><div class="clock-button clock-minute" data-value="0"><span class="content">00</span></div></div>
                                        <div class="clock-line" style="top: 5.9%;"><div class="clock-split" style="width: 45.25%;
left: 4.5%;"><div class="clock-button clock-minute" data-value="55"><span class="content">55</span></div></div><div class="clock-split" style="width: 45.25%;
left: 49.75%;"><div class="clock-button clock-minute" data-value="5"><span class="content">05</span></div></div></div>
                                        <div class="clock-line" style="top: 22.5%;"><div class="clock-split" style="width: 22%;
left: 0%;"><div class="clock-button clock-minute" data-value="50"><span class="content">50</span></div></div><div class="clock-split" style="width: 22%;
left: 78%;"><div class="clock-button clock-minute" data-value="10"><span class="content">10</span></div></div></div>
                                        <div class="clock-line" style="top: 45.3%;"><div class="clock-split" style="width: 16%;
left: 0%;"><div class="clock-button clock-minute" data-value="45"><span class="content">45</span></div></div><div class="clock-split" style="width: 16%;
left: 84%;"><div class="clock-button clock-minute" data-value="15"><span class="content">15</span></div></div></div>
                                        <div class="clock-line" style="top: 67.8%;"><div class="clock-split" style="width: 22%;
left: 0%;"><div class="clock-button clock-minute" data-value="40"><span class="content">40</span></div></div><div class="clock-split" style="width: 22%;
left: 78%;"><div class="clock-button clock-minute" data-value="20"><span class="content">20</span></div></div></div>
                                        <div class="clock-line" style="top: 83.5%;"><div class="clock-split" style="width: 45.25%;
left: 4.5%;"><div class="clock-button clock-minute" data-value="35"><span class="content">35</span></div></div><div class="clock-split" style="width: 45.25%;
left: 49.75%;"><div class="clock-button clock-minute" data-value="25"><span class="content">25</span></div></div></div>
                                        <div class="clock-line" style="top: 90%;"><div class="clock-button clock-minute" data-value="30"><span class="content">30</span></div></div>
                                        <div class="clock-center"><div class="clock-period-switch am"><span class="content">AM</span></div><div class="clock-period-switch pm"><span class="content">PM</span></div></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    */});

                    strHTML += '<div class="time-bottom-toolbar">' +
                                    '<div flex-horizontal align-top>';

                    if (!element.hasAttribute('no-now-button')) {
                        strHTML += '<gs-button class="now-time">Now</gs-button>';
                    }

                    strHTML += '<gs-button class="done" flex>Done</gs-button>';

                    if (!element.hasAttribute('non-empty')) {
                        strHTML += '<gs-button class="clear-time">Clear</gs-button>';
                    }

                    strHTML +=      '</div>' +
                                '</div>';

                    pickerElement.innerHTML = strHTML;

                    // save picker control
                    element.pickerModalControlElement = xtag.query(pickerContainerElement, '.time-modal-control')[0];

                    // set picker value
                    refreshPickerValue(element);

                    // bind picker control change
                    element.pickerModalControlElement.addEventListener('change', function (event) {
                        setValueDisplay(element, this.value);
                    });

                    // bind picker control keydown
                    element.pickerModalControlElement.addEventListener('keydown', function (event) {
                        if ((event.keyCode || event.which) === 13) {
                            element.close();
                        }
                    });

                    // bind picker click
                    pickerElement.addEventListener('mousedown', function (event) {
                        if (!evt.touchDevice) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                    });

                    //console.log('0***', pickerElement);
                    pickerElement.addEventListener('click', function (event) {
                        var target = event.target, arrElements, i, len, newValue;

                        //console.log('1***', newValue);

                        if (target.classList.contains('content')) {
                            target = target.parentNode;
                        }

                        if (target.classList.contains('clock-button') || target.classList.contains('clock-period-switch')) {
                            if (target.classList.contains('clock-hour')) {
                                arrElements = xtag.query(pickerElement, '.clock-hour');
                            }
                            if (target.classList.contains('clock-minute')) {
                                arrElements = xtag.query(pickerElement, '.clock-minute');
                            }
                            if (target.classList.contains('clock-period-switch')) {
                                arrElements = xtag.query(pickerElement, '.clock-period-switch');
                            }

                            for (i = 0, len = arrElements.length; i < len; i += 1) {
                                arrElements[i].classList.remove('selected');
                            }

                            target.classList.add('selected');

                            arrElements = xtag.query(pickerElement, '.selected');
                            if (arrElements.length === 3) {
                                newValue = arrElements[0].textContent + ':' +
                                           arrElements[1].textContent + ' ' +
                                           arrElements[2].textContent;
                            }
                        }

                        if (target.classList.contains('increment-time') && element.getAttribute('value')) {
                            newValue = new Date('1/1/1111 ' + element.getAttribute('value'));
                            newValue = newValue.setMinutes(newValue.getMinutes() + 1);
                        } else if (target.classList.contains('decrement-time') && element.getAttribute('value')) {
                            newValue = new Date('1/1/1111 ' + element.getAttribute('value'));
                            newValue = newValue.setMinutes(newValue.getMinutes() - 1);
                        } else if (target.classList.contains('now-time')) {
                            newValue = new Date();
                        } else if (target.classList.contains('clear-time')) {
                            newValue = '';
                        } else if (target.classList.contains('modal-done') || target.classList.contains('done')) {
                            element.close();
                        }

                        //console.log('2***', newValue);
                        if (newValue !== undefined) {
                            setValueDisplay(element, newValue);
                            //console.log('3***', element, element.getAttribute('value'), element.value);

                            if (!evt.touchDevice) {
                                GS.setInputSelection(element.control, 0, element.control.value.length);
                            }
                        }
                    });

                    // handle/bind positioning and look
                    handleLook = function () {
                        var positionData, intPopupHeight, intPopupWidth;

                        if (pickerContainerElement.parentNode !== document.body) {
                            window.removeEventListener('resize', handleLook);
                            window.removeEventListener('orientationchange', handleLook);
                            return;
                        }

                        // clear current styles
                        pickerElement.style.top = '';
                        pickerElement.style.left = '';
                        pickerElement.style.marginTop = '';
                        pickerContainerElement.classList.remove('modal');

                        // get position/size data
                        positionData = GS.getElementPositionData(element);
                        intPopupHeight = pickerElement.offsetHeight;
                        intPopupWidth = pickerElement.offsetWidth;

                        // if from control to bottom is too small and from control to top is too small
                        //      OR window width < 400px: dialog
                        //      OR window height < 550px: dialog
                        if ((positionData.intRoomAbove < intPopupHeight && positionData.intRoomBelow < intPopupHeight) ||
                            window.innerWidth < 400 ||
                            window.innerHeight < 550) {
                            // dialog mode
                            pickerElement.style.marginTop = '1em';
                            pickerContainerElement.classList.add('modal');

                        } else {
                            // if from control to bottom has enough room: popup below
                            if (positionData.intRoomBelow > intPopupHeight) {
                                pickerElement.style.top  = (positionData.objElementOffset.top + positionData.intElementHeight) + 'px';

                            // else: popup above
                            } else {
                                pickerElement.style.top  = (positionData.objElementOffset.top - intPopupHeight) + 'px';
                            }

                            pickerElement.style.left =
                                ((positionData.objElementOffset.left + positionData.intElementWidth) - intPopupWidth) + 'px';
                        }
                    };

                    handleLook();

                    window.addEventListener('resize', handleLook);
                    window.addEventListener('orientationchange', handleLook);
                }
            },

            close: function () {
                var element = this;

                if (element.innerState === 'open') {
                    element.innerState = 'closed';
                    //console.trace('closed', element.pickerContainerElement);
                    if (element.pickerContainerElement) {
                        document.body.removeChild(element.pickerContainerElement);
                        element.pickerContainerElement = '';
                    }

                    if (element.getAttribute('value') !== element.lastClosedValue) {
                        handleChange(element);
                    } else if (!element.getAttribute('value')) {
                        handleNonEmpty(element);
                    }
                }
            },

            toggle: function () {
                if (this.innerState === 'open') {
                    this.close();
                } else {
                    this.open();
                }
            }
        }
    });
});/*jslint white:true browser:true this:true*/
/*global window,GS,document,xtag,designRegisterElement,registerDesignSnippet,addProp,encodeHTML,setOrRemoveTextAttribute,setOrRemoveBooleanAttribute,addFlexProps*/

window.addEventListener('design-register-element', function () {
    'use strict';

    registerDesignSnippet('<gs-timestamp>', '<gs-timestamp>', 'gs-timestamp date-format="${0:isodate}" time-format=${1}></gs-timestamp>');

    designRegisterElement('gs-timestamp', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-timestamp.html');

    window.designElementProperty_GSTIMESTAMP = function (selectedElement) {
        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        addProp('Date Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('date-placeholder') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'date-placeholder', this.value);
        });

        addProp('Time Placeholder', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('time-placeholder') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'time-placeholder', this.value);
        });

        addProp('Mini', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('mini')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'mini', (this.value === 'true'), true);
        });

        addProp('Date Picker', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-date-picker')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-date-picker', (this.value === 'true'), false);
        });

        addProp('Date Format', true, '<gs-combo class="target" value="' + encodeHTML(selectedElement.getAttribute('date-format') || '') + '" mini>' +
                        ml(function () {/*<template>
                                            <table>
                                                <tbody>
                                                    <tr value="">
                                                        <td hidden>Default</td>
                                                        <td><center>Default<br /> (01/01/2015)</center></td>
                                                    </tr>
                                                    <tr value="shortdate">
                                                        <td hidden>shortdate</td>
                                                        <td><center>shortdate<br /> (1/1/15)</center></td>
                                                    </tr>
                                                    <tr value="mediumdate">
                                                        <td hidden>mediumdate</td>
                                                        <td><center>mediumdate<br /> (Jan 1, 2015)</center></td>
                                                    </tr>
                                                    <tr value="longdate">
                                                        <td hidden>longdate</td>
                                                        <td><center>longdate<br /> (January 1, 2015)</center></td>
                                                    </tr>
                                                    <tr value="fulldate">
                                                        <td hidden>fulldate</td>
                                                        <td><center>fulldate<br /> (Thursday, January 1, 2015)</center></td>
                                                    </tr>
                                                    <tr value="isodate">
                                                        <td hidden>isodate</td>
                                                        <td><center>isodate<br /> (2015-01-01)</center></td>
                                                    </tr>
                                                    <tr value="isodatetime">
                                                        <td hidden>isodatetime</td>
                                                        <td><center>isodatetime<br /> (2015-01-01T00:00:00)</center></td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </template>
                                    </gs-combo>
                                */}), function () {
            return setOrRemoveTextAttribute(selectedElement, 'date-format', this.value);
        });

        addProp('Time Picker', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('no-time-picker')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'no-time-picker', (this.value === 'true'), false);
        });

        addProp('Time Display Format', true, '<gs-select class="target" value="' + encodeHTML(selectedElement.getAttribute('time-format') || '') + '" mini>' +
                                    '<option value="">Regular (1:30 PM)</option>' +
                                    '<option value="military">Military (13:30)</option>' +
                                '</gs-select>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'time-format', this.value);
        });

        addProp('Time Non-Empty', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('time-non-empty')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'time-non-empty', (this.value === 'true'), true);
        });

        addProp('Time Now Button', true, '<gs-checkbox class="target" value="' + (!selectedElement.hasAttribute('time-no-now-button')) + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'time-no-now-button', (this.value === 'true'), false);
        });

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        addProp('Date Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('date-tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'date-tabindex', this.value);
        });

        addProp('Time Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('time-tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'time-tabindex', this.value);
        });

        addProp('Autocorrect', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocorrect') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocorrect', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocapitalize', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocapitalize') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocapitalize', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Autocomplete', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('autocomplete') !== 'off') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'autocomplete', (this.value === 'false' ? 'off' : ''));
        });

        addProp('Spellcheck', true, '<gs-checkbox class="target" value="' + (selectedElement.getAttribute('spellcheck') !== 'false') + '" mini></gs-checkbox>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'spellcheck', (this.value === 'false' ? 'false' : ''));
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden'))                   { strVisibilityAttribute = 'hidden'; }
        if (selectedElement.hasAttribute('hide-on-desktop'))  { strVisibilityAttribute = 'hide-on-desktop'; }
        if (selectedElement.hasAttribute('hide-on-tablet'))   { strVisibilityAttribute = 'hide-on-tablet'; }
        if (selectedElement.hasAttribute('hide-on-phone'))    { strVisibilityAttribute = 'hide-on-phone'; }
        if (selectedElement.hasAttribute('show-on-desktop'))   { strVisibilityAttribute = 'show-on-desktop'; }
        if (selectedElement.hasAttribute('show-on-tablet'))    { strVisibilityAttribute = 'show-on-tablet'; }
        if (selectedElement.hasAttribute('show-on-phone'))     { strVisibilityAttribute = 'show-on-phone'; }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        // READONLY attribute
        addProp('Readonly', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('readonly') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'readonly', this.value === 'true', true);
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol && strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (strQSCol && GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // for a given element, copy the control values with the value attribute
    function syncView(element) {
        var strDateValue = element.dateControl.value + ' ' + (element.timeControl.value === 'NULL' ? '00:00' : element.timeControl.value);
        var dateValue = new Date(strDateValue);
        var newValue = dateValue.getFullYear() + '-' + (dateValue.getMonth() + 1) + '-' + dateValue.getDate() + ' ' + dateValue.getHours() + ':' + dateValue.getMinutes();

        //console.log(element.dateControl.value);
        //console.log(element.timeControl.value === 'NULL' ? '00:00' : element.timeControl.value);
        //console.log(strDateValue);
        //console.log(dateValue);
        //console.log(newValue);

        element.setAttribute('value', newValue);
    }

    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        i = 0;
        len = element.attributes.length;
        arrAttr = element.attributes;
        while (i < len) {
            jsnAttr = element.attributes[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    // re-target focus event from control to element
    function focusFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'focus');
        event.target.parentNode.classList.add('focus');
    }

    // re-target blur event from control to element
    function blurFunction(event) {
        GS.triggerEvent(event.target.parentNode, 'blur');
        event.target.parentNode.classList.remove('focus');
    }

    // mouseout, remove hover class
    function mouseoutFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseout);
        event.target.parentNode.classList.remove('hover');
    }

    // mouseover, add hover class
    function mouseoverFunction(event) {
        GS.triggerEvent(event.target.parentNode, evt.mouseover);
        event.target.parentNode.classList.add('hover');
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {
            // if the value was set before the "created" lifecycle code runs: set attribute
            //      (discovered when trying to set a value of a date control in the after_open of a dialog)
            //      ("delete" keyword added because of firefox)
            if (element.value && new Date(element.value).getTime()) {
                element.setAttribute('value', element.value);
                delete element.value;
                //element.value = undefined;
                //element.value = null;
            }
        }
    }

    function elementInserted(element) {
        var dateValue = '';
        var timeValue = '';

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (element.hasAttribute('value')) {
                    var arrValue = element.getAttribute('value').split(' ');
                    dateValue = new Date(arrValue[0] + ' 00:00:00');    // adding an empty time causes the date to not be iso format
                                                                        // this makes the browser choose the local timezone instead of GMT
                    timeValue = arrValue[1];
                }

                element.dateControl = document.createElement('gs-date');
                element.timeControl = document.createElement('gs-time');

                var arrPassthrough = ['mini', 'autocorrect', 'autocapitalize', 'autocomplete', 'spellcheck', 'disabled', 'readonly'];
                var arrDatePassthrough = ['date-placeholder', 'no-date-picker', 'date-format', 'date-tabindex'];
                var arrTimePassthrough = ['time-placeholder', 'no-time-picker', 'time-format', 'time-non-empty', 'time-no-now-button', 'time-tabindex'];
                var i;
                var len;

                for (i = 0, len = arrPassthrough.length; i < len; i += 1) {
                    if (element.hasAttribute(arrPassthrough[i])) {
                        element.dateControl.setAttribute(arrPassthrough[i], '');
                        element.timeControl.setAttribute(arrPassthrough[i], '');
                    }
                }
                for (i = 0, len = arrDatePassthrough.length; i < len; i += 1) {
                    if (element.hasAttribute(arrDatePassthrough[i])) {
                        element.dateControl.setAttribute(arrDatePassthrough[i].replace(/date\-/g, ''), element.getAttribute(arrDatePassthrough[i]) || '');
                    }
                }
                for (i = 0, len = arrTimePassthrough.length; i < len; i += 1) {
                    if (element.hasAttribute(arrTimePassthrough[i])) {
                        element.timeControl.setAttribute(arrTimePassthrough[i].replace(/time\-/g, ''), element.getAttribute(arrTimePassthrough[i]) || '');
                    }
                }

                element.dateControl.value = dateValue;
                element.timeControl.value = timeValue;

                element.dateControl.setAttribute('flex', '');
                element.timeControl.setAttribute('flex', '');

                element.dateControl.setAttribute('gs-dynamic', '');
                element.timeControl.setAttribute('gs-dynamic', '');

                element.dateControl.addEventListener('focus', focusFunction);
                element.timeControl.addEventListener('focus', focusFunction);

                element.dateControl.addEventListener('blur', blurFunction);
                element.timeControl.addEventListener('blur', blurFunction);

                element.dateControl.addEventListener(evt.mouseout, mouseoutFunction);
                element.timeControl.addEventListener(evt.mouseout, mouseoutFunction);

                element.dateControl.addEventListener(evt.mouseover, mouseoverFunction);
                element.timeControl.addEventListener(evt.mouseover, mouseoverFunction);

                element.dateControl.addEventListener('change', function (event) {
                    syncView(element);
                    event.stopPropagation();
                    GS.triggerEvent(element, 'change');
                });
                element.timeControl.addEventListener('change', function (event) {
                    syncView(element);
                    event.stopPropagation();
                    GS.triggerEvent(element, 'change');
                });

                //console.log(element.dateControl);
                //console.log(element.timeControl);

                element.appendChild(element.dateControl);
                element.appendChild(element.timeControl);

                //console.log(element.children);

                pushReplacePopHandler(element);
                window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
            }
        }
    }

    xtag.register('gs-timestamp', {
        lifecycle: {
            created: function () {
                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                var dateValue = '';
                var timeValue = '';
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    if (strAttrName === 'value') {
                        if (newValue !== null) {
                            var arrValue = newValue.split(' ');
                            dateValue = new Date(arrValue[0]);
                            timeValue = arrValue[1];

                            this.dateControl.value = dateValue;
                            this.timeControl.value = timeValue;
                        } else {
                            this.dateControl.value = null;
                            this.timeControl.value = null;
                        }
                    }
                }
            }
        },
        events: {},
        accessors: {
            value: {
                get: function () {
                    return this.getAttribute('value');
                },

                set: function (newValue) {
                    this.setAttribute('value', newValue);
                }
            }
        },
        methods: {
        }
    });
});
window.addEventListener('design-register-element', function () {

    registerDesignSnippet('<gs-toggle>', '<gs-toggle>', 'gs-toggle column="${1}">${2}</gs-toggle>');

    designRegisterElement('gs-toggle', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-buttons-toggle.html');

    window.designElementProperty_GSTOGGLE = function(selectedElement) {
        addProp('Icon', true, '<div flex-horizontal>' +
                              '     <gs-text id="prop-icon-input" class="target" value="' + (selectedElement.getAttribute('icon') || '') + '" mini flex></gs-text>' +
                              '     <gs-button id="prop-icon-picker-button" mini icononly icon="list"></gs-button>' +
                              '     <style>#prop-icon-picker-button:after {font-size: 1em;}</style>' +
                              '</div>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'icon', this.value, false);
        });

        document.getElementById('prop-icon-picker-button').addEventListener('click', function () {
            var i, len, html, arrIcons = GS.iconList(), strName, templateElement;

            for (i = 0, len = arrIcons.length, html = ''; i < len; i += 1) {
                strName = arrIcons[i].name;
                html += '<gs-block>' +
                            '<gs-button iconleft icon="' + strName + '" dialogclose>' + strName + '</gs-button>' +
                        '</gs-block>';
            }

            templateElement = document.createElement('template');
            templateElement.setAttribute('data-max-width', '1100px');

            templateElement.innerHTML = ml(function () {/*
                <gs-page>
                    <gs-header><center><h3>Choose An Icon</h3></center></gs-header>
                    <gs-body padded>
                        <gs-grid widths="1,1,1,1" reflow-at="767px">{{HTML}}</gs-grid>
                    </gs-body>
                    <gs-footer><gs-button dialogclose>Cancel</gs-button></gs-footer>
                </gs-page>
            */}).replace('{{HTML}}', html);

            GS.openDialog(templateElement, '', function (event, strAnswer) {
                var propInput = document.getElementById('prop-icon-input');

                if (strAnswer !== 'Cancel') {
                    propInput.value = strAnswer;
                    GS.triggerEvent(propInput, 'change');
                }
            });
        });

        if (selectedElement.getAttribute('icon') ||
            selectedElement.hasAttribute('iconleft') ||
            selectedElement.hasAttribute('iconright') ||
            selectedElement.hasAttribute('icontop') ||
            selectedElement.hasAttribute('iconbottom') ||
            selectedElement.hasAttribute('icononly') ||
            selectedElement.hasAttribute('iconrotateright') ||
            selectedElement.hasAttribute('iconrotatedown') ||
            selectedElement.hasAttribute('iconrotateleft')) {
            // iconleft
            // iconright
            // icontop
            // iconbottom
            // icononly
                   if (selectedElement.hasAttribute('iconleft'))   { strIconPos = 'iconleft';
            } else if (selectedElement.hasAttribute('iconright'))  { strIconPos = 'iconright';
            } else if (selectedElement.hasAttribute('icontop'))    { strIconPos = 'icontop';
            } else if (selectedElement.hasAttribute('iconbottom')) { strIconPos = 'iconbottom';
            } else if (selectedElement.hasAttribute('icononly'))   { strIconPos = 'icononly';
            } else { strIconPos = ''; }

            addProp('Icon Position', true, '<gs-select class="target" value="' + strIconPos + '" mini>' +
                                                '   <option value="">Default</option>' +
                                                '   <option value="iconleft">Left</option>' +
                                                '   <option value="iconright">Right</option>' +
                                                '   <option value="icontop">Top</option>' +
                                                '   <option value="iconbottom">Bottom</option>' +
                                                '   <option value="icononly">Icononly</option>' +
                                                '</gs-select>', function () {
                selectedElement.removeAttribute('iconleft');
                selectedElement.removeAttribute('iconright');
                selectedElement.removeAttribute('icontop');
                selectedElement.removeAttribute('iconbottom');
                selectedElement.removeAttribute('icononly');

                if (this.value) {
                    selectedElement.setAttribute(this.value, '');
                }

                return selectedElement;
            });

            // None
            // 90 degrees  (iconrotateright)
            // 180 degrees (iconrotatedown)
            // 270 degrees (iconrotateleft)

                   if (selectedElement.hasAttribute('iconrotateright')) { strIconRotation = 'iconrotateright';
            } else if (selectedElement.hasAttribute('iconrotatedown'))  { strIconRotation = 'iconrotatedown';
            } else if (selectedElement.hasAttribute('iconrotateleft'))  { strIconRotation = 'iconrotateleft';
            } else { strIconRotation = ''; }

            addProp('Icon&nbsp;Rotation', true, '<gs-select class="target" value="' + strIconRotation + '" mini>' +
                                                '   <option value="">None</option>' +
                                                '   <option value="iconrotateright">90 degrees</option>' +
                                                '   <option value="iconrotatedown">180 degrees</option>' +
                                                '   <option value="iconrotateleft">270 degrees</option>' +
                                                '</gs-select>', function () {
                selectedElement.removeAttribute('iconrotateright');
                selectedElement.removeAttribute('iconrotatedown');
                selectedElement.removeAttribute('iconrotateleft');

                if (this.value) {
                    selectedElement.setAttribute(this.value, '');
                }

                return selectedElement;
            });
        }

        // TITLE attribute
        addProp('Title', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('title') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'title', this.value);
        });

        // TABINDEX attribute
        addProp('Tabindex', true, '<gs-number class="target" value="' + encodeHTML(selectedElement.getAttribute('tabindex') || '') + '" mini></gs-number>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'tabindex', this.value);
        });

        // visibility attributes
        var strVisibilityAttribute = '';
        if (selectedElement.hasAttribute('hidden')) {
            strVisibilityAttribute = 'hidden';
        }
        if (selectedElement.hasAttribute('hide-on-desktop')) {
            strVisibilityAttribute = 'hide-on-desktop';
        }
        if (selectedElement.hasAttribute('hide-on-tablet')) {
            strVisibilityAttribute = 'hide-on-tablet';
        }
        if (selectedElement.hasAttribute('hide-on-phone')) {
            strVisibilityAttribute = 'hide-on-phone';
        }
        if (selectedElement.hasAttribute('show-on-desktop')) {
            strVisibilityAttribute = 'show-on-desktop';
        }
        if (selectedElement.hasAttribute('show-on-tablet')) {
            strVisibilityAttribute = 'show-on-tablet';
        }
        if (selectedElement.hasAttribute('show-on-phone')) {
            strVisibilityAttribute = 'show-on-phone';
        }

        addProp('Visibility', true, '<gs-select class="target" value="' + strVisibilityAttribute + '" mini>' +
                                        '<option value="">Visible</option>' +
                                        '<option value="hidden">Invisible</option>' +
                                        '<option value="hide-on-desktop">Invisible at desktop size</option>' +
                                        '<option value="hide-on-tablet">Invisible at tablet size</option>' +
                                        '<option value="hide-on-phone">Invisible at phone size</option>' +
                                        '<option value="show-on-desktop">Visible at desktop size</option>' +
                                        '<option value="show-on-tablet">Visible at tablet size</option>' +
                                        '<option value="show-on-phone">Visible at phone size</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('hidden');
            selectedElement.removeAttribute('hide-on-desktop');
            selectedElement.removeAttribute('hide-on-tablet');
            selectedElement.removeAttribute('hide-on-phone');
            selectedElement.removeAttribute('show-on-desktop');
            selectedElement.removeAttribute('show-on-tablet');
            selectedElement.removeAttribute('show-on-phone');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // DISABLED attribute
        addProp('Disabled', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('disabled') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'disabled', this.value === 'true', true);
        });

        // Font Color attributes
        strFontAttribute = '';
        if (selectedElement.hasAttribute('txt-primary'))  { strFontAttribute = 'txt-primary'; }
        if (selectedElement.hasAttribute('txt-success'))  { strFontAttribute = 'txt-success'; }
        if (selectedElement.hasAttribute('txt-info'))     { strFontAttribute = 'txt-info'; }
        if (selectedElement.hasAttribute('txt-warning'))  { strFontAttribute = 'txt-warning'; }
        if (selectedElement.hasAttribute('txt-danger'))   { strFontAttribute = 'txt-danger'; }

        addProp('Font Color', true, '<gs-select class="target" value="' + strFontAttribute + '" mini>' +
                                        '<option value="">Default</option>' +
                                        '<option value="txt-primary">Primary</option>' +
                                        '<option value="txt-success">Success</option>' +
                                        '<option value="txt-info">Info</option>' +
                                        '<option value="txt-warning">Warning</option>' +
                                        '<option value="txt-danger">Danger</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('txt-primary');
            selectedElement.removeAttribute('txt-success');
            selectedElement.removeAttribute('txt-info');
            selectedElement.removeAttribute('txt-warning');
            selectedElement.removeAttribute('txt-danger');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        // Background Color attributes
        strBackgroundAttribute = '';
        if (selectedElement.hasAttribute('bg-primary'))  { strBackgroundAttribute = 'bg-primary'; }
        if (selectedElement.hasAttribute('bg-success'))  { strBackgroundAttribute = 'bg-success'; }
        if (selectedElement.hasAttribute('bg-info'))     { strBackgroundAttribute = 'bg-info'; }
        if (selectedElement.hasAttribute('bg-warning'))  { strBackgroundAttribute = 'bg-warning'; }
        if (selectedElement.hasAttribute('bg-danger'))   { strBackgroundAttribute = 'bg-danger'; }

        addProp('Background Color', true, '<gs-select class="target" value="' + strBackgroundAttribute + '" mini>' +
                                        '<option value="">Default</option>' +
                                        '<option value="bg-primary">Primary</option>' +
                                        '<option value="bg-success">Success</option>' +
                                        '<option value="bg-info">Info</option>' +
                                        '<option value="bg-warning">Warning</option>' +
                                        '<option value="bg-danger">Danger</option>' +
                                    '</gs-select>', function () {
            selectedElement.removeAttribute('bg-primary');
            selectedElement.removeAttribute('bg-success');
            selectedElement.removeAttribute('bg-info');
            selectedElement.removeAttribute('bg-warning');
            selectedElement.removeAttribute('bg-danger');

            if (this.value) {
                selectedElement.setAttribute(this.value, '');
            }

            return selectedElement;
        });

        addProp('Column', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('column') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'column', this.value);
        });

        addProp('Value', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('value') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'value', this.value);
        });

        addProp('Column In Querystring', true, '<gs-text class="target" value="' + encodeHTML(selectedElement.getAttribute('qs') || '') + '" mini></gs-text>', function () {
            return setOrRemoveTextAttribute(selectedElement, 'qs', this.value, false);
        });

        // SUSPEND-CREATED attribute
        addProp('suspend-created', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-created') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-created', this.value === 'true', true);
        });

        // SUSPEND-INSERTED attribute
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });

        addProp('Corners', true,   '<div class="target">' +
                                        '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                    selectedElement.hasAttribute('remove-top') ||
                                                                    selectedElement.hasAttribute('remove-left') ||
                                                                    selectedElement.hasAttribute('remove-top-left'))).toString() +
                                                '" remove-right remove-bottom id="round-top-left-corner________" inline></gs-checkbox>' +

                                        '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                    selectedElement.hasAttribute('remove-top') ||
                                                                    selectedElement.hasAttribute('remove-right') ||
                                                                    selectedElement.hasAttribute('remove-top-right'))).toString() +
                                                '" remove-left remove-bottom id="round-top-right-corner________" inline></gs-checkbox><br />' +

                                        '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                    selectedElement.hasAttribute('remove-bottom') ||
                                                                    selectedElement.hasAttribute('remove-left') ||
                                                                    selectedElement.hasAttribute('remove-bottom-left'))).toString() +
                                                '" remove-right remove-top id="round-bottom-left-corner________" inline></gs-checkbox>' +

                                        '<gs-checkbox value="' + (!(selectedElement.hasAttribute('remove-all') ||
                                                                    selectedElement.hasAttribute('remove-bottom') ||
                                                                    selectedElement.hasAttribute('remove-right') ||
                                                                    selectedElement.hasAttribute('remove-bottom-right'))).toString() +
                                                '" remove-left remove-top id="round-bottom-right-corner________" inline></gs-checkbox>' +
                                    '</div>', function () {
            var topLeft =     document.getElementById('round-top-left-corner________').value === 'true',
                topRight =    document.getElementById('round-top-right-corner________').value === 'true',
                bottomLeft =  document.getElementById('round-bottom-left-corner________').value === 'true',
                bottomRight = document.getElementById('round-bottom-right-corner________').value === 'true',
                arrStrAttr = [], i, len;

            selectedElement.removeAttribute('remove-all');
            selectedElement.removeAttribute('remove-top');
            selectedElement.removeAttribute('remove-bottom');
            selectedElement.removeAttribute('remove-left');
            selectedElement.removeAttribute('remove-right');
            selectedElement.removeAttribute('remove-top-left');
            selectedElement.removeAttribute('remove-top-right');
            selectedElement.removeAttribute('remove-bottom-left');
            selectedElement.removeAttribute('remove-bottom-right');

            if (!topLeft && !topRight && !bottomLeft && !bottomRight) {
                arrStrAttr.push('remove-all');
            } else if (!topLeft && !topRight) {
                arrStrAttr.push('remove-top');
            } else if (!bottomLeft && !bottomRight) {
                arrStrAttr.push('remove-bottom');
            } else if (!topLeft && !bottomLeft) {
                arrStrAttr.push('remove-left');
            } else if (!topRight && !bottomRight) {
                arrStrAttr.push('remove-right');
            }

            if (!topLeft && !bottomLeft && arrStrAttr[0] !== 'remove-all') {
                arrStrAttr.push('remove-left');
            } else if (!topLeft && topRight) {
                arrStrAttr.push('remove-top-left');
            } else if (!bottomLeft && bottomRight) {
                arrStrAttr.push('remove-bottom-left');
            }

            if (!topRight && !bottomRight && arrStrAttr[0] !== 'remove-all') {
                arrStrAttr.push('remove-right');
            } else if (topLeft && !topRight) {
                arrStrAttr.push('remove-top-right');
            } else if (bottomLeft && !bottomRight) {
                arrStrAttr.push('remove-bottom-right');
            }

            for (i = 0, len = arrStrAttr.length; i < len; i += 1) {
                selectedElement.setAttribute(arrStrAttr[i], '');
            }

            return selectedElement;
        });

        //addFlexContainerProps(selectedElement);
        addFlexProps(selectedElement);
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    //function pushReplacePopHandler(element) {
    //    var strQueryString = GS.getQueryString(), strQSCol = element.getAttribute('qs');
    //
    //    if (GS.qryGetKeys(strQueryString).indexOf(strQSCol) > -1) {
    //        element.value = GS.qryGetVal(strQueryString, strQSCol);
    //    }
    //}
    function saveDefaultAttributes(element) {
        var i;
        var len;
        var arrAttr;
        var jsnAttr;

        // we need a place to store the attributes
        element.internal.defaultAttributes = {};

        // loop through attributes and store them in the internal defaultAttributes object
        arrAttr = element.attributes;
        i = 0;
        len = arrAttr.length;
        while (i < len) {
            jsnAttr = arrAttr[i];

            element.internal.defaultAttributes[jsnAttr.nodeName] = (jsnAttr.nodeValue || '');

            i += 1;
        }
    }

    function pushReplacePopHandler(element) {
        var i;
        var len;
        var strQS = GS.getQueryString();
        var strQSCol = element.getAttribute('qs');
        var strQSValue;
        var strQSAttr;
        var arrQSParts;
        var arrAttrParts;
        var strOperator;

        if (strQSCol.indexOf('=') !== -1) {
            arrAttrParts = strQSCol.split(',');
            i = 0;
            len = arrAttrParts.length;
            while (i < len) {
                strQSCol = arrAttrParts[i];

                if (strQSCol.indexOf('!=') !== -1) {
                    strOperator = '!=';
                    arrQSParts = strQSCol.split('!=');
                } else {
                    strOperator = '=';
                    arrQSParts = strQSCol.split('=');
                }

                strQSCol = arrQSParts[0];
                strQSAttr = arrQSParts[1] || arrQSParts[0];

                // if the key is not present or we've got the negator: go to the attribute's default or remove it
                if (strOperator === '!=') {
                    // if the key is not present: add the attribute
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        element.setAttribute(strQSAttr, '');
                    // else: remove the attribute
                    } else {
                        element.removeAttribute(strQSAttr);
                    }
                } else {
                    // if the key is not present: go to the attribute's default or remove it
                    if (GS.qryGetKeys(strQS).indexOf(strQSCol) === -1) {
                        if (element.internal.defaultAttributes[strQSAttr] !== undefined) {
                            element.setAttribute(strQSAttr, (element.internal.defaultAttributes[strQSAttr] || ''));
                        } else {
                            element.removeAttribute(strQSAttr);
                        }
                    // else: set attribute to exact text from QS
                    } else {
                        element.setAttribute(strQSAttr, (
                            GS.qryGetVal(strQS, strQSCol) ||
                            element.internal.defaultAttributes[strQSAttr] ||
                            ''
                        ));
                    }
                }
                i += 1;
            }
        } else if (GS.qryGetKeys(strQS).indexOf(strQSCol) > -1) {
            strQSValue = GS.qryGetVal(strQS, strQSCol);

            if (element.internal.bolQSFirstRun !== true) {
                if (strQSValue !== '' || !element.getAttribute('value')) {
                    element.setAttribute('value', strQSValue);
                }
            } else {
                element.value = strQSValue;
            }
        }

        element.internal.bolQSFirstRun = true;
    }

    // dont do anything that modifies the element here
    function elementCreated(element) {
        // if "created" hasn't been suspended: run created code
        if (!element.hasAttribute('suspend-created')) {

        }
    }

    //
    function elementInserted(element) {
        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;
                element.internal = {};
                saveDefaultAttributes(element);

                if (!evt.touchDevice) {
                    element.addEventListener(evt.mousedown, function (event) {
                        element.classList.add('down');
                    });

                    element.addEventListener(evt.mouseout, function (event) {
                        element.classList.remove('down');
                        element.classList.remove('hover');
                    });

                    element.addEventListener(evt.mouseover, function (event) {
                        element.classList.remove('down');
                        element.classList.add('hover');
                    });

                    element.addEventListener('keydown', function (event) {
                        if (!element.hasAttribute('disabled') && !element.classList.contains('down') &&
                            (event.keyCode === 13 || event.keyCode === 32)) {

                            element.classList.add('down');
                        }
                    });

                    element.addEventListener('keyup', function (event) {
                        // if we are not disabled and we pressed return (13) or space (32): trigger click
                        if (!element.hasAttribute('disabled') && element.classList.contains('down') &&
                            (event.keyCode === 13 || event.keyCode === 32)) {
                            GS.triggerEvent(element, 'click');
                        }
                    });
                }


                // add a tabindex to allow focus
                if (!element.hasAttribute('tabindex')) {
                    element.tabIndex = 0;
                }

                if (typeof element.getAttribute('value') === 'string') {
                    if (element.getAttribute('value') === 'true' || element.getAttribute('value') === '-1') {
                        element.setAttribute('selected', '');
                    }
                }

                // handle "qs" attribute
                if (element.getAttribute('qs')) {
                    //var strQSValue = GS.qryGetVal(GS.getQueryString(), element.getAttribute('qs'));
                    //if (strQSValue !== '' || !element.getAttribute('value')) {
                    //    element.value = strQSValue;
                    //}
                    pushReplacePopHandler(element);
                    window.addEventListener('pushstate',    function () { pushReplacePopHandler(element); });
                    window.addEventListener('replacestate', function () { pushReplacePopHandler(element); });
                    window.addEventListener('popstate',     function () { pushReplacePopHandler(element); });
                }
            }
        }
    }

    xtag.register('gs-toggle', {
        lifecycle: {
            created: function () {
                // if the value was set before the "created" lifecycle code runs: set attribute
                //      (discovered when trying to set a value of a date control in the after_open of a dialog)
                //      ("delete" keyword added because of firefox)
                if (this.value) {
                    this.setAttribute('value', this.value);
                    delete this.value;
                    //this.value = null;
                }

                elementCreated(this);
            },

            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-created" has been removed: run created and inserted code
                if (strAttrName === 'suspend-created' && newValue === null) {
                    elementCreated(this);
                    elementInserted(this);

                // if "suspend-inserted" has been removed: run inserted code
                } else if (strAttrName === 'suspend-inserted' && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // attribute code
                }
            }
        },
        events: {
            'click': function (event) {
                if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    this.classList.remove('down');

                    if (this.hasAttribute('selected')) {
                        this.removeAttribute('selected');

                        if (this.getAttribute('value') === 'true') {
                            this.setAttribute('value', 'false');
                        } else if (this.getAttribute('value') === '-1') {
                            this.setAttribute('value', '0');
                        }

                    } else {
                        this.setAttribute('selected', '');

                        if (this.getAttribute('value') === 'false') {
                            this.setAttribute('value', 'true');
                        } else if (this.getAttribute('value') === '0') {
                            this.setAttribute('value', '-1');
                        }
                    }

                    xtag.fireEvent(this, 'change', {
                        bubbles: true,
                        cancelable: true
                    });
                }
            }
        },
        accessors: {
            'value': {
                'get': function () {
                    return this.hasAttribute('selected'); //this.classList.contains('down');
                },

                'set': function (newValue) {
                    if (newValue === true || newValue === 'true') {
                        this.setAttribute('selected', '');
                    } else {
                        this.removeAttribute('selected');
                    }
                }
            },

            'textValue': {
                'get': function () {
                    return this.hasAttribute('selected') ? 'YES' : 'NO';
                },

                'set': function (newValue) {
                    if (newValue === true || newValue === 'true' || newValue === 'YES') {
                        this.setAttribute('selected', '');
                    } else {
                        this.removeAttribute('selected');
                    }
                }
            }
        },
        methods: {

        }
    });
});
window.addEventListener('design-register-element', function () {
    'use strict';

    //registerDesignSnippet('<gs-checkbox>', '<gs-checkbox>', 'gs-checkbox value="0" column="${1:ready_to_ship}">${2}</gs-checkbox>');

    designRegisterElement('gs-tutorial', '/env/app/developer_g/greyspots-' + GS.version() + '/documentation/doc-elem-tutorial.html');

    window.designElementProperty_GSTUTORIAL = function (selectedElement) {
        addProp('suspend-inserted', true, '<gs-checkbox class="target" value="' + (selectedElement.hasAttribute('suspend-inserted') || '') + '" mini></gs-checkbox>', function () {
            return setOrRemoveBooleanAttribute(selectedElement, 'suspend-inserted', this.value === 'true', true);
        });
    };
});

document.addEventListener('DOMContentLoaded', function () {
    'use strict';

    function closeCurrentPopup(element) {
        var popupElement = element.currentPopup;

        // run before-close code if there is any
        if (popupElement.strBeforeClose) {
            new Function(popupElement.strBeforeClose).apply(element);
        }

        // remove overlay if there is one
        if (popupElement.relatedOverlay) {
            document.body.removeChild(popupElement.relatedOverlay);
        }

        // remove popup element
        document.body.removeChild(popupElement);
    }

    function openPopup(element, templateElement, intTemplateNumber, intNumberOfTemplates) {
        var strTargetSelector = (templateElement.getAttribute('target') || '')
          , strDirectionRequest = (templateElement.getAttribute('direction') || 'down')
          , intMaxWidthAttribute = parseInt((templateElement.getAttribute('max-width') || '9999999'), 10)
          , strBeforeOpen = templateElement.getAttribute('before-open')
          , strBeforeClose = templateElement.getAttribute('before-close')
          , strHTML, arrElements, elementTarget, arrTests, popupElement, overlayElement, arrowElement
          , positionHandlingFunction, buttonElement, i, len;

        // make the template a copy so that we can alter it safely
        templateElement = templateElement.cloneNode(true);

        // run before-open code if there is any
        if (strBeforeOpen) {
            new Function(strBeforeOpen).apply(element);
        }

        // get html from template
        strHTML = (templateElement.innerHTML || '');

        // add next, previous and skip buttons

        // if first and only
        if (intTemplateNumber === 1 && intNumberOfTemplates === 1) {
            strHTML += ml(function () {/*
                            <div class="popup-control-bar">
                                <gs-button class="button-close" inline icononly icon="times"></gs-button>
                            </div>
                        */});
        // if first
        } else if (intTemplateNumber === 1 && intNumberOfTemplates > 1) {
            strHTML += ml(function () {/*
                            <div class="popup-control-bar">
                                <gs-button class="button-right" inline icononly icon="arrow-right" remove-left></gs-button>
                                <gs-button class="button-close" inline icononly icon="times" remove-right></gs-button>
                            </div>
                        */});
        // if middle
        } else if (intTemplateNumber > 1 && intNumberOfTemplates > intTemplateNumber) {
            strHTML += ml(function () {/*
                            <div class="popup-control-bar">
                                <gs-button class="button-right" inline icononly icon="arrow-right" remove-left></gs-button>
                                <gs-button class="button-close" inline icononly icon="times" remove-all></gs-button>
                                <gs-button class="button-left" inline icononly icon="arrow-left" remove-right></gs-button>
                            </div>
                        */});
        // if last
        } else { //if (intNumberOfTemplates === intTemplateNumber) {
            strHTML += ml(function () {/*
                            <div class="popup-control-bar">
                                <gs-button class="button-close" inline icononly icon="times" remove-left></gs-button>
                                <gs-button class="button-left" inline icononly icon="arrow-left" remove-right></gs-button>
                            </div>
                        */});
        }

        // if a selector was provided: get the instruction target
        if (strTargetSelector) {
            try {
                arrElements = xtag.toArray(document.querySelectorAll(strTargetSelector));
            } catch (e) {}

            arrElements = arrElements || [];

            if (arrElements.length > 1) {
                console.warn('gs-tutorial Warning: More than one element matched with selector \'' + strTargetSelector + '\'.');
            }

            if (arrElements.length === 0) {
                console.warn('gs-tutorial Warning: No elements matched with selector \'' + strTargetSelector + '\'.');

            } else {
                elementTarget = arrElements[0];
            }
        }

        // make strDirectionRequest lowercase
        strDirectionRequest.toLowerCase();

        // if the direction does not match any valid direction: set direction to down and warn
        if (!strDirectionRequest.match(/^up$|^down$|^left$|^right$/)) {
            console.warn('gs-tutorial Warning: ' +
                                'Direction \'' + strDirectionRequest + '\' not recognized. ' +
                                'Please use \'up\', \'down\', \'left\', \'right\'. Defaulting to \'down\'.');
            strDirectionRequest = 'down';
        }

        // order of tests depending direction request
        if (strDirectionRequest === 'up') { // up: up, down, left, right, full
            arrTests = ['up', 'down', 'left', 'right'];

        } else if (strDirectionRequest === 'down') { // down: down, up, left, right, full
            arrTests = ['down', 'up', 'left', 'right'];

        } else if (strDirectionRequest === 'left') { // left: left, right, down, up, full
            arrTests = ['left', 'right', 'down', 'up'];

        } else if (strDirectionRequest === 'right') { // right: right, left, down, up, full
            arrTests = ['right', 'left', 'down', 'up'];
        }

        // create popup, overlay and arrow
        popupElement = document.createElement('gs-tutorial-popup');

        overlayElement = document.createElement('gs-tutorial-overlay');

        arrowElement = document.createElement('div');
        arrowElement.classList.add('connection-arrow');

        // append overlay then the popup so that they can have the same z-index and the popup will be over the overlay
        //      the reason why all of the overlays and all of the popups need the same z-index is because say for example
        //      the overlays had a z-index of '1' and the popups had a z-index of '2' if we had two popups open and the
        //      first one was bigger than the second one than you would be able to see the first popup without an overlay
        //      in from of it and potentially you would be able to interact with the first popup without dealing with the
        //      second popup.
        document.body.appendChild(overlayElement);
        document.body.appendChild(popupElement);

        // link the popup to it's overlay so that when we close the popup we can also remove the popup overlay
        popupElement.relatedOverlay = overlayElement;

        // link the popup to it's before-close so that before we close the popup we can run any code inside the before-close
        popupElement.strBeforeClose = strBeforeClose;

        // fill popup
        popupElement.innerHTML = strHTML;
        popupElement.appendChild(arrowElement);

        // bind next, previous and skip buttons
        buttonElement = xtag.query(popupElement, '.popup-control-bar > .button-left')[0];
        if (buttonElement) {
            buttonElement.addEventListener('click', function () {
                element.backward();
            });
        }

        buttonElement = xtag.query(popupElement, '.popup-control-bar > .button-close')[0];
        if (buttonElement) {
            buttonElement.addEventListener('click', function () {
                element.end();
            });
        }

        buttonElement = xtag.query(popupElement, '.popup-control-bar > .button-right')[0];
        if (buttonElement) {
            buttonElement.addEventListener('click', function () {
                element.forward();
            });
        }

        // bind the overlay
        overlayElement.addEventListener('click', function () {
            element.forward();
        });

        // create a positioning function: this is so that we can refresh the popup's position from several different events
        positionHandlingFunction = function () {
            var intTemp, intMaxWidth, intMaxHeight, intResolvedWidth, intResolvedHeight
              , jsnPositionData, strResolvedDirection, intPopupMidPoint, intElementMidPoint
              , intMargin = 10, intArrow = 5, intPopupTop, intPopupLeft, intArrowLeft, intArrowTop;

            // if the dialog is not in the DOM: unbind and skip the contents of the function using return
            if (popupElement.parentNode !== document.body) {
                window.removeEventListener('resize', positionHandlingFunction);
                window.removeEventListener('orientationchange', positionHandlingFunction);
                return;
            }

            // save scroll numbers
            popupElement.oldScrollTop = popupElement.scrollTop;
            popupElement.oldScrollLeft = popupElement.scrollLeft;

            // clear arrow direction
            popupElement.classList.remove('up');
            popupElement.classList.remove('down');
            popupElement.classList.remove('left');
            popupElement.classList.remove('right');

            // clear popup and arrow css
            popupElement.setAttribute('style', '');
            arrowElement.setAttribute('style', '');

            // find the closest balance of width and height (using the window width as a max width)
            if ((popupElement.offsetHeight + popupElement.offsetWidth) < 300) {
                intTemp = 300;
            } else {
                intTemp = ((popupElement.offsetHeight + popupElement.offsetWidth) / 2);
            }
            intMaxWidth = (intTemp < window.innerWidth ? intTemp : window.innerWidth - (intMargin * 2));

            if (intMaxWidth > intMaxWidthAttribute) {
                intMaxWidth = intMaxWidthAttribute;
            }

            // find the maximum height (must be less than half on touch devices and less than a third on everything else)
            if (evt.touchDevice) {
                intMaxHeight = Math.floor(window.innerHeight / 2) - (intMargin * 2);

            } else {
                intMaxHeight = Math.floor(window.innerHeight / 3) - (intMargin * 2);
            }

            // apply calculated max dimensions
            popupElement.style.maxWidth = intMaxWidth + 'px';
            popupElement.style.maxHeight = intMaxHeight + 'px';

            // get resolved dimensions
            intResolvedWidth = popupElement.offsetWidth;
            intResolvedHeight = popupElement.offsetHeight;

            // if there is a target: run through tests
            if (elementTarget) {
                // get target position data
                jsnPositionData = GS.getElementPositionData(elementTarget);

                //console.log(intResolvedHeight,
                //            intResolvedWidth,
                //            jsnPositionData.intRoomAbove,
                //            jsnPositionData.intRoomBelow,
                //            jsnPositionData.intRoomLeft,
                //            jsnPositionData.intRoomRight);

                // up: compare room above to popup resolved height
                //      pass: display
                //      fail: next test
                for (i = 0, len = arrTests.length; i < len; i += 1) {
                    if ((arrTests[i] ===    'up' && (intResolvedHeight + intMargin + intArrow) <= jsnPositionData.intRoomAbove) ||
                        (arrTests[i] ===  'down' && (intResolvedHeight + intMargin + intArrow) <= jsnPositionData.intRoomBelow) ||
                        (arrTests[i] ===  'left' && ( intResolvedWidth + intMargin + intArrow) <= jsnPositionData.intRoomLeft) ||
                        (arrTests[i] === 'right' && ( intResolvedWidth + intMargin + intArrow) <= jsnPositionData.intRoomRight)) {
                        strResolvedDirection = arrTests[i];
                        break;
                    }
                }

                // if we could not resolve to a particular direction: position in the middle
                strResolvedDirection = strResolvedDirection || 'middle';

            // else: center on screen
            } else {
                strResolvedDirection = 'middle';
            }

            //console.log(strDirectionRequest, strResolvedDirection);

            // if up or down: get as close to horizontally centered on the element as possible
            if (strResolvedDirection === 'up' || strResolvedDirection === 'down') {
                intElementMidPoint = (jsnPositionData.intElementLeft + (jsnPositionData.intElementWidth / 2));
                intPopupMidPoint = (intResolvedWidth / 2);
                //console.log(intElementMidPoint, jsnPositionData.left, jsnPositionData.intElementWidth);

                // if centered goes past intMargin of the left edge of the screen: go to intMargin from the bottom
                if (intElementMidPoint - intPopupMidPoint < intMargin) {
                    intPopupLeft = intMargin;

                    //console.log('1***', intMargin);

                // else if centered goes past intMargin of the right edge of the screen: go to intMargin less than the width of the viewport
                } else if (intElementMidPoint + intPopupMidPoint > window.innerWidth - intMargin) {
                    intPopupLeft = ((window.innerWidth - intResolvedWidth) - intMargin);
                    //console.log('2***', window.innerWidth, intResolvedWidth, intMargin);

                // else centered does not go past intMargin of either edge of the screen: center
                } else {
                    intPopupLeft = (intElementMidPoint - intPopupMidPoint);
                    //console.log('3***', intElementMidPoint, intPopupMidPoint, (intElementMidPoint - intPopupMidPoint) + 'px');
                }

                // move the arrow to be pointing at the midopoint of the target
                intArrowLeft = (intElementMidPoint - intPopupLeft);

                // if the midpoint of the target is really close the left of the screen: add extreme-left class to the popup
                //console.log(intElementMidPoint, intMargin, intArrow);
                if (intElementMidPoint <= (intMargin + Math.round(intArrow / 2) + 5)) {
                    popupElement.classList.add('extreme-left');
                }

                // if the midpoint of the target is really close the right of the screen: add extreme-right class to the popup
                //console.log(intElementMidPoint, window.innerWidth, intMargin, Math.round(intArrow / 2));
                if (intElementMidPoint >= (((window.innerWidth - intMargin) - Math.round(intArrow / 2)) - 5)) {
                    popupElement.classList.add('extreme-right');
                }

            // else if left or right: get as close to vertically centered next to the element as possible
            } else if (strResolvedDirection === 'left' || strResolvedDirection === 'right') {
                intElementMidPoint = (jsnPositionData.intElementTop + (jsnPositionData.intElementHeight / 2));
                intPopupMidPoint = (intResolvedHeight / 2);

                //console.log('0***', intElementMidPoint, intPopupMidPoint, window.innerHeight, intMargin, intDialogResolvedHeight);

                // if centered goes past intMargin of the top edge of the screen: go to intMargin from the bottom
                if (intElementMidPoint - intPopupMidPoint < intMargin) {
                    intPopupTop = intMargin;
                    //console.log('1***', intMargin);

                // else if centered goes past intMargin of the bottom edge of the screen: go to intMargin less than the height of the viewport
                } else if (intElementMidPoint + intPopupMidPoint > window.innerHeight - intMargin) {
                    intPopupTop = ((window.innerHeight - intResolvedHeight) - intMargin);
                    //console.log('2***', window.innerHeight, intResolvedHeight, intMargin);

                // else centered does not go past intMargin of either edge of the screen: center
                } else {
                    intPopupTop = (intElementMidPoint - intPopupMidPoint);
                    //console.log('3***', intElementMidPoint, intPopupMidPoint, (intElementMidPoint - intPopupMidPoint) + 'px');
                }

                intArrowTop = (intElementMidPoint - intPopupTop);

                // if the midpoint of the target is really close the left of the screen: add extreme-left class to the popup
                if (intElementMidPoint <= (intMargin + Math.round(intArrow / 2) + 5)) {
                    popupElement.classList.add('extreme-up');
                }

                // if the midpoint of the target is really close the right of the screen: add extreme-right class to the popup
                if (intElementMidPoint >= (((window.innerHeight - intMargin) - Math.round(intArrow / 2)) - 5)) {
                    popupElement.classList.add('extreme-down');
                }

            // else full: use dialog logic to get width and height and center both vertically and horizontally
            } else {
                intPopupTop = (window.innerHeight / 2) - (intResolvedHeight / 2);
                intPopupLeft = (window.innerWidth / 2) - (intResolvedWidth / 2);
            }

            // if direction is up: connect the bottom of the dialog to the top of the element
            if (strResolvedDirection === 'up') {
                intPopupTop = (jsnPositionData.intElementTop - intResolvedHeight) - intArrow;

            // if direction is down: connect the top of the dialog to the bottom of the element
            } else if (strResolvedDirection === 'down') {
                intPopupTop = (jsnPositionData.intElementTop + jsnPositionData.intElementHeight) + intArrow;

            // if direction is left: connect the right of the dialog to the left of the element
            } else if (strResolvedDirection === 'left') {
                intPopupLeft = (jsnPositionData.intElementLeft - intResolvedWidth) - intArrow;

            // if direction is right: connect the left of the dialog to the right of the element
            } else if (strResolvedDirection === 'right') {
                intPopupLeft = (jsnPositionData.intElementLeft + jsnPositionData.intElementWidth) + intArrow;
            }

            // prevent the dialog from vertically going outside the viewport
            if (intPopupTop + intResolvedWidth > window.innerHeight) {
                intPopupTop -= (intPopupTop + intResolvedWidth) - window.innerHeight;
            }

            // prevent the dialog from horizontally going outside the viewport
            if (intPopupLeft + intResolvedWidth > window.innerWidth) {
                intPopupLeft -= (intPopupLeft + intResolvedWidth) - window.innerWidth;
            }

            // apply CSS to the popup
            //console.log(intPopupTop, intPopupLeft);
            popupElement.style.top  = intPopupTop + 'px';
            popupElement.style.left = intPopupLeft + 'px';

            // handle arrow
            if (strResolvedDirection !== 'middle') {
                popupElement.classList.add(strResolvedDirection);

                // apply CSS to the arrow
                if (intArrowLeft) {
                    arrowElement.style.left = intArrowLeft + 'px';
                }
                if (intArrowTop) {
                    arrowElement.style.top = intArrowTop + 'px';
                }
            }
        };

        // run position handling function and bind to run it every window resize or re-orientation
        positionHandlingFunction();
        window.addEventListener('resize', positionHandlingFunction);
        window.addEventListener('orientationchange', positionHandlingFunction);

        element.currentPopup = popupElement;
    }


    // this runs code on the first inserted lifecycle call
    function elementInserted(element) {

        // if "created" hasn't been suspended and "inserted" hasn't been suspended: run inserted code
        if (!element.hasAttribute('suspend-created') && !element.hasAttribute('suspend-inserted')) {
            // if this is the first time inserted has been run: continue
            if (!element.inserted) {
                element.inserted = true;

            }
        }
    }

    xtag.register('gs-tutorial', {
        lifecycle: {
            inserted: function () {
                elementInserted(this);
            },

            attributeChanged: function (strAttrName, oldValue, newValue) {
                // if "suspend-inserted" or "suspend-created" has been removed: run inserted code
                if ((strAttrName === 'suspend-created' || strAttrName === 'suspend-created') && newValue === null) {
                    elementInserted(this);

                } else if (!this.hasAttribute('suspend-created') && !this.hasAttribute('suspend-inserted')) {
                    // attribute code
                }
            }
        },
        events: {},
        accessors: {},
        methods: {
            'start': function () {
                var strBeforeStart = this.getAttribute('before-start'),
                    arrElement = xtag.queryChildren(this, 'template');

                // if there are no templates: warning
                if (arrElement.length === 0) {
                    console.warn('gs-tutorial Warning: No popup templates provided.' +
                                    ' Please consult the documention if you need info on how to use the gs-tutorial element.');

                // if there are non-template children: warning
                } else if (this.children.length !== arrElement.length) {
                    console.warn('gs-tutorial Warning: Invalid element' + ((this.children.length - arrElement.length) === 1 ? '' : 's') + '.' +
                                    ' The gs-tutorial element only accepts template elements for it\'s children.');
                }

                // read first template
                this.currentIndex = 0;
                if (arrElement[this.currentIndex]) {
                    if (strBeforeStart) {
                        new Function(strBeforeStart).apply(this);
                    }

                    openPopup(this, arrElement[this.currentIndex], (this.currentIndex + 1), arrElement.length);
                }
            },

            'end': function () {
                var strBeforeEnd = this.getAttribute('before-end');

                if (strBeforeEnd) {
                    new Function(strBeforeEnd).apply(this);
                }

                if (this.currentPopup) {
                    closeCurrentPopup(this);
                }
            },

            'forward': function () {
                var arrElement = xtag.queryChildren(this, 'template');

                this.currentIndex += 1;
                if (arrElement[this.currentIndex]) {
                    if (this.currentPopup) {
                        closeCurrentPopup(this);
                    }

                    openPopup(this, arrElement[this.currentIndex], (this.currentIndex + 1), arrElement.length);
                } else {
                    this.end();
                }
            },

            'backward': function () {
                var arrElement = xtag.queryChildren(this, 'template');

                if (this.currentPopup) {
                    closeCurrentPopup(this);
                }

                this.currentIndex -= 1;
                if (arrElement[this.currentIndex]) {
                    if (this.currentPopup) {
                        closeCurrentPopup(this);
                    }

                    openPopup(this, arrElement[this.currentIndex], (this.currentIndex + 1), arrElement.length);
                }
            },

            'reposition': function () {

            }
        }
    });
});
